(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.1
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER

exports.glMatrix = require("./gl-matrix/common.js");
exports.mat2 = require("./gl-matrix/mat2.js");
exports.mat2d = require("./gl-matrix/mat2d.js");
exports.mat3 = require("./gl-matrix/mat3.js");
exports.mat4 = require("./gl-matrix/mat4.js");
exports.quat = require("./gl-matrix/quat.js");
exports.vec2 = require("./gl-matrix/vec2.js");
exports.vec3 = require("./gl-matrix/vec3.js");
exports.vec4 = require("./gl-matrix/vec4.js");
},{"./gl-matrix/common.js":2,"./gl-matrix/mat2.js":3,"./gl-matrix/mat2d.js":4,"./gl-matrix/mat3.js":5,"./gl-matrix/mat4.js":6,"./gl-matrix/quat.js":7,"./gl-matrix/vec2.js":8,"./gl-matrix/vec3.js":9,"./gl-matrix/vec4.js":10}],2:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

// Constants
glMatrix.EPSILON = 0.000001;
glMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
glMatrix.RANDOM = Math.random;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    GLMAT_ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}

module.exports = glMatrix;

},{}],3:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2x2 Matrix
 * @name mat2
 */
var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.fromRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
mat2.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 


module.exports = mat2;

},{"./common.js":2}],4:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */
var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
mat2d.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
mat2d.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

module.exports = mat2d;

},{"./common.js":2}],5:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 3x3 Matrix
 * @name mat3
 */
var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
mat3.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);

    out[0] = c;
    out[1] = s;
    out[2] = 0;

    out[3] = -s;
    out[4] = c;
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
mat3.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;

    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};


module.exports = mat3;

},{"./common.js":2}],6:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 4x4 Matrix
 * @name mat4
 */
var mat4 = {};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
mat4.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.fromRotation = function(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t;
    
    if (Math.abs(len) < glMatrix.EPSILON) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    
    // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromXRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    
    // Perform axis-specific matrix multiplication
    out[0]  = 1;
    out[1]  = 0;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromYRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    
    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = 0;
    out[2]  = -s;
    out[3]  = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromZRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    
    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = s;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScale = function (out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2,
        sx = s[0],
        sy = s[1],
        sz = s[2];

    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {
  // Quaternion math
  var x = q[0], y = q[1], z = q[2], w = q[3],
      x2 = x + x,
      y2 = y + y,
      z2 = z + z,

      xx = x * x2,
      xy = x * y2,
      xz = x * z2,
      yy = y * y2,
      yz = y * z2,
      zz = z * z2,
      wx = w * x2,
      wy = w * y2,
      wz = w * z2,
      
      sx = s[0],
      sy = s[1],
      sz = s[2],

      ox = o[0],
      oy = o[1],
      oz = o[2];
      
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;
        
  return out;
};

mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspectiveFromFieldOfView = function (out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&
        Math.abs(eyey - centery) < glMatrix.EPSILON &&
        Math.abs(eyez - centerz) < glMatrix.EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};


module.exports = mat4;

},{"./common.js":2}],7:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");
var mat3 = require("./mat3.js");
var vec3 = require("./vec3.js");
var vec4 = require("./vec4.js");

/**
 * @class Quaternion
 * @name quat
 */
var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
quat.sqlerp = (function () {
  var temp1 = quat.create();
  var temp2 = quat.create();
  
  return function (out, a, b, c, d, t) {
    quat.slerp(temp1, a, d, t);
    quat.slerp(temp2, b, c, t);
    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));
    
    return out;
  };
}());

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[5]-m[7])*fRoot;
        out[1] = (m[6]-m[2])*fRoot;
        out[2] = (m[1]-m[3])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

module.exports = quat;

},{"./common.js":2,"./mat3.js":5,"./vec3.js":9,"./vec4.js":10}],8:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */
var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
vec2.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

module.exports = vec2;

},{"./common.js":2}],9:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */
var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
vec3.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.hermite = function (out, a, b, c, d, t) {
  var factorTimes2 = t * t,
      factor1 = factorTimes2 * (2 * t - 3) + 1,
      factor2 = factorTimes2 * (t - 2) + t,
      factor3 = factorTimes2 * (t - 1),
      factor4 = factorTimes2 * (3 - 2 * t);
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.bezier = function (out, a, b, c, d, t) {
  var inverseFactor = 1 - t,
      inverseFactorTimesTwo = inverseFactor * inverseFactor,
      factorTimes2 = t * t,
      factor1 = inverseFactorTimesTwo * inverseFactor,
      factor2 = 3 * t * inverseFactorTimesTwo,
      factor3 = 3 * factorTimes2 * inverseFactor,
      factor4 = factorTimes2 * t;
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    var z = (glMatrix.RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
vec3.angle = function(a, b) {
   
    var tempA = vec3.fromValues(a[0], a[1], a[2]);
    var tempB = vec3.fromValues(b[0], b[1], b[2]);
 
    vec3.normalize(tempA, tempA);
    vec3.normalize(tempB, tempB);
 
    var cosine = vec3.dot(tempA, tempB);

    if(cosine > 1.0){
        return 0;
    } else {
        return Math.acos(cosine);
    }     
};

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

module.exports = vec3;

},{"./common.js":2}],10:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */
var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
vec4.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = x * len;
        out[1] = y * len;
        out[2] = z * len;
        out[3] = w * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = glMatrix.RANDOM();
    out[1] = glMatrix.RANDOM();
    out[2] = glMatrix.RANDOM();
    out[3] = glMatrix.RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

module.exports = vec4;

},{"./common.js":2}],11:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && !isFinite(value)) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) {
    return a === b;
  }
  var aIsArgs = isArguments(a),
      bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  var ka = objectKeys(a),
      kb = objectKeys(b),
      key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":16}],12:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],13:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],14:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],15:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],16:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":15,"_process":14,"inherits":13}],17:[function(require,module,exports){
/**
 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseAssign = require('lodash._baseassign'),
    createAssigner = require('lodash._createassigner'),
    keys = require('lodash.keys');

/**
 * A specialized version of `_.assign` for customizing assigned values without
 * support for argument juggling, multiple sources, and `this` binding `customizer`
 * functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 */
function assignWith(object, source, customizer) {
  var index = -1,
      props = keys(source),
      length = props.length;

  while (++index < length) {
    var key = props[index],
        value = object[key],
        result = customizer(value, source[key], key, object, source);

    if ((result === result ? (result !== value) : (value === value)) ||
        (value === undefined && !(key in object))) {
      object[key] = result;
    }
  }
  return object;
}

/**
 * Assigns own enumerable properties of source object(s) to the destination
 * object. Subsequent sources overwrite property assignments of previous sources.
 * If `customizer` is provided it is invoked to produce the assigned values.
 * The `customizer` is bound to `thisArg` and invoked with five arguments:
 * (objectValue, sourceValue, key, object, source).
 *
 * **Note:** This method mutates `object` and is based on
 * [`Object.assign`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign).
 *
 * @static
 * @memberOf _
 * @alias extend
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {*} [thisArg] The `this` binding of `customizer`.
 * @returns {Object} Returns `object`.
 * @example
 *
 * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
 * // => { 'user': 'fred', 'age': 40 }
 *
 * // using a customizer callback
 * var defaults = _.partialRight(_.assign, function(value, other) {
 *   return _.isUndefined(value) ? other : value;
 * });
 *
 * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
 * // => { 'user': 'barney', 'age': 36 }
 */
var assign = createAssigner(function(object, source, customizer) {
  return customizer
    ? assignWith(object, source, customizer)
    : baseAssign(object, source);
});

module.exports = assign;

},{"lodash._baseassign":18,"lodash._createassigner":24,"lodash.keys":28}],18:[function(require,module,exports){
/**
 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseCopy = require('lodash._basecopy'),
    keys = require('lodash.keys');

/**
 * The base implementation of `_.assign` without support for argument juggling,
 * multiple sources, and `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return source == null
    ? object
    : baseCopy(source, keys(source), object);
}

module.exports = baseAssign;

},{"lodash._basecopy":19,"lodash.keys":20}],19:[function(require,module,exports){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property names to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @returns {Object} Returns `object`.
 */
function baseCopy(source, props, object) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    object[key] = source[key];
  }
  return object;
}

module.exports = baseCopy;

},{}],20:[function(require,module,exports){
/**
 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var getNative = require('lodash._getnative'),
    isArguments = require('lodash.isarguments'),
    isArray = require('lodash.isarray');

/** Used to detect unsigned integer values. */
var reIsUint = /^\d+$/;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeKeys = getNative(Object, 'keys');

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * A fallback implementation of `Object.keys` which creates an array of the
 * own enumerable property names of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function shimKeys(object) {
  var props = keysIn(object),
      propsLength = props.length,
      length = propsLength && object.length;

  var allowIndexes = !!length && isLength(length) &&
    (isArray(object) || isArguments(object));

  var index = -1,
      result = [];

  while (++index < propsLength) {
    var key = props[index];
    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
var keys = !nativeKeys ? shimKeys : function(object) {
  var Ctor = object == null ? undefined : object.constructor;
  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
      (typeof object != 'function' && isArrayLike(object))) {
    return shimKeys(object);
  }
  return isObject(object) ? nativeKeys(object) : [];
};

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  if (object == null) {
    return [];
  }
  if (!isObject(object)) {
    object = Object(object);
  }
  var length = object.length;
  length = (length && isLength(length) &&
    (isArray(object) || isArguments(object)) && length) || 0;

  var Ctor = object.constructor,
      index = -1,
      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
      result = Array(length),
      skipIndexes = length > 0;

  while (++index < length) {
    result[index] = (index + '');
  }
  for (var key in object) {
    if (!(skipIndexes && isIndex(key, length)) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keys;

},{"lodash._getnative":21,"lodash.isarguments":22,"lodash.isarray":23}],21:[function(require,module,exports){
/**
 * lodash 3.9.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = getNative;

},{}],22:[function(require,module,exports){
/**
 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Native method references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as an `arguments` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  return isObjectLike(value) && isArrayLike(value) &&
    hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
}

module.exports = isArguments;

},{}],23:[function(require,module,exports){
/**
 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var arrayTag = '[object Array]',
    funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/* Native method references for those with the same name as other `lodash` methods. */
var nativeIsArray = getNative(Array, 'isArray');

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(function() { return arguments; }());
 * // => false
 */
var isArray = nativeIsArray || function(value) {
  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
};

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = isArray;

},{}],24:[function(require,module,exports){
/**
 * lodash 3.1.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var bindCallback = require('lodash._bindcallback'),
    isIterateeCall = require('lodash._isiterateecall'),
    restParam = require('lodash.restparam');

/**
 * Creates a function that assigns properties of source object(s) to a given
 * destination object.
 *
 * **Note:** This function is used to create `_.assign`, `_.defaults`, and `_.merge`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return restParam(function(object, sources) {
    var index = -1,
        length = object == null ? 0 : sources.length,
        customizer = length > 2 ? sources[length - 2] : undefined,
        guard = length > 2 ? sources[2] : undefined,
        thisArg = length > 1 ? sources[length - 1] : undefined;

    if (typeof customizer == 'function') {
      customizer = bindCallback(customizer, thisArg, 5);
      length -= 2;
    } else {
      customizer = typeof thisArg == 'function' ? thisArg : undefined;
      length -= (customizer ? 1 : 0);
    }
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"lodash._bindcallback":25,"lodash._isiterateecall":26,"lodash.restparam":27}],25:[function(require,module,exports){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * A specialized version of `baseCallback` which only supports `this` binding
 * and specifying the number of arguments to provide to `func`.
 *
 * @private
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function bindCallback(func, thisArg, argCount) {
  if (typeof func != 'function') {
    return identity;
  }
  if (thisArg === undefined) {
    return func;
  }
  switch (argCount) {
    case 1: return function(value) {
      return func.call(thisArg, value);
    };
    case 3: return function(value, index, collection) {
      return func.call(thisArg, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(thisArg, accumulator, value, index, collection);
    };
    case 5: return function(value, other, key, object, source) {
      return func.call(thisArg, value, other, key, object, source);
    };
  }
  return function() {
    return func.apply(thisArg, arguments);
  };
}

/**
 * This method returns the first argument provided to it.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = bindCallback;

},{}],26:[function(require,module,exports){
/**
 * lodash 3.0.9 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used to detect unsigned integer values. */
var reIsUint = /^\d+$/;

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if the provided arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
      ? (isArrayLike(object) && isIndex(index, object.length))
      : (type == 'string' && index in object)) {
    var other = object[index];
    return value === value ? (value === other) : (other !== other);
  }
  return false;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = isIterateeCall;

},{}],27:[function(require,module,exports){
/**
 * lodash 3.6.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as an array.
 *
 * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
 *
 * @static
 * @memberOf _
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.restParam(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function restParam(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        rest = Array(length);

    while (++index < length) {
      rest[index] = args[start + index];
    }
    switch (start) {
      case 0: return func.call(this, rest);
      case 1: return func.call(this, args[0], rest);
      case 2: return func.call(this, args[0], args[1], rest);
    }
    var otherArgs = Array(start + 1);
    index = -1;
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = rest;
    return func.apply(this, otherArgs);
  };
}

module.exports = restParam;

},{}],28:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20,"lodash._getnative":29,"lodash.isarguments":30,"lodash.isarray":31}],29:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],30:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],31:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],32:[function(require,module,exports){
/**
 * lodash 3.1.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseAssign = require('lodash._baseassign'),
    baseCreate = require('lodash._basecreate'),
    isIterateeCall = require('lodash._isiterateecall');

/**
 * Creates an object that inherits from the given `prototype` object. If a
 * `properties` object is provided its own enumerable properties are assigned
 * to the created object.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} prototype The object to inherit from.
 * @param {Object} [properties] The properties to assign to the object.
 * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
 * @returns {Object} Returns the new object.
 * @example
 *
 * function Shape() {
 *   this.x = 0;
 *   this.y = 0;
 * }
 *
 * function Circle() {
 *   Shape.call(this);
 * }
 *
 * Circle.prototype = _.create(Shape.prototype, {
 *   'constructor': Circle
 * });
 *
 * var circle = new Circle;
 * circle instanceof Circle;
 * // => true
 *
 * circle instanceof Shape;
 * // => true
 */
function create(prototype, properties, guard) {
  var result = baseCreate(prototype);
  if (guard && isIterateeCall(prototype, properties, guard)) {
    properties = undefined;
  }
  return properties ? baseAssign(result, properties) : result;
}

module.exports = create;

},{"lodash._baseassign":33,"lodash._basecreate":39,"lodash._isiterateecall":40}],33:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18,"lodash._basecopy":34,"lodash.keys":35}],34:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],35:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20,"lodash._getnative":36,"lodash.isarguments":37,"lodash.isarray":38}],36:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],37:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],38:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],39:[function(require,module,exports){
/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(prototype) {
    if (isObject(prototype)) {
      object.prototype = prototype;
      var result = new object;
      object.prototype = undefined;
    }
    return result || {};
  };
}());

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = baseCreate;

},{}],40:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],41:[function(require,module,exports){
/**
 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var assign = require('lodash.assign'),
    restParam = require('lodash.restparam');

/**
 * Used by `_.defaults` to customize its `_.assign` use.
 *
 * @private
 * @param {*} objectValue The destination object property value.
 * @param {*} sourceValue The source object property value.
 * @returns {*} Returns the value to assign to the destination object.
 */
function assignDefaults(objectValue, sourceValue) {
  return objectValue === undefined ? sourceValue : objectValue;
}

/**
 * Creates a `_.defaults` or `_.defaultsDeep` function.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Function} Returns the new defaults function.
 */
function createDefaults(assigner, customizer) {
  return restParam(function(args) {
    var object = args[0];
    if (object == null) {
      return object;
    }
    args.push(customizer);
    return assigner.apply(undefined, args);
  });
}

/**
 * Assigns own enumerable properties of source object(s) to the destination
 * object for all destination properties that resolve to `undefined`. Once a
 * property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
 * // => { 'user': 'barney', 'age': 36 }
 */
var defaults = createDefaults(assign, assignDefaults);

module.exports = defaults;

},{"lodash.assign":17,"lodash.restparam":42}],42:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],43:[function(require,module,exports){
module.exports = require( './lib/' );

},{"./lib/":44}],44:[function(require,module,exports){
module.exports = function () {

    var now = require("performance-now");

    function find(arr, predicate) {
            if (arr == null) {
                throw new TypeError('Array.prototype.find called on null or undefined');
            }
            if (typeof predicate !== 'function') {
                throw new TypeError('predicate must be a function');
            }
            var list = Object(arr);
            var length = list.length >>> 0;
            var value;

            for (var i = 0; i < length; i++) {
                value = list[i];
                if (predicate.call(null, value, i, list)) {
                    return value;
                }
            }
            return undefined;
    };

    var SimpleTextureManager = function (opt) {
        opt = opt || {};
        this._units = [];
        for (var i = 0; i < (opt.units || 8); i++) {
            this._units[i] = {slot: i, use: 0};
        }
    };

    SimpleTextureManager.NOT_FOUND = -1;
    SimpleTextureManager.FULL = -2;

    SimpleTextureManager.prototype = {

        _set: function (slot, newEntry) {
            var oldEntry = this._units[slot];
            if (oldEntry.dispose) {
                oldEntry.dispose(oldEntry, this);
            }
            if (newEntry) {
                this._units[slot] = newEntry;
                this._units[slot].slot = slot;
            } else {
                this._units[slot] = {slot: slot, use: 0};
            }
        },

        bind: function (id, opt) {
            opt = opt || {};
            var fixed = !!opt.fixed;
            var dispose = typeof opt.dispose == "function" ? opt.dispose : null;

            // Check if texture is already bound
            var result = this.get(id);
            if (result !== SimpleTextureManager.NOT_FOUND) {
                return result;
            }

            var candidates = this._units.filter(function (unit) {
                return !unit.fixed;
            });
            //console.log("Candidates,", candidates, candidates.length);

            if (!candidates.length) {
                return SimpleTextureManager.FULL;
            }

            var selected = candidates.reduce(function (prev, curr) {
                return prev ? (curr.use < prev.use ? curr : prev) : curr;
            }, null);
            //console.log("Selected entry", selected);

            var slot = selected.slot;
            this._set(slot, {
                fixed: fixed, use: now(), id: id, dispose: dispose
            });
            return slot;

        },

        dispose: function (id) {
            var entry = this.getEntry(id);
            this._set(entry.slot, null);
        },
        /**
         * Returns if the texture of the given id is bound to an unit
         * @param id
         * @returns {boolean}
         */
        has: function (id) {
            return !!this.getEntry(id);
        },
        /**
         * Returns the current texture unit for the id or SimpleTextureManager.NOT_FOUND
         * if the texture is currently not bound
         * @param id
         * @returns {*}
         */
        get: function (id) {
            var result = this.getEntry(id);
            if(result) {
                result.use = now();
                return result.slot;
            }
            return SimpleTextureManager.NOT_FOUND;
        },

        use: function (id) {
            var result = this.getEntry(id);
            if(result) {
                result.use = now();
            }
        },

        getEntry: function (id) {
            return find(this._units, function (entry) {
                return entry.id === id;
            });
        }

    };


    return {
        SimpleTextureManager: SimpleTextureManager
    };
}();

},{"performance-now":45}],45:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var getNanoSeconds, hrtime, loadTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - loadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    loadTime = getNanoSeconds();
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

}).call(this,require('_process'))

},{"_process":14}],46:[function(require,module,exports){
(function() {
  'use strict';

  if (self.fetch) {
    return
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)

    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var list = this.map[name]
    if (!list) {
      list = []
      this.map[name] = list
    }
    list.push(value)
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    var values = this.map[normalizeName(name)]
    return values ? values[0] : null
  }

  Headers.prototype.getAll = function(name) {
    return this.map[normalizeName(name)] || []
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = [normalizeValue(value)]
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    Object.getOwnPropertyNames(this.map).forEach(function(name) {
      this.map[name].forEach(function(value) {
        callback.call(thisArg, value, name, this)
      }, this)
    }, this)
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    reader.readAsArrayBuffer(blob)
    return fileReaderReady(reader)
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    reader.readAsText(blob)
    return fileReaderReady(reader)
  }

  var support = {
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob();
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  function Body() {
    this.bodyUsed = false


    this._initBody = function(body) {
      this._bodyInit = body
      if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (!body) {
        this._bodyText = ''
      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
        // Only support ArrayBuffers for POST method.
        // Receiving ArrayBuffers happens via Blobs, instead.
      } else {
        throw new Error('unsupported BodyInit type')
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        return this.blob().then(readBlobAsArrayBuffer)
      }

      this.text = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text')
        } else {
          return Promise.resolve(this._bodyText)
        }
      }
    } else {
      this.text = function() {
        var rejected = consumed(this)
        return rejected ? rejected : Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body
    if (Request.prototype.isPrototypeOf(input)) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = input
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this)
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function headers(xhr) {
    var head = new Headers()
    var pairs = xhr.getAllResponseHeaders().trim().split('\n')
    pairs.forEach(function(header) {
      var split = header.trim().split(':')
      var key = split.shift().trim()
      var value = split.join(':').trim()
      head.append(key, value)
    })
    return head
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this._initBody(bodyInit)
    this.type = 'default'
    this.status = options.status
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = options.statusText
    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
    this.url = options.url || ''
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request
      if (Request.prototype.isPrototypeOf(input) && !init) {
        request = input
      } else {
        request = new Request(input, init)
      }

      var xhr = new XMLHttpRequest()

      function responseURL() {
        if ('responseURL' in xhr) {
          return xhr.responseURL
        }

        // Avoid security warnings on getResponseHeader when not allowed by CORS
        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
          return xhr.getResponseHeader('X-Request-URL')
        }

        return;
      }

      xhr.onload = function() {
        var status = (xhr.status === 1223) ? 204 : xhr.status
        if (status < 100 || status > 599) {
          reject(new TypeError('Network request failed'))
          return
        }
        var options = {
          status: status,
          statusText: xhr.statusText,
          headers: headers(xhr),
          url: responseURL()
        }
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})();

},{}],47:[function(require,module,exports){
var Set = require("../xflow/utils/utils.js").set;
var DataNode = require("../xflow/interface/graph.js").DataNode;
var Base = require("../xflow/base.js");

function AssetError(message, node){
    this.message = message;
    this.node = node;
}

var Asset = function(refNode){
    this.name = null;
    this.srcAsset = null;
    this.children = [];
    this.subAssets = [];
    this.pickFilter = null;
    this.parents = [];
    this.listener = [];
    this.loading = false;
    this.refNode = refNode || null;
    this.material = null;
    this.transform = null;

    this.assetResult = null;
    this.loadLevel = 0;
    this.progressLevel = Infinity;
};

Asset.prototype.checkValidity = function(){
    if(this.isSubtreeLoading())
        return;
    checkRecursive(this);
};
function checkRecursive(asset){
    if(asset.srcAsset){
        checkRecursive(asset.srcAsset);
    }
    var localNames = [];
    for(var i = 0; i < asset.children.length; ++i){
        var child = asset.children[i], name = child.name;
        if(name && localNames.indexOf(name) != -1){
            throw new AssetError("Two subdata elements with the same name: '" + name + "'", child.refNode);
        }
        if(name) localNames.push(name);
    }
    for(var i = 0; i < asset.subAssets.length; ++i){
        checkRecursive(asset.subAssets[i]);
    }
}


Asset.prototype.setLoading = function(loading){
    if(loading != this.loading){
        this.loading = loading;
        updateLoadingState(this);
        invalidateAsset(this);

    }
};

Asset.prototype.isSubtreeLoading = function(){
    return this.progressLevel == 0;
};
Asset.prototype.getProgressLevel = function(){
    return this.progressLevel;
};

Asset.prototype.setName = function(name){
    this.name = name;
    invalidateAsset(this);
};

Asset.prototype.setMaterial = function(material){
    this.material = material;
    invalidateAsset(this);
};

Asset.prototype.setTransform = function(transform){
    this.transform = transform;
    if (this.refNode.localName.toLowerCase() !== "model") {
        invalidateAsset(this);
    }
};

Asset.prototype.appendChild = function(child){
    this.children.push(child);
    child.assetParent = this;
    updateLoadingState(this);
    invalidateAsset(this);

};

Asset.prototype.setPickFilter = function(pickFilterString){
    if(typeof pickFilterString == "string"){
        this.pickFilter = new AssetPickFilter();
        this.pickFilter.parse(pickFilterString);
    }
    else
        this.pickFilter = null;
    invalidateAsset(this);
};

Asset.prototype.appendSubAsset = function(subAsset){
    subAsset._addParent(this);
    this.subAssets.push(subAsset);
    updateLoadingState(this);
    invalidateAsset(this);

};

Asset.prototype.setSrcAsset = function(asset){
    if(this.srcAsset)
        this.srcAsset._removeParent(this);

    this.srcAsset = asset;

    if(this.srcAsset)
        this.srcAsset._addParent(this);
    updateLoadingState(this);
    invalidateAsset(this);

};

Asset.prototype.clearChildren = function(){
    var i = this.children.length;
    while(i--) this.children[i].assetParent = null;
    this.children = [];
    updateLoadingState(this);
    invalidateAsset(this);

};
Asset.prototype.clearSubAssets = function(){
    var i = this.subAssets.length;
    while(i--) {
        this.subAssets[i]._removeParent(this);
    }
    this.subAssets.length = 0;
    updateLoadingState(this);
    invalidateAsset(this);

};

Asset.prototype._addParent = function(asset){
    this.parents.push(asset);
};
Asset.prototype._removeParent = function(asset){
    var idx = this.parents.indexOf(asset);
    if(idx != -1)
        this.parents.splice(idx, 1);
};

Asset.prototype._callLoadListeners = function(newLevel, oldLevel){
    var listeners = this.listener;
    for(var i = 0; i < listeners.length; ++i){
        listeners[i].onAssetLoadChange && listeners[i].onAssetLoadChange(this, newLevel, oldLevel);
    }
};


Asset.prototype.addChangeListener = function(listener){
    Set.add(this.listener, listener);
};
Asset.prototype.removeChangeListener = function(listener){
    Set.remove(this.listener, listener);
    if (!this.listener.length) {
        this.dispose();
    }
};

Asset.prototype.dispose = function() {
    this.assetResult.dispose();
    this.clearSubAssets();
    this.clearChildren();
};

Asset.prototype.getResult = function(){
    if(!this.assetResult){
        this.assetResult = new AssetResult();
        this.assetResult.construct(this);
    }
    return this.assetResult;
};

function invalidateAsset(asset){
    if(asset.assetResult){
        asset.assetResult = null;
    }
    var listeners = asset.listener;
    for(var i = 0; i < listeners.length; ++i){
        listeners[i].onAssetChange && listeners[i].onAssetChange(this);
    }
    var i = asset.parents.length;
    while(i--){
        invalidateAsset(asset.parents[i]);
    }
}


function updateLoadingState(asset){
    var progressLevel = asset.loading ? asset.loadLevel : Infinity;
    if(progressLevel && asset.srcAsset){
        progressLevel = Math.min(progressLevel, Math.max(asset.srcAsset.loadLevel, asset.srcAsset.progressLevel));
    }
    var i = asset.subAssets.length;
    while(progressLevel && i--){
        progressLevel = Math.min(progressLevel, Math.max(asset.subAssets[i].loadLevel, asset.subAssets[i].progressLevel));
    }
    var i = asset.children.length;
    while(progressLevel && i--){
        progressLevel = Math.min(progressLevel, asset.children[i].progressLevel);
    }
    var oldLevel = asset.progressLevel;
    asset.progressLevel = progressLevel;

    if(oldLevel != asset.progressLevel){
        asset._callLoadListeners(asset.progressLevel, oldLevel);
        for(var i = 0; i < asset.parents.length; ++i)
            updateLoadingState(asset.parents[i]);
    }
}


//----------------------------------------------------------------------------------------------------------------------
// SubData
//----------------------------------------------------------------------------------------------------------------------

var SubData = function(xflowNodeOut, xflowNodeIn, refNode){
    this.xflowNodeOut = xflowNodeOut;
    this.xflowNodeIn = xflowNodeIn;
    this.refNode = refNode || null;
    this.name = null;
    this.matchFilter = null;
    this.classNames = [];
    this.postDataflow = null;
    this.postCompute = null;
    this.postFilter = null;
    this.includes = [];
    this.material = null;
    this.transform = null;
    this.meshType = null;
    this.visible = true;
    this.assetParent = null;
    this.loading = false;
    this.loadLevel = 0;
    this.progressLevel = Infinity;
    xflowNodeIn.addLoadListener(this.onXflowLoadEvent.bind(this));
    this._updateLoadingState();
};

SubData.prototype.setLoading = function(loading){
    if(loading != this.loading){
        this.loading = loading;
        this._updateLoadingState();
        invalidateParent(this);

    }
};

SubData.prototype._updateLoadingState = function(){
    var progressLevel = this.loading ? this.loadLevel : Infinity;
    progressLevel = Math.min(progressLevel, this.xflowNodeIn.getProgressLevel());
    var oldLevel = this.progressLevel;
    this.progressLevel = progressLevel;

    if(oldLevel != this.progressLevel){
        this.assetParent && updateLoadingState(this.assetParent);
        invalidateParent(this);
    }
};
SubData.prototype.onXflowLoadEvent = function(){
    this._updateLoadingState();
};

SubData.prototype.isSubtreeLoading = function(){
    return this.loading;
};

SubData.prototype.isMesh = function(){
    return !!this.meshType;
};

SubData.prototype.setName = function(name){
    this.name = name;
    invalidateParent(this);
};

SubData.prototype.setMatchFilter = function(matchString){
    if(typeof matchString == "string"){
        this.matchFilter = new AssetPickFilter();
        this.matchFilter.parse(matchString);
    }
    else
        this.matchFilter = null;
    invalidateParent(this);
};

SubData.prototype.setClassNames = function(classNames){
    this.classNames = classNames;
    invalidateParent(this);
};
SubData.prototype.setClassNamesString = function(classNamesString){
    if(!classNamesString)
        this.setClassNames([]);
    else{
        var array = classNamesString.split(/\s+/);
        var i = array.length;
        while(i--) array[i] = array[i].trim();
        this.setClassNames(array);
    }
};


SubData.prototype.setPostDataflow = function(postDataflow){
    this.postDataflow = postDataflow;
    invalidateParent(this);
};

SubData.prototype.setPostCompute = function(postCompute){
    this.postCompute = postCompute;
    invalidateParent(this);
};

SubData.prototype.setPostFilter = function(postFilter){
    this.postFilter = postFilter;
    invalidateParent(this);
};

SubData.prototype.setIncludes = function(includes){
    this.includes = includes;
    invalidateParent(this);
};

SubData.prototype.setMaterial = function(material){
    this.material = material;
    invalidateParent(this);
};

SubData.prototype.setTransform = function(transform){
    this.transform = transform;
    invalidateParent(this);
};

SubData.prototype.setMeshType = function(meshType){
    this.meshType = meshType;
    invalidateParent(this);
};

SubData.prototype.setVisibility = function(isVisible) {
    this.visible = isVisible;
    invalidateParent(this);
};
function invalidateParent(subData){
    if(subData.assetParent){
        invalidateAsset(subData.assetParent);
    }
}

//----------------------------------------------------------------------------------------------------------------------
// AssetResult
//----------------------------------------------------------------------------------------------------------------------

var AssetResult = function(){
    this.parentResult = null;
    this.name = null;
    this.namedEntries = {};
    this.allEntries = [];
    this.matchEntries = [];
    this.namedSubResults = {};
    this.allSubResults = [];

    this.material = null;
    this.transform = null;
    this.pickFilter = null;
};

AssetResult.prototype.construct = function(asset){
    constructAssetTable(this, asset);
};

AssetResult.prototype.dispose = function() {
    for (var i = 0; i < this.allEntries.length; i++) {
        this.allEntries[i].dispose();
    }

    for (var i = 0; i < this.allSubResults.length; i++) {
        this.allSubResults[i].dispose();
    }
};

AssetResult.prototype.getDataTree = function(){
    return rec_getDataTree(this);
};


function constructAssetTable(table, asset){
    table.name = asset.name;

    var srcAsset = asset.srcAsset, srcResult = srcAsset && srcAsset.getResult();
    if(srcResult){
        copySrcTable(table, srcAsset.getResult(), asset.pickFilter);
    }
    else
        table.pickFilter = asset.pickFilter;

    if(asset.material) table.material = asset.material;
    if(asset.transform) table.transform = combineTransform(table.transform, asset.transform);


    var subAssets = asset.subAssets;
    var i = subAssets.length;
    while(i--){
        var result = subAssets[i].getResult();
        mergeSubAssetResult(table, result);
    }
    var matchChildren = [];
    var children = asset.children;
    for(var i = 0; i < children.length; ++i){
        var child = children[i];
        var name = child.name;
        var entry;
        if(child.name && child.matchFilter){
            XML3D.debug.logWarning("Asset entry defines both name and match attribute. Match attribute will be ignored", child.refNode);
        }
        if(name){
            if(!table.namedEntries[name]){
                entry = new AssetTableEntry(child);
                applyMatchEntries(entry, table.matchEntries);
                table.namedEntries[name] = entry;
                table.allEntries.push(entry);
            }
            else
                entry = table.namedEntries[name];
        }
        else if(child.matchFilter){
            matchChildren.push(child);
            continue;
        }
        else{
            entry = new AssetTableEntry(child);
            applyMatchEntries(entry, table.matchEntries);
            table.allEntries.push(entry);
        }
        entry.pushPostEntry(child);
    }
    for(var i = 0; i < matchChildren.length; ++i){
        var child = matchChildren[i];
        var matchEntry = {filter: child.matchFilter, subdata: child};
        table.matchEntries.push(matchEntry);
        for(var j = 0; j < table.allEntries.length; ++j){
            applyMatchEntry(table.allEntries[j], matchEntry);
        }
    }
}

function applyMatchEntries(destEntry, matchEntries){
    for(var i = 0; i < matchEntries.length; ++i){
        applyMatchEntry(destEntry, matchEntries[i]);
    }
}

function applyMatchEntry(destEntry, matchEntry){
    var child = matchEntry.subdata;
    if(child.isMesh() == destEntry.isMesh() && matchEntry.filter.check(destEntry)){
        destEntry.pushPostEntry(child);
    }
}


function copySrcTable(table, srcTable, pickFilter){

    if(srcTable.matchEntries.length > 0){
        var i = table.allEntries.length;
        while(i--){
            var entry = table.allEntries[i];
            if(!entry.name || !srcTable.namedEntries[entry.name]){
                applyMatchEntries(entry, srcTable.matchEntries);
            }
        }
    }

    var i = srcTable.allEntries.length;
    while(i--){
        var srcEntry = srcTable.allEntries[i];
        var destEntry, newlyCreated = false;
        if(srcEntry.name && table.namedEntries[srcEntry.name]){
            destEntry = table.namedEntries[srcEntry.name];
        }
        else{
            destEntry = new AssetTableEntry();
            newlyCreated = true;
            table.allEntries.push(destEntry);
        }
        destEntry.pushTableEntry(srcEntry);
        if(newlyCreated)
            applyMatchEntries(destEntry, table.matchEntries);

        if(destEntry.name) table.namedEntries[destEntry.name] = destEntry;
    }

    table.matchEntries.push.apply(table.matchEntries, srcTable.matchEntries);


    var i = srcTable.allSubResults.length;
    while(i--){
        mergeSubAssetResult(table, srcTable.allSubResults[i]);
    }

    if(pickFilter && srcTable.pickFilter){
        table.pickFilter = new AssetPickFilter();
        table.pickFilter.intersection(pickFilter, srcTable.pickFilter);
    }
    else{
        table.pickFilter = pickFilter || srcTable.pickFilter;
    }
    if(srcTable.material) table.material = srcTable.material;
    if(srcTable.transform) table.transform = combineTransform(table.transform, srcTable.transform);
}


function mergeSubAssetResult(table, srcSubTable){
    var destSubTable;
    if(srcSubTable.name && table.namedSubResults[srcSubTable.name]){
        destSubTable = table.namedSubResults[srcSubTable.name];
    }
    else{
        destSubTable = new AssetResult();
        destSubTable.parentResult = table;
        destSubTable.name = srcSubTable.name;
        table.allSubResults.push(destSubTable);
        if(destSubTable.name) table.namedSubResults[destSubTable.name] = destSubTable;
    }
    copySrcTable(destSubTable, srcSubTable, destSubTable.pickFilter);
}

function rec_getDataTree(table){
    var node = {
        meshes: [],
        groups: [],
        transform: table.transform,
        material: table.material,
        postTransformXflowNode: null
    };

    for(var i = 0; i < table.allEntries.length; ++i){
        var entry = table.allEntries[i];
        if(entry.meshType && (!table.pickFilter || table.pickFilter.check(entry)) ){
            updateAccumulatedNode(table, entry);
            node.meshes.push({
                xflowNode: entry.accumulatedXflowNode,
                type: entry.meshType,
                material: entry.material,
                transform: entry.transform,
                visible: entry.visible,
                refNode: entry.refNode
            });
        }
    }
    var postTransformEntry = table.namedEntries["_postTransform"];
    if(postTransformEntry){
        updateAccumulatedNode(table, postTransformEntry);
        node.postTransformXflowNode = postTransformEntry.accumulatedXflowNode;
    }
    for(var i = 0; i < table.allSubResults.length; ++i){
        var subNode = rec_getDataTree(table.allSubResults[i]);
        node.groups.push(subNode);
    }
    return node;
}

function updateAccumulatedNode(table, entry){
    if(!entry.outOfSync)
        return;

    if(entry.accumulatedXflowNode){
        entry.accumulatedXflowNode.setCompute("");
        entry.accumulatedXflowNode.setFilter("");
        entry.accumulatedXflowNode.dataflowNode = null;
        entry.accumulatedXflowNode.setLoading(false);
    }
    else{
        entry.accumulatedXflowNode = new AssetDataNode(false);
    }

    var dataNode = entry.postQueue.length == 1 ? entry.accumulatedXflowNode : new AssetDataNode(false);
    for(var i = 0; i < entry.postQueue.length; ++i){
        var includes = entry.postQueue[i].includes;
        for(var j = 0; j < includes.length; ++j){
            var addEntry = getIncludeEntry(table, includes[j]);
            dataNode.appendChild(addEntry.accumulatedXflowNode);
        }
        if(entry.postQueue[i].xflowNode)
            dataNode.appendChild(entry.postQueue[i].xflowNode);
    }
    var node = dataNode, parentNode = null;
    for(var i = 0; i < entry.postQueue.length; ++i){
        var postEntry = entry.postQueue[i];
        if(!node) node = (i == entry.postQueue.length - 1 ? entry.accumulatedXflowNode : new AssetDataNode(false));
        node.setCompute(postEntry.compute);
        node.setFilter(postEntry.filter);
        node.dataflowNode = postEntry.dataflow;
        node.setLoading(postEntry.dataflowLoading);
        if(parentNode) node.appendChild(parentNode);
        parentNode = node;
        node = null;
    }
    entry.outOfSync = false;
}


var c_accum_entries = [],
    c_accum_names = [];

function getIncludeEntry(table, includeString){
    var segments = includeString.split(".");
    for(var i = 0; i < segments.length -1; ++i){
        var seg = segments[i];
        if(seg == "parent"){
            if(!table.parentResult)
                throw new Error("Includes entry '" + includeString + "' (token "+ i +") accesses non existent parent.");
            table = table.parentResult;
        }
        else{
            if(!table.namedSubResults[seg])
                throw new Error("Includes entry '" + includeString + "' (token "+ i +") accesses non existent sub result '" + seg + "'");
            table = table.namedSubResults[seg];
        }
    }
    var entryKey = segments[segments.length - 1];
    var entry = table.namedEntries[entryKey];
    if(!entry){
        throw new Error("Includes entry '" + includeString + "' accesses non existent asset entry '" + entryKey + "'" );
    }

    c_accum_names.push(includeString);
    if(c_accum_entries.indexOf(entry) != -1){
        var path = c_accum_names.join(" > ");
        throw new Error("Recursive include dependencies detected: " + path);
    }
    c_accum_entries.push(entry);

    updateAccumulatedNode(table, entry);
    c_accum_entries.pop();
    c_accum_names.pop();
    return entry;
}




function AssetTableEntry (subData){
    this.name = null;
    this.classNames = [];
    this.meshType = null;

    this.postQueue = [];
    this.material = null;
    this.transform = null;
    this.visible = true;

    this.accumulatedXflowNode = null;
    this.outOfSync = true;
    this.refNode = null;
    if(subData){
        this.name = subData.name;
        Set.add(this.classNames, subData.classNames);
    }
}

AssetTableEntry.prototype.isMesh = function(){
    return !!this.meshType;
};

/**
 * Clears child<->parent relationships for all Xflow nodes that were created for this Asset instance specifically (eg through overrides)
 */
AssetTableEntry.prototype.dispose = function() {
    clearAssetRelatedChildren(this.accumulatedXflowNode);
    this.accumulatedXflowNode.clear();
};

/**
 * This function clears parent->child and dataFlowNode relationships for all xflow nodes
 * that were generated for the AssetTableEntry that it's called from initially. It won't clear
 * relationships for any normal DataNodes that are part of non-asset-related Xflow graphs (ie. dataflow graphs)
 * @param dataNode
 */
function clearAssetRelatedChildren(dataNode) {
    if (dataNode._children === undefined) {
        return; //Input leaf node, nothing to do here
    }
    for (var i = 0; i < dataNode._children.length; i++) {
        clearAssetRelatedChildren(dataNode._children[i]);
    }
    if (dataNode.isAssetDataNode) {
        dataNode.clear();
        dataNode._channelNode.setStructureOutOfSync();
    }
}


AssetTableEntry.prototype.pushTableEntry = function(srcEntry){
    this.name = srcEntry.name;
    Set.add(this.classNames, srcEntry.classNames);
    if(srcEntry.meshType) this.meshType = srcEntry.meshType;
    if(srcEntry.visible !== undefined) this.visible = srcEntry.visible;

    if(srcEntry.transform) this.transform = combineTransform(this.transform, srcEntry.transform);
    if(srcEntry.material) this.material = srcEntry.material;

    this.postQueue.push.apply(this.postQueue, srcEntry.postQueue);
};


AssetTableEntry.prototype.pushPostEntry = function(subData){
    this.name = subData.name;
    this.postQueue.push({
        dataflow: subData.postDataflow,
        dataflowLoading: subData.loading,
        compute: subData.postCompute,
        filter: subData.postFilter,
        includes: subData.includes,
        xflowNode: subData.xflowNodeIn
    });
    this.refNode = subData.refNode;
    this.accumulatedXflowNode = subData.xflowNodeOut;
    Set.add(this.classNames, subData.classNames);
    if(subData.meshType) this.meshType = subData.meshType;
    if(subData.material) this.material = subData.material;
    if(subData.visible !== undefined) this.visible = subData.visible;
    if(subData.transform) this.transform = combineTransform(this.transform, subData.transform);
};


function combineTransform(oldTransform, newTransform){
    // TODO: Better multiply transformations here
    return newTransform;
}


function AssetPickFilter(){
    this.all = false;
    this.names = [];
    this.classNames = [];
}

AssetPickFilter.prototype.parse = function(string){
    var entries = string.split(",");
    var i = entries.length;
    while(i--){
        var entry = entries[i].trim();
        if(entry == "*"){
            this.all = true;
        }
        else if(entry.indexOf(".") == 0){
            var classNames = entry.split(".");
            var j = classNames.length;
            while(j--){
                if(!classNames[j].trim())
                    classNames.splice(j,1);
            }
            this.classNames.push(classNames);
        }
        else{
            Set.add(this.names, entry);
        }
    }
};

AssetPickFilter.prototype.intersection = function(setA, setB){
    Set.intersection(this.names, setA.names, setB.names);
    Set.intersection(this.classNames, setA.classNames, setB.classNames);
};

AssetPickFilter.prototype.check = function(entry){
    if(this.all)
        return true;
    if(entry.classNames.length > 0){
        var i = this.classNames.length;
        while(i--){
            if(Set.isSubset(this.classNames[i], entry.classNames))
                return true;
        }
    }
    return (entry.name && this.names.indexOf(entry.name) != -1);
};

/**
 * This is just a small wrapper to identify Xflow nodes that were created by an Asset, eg as part of overrides
 * that need to be cleaned up later if the corresponding model tag is destroyed
 * @param isDataFlow
 * @constructor
 */
var AssetDataNode = function(isDataFlow) {
    DataNode.call(this, isDataFlow);
    this.isAssetDataNode = true;
};

Base.createClass(AssetDataNode, DataNode);

module.exports = {
    Asset: Asset,
    SubData: SubData,
    AssetResult: AssetResult
};

},{"../xflow/base.js":186,"../xflow/interface/graph.js":189,"../xflow/utils/utils.js":238}],48:[function(require,module,exports){
var Events = require("../interface/notification.js");
var config = require("../interface/elements.js").config;
var Resource = require("../resource");

/**
 * A normal adapter that doesn't need to be connected to a DOM node
 * @constructor
 * @param {XML3D.base.AdapterFactory} factory - the factory this adapter was created from
 */
var Adapter = function(factory) {
    this.factory = factory;
};

/**
 * Connect an adapterHandle to a certain key.
 * This will enable the ConnectedAdapterNotifcations for notifyChanged.
 * @param {string} key - the key that will also be provided in connectAdapterChanged callback
 * @param {XML3D.base.AdapterHandle} adapterHandle handle of adapter to be added
 */
Adapter.prototype.connectAdapterHandle = function(key, adapterHandle) {
    if (!this.connectedAdapterHandles) {
        this.connectedAdapterHandles = {};
        this._bindedAdapterHandleCallback = adapterHandleCallback.bind(this);
    }

    this.disconnectAdapterHandle(key);

    if (adapterHandle) {
        this.connectedAdapterHandles[key] = adapterHandle;
        this.connectedAdapterHandles[key].addListener(this._bindedAdapterHandleCallback);
    }
    else
        delete this.connectedAdapterHandles[key];

};

/**
 * Disconnects the adapter handle from the given key.
 * @param {string} key - the key that was provided when this adapter handle was connected
 */
Adapter.prototype.disconnectAdapterHandle = function(key) {
    if (this.connectedAdapterHandles && this.connectedAdapterHandles[key]) {
        this.connectedAdapterHandles[key].removeListener(this._bindedAdapterHandleCallback);
        delete this.connectedAdapterHandles[key];
    }
};

/**
 * Disconnects all adapter handles.
 */
Adapter.prototype.clearAdapterHandles = function() {
    for (var i in this.connectedAdapterHandles) {
        this.connectedAdapterHandles[i].removeListener(this._bindedAdapterHandleCallback);
    }

    this.connectedAdapterHandles = null;
};

/**
 * Get the connected AdapterHandle of a certain key.
 * This will only return AdapterHandles previously added via connectAdapterHandle
 * @param {string} key
 * @return {?AdapterHandle} the adapter of that key, or null if not available
 */
Adapter.prototype.getConnectedAdapterHandle = function(key) {
    return this.connectedAdapterHandles && this.connectedAdapterHandles[key];
};

/**
 * Get the connected adapter of a certain key.
 * This will only return adapters of AdapterHandles previously added via connectAdapter
 * @param {string} key
 * @return {?XML3D.base.Adapter} the adapter of that key, or null if not available
 */
Adapter.prototype.getConnectedAdapter = function(key) {
    var handle = this.getConnectedAdapterHandle(key);
    return handle && handle.getAdapter();
};

/**
 * This function is called, when the adapater is detached from the node.
 * At this point, the adapater should disconnect from any other adapter and prepare to be properly garbage collected
 */
Adapter.prototype.dispose = function() {
};


/**
 * Internal function that converts an AdapterHandleNotification to a ConnectedAdapterNotification
 * @private
 * @param {Events.AdapterHandleNotification} evt
 */
function adapterHandleCallback(evt) {
    for (var key in this.connectedAdapterHandles) {
        if (this.connectedAdapterHandles[key] == evt.adapterHandle) {
            var subEvent = new Events.ConnectedAdapterNotification(evt, key);
            this.notifyChanged(subEvent);
        }
    }
}


/**
 * An Adapter connected to a DOMNode (possibly of an external document)
 * @constructor
 * @param {AdapterFactory} factory the AdapterFactory this adapter was created from
 * @param {Object} node - DOM node of this Adapter
 */
var NodeAdapter = function(factory, node) {
    Adapter.call(this, factory);
    this.node = node;
};
XML3D.createClass(NodeAdapter, Adapter);

/**
 * called by the factory after adding the adapter to the node
 */
NodeAdapter.prototype.init = function() {
};

/**
 * Notifiction due to a change in DOM, related adapters and so on.
 * @param {Events.Notification} e
 */
NodeAdapter.prototype.notifyChanged = function(e) {

};

/**
 * @param {string|XML3D.URI} uri Uri to referred adapterHandle
 * @param {Object=} aspectType Optional: the type of adapter (use same adapter type by default)
 * @param {number=} canvasId Optional: the canvas id of the adapter (use canvas id of this adapter by default)
 * @returns an AdapterHandle to the referred Adapter of the same aspect and canvasId
 */
NodeAdapter.prototype.getAdapterHandle = function(uri, aspectType, canvasId) {
    canvasId = canvasId === undefined ? this.factory.canvasId : canvasId;
    return Resource.getAdapterHandle(this.node.ownerDocument._documentURL || this.node.ownerDocument.URL,
        uri, aspectType || this.factory.aspect, canvasId, this.node.nodeName);
};
/**
 * notifies all adapter that refer to this adapter through AdapterHandles.
 * @param {number?} type The type of change
 */
NodeAdapter.prototype.notifyOppositeAdapters = function(type) {
    type = type || Events.ADAPTER_HANDLE_CHANGED;
    return Resource.notifyNodeAdapterChange(this.node,
        this.factory.aspect, this.factory.canvasId, type);
};

/**
 * Depth-first traversal over element hierarchy
 * @param {function(NodeAdapter)} callback
 */
NodeAdapter.prototype.traverse = function(callback) {
    callback(this);
    var child = this.node.firstElementChild;
    while (child) {
        var adapter = this.factory.getAdapter(child);
        adapter && adapter.traverse(callback);
        child = child.nextElementSibling;
    }
};


/**
 * @interface
 */
var IFactory = function() {
};
IFactory.prototype.createAdapter = function() {};


/**
 * An adapter factory is responsible for creating adapter from a certain data source.
 * Note that any AdapterFactory is registered with Resource
 * @constructor
 * @implements {IFactory}
 * @param {Object} aspect The aspect this factory serves (e.g. XML3D.data or XML3D.webgl)
 * @param {string|Array.<string>} mimetypes The mimetype this factory is compatible to
 * @param {number} canvasId The id of the corresponding canvas handler. 0, if not dependent on any GLCanvasHandler
 */
var AdapterFactory = function(aspect, mimetypes, canvasId) {
    this.aspect = aspect;
    this.canvasId = canvasId || 0;
    this.mimetypes = typeof mimetypes == "string" ? [ mimetypes] : mimetypes;
};

 /** Implemented by subclass
 * Create adapter from an object (node in case of an xml, and object in case of json)
 * @param {object} obj
 * @returns {?Adapter} created adapter or null if no adapter can be created
 */
AdapterFactory.prototype.createAdapter = function(obj) {
    return null;
};

/**
 * Checks if the adapter factory supports specified mimetype. Can be overridden by subclass.
 * @param {String} mimetype
 * @return {Boolean} true if the adapter factory supports specified mimetype
 */
AdapterFactory.prototype.supportsMimetype = function(mimetype) {
    return this.mimetypes.indexOf(mimetype) != -1;
};

/**
 * A NodeAdaperFactory is a AdapterFactory, that works specifically for DOM nodes / elements.
 * @constructor
 * @param {Object} aspect The aspect this factory serves (e.g. XML3D.data or XML3D.webgl)
 * @param {number} canvasId The id of the corresponding canvas handler. 0, if not dependent on any GLCanvasHandler
 */
var NodeAdapterFactory = function(aspect, canvasId) {
    AdapterFactory.call(this, aspect, ["text/xml", "application/xml"], canvasId);
};
XML3D.createClass(NodeAdapterFactory, AdapterFactory);

/**
 * This function first checks, if an adapter has been already created for the corresponding node
 * If yes, this adapter is returned, otherwise, a new adapter is created and returned.
 * @param {Object} node
 * @returns {Adapter} The adapter of the node
 */
NodeAdapterFactory.prototype.getAdapter = function(node) {
    if(node && node._configured === undefined)
        config.element(node);
    if (!node || node._configured === undefined)
        return null;

    var elemHandler = node._configured;
    var key = this.aspect + "_" + this.canvasId;
    var adapter = elemHandler.adapters[key];
    if (adapter !== undefined)
        return adapter;

    // No adapter found, try to create one
    adapter = this.createAdapter(node);
    if (adapter) {
        elemHandler.adapters[key] = adapter;
        adapter.init();
    }
    return adapter;
};

module.exports = {
NodeAdapter : NodeAdapter,
AdapterFactory : AdapterFactory,
NodeAdapterFactory : NodeAdapterFactory
};

},{"../interface/elements.js":72,"../interface/notification.js":74,"../resource":165}],49:[function(require,module,exports){
var Events = require("../interface/notification.js");

"use strict";
/**
 * An adapter handle is a connection piece for an adapter that is referred through a uri (e.g. id reference)
 * AdapterHandles are always fetched from the Resource object
 * @constructor
 */
var AdapterHandle = function(url) {
    this.url = url;
    this.adapter = null;
    this.listeners = [];
    this.status = 0; // STATUS.LOADING
};

/**
 * Enumaeration of states for the adapter handle
 * @enum {number}
 */
AdapterHandle.STATUS = {
    LOADING: 0,
    NOT_FOUND: 1,
    READY: 2
};

/**
 * @returns {Boolean} true iff an adapter is available
 */
AdapterHandle.prototype.hasAdapter = function() {
    return this.adapter != null;
};

/**
 * @returns {?XML3D.base.Adapter} the adapter connected to the handle. Can be null
 */
AdapterHandle.prototype.getAdapter = function() {
    return this.adapter;
};

/**
 * Note: this function should only be called by Resource
 * @param {XML3D.base.Adapter} adapter The adapter connected to the AdapterHandler
 * @param {AdapterHandle.STATUS} status
 */
AdapterHandle.prototype.setAdapter = function(adapter, status) {
    this.adapter = adapter;
    this.status = status;
    this.notifyListeners(Events.ADAPTER_HANDLE_CHANGED);
};

/**
 * This function is called to notify all listeners of this AdapterHandle about some change.
 * @param {number} type A type number with the type of change (usually Events.ADAPTER_HANDLE_CHANGED)
 */
AdapterHandle.prototype.notifyListeners = function(type) {
    var event = new Events.AdapterHandleNotification(this, type);
    var i = this.listeners.length;
    while (i--) {
        this.listeners[i](event);
    }
};

/**
 * Add a listener to the AdapterHandle that is notified about changes.
 * Listeners cannot be inserted twice.
 * @param {Function} listener - Function to be called when something concering the adapter changes
 */
AdapterHandle.prototype.addListener = function(listener) {
    var idx = this.listeners.indexOf(listener);
    if (idx == -1)
        this.listeners.push(listener);
};

/**
 * Remove a listener from the AdapterHandle
 * @param {Function} listener
 */
AdapterHandle.prototype.removeListener = function(listener) {
    var idx = this.listeners.indexOf(listener);
    if (idx != -1)
        this.listeners.splice(idx, 1);
};

module.exports = AdapterHandle;
},{"../interface/notification.js":74}],50:[function(require,module,exports){
/*jslint white: false, onevar: false, undef: true, nomen: true, eqeqeq: true, plusplus: true, bitwise: true, regexp: true, newcap: true, immed: true, sub: true, nomen: false */

/**
* This file contains code that may be under the following license:
*
* SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
* Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
*
* See http://oss.sgi.com/projects/FreeB/ for more information.
*
* All code in this file which is NOT under the SGI FREE SOFTWARE LICENSE B
* is free and unencumbered software released into the public domain.
*
* Anyone is free to copy, modify, publish, use, compile, sell, or
* distribute this software, either in source code form or as a compiled
* binary, for any purpose, commercial or non-commercial, and by any
* means.
*
* In jurisdictions that recognize copyright laws, the author or authors
* of this software dedicate any and all copyright interest in the
* software to the public domain. We make this dedication for the benefit
* of the public at large and to the detriment of our heirs and
* successors. We intend this dedication to be an overt act of
* relinquishment in perpetuity of all present and future rights to this
* software under copyright law.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
* OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/

var GLU = {};
/**
* Unproject a screen point.
*
* @param {number} winX the window point for the x value.
* @param {number} winY the window point for the y value.
* @param {number} winZ the window point for the z value.
* @param {Array.<number>} model the model-view matrix.
* @param {Array.<number>} proj the projection matrix.
* @param {Array.<number>} view the viewport coordinate array.
* @param {Array.<number>} objPos the model point result.
* @return {boolean} true if the unproject operation was successful, false otherwise.
*/
GLU.unProject = function(winX, winY, winZ, model, proj, view, objPos) {

    /** @type {Array.<number>} */
    var inp = [
        winX,
        winY,
        winZ,
        1.0
    ];

    /** @type {Array.<number>} */
    var finalMatrix = [];

    GLU.multMatrices(model, proj, finalMatrix);
    if (!GLU.invertMatrix(finalMatrix, finalMatrix)) {
        return (false);
    }

    /* Map x and y from window coordinates */
    inp[0] = (inp[0] - view[0]) / view[2];
    inp[1] = (inp[1] - view[1]) / view[3];

    /* Map to range -1 to 1 */
    inp[0] = inp[0] * 2 - 1;
    inp[1] = inp[1] * 2 - 1;
    inp[2] = inp[2] * 2 - 1;

    /** @type {Array.<number>} */
    var out = [];

    GLU.multMatrixVec(finalMatrix, inp, out);

    if (out[3] === 0.0) {
        return false;
    }

    out[0] /= out[3];
    out[1] /= out[3];
    out[2] /= out[3];

    objPos[0] = out[0];
    objPos[1] = out[1];
    objPos[2] = out[2];

    return true;
};

/**
* Multiply the matrix by the specified vector.
*
* @param {Array.<number>} matrix the matrix.
* @param {Array.<number>} inp the vector.
* @param {Array.<number>} out the output.
*/
GLU.multMatrixVec = function(matrix, inp, out) {
    for (var i = 0; i < 4; i = i + 1) {
        out[i] =
            inp[0] * matrix[0 * 4 + i] +
            inp[1] * matrix[1 * 4 + i] +
            inp[2] * matrix[2 * 4 + i] +
            inp[3] * matrix[3 * 4 + i];
    }
};

/**
* Multiply the specified matrices.
*
* @param {Array.<number>} a the first matrix.
* @param {Array.<number>} b the second matrix.
* @param {Array.<number>} r the result.
*/
GLU.multMatrices = function(a, b, r) {
    for (var i = 0; i < 4; i = i + 1) {
        for (var j = 0; j < 4; j = j + 1) {
            r[i * 4 + j] =
                a[i * 4 + 0] * b[0 * 4 + j] +
                a[i * 4 + 1] * b[1 * 4 + j] +
                a[i * 4 + 2] * b[2 * 4 + j] +
                a[i * 4 + 3] * b[3 * 4 + j];
        }
    }
};

/**
* Invert a matrix.
*
* @param {Array.<number>} m the matrix.
* @param {Array.<number>} invOut the inverted output.
* @return {boolean} true if successful, false otherwise.
*/
GLU.invertMatrix = function(m, invOut) {
    /** @type {Array.<number>} */
    var inv = [];

    inv[0] = m[5] * m[10] * m[15] - m[5] * m[11] * m[14] - m[9] * m[6] * m[15] +
        m[9] * m[7] * m[14] + m[13] * m[6] * m[11] - m[13] * m[7] * m[10];
    inv[4] = -m[4] * m[10] * m[15] + m[4] * m[11] * m[14] + m[8] * m[6] * m[15] -
        m[8] * m[7] * m[14] - m[12] * m[6] * m[11] + m[12] * m[7] * m[10];
    inv[8] = m[4] * m[9] * m[15] - m[4] * m[11] * m[13] - m[8] * m[5] * m[15] +
        m[8] * m[7] * m[13] + m[12] * m[5] * m[11] - m[12] * m[7] * m[9];
    inv[12] = -m[4] * m[9] * m[14] + m[4] * m[10] * m[13] + m[8] * m[5] * m[14] -
        m[8] * m[6] * m[13] - m[12] * m[5] * m[10] + m[12] * m[6] * m[9];
    inv[1] = -m[1] * m[10] * m[15] + m[1] * m[11] * m[14] + m[9] * m[2] * m[15] -
        m[9] * m[3] * m[14] - m[13] * m[2] * m[11] + m[13] * m[3] * m[10];
    inv[5] = m[0] * m[10] * m[15] - m[0] * m[11] * m[14] - m[8] * m[2] * m[15] +
        m[8] * m[3] * m[14] + m[12] * m[2] * m[11] - m[12] * m[3] * m[10];
    inv[9] = -m[0] * m[9] * m[15] + m[0] * m[11] * m[13] + m[8] * m[1] * m[15] -
        m[8] * m[3] * m[13] - m[12] * m[1] * m[11] + m[12] * m[3] * m[9];
    inv[13] = m[0] * m[9] * m[14] - m[0] * m[10] * m[13] - m[8] * m[1] * m[14] +
        m[8] * m[2] * m[13] + m[12] * m[1] * m[10] - m[12] * m[2] * m[9];
    inv[2] = m[1] * m[6] * m[15] - m[1] * m[7] * m[14] - m[5] * m[2] * m[15] +
        m[5] * m[3] * m[14] + m[13] * m[2] * m[7] - m[13] * m[3] * m[6];
    inv[6] = -m[0] * m[6] * m[15] + m[0] * m[7] * m[14] + m[4] * m[2] * m[15] -
        m[4] * m[3] * m[14] - m[12] * m[2] * m[7] + m[12] * m[3] * m[6];
    inv[10] = m[0] * m[5] * m[15] - m[0] * m[7] * m[13] - m[4] * m[1] * m[15] +
        m[4] * m[3] * m[13] + m[12] * m[1] * m[7] - m[12] * m[3] * m[5];
    inv[14] = -m[0] * m[5] * m[14] + m[0] * m[6] * m[13] + m[4] * m[1] * m[14] -
        m[4] * m[2] * m[13] - m[12] * m[1] * m[6] + m[12] * m[2] * m[5];
    inv[3] = -m[1] * m[6] * m[11] + m[1] * m[7] * m[10] + m[5] * m[2] * m[11] -
        m[5] * m[3] * m[10] - m[9] * m[2] * m[7] + m[9] * m[3] * m[6];
    inv[7] = m[0] * m[6] * m[11] - m[0] * m[7] * m[10] - m[4] * m[2] * m[11] +
        m[4] * m[3] * m[10] + m[8] * m[2] * m[7] - m[8] * m[3] * m[6];
    inv[11] = -m[0] * m[5] * m[11] + m[0] * m[7] * m[9] + m[4] * m[1] * m[11] -
        m[4] * m[3] * m[9] - m[8] * m[1] * m[7] + m[8] * m[3] * m[5];
    inv[15] = m[0] * m[5] * m[10] - m[0] * m[6] * m[9] - m[4] * m[1] * m[10] +
        m[4] * m[2] * m[9] + m[8] * m[1] * m[6] - m[8] * m[2] * m[5];

    /** @type {number} */
    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    if (det === 0) {
        return false;
    }

    det = 1.0 / det;

    for (var i = 0; i < 16; i = i + 1) {
        invOut[i] = inv[i] * det;
    }

    return true;
};

module.exports = GLU;
},{}],51:[function(require,module,exports){
// Domain Public by Eric Wendelin http://eriwen.com/ (2008)
//                  Luke Smith http://lucassmith.name/ (2008)
//                  Loic Dachary <loic@dachary.org> (2008)
//                  Johan Euphrosine <proppy@aminche.com> (2008)
//                  Oyvind Sean Kinsey http://kinsey.no/blog (2010)
//                  Victor Homyakov <victor-homyakov@users.sourceforge.net> (2010)


/**
 * Main function giving a function stack trace with a forced or passed in
 * Error
 *
 * @cfg {Error} e The error to create a stacktrace from (optional)
 * @cfg {Boolean} guess If we should try to resolve the names of anonymous
 * functions
 * @return {Array} of Strings with functions, lines, files, and arguments
 * where possible
 */
var printStackTrace = function (options) {
    options = options || {
        guess : true
    };
    var ex = options.e || null, guess = !!options.guess;
    var p = new printStackTrace.implementation(), result = p.run(ex);
    return (guess) ? p.guessAnonymousFunctions(result) : result;
};

printStackTrace.implementation = function() {};

printStackTrace.implementation.prototype = {
    /**
     * @param {Error} ex The error to create a stacktrace from (optional)
     * @param {String} mode Forced mode (optional, mostly for unit tests)
     */
    run : function(ex, mode) {
        ex = ex || this.createException();
        // examine exception properties w/o debugger
        // for (var prop in ex) {alert("Ex['" + prop + "']=" + ex[prop]);}
        mode = mode || this.mode(ex);
        if (mode === 'other') {
            return this.other(arguments.callee);
        } else {
            return this[mode](ex);
        }
    },

    createException : function() {
        try {
            this.undef();
        } catch (e) {
            return e;
        }
    },

    /**
     * Mode could differ for different exception, e.g. exceptions in Chrome
     * may or may not have arguments or stack.
     *
     * @return {String} mode of operation for the exception
     */
    mode : function(e) {
        if (e['arguments'] && e.stack) {
            return 'chrome';
        } else if (e.stack && e.sourceURL) {
            return 'safari';
        } else if (typeof e.message === 'string' && typeof window !== 'undefined' && window.opera) {
            // e.message.indexOf("Backtrace:") > -1 -> opera
            // !e.stacktrace -> opera
            if (!e.stacktrace) {
                return 'opera9'; // use e.message
            }
            // 'opera#sourceloc' in e -> opera9, opera10a
            if (e.message.indexOf('\n') > -1 && e.message.split('\n').length > e.stacktrace.split('\n').length) {
                return 'opera9'; // use e.message
            }
            // e.stacktrace && !e.stack -> opera10a
            if (!e.stack) {
                return 'opera10a'; // use e.stacktrace
            }
            // e.stacktrace && e.stack -> opera10b
            if (e.stacktrace.indexOf("called from line") < 0) {
                return 'opera10b'; // use e.stacktrace, format differs from
                                    // 'opera10a'
            }
            // e.stacktrace && e.stack -> opera11
            return 'opera11'; // use e.stacktrace, format differs from
                                // 'opera10a', 'opera10b'
        } else if (e.stack) {
            return 'firefox';
        }
        return 'other';
    },

    /**
     * Given a context, function name, and callback function, overwrite it
     * so that it calls printStackTrace() first with a callback and then
     * runs the rest of the body.
     *
     * @param {Object} context of execution (e.g. window)
     * @param {String} functionName to instrument
     * @param {Function} function to call with a stack trace on invocation
     */
    instrumentFunction : function(context, functionName, callback) {
        context = context || window;
        var original = context[functionName];
        context[functionName] = function instrumented() {
            callback.call(this, printStackTrace().slice(4));
            return context[functionName]._instrumented.apply(this, arguments);
        };
        context[functionName]._instrumented = original;
    },

    /**
     * Given a context and function name of a function that has been
     * instrumented, revert the function to it's original (non-instrumented)
     * state.
     *
     * @param {Object} context of execution (e.g. window)
     * @param {String} functionName to de-instrument
     */
    deinstrumentFunction : function(context, functionName) {
        if (context[functionName].constructor === Function && context[functionName]._instrumented
                && context[functionName]._instrumented.constructor === Function) {
            context[functionName] = context[functionName]._instrumented;
        }
    },

    /**
     * Given an Error object, return a formatted Array based on Chrome's
     * stack string.
     *
     * @param e - Error object to inspect
     * @return Array<String> of function calls, files and line numbers
     */
    chrome : function(e) {
        var stack = (e.stack + '\n').replace(/^\S[^\(]+?[\n$]/gm, '').replace(/^\s+(at eval )?at\s+/gm, '').replace(/^([^\(]+?)([\n$])/gm,
                '{anonymous}()@$1$2').replace(/^Object.<anonymous>\s*\(([^\)]+)\)/gm, '{anonymous}()@$1').split('\n');
        stack.pop();
        return stack;
    },

    /**
     * Given an Error object, return a formatted Array based on Safari's
     * stack string.
     *
     * @param e - Error object to inspect
     * @return Array<String> of function calls, files and line numbers
     */
    safari : function(e) {
        return e.stack.replace(/\[native code\]\n/m, '').replace(/^@/gm, '{anonymous}()@').split('\n');
    },

    /**
     * Given an Error object, return a formatted Array based on Firefox's
     * stack string.
     *
     * @param e - Error object to inspect
     * @return Array<String> of function calls, files and line numbers
     */
    firefox : function(e) {
        return e.stack.replace(/(?:\n@:0)?\s+$/m, '').replace(/^[\(@]/gm, '{anonymous}()@').split('\n');
    },

    opera11 : function(e) {
        var ANON = '{anonymous}', lineRE = /^.*line (\d+), column (\d+)(?: in (.+))? in (\S+):$/;
        var lines = e.stacktrace.split('\n'), result = [];

        for ( var i = 0, len = lines.length; i < len; i += 2) {
            var match = lineRE.exec(lines[i]);
            if (match) {
                var location = match[4] + ':' + match[1] + ':' + match[2];
                var fnName = match[3] || "global code";
                fnName = fnName.replace(/<anonymous function: (\S+)>/, "$1").replace(/<anonymous function>/, ANON);
                result.push(fnName + '@' + location + ' -- ' + lines[i + 1].replace(/^\s+/, ''));
            }
        }

        return result;
    },

    opera10b : function(e) {
        // "<anonymous function: run>([arguments not
        // available])@file://localhost/G:/js/stacktrace.js:27\n" +
        // "printStackTrace([arguments not
        // available])@file://localhost/G:/js/stacktrace.js:18\n" +
        // "@file://localhost/G:/js/test/functional/testcase1.html:15"
        var lineRE = /^(.*)@(.+):(\d+)$/;
        var lines = e.stacktrace.split('\n'), result = [];

        for ( var i = 0, len = lines.length; i < len; i++) {
            var match = lineRE.exec(lines[i]);
            if (match) {
                var fnName = match[1] ? (match[1] + '()') : "global code";
                result.push(fnName + '@' + match[2] + ':' + match[3]);
            }
        }

        return result;
    },

    /**
     * Given an Error object, return a formatted Array based on Opera 10's
     * stacktrace string.
     *
     * @param e - Error object to inspect
     * @return Array<String> of function calls, files and line numbers
     */
    opera10a : function(e) {
        // " Line 27 of linked script
        // file://localhost/G:/js/stacktrace.js\n"
        // " Line 11 of inline#1 script in
        // file://localhost/G:/js/test/functional/testcase1.html: In
        // function foo\n"
        var ANON = '{anonymous}', lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
        var lines = e.stacktrace.split('\n'), result = [];

        for ( var i = 0, len = lines.length; i < len; i += 2) {
            var match = lineRE.exec(lines[i]);
            if (match) {
                var fnName = match[3] || ANON;
                result.push(fnName + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\s+/, ''));
            }
        }

        return result;
    },

    // Opera 7.x-9.2x only!
    opera9 : function(e) {
        // " Line 43 of linked script
        // file://localhost/G:/js/stacktrace.js\n"
        // " Line 7 of inline#1 script in
        // file://localhost/G:/js/test/functional/testcase1.html\n"
        var ANON = '{anonymous}', lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
        var lines = e.message.split('\n'), result = [];

        for ( var i = 2, len = lines.length; i < len; i += 2) {
            var match = lineRE.exec(lines[i]);
            if (match) {
                result.push(ANON + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\s+/, ''));
            }
        }

        return result;
    },

    // Safari 5-, IE 9-, and others
    other : function(curr) {
        var ANON = '{anonymous}', fnRE = /function\s*([\w\-$]+)?\s*\(/i, stack = [], fn, args, maxStackSize = 10;
        while (curr && curr['arguments'] && stack.length < maxStackSize) {
            fn = fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON;
            args = Array.prototype.slice.call(curr['arguments'] || []);
            stack[stack.length] = fn + '(' + this.stringifyArguments(args) + ')';
            curr = curr.caller;
        }
        return stack;
    },

    /**
     * Given arguments array as a String, subsituting type names for
     * non-string types.
     *
     * @param {Arguments} args
     * @return {Array} of Strings with stringified arguments
     */
    stringifyArguments : function(args) {
        var result = [];
        var slice = Array.prototype.slice;
        for ( var i = 0; i < args.length; ++i) {
            var arg = args[i];
            if (arg === undefined) {
                result[i] = 'undefined';
            } else if (arg === null) {
                result[i] = 'null';
            } else if (arg.constructor) {
                if (arg.constructor === Array) {
                    if (arg.length < 3) {
                        result[i] = '[' + this.stringifyArguments(arg) + ']';
                    } else {
                        result[i] = '[' + this.stringifyArguments(slice.call(arg, 0, 1)) + '...' + this.stringifyArguments(slice.call(arg, -1)) + ']';
                    }
                } else if (arg.constructor === Object) {
                    result[i] = '#object';
                } else if (arg.constructor === Function) {
                    result[i] = '#function';
                } else if (arg.constructor === String) {
                    result[i] = '"' + arg + '"';
                } else if (arg.constructor === Number) {
                    result[i] = arg;
                }
            }
        }
        return result.join(',');
    },

    sourceCache : {},

    /**
     * @return the text from a given URL
     */
    ajax : function(url) {
        var req = this.createXMLHTTPObject();
        if (req) {
            try {
                req.open('GET', url, false);
                // req.overrideMimeType('text/plain');
                // req.overrideMimeType('text/javascript');
                req.send(null);
                // return req.status == 200 ? req.responseText : '';
                return req.responseText;
            } catch (e) {
            }
        }
        return '';
    },

    /**
     * Try XHR methods in order and store XHR factory.
     *
     * @return <Function> XHR function or equivalent
     */
    createXMLHTTPObject : function() {
        var xmlhttp, XMLHttpFactories = [ function() {
            return new XMLHttpRequest();
        }, function() {
            return new ActiveXObject('Msxml2.XMLHTTP');
        }, function() {
            return new ActiveXObject('Msxml3.XMLHTTP');
        }, function() {
            return new ActiveXObject('Microsoft.XMLHTTP');
        } ];
        for ( var i = 0; i < XMLHttpFactories.length; i++) {
            try {
                xmlhttp = XMLHttpFactories[i]();
                // Use memoization to cache the factory
                this.createXMLHTTPObject = XMLHttpFactories[i];
                return xmlhttp;
            } catch (e) {
            }
        }
    },

    /**
     * Given a URL, check if it is in the same domain (so we can get the
     * source via Ajax).
     *
     * @param url <String> source url
     * @return False if we need a cross-domain request
     */
    isSameDomain : function(url) {
        return typeof location !== "undefined" && url.indexOf(location.hostname) !== -1; // location
                                                                                            // may
                                                                                            // not
                                                                                            // be
                                                                                            // defined,
                                                                                            // e.g.
                                                                                            // when
                                                                                            // running
                                                                                            // from
                                                                                            // nodejs.
    },

    /**
     * Get source code from given URL if in the same domain.
     *
     * @param url <String> JS source URL
     * @return <Array> Array of source code lines
     */
    getSource : function(url) {
        // TODO reuse source from script tags?
        if (!(url in this.sourceCache)) {
            this.sourceCache[url] = this.ajax(url).split('\n');
        }
        return this.sourceCache[url];
    },

    guessAnonymousFunctions : function(stack) {
        for ( var i = 0; i < stack.length; ++i) {
            var reStack = /\{anonymous\}\(.*\)@(.*)/, reRef = /^(.*?)(?::(\d+))(?::(\d+))?(?: -- .+)?$/, frame = stack[i], ref = reStack.exec(frame);

            if (ref) {
                var m = reRef.exec(ref[1]);
                if (m) { // If falsey, we did not get any file/line
                            // information
                    var file = m[1], lineno = m[2], charno = m[3] || 0;
                    if (file && this.isSameDomain(file) && lineno) {
                        var functionName = this.guessAnonymousFunction(file, lineno, charno);
                        stack[i] = frame.replace('{anonymous}', functionName);
                    }
                }
            }
        }
        return stack;
    },

    guessAnonymousFunction : function(url, lineNo, charNo) {
        var ret;
        try {
            ret = this.findFunctionName(this.getSource(url), lineNo);
        } catch (e) {
            ret = 'getSource failed with url: ' + url + ', exception: ' + e.toString();
        }
        return ret;
    },

    findFunctionName : function(source, lineNo) {
        // FIXME findFunctionName fails for compressed source
        // (more than one function on the same line)
        // TODO use captured args
        // function {name}({args}) m[1]=name m[2]=args
        var reFunctionDeclaration = /function\s+([^(]*?)\s*\(([^)]*)\)/;
        // {name} = function ({args}) TODO args capture
        // /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*function(?:[^(]*)/
        var reFunctionExpression = /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*function\b/;
        // {name} = eval()
        var reFunctionEvaluation = /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*(?:eval|new Function)\b/;
        // Walk backwards in the source lines until we find
        // the line which matches one of the patterns above
        var code = "", line, maxLines = Math.min(lineNo, 20), m, commentPos;
        for ( var i = 0; i < maxLines; ++i) {
            // lineNo is 1-based, source[] is 0-based
            line = source[lineNo - i - 1];
            commentPos = line.indexOf('//');
            if (commentPos >= 0) {
                line = line.substr(0, commentPos);
            }
            // TODO check other types of comments? Commented code may lead to false positive
            if (line) {
                code = line + code;
                m = reFunctionExpression.exec(code);
                if (m && m[1]) {
                    return m[1];
                }
                m = reFunctionDeclaration.exec(code);
                if (m && m[1]) {
                    //return m[1] + "(" + (m[2] || "") + ")";
                    return m[1];
                }
                m = reFunctionEvaluation.exec(code);
                if (m && m[1]) {
                    return m[1];
                }
            }
        }
        return '(?)';
    }
};

module.exports = printStackTrace;
},{}],52:[function(require,module,exports){

var StateMachine = {

    //---------------------------------------------------------------------------

    VERSION: "2.2.0",

    //---------------------------------------------------------------------------

    Result: {
      SUCCEEDED:    1, // the event transitioned successfully from one state to another
      NOTRANSITION: 2, // the event was successfull but no state transition was necessary
      CANCELLED:    3, // the event was cancelled by the caller in a beforeEvent callback
      ASYNC:        4 // the event is asynchronous and the caller is in control of when the transition occurs
    },

    Error: {
      INVALID_TRANSITION: 100, // caller tried to fire an event that was innapropriate in the current state
      PENDING_TRANSITION: 200, // caller tried to fire an event while an async transition was still pending
      INVALID_CALLBACK:   300 // caller provided callback function threw an exception
    },

    WILDCARD: '*',
    ASYNC: 'async',

    //---------------------------------------------------------------------------

    create: function(cfg, target) {

      var initial   = (typeof cfg.initial == 'string') ? { state: cfg.initial } : cfg.initial; // allow for a simple string, or an object with { state: 'foo', event: 'setup', defer: true|false }
      var fsm       = target || cfg.target  || {};
      var events    = cfg.events || [];
      var callbacks = cfg.callbacks || {};
      var map       = {};

      var add = function(e) {
        var from = (e.from instanceof Array) ? e.from : (e.from ? [e.from] : [StateMachine.WILDCARD]); // allow 'wildcard' transition if 'from' is not specified
        map[e.name] = map[e.name] || {};
        for (var n = 0 ; n < from.length ; n++)
          map[e.name][from[n]] = e.to || from[n]; // allow no-op transition if 'to' is not specified
      };

      if (initial) {
        initial.event = initial.event || 'startup';
        add({ name: initial.event, from: 'none', to: initial.state });
      }

      for(var n = 0 ; n < events.length ; n++)
        add(events[n]);

      for(var name in map) {
        if (map.hasOwnProperty(name))
          fsm[name] = StateMachine.buildEvent(name, map[name]);
      }

      for(var name in callbacks) {
        if (callbacks.hasOwnProperty(name))
          fsm[name] = callbacks[name]
      }

      fsm.current = 'none';
      fsm.is      = function(state) { return this.current == state; };
      fsm.can     = function(event) { return !this.transition && (map[event].hasOwnProperty(this.current) || map[event].hasOwnProperty(StateMachine.WILDCARD)); }
      fsm.cannot  = function(event) { return !this.can(event); };
      fsm.error   = cfg.error || function(name, from, to, args, error, msg, e) { throw e || msg; }; // default behavior when something unexpected happens is to throw an exception, but caller can override this behavior if desired (see github issue #3 and #17)

      if (initial && !initial.defer)
        fsm[initial.event]();

      return fsm;

    },

    //===========================================================================

    doCallback: function(fsm, func, name, from, to, args) {
      if (func) {
        try {
          return func.apply(fsm, [name, from, to].concat(args));
        }
        catch(e) {
          return fsm.error(name, from, to, args, StateMachine.Error.INVALID_CALLBACK, "an exception occurred in a caller-provided callback function", e);
        }
      }
    },

    beforeEvent: function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onbefore' + name],                     name, from, to, args); },
    afterEvent:  function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onafter'  + name] || fsm['on' + name], name, from, to, args); },
    leaveState:  function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onleave'  + from],                     name, from, to, args); },
    enterState:  function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onenter'  + to]   || fsm['on' + to],   name, from, to, args); },
    changeState: function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onchangestate'],                       name, from, to, args); },


    buildEvent: function(name, map) {
      return function() {

        var from  = this.current;
        var to    = map[from] || map[StateMachine.WILDCARD] || from;
        var args  = Array.prototype.slice.call(arguments); // turn arguments into pure array

        if (this.transition)
          return this.error(name, from, to, args, StateMachine.Error.PENDING_TRANSITION, "event " + name + " inappropriate because previous transition did not complete");

        if (this.cannot(name))
          return this.error(name, from, to, args, StateMachine.Error.INVALID_TRANSITION, "event " + name + " inappropriate in current state " + this.current);

        if (false === StateMachine.beforeEvent(this, name, from, to, args))
          return StateMachine.Result.CANCELLED;

        if (from === to) {
          StateMachine.afterEvent(this, name, from, to, args);
          return StateMachine.Result.NOTRANSITION;
        }

        // prepare a transition method for use EITHER lower down, or by caller if they want an async transition (indicated by an ASYNC return value from leaveState)
        var fsm = this;
        this.transition = function() {
          fsm.transition = null; // this method should only ever be called once
          fsm.current = to;
          StateMachine.enterState( fsm, name, from, to, args);
          StateMachine.changeState(fsm, name, from, to, args);
          StateMachine.afterEvent( fsm, name, from, to, args);
        };
        this.transition.cancel = function() { // provide a way for caller to cancel async transition if desired (issue #22)
          fsm.transition = null;
          StateMachine.afterEvent(fsm, name, from, to, args);
        };

        var leave = StateMachine.leaveState(this, name, from, to, args);
        if (false === leave) {
          this.transition = null;
          return StateMachine.Result.CANCELLED;
        }
        else if ("async" === leave) {
          return StateMachine.Result.ASYNC;
        }
        else {
          if (this.transition)
            this.transition(); // in case user manually called transition() but forgot to return ASYNC
          return StateMachine.Result.SUCCEEDED;
        }

      };
    }

}; // StateMachine

//===========================================================================

/*if ("function" === typeof define) {
define(function(require) { return StateMachine; });
}
else {*/
window.StateMachine = StateMachine;
/*}*/

module.exports = StateMachine;


},{}],53:[function(require,module,exports){
var DOMTransformFetcher = require("../transform-fetcher.js");
var DataAdapter = require("./data.js");
var Base = require("../../xflow/base.js");
var DataNode = require("../../xflow/interface/graph.js").DataNode;
var getComputeDataflowUrl = require("../../xflow/interface/graph.js").getComputeDataflowUrl;
var Asset = require("../../asset/asset.js").Asset;
var SubData = require("../../asset/asset.js").SubData;
var Events = require("../../interface/notification.js");
var dispatchCustomEvent = require("../../utils/misc.js").dispatchCustomEvent;
var Resource = require("../../resource");

var NodeAdapter = require("../../base/adapter.js").NodeAdapter;
var createClass = XML3D.createClass;
var AdapterHandle = require("../../base/adapterhandle.js");


var AssetAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);

    /**
     *  @type Asset
     **/
    this.asset = new Asset(this.node);
    if (node.localName.toLowerCase() !== "model") {
        this.transformFetcher = new DOMTransformFetcher(this, "transform", "transform");
    }
};

createClass(AssetAdapter, NodeAdapter);

AssetAdapter.prototype.init = function () {
    this.asset.addChangeListener(this);
    this.asset.setName(this.node.getAttribute("name"));
    updateAdapterHandle(this, "src", this.node.getAttribute("src"));
    updatePickFilter(this);
    updateChildren(this);
    setMaterialUrl(this, this.asset);
    this.transformFetcher && this.transformFetcher.update();
};

AssetAdapter.prototype.onAssetLoadChange = function (asset, newLevel, oldLevel) {
    if (newLevel == Infinity) {
        dispatchCustomEvent(this.node, 'load', false, true, null);
    } else if (newLevel > oldLevel) {
        dispatchCustomEvent(this.node, 'progress', false, true, null);
    }
};

AssetAdapter.prototype.getAssetComplete = function () {
    return this.asset.getProgressLevel() == Infinity;
};
AssetAdapter.prototype.getAssetProgressLevel = function () {
    return this.asset.getProgressLevel();
};

AssetAdapter.prototype.getAsset = function () {
    return this.asset;
};

function updateChildren(adapter) {
    adapter.asset.clearChildren();
    adapter.asset.clearSubAssets();
    for (var child = adapter.node.firstElementChild; child !== null; child = child.nextElementSibling) {
        var subadapter = adapter.factory.getAdapter(child);
        if (subadapter && subadapter.getAsset) {
            adapter.asset.appendSubAsset(subadapter.getAsset());
        }
        if (subadapter && subadapter.assetEntry) {
            adapter.asset.appendChild(subadapter.assetEntry);
        }
    }
}

function updateAdapterHandle(adapter, key, url) {
    var adapterHandle = adapter.getAdapterHandle(url), status = (adapterHandle && adapterHandle.status);

    if (status === AdapterHandle.STATUS.NOT_FOUND) {
        XML3D.debug.logError("Could not find element of url '" + adapterHandle.url + "' for " + key, adapter.node);
    }
    adapter.connectAdapterHandle(key, adapterHandle);
    adapter.connectedAdapterChanged(key, adapterHandle ? adapterHandle.getAdapter() : null, status);
}

function updateAssetLoadState(dataAdapter) {
    var loading = false, handle;

    handle = dataAdapter.getConnectedAdapterHandle("src");
    if (handle && handle.status === AdapterHandle.STATUS.LOADING) {
        loading = true;
    }
    dataAdapter.asset.setLoading(loading);
}

function updatePickFilter(adapter) {
    if (!adapter.node.hasAttribute("pick"))
        adapter.asset.setPickFilter(null); else {
        var value = adapter.node.getAttribute("pick");
        adapter.asset.setPickFilter(value);
    }
}

AssetAdapter.prototype.connectedAdapterChanged = function (attributeName, adapter) {
    if (attributeName == "src")
        this.asset.setSrcAsset(adapter && adapter.getAsset() || null);
    updateAssetLoadState(this);
};

AssetAdapter.prototype.onTransformChange = function (attrName, matrix) {
    this.asset.setTransform(matrix);
};

AssetAdapter.prototype.attributeChangedCallback = function(name, oldValue, newValue) {
        switch (name) {
            case "name":
                this.asset.setName(newValue);
                break;
            case "material":
                setMaterialUrl(this, this.asset);
                break;
            case "style":
            case "transform":
                this.transformFetcher && this.transformFetcher.update();
                break;
            case "src":
                updateAdapterHandle(this, "src", newValue);
                break;
            case "pick":
                updatePickFilter(this);
                break;
        }
};


AssetAdapter.prototype.notifyChanged = function (evt) {
    if (evt.type == Events.ADAPTER_HANDLE_CHANGED) {
        this.connectedAdapterChanged(evt.key, evt.adapter);
        if (evt.handleStatus == AdapterHandle.STATUS.NOT_FOUND) {
            XML3D.debug.logError("Could not find <asset> element of url '" + evt.url + "' for " + evt.key);
        }
    } else if (evt.type == Events.NODE_INSERTED) {
        updateChildren(this);

    } else if (evt.type == Events.NODE_REMOVED) {
        updateChildren(this);

    }  else if (evt.type == Events.THIS_REMOVED) {
        this.clearAdapterHandles();
        this.asset.removeChangeListener(this);
    }
};

var AssetDataAdapter = function (factory, node) {
    this.assetData = true;
    DataAdapter.call(this, factory, node);

    // Node handles for src and proto
    this.assetEntry = null;
    this.outputXflowNode = null;
};
createClass(AssetDataAdapter, DataAdapter);

AssetDataAdapter.prototype.init = function () {
    DataAdapter.prototype.init.call(this);
    this.outputXflowNode = new AssetDataNode(false);
    this.assetEntry = new SubData(this.outputXflowNode, this.getXflowNode(), this.node);
    this.assetEntry.setName(this.node.getAttribute("name"));
    updateClassNames(this);
    updatePostCompute(this);
    this.assetEntry.setPostFilter(this.node.getAttribute("filter"));
    updateIncludes(this.assetEntry, this.node.getAttribute("includes"));
};

AssetDataAdapter.prototype.connectedAdapterChanged = function (attributeName, adapter) {
    if (attributeName == "postDataflow") {
        this.assetEntry.setPostDataflow(adapter && adapter.getXflowNode() || null);
        updateSubDataLoadState(this);
    } else {
        DataAdapter.prototype.connectedAdapterChanged.call(this, attributeName, adapter);
    }
};

AssetDataAdapter.prototype.attributeChangedCallback = function (name, oldValue, newValue) {
    DataAdapter.prototype.attributeChangedCallback.call(this, name, oldValue, newValue);
    switch (name) {
        case "name":
            this.assetEntry.setName(newValue);
            break;
        case "compute":
            updatePostCompute(this);
            break;
        case "class":
            updateClassNames(this);
            break;
        case "filter":
            this.assetEntry.setPostFilter(newValue);
            break;
        case "includes":
            updateIncludes(newValue);
            break;
    }
};

AssetDataAdapter.prototype.notifyChanged = function (evt) {
    DataAdapter.prototype.notifyChanged.call(this, evt);

};

AssetDataAdapter.prototype.onTransformChange = function (attrName, matrix) {
    this.assetEntry.setTransform(matrix);
};

function updateIncludes(assetEntry, includeString) {
    if (!includeString)
        assetEntry.setIncludes([]); else
        assetEntry.setIncludes(includeString.trim().split(/\s*,\s*/));
}

function updateClassNames(adapter) {
    var classNames = adapter.node.getAttribute("class");
    adapter.assetEntry.setClassNamesString(classNames)
}

function updatePostCompute(adapter) {
    var computeString = adapter.node.getAttribute("compute");
    var dataflowUrl = getComputeDataflowUrl(computeString);
    if (dataflowUrl) {
        updateAdapterHandle(adapter, "postDataflow", dataflowUrl);
    } else {
        adapter.disconnectAdapterHandle("postDataflow");
        updateSubDataLoadState(adapter);
    }
    adapter.assetEntry.setPostCompute(computeString);
}

function updateSubDataLoadState(dataAdapter) {
    var loading = false, handle;

    handle = dataAdapter.getConnectedAdapterHandle("postDataflow");
    if (handle && handle.status === AdapterHandle.STATUS.LOADING) {
        loading = true;
    }
    dataAdapter.assetEntry.setLoading(loading);
}


/**
 *
 * @param adapter
 * @param {Asset} dest
 */
function setMaterialUrl(adapter, dest) {
    var node = adapter.node;
    var materialURL = node.getAttribute("material");
    if (materialURL) {
        var materialAbsoluteURL = Resource.getAbsoluteURI(node.ownerDocument._documentURL || node.ownerDocument.URL, materialURL);
        dest.setMaterial(materialAbsoluteURL.toString());
    } else {
        dest.setMaterial(null);
    }
}

var AssetMeshAdapter = function (factory, node) {
    AssetDataAdapter.call(this, factory, node);
    this.transformFetcher = new DOMTransformFetcher(this, "transform", "transform");
};
createClass(AssetMeshAdapter, AssetDataAdapter, {

    init: function () {
        AssetDataAdapter.prototype.init.call(this);
        setMaterialUrl(this, this.assetEntry);
        this.assetEntry.setMeshType(this.node.getAttribute("type") || "triangles");
        this.assetEntry.setMatchFilter(this.node.getAttribute("match"));
        this.transformFetcher.update();
        this.updateVisibility();
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        AssetDataAdapter.prototype.attributeChangedCallback.call(this, name, oldValue, newValue);
        switch (name) {
            case "material":
                setMaterialUrl(this, this.assetEntry);
                break;
            case "match":
                this.assetEntry.setMatchFilter(newValue);
                break;
            case "style":
            case "transform":
                this.transformFetcher.update();
                this.updateVisibility();
                break;
            case "type":
                this.assetEntry.setMeshType(newValue || "triangles")
        }
    },

    notifyChanged: function (evt) {
        AssetDataAdapter.prototype.notifyChanged.call(this, evt);
    },

    updateVisibility: function () {
        if (!this.node.style) {
            this.node.style = window.getComputedStyle(this.node);
        }
        var none = this.node.style.display == "none";
        this.assetEntry && this.assetEntry.setVisibility(!none);
    }
});

/**
 * This is just a small wrapper to identify Xflow nodes that were created by an Asset, eg as part of overrides
 * that need to be cleaned up later if the corresponding model tag is destroyed
 * @param isDataFlow
 * @constructor
 */
var AssetDataNode = function(isDataFlow) {
    DataNode.call(this, isDataFlow);
    this.isAssetDataNode = true;
};

Base.createClass(AssetDataNode, DataNode);

module.exports = {
    AssetAdapter: AssetAdapter, AssetMeshAdapter: AssetMeshAdapter, AssetDataAdapter: AssetDataAdapter
};

},{"../../asset/asset.js":47,"../../base/adapter.js":48,"../../base/adapterhandle.js":49,"../../interface/notification.js":74,"../../resource":165,"../../utils/misc.js":182,"../../xflow/base.js":186,"../../xflow/interface/graph.js":189,"../transform-fetcher.js":66,"./data.js":56}],54:[function(require,module,exports){
var ComputeRequest = require("../../xflow/interface/request.js").ComputeRequest;
var setShaderConstant = require("../../xflow/processing/vs-connect.js").setShaderConstant;
var registerErrorCallback = require("../../xflow/base.js").registerErrorCallback;
var XC = require("../../xflow/interface/constants.js");
var URI = require("../../utils/uri.js").URI;

var NodeAdapter = require("../../base/adapter.js").NodeAdapter;
var createClass = XML3D.createClass;

/**
 * @extends NodeAdapter
 * @abstract
 *
 * @param factory
 * @param node
 */
var BaseDataAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
    this.xflowDataNode = null;
};
createClass(BaseDataAdapter, NodeAdapter);


BaseDataAdapter.prototype.getXflowNode = function () {
    return this.xflowDataNode;
};

BaseDataAdapter.prototype.getComputeRequest = function (filter, callback) {
    return new ComputeRequest(this.xflowDataNode, filter, callback);
};

BaseDataAdapter.prototype.getComputeResult = function (filter) {
    return this.xflowDataNode._getResult(XC.RESULT_TYPE.COMPUTE, filter);
};

BaseDataAdapter.prototype.getOutputNames = function () {
    return this.xflowDataNode.getOutputNames();
};

BaseDataAdapter.prototype.getOutputChannelInfo = function (name) {
    return this.xflowDataNode.getOutputChannelInfo(name);
};

setShaderConstant(XC.SHADER_CONSTANT_KEY.OBJECT_ID, "objectID");
setShaderConstant(XC.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM, "modelViewProjectionMatrix");
setShaderConstant(XC.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM_NORMAL, "modelViewProjectionNormalMatrix");
setShaderConstant(XC.SHADER_CONSTANT_KEY.VIEW_TRANSFORM, "modelViewMatrix");
setShaderConstant(XC.SHADER_CONSTANT_KEY.VIEW_TRANSFORM_NORMAL, "modelViewMatrixN");
setShaderConstant(XC.SHADER_CONSTANT_KEY.WORLD_TRANSFORM, "modelMatrix");
registerErrorCallback(function(message, xflowNode){
    message = "Xflow: " + message;
    var userData = xflowNode ? xflowNode.userData : null;
    if (userData && userData.ownerDocument) {
        if (userData.ownerDocument === document) {
            XML3D.debug.logError(message, userData);
        }
        else if (userData.id) {
            var uri = new URI("#" + userData.id);
            uri = uri.getAbsoluteURI(userData.ownerDocument._documentURL || userData.ownerDocument.URL);
            XML3D.debug.logError(message, "External Node: " + uri);
        }
        else {
            XML3D.debug.logError(message, "External Document: " + userData.ownerDocument.URL);
        }
    }
    else if (typeof userData == "string") {
        XML3D.debug.logError(message, userData);
    }
    else {
        XML3D.debug.logError(message);
    }
});

module.exports = BaseDataAdapter;

},{"../../base/adapter.js":48,"../../utils/uri.js":184,"../../xflow/base.js":186,"../../xflow/interface/constants.js":187,"../../xflow/interface/request.js":190,"../../xflow/processing/vs-connect.js":237}],55:[function(require,module,exports){
var Events = require("../../interface/notification.js");
var NodeAdapter = require("../../base/adapter.js").NodeAdapter;

/**
 * DataAdapter handling a <compute> element
 * @param {AdapterFactory} factory
 * @param {Element} node
 * @constructor
 */
var ComputeDataAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
};
XML3D.createClass(ComputeDataAdapter, NodeAdapter);

ComputeDataAdapter.prototype.getComputeCode = function () {
    return this.node.value;
};

/**
 * @param evt notification of type XML3D.Notification
 */
ComputeDataAdapter.prototype.notifyChanged = function (evt) {
    switch (evt.type) {
        case Events.VALUE_MODIFIED:
        case Events.NODE_INSERTED:
        case Events.NODE_REMOVED:
            var parent = this.node.parentNode;
            if (parent) {
                var parentAdapter = this.factory.getAdapter(parent);
                parentAdapter && parentAdapter.updateXflowNode();
            }
    }
};

module.exports = ComputeDataAdapter;

},{"../../base/adapter.js":48,"../../interface/notification.js":74}],56:[function(require,module,exports){
var BaseDataAdapter = require("./base.js");
var DataNode = require("../../xflow/interface/graph.js").DataNode;
var XC = require("../../xflow/interface/constants.js");
var Events = require("../../interface/notification.js");
var dispatchCustomEvent = require("../../utils/misc.js").dispatchCustomEvent;
var AdapterHandle = require("../../base/adapterhandle.js");
var Base = require("../../xflow/base.js");

/**
 * The DataAdapter implements the
 * DataCollector concept and serves as basis of all DataAdapter classes. In
 * general, a DataAdapter is associated with an element node which uses
 * generic data and should be instantiated via
 * XML3DDataAdapterFactory to ensure proper functionality.
 *
 * @extends Adapter
 * @constructor
 *
 * @param factory
 * @param node
 */
var DataAdapter = function (factory, node) {
    BaseDataAdapter.call(this, factory, node);
    // Node handles for src and proto
    this.xflowDataNode = null;
    this.externalScripts = {};
};
XML3D.createClass(DataAdapter, BaseDataAdapter);

DataAdapter.prototype.init = function () {
    this.xflowDataNode = new DataNode(false);
    this.xflowDataNode.addLoadListener(this.onXflowLoadEvent.bind(this));
    this.xflowDataNode.userData = this.node;

    this.srcDataNode = new DataNode(false);
    this.xflowDataNode.appendChild(this.srcDataNode);

    // Setting platform and node type information for a data sequence
    this.xflowDataNode.setPlatform(this.node.getAttribute("platform"));

    this.updateAdapterHandle("src", this.node.getAttribute("src"));
    if(!this.assetData){
        this.xflowDataNode.setFilter(this.node.getAttribute("filter"));
        updateCompute(this);
    }
    recursiveDataAdapterConstruction(this);
};

DataAdapter.prototype.updateAdapterHandle = function(key, url) {
    var oldAdapterHandle = this.getConnectedAdapterHandle(key);

    var adapterHandle = this.getAdapterHandle(url),
        status = (adapterHandle && adapterHandle.status);

    if(oldAdapterHandle == adapterHandle)
        return;
    if (status === AdapterHandle.STATUS.NOT_FOUND) {
        XML3D.debug.logError("Could not find element of url '" + adapterHandle.url + "' for " + key, this.node);
    }
    this.connectAdapterHandle(key, adapterHandle);
    this.connectedAdapterChanged(key, adapterHandle ? adapterHandle.getAdapter() : null, status);
};

DataAdapter.prototype.onXflowLoadEvent = function(node, newLevel, oldLevel){
    if(newLevel == Infinity){
        dispatchCustomEvent(this.node, 'load', false, true, null);
    }
    else if(newLevel > oldLevel){
        dispatchCustomEvent(this.node, 'progress', false, true, null);
    }
};
DataAdapter.prototype.getDataComplete = function(){
    return this.xflowDataNode.getProgressLevel() == Infinity;
};
DataAdapter.prototype.getDataProgressLevel = function(){
    return this.xflowDataNode.getProgressLevel();
};

    /** Recursively passing platform information to children of a data node
     *  Requires that the children and the parents of data nodes are defined
     *
     * @param {DataNode} parentNode
     */
function recursiveDataNodeAttrInit(parentNode) {
    var children = parentNode._children, NChildren, i;

    if (children && children.length > 0) {
        NChildren = children.length;

        for (i = NChildren; i--;) {
            if (children[i] instanceof DataNode) {
                children[i].setPlatform(parentNode._platform);
                recursiveDataNodeAttrInit(children[i]);
            }
        }
    }
}

function recursiveDataAdapterConstruction(adapter) {
    for (var child = adapter.node.firstElementChild; child !== null; child = child.nextElementSibling) {
        var subadapter = adapter.factory.getAdapter(child);
        if (subadapter) {
            if (subadapter.getXflowNode) {
                adapter.xflowDataNode.appendChild(subadapter.getXflowNode());
            } else if (subadapter.getScriptType) {
                var scriptId = subadapter.node.name;
                if (!scriptId) {
                    XML3D.debug.logError("Parsing error: Externally referenced operators must have a 'name' attribute matching the name they were registered with. ", subadapter.node);
                    scriptId = "unknown_operator";
                }
                adapter.externalScripts[scriptId] = subadapter;
                if (subadapter.connectedAdapterHandle) {
                    adapter.connectAdapterHandle(scriptId, subadapter.connectedAdapterHandle);
                }
                adapter.xflowDataNode.setLoading(true);
            }
            // Passes _platform values to children nodes starting from the node
            // where these attributes are first defined
            if (adapter.xflowDataNode._platform !== null) {
                recursiveDataNodeAttrInit(adapter.xflowDataNode);
            }
        }
    }
}

/**
 * The notifyChanged() method is called by the XML3D data structure to
 * notify the DataAdapter about data changes (DOM mustation events) in its
 * associating node. When this method is called, all observers of the
 * DataAdapter are notified about data changes via their notifyDataChanged()
 * method.
 *
 * @param evt notification of type XML3D.Notification
 */
DataAdapter.prototype.notifyChanged = function (evt) {
    if (evt.type === Events.ADAPTER_HANDLE_CHANGED) {
        this.connectedAdapterChanged(evt.key, evt.adapter, evt.handleStatus);
        if (evt.handleStatus === AdapterHandle.STATUS.NOT_FOUND) {
            XML3D.debug.logError("Could not find <data> element of url '" + evt.url + "' for " + evt.key, this.node);
        }

    } else if (evt.type === Events.NODE_INSERTED) {
        var insertedNode = evt.affectedNode;
        var adapter = this.factory.getAdapter(insertedNode);
        if (!adapter) {
            return;
        }

        var insertedXflowNode = adapter.getXflowNode();
        var sibling = insertedNode, followUpAdapter = null;

        do {
            sibling = sibling.nextSibling;
        } while (sibling && !(followUpAdapter = this.factory.getAdapter(sibling)));

        if (followUpAdapter) {
            this.xflowDataNode.insertBefore(insertedXflowNode, followUpAdapter.getXflowNode());
        } else {
            this.xflowDataNode.appendChild(insertedXflowNode);
        }

    } else if (evt.type === Events.NODE_REMOVED) {
        var adapter = this.factory.getAdapter(evt.affectedNode);
        if (!adapter) {
            return;
        }

        var removedXflowNode = adapter.getXflowNode();
        this.xflowDataNode.removeChild(removedXflowNode);

    } else if (evt.type === Events.THIS_REMOVED) {
        this.clearAdapterHandles();
        this.xflowDataNode.clear();
        delete this.srcDataNode;
        delete this.node;
    }
};

DataAdapter.prototype.attributeChangedCallback = function (name, oldValue, newValue) {
    if (name === "filter" && !this.assetData) {
        this.xflowDataNode.setFilter(newValue);
    } else if (name === "compute" && !this.assetData) {
        updateCompute(this);
    } else if (name === "src") {
        this.updateAdapterHandle(name, newValue);
    } else if (name === "platform") {
        updatePlatform(this);
    }
};

DataAdapter.prototype.connectedAdapterChanged = function (key, adapter /*, status */) {
    if (key === "src") {
        this.srcDataNode.sourceNode = adapter ? adapter.getXflowNode() : null;
    } else if (key === "dataflow") {
        this.xflowDataNode.dataflowNode = adapter ? adapter.getXflowNode() : null;
    } else if (this.externalScripts[key]) {
        window.eval(adapter.script);
        this.xflowDataNode.notify(XC.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    }
    // Cycle the load state to force a load event even if the new sourceNode is cached
    this.xflowDataNode.setLoading(true);
    updateLoadState(this);
};

/**
 * Returns String representation of this DataAdapter
 */
DataAdapter.prototype.toString = function () {
    return "DataAdapter";
};

function updateCompute(dataAdapter) {
    var xflowNode = dataAdapter.xflowDataNode;
    xflowNode.setCompute(dataAdapter.node.getAttribute("compute"));
    if (xflowNode.computeDataflowUrl) {
        dataAdapter.updateAdapterHandle("dataflow", xflowNode.computeDataflowUrl);
    }
    else {
        dataAdapter.disconnectAdapterHandle("dataflow");
        updateLoadState(dataAdapter);
    }
}

function updatePlatform(dataAdapter) {
    var xflowNode = dataAdapter.xflowDataNode;

    xflowNode.setPlatform(dataAdapter.node.getAttribute("platform"));
    recursiveDataNodeAttrInit(xflowNode);
}

function updateLoadState(dataAdpater) {
    var loading = false, handle;

    handle = dataAdpater.getConnectedAdapterHandle("src");
    if (handle && handle.status === AdapterHandle.STATUS.LOADING) {
        loading = true;
    }

    handle = dataAdpater.getConnectedAdapterHandle("dataflow");
    if (handle && handle.status === AdapterHandle.STATUS.LOADING) {
        loading = true;
    }

    for (var name in dataAdpater.externalScripts) {
        handle = dataAdpater.getConnectedAdapterHandle(name);
        if (handle && handle.status === AdapterHandle.STATUS.LOADING) {
            loading = true;
        }
    }

    dataAdpater.xflowDataNode.setLoading(loading);
}


module.exports = DataAdapter;



},{"../../base/adapterhandle.js":49,"../../interface/notification.js":74,"../../utils/misc.js":182,"../../xflow/base.js":186,"../../xflow/interface/constants.js":187,"../../xflow/interface/graph.js":189,"./base.js":54}],57:[function(require,module,exports){
var BaseDataAdapter = require("./base.js");
var DataNode = require("../../xflow/interface/graph.js").DataNode;
var XC = require("../../xflow/interface/constants.js");
var Events = require("../../interface/notification.js");
var AdapterHandle = require("../../base/adapterhandle.js");
var Base = require("../../xflow/base.js");

/**
 * DataAdapter handling a <dataflow> element
 * @param factory
 * @param node
 * @constructor
 */
var DataflowDataAdapter = function (factory, node) {
    BaseDataAdapter.call(this, factory, node);
    this.xflowDataNode = null;
    this.externalScripts = {};
};
XML3D.createClass(DataflowDataAdapter, BaseDataAdapter);

DataflowDataAdapter.prototype.init = function () {
    this.xflowDataNode = new DataNode(false);
    this.dataflowRefs = [];
    updateDataflowXflowNode(this, this.node);
};

DataflowDataAdapter.prototype.updateAdapterHandle = function(key, url) {
    var oldAdapterHandle = this.getConnectedAdapterHandle(key);

    var adapterHandle = this.getAdapterHandle(url),
        status = (adapterHandle && adapterHandle.status);

    if(oldAdapterHandle == adapterHandle)
        return;
    if (status === AdapterHandle.STATUS.NOT_FOUND) {
        XML3D.debug.logError("Could not find element of url '" + adapterHandle.url + "' for " + key, this.node);
    }
    this.connectAdapterHandle(key, adapterHandle);
    this.connectedAdapterChanged(key, adapterHandle ? adapterHandle.getAdapter() : null, status);
};


/**
 * @param evt notification of type XML3D.Notification
 */
DataflowDataAdapter.prototype.notifyChanged = function (evt) {
    if (evt.type === Events.ADAPTER_HANDLE_CHANGED) {
        //TODO: Handle ADAPTER_HANDLE_CHANGED
        if (this.externalScripts[evt.key]) {
            window.eval(evt.adapter.script);
            setLoadingStateForMatchingXflowNodes(this.xflowDataNode, evt.key, false);
            this.xflowDataNode.notify(XC.RESULT_STATE.CHANGED_STRUCTURE);
            Base._flushResultCallbacks();
        }
    }

    switch (evt.type) {
        case Events.ADAPTER_HANDLE_CHANGED:
            this.connectedAdapterChanged(evt.key, evt.adapter, evt.handleStatus);
            if (evt.handleStatus === AdapterHandle.STATUS.NOT_FOUND) {
                XML3D.debug.logError("Could not find dataflow of url '" + evt.url, this.node);
            }
            break;

        case Events.NODE_INSERTED:
        case Events.NODE_REMOVED:
            updateDataflowXflowNode(this);
            break;

        case Events.VALUE_MODIFIED:
            var attr = evt.mutation.attributeName;
            if (attr === "out") {
                updateDataflowOut(this);
            } else if (attr === "platform") {
                updateDataflowXflowNode(this, this.node);
            }
            break;
    }
};

/**
 * Traverse all subnodes of a dataflow and set the loading state of
 * all nodes with a compute operator that relies on the matching external script name.
 * A compute node will only be executed if its loading state is 'false' and none of its children are 'loading', so
 * this ensures we don't do the compute operations until the external operators have been loaded.
 * @param {DataNode} node the current node to check for instances of the given operator
 * @param {string} name the name of the external operator to check for
 * @param {boolean} loading whether the operator has finished loading or not
 */
function setLoadingStateForMatchingXflowNodes(node, name, loading) {
    if (node._computeOperator === name) {
        node.setLoading(loading);
    }
    if (node._children) {
        var i = node._children.length;
        while (i--) {
            setLoadingStateForMatchingXflowNodes(node._children[i], name, loading);
        }
    }
}

DataflowDataAdapter.prototype.updateXflowNode = function () {
    updateDataflowXflowNode(this, this.node);
};

DataflowDataAdapter.prototype.connectedAdapterChanged = function (key, adapter, status) {
    var xflowNode = this.dataflowRefs[key];
    if (xflowNode) {
        xflowNode.dataflowNode = adapter ? adapter.getXflowNode() : null;
        xflowNode.setLoading(status === AdapterHandle.STATUS.LOADING);
    }
};

function updateDataflowOut(adapter) {
    var out = adapter.node.getAttribute("out");
    if (out) {
        adapter.xflowDataNode.setFilter("keep(" + out + ")");
    } else {
        adapter.xflowDataNode.setFilter("");
    }
}

function updateDataflowXflowNode(adapter, node) {
    // Getting platform and node type information for a Dataflow node
    var platform = node.getAttribute("platform");

    adapter.xflowDataNode.setCompute("");
    adapter.clearAdapterHandles();
    adapter.dataflowRefs = [];
    adapter.externalScripts = {};
    updateDataflowOut(adapter);

    var child = node.lastElementChild, firstNode = true, prevNode = null, currentNode = adapter.xflowDataNode, subAdapter, xflowNode;

    do {
        subAdapter = adapter.factory.getAdapter(child);
        if (!subAdapter) {
            continue;
        }

        if (subAdapter.getXflowNode) {
            xflowNode = subAdapter.getXflowNode();

            if (prevNode) {
                currentNode.insertBefore(xflowNode, prevNode);
            } else {
                currentNode.appendChild(xflowNode);
            }
            prevNode = xflowNode;
        } else if (subAdapter.getComputeCode) {
            var statements = subAdapter.getComputeCode().split(";");
            var j = statements.length;

            while (j--) {
                var compute = statements[j].trim();
                if (!compute) {
                    continue;
                }

                if (firstNode) {
                    firstNode = false;
                } else {
                    xflowNode = new DataNode(false);
                    if (prevNode) {
                        currentNode.insertBefore(xflowNode, prevNode);
                    } else {
                        currentNode.appendChild(xflowNode);
                    }
                    currentNode = xflowNode;
                    prevNode = null;
                }
                currentNode.userData = child;

                currentNode.setPlatform(platform);

                currentNode.setCompute(statements[j].trim());

                if (currentNode.computeDataflowUrl) {
                    var idx = adapter.dataflowRefs.length;
                    adapter.dataflowRefs.push(currentNode);
                    adapter.updateAdapterHandle(idx, currentNode.computeDataflowUrl);
                }
            }
        } else if (subAdapter.getScriptType) {
            var scriptId = subAdapter.node.name;
            if (!scriptId) {
                XML3D.debug.logError("Parsing error: Externally referenced operators must have a 'name' attribute matching the name they were registered with. ", subAdapter.node);
                scriptId = "unknown_operator";
            }
            adapter.externalScripts[scriptId] = subAdapter;
            if (subAdapter.connectedAdapterHandle) {
                adapter.connectAdapterHandle(scriptId, subAdapter.connectedAdapterHandle);
            }
        }

    } while (child = child.previousElementSibling);

    for (var name in adapter.externalScripts) {
        // Ensure XFlow doesn't execute any compute nodes that depend on external scripts until they're loaded
        setLoadingStateForMatchingXflowNodes(adapter.xflowDataNode, name, true);
    }
}


module.exports = DataflowDataAdapter;

},{"../../base/adapterhandle.js":49,"../../interface/notification.js":74,"../../xflow/base.js":186,"../../xflow/interface/constants.js":187,"../../xflow/interface/graph.js":189,"./base.js":54}],58:[function(require,module,exports){
var NodeAdapterFactory = require("../../base/adapter.js").NodeAdapterFactory;
var Asset = require("./asset.js");
var Misc = require("./misc.js");
var ScriptDataAdapter = require("./script.js");
var TextureDataAdapter = require("./texture.js");
var TransformDataAdapter = require("./transform.js");
var ValueDataAdapter = require("./values.js");
var DataAdapter = require("./data.js");
var ComputeDataAdapter = require("./compute.js");
var DataflowDataAdapter = require("./dataflow.js");
// Register JSON Handler
require("./json/factory.js");
// Register JavaScript Handler (required for external shade.js Javascript resources)
require("./javascript/factory.js");

/**
 * Constructor of XML3DDataAdapterFactory
 * XML3DDataAdapterFactory creates DataAdapter instances for elements using generic data (<mesh>, <data>, <float>,...).
 * Additionally, it manages all DataAdapter instances so that for each node there is always just one DataAdapter. When
 * it creates a DataAdapter, it calls its init method.
 *
 * @constructor
 * @extends AdapterFactory
 */

var XML3DDataAdapterFactory = function () {
    NodeAdapterFactory.call(this, "data");
};
XML3D.createClass(XML3DDataAdapterFactory, NodeAdapterFactory);

var reg = {
    'mesh': Misc.SinkDataAdapter,
    'material': Misc.SinkDataAdapter,
    'shader': Misc.SinkDataAdapter, // TODO(ksons): Remove in 5.1
    'light': Misc.SinkDataAdapter,
    'view': Misc.SinkDataAdapter,
    'float': ValueDataAdapter,
    'float2': ValueDataAdapter,
    'float3': ValueDataAdapter,
    'float4': ValueDataAdapter,
    'float4x4': ValueDataAdapter,
    'int': ValueDataAdapter,
    'int4': ValueDataAdapter,
    'bool': ValueDataAdapter,
    'byte': ValueDataAdapter,
    'string': ValueDataAdapter,
    'ubyte': ValueDataAdapter,
    'img': Misc.ImgDataAdapter,
    'texture': TextureDataAdapter,
    'data': DataAdapter,
    'proto': DataAdapter,
    'dataflow': DataflowDataAdapter,
    'compute': ComputeDataAdapter,
    'video': Misc.VideoDataAdapter,
    'script': ScriptDataAdapter,
    'transform': TransformDataAdapter,
    'asset': Asset.AssetAdapter,
    'assetdata': Asset.AssetDataAdapter,
    'assetmesh': Asset.AssetMeshAdapter,
    'model': Asset.AssetAdapter
};

/**
 * Creates a DataAdapter associated with the given node.
 *
 * @param node
 *            element node which uses generic data. The supported elements
 *            are listed in the class description above.
 * @returns DataAdapter instance
 */
XML3DDataAdapterFactory.prototype.createAdapter = function (node) {
    //XML3D.debug.logDebug("Creating adapter: " + node.localName);
    var adapterContructor = reg[node.localName];
    if (adapterContructor !== undefined) {
        return new adapterContructor(this, node);
    }
    XML3D.debug.logWarning("Not supported as data element: " + node.localName);
    return null;
};

module.exports =  XML3DDataAdapterFactory;

},{"../../base/adapter.js":48,"./asset.js":53,"./compute.js":55,"./data.js":56,"./dataflow.js":57,"./javascript/factory.js":59,"./json/factory.js":60,"./misc.js":61,"./script.js":62,"./texture.js":63,"./transform.js":64,"./values.js":65}],59:[function(require,module,exports){

var JavaScriptFormatHandler = function () {
    XML3D.resource.FormatHandler.call(this);
};
XML3D.createClass(JavaScriptFormatHandler, XML3D.resource.FormatHandler);

JavaScriptFormatHandler.prototype.isFormatSupported = function (response) {
    return response.headers.get("Content-Type") === "application/javascript";
};


JavaScriptFormatHandler.prototype.getFormatData = function (response) {
    return response.text();
};

JavaScriptFormatHandler.prototype.getAdapter = function(xflowNode, aspect, canvasId) {
    if (aspect === "data") {
        return new ScriptDataAdapter(xflowNode);
    }
    throw new Error("Unsupported aspect '"+aspect+"' encountered in JavaScript format handler.");
};

XML3D.resource.registerFormatHandler(new JavaScriptFormatHandler());


var ScriptDataAdapter = function (script) {
    this.script = script;
};

ScriptDataAdapter.prototype.getScriptType = function () {
    return "application/javascript";
};

ScriptDataAdapter.prototype.getScript= function () {
    return this.script;
};

},{}],60:[function(require,module,exports){
var XC = require("../../../xflow/interface/constants.js");
var InputNode = require("../../../xflow/interface/graph.js").InputNode;
var DataNode = require("../../../xflow/interface/graph.js").DataNode;
var BufferEntry = require("../../../xflow/interface/data.js").BufferEntry;
var AdapterFactory = require("../../../base/adapter.js").AdapterFactory;

var XML3DJSONFormatHandler = function() {
    XML3D.resource.FormatHandler.call(this);
};
XML3D.createClass(XML3DJSONFormatHandler, XML3D.resource.FormatHandler);

XML3DJSONFormatHandler.prototype.isFormatSupported = function(response) {
    if (response.headers.has("Content-Type")) {
        return response.headers.get("Content-Type") === "application/json";
    }
    if (response.url.match(/\.json/)) {
        return true;
    }
};


XML3DJSONFormatHandler.prototype.getFormatData = function(response) {
    return response.json().then(function(json) {
        if (json.format != "xml3d-json")
            throw new Error("Unknown JSON format: " + json.format);
        if (json.version != "0.4.0")
          throw new Error("Unknown JSON version: " + json.version);

        return json;
    });
};

XML3DJSONFormatHandler.prototype.getAdapter = function(data, aspect, canvasId) {
    if (aspect === "data" || aspect === "scene") {
        return new JSONDataAdapter(createXflowNode(data, aspect));
    }
    throw new Error("Unsupported aspect '"+aspect+"' encountered in JSON format handler.");
};

XML3D.resource.registerFormatHandler(new XML3DJSONFormatHandler());


var empty = function() {};

var TYPED_ARRAY_MAP = {
    "int" : Int32Array,
    "int4" : Int32Array,
    "float" : Float32Array,
    "float2" : Float32Array,
    "float3" : Float32Array,
    "float4" : Float32Array,
    "float4x4" : Float32Array,
    "bool" : Uint8Array,
    "byte" : Int8Array,
    "ubyte" : Uint8Array,
    "string": Array
};

var isLittleEndian = (function () {
    var buf = new ArrayBuffer(4);
    var dv = new DataView(buf);
    var view = new Int32Array(buf);
    view[0] = 0x01020304;
    var littleEndian = (dv.getInt32(0, true) === 0x01020304);
    return function () { return littleEndian; }
})();

function realTypeOf(obj) {
    return Object.prototype.toString.call(obj).slice(8, -1);
}

function createXflowValue(dataNode, dataType, name, key, value) {
    var v = new (TYPED_ARRAY_MAP[dataType])(value);
    var type = XC.DATA_TYPE.fromString(dataType);
    var buffer = new BufferEntry(type, v);

    var inputNode = new InputNode();
    inputNode.data = buffer;
    inputNode.name = name;
    inputNode.key = key;
    dataNode.appendChild(inputNode);
}

function createXflowValueFromBuffer(dataNode, dataType, name, key, arrayBuffer, byteOffset, byteLength) {
    var ArrayType = TYPED_ARRAY_MAP[dataType];
    var v = new (ArrayType)(arrayBuffer, byteOffset, byteLength/ArrayType.BYTES_PER_ELEMENT);
    var type = XC.DATA_TYPE.fromString(dataType);
    var buffer = new BufferEntry(type, v);

    var inputNode = new InputNode();
    inputNode.data = buffer;
    inputNode.name = name;
    inputNode.key = key;
    dataNode.appendChild(inputNode);
}

function createXflowInputs(dataNode, name, jsonData){
    var v = null;

    if (!TYPED_ARRAY_MAP[jsonData.type])
        return;

    for(var i = 0; i < jsonData.seq.length; ++i) {
        var entry = jsonData.seq[i];
        var value = entry.value;
        var key = entry.key;

        if (realTypeOf(value) === 'Object' && value.url) {
            if (!isLittleEndian()) {
                // FIXME add big-endian -> little-endian conversion
                throw new Error("Big-endian binary data are not supported yet");
            }
            XML3D.resource.fetch(value.url)
                .then(function (response) {
                    return response.arrayBuffer();
                }).then(function(arrayBuffer) {
                    createXflowValueFromBuffer(dataNode, jsonData.type, name, key, arrayBuffer, value.byteOffset, value.byteLength);
                });
        } else {
            createXflowValue(dataNode, jsonData.type, name, key, value);
        }
    }
}

function createXflowNode(jsonData, aspect){

    var node = new DataNode(false);
    node.userData = "External Json"; // TODO: Try to add document URL here (how to get it?)

    var entries;
    if (aspect === "scene")
        entries = jsonData.material;
    else
        entries = jsonData.data;

    for(var name in entries) {
        createXflowInputs(node, name, entries[name]);
    }
    return node;
}

/**
 * @implements IDataAdapter
 */
var JSONDataAdapter = function(xflowNode) {
    this.xflowDataNode = xflowNode;
};

JSONDataAdapter.prototype.getXflowNode = function(){
    return this.xflowDataNode;
};

},{"../../../base/adapter.js":48,"../../../xflow/interface/constants.js":187,"../../../xflow/interface/data.js":188,"../../../xflow/interface/graph.js":189}],61:[function(require,module,exports){
var DataAdapter = require("./data.js");
var Events = require("../../interface/notification.js");
var URI = require("../../utils/uri.js").URI;
var Util = require("../../utils/misc.js");
var Resource = require("../../resource/coordinator.js");

var NodeAdapter = require("../../base/adapter.js").NodeAdapter;
var createClass = XML3D.createClass;

/**
 * SinkDataAdapter represents the sink in the data hierarchy (no parents).
 * @constructor
 * @extends {DataAdapter}
 * @param factory
 * @param node
 */
var SinkDataAdapter = function(factory, node) {
    DataAdapter.call(this, factory, node);
};
createClass(SinkDataAdapter, DataAdapter, {

    /**
     * Indicates whether this DataAdapter is a SinkAdapter (has no parent
     * DataAdapter).
     *
     * @returns true if this DataAdapter is a SinkAdapter, otherwise false.
     */
    isSinkAdapter: function () {
        return true;
    },

    /**
     * Returns String representation of this DataAdapter
     */
    toString: function () {
        return "XML3D.data.SinkDataAdapter";
    }
});


    var ImgDataAdapter = function(factory, node) {
        NodeAdapter.call(this, factory, node);
        this.textureEntry = null;
        this.image = null;
        if (node.src)
            this.createImageFromURL(node.src);
    };
    createClass(ImgDataAdapter, NodeAdapter, {

        /**
         * Creates a new image object
         *
         * @param {string} url
         */
        createImageFromURL: function (url) {
            var that = this;
            var uri = new URI(url).getAbsoluteURI(this.node.ownerDocument._documentURL || this.node.ownerDocument.URL);
            var onload = function (e, image) {
                if (that.textureEntry) {
                    that.textureEntry.setImage(image, true);
                }
            };
            var onerror = function (e, image) {
                XML3D.debug.logError("Could not load image URI=" + image.src);
            };
            this.image = Resource.getImage(uri, onload, onerror);
            if (that.textureEntry) {
                that.textureEntry.setImage(this.image, true);
            }
        },

        /**
         * @param {Xflow.TextureEntry} entry
         */
        setTextureEntry: function (entry) {
            this.textureEntry = entry;
            if (this.image) {
                this.textureEntry.setImage(this.image, true);
            }
        },

        attributeChangedCallback: function (name, oldValue, newValue) {
            if (name == "src") {
                this.createImageFromURL(newValue);
            }
        },

        notifyChanged: function (evt) {
        },

        getValue: function (cb, obj) {
            return this.image;
        },

        getOutputs: function () {
            var result = {};
            result['image'] = this;
            return result;
        },

        resolveScript: function () {
            return null;
        }
    });

    var VideoDataAdapter = function(factory, node) {
        DataAdapter.call(this, factory, node);
        this.textureEntry = null;
        this.video = null;
        this._ticking = false;
        this._boundTick = this._tick.bind(this);
        if (node.src)
            this.createVideoFromURL(node.src);
    };
    createClass(VideoDataAdapter, NodeAdapter);

    /**
     * Creates a new video object
     *
     * @param {string} url
     */
    VideoDataAdapter.prototype.createVideoFromURL = function(url) {
        var that = this;
        var uri = new URI(url).getAbsoluteURI(this.node.ownerDocument._documentURL || this.node.ownerDocument.URL);
        this.video = Resource.getVideo(uri, this.node.autoplay, this.node.loop, this.node.muted,
            {
                canplay : function(event, video) {
                    Util.dispatchCustomEvent(that.node, 'canplay', true, true, null);
                    that._startVideoRefresh();
                },
                ended : function(event, video) {
                    Util.dispatchCustomEvent(that.node, 'ended', true, true, null);
                },
                load : function(event, video) {
                    Util.dispatchEvent(that.node, 'load');
                },
                error : function(event, video) {
                    Util.dispatchCustomEvent(that.node, 'error', true, true, null);
                    XML3D.debug.logError("Could not load video URI="+video.src);
                }
            }
        );
        if (this.textureEntry)
            this.textureEntry.setImage(this.video, true);
    };

    VideoDataAdapter.prototype.play = function() {
        if (this.video)
            this.video.play();
    };

    VideoDataAdapter.prototype.pause = function() {
        if (this.video)
            this.video.pause();
    };

    VideoDataAdapter.prototype._startVideoRefresh = function() {
        if (!this._ticking)
            this._tick();
    };

    VideoDataAdapter.prototype._tick = function() {
        this._ticking = true;
        window.requestAnimationFrame(this._boundTick);
        // FIXME Do this only when currentTime is changed (what about webcam ?)
        if (this.textureEntry) {
            this.textureEntry.setImage(this.video);
        }
    };

    /**
     * @param {Xflow.TextureEntry} entry
     */
    VideoDataAdapter.prototype.setTextureEntry = function(entry) {
        this.textureEntry = entry;
        if (this.video) {
            this.textureEntry.setImage(this.video, true);
        }
    };

    VideoDataAdapter.prototype.notifyChanged = function(evt) {
    };

    VideoDataAdapter.prototype.attributeChangedCallback = function (name, oldValue, newValue) {
        if (name == "src") {
            this.createVideoFromURL(newValue);
        }
    };

    VideoDataAdapter.prototype.getValue = function(cb, obj) {
        return this.video;
    };

    VideoDataAdapter.prototype.getOutputs = function() {
        var result = {};
        result['video'] = this;
        return result;
    };

    // Export
    module.exports = {
        ImgDataAdapter: ImgDataAdapter,
        VideoDataAdapter: VideoDataAdapter,
        SinkDataAdapter: SinkDataAdapter
    };


},{"../../base/adapter.js":48,"../../interface/notification.js":74,"../../resource/coordinator.js":161,"../../utils/misc.js":182,"../../utils/uri.js":184,"./data.js":56}],62:[function(require,module,exports){
var Events = require("../../interface/notification.js");
var createClass = XML3D.createClass;
var NodeAdapter = require("../../base/adapter.js").NodeAdapter;

var ScriptDataAdapter = function(factory, node) {
    NodeAdapter.call(this, factory, node);
    this.connectedAdapterHandle = null;
    if (node.src) {
        this.connectedAdapterHandle = this.getAdapterHandle(node.src);
        this.connectAdapterHandle(node.name, this.connectedAdapterHandle);
    }
};

createClass(ScriptDataAdapter, NodeAdapter, {

    getScriptType: function () {
        return this.node.type;
    },

    getScript: function () {
        if (this.node.src) {
            return this.externalScript;
        } else {
            return this.node.value;
        }
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        this.notifyOppositeAdapters();
    },

    notifyChanged: function (evt) {
        switch (evt.type) {
            case Events.NODE_INSERTED:
            case Events.NODE_REMOVED:
            case Events.VALUE_MODIFIED:
                this.notifyOppositeAdapters();
                break;

            case Events.ADAPTER_HANDLE_CHANGED:
                this.externalScript = evt.adapter.script;
                this.notifyOppositeAdapters();
                break;
        }
    }
});

module.exports = ScriptDataAdapter;

},{"../../base/adapter.js":48,"../../interface/notification.js":74}],63:[function(require,module,exports){
var TextureEntry = require("../../xflow/interface/data.js").TextureEntry;
var InputNode = require("../../xflow/interface/graph.js").InputNode;
var XC = require("../../xflow/interface/constants.js");
var Events = require("../../interface/notification.js");
var NodeAdapter = require("../../base/adapter.js").NodeAdapter;
var GL = require("../../renderer/webgl/constants.js");

var defaults = require('lodash.defaults');
var assign = require('lodash.assign');


var TextureDataAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
};

XML3D.createClass(TextureDataAdapter, NodeAdapter, {

    init: function () {
        this.xflowInputNode = this.createXflowNode();
        this.xflowInputNode.data = this.createTextureEntry();
    },

    createTextureEntry: function () {
        var node = this.node;
        var entry = new TextureEntry(null);
        initTextureSamplingParameters(entry.getSamplerConfig(), node.getAttribute("wrap"), node.getAttribute("filter"), node.getAttribute("anisotropy"));

        var imageAdapter = this.factory.getAdapter(this.node.firstElementChild);
        if (imageAdapter) {
            imageAdapter.setTextureEntry(entry);
        }
        return entry;
    },

    shouldGenerateMipMaps: shouldGenerateMipMaps,

    /**
     *
     * @returns {InputNode}
     */
    createXflowNode: function () {
        var xnode = new InputNode();
        xnode.name = this.node.name;
        xnode.paramName = this.node.param ? this.node.name : null;
        xnode.key = this.node.key;
        return xnode;
    },

    setScriptValue: function () {
        XML3D.debug.logError("Texture currently does not support setScriptValue()");
    },

    getOutputs: function () {
        var result = {};
        result[this.node.name] = this;
        return result;
    },

    getValue: function () {
        return this.value;
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        switch (name) {
            case "name":
                this.xflowInputNode.name = newValue;
                break;
            case "param":
                this.xflowInputNode.paramName = newValue ? this.node.name : null;
                break;
            case "key":
                this.xflowInputNode.key = newValue;
                break;
            case "wrap":
            case "filter":
            case "samples":
                this.xflowInputNode.data = this.createTextureEntry();
                break;
        }
    },

    notifyChanged: function () { /* Nothing to do */
    },

    /**
     * @return {Element}
     */
    getXflowNode: function () {
        return this.xflowInputNode;
    }

});

var wrapToGL = {
    "clamp":  GL.CLAMP_TO_EDGE,
    "repeat": GL.REPEAT
};

var filterToGL = {
    "nearest": GL.NEAREST,
    "linear": GL.LINEAR,
    "nearest-mipmap-nearest": GL.NEAREST_MIPMAP_NEAREST,
    "linear-mipmap-nearest": GL.LINEAR_MIPMAP_NEAREST,
    "nearest-mipmap-linear": GL.NEAREST_MIPMAP_LINEAR,
    "linear-mipmap-linear": GL.LINEAR_MIPMAP_LINEAR
};

function shouldGenerateMipMaps(minFilter, magFilter) {
    return (minFilter != GL.NEAREST && minFilter != GL.LINEAR) || (magFilter != GL.NEAREST && magFilter != GL.LINEAR);
}

function parseTextureSamplingParameters(wrap, filter, anisotropy) {
    var result = {}, args;

    if(wrap) {
        args = wrap.split(/(\s+)/);
        result.wrapS = wrapToGL[args[0]];
        result.wrapT = wrapToGL[args[args.length - 1]];
    }

    if(filter) {
        args = filter.split(/(\s+)/);
        result.minFilter = filterToGL[args[0]];
        result.magFilter = filterToGL[args[args.length - 1]];
    }

    if(anisotropy) {
        var number = parseFloat(anisotropy);
        if (isNaN(number)) {
            number = anisotropy == "max" ? Infinity : undefined
        } else {
            number = Math.min(1.0, number)
        }
        result.anisotropy = number;
    }

    return result;
}

function initTextureSamplingParameters(config, wrap, filter, samples) {
    var params = parseTextureSamplingParameters(wrap, filter, samples);
    defaults(params, {
        wrapS: GL.CLAMP_TO_EDGE,
        wrapT: GL.CLAMP_TO_EDGE,
        minFilter: GL.LINEAR_MIPMAP_LINEAR,
        magFilter: GL.LINEAR,
        textureType: XC.TEX_TYPE.TEXTURE_2D,
        anisotropy: 1
    });
    assign(config, params);
    config.generateMipMap = shouldGenerateMipMaps(config.minFilter, config.magFilter);
}

// Export
module.exports = TextureDataAdapter;

},{"../../base/adapter.js":48,"../../interface/notification.js":74,"../../renderer/webgl/constants.js":120,"../../xflow/interface/constants.js":187,"../../xflow/interface/data.js":188,"../../xflow/interface/graph.js":189,"lodash.assign":17,"lodash.defaults":41}],64:[function(require,module,exports){
var Events = require("../../interface/notification.js");
var NodeAdapter = require("../../base/adapter.js").NodeAdapter;
var mat4 = require("gl-matrix").mat4;
var vec3 = require("gl-matrix").vec3;

var TransformDataAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
    this.isValid = true;
    this.needsUpdate = true;
};

XML3D.createClass(TransformDataAdapter, NodeAdapter);

var IDENT_MAT = mat4.create();

TransformDataAdapter.prototype.init = function () {
    // Create all matrices, no valid values yet
    this.matrix = mat4.create();
    this.transform = {
        translate: mat4.create(),
        scale: mat4.create(),
        scaleOrientation: mat4.create(),
        scaleOrientationInv: mat4.create(),
        center: mat4.create(),
        centerInverse: mat4.create(),
        rotation: mat4.create()
    };
    this.needsUpdate = true;
    this.checkForImproperNesting();
};

TransformDataAdapter.prototype.updateMatrix = function () {
    var n = this.node;
    var transform = this.transform;
    var centerVec = n.center.data;
    var so = n.scaleOrientation.data;
    var ro = n.rotation.data;

    mat4.fromRotation(transform.scaleOrientation, so[3], so);
    mat4.fromRotation(transform.rotation, ro[3], ro);

    mat4.translate(transform.translate, IDENT_MAT, n.translation.data);
    mat4.translate(transform.center, IDENT_MAT, centerVec);
    mat4.translate(transform.centerInverse, IDENT_MAT, vec3.negate(centerVec, centerVec));
    mat4.scale(transform.scale, IDENT_MAT, n.scale.data);
    mat4.invert(transform.scaleOrientationInv, transform.scaleOrientation);

    multiplyComponents(transform, this.matrix);
    this.needsUpdate = false;
};

function multiplyComponents(transform, matrix) {
    // M = T * C
    mat4.multiply(matrix, transform.translate, transform.center);
    // M = T * C * R
    mat4.multiply(matrix, matrix, transform.rotation);
    // M = T * C * R * SO
    mat4.multiply(matrix, matrix, transform.scaleOrientation);
    // M = T * C * R * SO * S
    mat4.multiply(matrix, matrix, transform.scale);
    // M = T * C * R * SO * S * -SO
    mat4.multiply(matrix, matrix, transform.scaleOrientationInv);
    // M = T * C * R * SO * S * -SO * -C
    mat4.multiply(matrix, matrix, transform.centerInverse);
}

TransformDataAdapter.prototype.getMatrix = function () {
    this.needsUpdate && this.updateMatrix();
    return this.matrix;
};

TransformDataAdapter.prototype.attributeChangedCallback = function (name, oldValue, newValue) {
   this.needsUpdate = true;
   this.notifyOppositeAdapters(Events.ADAPTER_VALUE_CHANGED);
};

TransformDataAdapter.prototype.notifyChanged = function (e) {
    if (e.type == Events.NODE_REMOVED) {
        this.dispose();
        this.notifyOppositeAdapters(Events.ADAPTER_HANDLE_CHANGED);
    }
};
TransformDataAdapter.prototype.dispose = function () {
    this.isValid = false;
};

TransformDataAdapter.prototype.checkForImproperNesting = function () {
    for (var i = 0; i < this.node.childNodes.length; i++) {
        if (this.node.childNodes[i].localName === "transform") {
            XML3D.debug.logError("Parsing error: Transform elements cannot be nested!", this.node);
        }
    }
};

// Export to XML3D.data namespace
module.exports = TransformDataAdapter;




},{"../../base/adapter.js":48,"../../interface/notification.js":74,"gl-matrix":1}],65:[function(require,module,exports){
var BufferEntry = require("../../xflow/interface/data.js").BufferEntry;
var InputNode = require("../../xflow/interface/graph.js").InputNode;
var XC = require("../../xflow/interface/constants.js");
var Events = require("../../interface/notification.js");
var NodeAdapter = require("../../base/adapter.js").NodeAdapter;

/**
 * Constructor of XML3D.data.ValueDataAdapter
 *
 * @extends XML3D.data.DataAdapter
 * @constructor
 *
 * @param factory
 * @param {Element} node
 */
var ValueDataAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
    this.xflowInputNode = null;
    this.type = XC.DATA_TYPE.fromString(node.localName);
};
XML3D.createClass(ValueDataAdapter, NodeAdapter);

ValueDataAdapter.prototype.init = function()
{
    var config = this.node._configured, value;
    if(this.node.textContent == "[value set by script]"){
        value = config.scriptValue;
    }
    else{
        delete config.scriptValue;
        value = this.node.value;
    }

    if (this.type === XC.DATA_TYPE.STRING) {
        value = value ? value.split(",") : [];
    }
    var buffer = new BufferEntry(this.type, value);

    this.xflowInputNode = new InputNode(null);
    this.xflowInputNode.name = this.node.name;
    this.xflowInputNode.data = buffer;
    this.xflowInputNode.key = this.node.key;
    this.xflowInputNode.paramName = this.node.param ? this.node.name : null;
    this.checkForImproperNesting();
};

ValueDataAdapter.prototype.getXflowNode = function () {
    return this.xflowInputNode;
};

/**
 *
 */
ValueDataAdapter.prototype.notifyChanged = function (evt) {
    if (evt.type == Events.VALUE_MODIFIED) {
        var attr = evt.mutation.attributeName;
        if (!attr) {
            delete this.node._configured.scriptValue;
            var value = this.node.value;
            if (this.type === XC.DATA_TYPE.STRING) {
                value = value ? value.split(",") : [];
            }
            this.xflowInputNode.data.setValue(value);
        }
    }
};

ValueDataAdapter.prototype.attributeChangedCallback = function (name, oldValue, newValue) {
    if (name == "name") {
        this.xflowInputNode.name = newValue;
    } else if (name == "key") {
        this.xflowInputNode.key = newValue;
    } else if (name == "param") {
        this.xflowInputNode.paramName = newValue ? this.node.name : null;
    }
};


ValueDataAdapter.prototype.setScriptValue = function (value) {
    // TODO: Add Type check
    if (this.type === XC.DATA_TYPE.STRING) {
        value = value ? value.split(",") : [];
    }
    this.xflowInputNode.data.setValue(value);
};

/**
 * Returns String representation of this DataAdapter
 */
ValueDataAdapter.prototype.toString = function () {
    return "XML3D.data.ValueDataAdapter";
};

ValueDataAdapter.prototype.checkForImproperNesting = function() {
    for (var i=0; i < this.node.childNodes.length; i++) {
        if (XC.DATA_TYPE.fromString(this.node.childNodes[i].localName)) {
            XML3D.debug.logError("Parsing error: Value elements cannot be nested!", this.node);
        }
    }
};

// Export
module.exports = ValueDataAdapter;

},{"../../base/adapter.js":48,"../../interface/notification.js":74,"../../xflow/interface/constants.js":187,"../../xflow/interface/data.js":188,"../../xflow/interface/graph.js":189}],66:[function(require,module,exports){
var ComputeRequest = require("../xflow/interface/request.js").ComputeRequest;
var Events = require("../interface/notification.js");
var CSS = require("../utils/css.js");
var mat4 = require("gl-matrix").mat4;

var DOMTransformFetcher = function (owner, attrName, dataName, onlyDataTransform) {
    this.owner = owner;
    this.node = owner.node;
    this.attrName = attrName;
    this.dataName = dataName;
    this.adapterHandle = null;
    this.xflowRequest = null;
    this.onlyDataTransform = onlyDataTransform || false;
    this._bindedCallback = this._onChange.bind(this);
};
DOMTransformFetcher.prototype.clear = function () {
    this.xflowRequest && this.xflowRequest.clear();
    this.xflowRequest = null;
    this.adapterHandle && this.adapterHandle.removeListener(this._bindedCallback);
};

DOMTransformFetcher.prototype.dispose = function() {
    this.clear();
    delete this.owner;
    delete this.node;
};

DOMTransformFetcher.prototype.update = function () {
    var newHandle = this.owner.getAdapterHandle(this.node.getAttribute(this.attrName), "data", 0);
    if (newHandle != this.adapterHandle) {
        this.clear();
        this.adapterHandle = newHandle;
        if (newHandle)
            newHandle.addListener(this._bindedCallback)
    }
    this.updateMatrix();
};

DOMTransformFetcher.prototype.updateMatrix = function () {
    this.owner.onTransformChange(this.attrName, this.getMatrix());
};

DOMTransformFetcher.prototype.getMatrix = ( function () {
    var IDENTITY = mat4.create();

    return function () {
        if (!this.onlyDataTransform) {
            var cssMatrix = CSS.getCSSMatrix(this.node);
            if (cssMatrix) {
                return CSS.convertCssToMat4(cssMatrix).data;
            }
        }
        var adapter;
        if (this.adapterHandle && (adapter = this.adapterHandle.getAdapter())) {
            if (adapter.getXflowNode) {
                if (!this.xflowRequest)
                    this.xflowRequest = new ComputeRequest(adapter.getXflowNode(), [this.dataName], this._bindedCallback);
                var dataResult = this.xflowRequest.getResult();
                var transformData = (dataResult.getOutputData(this.dataName) && dataResult.getOutputData(this.dataName).getValue());
                if (transformData)
                    return transformData;
            }
            if (adapter.getMatrix) {
                return adapter.getMatrix();
            }
        }
        return this.onlyDataTransform ? null : IDENTITY;
    };
}());

DOMTransformFetcher.prototype._onChange = function (evt) {
    if (evt.type == Events.ADAPTER_VALUE_CHANGED) {
        this.owner.onTransformChange(this.attrName, evt.adapterHandle.getAdapter().getMatrix());
    } else { // If the adapter changed, we need to re-evaluate the matrix
        this.updateMatrix();
    }
};

module.exports = DOMTransformFetcher;

},{"../interface/notification.js":74,"../utils/css.js":179,"../xflow/interface/request.js":190,"gl-matrix":1}],67:[function(require,module,exports){
var assign = require("lodash.assign");
var create = require("lodash.create");

if (window.XML3D !== undefined) {
    throw new Error("Tried to define the XML3D namespace a second time. Please ensure xml3d.js is only loaded once!");
}
/** @namespace * */
var XML3D = XML3D || {};
var Xflow = Xflow || {};
window.XML3D = XML3D;
window.Xflow = Xflow;

XML3D.version = 'DEVELOPMENT SNAPSHOT (07.01.2016 13:43:04 GMT+0100)';
/** @const */
XML3D.xml3dNS = 'http://www.xml3d.org/2009/xml3d';
/** @const */
XML3D.xhtmlNS = 'http://www.w3.org/1999/xhtml';
/** @const */
XML3D.webglNS = 'http://www.xml3d.org/2009/xml3d/webgl';
XML3D._xml3d = document.createElementNS(XML3D.xml3dNS, "xml3d");
XML3D._parallel = XML3D._parallel != undefined ? XML3D._parallel : false;
XML3D.xhtml = !!(document.doctype && new XMLSerializer().serializeToString(document.doctype).match(/xhtml/i));

XML3D.createElement = function(tagName) {
    XML3D.debug.logWarning("This function is deprecated and will be removed in the next major release. Use document.createElement instead.");
    return document.createElement(tagName);
};

XML3D.extend = assign;

/**
 *
 * @param {Object} obj Constructor
 * @param {Object} parent Parent class
 * @param {Object=} methods Methods to add to the class
 * @return {Object!}
 */
XML3D.createClass = function(obj, parent, methods) {
    if(!parent) {
        assign(obj.prototype, methods);
    } else {
        obj.prototype = create(parent.prototype, methods);
    }
    return obj;
};

XML3D.debug = require("./utils/debug.js");
XML3D.util = require("./utils/misc.js");
XML3D.options = require("./utils/options.js");
XML3D.materials = require("./renderer/webgl/materials/urn/registery.js");
XML3D.resource = {};
XML3D.extend(XML3D.resource, require("./resource"));
XML3D.extend(XML3D.resource, require("./utils/uri.js"));
XML3D.resource.Asset = require("./asset/asset.js").Asset;
XML3D.resource.SubData = require("./asset/asset.js").SubData;

XML3D.webcl = require("./utils/webcl.js").webcl;
XML3D.math = require("gl-matrix");
require("./math/math.js")(XML3D.math);

XML3D.Mat2 = require("./types/mat2.js");
XML3D.Mat3 = require("./types/mat3.js");
XML3D.Mat4 = require("./types/mat4.js");
XML3D.Vec2 = require("./types/vec2.js");
XML3D.Vec3 = require("./types/vec3.js");
XML3D.Vec4 = require("./types/vec4.js");
XML3D.AxisAngle = require("./types/axisangle.js");
XML3D.Quat = require("./types/quat.js");
XML3D.Ray = require("./types/ray.js");
XML3D.Box = require("./types/box.js");

XML3D.extend(window, require("./types/data-observer.js"));

Xflow.registerOperator = require("./xflow/operator/operator.js").registerOperator;
Xflow.constants = require("./xflow/interface/constants.js");
XML3D.extend(Xflow, require("./xflow/interface/graph.js"));
XML3D.extend(Xflow, require("./xflow/interface/data.js"));
Xflow.ComputeRequest = require("./xflow/interface/request.js").ComputeRequest;

XML3D.asset = require("./asset/asset.js");

XML3D.webgl = {};
XML3D.webgl.BaseRenderTree = require("./renderer/webgl/render-trees/base.js");
XML3D.webgl.BaseRenderPass = require("./renderer/webgl/render-passes/base.js");

require("./resource/xml3dformathandler.js");

require("./xflow/operator/default");

module.exports = {
    XML3D : XML3D,
    Xflow : Xflow
};

},{"./asset/asset.js":47,"./math/math.js":76,"./renderer/webgl/materials/urn/registery.js":133,"./renderer/webgl/render-passes/base.js":139,"./renderer/webgl/render-trees/base.js":150,"./resource":165,"./resource/xml3dformathandler.js":166,"./types/axisangle.js":167,"./types/box.js":168,"./types/data-observer.js":169,"./types/mat2.js":170,"./types/mat3.js":171,"./types/mat4.js":172,"./types/quat.js":173,"./types/ray.js":174,"./types/vec2.js":175,"./types/vec3.js":176,"./types/vec4.js":177,"./utils/debug.js":181,"./utils/misc.js":182,"./utils/options.js":183,"./utils/uri.js":184,"./utils/webcl.js":185,"./xflow/interface/constants.js":187,"./xflow/interface/data.js":188,"./xflow/interface/graph.js":189,"./xflow/interface/request.js":190,"./xflow/operator/default":208,"./xflow/operator/operator.js":227,"gl-matrix":1,"lodash.assign":17,"lodash.create":32}],68:[function(require,module,exports){
var XML3D = require("./global.js").XML3D;
var Config = require("./interface/elements.js").config;
var sendAdapterEvent = require("./utils/misc.js").sendAdapterEvent;
var Options = require("./utils/options.js");
var CSS = require("./utils/css.js");
var ConfigureRenderer = require("./renderer/renderer/configure.js");
var WebglSupported = require("./renderer/webgl/base/utils.js").supported;
var Util = require("./utils/misc.js");
require("./interface/dom.js");
require("./utils/debug.js");

(function () {
    if (navigator.userAgent.match(/(iPad|iPhone|iPod touch)/i)) {
        var m = document.createElement("meta");
        m.name = "format-detection";
        m.content = "telephone=no";
        document.head.appendChild(m)
    }
}());

function displayWebGLNotSupportedInfo(xml3dElement){

    if(xml3dElement.hasAttribute("onunsupported")){
        var callback = new Function("event", xml3dElement.getAttribute("onunsupported"));
        xml3dElement.addEventListener('unsupported', callback, false);
    }
    var doDefault = XML3D.util.dispatchCustomEvent(xml3dElement, 'unsupported', false, true, null);
    if(doDefault){
        // Place xml3dElement inside an invisible div
        var hideDiv = document.createElement('div');

        xml3dElement.parentNode.insertBefore(hideDiv, xml3dElement);
        hideDiv.appendChild(xml3dElement);
        //hideDiv.style.display = "none";

        var infoDiv = document.createElement('div');
        if(xml3dElement.hasAttribute("class")){
            infoDiv.setAttribute("class", xml3dElement.getAttribute("class"));
        }

        infoDiv.setAttribute("style", xml3dElement.getAttribute("style"));
        infoDiv.style.border = "2px solid red";
        infoDiv.style.fontFamily = "verdana,sans-serif";
        infoDiv.style.color = "red";
        infoDiv.style.padding = "10px";
        infoDiv.style.backgroundColor = "rgba(255, 0, 0, 0.3)";

        var width = xml3dElement.getAttribute("width");
        if (width !== null) {
            infoDiv.style.width = width;
        }

        var height = xml3dElement.getAttribute("height");
        if (height !== null) {
            infoDiv.style.height = height;
        }

        var hElement = document.createElement("h3");
        var hTxt = document.createTextNode("Sorry, your browser doesn't appear to support XML3D.");
        hElement.appendChild(hTxt);

        var pElement = document.createElement("p");
        pElement.appendChild(document.createTextNode("Please visit "));
        var link = document.createElement("a");
        link.setAttribute("href", "http://www.xml3d.org/help");
        link.appendChild(document.createTextNode("http://www.xml3d.org/help"));
        pElement.appendChild(link);
        pElement.appendChild(document.createTextNode(" for more information."));
        infoDiv.appendChild(hElement);
        infoDiv.appendChild(pElement);

        hideDiv.parentNode.insertBefore(infoDiv, hideDiv);
    }

}

/*  a list of elements that are currently initialized. More specifically,
 *  they're currently in a call to the method below.
 *
 *  Why?
 *  In webgl we actually reattach the xml3d element in the DOM. Thus, when
 *  we're in the middle of working on a onNodeInserted event, there will probably
 *  come right another event which we actually don't care for.
 *  So we use this list to keep track of which elements are currently initializing.
 */
var curXML3DInitElements = [];

/**
 * @param {Element} xml3dElement
 */
function initXML3DElement(xml3dElement) {
    if(curXML3DInitElements.indexOf(xml3dElement) > -1)
        return;

    curXML3DInitElements.push(xml3dElement);

    var debug = XML3D.debug.setup();

    if (!WebglSupported()) {
        debug && XML3D.debug.logWarning("Could not initialise WebGL, sorry :-(");
        displayWebGLNotSupportedInfo(xml3dElement);
        curXML3DInitElements.splice(curXML3DInitElements.indexOf(xml3dElement), 1);
        return;
    }

    XML3D.debug.logInfo("Configuring", xml3dElement.querySelectorAll("*").length, "elements");

    try {
        Config.configure(xml3dElement);
    } catch (e) {
        debug && XML3D.debug.logException(e);
        curXML3DInitElements.splice(curXML3DInitElements.indexOf(xml3dElement), 1);
        return;
    }
    try {
        ConfigureRenderer(xml3dElement);
    } catch (e) {
        debug && XML3D.debug.logException(e);
        curXML3DInitElements.splice(curXML3DInitElements.indexOf(xml3dElement), 1);
        return;
    }

    // initialize all attached adapters
    sendAdapterEvent(xml3dElement, {onConfigured : []});

    curXML3DInitElements.splice(curXML3DInitElements.indexOf(xml3dElement), 1);
    clearObserver();
}

/**
 * @param {Element} xml3dElement
 */
function destroyXML3DElement(xml3dElement)
{
    if(curXML3DInitElements.indexOf(xml3dElement) > -1)
        return;

    if (!xml3dElement._configured) {
        return; //Already destroyed or never initialized
    }

    var canvas = xml3dElement._configured.canvas;

    xml3dElement._configured.destroy();
    xml3dElement._configured = undefined;

    if(!canvas || !Util.elementIs(canvas, "canvas"))
        return; // an element we didn't create, skip deletion

    if (!xml3dElement.parentNode) {
        // The xml3d element was removed directly rather than as a result of a parent container being removed,
        // here we should also remove the hiding div
        var div = canvas.nextElementSibling;
        if (Util.elementIs(div, "div") && div.getAttribute("class") == "_xml3d_hideDiv") {
            div.parentNode && div.parentNode.removeChild(div);
        }
    }

    canvas.parentNode && canvas.parentNode.removeChild(canvas);
}

/**
 * @param {Event} evt
 */
function onNodeInserted(evt) {

    if(Util.elementIs(evt.target, "xml3d")) {
        initXML3DElement(evt.target);
    }
}

/**
 * @param {Event} evt
 */
function onNodeRemoved(evt) {

    if(Util.elementIs(evt.target, "xml3d")) {
        destroyXML3DElement(evt.target);
    }
}

var observer = null;

function onLoad() {

    Options.setOptionsFromQuery();

    CSS.init();

    var debug = XML3D.debug.setup();
    debug && XML3D.debug.logInfo("xml3d.js version: " + XML3D.version);

    /**
     * Find all the XML3D tags in the document
     * @type {NodeList}
     */
    var xml3ds = document.querySelectorAll("xml3d");

    debug && XML3D.debug.logInfo("Found " + xml3ds.length + " xml3d node(s)");

    for(var i = 0; i < xml3ds.length; i++) {
        initXML3DElement(xml3ds[i]);
    }

    // TODO(ksons): Remove this, no MutationObserver no XML3D
    if(!MutationObserver){
        document.addEventListener('DOMNodeInserted', onNodeInserted, false);
        document.addEventListener('DOMNodeRemoved', onNodeRemoved, false);
    }
    else{
        observer = new MutationObserver(resolveMutations);
        observer.observe(document.documentElement, { childList: true, subtree: true, attributes: true, attributeFilter: [ "class", "id", "style" ] } );
    }
}

function onUnload() {
    if (XML3D.document)
        XML3D.document.onunload();
}



function resolveMutations(mutations){
    for(var i = 0; i < mutations.length; ++i){
        var mutation = mutations[i];
        if(mutation.type == 'childList'){
            mapFunctionOnXML3DElements(mutation.addedNodes, initXML3DElement);
            mapFunctionOnXML3DElements(mutation.removedNodes, destroyXML3DElement);

        } else if (mutation.type == 'attributes') {
            var mutationTarget = mutation.target;
            if (mutation.attributeName === "id" || mutation.attributeName === "class") {
                mutationTarget = mutation.target.parentNode; // Start CSS re-eval at parent to honor sibling selectors
                if (!mutationTarget) {
                    continue; // Target was removed from the DOM before this event was processed
                }
            }
            var cssTarget = mutationTarget._configured ? mutationTarget : mutationTarget.querySelector("xml3d");
            if(cssTarget && cssTarget._configured) { // xml3d is a child node
                var adaptersNames = Object.keys(cssTarget._configured.adapters).filter(function(a) {
                    return a.indexOf("scene") == 0;
                });
                adaptersNames.map(function(name){return cssTarget._configured.adapters[name];}).forEach(function(renderAdapter) {
                    renderAdapter.traverse(function(adapter) {
                        adapter.styleChangedCallback();
                    })

                });

            }

        }
    }
}

function mapFunctionOnXML3DElements(elementList, fun) {
    Array.forEach(elementList, function(element) {
        if (!element.getElementsByTagNameNS) {
            // These elements are leaf nodes (eg. TEXT) so we can ignore them
            return;
        }
        if (Util.elementIs(element, "xml3d")) {
            fun(element);
            // An XML3D element can't have further XML3D elements as children
            return;
        }
        // For cases where an XML3D element might be inside the subtree of the added node
        var xml3dElems = element.getElementsByTagName("xml3d");
        xml3dElems = xml3dElems.length ? xml3dElems : element.getElementsByTagNameNS(XML3D.xml3dNS, "xml3d");

        Array.forEach(xml3dElems, fun);
    });
}

XML3D.flushCSSChanges = function(){
    if(observer){
        resolveMutations(observer.takeRecords());
    }
};

function clearObserver(){
    if(observer){
        observer.takeRecords();
    }
}

if (document.readyState === "complete" || document.readyState === "interactive") {
    onLoad();
} else {
    document.addEventListener('DOMContentLoaded', onLoad, false);
}

window.addEventListener('unload', onUnload, false);
window.addEventListener('reload', onUnload, false);

module.exports = XML3D;


},{"./global.js":67,"./interface/dom.js":71,"./interface/elements.js":72,"./renderer/renderer/configure.js":91,"./renderer/webgl/base/utils.js":118,"./utils/css.js":179,"./utils/debug.js":181,"./utils/misc.js":182,"./utils/options.js":183}],69:[function(require,module,exports){
var Resource = require("../resource");

var string2bool = function(string) {
    if (!string) {
        return false;
    }
    switch (string.toLowerCase()) {
    case "true":
    case "1":
        return true;
    case "false":
    case "0":
        return false;
    default:
        return Boolean(string);
    }
};
var handlers = {};

function getStorage(elem){
    return elem._configured.storage;
}

var AttributeHandler = function(elem) {
};

handlers.IDHandler = function(id) {
    id = id.toLowerCase();
    this.setFromAttribute = function(value, prevValue, elem) {
        Resource.notifyNodeIdChange(elem, prevValue, value);
    };
    this.desc = {
        get : function() {
            return this.getAttribute(id) || "";
        },
        set : function(value) {
            this.setAttribute(id, value);
        }
    };
};

handlers.StringAttributeHandler = function(id, params) {
    id = id.toLowerCase();
    var defaultValue = params ? params.defaultValue: "";
    this.desc = {
        get : function() {
            return this.getAttribute(id) || defaultValue;
        },
        set : function(value) {
            this.setAttribute(id, value || defaultValue);
        }
    };
};

handlers.EnumAttributeHandler = function(id, enumObj) {
    AttributeHandler.call(this);
    id = id.toLowerCase();

    this.init = function(elem, storage){
        storage[id] = enumObj.defaultValue;
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };
    this.setFromAttribute = function(v, prevValue, elem, storage) {
        var value = v.toLowerCase();
        storage[id] = (value && enumObj.values[value] !== undefined) ? enumObj.values[value] : enumObj.defaultValue;
        return false;
    };
    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            return enumObj.values[storage[id]];
        },
        set : function(v) {
                // Attribute is set to whatever comes in
            this.setAttribute(id, v);
            var storage = getStorage(this);
            var value = typeof v == 'string' ? v.toLowerCase() : undefined;
            if (value && enumObj.values[value] !== undefined)
                storage[id] = enumObj.values[value];
            else
                storage[id] = enumObj.defaultValue;
        }
    };
};
handlers.EnumAttributeHandler.prototype = new AttributeHandler();
handlers.EnumAttributeHandler.prototype.constructor = handlers.EnumAttributeHandler;

handlers.EventAttributeHandler = function(id) {
    AttributeHandler.call(this);
    id = id.toLowerCase();
    var eventType = id.substring(2);

    this.init = function(elem, storage){
        storage[id] = null;
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };

    this.setFromAttribute = function(value, prevValue, elem, storage) {
        if(storage[id] != null)
            elem.removeEventListener(eventType, storage[id]);
        if(!value){
            storage[id] = null;
        }
        else{
            storage[id] = eval("crx = function " + id + "(event){\n  " + value + "\n}");
            if (XML3D.xhtml) {
                // only XHTML documents require this polyfill for mouse event attributes
                elem.addEventListener(eventType, storage[id], false);
            }
        }
        return false;
    };
    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            return storage[id];
        },
        set : function(value) {
            var storage = getStorage(this);
            if(XML3D.xhtml && storage[id]) this.removeEventListener(eventType, storage[id]);
            storage[id] = (typeof value == 'function') ? value : undefined;
            if(XML3D.xhtml && storage[id]) this.addEventListener(eventType, storage[id], false);
            return false;
        }
    };
};

handlers.EventAttributeHandler.prototype = new AttributeHandler();
handlers.EventAttributeHandler.prototype.constructor = handlers.EventAttributeHandler;

handlers.IntAttributeHandler = function(id, defaultValue) {
    id = id.toLowerCase();
    this.init = function(elem, storage){
        storage[id] = defaultValue;
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };

    this.setFromAttribute = function(value, prevValue, elem, storage) {
        var v = value.match(/^\d+/);
        if (!v || isNaN(+v[0])) {
            XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, elem);
            elem.setAttribute(id, prevValue);
            storage[id] = defaultValue;
        } else {
            storage[id] =  +v[0];
        }
        if(elem._configured.canvas)
            elem._configured.canvas[id] = storage[id];
        return false;
    };

    this.desc = {
        get : function(){
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            return storage[id];
        },
        set : function(value) {
            var storage = getStorage(this);
            var v = +value;
            if (isNaN(v)) {
                XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, this);
                storage[id] = defaultValue;
            } else {
                storage[id] =  Math.floor(v);
            }
            this.setAttribute(id, storage[id] + '');
        }
    };
};
handlers.IntAttributeHandler.prototype = new AttributeHandler();
handlers.IntAttributeHandler.prototype.constructor = handlers.IntAttributeHandler;

handlers.FloatAttributeHandler = function(id, defaultValue) {
    id = id.toLowerCase();
    this.init = function(elem, storage){
        storage[id] = defaultValue;
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };

    this.setFromAttribute = function(value, prevValue, elem, storage) {
        var v = +value;
        if (isNaN(v)) {
            XML3D.debug.logWarning("Invalid attribute value: " + value, elem);
            elem.setAttribute(id, prevValue);
            storage[id] = defaultValue;
        } else {
            storage[id] =  v;
        }
        return false;
    };

    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            return storage[id];
        },
        set : function(value) {
            var storage = getStorage(this);
            var v = +value;
            if (isNaN(v)) {
                XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, this);
                storage[id] = defaultValue;
            } else {
                storage[id] =  v;
            }
            this.setAttribute(id, storage[id] + '');
        }
    };
};

handlers.BoolAttributeHandler = function(id, defaultValue) {
    id = id.toLowerCase();
    this.init = function(elem, storage){
        storage[id] = defaultValue;
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };
    this.setFromAttribute = function(value, prevValue, elem, storage) {
        storage[id] = string2bool(value);
        return false;
    };

    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            return storage[id];
        },
        set : function(value) {
            var storage = getStorage(this);
            storage[id] = Boolean(value);
            this.setAttribute(id, storage[id] + '');
        }
    };
};

handlers.Vec3AttributeHandler = function(id, defaultValue) {
    var that = this;
    id = id.toLowerCase();

    this.init = function(elem, storage){
        storage[id] = null;
    };

    this.setFromAttribute = function(value, prevValue, elem, storage, init) {
        if (!storage[id]) {
            storage[id] = XML3D.math.vec3.create();
        }
        var v = storage[id];
        var m = /^\s*(\S+)\s+(\S+)\s+(\S+)\s*$/.exec(value);
        if (!m  || isNaN(+m[1]) || isNaN(+m[2]) || isNaN(+m[3])) {
            v[0] = defaultValue[0];
            v[1] = defaultValue[1];
            v[2] = defaultValue[2];
            !init && XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, elem);
        } else {
            v[0] = +m[1];
            v[1] = +m[2];
            v[2] = +m[3];
        }
        return false;
    };

    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            if (!storage[id]) {
                that.setFromAttribute(this.getAttribute(id), null, this, storage, true);
            }
            return new XML3D.Vec3(storage[id]);
        },
        set : function(value) {
            var storage = getStorage(this);
            if (!storage[id]) {
                that.setFromAttribute(this.getAttribute(id), null, this, storage, true);
            }
            var v = storage[id];
            var val = value.data ? value.data : value;
            if (val.length !== 3 || isNaN(val[0]) || isNaN(val[1]) || isNaN(val[2])) {
                XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, this);
                v = defaultValue;
            } else {
                v[0] = val[0]; v[1] = val[1]; v[2] = val[2];
            }
            this.setAttribute(id, XML3D.math.vec3.toDOMString(v));
        }
    };
};

// Note: All vec4 attributes are considered to be axis-angle, NOT quaternions!
handlers.AxisAngleAttributeHandler = function(id, defaultValue) {
    var that = this;
    id = id.toLowerCase();

    this.init = function(elem, storage){
        storage[id] = null;
    };

    this.setFromAttribute = function(value, prevValue, elem, storage, init) {
        if (!storage[id]) {
            storage[id] = XML3D.math.vec4.create();
        }
        var v = storage[id];
        var m = /^\s*(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s*$/.exec(value);
        if (!m  || isNaN(+m[1]) || isNaN(+m[2]) || isNaN(+m[3]) || isNaN(+m[4])) {
            XML3D.math.vec4.copy(v, defaultValue);
            !init && XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, elem);
        } else {
            XML3D.math.vec4.set(v, +m[1], +m[2], +m[3], +m[4]);
        }
        return false;
    };

    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            if (!storage[id]) {
                that.setFromAttribute(this.getAttribute(id), null, this, storage, true);
            }
            return new XML3D.AxisAngle(storage[id]);
        },
        set : function(value) {
            var storage = getStorage(this);
            if (!storage[id]) {
                that.setFromAttribute(this.getAttribute(id), null, this, storage, true);
            }
            var v = storage[id];
            var val = value.data ? value.data : value;
            if (val.length !== 4 || isNaN(val[0]) || isNaN(val[1]) || isNaN(val[2]) || isNaN(val[3])) {
                XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, this);
                XML3D.math.vec4.copy(v, defaultValue);
            } else {
                XML3D.math.quat.copy(v, val);
            }
            this.setAttribute(id, XML3D.math.vec4.toDOMString(v));
        }
    };
};

var mixedContent = function(handler) {
    handler.init = function(elem, storage){
        elem._configured.registerMixed();
    };
    handler.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            if (!storage.value) {
                storage.value = handler.parse(this);
            }
            return storage.value;
        },
        set : function(value) {
            // Throw error?
            throw Error("Can't set " + this.nodeName + "::value: it's readonly");
        }
    };
    handler.resetValue = function(storage) { storage.value = null; };
};

var getContent = function(elem) {
    var str = "";
    var k = elem.firstChild;
    while (k) {
        str += k.nodeType == 3 ? k.textContent : " ";
        k = k.nextSibling;
    }
    return str;
};

handlers.FloatArrayValueHandler = function(id) {
    mixedContent(this);
};

handlers.FloatArrayValueHandler.prototype.parse = function(elem) {
    var exp = /([+\-0-9eE\.]+)/g;
    var str = getContent(elem);
    var m = str.match(exp);
    return m ? new Float32Array(m) : new Float32Array();
};

handlers.Float2ArrayValueHandler = handlers.FloatArrayValueHandler;
handlers.Float3ArrayValueHandler = handlers.FloatArrayValueHandler;
handlers.Float4ArrayValueHandler = handlers.FloatArrayValueHandler;
handlers.Float4x4ArrayValueHandler = handlers.FloatArrayValueHandler;

handlers.IntArrayValueHandler = function(id) {
    mixedContent(this);
};
handlers.IntArrayValueHandler.prototype.parse = function(elem) {
    var exp = /([+\-0-9]+)/g;
    var str = getContent(elem);
    var m = str.match(exp);
    return m ? new Int32Array(m) : new Int32Array();
};

handlers.BoolArrayValueHandler = function(id) {
    mixedContent(this);
};
handlers.BoolArrayValueHandler.prototype.parse = function(elem) {
    var exp = /(true|false|0|1)/ig;
    var str = getContent(elem);
    var m = str.match(exp);
    if (!m)
        return new Uint8Array();
    m = m.map(string2bool);
    return m ? new Uint8Array(m) : new Uint8Array();
};

handlers.StringValueHandler = function(id) {
    mixedContent(this);
};
handlers.StringValueHandler.prototype.parse = function(elem) {
    return elem.textContent;
};

handlers.CanvasStyleHandler = function(id, d) {
    id = id.toLowerCase();
    this.init = function(elem, storage){
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };

    this.setFromAttribute = function(value, prevValue, elem, storage) {
        elem._configured.canvas.setAttribute(id, value);
    };

    this.desc = {
        get: function() { return this._configured.canvas.style; },
        set: function(value) {}
    };

};

handlers.CanvasClassHandler = function(id) {
    id = id.toLowerCase();
    this.init = function(elem, storage){
        var canvas = elem._configured.canvas;
        canvas.className = "_xml3d"; // Class name always defined for xml3d canvas
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };

    this.setFromAttribute = function(value, prevValue, elem, storage) {
        var canvas = elem._configured.canvas;
        canvas.setAttribute(id, value + " _xml3d");
    };

    this.desc = {
        // TODO: Should we not strip the _xml3d class here?
        get: function() {
            if (!this._configured) {
                return "";
            }
            return this._configured.canvas.className;
        },
        set: function(value) {
            if (this._configured) {
                this._configured.canvas.className = value;
            }
        }
    };
};

module.exports = handlers;

},{"../resource":165}],70:[function(require,module,exports){
var methods = require("./methods.js");
var handlers = require("./attributes.js");
var properties = require("./properties.js");

// MeshTypes
var MeshTypes = {};
MeshTypes["triangles"] = 0;
MeshTypes[0] = "triangles";
MeshTypes["trianglestrips"] = 1;
MeshTypes[1] = "trianglestrips";
MeshTypes["lines"] = 2;
MeshTypes[2] = "lines";
MeshTypes["linestrips"] = 3;
MeshTypes[3] = "linestrips";
MeshTypes["points"] = 4;
MeshTypes[4] = "points";
MeshTypes["derived"] = 5;
MeshTypes[5] = "derived";
// TextureTypes
var TextureTypes = {};
TextureTypes["2d"] = 0;
TextureTypes[0] = "2d";
TextureTypes["1d"] = 1;
TextureTypes[1] = "1d";
TextureTypes["3d"] = 2;
TextureTypes[2] = "3d";

// PlatformTypes
var PlatformTypes = {};
PlatformTypes["auto"] = 1;
PlatformTypes[1] = "auto";
PlatformTypes["js"] = 2;
PlatformTypes[2] = "js";
PlatformTypes["gl"] = 3;
PlatformTypes[3] = "gl";
PlatformTypes["cl"] = 4;
PlatformTypes[4] = "cl";
// DataFieldType
var DataFieldType = {};
DataFieldType["float "] = 0;
DataFieldType[0] = "float ";
DataFieldType["float2 "] = 1;
DataFieldType[1] = "float2 ";
DataFieldType["float3"] = 2;
DataFieldType[2] = "float3";
DataFieldType["float4"] = 3;
DataFieldType[3] = "float4";
DataFieldType["float4x4"] = 4;
DataFieldType[4] = "float4x4";
DataFieldType["int"] = 10;
DataFieldType[10] = "int";
DataFieldType["int4"] = 11;
DataFieldType[11] = "int4";
DataFieldType["bool"] = 20;
DataFieldType[20] = "bool";
DataFieldType["texture"] = 30;
DataFieldType[30] = "texture";
// DataChannelOrigin
var DataChannelOrigin = {};
DataChannelOrigin["origin_value "] = 0;
DataChannelOrigin[0] = "origin_value ";
DataChannelOrigin["origin_child"] = 1;
DataChannelOrigin[1] = "origin_child";
DataChannelOrigin["origin_source"] = 2;
DataChannelOrigin[2] = "origin_source";
DataChannelOrigin["origin_compute"] = 3;
DataChannelOrigin[3] = "origin_compute";
DataChannelOrigin["origin_proto"] = 4;
DataChannelOrigin[4] = "origin_proto";

var classInfo = {};

/**
 * Properties and methods for <xml3d>
 **/
classInfo['xml3d'] = {
    id : {a: handlers.IDHandler},
    className : {a: handlers.CanvasClassHandler, id: 'class'},
    style : {a: handlers.CanvasStyleHandler},
    onclick : {a: handlers.EventAttributeHandler},
    ondblclick : {a: handlers.EventAttributeHandler},
    onmousedown : {a: handlers.EventAttributeHandler},
    onmouseup : {a: handlers.EventAttributeHandler},
    onmouseover : {a: handlers.EventAttributeHandler},
    onmousemove : {a: handlers.EventAttributeHandler},
    onmouseout : {a: handlers.EventAttributeHandler},
    onkeypress : {a: handlers.EventAttributeHandler},
    onkeydown : {a: handlers.EventAttributeHandler},
    onkeyup : {a: handlers.EventAttributeHandler},
    onload: {a: handlers.EventAttributeHandler},
    onframedrawn: {a: handlers.EventAttributeHandler},
    complete: {p: properties.xml3dComplete},
    height : {a: handlers.IntAttributeHandler, params: 600},
    width : {a: handlers.IntAttributeHandler, params: 800},
    getElementByPoint : {m: methods.xml3dGetElementByPoint},
    generateRay : {m: methods.xml3dGenerateRay},
    getElementByRay : {m: methods.xml3dGetElementByRay},
    getWorldBoundingBox : {m: methods.getWorldBoundingBox},
    getLocalBoundingBox : {m: methods.getLocalBoundingBox},
    getRenderInterface : {m: methods.xml3dGetRenderInterface},
    view : {a: handlers.StringAttributeHandler, params: {defaultValue: "view"}}
    };

classInfo['compute'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    value: {a: handlers.StringValueHandler}
    };

/**
 * Properties and methods for <data>
 **/
classInfo['data'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    compute: {a: handlers.StringAttributeHandler},
    platform: {a: handlers.EnumAttributeHandler, params: {values: PlatformTypes, defaultValues: 1}},
    filter: {a: handlers.StringAttributeHandler},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    getOutputNames: {m: methods.XML3DNestedDataContainerTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DNestedDataContainerTypeGetOutputChannelInfo},
    getResult: {m: methods.XML3DNestedDataContainerTypeGetResult},
    src: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <dataflow>
 **/
classInfo['dataflow'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    platform: {a: handlers.EnumAttributeHandler, params: {values: PlatformTypes, defaultValues: 1}},
    out: {a: handlers.StringAttributeHandler},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    getOutputNames: {m: methods.XML3DNestedDataContainerTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DNestedDataContainerTypeGetOutputChannelInfo},
    getResult: {m: methods.XML3DNestedDataContainerTypeGetResult}
    };
/**
 * Properties and methods for <data>
 **/
classInfo['asset'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.AssetComplete},
    progressLevel: {p: properties.AssetProgressLevel},
    src: {a: handlers.StringAttributeHandler},
    name: {a: handlers.StringAttributeHandler},
    pick: {a: handlers.StringAttributeHandler},
    transform: {a: handlers.StringAttributeHandler},
    material: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <defs>
 **/
classInfo['defs'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'}
    };
/**
 * Properties and methods for <group>
 **/
classInfo['group'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onclick: {a: handlers.EventAttributeHandler},
    ondblclick: {a: handlers.EventAttributeHandler},
    onmousedown: {a: handlers.EventAttributeHandler},
    onmouseup: {a: handlers.EventAttributeHandler},
    onmouseover: {a: handlers.EventAttributeHandler},
    onmousemove: {a: handlers.EventAttributeHandler},
    onmouseout: {a: handlers.EventAttributeHandler},
    onkeypress: {a: handlers.EventAttributeHandler},
    onkeydown: {a: handlers.EventAttributeHandler},
    onkeyup: {a: handlers.EventAttributeHandler},
    getWorldMatrix: {m: methods.XML3DGraphTypeGetWorldMatrix},
    getLocalMatrix: {m: methods.XML3DGraphTypeGetLocalMatrix},
    getWorldBoundingBox : {m: methods.getWorldBoundingBox},
    getLocalBoundingBox : {m: methods.getLocalBoundingBox},
    transform: {a: handlers.StringAttributeHandler},
    material: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <mesh>
 **/
classInfo['mesh'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onclick: {a: handlers.EventAttributeHandler},
    ondblclick: {a: handlers.EventAttributeHandler},
    onmousedown: {a: handlers.EventAttributeHandler},
    onmouseup: {a: handlers.EventAttributeHandler},
    onmouseover: {a: handlers.EventAttributeHandler},
    onmousemove: {a: handlers.EventAttributeHandler},
    onmouseout: {a: handlers.EventAttributeHandler},
    onkeypress: {a: handlers.EventAttributeHandler},
    onkeydown: {a: handlers.EventAttributeHandler},
    onkeyup: {a: handlers.EventAttributeHandler},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    type: {a: handlers.EnumAttributeHandler, params: {values: MeshTypes, defaultValue: 0}},
    compute: {a: handlers.StringAttributeHandler},
    transform: {a: handlers.StringAttributeHandler},
    material: {a: handlers.StringAttributeHandler},
    getWorldMatrix: {m: methods.XML3DGraphTypeGetWorldMatrix},
    getLocalMatrix: {m: methods.XML3DGraphTypeGetLocalMatrix},
    getWorldBoundingBox : {m: methods.getWorldBoundingBox},
    getLocalBoundingBox : {m: methods.getLocalBoundingBox},
    getOutputNames: {m: methods.meshGetOutputNames},
    getOutputChannelInfo: {m: methods.meshGetOutputChannelInfo},
    getResult: {m: methods.meshGetResult},
    src: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <model>
 **/
classInfo['model'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onclick: {a: handlers.EventAttributeHandler},
    ondblclick: {a: handlers.EventAttributeHandler},
    onmousedown: {a: handlers.EventAttributeHandler},
    onmouseup: {a: handlers.EventAttributeHandler},
    onmouseover: {a: handlers.EventAttributeHandler},
    onmousemove: {a: handlers.EventAttributeHandler},
    onmouseout: {a: handlers.EventAttributeHandler},
    onkeypress: {a: handlers.EventAttributeHandler},
    onkeydown: {a: handlers.EventAttributeHandler},
    onkeyup: {a: handlers.EventAttributeHandler},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.AssetComplete},
    progressLevel: {p: properties.AssetProgressLevel},
    getWorldMatrix: {m: methods.XML3DGraphTypeGetWorldMatrix},
    getLocalMatrix: {m: methods.XML3DGraphTypeGetLocalMatrix},
    getWorldBoundingBox : {m: methods.getWorldBoundingBox},
    getLocalBoundingBox : {m: methods.getLocalBoundingBox},
    src: {a: handlers.StringAttributeHandler},
    pick: {a: handlers.StringAttributeHandler},
    transform: {a: handlers.StringAttributeHandler},
    material: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <transform>
 **/
classInfo['transform'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    translation: {a: handlers.Vec3AttributeHandler, params: [0, 0, 0]},
    scale: {a: handlers.Vec3AttributeHandler, params: [1, 1, 1]},
    rotation: {a: handlers.AxisAngleAttributeHandler, params: [0, 0, 1, 0]},
    center: {a: handlers.Vec3AttributeHandler, params: [0, 0, 0]},
    scaleOrientation: {a: handlers.AxisAngleAttributeHandler, params: [0, 0, 1, 0]}
    };
/**
 * Properties and methods for <material>
 **/
classInfo['material'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    compute: {a: handlers.StringAttributeHandler},
    getOutputNames: {m: methods.XML3DShaderProviderTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DShaderProviderTypeGetOutputChannelInfo},
    getResult: {m: methods.XML3DShaderProviderTypeGetResult},
    model: {a: handlers.StringAttributeHandler},
    src: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <light>
 **/
classInfo['light'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onclick: {a: handlers.EventAttributeHandler},
    ondblclick: {a: handlers.EventAttributeHandler},
    onmousedown: {a: handlers.EventAttributeHandler},
    onmouseup: {a: handlers.EventAttributeHandler},
    onmouseover: {a: handlers.EventAttributeHandler},
    onmousemove: {a: handlers.EventAttributeHandler},
    onmouseout: {a: handlers.EventAttributeHandler},
    onkeypress: {a: handlers.EventAttributeHandler},
    onkeydown: {a: handlers.EventAttributeHandler},
    onkeyup: {a: handlers.EventAttributeHandler},
    global: {a: handlers.BoolAttributeHandler, params: false},
    getWorldMatrix: {m: methods.XML3DGraphTypeGetWorldMatrix},
    getLocalMatrix: {m: methods.XML3DGraphTypeGetLocalMatrix},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    compute: {a: handlers.StringAttributeHandler},
    getOutputNames: {m: methods.XML3DShaderProviderTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DShaderProviderTypeGetOutputChannelInfo},
    getResult: {m: methods.XML3DShaderProviderTypeGetResult},
    src: {a: handlers.StringAttributeHandler},
    model: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <lightshader>
 * // TODO(ksons): Remove in XML3D 5.1
 **/
classInfo['lightshader'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    compute: {a: handlers.StringAttributeHandler},
    getOutputNames: {m: methods.XML3DShaderProviderTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DShaderProviderTypeGetOutputChannelInfo},
    getResult: {m: methods.XML3DShaderProviderTypeGetResult},
    script: {a: handlers.StringAttributeHandler},
    src: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <script>
 **/
classInfo['script'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    value: {a: handlers.StringValueHandler},
    src: {a: handlers.StringAttributeHandler},
    name: {a: handlers.StringAttributeHandler},
    type: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <assetmesh>
 **/
classInfo['assetmesh'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    match: {a: handlers.StringAttributeHandler},
    type: {a: handlers.EnumAttributeHandler, params: {values: MeshTypes, defaultValue: 0}},
    compute: {a: handlers.StringAttributeHandler},
    filter: {a: handlers.StringAttributeHandler},
    includes: {a: handlers.StringAttributeHandler},
    material: {a: handlers.StringAttributeHandler},
    transform: {a: handlers.StringAttributeHandler},
    platform: {a: handlers.EnumAttributeHandler, params: {values: PlatformTypes, defaultValue: 1}},
    getOutputNames: {m: methods.XML3DNestedDataContainerTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DNestedDataContainerTypeGetOutputChannelInfo},
    getResult: {m: methods.XML3DNestedDataContainerTypeGetResult},
    src: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <assetdata>
 **/
classInfo['assetdata'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    compute: {a: handlers.StringAttributeHandler},
    filter: {a: handlers.StringAttributeHandler},
    includes: {a: handlers.StringAttributeHandler},
    platform: {a: handlers.EnumAttributeHandler, params: {values: PlatformTypes, defaultValue: 1}},
    getOutputNames: {m: methods.XML3DNestedDataContainerTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DNestedDataContainerTypeGetOutputChannelInfo},
    getResult: {m: methods.XML3DNestedDataContainerTypeGetResult},
    src: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <float>
 **/
classInfo['float'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.FloatArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };
/**
 * Properties and methods for <float2>
 **/
classInfo['float2'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.Float2ArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };
/**
 * Properties and methods for <float3>
 **/
classInfo['float3'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.Float3ArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };
/**
 * Properties and methods for <float4>
 **/
classInfo['float4'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.Float4ArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };
/**
 * Properties and methods for <float4x4>
 **/
classInfo['float4x4'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.Float4x4ArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };
/**
 * Properties and methods for <int>
 **/
classInfo['int'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.IntArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };
/**
 * Properties and methods for <int4>
 **/
classInfo['int4'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.IntArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };
/**
 * Properties and methods for <bool>
 **/
classInfo['bool'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.BoolArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };

/**
 * Properties and methods for <string>
 **/
classInfo['string'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.StringValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
};

/**
 * Properties and methods for <texture>
 **/
classInfo['texture'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    type: {a: handlers.EnumAttributeHandler, params: {values: TextureTypes, defaultValue: 0}},
    filter: {a: handlers.StringAttributeHandler},
    wrap: {a: handlers.StringAttributeHandler},
    anisotropy: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <img>
 **/
classInfo['img'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    src: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <video>
 **/
classInfo['video'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    src: {a: handlers.StringAttributeHandler},
    autoplay: {a: handlers.BoolAttributeHandler, params: false},
    muted: {a: handlers.BoolAttributeHandler, params: false},
    play: {m: methods.videoPlay},
    pause: {m: methods.videoPause}
    };
/**
 * Properties and methods for <view>
 **/
classInfo['view'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onclick: {a: handlers.EventAttributeHandler},
    ondblclick: {a: handlers.EventAttributeHandler},
    onmousedown: {a: handlers.EventAttributeHandler},
    onmouseup: {a: handlers.EventAttributeHandler},
    onmouseover: {a: handlers.EventAttributeHandler},
    onmousemove: {a: handlers.EventAttributeHandler},
    onmouseout: {a: handlers.EventAttributeHandler},
    onkeypress: {a: handlers.EventAttributeHandler},
    onkeydown: {a: handlers.EventAttributeHandler},
    onkeyup: {a: handlers.EventAttributeHandler},
    getWorldMatrix: {m: methods.XML3DGraphTypeGetWorldMatrix},
    getLocalMatrix: {m: methods.XML3DGraphTypeGetLocalMatrix},
    getProjectionMatrix:{m: methods.viewGetProjectionMatrix},
    getViewMatrix: {m: methods.viewGetViewMatrix}
    };

module.exports = {
    classInfo : classInfo,
    MeshTypes : MeshTypes,
    TextureTypes : TextureTypes,
    PlatformTypes : PlatformTypes,
    DataFieldTypes : DataFieldType,
    DataChannelOrigin : DataChannelOrigin
};

},{"./attributes.js":69,"./methods.js":73,"./properties.js":75}],71:[function(require,module,exports){
var config = require("./elements.js").config;
var classInfo = require("./configuration.js").classInfo;

var doc = {};
var nativeGetElementById = document.getElementById;
doc.getElementById = function(id) {
    var elem = nativeGetElementById.call(this, id);
    if (elem) {
        return elem;
    } else {
        var elems = this.getElementsByTagName("*");
        for ( var i = 0; i < elems.length; i++) {
            var node = elems[i];
            if (node.getAttribute("id") === id) {
                return node;
            }
        }
    }
    return null;
};
var nativeCreateElementNS = document.createElementNS;
doc.createElementNS = function(ns, name) {
    var r = nativeCreateElementNS.call(this, ns, name);
    if (ns == XML3D.xml3dNS || classInfo[name.toLowerCase()]) {
        config.element(r);
    }
    return r;
};
var nativeCreateElement = document.createElement;
doc.createElement = function(name) {
    var r = nativeCreateElement.call(this, name);
    if (classInfo[name.toLowerCase()] ) {
        config.element(r);
    }
    return r;
};

XML3D.extend(window.document, doc);

},{"./configuration.js":70,"./elements.js":72}],72:[function(require,module,exports){
var events = require("./notification.js");
var ClassInfo = require("./configuration.js").classInfo;
var Resource = require("../resource");

var MutationObserver = (window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver),
    mutObserver;

if(MutationObserver){
    mutObserver = new MutationObserver(handleMutations);
} else {
    XML3D.debug.logError("XML3D requires MutationObservers, which your browser does not support. Please consider upgrading to a newer version.");
    mutObserver = {
        takeRecords:function(){return []},
        observe: function(a,b) {}
    }
}

XML3D.flushDOMChanges = function(){
    var records = mutObserver.takeRecords();
    records.length && handleMutations(records);
};

function handleMutations(mutations) {
    for(var i = 0; i < mutations.length; ++i){
        var mutationRecord = mutations[i];
        if (mutationRecord.type === 'attributes') {
            handleAttributeChanged(mutationRecord);
        } else if (mutationRecord.type === 'childList') {
            handleChildListChanged(mutationRecord);
        } else if(mutationRecord.type == 'characterData'){
            handleCharacterDataChanged(mutationRecord);
        }
    }
}

function handleCharacterDataChanged(mutation) {
    var target = mutation.target;
    while(!target._configured && target.parentElement) {
        target = target.parentElement;
    }
    var elementHandler = target._configured;
    if (!elementHandler) {
        return;
    }
    var n = new events.NotificationWrapper(mutation, events.VALUE_MODIFIED, target);
    if (elementHandler.handlers.value !== undefined) {
        elementHandler.handlers.value.resetValue(elementHandler.storage);
    }
    elementHandler.notify(n);
}

function handleChildListChanged(mutation) {
    var addedNodes = mutation.addedNodes;
    for (var i = 0; i < addedNodes.length; i++) {
        if (addedNodes[i].nodeType === Node.TEXT_NODE){
            // This may have been the value of eg. a float3 element, we should treat it as a characterDataChanged event
            handleCharacterDataChanged(mutation);
            continue;
        }
        handleNodeInserted(addedNodes[i], mutation);
    }

    var removedNodes = mutation.removedNodes;
    for (var i=0; i < removedNodes.length; i++) {
        if (removedNodes[i].nodeType === Node.TEXT_NODE){
            continue; // characterDataChanged events were already handled in addedNodes
        }
        handleNodeRemoved(removedNodes[i], mutation);
    }
}

function handleNodeInserted(node, mutation) {
    if (!node.parentNode) {
        return; //Node may have been subsequently removed again in a mutation event that we haven't processed yet
    }
    var targetHandler = mutation.target._configured;
    if (!targetHandler) {
        return;
    }
    config.element(node);
    addRecursive(node);
    var n = new events.NotificationWrapper(mutation, events.NODE_INSERTED, node);
    targetHandler.notify(n);
}

function handleNodeRemoved(node, mutation) {
    var targetHandler = mutation.target._configured;
    if (!targetHandler) {
        return;
    }
    var n = new events.NotificationWrapper(mutation, events.NODE_REMOVED, node);
    targetHandler.notify(n);
    if(node._configured) {
        n.type = events.THIS_REMOVED;
        removeRecursive(node, n);
    } else if (node.nodeType === Node.TEXT_NODE){
        // This may have been the value of eg. a float3 element, we should also treat it as a characterDataChanged event
        handleCharacterDataChanged(mutation);
    }
}

function removeRecursive(element, evt) {
    if(element._configured) {
        Resource.notifyNodeIdChange(element, element.id, null);
        element._configured.notify(evt);
        delete element._configured;
    }
    var child = element.firstElementChild;
    while(child) {
        removeRecursive(child, evt);
        child = child.nextElementSibling;
    }
}

function addRecursive(element){
    var n = element.firstElementChild;
    while(n) {
        addRecursive(n);
        n = n.nextElementSibling;
    }
    // We call this here in addition to nodeInsertedIntoDocument, since the later is not supported by Firefox
    Resource.notifyNodeIdChange(element, null, element.id);
}

/**
 *
 * @param {MutationRecord} mutation
 */
function handleAttributeChanged(mutation) {
    var target = mutation.target;
    var elementHandler = target._configured;
    if (!elementHandler) {
        return;
    }

    var attributeHandler = elementHandler.handlers[mutation.attributeName] || elementHandler.handlers[mutation.attributeName.toLowerCase()];
    if (attributeHandler && attributeHandler.setFromAttribute) {
        var newValue = target.getAttribute(mutation.attributeName);
        var notified = attributeHandler.setFromAttribute(newValue, mutation.oldValue, target, elementHandler.storage);
        XML3D.debug.assert(!notified, "We assume no attribute handler notifies adapters anymore.");
    }
    elementHandler.attributeChangedCallback(mutation);
}


var ElementHandler = function(elem) {
    if (!elem) {
        return;
    }
    this.element = elem;
    this.handlers = null;
    this.storage = {};
    this.adapters = {};
    mutObserver.observe(elem, { childList: true,  attributes: true, attributeOldValue: true} );

};

ElementHandler.prototype.registerAttributes = function(config) {
    var elem = this.element;

    var isHTML = (elem instanceof HTMLElement);
    var keyPrefix = (isHTML ? "_html" : "_xml");
    var handlerKey = keyPrefix + "handlers",
        protoKey = keyPrefix + "proto";

    var canProto = !!elem.__proto__;

    if(!config._cache) config._cache = {};

    if(!config._cache[handlerKey]){
        // Create handlers and prototype only once per configuration
        var proto;
        if(canProto){
            var F = function () {
            };
            F.prototype = elem.__proto__;
            proto = new F();
        }

        var handlers = {};
        for ( var prop in config) {
            if(prop =="_cache") continue;
            if (config[prop] === undefined) {
                if(proto) delete proto[prop];
            } else {
                if (config[prop].a !== undefined) {
                    var attrName = config[prop].id || prop;
                    var handler = new config[prop].a(attrName, config[prop].params);
                    handlers[attrName.toLowerCase()] = handler;
                    if(proto) {
                        try {
                            Object.defineProperty(proto, prop, handler.desc);
                        } catch (e) {
                            XML3D.debug.logWarning("Can't configure " + elem.nodeName + "::" + prop);
                        }
                    }

                } else if (config[prop].m !== undefined) {
                    if(proto) proto[prop] = config[prop].m;
                } else if (config[prop].p !== undefined) {
                    if(proto){
                        try {
                            Object.defineProperty(proto, prop, config[prop].p);
                        } catch (e) {
                            XML3D.debug.logWarning("Can't configure " + elem.nodeName + "::" + prop);
                        }
                    }
                }else
                    XML3D.debug.logError("Can't configure " + elem.nodeName + "::" + prop);
            }
        }
        config._cache[handlerKey] = handlers;
        config._cache[protoKey] = proto;
    }
    // Set and initialize handlers for element
    this.handlers = config._cache[handlerKey];
    if(canProto){
        elem.__proto__ = config._cache[protoKey];
        for ( var prop in config) {
            if(prop =="_cache") continue;
            if(config[prop] && config[prop].a !== undefined){
                var attrName = config[prop].id || prop;
                var handler = this.handlers[attrName.toLowerCase()];
                handler.init && handler.init(elem, this.storage);
                delete elem[prop];
            }
        }
    }
    else{
        for ( var prop in config) {
            if(prop =="_cache") continue;
            if (config[prop] === undefined) {
                delete elem[prop];
            }
            else if (config[prop].a !== undefined){
                var attrName = config[prop].id || prop;
                var handler = this.handlers[attrName.toLowerCase()];
                handler.init && handler.init(elem, this.storage);
                try {
                    Object.defineProperty(elem, prop, handler.desc);
                } catch (e) {
                    XML3D.debug.logWarning("Can't configure " + elem.nodeName + "::" + prop);
                }
            }else if (config[prop].m !== undefined) {
                elem[prop] = config[prop].m;
            } else if (config[prop].p !== undefined) {
                try {
                    Object.defineProperty(elem, prop, config[prop].p);
                } catch (e) {
                    XML3D.debug.logWarning("Can't configure " + elem.nodeName + "::" + prop);
                }
            }
        }
    }

    return elem;
};


ElementHandler.prototype.registerMixed = function() {
    mutObserver.observe(this.element, { childList: true,  attributes: true, attributeOldValue: true, characterData: true, subtree: true} );
};

/**
 * @param evt
 */
ElementHandler.prototype.notify =  function(evt) {
    var adapters = this.adapters;
    for(var a in adapters) {
        try {
            adapters[a].notifyChanged(evt);
        } catch (e) {
            XML3D.debug.logException(e);
        }
    }
};

/**
 * @param {MutationRecord} mutation
 */
ElementHandler.prototype.attributeChangedCallback =  function(mutation) {
    var adapters = this.adapters;
    for(var a in adapters) {
        XML3D.debug.assert(adapters[a].attributeChangedCallback, "Adapter implements 'attributeChangedCallback': " + this.element.nodeName + " (" + a + ")");
        try {
            adapters[a].attributeChangedCallback(mutation.attributeName, mutation.oldValue, this.element.getAttribute(mutation.attributeName), mutation.attributeNamespace);
        } catch (e) {
            XML3D.debug.logException(e);
        }
    }
};

/*
 * Get called, if the related node gets removed from the DOM
 */
ElementHandler.prototype.remove = function(evt) {
    for(var h in this.adapters) {
        var adapter = this.adapters[h];
        if(adapter.dispose)
            adapter.dispose();
        if(adapter.clearAdapterHandles)
            adapter.clearAdapterHandles();
    }
    this.adapters = {};
    for(var h in this.handlers) {
        var handler = this.handlers[h];
        if(handler.remove)
            handler.remove();
    }

};

ElementHandler.prototype.toString = function() {
    return "ElementHandler ("+this.element.nodeName + ", id: "+this.element.id+")";
};

var delegateProperties = ["clientHeight", "clientLeft", "clientTop", "clientWidth",
    "offsetHeight", "offsetLeft", "offsetTop", "offsetWidth"];
function delegateProp(name, elem, canvas) {
    var desc = {
        configurable : true,
        get : function() {
            return canvas[name];
        }
    };
    try {
        Object.defineProperty(elem, name, desc);
    } catch (e){
        XML3D.debug.logWarning("Can't configure " + elem.nodeName + "::" + name);
    }
}

var XML3DHandler = function(elem) {
    ElementHandler.call(this, elem);
    var c = document.createElement("canvas");
    c.width = 800;
    c.height = 600;
    this.canvas = c;
    this.canvasHandler = { destroy:function() {} };

    for(var i in delegateProperties) {
        delegateProp(delegateProperties[i], elem, c);
    }

    elem.getBoundingClientRect = function() {
        return c.getBoundingClientRect();
    };

    this.destroy = function() {
        for(var i in delegateProperties) {
            delete elem[delegateProperties[i]];
        }
        this.canvasHandler.destroy();
    }
};

XML3D.createClass(XML3DHandler, ElementHandler);


var config = {};

/**
 * @param {Element} element
 * @return {undefined}
 */
config.element = function(element) {
    if (element._configured === undefined ) {
        var classInfo = ClassInfo[element.localName];
        if (classInfo === undefined) {
            XML3D.debug.logInfo("Unrecognised element " + element.localName);
        } else {
            element._configured = element.localName == "xml3d" ?
                new XML3DHandler(element)
                : new ElementHandler(element);
            element._configured.registerAttributes(classInfo);
            // Fix difference in Firefox (undefined) and Chrome (null)
            try{
                if (element.style == undefined)
                    element.style = null;
            }
            catch(e){
                // Firefox throws exception here...
            }

            var n = element.firstElementChild;

            Resource.notifyNodeIdChange(element, null, element.getAttribute("id"));

            while(n) {
                config.element(n);
                n = n.nextElementSibling;
            }
        }
    }
};

/**
 * @param {Element} element
 * @return {undefined}
 */
config.configure = function(element) {
    if (Array.isArray(element)) {
        element.forEach(function(el) {
            config.element(el);
        });
    } else {
        config.element(element);
    }
};


module.exports = {
    ElementHandler : ElementHandler,
    XML3DHandler : XML3DHandler,
    config : config
};

},{"../resource":165,"./configuration.js":70,"./notification.js":74}],73:[function(require,module,exports){
var sendAdapterEvent = require("../utils/misc.js").sendAdapterEvent;
var callAdapterFunc = require("../utils/misc.js").callAdapterFunc;
var CSS = require("../utils/css.js");
var Resource = require("../resource");

var Vec3 = require("../types/vec3.js");
var Mat4 = require("../types/mat4.js");
var vec3 = require("gl-matrix").vec3;

var methods = {};

methods.xml3dGetElementByRay = function(ray, hitPoint, hitNormal) {
    XML3D.flushDOMChanges();
    XML3D.flushCSSChanges();
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].getElementByRay) {
            return adapters[adapter].getElementByRay(ray, hitPoint, hitNormal);
        }
    }
    return null;
};

methods.viewGetViewMatrix = function() {
    XML3D.flushDOMChanges();
    var adapters = this._configured.adapters || {};
    for ( var adapter in adapters) {
        if (adapters[adapter].getViewMatrix) {
            return adapters[adapter].getViewMatrix();
        }
    }
    // Fallback implementation
    var result = new XML3D.Mat4();
    var cssMatrix = CSS.getCSSMatrix(this);
    if(cssMatrix) {
        CSS.convertCssToMat4(cssMatrix, result);
    }
    return result.invert();
};

methods.viewGetProjectionMatrix = function() {
    XML3D.flushDOMChanges();
    var adapters = this._configured.adapters || {};
    for ( var adapter in adapters) {
        if (adapters[adapter].getProjectionMatrix) {
            return adapters[adapter].getProjectionMatrix();
        }
    }
    return null;
};

methods.xml3dGetElementByPoint = function(x, y, hitPoint, hitNormal) {
    XML3D.flushDOMChanges();
    XML3D.flushCSSChanges();
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].getElementByPoint) {
            return adapters[adapter].getElementByPoint(x, y, hitPoint, hitNormal);
        }
    }
    return null;
};

methods.xml3dGenerateRay = function(x, y) {
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].generateRay) {
            return adapters[adapter].generateRay(x, y);
        }
    }
    return new XML3D.Ray();
};

/**
 * return the bounding box of the owning space in world space
 */
methods.getWorldBoundingBox = function() {
    XML3D.flushDOMChanges();
    // Visibility influences bounding box
    XML3D.flushCSSChanges();
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].getWorldBoundingBox) {
            return adapters[adapter].getWorldBoundingBox();
        }
    }
    return new XML3D.Box();
};

/**
 * return the bounding box of the owning space in local space (object BB)
 */
methods.getLocalBoundingBox = function() {
    XML3D.flushDOMChanges();
    // Visibility influences bounding box
    XML3D.flushCSSChanges();
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].getLocalBoundingBox) {
            return adapters[adapter].getLocalBoundingBox();
        }
    }
    return new XML3D.Box();
};

methods.xml3dGetRenderInterface = function() {
    XML3D.flushDOMChanges();
    var adapters = this._configured.adapters || {};
    for ( var adapter in adapters) {
        if (adapters[adapter].getRenderInterface) {
            return adapters[adapter].getRenderInterface();
        }
    }
    return {};
};


methods.XML3DGraphTypeGetWorldMatrix = function() {
    XML3D.flushDOMChanges();
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].getWorldMatrix) {
            return adapters[adapter].getWorldMatrix();
        }
    }
    return new Mat4();
};

methods.XML3DGraphTypeGetLocalMatrix = function() {
    XML3D.flushDOMChanges();
    var adapters = this._configured.adapters || {};
    for ( var adapter in adapters) {
        if (adapters[adapter].getLocalMatrix) {
            return adapters[adapter].getLocalMatrix();
        }
    }
    return new Mat4();
};

methods.videoPlay = function() {
    sendAdapterEvent(this, {play: []});
};

methods.videoPause = function() {
    sendAdapterEvent(this, {pause: []});
};

methods.XML3DNestedDataContainerTypeGetOutputNames =
methods.XML3DShaderProviderTypeGetOutputNames =
methods.meshGetOutputNames = function() {
    XML3D.flushDOMChanges();
    var dataAdapter = Resource.getAdapter(this, "data");
    if(dataAdapter){
        return dataAdapter.getOutputNames();
    }
    return null;
};

methods.XML3DNestedDataContainerTypeGetResult =
methods.XML3DShaderProviderTypeGetResult =
methods.meshGetResult = function(filter) {
    XML3D.flushDOMChanges();
    var dataAdapter = Resource.getAdapter(this, "data");
    if(dataAdapter){
        var result = dataAdapter.getComputeResult(filter);
        if(!result) return null;
        return new window.XML3DDataResult(result);
    }
    return null;
};

methods.XML3DNestedDataContainerTypeGetOutputChannelInfo =
    methods.XML3DShaderProviderTypeGetOutputChannelInfo =
        methods.meshGetOutputChannelInfo = function (name) {
            XML3D.flushDOMChanges();
            var dataAdapter = Resource.getAdapter(this, "data");
            if (dataAdapter) {
                var result = dataAdapter.getOutputChannelInfo(name);
                if (!result) return null;
                return new window.XML3DDataChannelInfo(result.type, result.origin, result.originalName,
                    result.seqLength, result.seqMinKey, result.seqMaxKey);
            }
            return null;
        };

function createValues(result, names) {
    var values = {};
    for (var i in names) {
        var name = names[i];
        var data = result.getOutputData(name) && result.getOutputData(name).getValue();
        if (data)
            values[name] = data;
    }
    return values;
}

/** Register data listener for data fields specified by names.
 *
 * @param names   single name or array of names that are monitored.
 * @param callback function that is called when selected data are changed.
 * @return {Boolean}
 */
methods.dataAddOutputFieldListener = function(names, callback) {
    XML3D.flushDOMChanges();
    if (!names)
        return false;

    // check if names is a single string, and convert it to array then
    var typeOfNames = Object.prototype.toString.call(names).slice(8, -1);
    if (typeOfNames === "String") {
        names = [names];
    }
    if (names.length == 0)
        return false;

    var request = callAdapterFunc(this, {
        getComputeRequest : [names, function(request, changeType) {
            callback(createValues(request.getResult(), names));
        }
        ]});
    if (request.length == 0)
        return false;
    var result = request[0].getResult();
    var values = createValues(result, names);
    if (Object.keys(values).length)
        callback(values);
    return true;
};

methods.XML3DDataSourceTypeSetScriptValue = function(data){
    var configData = this._configured;

    if(!configData)
        return;

    if(this.textContent != "[value set by script]")
        this.textContent = "[value set by script]";
    XML3D.flushDOMChanges();
    configData.scriptValue = data;

    var dataAdapter = Resource.getAdapter(this, "data");
    if(dataAdapter)
        dataAdapter.setScriptValue(data);

};

module.exports = methods;

},{"../resource":165,"../types/mat4.js":172,"../types/vec3.js":176,"../utils/css.js":179,"../utils/misc.js":182,"gl-matrix":1}],74:[function(require,module,exports){

/**
 * Types of change events
 * @enum {number}
 */
var events = {
      NODE_INSERTED: 0,
      VALUE_MODIFIED:  1,
      NODE_REMOVED: 2,
      THIS_REMOVED: 3,
      ADAPTER_HANDLE_CHANGED: 4,
      ADAPTER_VALUE_CHANGED: 5
};

//-----------------------------------------------------------------------------
//Class Notification
//-----------------------------------------------------------------------------
events.Notification = function(type) {
    this.type = type;
};
events.Notification.prototype.toString = function() {
    return "Notification (type:" + this.type + ")";
};
//-----------------------------------------------------------------------------
events.NotificationWrapper = function(mutation, type, affectedNode) {
    this.mutation = mutation;
    this.type = type;
    this.affectedNode = affectedNode;
};
XML3D.createClass(events.NotificationWrapper, events.Notification);
events.NotificationWrapper.prototype.toString = function() {
    return "NotificationWrapper (type:" + this.type + ", wrapped: "+ this.mutation +")";
};

//-----------------------------------------------------------------------------

/**
 * @param {AdapterHandle} handle
 * @param {int} type
 * @constructor
 */
events.AdapterHandleNotification = function (handle, type) {
    this.adapterHandle = handle;
    this.type = type;
};
XML3D.createClass(events.AdapterHandleNotification, events.Notification);
events.AdapterHandleNotification.prototype.toString = function () {
    return "AdapterHandleNotification (type:" + this.type + ")";
};
//-----------------------------------------------------------------------------

events.ConnectedAdapterNotification = function(adapterHandleNotification, key) {
    this.adapter = adapterHandleNotification.adapterHandle.getAdapter();
    this.key = key;
    this.url = adapterHandleNotification.adapterHandle.url;
    this.type = adapterHandleNotification.type;
    this.handleStatus = adapterHandleNotification.adapterHandle.status;
};
XML3D.createClass(events.ConnectedAdapterNotification, events.Notification);
events.ConnectedAdapterNotification.prototype.toString = function() {
    return "ConnectedAdapterNotification (type:" + this.type + ", key: " + this.key + ")";
};

module.exports = events;
},{}],75:[function(require,module,exports){
var properties = {};

properties.XML3DNestedDataContainerTypeComplete = {
    get: function(){
        XML3D.flushDOMChanges();
        var adapters = this._configured.adapters || {};
        for (var adapter in adapters) {
            if (adapters[adapter].getDataComplete) {
                return adapters[adapter].getDataComplete();
            }
        }
        return false;
    },
    set: function(){}
};

properties.AssetComplete = {
    get: function(){
        XML3D.flushDOMChanges();
        var adapters = this._configured.adapters || {};
        for (var adapter in adapters) {
            if (adapters[adapter].getAssetComplete) {
                return adapters[adapter].getAssetComplete();
            }
        }
        return false;
    },
    set: function(){}
};


properties.AssetProgressLevel = {
    get: function(){
        XML3D.flushDOMChanges();
        var adapters = this._configured.adapters || {};
        for (var adapter in adapters) {
            if (adapters[adapter].getAssetProgressLevel) {
                return adapters[adapter].getAssetProgressLevel();
            }
        }
        return false;
    },
    set: function(){}
};

properties.xml3dComplete = {
    get: function(){
        XML3D.flushDOMChanges();
        var adapters = this._configured.adapters || {};
        for (var adapter in adapters) {
            if (adapters[adapter].getComplete) {
                return adapters[adapter].getComplete();
            }
        }
        return false;
    },
    set: function(){}
};

module.exports = properties;

},{}],76:[function(require,module,exports){
module.exports = function (math) {

// Additional methods in glMatrix style
    math.vec3.reciprocal = function (dest, vec) {
        if (!dest) {
            dest = vec;
        }

        dest[0] = 1 / vec[0];
        dest[1] = 1 / vec[1];
        dest[2] = 1 / vec[2];
        return dest;
    };

    var toDOMString = function(data) {
        return Array.prototype.join.call(data, ' ');
    };

    math.vec2.toDOMString = toDOMString;

    math.vec2.fromDOMString = function(str) {
        var s = str.split(' ');
        if (s.length !== 2 || isNaN(+s[0]) || isNaN(+s[1])) {
            throw "Could not parse '"+str+"' into a valid vec2 object";
        }
        return math.vec2.fromValues(+s[0], +s[1]);
    };

    math.vec3.toDOMString = toDOMString;

    math.vec3.fromDOMString = function(str) {
        var s = str.split(' ');
        if (s.length !== 3 || isNaN(+s[0]) || isNaN(+s[1]) || isNaN(+s[2])) {
            throw "Could not parse '"+str+"' into a valid vec3 object";
        }
        return math.vec3.fromValues(+s[0], +s[1], +s[2]);
    };


    math.vec4.toDOMString = toDOMString;

    math.vec4.fromDOMString = function(str) {
        var s = str.split(' ');
        if (s.length !== 4 || isNaN(+s[0]) || isNaN(+s[1]) || isNaN(+s[2]) || isNaN(+s[3])) {
            throw "Could not parse '"+str+"' into a valid vec4 or quat object";
        }
        return math.vec4.fromValues(+s[0], +s[1], +s[2], +s[3]);
    };

    math.quat.toDOMString = toDOMString;

    math.quat.fromDOMString = math.vec4.fromDOMString;

    math.mat3.toDOMString = toDOMString;

    math.mat3.fromDOMString = function(str) {
        var s = str.split(' ');
        if (s.length !== 9) {
            throw "Could not parse '"+str+"' into a valid mat3 object";
        }
        var mat = math.mat3.create();
        for (var i=0; i<9; i++) {
            mat[i] = +s[i];
            if (isNaN(mat[i])) {
                throw "Could not parse '"+str+"' into a valid mat3 object";
            }
        }
        return mat;
    };

    math.mat4.toDOMString = toDOMString;

    math.mat4.fromDOMString = function(str) {
        var s = str.split(' ');
        if (s.length !== 16) {
            throw "Could not parse '"+str+"' into a valid mat4 object";
        }
        var mat = math.mat4.create();
        for (var i=0; i<16; i++) {
            mat[i] = +s[i];
            if (isNaN(mat[i])) {
                throw "Could not parse '"+str+"' into a valid mat4 object";
            }
        }
        return mat;
    };


    math.mat4.multiplyOffsetVec3 = function (mat, matOffset, vec, vecOffset, dest) {
        if (!dest) {
            dest = vec;
        }
        if (!vecOffset) {
            vecOffset = 0;
        }

        var x = vec[vecOffset + 0], y = vec[vecOffset + 1], z = vec[vecOffset + 2];

        dest[0] = mat[matOffset + 0] * x + mat[matOffset + 4] * y + mat[matOffset + 8] * z + mat[matOffset + 12];
        dest[1] = mat[matOffset + 1] * x + mat[matOffset + 5] * y + mat[matOffset + 9] * z + mat[matOffset + 13];
        dest[2] = mat[matOffset + 2] * x + mat[matOffset + 6] * y + mat[matOffset + 10] * z + mat[matOffset + 14];

        return dest;
    };


    math.mat4.multiplyOffsetDirection = function (mat, matOffset, vec, vecOffset, dest) {
        if (!dest) {
            dest = vec;
        }
        if (!vecOffset) {
            vecOffset = 0;
        }

        var x = vec[vecOffset + 0], y = vec[vecOffset + 1], z = vec[vecOffset + 2], w;

        dest[0] = mat[matOffset + 0] * x + mat[matOffset + 4] * y + mat[matOffset + 8] * z;
        dest[1] = mat[matOffset + 1] * x + mat[matOffset + 5] * y + mat[matOffset + 9] * z;
        dest[2] = mat[matOffset + 2] * x + mat[matOffset + 6] * y + mat[matOffset + 10] * z;

        return dest;
    };

    math.mat4.multiplyOffset = function (dest, destOffset, mat, offset1, mat2, offset2) {
        var a00 = mat2[offset2 + 0], a01 = mat2[offset2 + 1], a02 = mat2[offset2 + 2], a03 = mat2[offset2 + 3];
        var a10 = mat2[offset2 + 4], a11 = mat2[offset2 + 5], a12 = mat2[offset2 + 6], a13 = mat2[offset2 + 7];
        var a20 = mat2[offset2 + 8], a21 = mat2[offset2 + 9], a22 = mat2[offset2 + 10], a23 = mat2[offset2 + 11];
        var a30 = mat2[offset2 + 12], a31 = mat2[offset2 + 13], a32 = mat2[offset2 + 14], a33 = mat2[offset2 + 15];

        var b00 = mat[offset1 + 0], b01 = mat[offset1 + 1], b02 = mat[offset1 + 2], b03 = mat[offset1 + 3];
        var b10 = mat[offset1 + 4], b11 = mat[offset1 + 5], b12 = mat[offset1 + 6], b13 = mat[offset1 + 7];
        var b20 = mat[offset1 + 8], b21 = mat[offset1 + 9], b22 = mat[offset1 + 10], b23 = mat[offset1 + 11];
        var b30 = mat[offset1 + 12], b31 = mat[offset1 + 13], b32 = mat[offset1 + 14], b33 = mat[offset1 + 15];

        dest[destOffset + 0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
        dest[destOffset + 1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
        dest[destOffset + 2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
        dest[destOffset + 3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
        dest[destOffset + 4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
        dest[destOffset + 5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
        dest[destOffset + 6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
        dest[destOffset + 7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
        dest[destOffset + 8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
        dest[destOffset + 9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
        dest[destOffset + 10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
        dest[destOffset + 11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
        dest[destOffset + 12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
        dest[destOffset + 13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
        dest[destOffset + 14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
        dest[destOffset + 15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;
    };

    math.quat.slerpOffset = function (quat, offset1, quat2, offset2, t, dest, destOffset, shortest) {
        if (!dest) {
            dest = quat;
        }

        var ix1 = offset1, iy1 = offset1 + 1, iz1 = offset1 + 2, iw1 = offset1 + 3;
        var ix2 = offset2, iy2 = offset2 + 1, iz2 = offset2 + 2, iw2 = offset2 + 3;
        var ixd = destOffset, iyd = destOffset + 1, izd = destOffset + 2, iwd = destOffset + 3;

        var cosAngle = quat[ix1] * quat2[ix2] + quat[iy1] * quat2[iy2] + quat[iz1] * quat2[iz2] + quat[iw1] * quat2[iw2];

        var c1, c2;

        // Linear interpolation for close orientations
        if ((1.0 - Math.abs(cosAngle)) < 0.01) {
            c1 = 1.0 - t;
            c2 = t;
        } else {
            // Spherical interpolation
            var angle = Math.acos(Math.abs(cosAngle));
            var sinAngle = Math.sin(angle);
            c1 = Math.sin(angle * (1.0 - t)) / sinAngle;
            c2 = Math.sin(angle * t) / sinAngle;
        }

        // Use the shortest path
        if (shortest && (cosAngle < 0.0))
            c1 = -c1;

        dest[ixd] = c1 * quat[ix1] + c2 * quat2[ix2];
        dest[iyd] = c1 * quat[iy1] + c2 * quat2[iy2];
        dest[izd] = c1 * quat[iz1] + c2 * quat2[iz2];
        dest[iwd] = c1 * quat[iw1] + c2 * quat2[iw2];
    };

    math.quat.fromAxisAngle = function(axis, angle) {
        var q = math.quat.create();
        if (axis.length === 4 && angle === undefined) {
            math.quat.setAxisAngle(q, axis, axis[3]);
        } else {
            math.quat.setAxisAngle(q, axis, angle);
        }
        return math.quat.normalize(q,q);
    };

    /**
     * Transforms the vec3 with a mat4.
     * 4th vector component is implicitly '0'
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the vector to transform
     * @param {mat4} m matrix to transform with
     * @returns {vec3} out
     */
    math.vec3.transformDirection = function(out, a, m) {
        var x = a[0], y = a[1], z = a[2];
        out[0] = (m[0] * x + m[4] * y + m[8] * z);
        out[1] = (m[1] * x + m[5] * y + m[9] * z);
        out[2] = (m[2] * x + m[6] * y + m[10] * z);
        return out;
    };

    math.quat.setFromMat3 = function(dest, m) {
        var tr = m[0] + m[4] + m[8];

        if (tr > 0) {
            var s = Math.sqrt(tr + 1.0) * 2; // s=4*dest[3]
            dest[0] = (m[7] - m[5]) / s;
            dest[1] = (m[2] - m[6]) / s;
            dest[2] = (m[3] - m[1]) / s;
            dest[3] = 0.25 * s;
        } else if ((m[0] > m[4]) && (m[0] > m[8])) {
            var s = Math.sqrt(1.0 + m[0] - m[4] - m[8]) * 2; // s=4*qx
            dest[3] = (m[7] - m[5]) / s;
            dest[0] = 0.25 * s;
            dest[1] = (m[1] + m[3]) / s;
            dest[2] = (m[2] + m[6]) / s;
        } else if (m[4] > m[8]) {
            var s = Math.sqrt(1.0 + m[4] - m[0] - m[8]) * 2; // s=4*qy
            dest[3] = (m[2] - m[6]) / s;
            dest[0] = (m[1] + m[3]) / s;
            dest[1] = 0.25 * s;
            dest[2] = (m[5] + m[7]) / s;
        } else {
            var s = Math.sqrt(1.0 + m[8] - m[0] - m[4]) * 2; // s=4*qz
            dest[3] = (m[3] - m[1]) / s;
            dest[0] = (m[2] + m[6]) / s;
            dest[1] = (m[5] + m[7]) / s;
            dest[2] = 0.25 * s;
        }
        return dest;
    };

    math.quat.setFromBasis = function(dest, X,Y,Z) {
        var lx = 1.0 / XML3D.math.vec3.length(X);
        var ly = 1.0 / XML3D.math.vec3.length(Y);
        var lz = 1.0 / XML3D.math.vec3.length(Z);
        var m = XML3D.math.mat3.create();
        m[0] = X[0] * lx;
        m[1] = Y[0] * ly;
        m[2] = Z[0] * lz;
        m[3] = X[1] * lx;
        m[4] = Y[1] * ly;
        m[5] = Z[1] * lz;
        m[6] = X[2] * lx;
        m[7] = Y[2] * ly;
        m[8] = Z[2] * lz;
        return XML3D.math.quat.setFromMat3(dest, m);
    };

    math.vec4.fromQuat = function(q) {
        var dest = XML3D.math.vec4.create();
        if (q[3] > 1) {
            XML3D.math.quat.normalize(q,q);
        }
        var s = Math.sqrt(1-q[3]*q[3]);
        var angle = 2*Math.acos(q[3]);
        if (s < 0.0001) {
            // Axis is practically 0 so we return the identity axis angle
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 1;
            dest[3] = 0;
        } else {
            dest[0] = q[0] / s;
            dest[1] = q[1] / s;
            dest[2] = q[2] / s;
            dest[3] = angle;
        }
        return dest;
    };


};

},{}],77:[function(require,module,exports){
var NodeAdapter = require("../../../base/adapter.js").NodeAdapter;

var RenderAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
};

XML3D.createClass(RenderAdapter, NodeAdapter, {

    getParentRenderAdapter: function () {
        return this.factory.getAdapter(this.node.parentNode, RenderAdapter);
    },

    /**
     * @param element
     */
    initElement: function (element) {
        this.factory.getAdapter(element);
        this.initChildElements(element);
    },

    /**
     * @param {Element} element
     */
    initChildElements: function (element) {
        var child = element.firstElementChild;
        while (child) {
            this.initElement(child);
            child = child.nextElementSibling;
        }
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
    },

    styleChangedCallback: function () {
    },

    getScene: function () {
        return this.factory.renderer.scene;
    }
});

module.exports = RenderAdapter;

},{"../../../base/adapter.js":48}],78:[function(require,module,exports){
var RenderAdapter = require("./base.js");

//Adapter for <defs>
var DefsRenderAdapter = function (factory, node) {
    RenderAdapter.call(this, factory, node);
};
XML3D.createClass(DefsRenderAdapter, RenderAdapter);

module.exports = DefsRenderAdapter;

},{"./base.js":77}],79:[function(require,module,exports){
var NodeAdapterFactory = require("../../../base/adapter.js").NodeAdapterFactory;

/**
 * @constructor
 * @implements {XML3D.base.IFactory}
 * @extends XML3D.base.NodeAdapterFactory
 * @param {number} canvasId
 */
var RenderAdapterFactory = function (canvasId) {
    NodeAdapterFactory.call(this, "scene", canvasId);
    this.type = "RenderAdapterFactory";
};
XML3D.createClass(RenderAdapterFactory, NodeAdapterFactory);

var registry = {
        xml3d: require("./xml3d.js"),
        view: require("./view.js"),
        defs: require("./defs.js"),
        mesh: require("./mesh.js"),
        model: require("./model.js"),
        material: require("./material.js"),
        shader: require("./material.js"), // TODO(ksons): Remove in 5.1
        group: require("./group.js"),
        light: require("./light.js"),
        lightshader: require("./lightshader.js") // TODO(ksons): Remove in 5.1
    };

/**
 * @param node
 * @return {XML3D.base.Adapter|null}
 */
RenderAdapterFactory.prototype.createAdapter = function (node) {
    var adapterConstructor = registry[node.localName];
    if (adapterConstructor !== undefined) {
        return new adapterConstructor(this, node);
    }
    return null;
};

RenderAdapterFactory.prototype.setScene = function (scene) {
    this.scene = scene;
};

RenderAdapterFactory.prototype.getScene = function () {
    return this.scene;
};

RenderAdapterFactory.prototype.setRenderer = function (renderer) {
    this.renderer = renderer;
};

RenderAdapterFactory.prototype.getRenderer = function () {
    return this.renderer;
};

// Export
module.exports = RenderAdapterFactory;

},{"../../../base/adapter.js":48,"./defs.js":78,"./group.js":80,"./light.js":81,"./lightshader.js":82,"./material.js":83,"./mesh.js":84,"./model.js":85,"./view.js":87,"./xml3d.js":88}],80:[function(require,module,exports){
var SceneElementAdapter = require("./scene-element.js");
var Events = require("../../../interface/notification.js");
var mat4 = require("gl-matrix").mat4;

var GroupRenderAdapter = function (factory, node) {
    SceneElementAdapter.call(this, factory, node, true, true);
    this.createRenderNode();
};

XML3D.createClass(GroupRenderAdapter, SceneElementAdapter, {

    createRenderNode: function () {
        var parent = this.getParentRenderAdapter();
        var parentNode = parent.getRenderNode && parent.getRenderNode();
        this.renderNode = this.getScene().createRenderGroup({
            parent: parentNode, name: this.node.id
        });
        this.updateLocalMatrix();
        this.updateMaterialHandler();
        this.updateVisibility();
        this.renderNode.setWorldSpaceBoundingBox(new XML3D.Box());
    },

    /* Interface methods */
    getWorldBoundingBox: function () {
        var bbox = new XML3D.Box();
        this.renderNode.getWorldSpaceBoundingBox(bbox);
        return bbox;
    },

    getLocalBoundingBox: (function () {
        var localMat = mat4.create();
        var childBB = new XML3D.Box();

        return function () {
            var bbox = new XML3D.Box();
            Array.prototype.forEach.call(this.node.childNodes, function (c) {
                if (c.getLocalBoundingBox) {
                    childBB = c.getLocalBoundingBox();
                    bbox.extend(childBB);
                }
            });
            this.renderNode.getLocalMatrix(localMat);
            bbox.transformAxisAligned(localMat);
            return bbox;
        }
    })(),

    getLocalMatrix: function () {
        var m = new XML3D.Mat4();
        this.renderNode.getLocalMatrix(m.data);
        return m;
    },

    getWorldMatrix: function () {
        var m = new XML3D.Mat4();
        this.renderNode.getWorldMatrix(m.data);
        return m;
    }
});

module.exports = GroupRenderAdapter;

},{"../../../interface/notification.js":74,"./scene-element.js":86,"gl-matrix":1}],81:[function(require,module,exports){
var SceneElementAdapter = require("./scene-element.js");

var Events = require("../../../interface/notification.js");
var LightConfiguration = require("../scene/configuration.js");
var Resource = require("../../../resource");

var DEFAULT_LIGHT_MODEL = "urn:xml3d:light:directional";
/**
 * Adapter for <light>
 * @constructor
 * @param {RenderAdapterFactory} factory
 * @param {Element} node
 */
var LightRenderAdapter = function (factory, node) {
    SceneElementAdapter.call(this, factory, node, false, true);
    this.dataAdapter = Resource.getAdapter(node, "data");
    this.createRenderNode();
};

XML3D.createClass(LightRenderAdapter, SceneElementAdapter, {

    createRenderNode: function () {
        var parentAdapter = this.getParentRenderAdapter();
        var parentNode = parentAdapter.getRenderNode && parentAdapter.getRenderNode();
        this.renderNode = this.factory.getScene().createRenderLight({
            configuration: this.createLightConfiguration(),
            parent: parentNode
        });
        this.updateVisibility();
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        SceneElementAdapter.prototype.attributeChangedCallback.call(this, name, oldValue, newValue);

        switch (name) {
            case "intensity": // TODO(ksons): remove in 5.1
                XML3D.debug.logWarning("The <light> attribute intensity is deprecated in XML3D 5.0.", this.node);
                break;
            case "model":
                this.renderNode.remove();
                this.createRenderNode();
                break;
        }
    },

    updateVisibility: function () {
        var none = this.style.getPropertyValue("display").trim() == "none";
        this.renderNode.setLocalVisible(!none);
    },


    notifyChanged: function (evt) {
        switch (evt.type) {
            case Events.NODE_REMOVED:
                return;
            case Events.THIS_REMOVED:
                this.dispose();
                return;
        }
    },

    createLightConfiguration: function () {
        var model = this.node.hasAttribute("model") ? this.node.getAttribute("model") : DEFAULT_LIGHT_MODEL;
        var opt = {
            name: this.node.id
        };
        return new LightConfiguration(model, this.dataAdapter.getXflowNode(), opt);
    },

    dispose: function () {
        this.getRenderNode().remove();
        this.clearAdapterHandles();
    },

    /**
     * @return {XML3D.Mat4}
     */
    getWorldMatrix: function () {
        var m = new XML3D.Mat4();
        this.renderNode.getWorldMatrix(m.data);
        return m;
    }
});

// Export
module.exports = LightRenderAdapter;


},{"../../../interface/notification.js":74,"../../../resource":165,"../scene/configuration.js":97,"./scene-element.js":86}],82:[function(require,module,exports){
var RenderAdapter = require("./base.js");

/**
 * Adapter for <lightshader>
 * TODO(ksons): Remove in 5.1
 * @constructor
 * @param {RenderAdapterFactory} factory
 * @param {Element} node
 * @extends RenderAdapter
 */
var LightShaderRenderAdapter = function (factory, node) {
    RenderAdapter.call(this, factory, node);
    XML3D.debug.logWarning("The <lightshader> element is deprecated in XML3D 5.0.", node);
};

// Export
module.exports = LightShaderRenderAdapter;


},{"./base.js":77}],83:[function(require,module,exports){
var RenderAdapter = require("./base.js");
var Events = require("../../../interface/notification.js");
var URI = require("../../../utils/uri.js").URI;
var AdapterHandle = require("../../../base/adapterhandle.js");
var Resource = require("../../../resource");

/**
 * @param factory
 * @param {Element} node
 * @extends RenderAdapter
 * @constructor
 */
var MaterialRenderAdapter = function (factory, node) {
    RenderAdapter.call(this, factory, node);
    this._dataAdapter = Resource.getAdapter(node, "data");
    /** @type MaterialConfiguration | null **/
    this._materialConfiguration = null;
    this._materialModel = null;

    this.updateMaterialConfiguration();
};

XML3D.createClass(MaterialRenderAdapter, RenderAdapter,  {

    getMaterialConfiguration: function() {
        return this._materialConfiguration;
    },

    updateMaterialConfiguration: function () {
        // First find the model
        this.updateMaterialModel();
        if (!this._materialModel) {
            this._materialConfiguration = null;
        } else {
            this._materialConfiguration = this.getScene().createMaterialConfiguration(this._materialModel, this._dataAdapter.getXflowNode(), {name: this.node.id});
        }
        this.notifyOppositeAdapters();
    },

    updateMaterialModel: function () {
        this._materialModel = null;

        var uri = this.getMaterialModel();
        if (uri.scheme == "urn") {
            this.disconnectAdapterHandle("model");
            this._materialModel = { "type": "urn", "urn": uri };
            return;
        }

        this.connectAdapterHandle("model", this.getAdapterHandle(uri, "data", 0));
        var adapter = this.getConnectedAdapter("model");
        if (adapter && adapter.getScriptType) {
            this._materialModel = { type: adapter.getScriptType(), script: adapter.getScript() };
        }
    },

    getMaterialModel: function () {
        return new URI(this.node.getAttribute("model"));
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        if (name == "model") {
            this.updateMaterialConfiguration();
        }
    },

    notifyChanged: function (evt) {
        switch (evt.type) {
            case Events.ADAPTER_HANDLE_CHANGED:
                if (evt.handleStatus == AdapterHandle.STATUS.NOT_FOUND) {
                    XML3D.debug.logError("Could not find material for url '" + evt.url + "'");

                }
                this.updateMaterialConfiguration();
                break;
        }
    }
});

// Export
module.exports = MaterialRenderAdapter;


},{"../../../base/adapterhandle.js":49,"../../../interface/notification.js":74,"../../../resource":165,"../../../utils/uri.js":184,"./base.js":77}],84:[function(require,module,exports){
var SceneElementAdapter = require("./scene-element.js");

var Events = require("../../../interface/notification.js");
var encodeZIndex = require("../../../utils/misc.js").encodeZIndex;
var Resource = require("../../../resource");

var DEFAULT_PRIMITIVE_TYPE = "triangles";

/**
 * @constructor
 */
var MeshRenderAdapter = function (factory, node) {
    SceneElementAdapter.call(this, factory, node, true, true);
    this.createRenderNode();
};

XML3D.createClass(MeshRenderAdapter, SceneElementAdapter, {

    createRenderNode: function () {
        var parent = this.getParentRenderAdapter();
        var parentNode = parent.getRenderNode && parent.getRenderNode();

        this.renderNode = this.getScene().createRenderObject({
            parent: parentNode,
            node: this.node,
            configuration: this.createMeshConfiguration(),
            name: this.node.id
        });
        this.updateZIndex();
        this.updateVisibility();
        this.updateLocalMatrix();
        this.updateMaterialHandler();
    },

    createMeshConfiguration: function () {
        return {
            data: Resource.getAdapter(this.node, "data").getXflowNode(),
            type: this.node.hasAttribute("type") ? this.node.getAttribute("type") : DEFAULT_PRIMITIVE_TYPE
        }
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        SceneElementAdapter.prototype.attributeChangedCallback.call(this, name, oldValue, newValue);
        if (name == "type") {
            this.renderNode.remove();
            this.createRenderNode();
        }
    },

    updateZIndex: function() {
        var zIndex = this.style.getPropertyValue("z-index");
        zIndex = encodeZIndex(zIndex, true);

        var parent = this.getParentRenderAdapter();
        while (parent) {
            if (parent.style) {
                var parentZ = parent.style.getPropertyValue("z-index");
                parentZ = encodeZIndex(parentZ, false);
                if (parentZ != "")
                    zIndex = parentZ + ":" + zIndex;
            }
            parent = parent.getParentRenderAdapter();
        }

        this.renderNode.setZIndex(zIndex);
    },

    /**
     * @param {Events.Notification} evt
     */
    notifyChanged: function (evt) {
        SceneElementAdapter.prototype.notifyChanged.call(this, evt);
    },

    // Interface methods

    /**
     * @return {XML3D.Box}
     */
    getLocalBoundingBox: function () {
        var bbox = new XML3D.Box();
        if (this.renderNode && this.renderNode.visible) {
            this.renderNode.getObjectSpaceBoundingBox(bbox);
        }
        return bbox;
    },

    /**
     * @return {XML3D.Box}
     */
    getWorldBoundingBox: function () {
        var bbox = new XML3D.Box();
        if (this.renderNode && this.renderNode.visible) {
            this.renderNode.getWorldSpaceBoundingBox(bbox);
        }
        return bbox;
    },

    /**
     * @return {mat4}
     */
    getWorldMatrix: function () {
        var m = new XML3D.Mat4(), obj = this.renderNode;
        if (obj) {
            obj.getWorldMatrix(m.data);
        }
        return m;
    }
});

// Export
module.exports = MeshRenderAdapter;


},{"../../../interface/notification.js":74,"../../../resource":165,"../../../utils/misc.js":182,"./scene-element.js":86}],85:[function(require,module,exports){
var SceneElementAdapter = require("./scene-element.js");
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;
var Events = require("../../../interface/notification.js");
var AdapterHandle = require("../../../base/adapterhandle.js");
var encodeZIndex = require("../../../utils/misc.js").encodeZIndex;
var mat4 = require("gl-matrix").mat4;
var Resource = require("../../../resource");


var ModelRenderAdapter = function (factory, node) {
    SceneElementAdapter.call(this, factory, node, false, true);
    this.asset = null;
    this.postTransformXflowRequests = [];
    this.postTransformRenderGroups = [];
    this.createRenderNode();
    this._bindedRequestCallback = this.onXflowRequestChange.bind(this);
    this.transformFetcher.update();
};

var c_IDENTITY = mat4.create();

XML3D.createClass(ModelRenderAdapter, SceneElementAdapter, {

    createRenderNode: function () {
        var dataAdapter = Resource.getAdapter(this.node, "data");
        this.asset = dataAdapter.getAsset();

        this.asset.addChangeListener(this);

        var parent = this.getParentRenderAdapter();
        var parentNode = parent.getRenderNode && parent.getRenderNode();

        this.renderNode = this.getScene().createRenderGroup({
            parent: parentNode, name: this.node.id
        });
        this.renderNode.setLocalMatrix(c_IDENTITY);
        this.createModelRenderNodes();
        this.updateVisibility();
    },

    clearModelRenderNodes: function () {
        this.clearAdapterHandles();
        this._subRenderNodes = [];
        var i = this.postTransformXflowRequests.length;
        while (i--) {
            this.postTransformXflowRequests[i].clear();
        }
        rec_removeRenderNodes(this.renderNode, true);
        this.postTransformXflowRequests.length = 0;
        this.postTransformRenderGroups.length = 0;
    },

    createModelRenderNodes: function () {
        this.clearModelRenderNodes();
        if (!this.asset.isSubtreeLoading()) {
            try {
                this.asset.checkValidity();
                var assetResult = this.asset.getResult();
                var dataTree = assetResult.getDataTree();
                rec_createRenderNodes(this, this.renderNode, dataTree);
                this.updateZIndex();
            } catch (e) {
                XML3D.debug.logError("Asset Error: " + e.message, e.node || this.node);
                this.clearModelRenderNodes();
            }
        }
    },

    getMaterialConfiguration: function (materialURI, index) {
        var result = null;
        if (materialURI) {
            var adapterHandle = this.getAdapterHandle(materialURI);
            this.connectAdapterHandle("material_" + index, adapterHandle);

            switch (adapterHandle.status) {

                case AdapterHandle.STATUS.NOT_FOUND:
                    XML3D.debug.logError("Could not find <material> of url '" + adapterHandle.url + "' ", this.node);
                    break;
                case AdapterHandle.STATUS.READY:
                    var adapter = adapterHandle.getAdapter();
                    if (adapter && adapter.getMaterialConfiguration) {
                        result = adapter.getMaterialConfiguration();
                    }
                    break;
                case AdapterHandle.STATUS.LOADING:
                    break;
            }

        }
        return result;
    },

    updateVisibility: function() {
        var none = this.style.getPropertyValue("display").trim() == "none";
        var hidden  = this.style.getPropertyValue("visibility").trim() == "hidden";
        var visible = !(none || hidden);
        var propagate = function(node) {
            if (node.setLocalVisible) {
                 node.setLocalVisible(visible)
            }
            if (node.children) {
                node.children.forEach(propagate);
            }
        };
        propagate(this.renderNode);
    },

    updateZIndex: function() {
        var zIndex = this.style.getPropertyValue("z-index");
        zIndex = encodeZIndex(zIndex, true);

        var parent = this.getParentRenderAdapter();
        while (parent) {
            if (parent.style) {
                var parentZ = parent.style.getPropertyValue("z-index");
                parentZ = encodeZIndex(parentZ, false);
                if (parentZ != "")
                    zIndex = parentZ + ":" + zIndex;
            }
            parent = parent.getParentRenderAdapter();
        }

        var propagate = function(node) {
            if (node.setZIndex) {
                node.setZIndex(zIndex);
            }
            if (node.children) {
                node.children.forEach(propagate);
            }
        };
        propagate(this.renderNode);
    },


    /**
     * @param evt
     */
    notifyChanged: function (evt) {
        SceneElementAdapter.prototype.notifyChanged.call(this, evt);
        switch (evt.type) {
            case Events.ADAPTER_HANDLE_CHANGED:
                var splits = evt.key.split("_");
                if (splits[0] == "material") {
                    var renderNodeId = +splits[1];
                    // We identify the corresponding rendernode by the handler key
                    // This is a workaround that should be removed if there are
                    // custom callbacks for
                    var renderNode = this._subRenderNodes[renderNodeId];
                    XML3D.debug.assert(renderNode);
                    if (evt.handleStatus == AdapterHandle.STATUS.NOT_FOUND) {
                        renderNode.setMaterial(null);
                    } else {
                        var adapter = evt.adapter;
                        if (adapter && adapter.getMaterialConfiguration) {
                            renderNode.setMaterial(adapter.getMaterialConfiguration());
                        }
                    }
                    this.factory.renderer.requestRedraw("Material model changed.");
                }
        }
    },

    onAssetChange: function () {
         if (!this.renderNode) {
            //This model hasn't even been initialized yet so we defer building the render nodes to that step
            //This can happen for ex. when changing the "src" attribute before the model is appended into the DOM
            return;
        }

        this.createModelRenderNodes();
    },

    onXflowRequestChange: function (request) {
        var index = this.postTransformXflowRequests.indexOf(request);
        if (index != -1) {
            this.updatePostTransform(this.postTransformRenderGroups[index], request);
        }
    },

    updatePostTransform: function (renderNode, xflowRequest) {
        var dataResult = xflowRequest.getResult();
        var transformData = (dataResult.getOutputData("transform") && dataResult.getOutputData("transform").getValue());
        if (!transformData) {
            XML3D.debug.logWarning("Post Transform entry does not contain any 'transform' value.", this.node);
            renderNode.setLocalMatrix(c_IDENTITY);
            return;
        }
        renderNode.setLocalMatrix(transformData);
    },

    dispose: function () {
        this.asset.removeChangeListener(this);
        this.clearModelRenderNodes();
        this.getRenderNode().remove();
        this.clearAdapterHandles();
    }
});

function rec_removeRenderNodes(node, keepCurrentNode) {
    if (!node) {
        return;
    }
    if (!keepCurrentNode)
        node.remove();
    var children = node.getChildren();
    var i = children.length;
    while (i--) {
        rec_removeRenderNodes(children[i], false);
    }
}

function rec_createRenderNodes(adapter, parentNode, dataTreeNode) {

    if (dataTreeNode.postTransformXflowNode) {
        var request = new ComputeRequest(dataTreeNode.postTransformXflowNode, ["transform"], adapter._bindedRequestCallback);
        parentNode = adapter.getScene().createRenderGroup({
            parent: parentNode, visible: true, name: undefined
        });
        adapter.postTransformXflowRequests.push(request);
        adapter.postTransformRenderGroups.push(parentNode);
        adapter.updatePostTransform(parentNode, request);
    }

    var groupNode = adapter.getScene().createRenderGroup({
        parent: parentNode,
        visible: true,
        name: adapter.node.id
    });
    groupNode.setLocalMatrix(dataTreeNode.transform || c_IDENTITY);
    groupNode.setMaterial(adapter.getMaterialConfiguration(dataTreeNode.material, adapter._subRenderNodes.length));
    adapter._subRenderNodes.push(groupNode);

    var meshSets = dataTreeNode.meshes, i;
    for (i = 0; i < meshSets.length; ++i) {
        var renderNode = adapter.getScene().createRenderObject({
            parent: groupNode,
            node: meshSets[i].refNode || adapter.node,
            configuration: {
                data: meshSets[i].xflowNode, type: meshSets[i].type
            },
            name: adapter.node.id,
            visible: meshSets[i].visible
        });
        renderNode.setLocalMatrix(meshSets[i].transform || c_IDENTITY);
        renderNode.setMaterial(adapter.getMaterialConfiguration(meshSets[i].material, adapter._subRenderNodes.length));
        adapter._subRenderNodes.push(renderNode);
    }
    var groups = dataTreeNode.groups;
    for (i = 0; i < groups.length; ++i) {
        rec_createRenderNodes(adapter, groupNode, groups[i]);
    }
}


// Interface methods

XML3D.extend(ModelRenderAdapter.prototype, {
    /**
     * @return {XML3D.Box}
     */
    getLocalBoundingBox: function () {
        var bbox = new XML3D.Box();
        if (this.renderNode) {
            this.renderNode.getObjectSpaceBoundingBox(bbox);
        }
        return bbox;
    },

    /**
     * @return {XML3D.Box}
     */
    getWorldBoundingBox: function () {
        var bbox = new XML3D.Box();
        if (this.renderNode) {
            this.renderNode.getWorldSpaceBoundingBox(bbox);
        }
        return bbox;
    },

    /**
     * @return {mat4}
     */
    getWorldMatrix: function () {
        var m = new XML3D.Mat4(), obj = this.renderNode;
        if (obj) {
            obj.getWorldMatrix(m.data);
        }
        return m;
    }
});

// Export
module.exports = ModelRenderAdapter;


},{"../../../base/adapterhandle.js":49,"../../../interface/notification.js":74,"../../../resource":165,"../../../utils/misc.js":182,"../../../xflow/interface/request.js":190,"./scene-element.js":86,"gl-matrix":1}],86:[function(require,module,exports){
var RenderAdapter = require("./base.js");
var DOMTransformFetcher = require("../../../data/transform-fetcher.js");
var Events = require("../../../interface/notification.js");
var AdapterHandle = require("../../../base/adapterhandle.js");

/**
 * The SceneElementAdapter adapter is the base adapter for all scene elements,
 * i.e. <group>, <view>, <mesh>, <light> and <model>. These are also
 * those element that create an object inside the {@link Scene} data structure
 *
 * @param {RenderAdapterFactory} factory
 * @param {HTMLElement} node
 * @param handleMaterial
 * @constructor
 * @extends RenderAdapter
 * @see @link http://xml3d.org/xml3d/specification/5.0/#scene-elements
 */
var SceneElementAdapter = function (factory, node, handleMaterial) {
    RenderAdapter.call(this, factory, node);
    this.renderNode = null;

    /**
     * Living object: Holds the style of the associated node
     * @type {CSSStyleDeclaration}
     */
    this.style = window.getComputedStyle(node);

    this.materialHandler = null;
    this.handleMaterial = handleMaterial || false;
    this.transformFetcher = new DOMTransformFetcher(this, "transform", "transform");
};

XML3D.createClass(SceneElementAdapter, RenderAdapter, {

    updateMaterialHandler: function () {
        var materialURI = getMaterialURI(this.node);
        if (!materialURI) {
            this.disconnectAdapterHandle("material");
            this.materialHandler = null;
        } else {
            this.materialHandler = this.getAdapterHandle(materialURI);
            this.connectAdapterHandle("material", this.materialHandler);
        }
        this.referencedMaterialChanged();
    },

    referencedMaterialChanged: function () {
        if (!this.materialHandler) {
            this.getRenderNode().setMaterial(null);
            return;
        }
        var status = this.materialHandler.status;
        if (status === AdapterHandle.STATUS.NOT_FOUND) {
            XML3D.debug.logError("Could not find element of url '" + this.materialHandler.url + "' for material", this.node);
            this.getRenderNode().setMaterial(null);
            return;
        }
        var adapter = this.materialHandler.getAdapter();
        if (adapter && adapter.getMaterialConfiguration) {
            this.getRenderNode().setMaterial(adapter.getMaterialConfiguration());
        } else {
            this.getRenderNode().setMaterial(null);
        }
    },

    onConfigured: function () {
    },

    getRenderNode: function () {
        if (!this.renderNode) {
            this.renderNode = this.createRenderNode ? this.createRenderNode() : null;
        }
        return this.renderNode;
    },

    updateVisibility: function () {
        var none = this.style.getPropertyValue("display").trim() == "none";
        var hidden = this.style.getPropertyValue("visibility").trim() == "hidden";
        this.renderNode.setLocalVisible(!(none || hidden));
    },


    updateZIndex: function() {
        //This function is overridden by the leaf nodes (mesh, model), otherwise it should do nothing
    },

    dispose: function() {
        this.getRenderNode().remove();
        this.transformFetcher && this.transformFetcher.dispose();
        this.clearAdapterHandles();
    },

    styleChangedCallback: function() {
        this.updateZIndex();
        this.updateVisibility();
    },

    updateLocalMatrix: function () {
        this.transformFetcher && this.transformFetcher.update();
    },

    onTransformChange: function (attrName, matrix) {
        if (attrName == "transform") {
            this.renderNode.setLocalMatrix(matrix);
        }

    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        RenderAdapter.prototype.attributeChangedCallback.call(this, name, oldValue, newValue);

        if (name == "transform") {
            this.transformFetcher && this.transformFetcher.update();
        } else if (name == "style") {
            this.transformFetcher && this.transformFetcher.updateMatrix();
        } else if (name == "material" && this.handleMaterial) {
            this.updateMaterialHandler();
            this.factory.renderer.requestRedraw("Transformable material changed.");
        }
    },

    notifyChanged: function (evt) {
        switch (evt.type) {
            case Events.ADAPTER_HANDLE_CHANGED:
                var key = evt.key;
                if (key == "material") {
                    this.updateMaterialHandler();
                    this.factory.renderer.requestRedraw("Material reference changed.");
                }
                break;
            case Events.THIS_REMOVED:
                this.dispose();
                break;
            case Events.NODE_INSERTED:
                this.initElement(evt.affectedNode);
                break;
            default:
                XML3D.debug.logDebug("Unhandled event in SceneElementAdapter:", evt);
        }
    }
});



function getMaterialURI(node) {
    var materialURI = node.getAttribute("material");
    if (!materialURI) {
        var styleValue = node.getAttribute('style');
        if (styleValue) {
            var pattern = /material\s*:\s*url\s*\(\s*(\S+)\s*\)/i;
            var result = pattern.exec(styleValue);
            if (result)
                materialURI = result[1];
        }
    }
    return materialURI;
}

module.exports = SceneElementAdapter;

},{"../../../base/adapterhandle.js":49,"../../../data/transform-fetcher.js":66,"../../../interface/notification.js":74,"./base.js":77}],87:[function(require,module,exports){
var SceneElementAdapter = require("./scene-element.js");
var CameraConfiguration = require("../scene/configuration.js");
var Resource = require("../../../resource");

var DEFAULT_CAMERA_MODEL = "urn:xml3d:view:perspective";

/**
 * Adapter for <view>
 * @param {RenderAdapterFactory} factory
 * @param {Element} node
 * @extends SceneElementAdapter
 * @constructor
 */
var ViewRenderAdapter = function (factory, node) {
    SceneElementAdapter.call(this, factory, node, false, false);
    this.dataAdapter = Resource.getAdapter(node, "data");
    this.createRenderNode();
};
XML3D.createClass(ViewRenderAdapter, SceneElementAdapter, {

    createRenderNode: function () {
        var parent = this.getParentRenderAdapter();
        var parentNode = parent.getRenderNode ? parent.getRenderNode() : this.factory.renderer.scene.createRootNode();
        this.renderNode = this.factory.renderer.scene.createRenderView({
            camera: this.createCameraConfiguration(), parent: parentNode
        });
        this.updateLocalMatrix();
    },

    createCameraConfiguration: function () {
        var model = this.node.hasAttribute("model") ? this.node.getAttribute("model") : DEFAULT_CAMERA_MODEL;
        return new CameraConfiguration(model, this.dataAdapter.getXflowNode(), {name: this.node.id});
    },


    /* Interface method */
    getViewMatrix: function () {
        var m = new XML3D.Mat4();
        this.renderNode.getWorldToViewMatrix(m.data);
        return m;
    },

    /**
     * returns view2world matrix
     * @return {mat4}
     */
    getWorldMatrix: function () {
        var m = new XML3D.Mat4();
        this.renderNode.getViewToWorldMatrix(m.data);
        return m;
    },

    getProjectionMatrix: function () {
        var m = new XML3D.Mat4();
        this.renderNode.getProjectionMatrix(m.data);
        return m;
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        SceneElementAdapter.prototype.attributeChangedCallback.call(this, name, oldValue, newValue);
        switch (name) {
            case "model":
                this.renderNode.remove();
                this.createRenderNode();
                break;
        }
    }
});

// Export
module.exports = ViewRenderAdapter;

},{"../../../resource":165,"../scene/configuration.js":97,"./scene-element.js":86}],88:[function(require,module,exports){
var RenderAdapter = require("./base.js");
var Utils = require("../utils.js");
var Events = require("../../../interface/notification.js");
var dispatchCustomEvent = require("../../../utils/misc.js").dispatchCustomEvent;
var ResourceCounter = require("../../../resource/counter.js");

var XML3DRenderAdapter = function (factory, node) {
    RenderAdapter.call(this, factory, node);
    this.fireLoadEventAfterDraw = false;
    this.firstLoadFired = false;
};
XML3D.createClass(XML3DRenderAdapter, RenderAdapter, {

    activeViewChanged: function () {
        var viewElement = getOrCreateActiveView(this.node);
        var adapter = this.factory.getAdapter(viewElement);
        this.factory.getScene().setActiveView(adapter.getRenderNode());
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        if (name == "view") {
            this.activeViewChanged();
        }
    },

    notifyChanged: function (evt) {
        switch (evt.type) {
            case Events.NODE_INSERTED:
                // This also initializes the children
                this.initElement(evt.mutation.target);
                return;
        }
    },


    /*
     * This function is called when scene DOM is loaded and all adapters are attached
     */
    onConfigured: function () {
        this.activeViewChanged();

        // emit load event when all resources currently loading are completed
        var callback = this.onLoadComplete.bind(this);
        // register callback for canvasId == 0 i.e. global resources
        ResourceCounter.addLoadCompleteListener(0, callback);
        // register callback for canvasId of this node
        ResourceCounter.addLoadCompleteListener(this.factory.canvasId, callback);
        this.onLoadComplete();
    },

    /* Interface methods */

    onLoadComplete: function (canvasId) {
        if (ResourceCounter.isLoadComplete(0) && ResourceCounter.isLoadComplete(this.factory.canvasId)) {
            this.fireLoadEventAfterDraw = true;
        }
    },

    onFrameDrawn: function () {
        if (this.fireLoadEventAfterDraw) {
            this.fireLoadEventAfterDraw = false;
            this.firstLoadFired = true;
            dispatchCustomEvent(this.node, 'load', false, true, null);
        }
    },


    getComplete: function () {
        if (this.fireLoadEventAfterDraw) return false;
        if (!this.firstLoadFired) return false;
        return ResourceCounter.isLoadComplete(0) && ResourceCounter.isLoadComplete(this.factory.canvasId);
    },

    getWorldBoundingBox: function () {
        var bbox = new XML3D.Box();
        Array.prototype.forEach.call(this.node.childNodes, function (c) {
            if (c.getWorldBoundingBox) {
                bbox.extend(c.getWorldBoundingBox());
            }
        });
        return bbox;
    }
})
;
//XML3D element is the root with no transform of its own so by definition it's always in world space
XML3DRenderAdapter.prototype.getLocalBoundingBox = XML3DRenderAdapter.prototype.getWorldBoundingBox;

/**
 *
 * @param {number} x x coordinate in screen space
 * @param {number} y y coordinate in screen space
 * @param {XML3D.Vec3?} hitPoint
 * @param {XML3D.Vec3?} hitNormal
 * @returns {*}
 */
XML3DRenderAdapter.prototype.getElementByPoint = function (x, y, hitPoint, hitNormal) {
    var relativeMousePos = Utils.convertPageCoords(this.node, x, y);

    var relX = relativeMousePos.x;
    var relY = relativeMousePos.y;

    var renderer = this.factory.getRenderer();
    var object = renderer.getRenderObjectFromPickingBuffer(relX, relY);
    if (object) {
        if (hitPoint) {
            var vec = renderer.getWorldSpacePositionByPoint(relX, relY, object);
            XML3D.math.vec3.copy(hitPoint.data, vec);
        }
        if (hitNormal) {
            var vec = renderer.getWorldSpaceNormalByPoint(relX, relY, object);
            XML3D.math.vec3.copy(hitNormal.data, vec);
        }
    } else {
        if (hitPoint) {
            hitPoint.x = NaN;
            hitPoint.y = NaN;
            hitPoint.z = NaN;
        }
        if (hitNormal) {
            hitNormal.x = NaN;
            hitNormal.y = NaN;
            hitNormal.z = NaN;
        }
    }
    return object ? object.node : null;
};

XML3DRenderAdapter.prototype.getRenderInterface = function () {
    return this.factory.getRenderer().getRenderInterface();
};

XML3DRenderAdapter.prototype.generateRay = function (x, y) {
    var relativeMousePos = Utils.convertPageCoords(this.node, x, y);
    return this.factory.getRenderer().generateRay(relativeMousePos.x, relativeMousePos.y);
};

XML3DRenderAdapter.prototype.getElementByRay = (function () {
    var c_viewMat = XML3D.math.mat4.create();
    var c_projMat = XML3D.math.mat4.create();

    return function (xml3dRay, hitPoint, hitNormal) {
        var renderer = this.factory.getRenderer();
        renderer.calculateMatricesForRay(xml3dRay, c_viewMat, c_projMat);
        var hitObject = renderer.getRenderObjectByRay(xml3dRay, c_viewMat, c_projMat);
        if (hitObject !== null && (hitPoint || hitNormal)) {
            if (hitPoint) {
                var vec = renderer.getWorldSpacePositionByRay(xml3dRay, hitObject, c_viewMat, c_projMat);
                XML3D.math.vec3.copy(hitPoint.data, vec);
            }
            if (hitNormal) {
                var vec = renderer.getWorldSpaceNormalByRay(xml3dRay, hitObject, c_viewMat, c_projMat);
                XML3D.math.vec3.copy(hitNormal.data, vec);
            }
        } else {
            if (hitPoint) {
                hitPoint.x = NaN;
                hitPoint.y = NaN;
                hitPoint.z = NaN;
            }
            if (hitNormal) {
                hitNormal.x = NaN;
                hitNormal.y = NaN;
                hitNormal.z = NaN;
            }
        }
        return hitObject !== null ? hitObject.node : null;
    }
})();


/**
 * Returns the active view element corresponding to the given xml3d element.
 *
 * @param {!Object} xml3d
 * @return {Object} the active view element
 */
function getOrCreateActiveView(xml3d) {
    // try to resolve reference
    var view = xml3d.querySelector(xml3d.view) || xml3d.querySelector("view");
    if (!view) {
        // didn't find any: create new one
        XML3D.debug.logWarning("xml3d element has no view defined: creating one.");

        view = xml3d.ownerDocument.createElement("view");
        xml3d.appendChild(view);
        xml3d.removeAttribute("view");
    }
    return view;
};

module.exports = XML3DRenderAdapter;



},{"../../../interface/notification.js":74,"../../../resource/counter.js":162,"../../../utils/misc.js":182,"../utils.js":111,"./base.js":77}],89:[function(require,module,exports){
var XC = require("../../../xflow/interface/constants.js");
var DataNode = require("../../../xflow/interface/graph.js").DataNode;
var InputNode = require("../../../xflow/interface/graph.js").InputNode;
var BufferEntry = require("../../../xflow/interface/data.js").BufferEntry;
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;
var Frustum = require("../tools/frustum.js").Frustum;
var mat4 = require("gl-matrix").mat4;
var assert = require('assert');



var ProjectiveCameraData = {
    "projectionMatrix": {
        type: XC.DATA_TYPE.FLOAT4X4, default: mat4.perspective(mat4.create(), (45 * Math.PI / 180), 1, 0.001, 10000)
    }
};

var PerspectiveCameraData = {
    "fovVertical": {type: XC.DATA_TYPE.FLOAT3, 'default': [(45 * Math.PI / 180)]},
    "fovHorizontal": {type: XC.DATA_TYPE.FLOAT3, 'default': undefined},
    "near": {type: XC.DATA_TYPE.FLOAT3, 'default': undefined},
    "far": {type: XC.DATA_TYPE.FLOAT3, 'default': undefined},
    "aspect": {type: XC.DATA_TYPE.FLOAT, 'default': undefined},
    "worldBoundingBox": {type: XC.DATA_TYPE.FLOAT, 'default': undefined}
};

/**
 * @param {DataNode|null} dataNode
 * @param scene
 * @param owner
 * @param {string} model
 * @param defaults
 * @constructor
 */
var AbstractCameraModel = function (dataNode, scene, owner, model, defaults) {
    assert.equal(typeof owner.viewFrustumChanged, 'function');
    assert.equal(typeof model, 'string');
    assert(defaults);
    assert(scene);

    this.owner = owner;
    this.model = model;
    this.scene = scene;
    this.parameters = Object.keys(defaults);

    if (dataNode) {
        var data = new DataNode();
        data.insertBefore(createXflowData(defaults), null);
        data.insertBefore(dataNode, null);
        this.dataNode = data;
    } else {
        this.dataNode = createXflowData(defaults);
    }
    this.dataNode.insertBefore(this.scene.data.data, null);

    this.cameraParameterRequest = new ComputeRequest(this.dataNode, this.parameters, this.cameraParametersChanged.bind(this));
    this.cameraParametersChanged(this.cameraParameterRequest, null);
};

AbstractCameraModel.prototype = {
    cameraParametersChanged: function (request, changeType) {
        if (changeType) {
            this.owner.viewFrustumChanged(changeType);
        }
    },

    destroy: function() {
        this.cameraParameterRequest.clear();
        this.dataNode.clear();
    }
};


/**
 * @param dataNode
 * @param {Scene} scene
 * @param {RenderView} owner
 * @constructor
 * @extends AbstractCameraModel
 */
var ProjectiveCameraModel = function (dataNode, scene, owner) {
    AbstractCameraModel.call(this, dataNode, scene, owner, "projective", ProjectiveCameraData);
};

XML3D.createClass(ProjectiveCameraModel, AbstractCameraModel, {
    getProjectionMatrix: function (aspect) {
        var result = this.cameraParameterRequest.getResult();
        var projectionMatrix = result.getOutputData("projectionMatrix").getValue();
        return projectionMatrix;
    },

    // TODO(ksons): Compute frustum from projection matrix
    getFrustum: function () {
        return null;
    }
});

/**
 * Perspective Camera Model
 * @param dataNode
 * @param scene
 * @param owner
 * @extends AbstractCameraModel
 * @constructor
 */
var PerspectiveCameraModel = function (dataNode, scene, owner) {
    AbstractCameraModel.call(this, dataNode, scene, owner, "perspective", PerspectiveCameraData);
    this.frustum = new Frustum(0.01, 1000, 0, 0.78, 1);
};

XML3D.createClass(PerspectiveCameraModel, AbstractCameraModel, {

    _updateFrustum: function () {
        var result = this.cameraParameterRequest.getResult();

        var fovv, fovh, near, far;

        var fovhEntry = result.getOutputData("fovHorizontal");
        if (fovhEntry) {
            fovh = fovhEntry.getValue()[0];
        } else {
            fovv = result.getOutputData("fovVertical").getValue()[0];
        }

        var nearEntry = result.getOutputData("near");
        if (nearEntry) {
            near = nearEntry.getValue()[0];
        }

        var farEntry = result.getOutputData("far");
        if (farEntry) {
            far = farEntry.getValue()[0];
        }

        var aspect = result.getOutputData("aspect").getValue()[0];

        if (near == undefined || far == undefined) {
            var boundingBox = new XML3D.Box(result.getOutputData("worldBoundingBox").getValue())
            var nearFar = this.owner.getClippingPlanes(boundingBox);

            near = near == undefined ? nearFar.near : near;
            far = far == undefined ? nearFar.far : far;
        }

        this.frustum.setFrustum(near, far, fovh, fovv, aspect /*, orthographic = false */);
    },

    getProjectionMatrix: function () {
        this._updateFrustum();
        return this.frustum.getProjectionMatrix(mat4.create());
    },

    getFrustum: function () {
        this._updateFrustum();
        return this.frustum;
    }
});

function createXflowData(config) {
    var data = new DataNode();
    for (var name in config) {
        var entry = config[name];
        if (entry['default']) {
            createXflowValue(data, name, entry.type, entry['default']);
        }
    }
    return data;
}

function createXflowValue(dataNode, name, type, value) {
    var buffer = new BufferEntry(type, new XC.TYPED_ARRAY_MAP[type](value));
    var inputNode = new InputNode();
    inputNode.data = buffer;
    inputNode.name = name;
    dataNode.appendChild(inputNode);
}




module.exports = {
    AbstractCameraModel: AbstractCameraModel, PerspectiveCameraModel: PerspectiveCameraModel, ProjectiveCameraModel: ProjectiveCameraModel
};

},{"../../../xflow/interface/constants.js":187,"../../../xflow/interface/data.js":188,"../../../xflow/interface/graph.js":189,"../../../xflow/interface/request.js":190,"../tools/frustum.js":109,"assert":11,"gl-matrix":1}],90:[function(require,module,exports){
var MouseEvents = require("./events/mouse.js");
var TouchEvents = require("./events/touch.js");

var c_globalCanvasId = 0;

/**
 * @param {Element} xml3dElement
 * @constructor
 */
function AbstractCanvasHandler(xml3dElement, canvas) {
    this._xml3dElement = xml3dElement;
    this._canvas = canvas;
    this.id = ++c_globalCanvasId; // global canvas id starts at 1

    this._mouseHandler = new MouseEvents.MouseEventHandler(xml3dElement, this);
    this._registerCanvasListeners(this._mouseHandler, MouseEvents.EVENTS);
    if(this.hasTouchEvents()) {
        this._touchHandler = new TouchEvents.TouchEventHandler(xml3dElement, this);
        this._registerCanvasListeners(this._touchHandler, TouchEvents.EVENTS);
    }
}

/**
 * @returns {boolean}
 */
AbstractCanvasHandler.prototype.hasTouchEvents = function() {
    return 'ontouchstart' in window;
};

AbstractCanvasHandler.prototype.getCanvas = function() {
   return this._canvas;
};

AbstractCanvasHandler.prototype.dispatchEvent = function(event) {
    this._xml3dElement.dispatchEvent(event);
};

AbstractCanvasHandler.prototype._registerCanvasListeners = function (handler, events) {
    var canvas = this._canvas;
    events.forEach(function (name) {
        canvas.addEventListener(name, function (e) {
            handler[name] && handler[name].call(handler, e);
            e.stopPropagation();
        });
    });
};

AbstractCanvasHandler.prototype.dispatchCustomEvent = function(type, detail) {
    detail = detail || null;
    var event = document.createEvent('CustomEvent');
    event.initCustomEvent(type, true, true, detail);
    this._xml3dElement.dispatchEvent(event);
};

AbstractCanvasHandler.prototype.dispatchResizeEvent = function (dimensions) {
    this.dispatchCustomEvent("resize", dimensions);
};

/**
 * Dispatches a FrameDrawnEvent to listeners
 *
 * @param start
 * @param end
 * @param stats
 * @return
 */
AbstractCanvasHandler.prototype.dispatchFrameDrawnEvent = function (start, end, stats) {
    stats = stats || {
        count: {
            primitives: 0, objects: 0
        }
    };
    var data = {
        timeStart: start, timeEnd: end, renderTimeInMilliseconds: end - start, count: stats.count
    };
    this.dispatchCustomEvent("framedrawn", data);
};

module.exports = AbstractCanvasHandler;

},{"./events/mouse.js":92,"./events/touch.js":93}],91:[function(require,module,exports){
var factory = require("./renderer-factory.js");

var configure = function(xml3ds) {
    if (!(xml3ds instanceof Array))
        xml3ds = [xml3ds];

    xml3ds.forEach(function(xml3dElement) {
        if (xml3dElement._configured.canvasHandler.renderer) {
            // This element has already been configured
            return;
        }
        XML3D.debug.logDebug("Configuring Renderer for", xml3dElement.id);
        var renderer = factory.createRenderer(xml3dElement)

    });
};

module.exports = configure;
},{"./renderer-factory.js":96}],92:[function(require,module,exports){
var Options = require("../../../utils/options.js");

var OPTION_MOUSEMOVE_PICKING = "renderer-mousemove-picking";
var OPTION_MOVEMENT_AWARE_CLICK_HANDLER = "renderer-movement-aware-click-handler";
Options.register(OPTION_MOUSEMOVE_PICKING, true);
Options.register(OPTION_MOVEMENT_AWARE_CLICK_HANDLER, false);

var EVENTS = ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mousemove", "mouseout", "wheel"];

/**
 *
 * @param {Element} defaultTarget
 * @param {AbstractCanvasHandler} canvasHandler
 * @constructor
 */
var MouseEventHandler = function(defaultTarget, canvasHandler) {
    this._defaultTarget = defaultTarget;
    this._canvasHandler = canvasHandler;
    this._lastMousePosition =  {x: 0, y: 0};
};

var supportsEventConstructors = (function() {
    try {
        new MouseEvent("click", {});
        return true;
    } catch (e){
        return false;
    }
})();

MouseEventHandler.prototype =  {

    /**
     * @param {MouseEvent} event  The original event
     * @param {Element} target  target to dispatch on
     * @param {object?}     opt    Options
     */
    dispatchMouseEvent: function (event, target, opt) {
        opt = opt || {};
        target = target || this._defaultTarget;
        var x = opt.x !== undefined ? opt.x : event.clientX;
        var y = opt.y !== undefined ? opt.y : event.clientY;
        var noCopy = opt.noCopy || false;
        // Copy event to avoid DOM dispatch errors (cannot dispatch event more
        // than once)
        if (!noCopy) {
            event = this.copyMouseEvent(event);
        }
        this.initExtendedMouseEvent(event, x, y);

        target.dispatchEvent(event);
    },

    /**
     * @param {MouseEvent|WheelEvent} event the event to copy
     * @return {MouseEvent} the new event
     */
    copyMouseEvent: function (event) {
        var evt;
        if (supportsEventConstructors) {
            if (event.toString() === "[object WheelEvent]") {
                evt = new WheelEvent(event.type, event);
            } else {
                evt = new MouseEvent(event.type, event);
            }
        } else {
            //These event APIs are deprecated but still required by IE, which doesn't support event constructors yet
            if (event.toString() === "[object WheelEvent]") {
                evt = document.createEvent("WheelEvent");
                evt.initWheelEvent(event.type, event.bubbles, event.cancelable, event.view, event.detail,
                    event.screenX, event.screenY, event.clientX, event.clientY, event.button, event.relatedTarget, "",
                    event.deltaX, event.deltaY, event.deltaZ, event.deltaMode);
            } else {
                evt = document.createEvent("MouseEvent");
                evt.initMouseEvent(event.type, event.bubbles, event.cancelable, event.view, event.detail,
                    event.screenX, event.screenY, event.clientX, event.clientY, event.ctrlKey, event.altKey,
                    event.shiftKey, event.metaKey, event.button, event.relatedTarget);
            }
        }
        if (event.dataTransfer)
            evt.data = {url: event.dataTransfer.getData("URL"), text: event.dataTransfer.getData("Text")};
        // override preventDefault to actually prevent the default of the original event
        evt.preventDefault = function () {
            event.preventDefault();
        };
        return evt;
    },

    createMouseEvent: function (type, opts) {
        opts = opts || {};
        var dict = {
            bubbles		: opts.bubbles !== undefined ? opts.bubbles : true,
            cancelable 	: opts.cancelable !== undefined ? opts.cancelable : true,
            view 		: opts.view || window,
            detail 		: opts.detail !== undefined ? opts.detail : 0,
            screenX		: opts.screenX !== undefined ? opts.screenX : 0,
            screenY		: opts.screenY !== undefined ? opts.screenY : 0,
            clientX		: opts.clientX !== undefined ? opts.clientX : 0,
            clientY		: opts.clientY !== undefined ? opts.clientY : 0,
            ctrl 		: opts.ctrl !== undefined ? opts.ctrl : false,
            alt 		: opts.alt !== undefined ? opts.alt : false,
            shift 		: opts.shift !== undefined ? opts.shift : false,
            meta 		: opts.meta !== undefined ? opts.meta : false,
            button 		: opts.button !== undefined ? opts.button : 0,
            relatedTarget : opts.relatedTarget
        };
        if (supportsEventConstructors) {
            return new MouseEvent(type, dict);
        } else {
            var evt = document.createEvent("MouseEvent");
            evt.initMouseEvent(type, dict.bubbles, dict.cancelable, dict.view, dict.detail,
                dict.screenX, dict.screenY, dict.clientX, dict.clientY, dict.ctrlKey, dict.altKey,
                dict.shiftKey, dict.metaKey, dict.button, dict.relatedTarget);
            return evt;
        }
    },

    /**
     * Adds position and normal attributes to the given event.
     *
     * @param {Event} event
     * @param {number} x
     * @param {number} y
     * @return {XML3D.Vec3}
     */
    initExtendedMouseEvent: function (event, x, y) {
        var handler = this._canvasHandler;

        (function () {
            var cachedPosition = undefined;
            var cachedNormal = undefined;

            Object.defineProperty(event, "normal", {
                get : function() {
                    if (!cachedNormal) {
                        var norm = (handler.getWorldSpaceNormalByPoint(x, y));
                        cachedNormal = norm || null;
                    }
                    return cachedNormal;
                }
            });

            Object.defineProperty(event, "position", {
                get : function() {
                    if (!cachedPosition) {
                        var pos = handler.getWorldSpacePositionByPoint(x, y);
                        cachedPosition = pos || null;
                    }
                    return cachedPosition;
                }
            });
        })();
    },

    /**
     * @param {MouseEvent} evt
     * @param {object?} opt
     */
    dispatchMouseEventOnPickedObject: function (evt, opt) {
        opt = opt || {};
        var pos = this.getMousePosition(evt);

        var picked = null;
        if (!opt.omitUpdate)
            picked = this._canvasHandler.getPickObjectByPoint(pos.x, pos.y);

        this.dispatchMouseEvent(evt, picked && picked.node, pos);
    },

    getMousePosition: function (evt) {
        return this._canvasHandler.getMousePosition(evt)
    },


    /**
     * @param {MouseEvent} evt
     */
    mouseup: function (evt) {
        this.dispatchMouseEventOnPickedObject(evt);
    },

    /**
     * @param {MouseEvent} evt
     */
    mousedown: function (evt) {
        this._lastMousePosition = this.getMousePosition(evt);
        this.dispatchMouseEventOnPickedObject(evt);
    },


    /**
     * @param {MouseEvent} evt
     */
    click: function (evt) {
        if (Options.getValue("renderer-movement-aware-click-handler") === true) {
            var pos = this.getMousePosition(evt);
            if (Math.abs(pos.x - this._lastMousePosition.x) > 4 || Math.abs(pos.y - this._lastMousePosition.y) > 4)
                return;
        }
        this.dispatchMouseEventOnPickedObject(evt);
    },

    /**
     * @param {MouseEvent} evt
     */
    dblclick: function (evt) {
        this.dispatchMouseEventOnPickedObject(evt);
    },

    /**
     * This method is called each time a mouseMove event is triggered on the
     * canvas.
     *
     * This method also triggers mouseover and mouseout events of objects in the
     * scene.
     *
     * @param {MouseEvent} evt
     */
    mousemove: function (evt) {
        var pos = this.getMousePosition(evt);

        var doMouseMovePick = Options.getValue(OPTION_MOUSEMOVE_PICKING);

        this.dispatchMouseEventOnPickedObject(evt, {omitUpdate: !doMouseMovePick});
        if (!doMouseMovePick)
            return;

        var curObj = this._canvasHandler.getPickedObject();

        // trigger mouseover and mouseout
        if (curObj !== this.lastPickObj) {
            if (this.lastPickObj) {
                // The mouse has left the last object
                this.dispatchMouseEvent(this.createMouseEvent("mouseout", {
                    clientX: pos.x, clientY: pos.y, button: evt.button
                }), this.lastPickObj);
            }
            if (curObj) {
                // The mouse is now over a different object, so call the new
                // object's mouseover method
                this.dispatchMouseEvent(this.createMouseEvent("mouseover", {
                    clientX: pos.x, clientY: pos.y, button: evt.button
                }), curObj);
            }

            this.lastPickObj = curObj;
        }
    },

    /**
     * @param {MouseEvent} evt
     */
    mouseout: function (evt) {
        var pos = this.getMousePosition(evt);
        this.dispatchMouseEvent(evt, this.lastPickObj, pos);
    },

    /**
     * @param {MouseEvent} evt
     */
    mouseover: function (evt) {
        var doMouseMovePick = Options.getValue(OPTION_MOUSEMOVE_PICKING);
        this.dispatchMouseEventOnPickedObject(evt, {omitUpdate: !doMouseMovePick});
    },

    /**
     * @param {WheelEvent} evt
     */
    wheel: function (evt) {
        this.dispatchMouseEventOnPickedObject(evt, { type: "wheel" });
    }


};

module.exports = {
    EVENTS: EVENTS, MouseEventHandler: MouseEventHandler
};

},{"../../../utils/options.js":183}],93:[function(require,module,exports){
/**
 *
 * @param {Element} defaultTarget
 * @param {AbstractCanvasHandler} canvasHandler
 * @constructor
 */
var TouchEventHandler = function (defaultTarget, canvasHandler) {
    this._defaultTarget = defaultTarget;
    this._canvasHandler = canvasHandler;
};


var EVENTS = ["touchstart", "touchmove", "touchend", "touchcancel"];
var ua = /iPhone|iP[oa]d/.test(navigator.userAgent) ? 'iOS' : /Android/.test(navigator.userAgent) ? 'Android' : 'PC';

TouchEventHandler.prototype = {

    copyTouchEvent: function (event, options) {
        var touchEventData = this.copyTouchEventData(event, options);
        return this.createTouchEvent(touchEventData);
    },


    copyTouchEventData: function (event, options) {
        return {
            type: options.type || event.type,
            timeStamp: Date.now(),
            bubbles: event.bubbles,
            cancelable: event.cancelable,
            detail: event.detail,
            screenX: event.screenX,
            screenY: event.screenY,
            pageX: event.pageX,
            pageY: event.pageY,
            clientX: event.clientX,
            clientY: event.clientY,
            ctrlKey: event.ctrlKey,
            altKey: event.altKey,
            shiftKey: event.shiftKey,
            metaKey: event.metaKey,
            scale: event.scale,
            rotation: event.rotation,
            view: event.view,
            touches: event.touches,
            changedTouches: event.changedTouches,
            targetTouches: event.targetTouches
        };
    },

    createTouchEvent: function (data) {
        var touchEvent;

        try {
            touchEvent = document.createEvent('TouchEvent');
        } catch (e) {
            XML3D.debug.logWarning("Create Touch Event failed, creating UI instead");
            touchEvent = document.createEvent('UIEvent');
        }

        if (touchEvent && touchEvent.initTouchEvent) {
            if (touchEvent.initTouchEvent.length == 0 && ua !== "iOS") { //chrome
                touchEvent.initTouchEvent(data.touches, data.targetTouches, data.changedTouches, data.type, data.view, data.screenX, data.screenY, data.clientX, data.clientY);
            } else if (touchEvent.initTouchEvent.length == 12) { //firefox
                touchEvent.initTouchEvent(data.type, data.bubbles, data.cancelable, data.view, data.detail, data.ctrlKey, data.altKey, data.shiftKey, data.metaKey, data.touches, data.targetTouches, data.changedTouches);
            } else { //iOS length = 18
                touchEvent.initTouchEvent(data.type, data.bubbles, data.cancelable, data.view, data.detail, data.screenX, data.screenY, data.pageX, data.pageY, data.ctrlKey, data.altKey, data.shiftKey, data.metaKey, data.touches, data.targetTouches, data.changedTouches, data.scale, data.rotation);
            }
        }
        return touchEvent;
    },

    /**
     * @param {Event} evt
     * @param {object?} opt
     */
    dispatchTouchEventOnPickedObject: function (evt, opt) {
        opt = opt || {};
        var touchEvent = this.copyTouchEvent(evt, opt);
        touchEvent.preventDefault = function () {
            evt.preventDefault();
        };
        this._defaultTarget.dispatchEvent(touchEvent);
    },

    touchstart: function (evt) {
        this.dispatchTouchEventOnPickedObject(evt);
    },

    touchend: function (evt) {
        this.dispatchTouchEventOnPickedObject(evt);
    },

    touchmove: function (evt) {
        this.dispatchTouchEventOnPickedObject(evt);
    },

    touchcancel: function (evt) {
        this.dispatchTouchEventOnPickedObject(evt);
    }

};


module.exports = {
    EVENTS: EVENTS, TouchEventHandler: TouchEventHandler
};

},{}],94:[function(require,module,exports){
function LightManager() {
    this._lights = [];
    this._models = {};

    /**
     * Updating light parameters can lead to updating the (lazy) scene structure, which
     * in turn updates the lights. If we are in updating the lights, flag is set to true.
     * @type {boolean}
     * @private
     */
    this._inUpdate = false;
}

LightManager.prototype = {
    add: function (light) {
        this._lights.push(light);
        this._addModel(light.model);
    },

    remove: function (light) {
        var index = this._lights.indexOf(light);
        if (index != -1) {
            this._lights.splice(index, 1);
        }
        this._removeModel(light.model);
    },

    fillGlobalParameters: function (globals, force) {
        for (var id in this._models) {
            var entry = this._models[id];
            /* Fill globals only if this was not already done before */
            if (entry.changed || force) {
                var prefix = id + "Light";
                for (var param in entry.parameters) {
                    var name = prefix + param.charAt(0).toUpperCase() + param.slice(1);
                    globals[name] = entry.parameters[param];
                }
                entry.changed = false;
            }
        }
    },

    lightValueChanged: function (light) {
        if (this._inUpdate)
            return;
        this._inUpdate = true;

        var lights = light ? [light] : this._lights;
        var that = this;

        lights.forEach(function(light) {
            var model = light.model;
            var entry = that.getModelEntry(model.id);
            var offset = entry.lightModels.indexOf(model);
            if (offset < 0) {
                //These changes are for a light that no longer exists so we can ignore them
                //This can happen for ex. during a delayed change notification that isn't fired until after a remove()
                return;
            }
            model.fillLightParameters(entry.parameters, offset);
            model.getLightData(entry.parameters, offset);
            entry.changed = true;
        });
        this._inUpdate = false;
    },

    getModelEntry: function (id) {
        return this._models[id];
    },

    getModels: function (id) {
        return Object.keys(this._models);
    },

    getModelCount: function (id) {
        var model = this.getModelEntry(id);
        return model ? model.lightModels.length : 0;
    },

    _addModel: function (model) {
        var entry = this._models[model.id];
        if (!entry) {
            entry = this._models[model.id] = {lightModels: [], parameters: {}};
        }
        entry.lightModels.push(model);
        this._lightStructureChanged(entry);
    },

    _removeModel: function (model) {
        var entry = this.getModelEntry(model.id);
        var index = entry.lightModels.indexOf(model);
        if (index != -1) {
            entry.lightModels.splice(index, 1);
        }
        this._lightStructureChanged(entry);
    },

    _lightStructureChanged: function (entry) {
        this._inUpdate = true;
        var length = entry.lightModels.length;
        if (!length) {
            entry.parameters = {};
            return;
        }
        var model = entry.lightModels[0];
        entry.parameters = model.allocateParameterArray(length);
        entry.lightModels.forEach(function (lightModel, offset) {
            lightModel.fillLightParameters(entry.parameters, offset)
            lightModel.getLightData(entry.parameters, offset);
        });
        entry.changed = true;
        this._inUpdate = false;

    }
};

module.exports = LightManager;

},{}],95:[function(require,module,exports){
var Frustum = require("../tools/frustum.js").Frustum;
var XC = require("../../../xflow/interface/constants.js");
var DataNode = require("../../../xflow/interface/graph.js").DataNode;
var InputNode = require("../../../xflow/interface/graph.js").InputNode;
var BufferEntry = require("../../../xflow/interface/data.js").BufferEntry;
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;
var mat4 = require("gl-matrix").mat4;
var vec3 = require("gl-matrix").vec3;
var quat = require("gl-matrix").quat;

var PointLightData = {
    "intensity": {type: XC.DATA_TYPE.FLOAT3, 'default': [1, 1, 1]},
    "attenuation": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, 1]},
    "position": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, 0]},
    "shadowBias": {type: XC.DATA_TYPE.FLOAT, 'default': [0.0001]},
    "direction": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, -1]},
    "castShadow": {type: XC.DATA_TYPE.BOOL, 'default': [false]},
    "on": {type: XC.DATA_TYPE.BOOL, 'default': [true]},
    "matrix": {type: XC.DATA_TYPE.FLOAT4X4, 'default': [1, 0, 0, 0,   0, 1, 0, 0,    0, 0, 1, 0,  0, 0, 0, 1]},
    "nearFar": {type: XC.DATA_TYPE.FLOAT2, 'default': [1.0, 100.0]}
};

var SpotLightData = {
    "intensity": {type: XC.DATA_TYPE.FLOAT3, 'default': [1, 1, 1]},
    "attenuation": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, 1]},
    "position": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, 0]},
    "direction": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, -1]},
    "cutoffAngle": {type: XC.DATA_TYPE.FLOAT, 'default': [Math.PI / 4]},
    "softness": {type: XC.DATA_TYPE.FLOAT, 'default': [0.0]},
    "shadowBias": {type: XC.DATA_TYPE.FLOAT, 'default': [0.0001]},
    "castShadow": {type: XC.DATA_TYPE.BOOL, 'default': [false]},
    "matrix": {type: XC.DATA_TYPE.FLOAT4X4, 'default': [1, 0, 0, 0,   0, 1, 0, 0,    0, 0, 1, 0,  0, 0, 0, 1]},
    "on": {type: XC.DATA_TYPE.BOOL, 'default': [true]}
};

var DirectionalLightData = {
    "intensity": {type: XC.DATA_TYPE.FLOAT3, 'default': [1, 1, 1]},
    "direction": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, -1]},
    "shadowBias": {type: XC.DATA_TYPE.FLOAT, 'default': [0.0001]},
    "position": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, 0]},
    "castShadow": {type: XC.DATA_TYPE.BOOL, 'default': [false]},
    "on": {type: XC.DATA_TYPE.BOOL, 'default': [true]},
    "matrix": {type: XC.DATA_TYPE.FLOAT4X4, 'default': [1, 0, 0, 0,   0, 1, 0, 0,    0, 0, 1, 0,  0, 0, 0, 1]}
};


function createXflowData(config) {
    var data = new DataNode();
    for (var name in config) {
        var entry = config[name];
        createXflowValue(data, name, entry.type, entry['default']);
    }
    return data;
}

function createXflowValue(dataNode, name, type, value) {
    var buffer = new BufferEntry(type, new XC.TYPED_ARRAY_MAP[type](value));
    var inputNode = new InputNode();
    inputNode.data = buffer;
    inputNode.name = name;
    dataNode.appendChild(inputNode);
}

/**
 * Base class for light models
 * @param {string} id Unique id that identifies the light model
 * @param {RenderLight} light
 * @param {DataNode} dataNode
 * @param {Object} config Configuration that contains the light model's parameters and default values
 * @constructor
 */
var LightModel = function (id, light, dataNode, config) {
    this.id = id;
    this.light = light;
    this.configuration = config;
    this.parameters = Object.keys(config);
    /**
     * If the light has not data, just use the default parameters
     */
    if (dataNode) {
        var data = new DataNode();
        data.insertBefore(createXflowData(config), null);
        data.insertBefore(dataNode, null);
        this.dataNode = data;
    } else {
        this.dataNode = createXflowData(config);
    }

    // Horizontal opening angle of the light camera. Derived from cutoffAngle in case of spot light
    this.fovy =  Math.PI/2.0;

    this.lightParameterRequest = new ComputeRequest(this.dataNode, this.parameters, this.lightParametersChanged.bind(this));
    this.lightParametersChanged(this.lightParameterRequest, null);
};

LightModel.prototype = {
    /**
     * Copies the light parameters in an array of the same size
     * @param {Object} target Name to typed array map containing the data
     * @param {number} offset Slot in the array to be filled
     */
    fillLightParameters: function (target, offset) {
        var result = this.lightParameterRequest.getResult();
        this.parameters.forEach(function (name) {
            var entry = result.getOutputData(name);
            var size = XC.DATA_TYPE_TUPLE_SIZE[entry.type];
            var value = entry.getValue();
            target[name].set(value.subarray(0, size), offset * size);
        });
        this.transformParameters(target, offset);
    },

    allocateParameterArray: function (size) {
        var parameterArrays = {};
        var config = this.configuration;
        this.parameters.forEach(function (name) {
            var type = config[name].type;
            var tupleSize = XC.DATA_TYPE_TUPLE_SIZE[type];
            parameterArrays[name] = new XC.TYPED_ARRAY_MAP[type](tupleSize * size);
        });
        return parameterArrays;
    },

    getParameter: function(name) {
        if(name in this.configuration) {
            // No other checks required because parameters are always defined
            return this.lightParameterRequest.getResult().getOutputData(name).getValue();
        }
        return null;
    },

    lightParametersChanged: function (request, changeType) {
        if (changeType) {
            this.light.lightValueChanged();
        }
    },

    _expandNearFar:function(nfobject){
        var expand = Math.max((nfobject.far - nfobject.near) * 0.30, 0.05);
        nfobject.near -= expand;
        nfobject.far  += expand;
    },

    getLightData: function (target, offset) {
        var matrix = target["matrix"].subarray(offset * 16, offset * 16 + 16);
        this.getLightViewProjectionMatrix(matrix);
    },

    getLightViewProjectionMatrix: function (target) {
        var LVM = mat4.create();
        var LPM = mat4.create();
        this.getLightViewMatrix(LVM);
        this.getLightProjectionMatrix(LPM);
        XML3D.math.mat4.multiply(target, LPM, LVM);
    },

    getLightProjectionMatrix: function (target) {
        this.light.getFrustum(1).getProjectionMatrix(target);
    },

    getLightViewMatrix: (function() {
        var tmp = mat4.create();

        return function (mat) {
            var p_dir = this.getParameter("direction");
            var p_pos = this.getParameter("position");

            // Get the world matrix from the light in the transformation hierarchy
            // world => light
            this.light.getWorldMatrix(mat);

            // Derive rotation from the direction and standard direction (-z => no rotation)
            var q_rot = XML3D.math.quat.rotationTo(quat.create(),c_standardDirection, p_dir);
            // Create matrix from rotation and translation
            mat4.fromRotationTranslation(tmp, q_rot, p_pos);
            // Add to world matrix\
            mat4.mul(mat, mat, tmp);

            // Invert:  light => world
            mat4.invert(mat, mat);
        }
    })()

};

var c_tmpWorldMatrix = mat4.create();
var c_standardDirection = vec3.fromValues(0,0,-1);


function transformPose(light, position, direction) {
    light.getWorldMatrix(c_tmpWorldMatrix);
    if (position) {
        vec3.transformMat4(position, position, c_tmpWorldMatrix);
    }
    if (direction) {
        XML3D.math.vec3.transformDirection(direction, direction, c_tmpWorldMatrix);
        vec3.normalize(direction, direction);
    }
}

function transformDefault(target, offset, light) {
    target["on"][offset] = light.visible;
}


/**
 * Implement XML3D's predefined point light model urn:xml3d:light:point
 * @param {DataNode} dataNode
 * @param {RenderLight} light
 * @extends LightModel
 * @constructor
 */
var PointLightModel = function (dataNode, light) {
    LightModel.call(this, "point", light, dataNode, PointLightData);
};

XML3D.createClass(PointLightModel, LightModel, {
    getFrustum: function (aspect, sceneBoundingBox) {
        var orthogonal = false;
        var entry = this.light.scene.lights.getModelEntry(this.id);

        if (sceneBoundingBox.isEmpty()) {
            entry.parameters["nearFar"][0] = 1.0;
            entry.parameters["nearFar"][1] = 110.0;
            return new Frustum(1.0, 110.0, 0, this.fovy, aspect, orthogonal)
        }


        var t_mat = mat4.create();
        this.getLightViewMatrix(t_mat);
        sceneBoundingBox.transformAxisAligned(t_mat);

        var nf = {
            near: -sceneBoundingBox.max.z, far: -sceneBoundingBox.min.z
        };
        // Expand the view frustum a bit to ensure 2D objects parallel to the camera are rendered
        this._expandNearFar(nf);

        if (nf.far < 1.0) {
            nf.far = 110;
        }

        entry.parameters["nearFar"][0] = 1.0;
        entry.parameters["nearFar"][1] = nf.far;

        return new Frustum(1.0, nf.far, 0, this.fovy, aspect, orthogonal);
    },

    transformParameters: function (target, offset) {
        var position = target["position"].subarray(offset * 3, offset * 3 + 3);
        transformPose(this.light, position, null);
        transformDefault(target, offset, this.light);
    }
});




/**
 * Implement XML3D's predefined spot light model urn:xml3d:light:spot
 * @param {DataNode} dataNode
 * @param {RenderLight} light
 * @extends LightModel
 * @constructor
 */
var SpotLightModel = function (dataNode, light) {
    LightModel.call(this, "spot", light, dataNode, SpotLightData);
};


XML3D.createClass(SpotLightModel, LightModel, {
    getFrustum: function (aspect, sceneBoundingBox) {

        if (sceneBoundingBox.isEmpty()) {
            return new Frustum(1.0, 110.0, 0, this.fovy, aspect, false)
        }

        var t_mat = mat4.create();
        this.getLightViewMatrix(t_mat);
        sceneBoundingBox.transformAxisAligned(t_mat);

        var nf = {
            near: -sceneBoundingBox.max.z, far: -sceneBoundingBox.min.z
        };
        // Expand the view frustum a bit to ensure 2D objects parallel to the camera are rendered
        this._expandNearFar(nf);

        if (nf.far < 1.0) {
            nf.far = 110;
        }

        return new Frustum(1.0, nf.far, 0, this.fovy, aspect, false);
    },

    transformParameters: function (target, offset) {
        var position = target["position"].subarray(offset * 3, offset * 3 + 3);
        var direction = target["direction"].subarray(offset * 3, offset * 3 + 3);
        // Transform position and direction from object to world space
        transformPose(this.light, position, direction);
        transformDefault(target, offset, this.light);
    },

    lightParametersChanged: function (request, changeType) {
        this.fovy = this.getParameter("cutoffAngle")[0] * 2;
        LightModel.prototype.lightParametersChanged.call(this, request, changeType);
    }
});




/**
 * Implement XML3D's predefined spot light model urn:xml3d:light:directional
 * @param {DataNode} dataNode
 * @param {RenderLight} light
 * @extends LightModel
 * @constructor
 */
var DirectionalLightModel = function (dataNode, light) {
    LightModel.call(this, "directional", light, dataNode, DirectionalLightData);
};

XML3D.createClass(DirectionalLightModel, LightModel, {
    getFrustum: function(aspect, sceneBoundingBox) {
        var orthogonal = true;

        if (sceneBoundingBox.isEmpty()) {
            return new Frustum(1.0, 110.0, 0, this.fovy, aspect, orthogonal)
        }

        var t_mat = mat4.create();
        this.getLightViewMatrix(t_mat);
        sceneBoundingBox.transformAxisAligned(t_mat);

        var nf = {  near: -sceneBoundingBox.max.z,
                    far:  -sceneBoundingBox.min.z};
        // Expand the view frustum a bit to ensure 2D objects parallel to the camera are rendered
        this._expandNearFar(nf);

        if (nf.far < 1.0) {
            nf.far = 110;
        }

        return new Frustum(1.0, nf.far, 0, this.fovy, aspect, orthogonal);
    },

    transformParameters: function (target, offset) {
        var direction = target["direction"].subarray(offset * 3, offset * 3 + 3);
        transformPose(this.light, null, direction);
        transformDefault(target, offset, this.light);
    },



    getLightViewMatrix: function (mat) {
        var manager = this.light.scene.lights;
        var entry = manager.getModelEntry(this.id);
        var p_dir = entry.parameters["direction"];
        var p_pos = entry.parameters["position"];

        var bb = new XML3D.Box();
        this.light.scene.getBoundingBox(bb);
        var off = vec3.create();
        var bbCenter = bb.center();
        var bbSize = bb.size();
        var d = bbSize.length(); //diameter of bounding sphere of the scene
        vec3.scale(off, p_dir, -0.55 * d); //enlarge a bit on the radius of the scene
        p_pos = vec3.add(p_pos, bbCenter.data, off);
        entry.parameters["position"] = p_pos;


        //create new transformation matrix depending on the updated parameters
        mat4.identity(mat);
        var lookat_mat = mat4.create();
        var top_vec = vec3.fromValues(0.0, 1.0, 0.0);
        if ((p_dir[0] == 0.0) && (p_dir[2] == 0.0)) //check if top_vec colinear with direction
            top_vec = vec3.fromValues(0.0, 0.0, 1.0);
        var up_vec = vec3.create();
        var dir_len = vec3.len(p_dir);
        vec3.scale(up_vec, p_dir, -vec3.dot(top_vec, p_dir) / (dir_len * dir_len));
        vec3.add(up_vec, up_vec, top_vec);
        vec3.normalize(up_vec, up_vec);
        mat4.lookAt(lookat_mat, vec3.fromValues(0.0, 0.0, 0.0), p_dir, up_vec);
        mat4.invert(lookat_mat, lookat_mat);
        mat4.translate(mat, mat, p_pos);
        mat4.multiply(mat, mat, lookat_mat);

        bb = new XML3D.Box();
        this.light.scene.getBoundingBox(bb);
        bb.transformAxisAligned(mat);
        bbSize = bb.size().data;
        var max = (bbSize[0] > bbSize[1]) ? bbSize[0] : bbSize[1];
        max = 0.55 * (max);//enlarge 10percent to make sure nothing gets cut off
        this.fovy = max <= 0 ? Math.PI : Math.atan(max)*2.0;

        entry.parameters["direction"] = p_dir;
        entry.parameters["position"]  = p_pos;

        mat4.invert(mat, mat);
    }

});

module.exports = {
    PointLightModel: PointLightModel, SpotLightModel: SpotLightModel, DirectionalLightModel: DirectionalLightModel

};

},{"../../../xflow/interface/constants.js":187,"../../../xflow/interface/data.js":188,"../../../xflow/interface/graph.js":189,"../../../xflow/interface/request.js":190,"../tools/frustum.js":109,"gl-matrix":1}],96:[function(require,module,exports){
var GLRenderer = require("../webgl/renderer.js");
var GLCanvasHandler = require("../webgl/canvas-handler.js");

var RendererFactory = function () {
    this.createRenderer = function (xml3dElement) {
        var canvas = xml3dElement._configured.canvas;
        var canvasHandler = new GLCanvasHandler(xml3dElement, canvas);
        var renderer = new GLRenderer(xml3dElement, canvasHandler);
        canvasHandler.setRenderer(renderer);
        xml3dElement._configured.canvasHandler = canvasHandler;
        window.requestAnimationFrame(canvasHandler.tick);
        return renderer;
    }
};
module.exports = new RendererFactory();








},{"../webgl/canvas-handler.js":119,"../webgl/renderer.js":152}],97:[function(require,module,exports){
var uniqueObjectId = require("../../webgl/base/utils.js").getUniqueCounter();
/**
 * A configuration connects a model (material, light, camera) with a data node containing
 * the parameters for the model
 * The Configuration is immutable
 *
 * @param model The model (e.g. identified by an URN)
 * @param {Xflow.DataNode} dataNode  The parameters of this model instance
 * @param {{}} opt
 * @constructor
 */
var Configuration = function(model, dataNode, opt) {
    opt = opt || {};

    this.id = uniqueObjectId();

    /**
     * @type {{type: string}}
     */
    this.model = model;

    /**
     * Data Node of the renderObject
     * @type {Xflow.DataNode}
     */
    this.dataNode = dataNode;

    /**
     * A name for debug purposes
     * @type {string|null}
     */
    this.name = opt.name || null;
};

module.exports = Configuration;

},{"../../webgl/base/utils.js":118}],98:[function(require,module,exports){
module.exports = {
    NODE_TYPE: {
        GROUP: "group", OBJECT: "object", LIGHT: "light", VIEW: "view"
    },

    EVENT_TYPE: {
        VIEW_CHANGED: "view_changed",
        LIGHT_STRUCTURE_CHANGED: "light_structure_changed",
        LIGHT_VALUE_CHANGED: "light_value_changed",
        SCENE_SHAPE_CHANGED: "scene_shape_changed",
        SCENE_STRUCTURE_CHANGED: "scene_structure_changed",
        DRAWABLE_STATE_CHANGED: "drawable_state_changed"

    }
};

},{}],99:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;

var DrawableClosure = function (context, type) {
    EventEmitter.call(this);
    this.context = context;
    this._type = type;
    this._valid = false;
    // Do not limit the number of listeners
    this.setMaxListeners(0);
};

DrawableClosure.TYPES = {
    MESH: "mesh", VOLUME: "volume"
};

DrawableClosure.READY_STATE = {
    COMPLETE: "complete", INCOMPLETE: "incomplete"
};

XML3D.createClass(DrawableClosure, EventEmitter, {
    getType: function () {
        return this._type;
    }, isValid: function () {
        return this._valid;
    }, setShaderComposer: function (shaderComposer) {
        // implemented by subclass
    }, update: function (scene) {
        // implemented by subclass
    }
});

module.exports = DrawableClosure;


},{"events":12}],100:[function(require,module,exports){
var DEFAULT_PAGE_SIZE = 1 << 12;

/**
 * @constructor
 */
var Pager = function (opt) {
    opt = opt || {};

    this.pageSize = opt.pageSize || DEFAULT_PAGE_SIZE;

    /** @type Array<Float32Array> */
    this.pages = [];
    /** @type number */
    this.nextOffset = 0;
    /** @type Array<*> */
    this.freeEntries = [];
    // Add a first page
    this.addPage();
};

XML3D.extend(Pager.prototype, {
    addPage: function () {
        var page = new Float32Array(this.pageSize);
        this.pages.push(page);
        this.nextOffset = 0;
        XML3D.debug.logInfo("Adding page", this.pages.length, "(", this.pageSize * Float32Array.BYTES_PER_ELEMENT * this.pages.length / 1024, "kB)");
    },

    getPageEntry: function (size) {
        if (!size)
            throw new Error("No size given for page entry");
        return this.reusePageEntry(size) || this.createPageEntry(size);
    },

    /**
     * @param {number} size Requested size in number of floats
     * @returns {{ page: Float32Array, offset: number, size: number }}
     */
    reusePageEntry: function (size) {
        var sameSizeEntries = this.freeEntries[size];
        if (sameSizeEntries && sameSizeEntries.length) {
            return sameSizeEntries.pop();
        }
        return null;
    },

    /**
     * @param {number} size  Size in number of floats
     * @returns {{ page: Float32Array, offset: number, size: number }}
     */
    createPageEntry: function (size) {
        if (this.nextOffset + size > this.pageSize) {
            this.addPage();
            return this.getPageEntry(size);
        }
        var page = this.pages[this.pages.length - 1];
        var localOffset = this.nextOffset;
        this.nextOffset += size;
        return {page: page, offset: localOffset, size: size};
    },

    /**
     *
     * @param {{ page: Float32Array, offset: number, size: number }} entryInfo
     */
    freePageEntry: function (entryInfo) {
        var sameSizeEntries = this.freeEntries[entryInfo.size];
        if (!sameSizeEntries) {
            sameSizeEntries = this.freeEntries[entryInfo.size] = [];
        }
        sameSizeEntries.push(entryInfo);
    }
});

module.exports = Pager;


},{}],101:[function(require,module,exports){
var RenderNode = require("./rendernode.js");
var Constants = require("./constants.js");
var Frustum = require("../tools/frustum.js").Frustum;
var vec3 = require("gl-matrix").vec3;
var mat4 = require("gl-matrix").mat4;

var NODE_TYPE = Constants.NODE_TYPE;
var EVENT_TYPE = Constants.EVENT_TYPE;

/** @const */
var WORLD_MATRIX_OFFSET = 0;
/** @const */
var LOCAL_MATRIX_OFFSET = WORLD_MATRIX_OFFSET + 16;
/** @const */
var WORLD_BB_OFFSET = LOCAL_MATRIX_OFFSET + 16;
/** @const */
var ENTRY_SIZE = WORLD_BB_OFFSET + 6;


   /** @const */
    var CLIPPLANE_NEAR_MIN = 0.01;

    /** @const */
    var DEFAULT_FIELDOFVIEW = 45 / 180 * Math.PI;
/**
 *
 * @constructor
 * @extends {RenderNode}
 */
var RenderGroup = function (scene, pageEntry, opt) {
    RenderNode.call(this, NODE_TYPE.GROUP, scene, pageEntry, opt);
    opt = opt || {};

    /**
     * The material attached to this group
     * @type {MaterialConfiguration|null}
     */
    this._material = opt.material || null;
    this.boundingBoxDirty = false;
    this.setWorldSpaceBoundingBox(XML3D.Box.EMPTY_BOX);
};
RenderGroup.ENTRY_SIZE = ENTRY_SIZE;

XML3D.createClass(RenderGroup, RenderNode);

XML3D.extend(RenderGroup.prototype, {
    getLocalMatrix: function (dest) {
        var o = this.offset + LOCAL_MATRIX_OFFSET;
        for (var i = 0; i < 16; i++, o++) {
            dest[i] = this.page[o];
        }
    },

    setLocalMatrix: function (source) {
        var o = this.offset + LOCAL_MATRIX_OFFSET;
        for (var i = 0; i < 16; i++, o++) {
            this.page[o] = source[i];
        }
        this.setTransformDirty();
        this.setBoundingBoxDirty();
    },

    getWorldSpaceBoundingBox: function (bbox) {
        if (this.boundingBoxDirty) {
            this.updateWorldSpaceBoundingBox();
        }
        var o = this.offset + WORLD_BB_OFFSET;
        bbox.data[0] = this.page[o];
        bbox.data[1] = this.page[o + 1];
        bbox.data[2] = this.page[o + 2];
        bbox.data[3] = this.page[o + 3];
        bbox.data[4] = this.page[o + 4];
        bbox.data[5] = this.page[o + 5];
    },

    setWorldSpaceBoundingBox: function (bbox) {
        var o = this.offset + WORLD_BB_OFFSET;
        this.page[o] = bbox.data[0];
        this.page[o + 1] = bbox.data[1];
        this.page[o + 2] = bbox.data[2];
        this.page[o + 3] = bbox.data[3];
        this.page[o + 4] = bbox.data[4];
        this.page[o + 5] = bbox.data[5];
    },


    updateWorldSpaceBoundingBox: (function () {
        var childBB = new XML3D.Box();

        return function () {
            var localBB = new XML3D.Box();

            for (var i = 0, j = this.children.length; i < j; i++) {
                var obj = this.children[i];
                obj.getWorldSpaceBoundingBox(childBB);
                localBB.extend(childBB);
            }
            this.setWorldSpaceBoundingBox(localBB);
            this.boundingBoxDirty = false;
        }
    })(),

    addChild: function (child) {
        this.children.push(child);
        this.setBoundingBoxDirty();
        this.scene.emit(EVENT_TYPE.SCENE_STRUCTURE_CHANGED, child, false);
    },

    removeChild: function (child) {
        var index = this.children.indexOf(child);
        if (index != -1) {
            this.children.splice(index, 1);
        }
        this.scene.emit(EVENT_TYPE.SCENE_STRUCTURE_CHANGED, child, true);
    },

    getChildren: function () {
        return this.children;
    },

    updateWorldMatrix: function (sourceMat4) {
        var page = this.page;
        var offset = this.offset;
        XML3D.math.mat4.multiplyOffset(page, offset + WORLD_MATRIX_OFFSET, page, offset + LOCAL_MATRIX_OFFSET, sourceMat4, 0);
        this.transformDirty = false;
    },

    setTransformDirty: function () {
        if (this.transformDirty) {
            //We can be sure all child nodes are already set to transformDirty from here
            return;
        }
        this.transformDirty = true;
        var children = this.children;
        for(var i = 0, l = children.length; i < l; i++) {
            children[i].setTransformDirty();
        }
    },

    /**
     * @param {MaterialConfiguration|null} material
     */
    setMaterial: function (material) {
        if(this._material === material)
            return;
        this._material = material;
        this.children.forEach(function (obj) {
            obj.parentMaterialChanged && obj.parentMaterialChanged();
        });
    },

    parentMaterialChanged: function () {
        if (this._material) {
            // Local material overrides anything coming from upstream
            return;
        }
        this.children.forEach(function (obj) {
            obj.parentMaterialChanged && obj.parentMaterialChanged();
        });
    },

    /**
     * @returns {MaterialConfiguration}
     */
    getMaterial: function () {
        return this._material || this.parent.getMaterial();
    },

    /**
     * A group propagates its visibility
     */
    visibilityChanged: function () {
        var children = this.children;
        for (var i = 0, l = children.length; i < l; i++) {
            children[i].evaluateVisibility();
        }
    },



    setBoundingBoxDirty: function () {
        this.boundingBoxDirty = true;
        if (this.parent) {
            this.parent.setBoundingBoxDirty();
        }
    },

    findRayIntersections: (function () {
        var bbox = new XML3D.Box();

        return function (ray, intersections) {
            this.getWorldSpaceBoundingBox(bbox);
            if (ray.intersects(bbox)) {
                for (var i = 0; i < this.children.length; i++) {
                    this.children[i].findRayIntersections(ray, intersections);
                }
            }
        }
    })()

});

// Export
module.exports = RenderGroup;


},{"../tools/frustum.js":109,"./constants.js":98,"./rendernode.js":103,"gl-matrix":1}],102:[function(require,module,exports){
var RenderNode = require("./rendernode.js");
var Constants = require("./constants.js");
var LightModels = require("../lights/light-models.js");

var NODE_TYPE = Constants.NODE_TYPE;
var EVENT_TYPE = Constants.EVENT_TYPE;

var tmp_worldMatrix = XML3D.math.mat4.create();

var SHADOWMAP_OFFSET_MATRIX = new Float32Array([0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0]);

/** @const */
var CLIPPLANE_NEAR_MIN = 1.0;

/** @const */
var ENTRY_SIZE = 16;

var c_BoundingBox = new XML3D.Box();


function createLightModel(type, data, light) {
    switch (type) {
        case "urn:xml3d:light:point":
            return new LightModels.PointLightModel(data, light);
        case "urn:xml3d:light:spot":
            return new LightModels.SpotLightModel(data, light);
        case "urn:xml3d:light:directional":
            return new LightModels.DirectionalLightModel(data, light);
        default:
            XML3D.debug.logWarning("Unknown light model: ", type, ". Using directional instead.");
            return new LightModels.DirectionalLightModel(data, light);
    }
}

/**
 * @constructor
 * @param {Scene} scene
 * @param {Object} pageEntry
 * @param {Object} opt
 * @extends {RenderNode}
 */
var RenderLight = function (scene, pageEntry, opt) {
    RenderNode.call(this, NODE_TYPE.LIGHT, scene, pageEntry, opt);
    opt = opt || {};
    var configuration = opt.configuration || {};
    this.setLightType(configuration.model, configuration.dataNode);
};
RenderLight.ENTRY_SIZE = ENTRY_SIZE;

XML3D.createClass(RenderLight, RenderNode);
XML3D.extend(RenderLight.prototype, {

    setLightType: function (modelId, data) {
        if (this.model) {
            if (this.model.id == modelId) {
                return; // Nothing changed
            }
            this.scene.lights.remove(this);
            this.lightStructureChanged(true);
        }
        this.model = createLightModel(modelId, data, this);
        this.scene.lights.add(this);
        this.lightStructureChanged(false);
    },

    setLocalMatrix: function (source) {
        XML3D.debug.logError("RenderLight::setLocalMatrix not implemented");
    },


    getFrustum: function (aspect) {
        this.scene.getBoundingBox(c_BoundingBox);
        return this.model.getFrustum(aspect, c_BoundingBox);
    },

    lightValueChanged: function () {
        if (this.model) { // FIXME: Complex dependency
            this.scene.emit(EVENT_TYPE.LIGHT_VALUE_CHANGED, this);
        }
    },

    lightStructureChanged: function (removed) {
        this.scene.emit(EVENT_TYPE.LIGHT_STRUCTURE_CHANGED, this, removed);
    },

    updateWorldMatrix: function () {
        if (this.parent) {
            this.parent.getWorldMatrix(tmp_worldMatrix);
            this.setWorldMatrix(tmp_worldMatrix);
            // We change position / direction of the light
            this.lightValueChanged();
        }
    },

    visibilityChanged: function (newVal) {
        // Visibility is a light parameter
        this.lightValueChanged();
    },

    setTransformDirty: function () {
        this.updateWorldMatrix();
    },


    remove: function () {
        this.parent.removeChild(this);
        this.scene.lights.remove(this);
        this.lightStructureChanged(true);
    },


    getWorldSpaceBoundingBox: function (bbox) {
        bbox.setEmpty();
    }
});

module.exports = RenderLight;



},{"../lights/light-models.js":95,"./constants.js":98,"./rendernode.js":103}],103:[function(require,module,exports){
/** @const */
var WORLD_MATRIX_OFFSET = 0;

/**
 * @constructor
 * @param type
 * @param {Scene} scene
 * @param {Object} pageEntry
 * @param {Object} opt
 */
var RenderNode = function (type, scene, pageEntry, opt) {
    opt = opt || {};

    this.scene = scene;
    this.type = type;
    this.name = opt.name || "";
    this.page = pageEntry.page;
    this.offset = pageEntry.offset;
    this.entrySize = pageEntry.size;
    this.transformDirty = true;
    this.children = [];
    this.parent = null;

    this.setParent(opt.parent || scene.rootNode);

    this.localVisible = opt.visible !== undefined ? opt.visible : true;
    // The global visibility depends on visibility of parents
    this.visible = true;
    this.evaluateVisibility();
};

XML3D.extend(RenderNode.prototype, {

    getChildren: function () {
        return this.children;
    },

    evaluateVisibility: function() {
        var oldVisible = this.visible;
        if(this.parent && !this.parent.visible) {
            this.visible = false;
        } else {
            this.visible = this.localVisible;
        }
        if(oldVisible !== this.visible) {
            this.visibilityChanged();
            this.scene.requestRedraw && this.scene.requestRedraw("Visibility changed.");
        }
    },

    setLocalVisible: function(newVisible) {
        if (this.localVisible === newVisible) {
            return;
        }
        this.localVisible = newVisible;
        this.evaluateVisibility();
    },

    // Needs to be overwritten
    visibilityChanged: function() {},

    getParent: function () {
        return this.parent;
    },

    setParent: function (parent) {
        this.parent = parent;
        if (parent && parent.addChild) {
            parent.addChild(this);
        }
        // Reevaluate visibility, which might change due to
        // invisibility of parent
        this.evaluateVisibility();
    },

    traverse: function (callback) {
        callback(this);
        this.children.forEach(function (child) {
            child.traverse(callback);
        })
    },

    /**
     * @param {Mat4} source
     * @param {number} offset
     */
    setMat4InPage: function(source, offset) {
        var o = this.offset + offset;
        for(var i = 0; i < 16; i++, o++) {
            this.page[o] = source[i];
        }
    },

    /**
     * @param {Mat4} dest
     * @param {number} offset
     */
    getMat4FromPage: function(dest, offset) {
        var o = this.offset + offset;
        for(var i = 0; i < 16; i++, o++) {
            dest[i] = this.page[o];
        }
    },

    getWorldMatrix: function (dest) {
        if (this.transformDirty) {
            this.parent.getWorldMatrix(dest);
            this.updateWorldMatrix(dest);
        }
        this.getMat4FromPage(dest, WORLD_MATRIX_OFFSET);
    },

    setWorldMatrix: function (source) {
        this.setMat4InPage(source, WORLD_MATRIX_OFFSET);
        this.transformDirty = false;
        if (this.setBoundingBoxDirty) {
            this.setBoundingBoxDirty();
        }
    },

    setTransformDirty: function () {
        this.transformDirty = true;
    },

    remove: function () {
        this.parent.removeChild(this);
        this.scene.pager.freePageEntry({page: this.page, offset: this.offset, size: this.entrySize});
    },

    findRayIntersections: function (/* ray, closestIntersection*/) {
        //This function is overridden by groups and drawables
    }

});

module.exports = RenderNode;

},{}],104:[function(require,module,exports){
var SystemNotifier = require("../../webgl/system/system-notifier.js");
var RenderNode = require("./rendernode.js");
var DrawableClosure= require("./drawableclosure.js");
var C = require("./constants.js");
var Scene= require("./scene.js");
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;
var mat4 = require("gl-matrix").mat4;

// Entry:
/** @const */
var WORLD_MATRIX_OFFSET = 0;
/** @const */
var LOCAL_MATRIX_OFFSET = WORLD_MATRIX_OFFSET + 16;
/** @const */
var OBJECT_BB_OFFSET = LOCAL_MATRIX_OFFSET + 16;
/** @const */
var WORLD_BB_OFFSET = OBJECT_BB_OFFSET + 6;
/** @const */
var MODELVIEW_MATRIX_OFFSET = WORLD_BB_OFFSET + 6;
/** @const */
var MODELVIEWPROJECTION_MATRIX_OFFSET = MODELVIEW_MATRIX_OFFSET + 16;
/** @const */
var MODEL_MATRIX_N_OFFSET = MODELVIEWPROJECTION_MATRIX_OFFSET + 16;
/** @const */
var MODELVIEW_MATRIX_N_OFFSET = MODEL_MATRIX_N_OFFSET + 16;
/** @const */
var ENTRY_SIZE = MODELVIEW_MATRIX_N_OFFSET + 16;

//noinspection JSClosureCompilerSyntax,JSClosureCompilerSyntax
/**
 * Represents a renderable object in the scene.
 * The RenderObject has these responsibilities:
 *  1. Keep track of the transformation hierarchy and bounding boxes
 *  2. Connect the DrawableClosure with the ShaderClosure
 *
 *  The {@link DrawableClosure} is a DrawableObject plus it's data
 *  The {@link ShaderClosure} is a ProgramObject plus it's data
 *  The concrete ShaderClosure can vary per DrawableObject and change
 *  due to scene or object changes. Thus we have to keep track of the
 *  related {@link IShaderComposer}.
 *
 * @constructor
 * @implements {IRenderObject}
 * @param {Scene} scene
 * @param {Object} pageEntry
 * @param {Object} opt
 */
var RenderObject = function (scene, pageEntry, opt) {
    RenderNode.call(this, C.NODE_TYPE.OBJECT, scene, pageEntry, opt);
    opt = opt || {};

    /**
     * Keep reference to DOM Element need e.g. for picking
     * @type {Element}
     */
    this.node = opt.node;

    /**
     * Object related data
     * @type {{data: DataNode|null, type: string}}
     */
    this.configuration = opt.configuration || {data: null, type: "triangles"};

    /**
     * Can we rely on current WorldMatrix?
     * @type {boolean}
     */
    this.transformDirty = true;

    /**
     * Can we rely on current Bounding Boxes?
     * @type {boolean}
     */
    this.boundingBoxDirty = true;

    /**
     * The drawable closure transforms object data and type into
     * a drawable entity
     * @type {DrawableClosure}
     */
    this.drawable = this.createDrawable();

    this._material = opt.material || null;
    this._zIndex = opt.zIndex || "0";
    this._actualMaterial = null;
    this.pickId = -1;
    this.initMaterial();

    /** {Object?} **/
    this.override = null;
};
RenderObject.ENTRY_SIZE = ENTRY_SIZE;

RenderObject.IDENTITY_MATRIX = mat4.create();

XML3D.createClass(RenderObject, RenderNode, {
    createDrawable: function () {
        var result = this.scene.createDrawable(this);
        if (result) {
            var that = this;
            result.on(C.EVENT_TYPE.DRAWABLE_STATE_CHANGED, function (newState, oldState) {
                if (newState === DrawableClosure.READY_STATE.COMPLETE) {
                    that.scene.moveFromQueueToReady(that);
                } else if (newState === DrawableClosure.READY_STATE.INCOMPLETE && oldState === DrawableClosure.READY_STATE.COMPLETE) {
                    that.scene.moveFromReadyToQueue(that);
                }
            });
            result.updateTypeRequest();
            result.calculateBoundingBox();
            result.on(C.EVENT_TYPE.SCENE_SHAPE_CHANGED, function (evt) {
                that.scene.emit(C.EVENT_TYPE.SCENE_SHAPE_CHANGED)
            })
        }
        return result;
    },

    getLocalMatrix: function (dest) {
        this.getMat4FromPage(dest, LOCAL_MATRIX_OFFSET);
    },

    setLocalMatrix: function (source) {
        this.setMat4InPage(source, LOCAL_MATRIX_OFFSET);
        this.setTransformDirty();
        this.setBoundingBoxDirty();
    },

    dispose: function () {
        this.scene.remove(this);
    },

    onTransformDataChange: function () {
        this.setTransformDirty();
    },

    getModelViewMatrix: function (dest) {
        this.getMat4FromPage(dest, MODELVIEW_MATRIX_OFFSET);
    },

    getModelMatrixN: function (dest) {
        var o = this.offset + MODEL_MATRIX_N_OFFSET;
        dest[0] = this.page[o];
        dest[1] = this.page[o + 1];
        dest[2] = this.page[o + 2];
        dest[3] = this.page[o + 4];
        dest[4] = this.page[o + 5];
        dest[5] = this.page[o + 6];
        dest[6] = this.page[o + 8];
        dest[7] = this.page[o + 9];
        dest[8] = this.page[o + 10];
    },

    getModelViewMatrixN: function (dest) {
        var o = this.offset + MODELVIEW_MATRIX_N_OFFSET;
        dest[0] = this.page[o];
        dest[1] = this.page[o + 1];
        dest[2] = this.page[o + 2];
        dest[3] = this.page[o + 4];
        dest[4] = this.page[o + 5];
        dest[5] = this.page[o + 6];
        dest[6] = this.page[o + 8];
        dest[7] = this.page[o + 9];
        dest[8] = this.page[o + 10];
    },


    getModelViewProjectionMatrix: function (dest) {
        this.getMat4FromPage(dest, MODELVIEWPROJECTION_MATRIX_OFFSET);
    },

    updateWorldSpaceMatrices: function (view, projection) {
        if (this.transformDirty) {
            this.updateWorldMatrix();
        }
        this.updateModelViewMatrix(view);
        this.updateModelMatrixN();
        this.updateModelViewMatrixN();
        this.updateModelViewProjectionMatrix(projection);
    },

    updateWorldMatrix: (function () {
        var tmp_mat = mat4.create();
        return function () {
            this.parent.getWorldMatrix(tmp_mat);
            var page = this.page;
            var offset = this.offset;
            XML3D.math.mat4.multiplyOffset(tmp_mat, 0, page, offset + LOCAL_MATRIX_OFFSET, tmp_mat, 0);
            this.setWorldMatrix(tmp_mat);
            this.boundingBoxDirty = true;
            this.transformDirty = false;
        }
    })(),

    /** Relies on an up-to-date transform matrix **/
    updateModelViewMatrix: function (view) {
        if (this.transformDirty) {
            this.updateWorldMatrix();
        }
        var page = this.page;
        var offset = this.offset;
        XML3D.math.mat4.multiplyOffset(page, offset + MODELVIEW_MATRIX_OFFSET, page, offset + WORLD_MATRIX_OFFSET, view, 0);
    },

    updateModelMatrixN: (function () {
        var c_tmpMatrix = mat4.create();
        return function () {
            this.getWorldMatrix(c_tmpMatrix);
            mat4.invert(c_tmpMatrix, c_tmpMatrix);
            var normalMatrix = c_tmpMatrix ? mat4.transpose(c_tmpMatrix, c_tmpMatrix) : RenderObject.IDENTITY_MATRIX;
            this.setMat4InPage(normalMatrix, MODEL_MATRIX_N_OFFSET);
        }
    })(),

    /** Relies on an up-to-date view matrix **/
    updateModelViewMatrixN: (function () {
        var c_tmpMatrix = mat4.create();
        return function () {
            this.getModelViewMatrix(c_tmpMatrix);
            mat4.invert(c_tmpMatrix, c_tmpMatrix);
            var normalMatrix = c_tmpMatrix ? mat4.transpose(c_tmpMatrix, c_tmpMatrix) : RenderObject.IDENTITY_MATRIX;
            this.setMat4InPage(normalMatrix, MODELVIEW_MATRIX_N_OFFSET);
        }
    })(),


    /** Relies on an up-to-date view matrix **/
    updateModelViewProjectionMatrix: function (projection) {
        var page = this.page;
        var offset = this.offset;
        XML3D.math.mat4.multiplyOffset(page, offset + MODELVIEWPROJECTION_MATRIX_OFFSET, page, offset + MODELVIEW_MATRIX_OFFSET, projection, 0);
    },

    setTransformDirty: function () {
        this.transformDirty = true;
        this.setBoundingBoxDirty();
        this.scene.emit(C.EVENT_TYPE.SCENE_SHAPE_CHANGED);
        this.scene.requestRedraw("Transformation changed");
    },

    setObjectSpaceBoundingBox: function (box) {
        var o = this.offset + OBJECT_BB_OFFSET;
        this.page[o] = box.data[0];
        this.page[o + 1] = box.data[1];
        this.page[o + 2] = box.data[2];
        this.page[o + 3] = box.data[3];
        this.page[o + 4] = box.data[4];
        this.page[o + 5] = box.data[5];
        this.setBoundingBoxDirty();
    },

    getObjectSpaceBoundingBox: function (box) {
        var o = this.offset + OBJECT_BB_OFFSET;
        box.data[0] = this.page[o];
        box.data[1] = this.page[o + 1];
        box.data[2] = this.page[o + 2];
        box.data[3] = this.page[o + 3];
        box.data[4] = this.page[o + 4];
        box.data[5] = this.page[o + 5];
    },

    setBoundingBoxDirty: function () {
        this.boundingBoxDirty = true;
        this.parent.setBoundingBoxDirty();
    },

    setWorldSpaceBoundingBox: function (bbox) {
        var o = this.offset + WORLD_BB_OFFSET;
        this.page[o] = bbox.data[0];
        this.page[o + 1] = bbox.data[1];
        this.page[o + 2] = bbox.data[2];
        this.page[o + 3] = bbox.data[3];
        this.page[o + 4] = bbox.data[4];
        this.page[o + 5] = bbox.data[5];
    },

    getWorldSpaceBoundingBox: function (bbox) {
        if (this.boundingBoxDirty) {
            this.updateWorldSpaceBoundingBox();
        }
        var o = this.offset + WORLD_BB_OFFSET;
        bbox.data[0] = this.page[o];
        bbox.data[1] = this.page[o + 1];
        bbox.data[2] = this.page[o + 2];
        bbox.data[3] = this.page[o + 3];
        bbox.data[4] = this.page[o + 4];
        bbox.data[5] = this.page[o + 5];

    },

    updateWorldSpaceBoundingBox: (function () {
        var c_box = new XML3D.Box();
        var c_trans = mat4.create();

        return function () {
            if(!this.visible) {
                c_box.setEmpty();
            } else {
                this.getObjectSpaceBoundingBox(c_box);
                this.getWorldMatrix(c_trans);
                c_box.transformAxisAligned(c_trans);
            }
            this.setWorldSpaceBoundingBox(c_box);
            this.boundingBoxDirty = false;
        }
    })(),

    visibilityChanged: function () {
        this.setBoundingBoxDirty();
    },

    getProgram: function () {
        return this.drawable.getProgram();
    },

    hasTransparency: function () {
        var program = this.getProgram();
        return program ? program.hasTransparency() : false;
    },

    updateForRendering: function () {
        SystemNotifier.setNode(this.node);
        try {
            this.drawable && this.drawable.update(this.scene);
        } catch (e) {
            XML3D.debug.logError("Mesh Error: " + e.message, this.node);
        }
        SystemNotifier.setNode(null);
    },

    findRayIntersections: (function () {
        var bbox = new XML3D.Box();
        var opt = {dist: 0};

        return function (ray, intersections) {
            this.getWorldSpaceBoundingBox(bbox);
            if (ray.intersects(bbox, opt)) {
                intersections.push(this);
            }
        }
    })(),

        /**
     * @param {MaterialConfiguration|null} material
     */
    setMaterial: function (material) {
        if(this._material === material) {
            return;
        }
        this._material = material;
        if (material) {
            this._actualMaterial = material;
        } else {
            this._actualMaterial = this.parent.getMaterial();
        }
        this.materialChanged();
    },

    setZIndex: function(zIndex){
        this._zIndex = zIndex;
    },

    parentMaterialChanged: function () {
        if (this._material) {
            // Local material overrides the change from above
            return;
        }
        this.initMaterial();
    },

    initMaterial: function () {
        if (this._material) {
            this._actualMaterial = this._material;
        } else {
            this._actualMaterial = this.parent.getMaterial();
        }
        this.materialChanged();
    },

    materialChanged: function() {
        XML3D.debug.logDebug("material changed", this._actualMaterial);
        if (this.drawable) {
            var composer = this.scene.shaderFactory.createComposerFromMaterialConfiguration(this._actualMaterial);
            this.drawable.setShaderComposer(composer);
        }
    },

    remove: function() {
        this.parent.removeChild(this);
        this.scene.pager.freePageEntry({page: this.page, offset: this.offset, size: this.entrySize});
        if (this.drawable) {
            this.drawable.destroy();
        }
    }

});


// Export
module.exports = RenderObject;


},{"../../../xflow/interface/request.js":190,"../../webgl/system/system-notifier.js":158,"./constants.js":98,"./drawableclosure.js":99,"./rendernode.js":103,"./scene.js":107,"gl-matrix":1}],105:[function(require,module,exports){
var RenderNode = require("./rendernode.js");
var CameraModels = require("../cameras/camera-models.js");
var Constants = require("./constants.js");
var Frustum = require("../tools/frustum.js").Frustum;
var vec3 = require("gl-matrix").vec3;
var mat4 = require("gl-matrix").mat4;

/** @const */
var CLIPPLANE_NEAR_MIN = 0.01;

var NODE_TYPE = Constants.NODE_TYPE;
var EVENT_TYPE = Constants.EVENT_TYPE;

/** @const */
var VIEW_TO_WORLD_MATRIX_OFFSET = 0;
/** @const */
var WORLD_TO_VIEW_MATRIX_OFFSET = 16;
/** @const */
var PROJECTION_MATRIX_OFFSET = 32;
/** @const */
var ENTRY_SIZE = PROJECTION_MATRIX_OFFSET + 16;

var DEFAULT_CAMERA_CONFIGURATION = { model: "urn:xml3d:view:perspective", dataNode: null };

/**
 *
 * @constructor
 * @extends {RenderNode}
 */
var RenderView = function (scene, pageEntry, opt) {
    RenderNode.call(this, NODE_TYPE.VIEW, scene, pageEntry, opt);
    opt = opt || {};

    this.lastAspectRatio = 1;
    this.projectionDirty = true;

    this.camera = createCamera(opt.camera ? opt.camera : DEFAULT_CAMERA_CONFIGURATION, scene, this);
    this.localMatrix = mat4.create();
    this.worldSpacePosition = vec3.create();
    this.viewDirty = true;
    this.frustum = null;
};
RenderView.ENTRY_SIZE = ENTRY_SIZE;

XML3D.createClass(RenderView, RenderNode);

XML3D.extend(RenderView.prototype, {

    setLocalMatrix: function (source) {
        this.localMatrix = source;
        this.setTransformDirty();
    },

    getFrustum: function () {
        return this.frustum;
    },

    updateViewMatrix: (function () {
        var tmp_mat4 = mat4.create();
        var tmp_parent = mat4.create();

        return function () {
            mat4.copy(tmp_mat4, this.localMatrix);
            this.parent.getWorldMatrix(tmp_parent);
            mat4.multiply(tmp_mat4, tmp_parent, tmp_mat4);
            vec3.set(this.worldSpacePosition, tmp_mat4[12], tmp_mat4[13], tmp_mat4[14]);
            this.setViewToWorldMatrix(tmp_mat4);
            mat4.invert(tmp_mat4, tmp_mat4);
            this.setWorldToViewMatrix(tmp_mat4);
            this.viewDirty = false;
            // View frustum might have changed due to clipping planes
            this.viewFrustumChanged();
        }
    })(),

    setWorldToViewMatrix: function (source) {
        this.setMat4InPage(source, WORLD_TO_VIEW_MATRIX_OFFSET);
    },

    setViewToWorldMatrix: function (source) {
        this.setMat4InPage(source, VIEW_TO_WORLD_MATRIX_OFFSET);
    },

    setProjectionMatrix: function (source) {
        this.setMat4InPage(source, PROJECTION_MATRIX_OFFSET);
        this.projectionDirty = false;
    },

    setTransformDirty: function () {
        this.viewDirty = true;
        this.scene.requestRedraw("view pose changed");
    },

    getViewToWorldMatrix: function (dest) {
        if (this.viewDirty) {
            this.updateViewMatrix();
        }
        this.getMat4FromPage(dest, VIEW_TO_WORLD_MATRIX_OFFSET);
    },

    getWorldToViewMatrix: function (dest) {
        if (this.viewDirty) {
            this.updateViewMatrix();
        }
        this.getMat4FromPage(dest, WORLD_TO_VIEW_MATRIX_OFFSET);
    },

    getProjectionMatrix: function (dest, aspect) {
        if (this.projectionDirty || Math.abs(aspect - this.lastAspectRatio) > 0.001 ) {
            // Set projectionMatrix
            this.frustum = this.camera.getFrustum(aspect);
            if(this.frustum) {
                this.setProjectionMatrix(this.frustum.getProjectionMatrix(mat4.create()));
            } else {
                this.setProjectionMatrix(this.camera.getProjectionMatrix())
            }
            this.lastAspectRatio = aspect;
        }
        this.getMat4FromPage(dest, PROJECTION_MATRIX_OFFSET);
    },

    getWorldSpacePosition: function () {
        return this.worldSpacePosition;
    },

    getWorldSpaceBoundingBox: function (bbox) {
        bbox.setEmpty();
    },

    viewFrustumChanged: function() {
        this.projectionDirty = true;
        this.scene.requestRedraw("view frustum changed");
    },

    getClippingPlanes: function(bb) {
        if(!bb) {
            bb = new XML3D.Box();
            this.scene.getBoundingBox(bb);
        }
        if (bb.isEmpty()) {
            return {near: 1, far: 10};
        }
        var w2v = mat4.create();
        this.getWorldToViewMatrix(w2v);
        bb.transformAxisAligned(w2v);

        var near = -bb.max.z, far = -bb.min.z, expand = Math.max((far - near) * 0.005, 0.05);

        // Expand the view frustum a bit to ensure 2D objects parallel to the camera are rendered
        near = Math.max(near - expand, expand, CLIPPLANE_NEAR_MIN);
        far = Math.max(far + expand, near + expand);
        return {near: near, far: far};
    },

    remove: function() {
        this.camera.destroy();
    }
});

/**
 * @param {Configuration} configuration
 * @param {Scene} scene
 * @param {RenderView} owner
 * @returns {Object}
 */
function createCamera(configuration, scene, owner) {

    switch(configuration.model) {
        case "urn:xml3d:view:perspective":
            return new CameraModels.PerspectiveCameraModel(configuration.dataNode, scene, owner);
        case "urn:xml3d:view:projective":
            return new CameraModels.ProjectiveCameraModel(configuration.dataNode, scene, owner);
        default:
            XML3D.debug.logWarning("Unknown camera model:", configuration.model);
            return new CameraModels.PerspectiveCameraModel(configuration.dataNode, scene, owner);
    }


}

// Export
module.exports = RenderView;


},{"../cameras/camera-models.js":89,"../tools/frustum.js":109,"./constants.js":98,"./rendernode.js":103,"gl-matrix":1}],106:[function(require,module,exports){
var DataNode = require("../../../xflow/interface/graph.js").DataNode;
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;
var XC = require("../../../xflow/interface/constants.js");
var BufferEntry = require("../../../xflow/interface/data.js").BufferEntry;
var InputNode = require("../../../xflow/interface/graph.js").InputNode;

var SceneParameters = ["width", "height", "aspect", "worldBoundingBox"];

/**
 *
 * @constructor
 */
var SceneData = function() {
    this.data = new DataNode(false);

    var width = createInputNode(this.data, "width", XC.DATA_TYPE.FLOAT, new Float32Array([600]));
    var height = createInputNode(this.data, "height", XC.DATA_TYPE.FLOAT, new Float32Array([800]));
    var worldBoundingBox = createInputNode(this.data, "worldBoundingBox", XC.DATA_TYPE.FLOAT, new XML3D.Box().data);

    var request = new ComputeRequest(this.data, SceneParameters, null);
    var result = this.result = request.getResult();

    defineFloatProperty(this, "width", result, width);
    defineFloatProperty(this, "height", result, height);

    Object.defineProperty(this, "worldBoundingBox", {
        get: function () {
            return result.getOutputData("worldBoundingBox").getValue();
        }, set: function (value) {
            worldBoundingBox.data.setValue(value);
        }
    });

    Object.defineProperty(this, "aspect", { writeable: false, get: function() {
        return result.getOutputData("aspect").getValue()[0];
    }});

    this.data.setCompute("aspect = xflow.div(width, height)");

};

function defineFloatProperty(obj, name, result, field) {
    Object.defineProperty(obj, name, {
        get: function () {
            return result.getOutputData(name).getValue()[0];
        },
        set: function (value) {
            field.data.setValue(new Float32Array([value]));
        }
    });
}


function createInputNode(dataNode, name, type, value) {
    var inputNode = new InputNode();
    inputNode.data = new BufferEntry(type, value);
    inputNode.name = name;
    dataNode.appendChild(inputNode);
    return inputNode;
}


module.exports = SceneData;

},{"../../../xflow/interface/constants.js":187,"../../../xflow/interface/data.js":188,"../../../xflow/interface/graph.js":189,"../../../xflow/interface/request.js":190}],107:[function(require,module,exports){
var Pager = require("./pager.js");
var RenderObject = require("./renderobject.js");
var RenderView = require("./renderview.js");
var RenderGroup = require("./rendergroup.js");
var RenderLight = require("./renderlight.js");
var MaterialConfiguration = require("./configuration.js");
var LightManager = require("../lights/light-manager.js");
var C = require("./constants.js");
var InputNode = require("../../../xflow/interface/graph.js").InputNode;
var DataNode = require("../../../xflow/interface/graph.js").DataNode;
var BufferEntry = require("../../../xflow/interface/data.js").BufferEntry;
var SceneData = require("./scene-data.js");
var XC = require("../../../xflow/interface/constants.js");
var URI = require("../../../utils/uri.js").URI;
var EventEmitter = require('events').EventEmitter;
var mat4 = require("gl-matrix").mat4;
var assert = require("assert");
/**
 * @extends {EventEmitter}
 * @constructor
 */
var Scene = function () {
    EventEmitter.call(this);
    this.boundingBox = new XML3D.Box();
    this.lights = new LightManager();
    this.pager = new Pager();

    /** @type RenderView */
    this.activeView = null;

    /** @type MaterialConfiguration */
    this._defaultMaterial = null;

    this.rootNode = this.createRootNode();

    var data = this.data = new SceneData();

    Object.defineProperty(this, "width", {
        get: function() { return data.width; },
        set: function(width) { data.width = width; }
    });

    Object.defineProperty(this, "height", {
        get: function() { return data.height; },
        set: function(height) { data.height = height; }
    });

};

XML3D.createClass(Scene, EventEmitter, {
    /**
     * @returns {RenderView}
     */
    getActiveView: function () {
        return this.activeView;
    }, /**
     * @param {RenderView} view
     */
    setActiveView: function (view) {
        if (view != this.activeView) {
            assert(view, "Active view must not be null");
            this.activeView = view;
            this.emit(C.EVENT_TYPE.VIEW_CHANGED, this.activeView);
        }
    },
    /**
     * @param {object?} opt
     * @returns {RenderObject}
     */
    createRenderObject: function (opt) {
        var pageEntry = this.pager.getPageEntry(RenderObject.ENTRY_SIZE);
        return new RenderObject(this, pageEntry, opt);
    },

    createRenderGroup: function (opt) {
        var pageEntry = this.pager.getPageEntry(RenderGroup.ENTRY_SIZE);
        return new RenderGroup(this, pageEntry, opt);
    },

    createRenderView: function (opt) {
        var pageEntry = this.pager.getPageEntry(RenderView.ENTRY_SIZE);
        return new RenderView(this, pageEntry, opt);
    },

    createRenderLight: function (opt) {
        var pageEntry = this.pager.getPageEntry(RenderLight.ENTRY_SIZE);
        return new RenderLight(this, pageEntry, opt);
    },

    createMaterialConfiguration: function(model, data, opt) {
        return new MaterialConfiguration(model, data, opt);
    },

    createRootNode: function () {
        var pageEntry = this.pager.getPageEntry(RenderGroup.ENTRY_SIZE);
        var root = new RenderGroup(this, pageEntry, {
            material: this.getDefaultMaterial(), name: "@scene"
        });
        root.setWorldMatrix(mat4.create());
        root.setLocalMatrix(mat4.create());
        root.transformDirty = false;
        return root;
    },

    updateBoundingBox: function () {
        if (this.rootNode.boundingBoxDirty) {
            this.rootNode.getWorldSpaceBoundingBox(this.boundingBox);
            this.data.worldBoundingBox = this.boundingBox.data;
        }
    },

    getBoundingBox: function (bb) {
        this.updateBoundingBox();
        bb.copy(this.boundingBox);
    },

    createDrawable: function (/*obj*/) {
        throw new Error("Scene::createDrawable not implemented");
    },

    requestRedraw: function (/*reason*/) {
        throw new Error("Scene::requestRedraw not implemented");
    },

    traverse: function (callback) {
        this.rootNode.traverse(callback);
    },

    /**
     * Returns all objects intersected by the given ray, based on their bounding boxes
     * @param ray
     * @returns {Array} An array of RenderObjects that were hit by this ray
     */
    findRayIntersections: function (ray) {
        var intersections = [];
        this.rootNode.findRayIntersections(ray, intersections);
        return intersections;
    },

    getDefaultMaterial: function() {
        if(!this._defaultMaterial) {
            var inputNode = new InputNode();
            inputNode.data = new BufferEntry(XC.DATA_TYPE.FLOAT3, new Float32Array([1, 0, 0]));
            inputNode.name = "diffuseColor";

            var data = new DataNode(false);
            data.appendChild(inputNode);

            this._defaultMaterial = this.createMaterialConfiguration(
                {"type": "urn", "urn": new URI("urn:xml3d:material:matte")},
                data,
                {name: "default"}
            );
        }
        return this._defaultMaterial;
    },

    handleResizeEvent: function (width, height) {
        this.width = width;
        this.height = height;
    }



});

module.exports = Scene;

},{"../../../utils/uri.js":184,"../../../xflow/interface/constants.js":187,"../../../xflow/interface/data.js":188,"../../../xflow/interface/graph.js":189,"../lights/light-manager.js":94,"./configuration.js":97,"./constants.js":98,"./pager.js":100,"./rendergroup.js":101,"./renderlight.js":102,"./renderobject.js":104,"./renderview.js":105,"./scene-data.js":106,"assert":11,"events":12,"gl-matrix":1}],108:[function(require,module,exports){
var DataChangeNotifier = require("../../../xflow/interface/data.js").DataChangeNotifier;

/**
 *
 * @constructor
 */
var DataChangeListener = function () {
    DataChangeNotifier.addListener(this.dataEntryChanged);
};

/**
 *
 * @param {Xflow.DataEntry} entry
 * @param {Xflow.DATA_ENTRY_STATE} notification
 */
DataChangeListener.prototype.dataEntryChanged = function (entry, notification) {
    if (entry.userData.webglData) {
        for (var i in entry.userData.webglData) {
            var oldChanged = entry.userData.webglData[i].changed;
            entry.userData.webglData[i].changed = Math.max(oldChanged, notification);
        }
    }
};

module.exports = DataChangeListener;

},{"../../../xflow/interface/data.js":188}],109:[function(require,module,exports){
var vec3 = require("gl-matrix").vec3;
var tmp1 = vec3.create();
var tmp2 = vec3.create();
var assert = require("assert");

/**
 *
 * @param {number} nearPlane
 * @param {number} farPlane
 * @param {number} fovx
 * @param {number} fovy
 * @param {number} aspect
 * @param {boolean} orthographic
 * @constructor
 */
var Frustum = function (nearPlane, farPlane, fovx, fovy, aspect, orthographic) {
    this.setFrustum(nearPlane, farPlane, fovx, fovy, aspect, orthographic);
};

XML3D.extend(Frustum.prototype, {
    /**
     *
     * @param nearPlane
     * @param farPlane
     * @param fovx Horizontal field of view in radians
     * @param fovy Vertical field of view in radians
     * @param aspect
     * @param {bool?} orthographic
     */
    setFrustum: function (nearPlane, farPlane, fovx, fovy, aspect , orthographic) {
        assert(nearPlane > 0 && farPlane > 0, "Near or far plane undefined or non-positive");
        assert(!(fovx && fovy), "fovx and fovy cannot both be non-zero.");
        assert(aspect > 0, "aspect cannot both be non-zero.");

        if (fovx) {
            this.right = nearPlane * Math.tan(fovx / 2);
            this.left = -this.right;
            this.top = ((this.right - this.left) / aspect) / 2;
            this.bottom = -this.top;
        } else {
            this.top = nearPlane * Math.tan(0.5 * fovy);
            this.bottom = -this.top;
            this.right = (this.top - this.bottom) * aspect / 2;
            this.left = -this.right;
        }
        this.nearPlane = nearPlane;
        this.farPlane = farPlane;

        this.orthographic = orthographic == undefined ? false : orthographic;
    },

    getProjectionMatrix: function (matrix) {
        var limitMax = Number.MAX_VALUE;
        var rightPlusLeft = this.right + this.left;
        var rightMinusLeft = this.right - this.left;

        var topPlusBottom = this.top + this.bottom;
        var topMinusBottom = this.top - this.bottom;

        var farPlusNear = this.farPlane + this.nearPlane;
        var farMinusNear = this.farPlane - this.nearPlane;

        if ((Math.abs(rightMinusLeft) < 1 && Math.abs(rightPlusLeft) > limitMax * Math.abs(rightMinusLeft)) || (Math.abs(topMinusBottom) < 1 && Math.abs(topPlusBottom) > limitMax * Math.abs(topMinusBottom)) || (Math.abs(farMinusNear) < 1 && Math.abs(farPlusNear) > limitMax * Math.abs(farMinusNear))) {
            throw new Error("Bad viewing frustum: projection matrix cannot be computed.");
        }

        var A, B, C, D, E, F;
        var m = matrix.data ? matrix.data : matrix;

        if (this.orthographic) {
            var tx = -rightPlusLeft / rightMinusLeft;
            var ty = -topPlusBottom / topMinusBottom;
            var tz = -farPlusNear / farMinusNear;

            if ((Math.abs(rightMinusLeft) < 1 && 2 > limitMax * Math.abs(rightMinusLeft)) || (Math.abs(topMinusBottom) < 1 && 2 > limitMax * Math.abs(topMinusBottom)) || (Math.abs(farMinusNear) < 1 && 2 > limitMax * Math.abs(farMinusNear))) {
                throw new Error("Bad viewing frustum:  projection matrix cannot be computed.");
            }

            A = 2 / rightMinusLeft;
            B = 2 / topMinusBottom;
            C = -2 / farMinusNear;

            XML3D.math.mat4.identity(m);
            m[0] = A;
            m[5] = B;
            m[10] = C;
            m[12] = tx;
            m[13] = ty;
            m[14] = tz;
            m[15] = 1.0;
        } else {
            A = rightPlusLeft / rightMinusLeft;
            B = topPlusBottom / topMinusBottom;
            C = -farPlusNear / farMinusNear;

            var farTimesNear = -2 * this.farPlane * this.nearPlane;
            if (Math.abs(farMinusNear) < 1 && Math.abs(farTimesNear) > limitMax * Math.abs(farMinusNear)) {
                throw new Error("Bad viewing frustum: projection matrix cannot be computed.");
            }

            D = farTimesNear / farMinusNear;

            var twoTimesNear = 2 * this.nearPlane;

            if ((Math.abs(rightMinusLeft) < 1 && Math.abs(twoTimesNear) > limitMax * Math.abs(rightMinusLeft)) || (Math.abs(topMinusBottom) < 1 && Math.abs(twoTimesNear) > limitMax * Math.abs(topMinusBottom))) {
                throw new Error("Bad viewing frustum: projection matrix cannot be computed.");
            }

            E = twoTimesNear / rightMinusLeft;
            F = twoTimesNear / topMinusBottom;

            XML3D.math.mat4.identity(m);
            m[0] = E;
            m[5] = F;
            m[8] = A;
            m[9] = B;
            m[10] = C;
            m[11] = -1;
            m[14] = D;
            m[15] = 0;
        }
        return matrix;
    },

    getPlanes: (function () {

        var c_a = vec3.create();
        var c_b = vec3.create();
        var c_c = vec3.create();
        var c_d = vec3.create();

        var c_e = vec3.create();
        var c_f = vec3.create();
        var c_g = vec3.create();
        var c_o = vec3.create();


        return function (planes, M) {
            vec3.transformMat4(c_a, [this.left, this.bottom, -this.nearPlane], M);
            vec3.transformMat4(c_b, [this.left, this.top, -this.nearPlane], M);
            vec3.transformMat4(c_c, [this.right, this.top, -this.nearPlane], M);
            vec3.transformMat4(c_d, [this.right, this.bottom, -this.nearPlane], M);
            if (!this.orthographic) {
                var s = this.farPlane / this.nearPlane;
                var farLeft = s * this.left;
                var farRight = s * this.right;
                var farTop = s * this.top;
                var farBottom = s * this.bottom;
                vec3.transformMat4(c_e, [farLeft, farBottom, -this.farPlane], M);
                vec3.transformMat4(c_f, [farLeft, farTop, -this.farPlane], M);
                vec3.transformMat4(c_g, [farRight, farTop, -this.farPlane], M);
                vec3.transformMat4(c_o, [0, 0, 0], M);
                planes[0].setFromPoints(c_o, c_c, c_b);
                planes[1].setFromPoints(c_o, c_d, c_c);
                planes[2].setFromPoints(c_o, c_a, c_d);
                planes[3].setFromPoints(c_o, c_b, c_a);
                planes[4].setFromPoints(c_a, c_d, c_c);
                planes[5].setFromPoints(c_e, c_f, c_g);
            } else {
                vec3.transformMat4(c_e, [this.left, this.bottom, -this.farPlane], M);
                vec3.transformMat4(c_f, [this.left, this.top, -this.farPlane], M);
                vec3.transformMat4(c_g, [this.right, this.top, -this.farPlane], M);
                vec3.transformMat4(c_o, [this.right, this.bottom, -this.farPlane], M);
                planes[0].setFromPoints(c_c, c_g, c_f);
                planes[1].setFromPoints(c_d, c_o, c_g);
                planes[2].setFromPoints(c_a, c_e, c_o);
                planes[3].setFromPoints(c_b, c_f, c_e);
                planes[4].setFromPoints(c_a, c_d, c_c);
                planes[5].setFromPoints(c_e, c_f, c_g);
            }
        };
    }())


});


var Plane = function () {
    this.distance = 0;
    this.normal = vec3.create();
};

XML3D.extend(Plane.prototype, {
    setFromPoints: function (point1, point2, point3) {
        vec3.cross(this.normal, vec3.sub(tmp2, point3, point1), vec3.sub(tmp1, point2, point1));
        vec3.normalize(this.normal, this.normal);
        this.distance = -vec3.dot(this.normal, point1);
    },

    set: function (x, y, z, distance) {
        vec3.set(this.normal, x, y, z);
        vec3.normalize(this.normal, this.normal);
        this.distance = distance;
    }
});

var FrustumTest = function (frustum, cameraMatrix) {
    this.frustumPlanes = [new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()];
    if (frustum && cameraMatrix) {
        this.set(frustum, cameraMatrix);
    }
};


XML3D.extend(FrustumTest.prototype, {
    /**
     *
     * @param {Frustum} frustum
     * @param {mat4} matrix
     */
    set: function (frustum, matrix) {
        frustum.getPlanes(this.frustumPlanes, matrix);

    }, /**
     * @param bbox
     * @returns {boolean}
     */
    isBoxVisible:  function (bbox) {
            if (bbox.isEmpty())
                return false;

            for (var i = 0; i < this.frustumPlanes.length; i++) {
                var plane = this.frustumPlanes[i];
                var normal = plane.normal;
                var bbx = normal[0] >= 0.0 ? bbox.data[3] : bbox.data[0];
                var bby = normal[1] >= 0.0 ? bbox.data[4] : bbox.data[1];
                var bbz = normal[2] >= 0.0 ? bbox.data[5] : bbox.data[2];

                // Compute the distance
                var distance = bbx * normal[0] + bby * normal[1] + bbz * normal[2] + plane.distance;
                assert(!isNaN(distance));

                // if highest point is below plane then all below.
                if (distance < 0.0) {
                    return false;
                }
            }
            return true;
    }

});

module.exports = {
    Plane: Plane,
    Frustum: Frustum,
    FrustumTest: FrustumTest
};

},{"assert":11,"gl-matrix":1}],110:[function(require,module,exports){
var vec3 = require("gl-matrix").vec3;

/**
 *
 * @constructor
 */
var ObjectSorter = function () {

};

var c_bbox = new XML3D.Box();
var c_center = vec3.create();

XML3D.extend(ObjectSorter.prototype, {
    /**
     * @param {Array} sourceObjectArray
     * @param {XML3D.Mat4?} viewMatrix Matrix to apply to objects world space extend before sorting
     */
    sortObjects: function (sourceObjectArray, viewMatrix) {
        var presortOpaque = {}, presortTransparent = {}, obj, zLayer, i, l, n;

        // Sort by transparency and z-index
        for (i = 0, l = sourceObjectArray.length; i < l; i++) {
            obj = sourceObjectArray[i];
            if (obj.inFrustum === false) {
                continue;
            }
            if (obj.hasTransparency()) {
                if (!presortTransparent[obj._zIndex]) {
                    presortTransparent[obj._zIndex] = [obj];
                } else {
                    presortTransparent[obj._zIndex].push(obj);
                }
            } else {
                if (!presortOpaque[obj._zIndex]) {
                    presortOpaque[obj._zIndex] = [obj];
                } else {
                    presortOpaque[obj._zIndex].push(obj);
                }
            }
        }

        // Separate the scene into z-layers according to z-index
        var zLayers = Object.keys(presortOpaque).concat(Object.keys(presortTransparent));
        zLayers = zLayers.sort(function(a,b) {
            return a.localeCompare(b);
        }).filter(function(item, pos, ary) {
            // Remove duplicates
            return !pos || item != ary[pos - 1];
        });

        // Sort opaque z-buckets by shader
        var opaque = {};
        for (i=0; i<zLayers.length; i++) {
            zLayer = zLayers[i];
            opaque[zLayer] = {};
            for (n in presortOpaque[zLayer]) {
                obj = presortOpaque[zLayer][n];
                var program = obj.getProgram();
                opaque[zLayer][program.id] = opaque[zLayer][program.id] || [];
                opaque[zLayer][program.id].push(obj);
            }
        }

        // Sort opaque shader buckets by depth for early z fails
        for (zLayer in zLayers) {
            for (var progId in opaque[zLayer]) {
                var withinShader = opaque[zLayer][progId];
                var sortedArray = new Array(withinShader.length);
                for (i = 0; i < withinShader.length; i++) {
                    obj = withinShader[i];
                    obj.getWorldSpaceBoundingBox(c_bbox);
                    c_bbox.center(c_center);
                    viewMatrix && vec3.transformMat4(c_center, c_center, viewMatrix);
                    sortedArray[i] = {
                        obj: obj, depth: c_center.z
                    };
                }
                sortedArray.sort(function (a, b) {
                    return b.depth - a.depth;
                });
                opaque[zLayer][progId] = sortedArray.map(function (e) {
                    return e.obj;
                });
            }
        }

        //Sort transparent z-buckets back to front
        var transparent = {};
        for (var ind in zLayers) {
            zLayer = zLayers[ind];
            var tlayer = [];
            for (n in presortTransparent[zLayer]) {
                obj = presortTransparent[zLayer][n];
                obj.getWorldSpaceBoundingBox(c_bbox);
                c_bbox.center(c_center);
                viewMatrix && vec3.transformMat4(c_center, c_center, viewMatrix);
                tlayer.push([obj, c_center.z]);
            }

            tlayer.sort(function (a, b) {
                return a[1] - b[1];
            });

            for (i = 0; i < tlayer.length; i++) {
                tlayer[i] = tlayer[i][0];
            }

            transparent[zLayer] = tlayer;
        }

        // zLayers contains all unique z-index values in the scene, partitioning it into z-buckets
        return {
            opaque: opaque, transparent: transparent, zLayers : zLayers
        }
    }

});


module.exports = ObjectSorter;



},{"gl-matrix":1}],111:[function(require,module,exports){
/** Calculate the offset of the given element and return it.
 *
 *  @param {Object} element
 *  @return {{top:number, left:number}} the offset
 *
 *  This code is taken from http://javascript.info/tutorial/coordinates .
 *  We don't want to do it with the offsetParent way, because the xml3d
 *  element is actually invisible and thus offsetParent will return null
 *  at least in WebKit. Also it's slow. So we use getBoundingClientRect().
 *  However it returns the box relative to the window, not the document.
 *  Thus, we need to incorporate the scroll factor. And because IE is so
 *  awesome some workarounds have to be done and the code gets complicated.
 */
function calculateOffset(element) {
    var box = element.getBoundingClientRect();
    var body = document.body;
    var docElem = document.documentElement;

    // get scroll factor (every browser except IE supports page offsets)
    var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
    var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;

    // the document (`html` or `body`) can be shifted from left-upper corner in IE. Get the shift.
    var clientTop = docElem.clientTop || body.clientTop || 0;
    var clientLeft = docElem.clientLeft || body.clientLeft || 0;

    var top = box.top + scrollTop - clientTop;
    var left = box.left + scrollLeft - clientLeft;

    // for Firefox an additional rounding is sometimes required
    return {top: Math.round(top), left: Math.round(left)};
}


module.exports = {

    /** Convert a given mouse page position to be relative to the given target element.
     *  Most probably the page position are the MouseEvent's pageX and pageY attributes.
     *
     *  @param {!Object} xml3dEl the xml3d element to which the coords need to be translated
     *  @param {!number} pageX the x-coordinate relative to the page
     *  @param {!number} pageY the y-coordinate relative to the page
     *  @return {{x: number, y: number}} the converted coordinates
     */
    convertPageCoords: function (xml3dEl, pageX, pageY) {
        var off = calculateOffset(xml3dEl);

        return {x: pageX - off.left, y: pageY - off.top};
    }
};

},{}],112:[function(require,module,exports){
var TextureManager = require("texture-manager").SimpleTextureManager;
var GLTexture = require("./texture.js").GLTexture;
var GLCubeMap = require("./texture.js").GLCubeMap;
var GLCanvasTarget = require("./rendertarget.js").GLCanvasTarget;
var ProgramFactory = require("./../shader/programfactory.js");
var XC = require("../../../xflow/interface/constants.js");
var GL = require("../constants.js");

var CONTEXT_OPTIONS = {
    alpha: true, premultipliedAlpha: false, antialias: true, stencil: true, preserveDrawingBuffer: true
};

/**
 * @param {HTMLCanvasElement!} canvas
 */
function getContextForCanvas(canvas) {
    try {
        return canvas.getContext('experimental-webgl', CONTEXT_OPTIONS);
    } catch (e) {
        return null;
    }
}

/**
 * Context that includes all GL related resources / handlers
 * @param {HTMLCanvasElement!} canvas
 * @param {number} id
 * @constructor
 */
var GLContext = function (canvas, id) {
    this.gl = getContextForCanvas(canvas);
    this.id = id;
    this.canvasTarget = new GLCanvasTarget(this, canvas.clientWidth, canvas.clientHeight);
    this.programFactory = new ProgramFactory(this);
    this.textureManager = new TextureManager({ units: this.gl.getParameter(GL.MAX_COMBINED_TEXTURE_IMAGE_UNITS )});
    this.stats = {
        materials: 0, meshes: 0
    };
    this.extensions = populateExtensions(this.gl);

};

var EXTENSIONS = GLContext.EXTENSIONS = {};
EXTENSIONS.STANDARD_DERIVATES = 'OES_standard_derivatives';
EXTENSIONS.MULTIPLE_RENDER_TARGETS = 'WEBGL_draw_buffers';
EXTENSIONS.DEPTH_TEXTURE = 'WEBGL_depth_texture';
EXTENSIONS.FLOAT_COLOR_BUFFER = 'WEBGL_color_buffer_float';
EXTENSIONS.FLOAT_TEXTURES = 'OES_texture_float';
EXTENSIONS.FLOAT_TEXTURES_LINEAR = "OES_texture_float_linear";
EXTENSIONS.UINT32_INDICES = 'OES_element_index_uint'; //Also defined in xflow/utils/utils.js

XML3D.extend(GLContext.prototype, {
    getXflowEntryWebGlData: function (entry) {
        return getXflowEntryWebGlData(entry, this.id);
    },

    requestRedraw: function (reason) {
        //handler.redraw(reason, forcePicking);
    },

    handleResizeEvent: function (width, height) {
        this.canvasTarget = new GLCanvasTarget(this, width, height);
    },

    getStatistics: function () {
        return this.stats;
    },

    getExtensionByName: function (name) {
        return this.extensions[name];
    } ,

    createTexture: function() {
        return new GLTexture(this);
    } ,
    createCubeMap: function() {
        return new GLCubeMap(this);
    }
});


function getXflowEntryWebGlData(entry, canvasId){
    if(!entry) return null;
    if(!entry.userData.webglData)
        entry.userData.webglData = {};
    if(!entry.userData.webglData[canvasId])
        entry.userData.webglData[canvasId] = {
            changed : XC.DATA_ENTRY_STATE.CHANGED_NEW
        };
    return entry.userData.webglData[canvasId];
}

/**
 * @param {WebGLRenderingContext} gl
 * @returns {{}}
 */
function populateExtensions(gl) {
    var result = {};
    for (var name in EXTENSIONS) {
        var extensionName = EXTENSIONS[name];
        var ext = gl.getExtension(extensionName);
        if (!ext) {
            XML3D.debug.logInfo(extensionName, "is not supported on your graphics card");
        } else {
            result[extensionName] = ext;
        }
    }
    return result;
}

module.exports = GLContext;



},{"../../../xflow/interface/constants.js":187,"../constants.js":120,"./../shader/programfactory.js":156,"./rendertarget.js":116,"./texture.js":117,"texture-manager":43}],113:[function(require,module,exports){
var FullscreenQuad = function (context) {
    this.gl = context.gl;
    this.createGLAssets();
};

XML3D.extend(FullscreenQuad.prototype, {

    createGLAssets: function () {
        var gl = this.gl;
        this.posBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0]), gl.STATIC_DRAW);
    },

    draw: function (program) {
        var gl = this.gl;
        var posAttr = program.attributes["position"];
        gl.enableVertexAttribArray(posAttr.location);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer);
        gl.vertexAttribPointer(posAttr.location, 3, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        gl.disableVertexAttribArray(posAttr.location);
    }

});

module.exports = FullscreenQuad;


},{}],114:[function(require,module,exports){
var GL = require("../constants.js");

/**
 *
 * @param context
 * @constructor
 */
var GLMesh = function (context) {
    this.context = context;
    this.buffers = {};
    this.uniformOverride = {};
    this.minIndex = 0;
    this.maxIndex = 0;
    this.isIndexed = false;
    this.vertexCount = null;
    this.minAttributeCount = -1;
    this.context.getStatistics().meshes++;
    this.glType = null;
    this.multiDraw = false;
};

XML3D.extend(GLMesh.prototype, {
    setIndexRange: function (minIndex, maxIndex) {
        this.minIndex = minIndex;
        this.maxIndex = maxIndex;
    },

    setPrimitiveType: function(type) {
        this.glType = type;
        this.multiDraw = (this.glType == GL.LINE_STRIP || this.glType == GL.TRIANGLE_STRIP);
    },

    checkBufferCompatible: function (name, xflowDataBuffer) {
        var cnt = xflowDataBuffer.getIterateCount();
        this.minAttributeCount = (this.minAttributeCount == -1 ? cnt : Math.min(this.minAttributeCount, cnt));

        if (this.isIndexed) {
            if (cnt <= this.maxIndex) {
                throw new Error("Index range of [" + this.minIndex + ", " + this.maxIndex + "] " + " goes beyond element count " + cnt + " of attribute '" + name + "'");
            }
        } else if (this.vertexCount !== null) {
            if (cnt < this.vertexCount)
                throw new Error("VertexCount " + this.vertexCount + " is larger than element count " + cnt + " of attribute '" + name + "'");
        }
    },

    removeBuffer: function (name) {
        delete this.buffers[name];
    },

    setBuffer: function (name, buffer) {
        this.buffers[name] = buffer;
        this.isIndexed = this.isIndexed || name == "index";
    },

    clear: function () {
        this.buffers = {};
        this.uniformOverride = {};
        this.minIndex = this.maxIndex = 0;
        this.isIndexed = false;
        this.minAttributeCount = -1;
    },

    setUniformOverride: function (name, value) {
        if (value === undefined)
            delete this.uniformOverride[name];
        this.uniformOverride[name] = value;
    },

    setVertexCount: function (vertexCount) {
        this.vertexCount = vertexCount;
    },

    isReadyToRender: function () {
        return this.minAttributeCount > 0;
    },

    /**
     * @returns {number}
     */
    getElementCount: function () {
        try {
            return this.buffers.index.length;
        } catch (e) {
            //XML3D.debug.logError("Could not calculate element count.", e);
            return 0;
        }
    }, /**
     * @returns {number}
     */
    getVertexCount: function () {
        try {
            return (this.vertexCount != null ? this.vertexCount : this.minAttributeCount );
        } catch (e) {
            //XML3D.debug.logError("Could not calculate vertex count.", e);
            return 0;
        }
    },

    /**
     * @param {AbstractShaderClosure} program
     * @private
     */
    _bindVertexBuffers: function(program) {
        var gl = this.context.gl, sAttributes = program.attributes, buffers = this.buffers, i, name;

        var keys = Object.keys(sAttributes);
        var keyLength = keys.length;

        for (i = 0; i < keyLength; i++) {
            name = keys[i];
            var buffer = buffers[name];
            var location = sAttributes[name].location;

            if (!buffer) {
                continue;
            }
            gl.enableVertexAttribArray(location);
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.vertexAttribPointer(location, buffer.tupleSize, buffer.glType, false, 0, 0);
        }
    },

    _unbindVertexBuffers: function (program) {
        var gl = this.context.gl, sAttributes = program.attributes;
        for (var name in sAttributes) {
            var shaderAttribute = sAttributes[name];
            gl.disableVertexAttribArray(shaderAttribute.location);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    },

    /**
     * @param {AbstractShaderClosure} program
     * @returns {number}
     */
    draw: function (program) {
        var gl = this.context.gl, sAttributes = program.attributes, buffers = this.buffers, triCount = 0, offset, j;

        //Bind vertex buffers
        this._bindVertexBuffers(program);

        //Draw the object
        if (this.isIndexed) {
            var indexBuffer = buffers.index;
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexBuffer);

            if (this.multiDraw && this.vertexCount) {
                offset = 0;
                for (j = 0; j < this.vertexCount.length; j++) {
                    var count = this.vertexCount[j];
                    gl.drawElements(this.glType, count, indexBuffer.glType, offset * indexBuffer.bytesPerElement);
                    offset += count;
                }
            } else {
                gl.drawElements(this.glType, this.getElementCount(), indexBuffer.glType, 0);
            }
            triCount = this.getElementCount() / 3;
        } else { // not indexed
            if (this.multiDraw && this.vertexCount) {
                offset = 0;
                for (j = 0; j < this.vertexCount.length; j++) {
                    var count = this.vertexCount[j];
                    gl.drawArrays(this.glType, offset, count);
                    offset += count;
                }
            } else {
                gl.drawArrays(this.glType, 0, this.getVertexCount());
                triCount = this.getVertexCount();
            }
        }

        //Unbind vertex buffers
        this._unbindVertexBuffers(program);


        if (program.undoUniformVariableOverride)
            program.undoUniformVariableOverride(this.uniformOverride);

        return triCount;
    }


});

module.exports = GLMesh;

},{"../constants.js":120}],115:[function(require,module,exports){

var utils = require("./utils.js");
var SystemNotifier = require("../system/system-notifier.js");
var GL = require("../constants.js");

//noinspection JSValidateJSDoc
/**
 * @param {WebGLRenderingContext} gl
 * @param {Number} type
 * @param {string} shaderSource
 * @return {WebGLShader}
 */
var createWebGLShaderFromSource = function (gl, type, shaderSource) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, shaderSource);
    gl.compileShader(shader);

    if (gl.getShaderParameter(shader, GL.COMPILE_STATUS) == 0) {
        var message = gl.getShaderInfoLog(shader);
        var errorString = "";
        if (type == GL.VERTEX_SHADER)
            errorString = "Vertex shader failed to compile: \n"; else
            errorString = "Fragment shader failed to compile: \n";

        errorString += message + "\n--------\n";
        errorString += "Shader Source:\n--------\n";
        errorString += XML3D.debug.formatSourceCode(shaderSource);
        gl.getError();
        SystemNotifier.sendEvent('glsl', {
                glslType: "compile_error",
                shaderType: type == GL.VERTEX_SHADER ? "vertex" : "fragment",
                code: shaderSource,
                message: message
            });

        throw new Error(errorString)
    }
    return shader;
};

//noinspection JSValidateJSDoc
/**
 * @param {WebGLRenderingContext} gl
 * @param vertexSources
 * @param fragmentSources
 * @returns {WebGLProgram}
 */
var createProgramFromSources = function (gl, vertexSources, fragmentSources) {
    var shd, s, src;
    var shaders = [];
    for (s in vertexSources) {
        src = vertexSources[s];
        shd = createWebGLShaderFromSource(gl, GL.VERTEX_SHADER, src);
        shaders.push(shd);
    }
    for (s in fragmentSources) {
        src = fragmentSources[s];
        shd = createWebGLShaderFromSource(gl, GL.FRAGMENT_SHADER, src);
        shaders.push(shd);
    }
    return createProgramFromShaders(gl, shaders);
};

//noinspection JSValidateJSDoc
/**
 * @param {WebGLRenderingContext} gl
 * @param {Object} shaders
 * @return {WebGLProgram}
 */
var createProgramFromShaders = function (gl, shaders) {
    var program = gl.createProgram();
    for (var s in shaders) {
        var shader = shaders[s];
        gl.attachShader(program, shader);
    }
    gl.linkProgram(program);
    if (gl.getProgramParameter(program, GL.LINK_STATUS) == 0) {
        var message = gl.getProgramInfoLog(program);
        var errorString = "Shader linking failed: \n";
        errorString += message;
        errorString += "\n--------\n";
        gl.getError();
        SystemNotifier.sendEvent('glsl', {glslType: "link_error", message: message});
        throw new Error(errorString);
    }
    return program;
};

var tally = function (gl, handle, programObject) {
    var i;
    // Tally shader attributes
    var numAttributes = gl.getProgramParameter(handle, gl.ACTIVE_ATTRIBUTES);
    for (i = 0; i < numAttributes; i++) {
        var att = gl.getActiveAttrib(handle, i);
        if (!att)
            continue;
        var attInfo = {};
        attInfo.name = att.name;
        attInfo.size = att.size;
        attInfo.glType = att.type;
        attInfo.location = gl.getAttribLocation(handle, att.name);
        programObject.attributes[att.name] = attInfo;
    }


    // Tally shader uniforms and samplers
    var numUniforms = gl.getProgramParameter(handle, gl.ACTIVE_UNIFORMS);
    for (i = 0; i < numUniforms; i++) {
        var uni = gl.getActiveUniform(handle, i);
        if (!uni)
            continue;
        var uniInfo = {};
        uniInfo.name = uni.name;
        uniInfo.size = uni.size;
        uniInfo.glType = uni.type;
        uniInfo.location = gl.getUniformLocation(handle, uni.name);

        var name = uniInfo.name;

        // Remove array identifier from name, this is handled by size
        if (name.substring(name.length - 3) == "[0]") {
            name = name.substring(0, name.length - 3); // Remove [0]
        }

        if (uni.type == gl.SAMPLER_2D || uni.type == gl.SAMPLER_CUBE) {
            // Set all texture units to 0, needs to be Int32Array
            uniInfo.cachedUnits = new Int32Array(uniInfo.size);
            uniInfo.textures = [];
            // Caches this information
            utils.setUniform(gl, uniInfo, uniInfo.cachedUnits);

            programObject.samplers[name] = uniInfo;
        } else
            programObject.uniforms[name] = uniInfo;
    }

};

var uniqueObjectId = utils.getUniqueCounter();

/**
 * @constructor
 * @param {WebGLRenderingContext} gl
 * @param {{ fragment: string, vertex: string }} sources
 */
var ProgramObject = function (gl, sources) {
    this.gl = gl;
    this.sources = sources;

    this.id = uniqueObjectId();
    this.attributes = {};
    this.uniforms = {};
    this.samplers = {};
    this.handle = null;

    this.create();
};

XML3D.extend(ProgramObject.prototype, {
    create: function () {
        XML3D.debug.logDebug("Create shader program: ", this.id);
        this.handle = createProgramFromSources(this.gl, [this.sources.vertex], [this.sources.fragment]);
        if (!this.handle)
            return;
        SystemNotifier.sendEvent('glsl', {glslType: "success"});
        this.bind();
        tally(this.gl, this.handle, this);
    },

    bind: function () {
        if (!this.handle) {
            XML3D.debug.logError("Trying to bind invalid GLProgram.");
        }
        this.gl.useProgram(this.handle);

        /**
         * Some of the dependent textures may have changed their texture units
         */
        for (var name in this.samplers) {
            var sampler = this.samplers[name];
            if(sampler.textures.length) {
                this.setSamplerFromTextures(sampler);
            }
        }
    },

    unbind: function () {
    }, isValid: function () {
        return !!this.handle;
    }, setUniformVariables: function (envNames, sysNames, inputCollection) {
        var i, base, override, name;
        if (envNames && inputCollection.envBase) {
            i = envNames.length;
            base = inputCollection.envBase;
            override = inputCollection.envOverride;
            while (i--) {
                name = envNames[i];
                this.setUniformVariable(name, override && override[name] !== undefined ? override[name] : base[name]);
            }
        }
        if (sysNames && inputCollection.sysBase) {
            i = sysNames.length;
            base = inputCollection.sysBase;
            while (i--) {
                name = sysNames[i];
                this.setUniformVariable(name, base[name]);
            }
        }
    }, setUniformVariable: function (name, value) {
        if (value === undefined) return;
        if (this.uniforms[name]) {
            utils.setUniform(this.gl, this.uniforms[name], value);
        } else if (this.samplers[name]) {
            this.setUniformSampler(this.samplers[name], value);
        }
    },

    /**
     * Sets the texture units from the textures associated with the sampler
     * @param sampler
     * @returns {boolean}
     */
    setSamplerFromTextures: function (sampler) {
        var textures = sampler.textures;
        var cachedUnits = sampler.cachedUnits;
        var textureUnitsChanged = false;

        for (var i = 0, ii = textures.length; i < ii; i++) {
            var unit = textures[i].unit;

            // If texture is not bound to a texture unit (-1), bind it now
            if (unit == -1) {
                unit = textures[i]._bind();
            }
            if (unit != cachedUnits[i]) {
                cachedUnits[i] = unit;
                textureUnitsChanged = true;
            }
        }
        if (textureUnitsChanged) {
            XML3D.debug.logDebug("Setting new texture units:", sampler.name, cachedUnits);
            utils.setUniform(this.gl, sampler, cachedUnits);
        }
    },

    setSamplerFromArray: function(sampler, arr) {
        var cachedUnits = sampler.cachedUnits;
        var textureUnitsChanged = false;

       for (var i = 0, ii = arr.length; i < ii; i++) {
            var unit = arr[i];
            if (unit != cachedUnits[i]) {
                cachedUnits[i] = unit;
                textureUnitsChanged = true;
            }
        }
        if (textureUnitsChanged) {
            utils.setUniform(this.gl, sampler, cachedUnits);
            XML3D.debug.logDebug("Setting global texture units:", sampler.name, cachedUnits, this.id);
        }
    },

    /**
     *
     * @param {Object} sampler
     * @param {Array.<GLTexture>|Int32Array} value
     */
    setUniformSampler: function (sampler, value) {
        XML3D.debug.assert(value && sampler);
        // Textures are always an array value
        XML3D.debug.assert(Array.isArray(value), "Program::setUniformSampler: Unexpected value.");
        // We have at least one entry
        XML3D.debug.assert(value.length, "Program::setUniformSampler: No entry in value.");

        /**
         * Value can either be an array of GLTextures that know their current texture unit,
         * otherwise a typed array containing the texture units we have to bind.
         * @type {boolean}
         */
        var hasTextures = value[0].unit != undefined;

        if(hasTextures) {
            sampler.textures = value;
            this.setSamplerFromTextures(sampler);
        } else {
            this.setSamplerFromArray(sampler, value);
        }
    }
});

module.exports = ProgramObject;


},{"../constants.js":120,"../system/system-notifier.js":158,"./utils.js":118}],116:[function(require,module,exports){
/**
 * @interface
 */
var IRenderTarget = function () {
};
IRenderTarget.prototype.bind = function () {
};
IRenderTarget.prototype.unbind = function () {
};
IRenderTarget.prototype.getWidth = function () {
};
IRenderTarget.prototype.getHeight = function () {
};
IRenderTarget.prototype.getScale = function () {
};
IRenderTarget.prototype.resize = function (width, height) {
};

/**
 * Wrapper to handle screen context as render target
 * @constructor
 * @param {GLContext} context
 * @param {Number} width
 * @param {Number} height
 * @implements IRenderTarget
 */
var GLCanvasTarget = function (context, width, height) {
    this.context = context;
    this.width = width;
    this.height = height;
};

var empty = function () {
};

XML3D.extend(GLCanvasTarget.prototype, {
    getWidth: function () {
        return this.width;
    }, getHeight: function () {
        return this.height;
    }, getScale: function () {
        return 1;
    }, bind: function() {
        this.context.gl.viewport(0, 0, this.width, this.height);
    }, unbind: empty, resize: empty
});

/**
 * @param context
 * @param opt
 * @constructor
 * @implements IRenderTarget
 */
var GLRenderTarget = function (context, opt) {
    this.context = context;
    this.width = opt.width || 800;
    this.height = opt.height || 600;
    this.scale = opt.scale || 1;
    this.opt = this.fillOptions(opt);
    this.handle = null;
    this.colorTarget = {handle: null, isTexture: false};
    this.depthTarget = {handle: null, isTexture: false};
    this.stencilTarget = {handle: null, isTexture: false};
    this.valid = false;
};

XML3D.extend(GLRenderTarget.prototype, {
    getWidth: function () {
        return this.width;
    }, getHeight: function () {
        return this.height;
    }, getScale: function () {
        return this.scale;
    }, bind: function () {
        if (!this.handle) {
            this.createFrameBuffer(this.opt.colorFormat, this.opt.depthFormat, this.opt.stencilFormat);
        }
        if (this.valid) {
            var gl = this.context.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.handle);
            gl.viewport(0, 0, this.width, this.height);
        }
    }, unbind: function () {
        var gl = this.context.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }, resize: function (width, height) {
        this.dispose();
        this.width = width;
        this.height = height;
        this.bind();
    }, createFrameBuffer: function (colorFormat, depthFormat, stencilFormat) {
        var gl = this.context.gl;

        this.handle = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.handle);
        colorFormat && this.createColorTarget(colorFormat);
        depthFormat && this.createDepthTarget(depthFormat);
        stencilFormat && this.createStencilTarget(stencilFormat);
        this.checkStatus();
    }, createColorTarget: function (colorFormat) {
        var gl = this.context.gl;
        if (this.opt.colorAsRenderbuffer) {
            var ct = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, ct);
            gl.renderbufferStorage(gl.RENDERBUFFER, colorFormat, this.width, this.height);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);

            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, ct);

            this.colorTarget = {
                handle: ct, isTexture: false
            };
        } else {
            //opt.generateMipmap = opt.generateColorsMipmap;
            var ctex = this.context.createTexture();
            ctex.createTex2DFromData(colorFormat, this.width, this.height, gl.RGBA, this.opt.colorType || gl.UNSIGNED_BYTE, this.opt);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, ctex.handle, 0);
            this.colorTarget = {
                handle: ctex, isTexture: true
            };
        }
    }, createDepthTarget: function (depthFormat) {
        var gl = this.context.gl;
        this.opt.isDepth = true;
        if (this.opt.depthAsRenderbuffer) {
            var dt = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, dt);
            gl.renderbufferStorage(gl.RENDERBUFFER, depthFormat, this.width, this.height);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);

            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, dt);

            this.depthTarget = {
                handle: dt, isTexture: false
            }
        } else {
            //opt.generateMipmap = opt.generateDepthMipmap;
            var dtex = this.context.createTexture();
            dtex.createTex2DFromData(depthFormat, this.width, this.height, gl.DEPTH_COMPONENT, gl.FLOAT, this.opt);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, dtex.handle, 0);

            this.depthTarget = {
                handle: dtex, isTexture: true
            }
        }
    }, createStencilTarget: function (stencilFormat) {
        var gl = this.context.gl;
        if (this.opt.stencilAsRenderbuffer) {
            var st = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, st);
            gl.renderbufferStorage(gl.RENDERBUFFER, stencilFormat, this.width, this.height);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);

            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, st);

            this.stencilTarget = {
                handle: st, isTexture: false
            }
        } else {
            //opt.generateMipmap = opt.generateStencilMipmap;
            var stex = this.context.createTexture();
            stex.createTex2DFromData(stencilFormat, this.width, this.height, gl.STENCIL_COMPONENT, gl.UNSIGNED_BYTE, this.opt);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.TEXTURE_2D, stex.handle, 0);

            this.stencilTarget = {
                handle: stex, isTexture: true
            }
        }
    }, checkStatus: function () {
        var gl = this.context.gl;

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.handle);
        //Finalize framebuffer creation
        var fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

        switch (fbStatus) {
            case gl.FRAMEBUFFER_COMPLETE:
                break;
            case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                break;
            case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                break;
            case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                break;
            case gl.FRAMEBUFFER_UNSUPPORTED:
                XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
                break;
            default:
                XML3D.debug.logError("Incomplete framebuffer: " + fbStatus);
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        this.valid = (fbStatus == gl.FRAMEBUFFER_COMPLETE);
        return this.valid;
    }, fillOptions: function (options) {
        var gl = this.context.gl;
        var opt = {
            wrapS: gl.CLAMP_TO_EDGE,
            wrapT: gl.CLAMP_TO_EDGE,
            minFilter: gl.NEAREST,
            magFilter: gl.NEAREST,
            depthMode: gl.LUMINANCE,
            depthCompareMode: gl.COMPARE_R_TO_TEXTURE,
            depthCompareFunc: gl.LEQUAL,
            colorsAsRenderbuffer: false,
            depthAsRenderbuffer: false,
            stencilAsRenderbuffer: false,
            isDepth: false
        };

        for (var item in options) {
            opt[item] = options[item];
        }
        return opt;
    }, dispose: function () {
        if (!this.handle)
            return;

        var gl = this.context.gl;
        gl.deleteFramebuffer(this.handle);

        if (this.colorTarget !== null) {
            if (this.colorTarget.isTexture)
                this.colorTarget.handle.dispose(); else
                gl.deleteRenderBuffer(this.colorTarget.handle);
        }
        if (this.depthTarget !== null) {
            if (this.depthTarget.isTexture)
                this.depthTarget.handle.dispose(); else
                gl.deleteRenderBuffer(this.depthTarget.handle);
        }
        if (this.stencilTarget !== null) {
            if (this.stencilTarget.isTexture)
                this.stencilTarget.handle.dispose(); else
                gl.deleteRenderBuffer(this.stencilTarget.handle);
        }
    }
});

var GLScaledRenderTarget = function (context, maxDimension, opt) {
    GLRenderTarget.call(this, context, opt);
    this.scaleToMaxDimension(maxDimension);
};

XML3D.createClass(GLScaledRenderTarget, GLRenderTarget);
XML3D.extend(GLScaledRenderTarget.prototype, {
    scaleToMaxDimension: function (maxDimension) {
        var hDiff = this.height - maxDimension;
        var wDiff = this.width - maxDimension;

        if (hDiff > 0 || wDiff > 0) {
            var scale;
            if (hDiff > wDiff) {
                scale = maxDimension / this.height;
            } else {
                scale = maxDimension / this.width;
            }
            this.width = Math.floor(this.width * scale);
            this.height = Math.floor(this.height * scale);
            this.scale = scale;
        }
    }
});


    /**
     * @param context
     * @param opt
     * @constructor
     * @implements IRenderTarget
     */
    var GLCubeMapRenderTarget = function (context, opt) {
        var gl = context.gl;
        this.context = context;
        this.width = opt.width || 800;
        this.height = this.width;
        this.scale = opt.scale || 1;
        this.opt = this.fillOptions(opt);
        this.handle = null;
        this.ctex = null;
        this.dtex = null;
        this.stex = null;
        this.colorTarget = null;
        this.depthTarget =  null;
        this.stencilTarget = null;
        this.valid = false;
        this.glSides = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                        gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
                        gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];
        this.framebuffers = [];
    };

    XML3D.extend(GLCubeMapRenderTarget.prototype, {
        getWidth: function() {
            return this.width;
        },
        getHeight: function() {
            return this.height;
        },
        getScale: function() {
            return this.scale;
        },
        bind: function (side) {
            if (this.framebuffers.length <= 0) {
                this.createFrameBuffers(this.opt.colorFormat, this.opt.depthFormat, this.opt.stencilFormat);
            }
            if (this.valid) {
                var gl = this.context.gl;
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[side]);
                gl.viewport(0, 0, this.width, this.height);
            }
        },
        unbind: function () {
            var gl = this.context.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        },
        resize: function(width, height) {
            this.dispose();
            this.width = width;
            this.height = height;
            this.bind();
        },
        createFrameBuffers: function (colorFormat, depthFormat, stencilFormat) {
            var gl = this.context.gl;

            if(colorFormat) { //TODO check if renderbuffers instead of textures...
                this.ctex = this.context.createCubeMap();
                this.ctex.createTex2DFromData(colorFormat, this.width, this.height, gl.RGBA, this.opt.colorType || gl.UNSIGNED_BYTE, this.opt);
                this.colorTarget = { handle: this.ctex,  isTexture: true};
            }
            if(depthFormat) {
                this.opt.isDepth = true;

                if (this.opt.depthAsRenderbuffer) {
                } else {
                    this.dtex = this.context.createCubeMap();
                    this.dtex.createTex2DFromData(depthFormat, this.width, this.height, gl.DEPTH_COMPONENT, gl.FLOAT, this.opt);
                    this.depthTarget = { handle: this.dtex,  isTexture: true};
                }
            }
            if(stencilFormat) {
                this.stex = this.context.createCubeMap();
                this.stex.createTex2DFromData(stencilFormat, this.width, this.height, gl.STENCIL_COMPONENT, gl.UNSIGNED_BYTE, this.opt);
                this.stencilTarget = { handle: this.stex, isTexture: true};
            }

            for(var i = 0; i < this.glSides.length; ++i) {
                this.framebuffers[i] = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[i]);
                colorFormat && this.createColorTarget(colorFormat, i);
                depthFormat && this.createDepthTarget(depthFormat, i);
                stencilFormat && this.createStencilTarget(stencilFormat, i);
                this.checkStatus(i);
            }
        },
        createColorTarget: function (colorFormat, side) {
            var gl = this.context.gl;
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, this.glSides[side], this.ctex.handle, 0);
        },
        createDepthTarget: function (depthFormat, side) {
            var gl = this.context.gl;

            if (this.opt.depthAsRenderbuffer) {
                if (!this.dtex) this.dtex = [];
                this.dtex[side] = gl.createRenderbuffer();
                gl.bindRenderbuffer(gl.RENDERBUFFER, this.dtex[side]);
                gl.renderbufferStorage(gl.RENDERBUFFER, depthFormat, this.width, this.height);
                gl.bindRenderbuffer(gl.RENDERBUFFER, null);

                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.dtex[side]);
                if (!this.depthTarget) this.depthTarget = [];
                this.depthTarget[side] = {
                    handle: this.dtex[side],
                    isTexture: false
                }
            }
            else
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT0, this.glSides[side], this.dtex.handle, 0);
        },
        createStencilTarget: function (stencilFormat, side) {
            var gl = this.context.gl;

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, this.glSides[side], this.stex.handle, 0);
        },
        checkStatus: function (side) {
            var gl = this.context.gl;

            gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[side]);
            //Finalize framebuffer creation
            var fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

            switch (fbStatus) {
                case gl.FRAMEBUFFER_COMPLETE:
                    break;
                case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                    break;
                case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                    break;
                case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                    XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                    break;
                case gl.FRAMEBUFFER_UNSUPPORTED:
                    XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
                    break;
                default:
                    XML3D.debug.logError("Incomplete framebuffer: " + fbStatus);
            }

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            this.valid = (fbStatus == gl.FRAMEBUFFER_COMPLETE);
            return this.valid;
        },
        fillOptions: function (options) {
            var gl = this.context.gl;
            var opt = {
                wrapS: gl.CLAMP_TO_EDGE,
                wrapT: gl.CLAMP_TO_EDGE,
                minFilter: gl.NEAREST,
                magFilter: gl.NEAREST,
                depthMode: gl.LUMINANCE,
                depthCompareMode: gl.COMPARE_R_TO_TEXTURE,
                depthCompareFunc: gl.LEQUAL,
                colorsAsRenderbuffer: false,
                depthAsRenderbuffer: false,
                stencilAsRenderbuffer: false,
                isDepth: false
            };

            for (var item in options) {
                opt[item] = options[item];
            }

            return opt;
        },
        dispose: function () {
            if (this.framebuffers.length <= 0)
                return;

            var gl = this.context.gl;
            for(var side in this.framebuffers)
                gl.deleteFramebuffer(this.framebuffers[side]);

            if (this.colorTarget.handle !== null) {
                    this.colorTarget.handle.dispose();
            }
            if (this.depthTarget !== null) {
                this.depthTarget.handle.dispose();
            }
            if (this.stencilTarget !== null) {
                    this.stencilTarget.handle.dispose();
            }

            this.framebuffers = [];
        }
    });

module.exports = {
    GLCanvasTarget: GLCanvasTarget,
    GLRenderTarget: GLRenderTarget,
    GLScaledRenderTarget: GLScaledRenderTarget,
    GLCubeMapRenderTarget: GLCubeMapRenderTarget
};



},{}],117:[function(require,module,exports){
var utils = require("./utils.js");
var StateMachine = require("../../../contrib/state-machine.js");
var SamplerConfig = require("../../../xflow/interface/data.js").SamplerConfig;
var XC = require("../../../xflow/interface/constants.js");
var uniqueObjectId = utils.getUniqueCounter();

/**
 * @type {WebGLRenderingContext}
 */
var GL = require("../constants.js");

//noinspection JSValidateJSDoc
/**
 * @param {GLContext} context
 * @constructor
 */
var GLTexture = function (context) {
    SamplerConfig.call(this);

    /**
     * @type {GLContext}
     */
    this.context = context;

    /**
     * @type {number}
     */
    this.id = uniqueObjectId();

    /**
     * Unit the texture is currently bound to (or -1 if bound to no unit)
     * @type {number}
     */
    this.unit = -1;

    this.setDefaults();

    this.width = 0;
    this.height = 0;
    this.handle = null;

    this.textureType = context.gl.TEXTURE_2D;

    this.textureUnitCallback = this.lostTextureUnit.bind(this);
};

XML3D.createClass(GLTexture, SamplerConfig);

GLTexture.State = {
    NONE: "none", LOADING: "loading", READY: "ready", ERROR: "error"
};


var getOrCreateFallbackTexture = (function () {

    var c_fallbackTexture = null;

    return function (context) {
        if (!c_fallbackTexture) {
            c_fallbackTexture = new GLTexture(context);
            var size = 16;
            var texels = new Uint8Array(size * size * 3);
            for (var i = 0; i < texels.length; i++) {
                texels[i] = 128;
            }
            c_fallbackTexture.createTex2DFromData(GL.RGB, size, size, GL.RGB, GL.UNSIGNED_BYTE, {
                texels: texels, wrapS: GL.REPEAT, wrapT: GL.REPEAT, minFilter: GL.LINEAR, magFilter: GL.LINEAR
            });
        }
        return c_fallbackTexture;
    }
}());

var isPowerOfTwo = function (dimension) {
    return (dimension & (dimension - 1)) == 0;
};
var nextHighestPowerOfTwo = function (x) {
    --x;
    for (var i = 1; i < 32; i <<= 1) {
        x = x | x >> i;
    }
    return x + 1;
};

/**
 * Scale up the texture to the next highest power of two dimensions.
 * @returns {HTMLCanvasElement}
 */
var scaleImage = function (image, width, height) {
    /**
     * @type {HTMLCanvasElement}
     */
    var canvas = document.createElement("canvas");
    canvas.width = nextHighestPowerOfTwo(width);
    canvas.height = nextHighestPowerOfTwo(height);

    var context = canvas.getContext("2d");
    if (image instanceof HTMLElement) {
        context.drawImage(image, 0, 0, canvas.width, canvas.height);
    } else {
        var tmpCanvas = document.createElement("canvas");
        tmpCanvas.width = width;
        tmpCanvas.height = height;
        var tmpContext = tmpCanvas.getContext("2d");
        var imageData = tmpContext.createImageData(width, height);
        imageData.data.set(image.data);
        tmpContext.putImageData(imageData, 0, 0);

        context.drawImage(tmpCanvas, 0, 0, canvas.width, canvas.height);
    }

    return canvas;
};

var glTextureFormatFromXflow = function (format, gl) {
    switch (format) {
        case XC.TEXTURE_FORMAT.ALPHA:
            return gl.ALPHA;
        case XC.TEXTURE_FORMAT.RGB:
            return gl.RGB;
        case XC.TEXTURE_FORMAT.RGBA:
            return gl.RGBA;
        case XC.TEXTURE_FORMAT.LUMINANCE:
            return gl.LUMINANCE;
        case XC.TEXTURE_FORMAT.LUMINANCE_ALPHA:
            return gl.LUMINANCE_ALPHA;
        default:
            throw new Error("Unsupported Texture Format!");
    }
};

var glTextureTypeFromXflow = function (type, gl) {
    switch (type) {
        case XC.TEXTURE_TYPE.FLOAT:
            return gl.FLOAT;
        case XC.TEXTURE_TYPE.UBYTE:
            return gl.UNSIGNED_BYTE;
        case XC.TEXTURE_TYPE.USHORT_4_4_4_4:
            return gl.UNSIGNED_SHORT_4_4_4_4;
        case XC.TEXTURE_TYPE.USHORT_5_5_5_1:
            return gl.UNSIGNED_SHORT_5_5_5_1;
        case XC.TEXTURE_TYPE.USHORT_5_6_5:
            return gl.GL_UNSIGNED_SHORT_5_6_5;
        default:
            throw new Error("Unsupported Texture Type!");
    }
};

XML3D.extend(GLTexture.prototype, {
    /**
     * @param {Xflow.TextureEntry} textureEntry
     */
    updateFromTextureEntry: function (textureEntry) {
        if (!textureEntry.isLoading()) {
            this.set(textureEntry.getSamplerConfig());
            var img = textureEntry.asGLTextureValue();
            if (!img)
                return this.failed();
            this.createOrUpdateTexture(img);
        } else {
            this.loads();
        }
    }, /**
     * We need to scale texture when one of the wrap modes is not CLAMP_TO_EDGE and
     * one of the texture dimensions is not power of two.
     * Otherwise rendered texture will be just black.
     * @param {number} width
     * @param {number} height
     * @returns {boolean}
     */
    needsScale: function (width, height) {
        return (this.generateMipMap || this.wrapS != GL.CLAMP_TO_EDGE || this.wrapT != GL.CLAMP_TO_EDGE) && (!isPowerOfTwo(width) || !isPowerOfTwo(height))
    },


    _bind: function () {
        var gl = this.context.gl;
        var textureManager = this.context.textureManager;
        var unit = this.unit = textureManager.bind(this.id, { dispose: this.textureUnitCallback });
        if (unit == -2) {
            XML3D.debug.logError("All available texture units are full.");
        } else {
            gl.activeTexture(GL.TEXTURE0 + unit);
            gl.bindTexture(this.textureType, this.handle);
        }
        return unit;
    },

    unbind: function (unit) {
        // Do nothing, texture manager will handle this
    },

    destroy: function () {
        var gl = this.context.gl;
        var textureManager = this.context.textureManager;
        textureManager.dispose(this.id);
        gl.deleteTexture(this.handle);
    },

    canBind: function () {
        return this.current == GLTexture.State.READY;
    },

    createOrUpdateTexture: function (texelSource) {

        if (!this.handle) {
            this.handle = this.context.gl.createTexture();
        }

        this.updateTextureFromData(texelSource);
    },

    updateTextureFromData: function (texelSource) {
        var gl = this.context.gl;
        this._bind();

        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.flipY);
        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_S, this.wrapS);
        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_T, this.wrapT);
        gl.texParameteri(this.textureType, gl.TEXTURE_MIN_FILTER, this.minFilter);
        gl.texParameteri(this.textureType, gl.TEXTURE_MAG_FILTER, this.magFilter);

        var type = glTextureTypeFromXflow(texelSource.texelType, gl);
        var format = glTextureFormatFromXflow(texelSource.texelFormat, gl);

        var width = texelSource.width;
        this.width = width;
        var height = texelSource.height;
        this.height = height;

        if (this.generateMipMap && this.needsScale(width, height)) {
            if (type === gl.FLOAT)
                throw new Error("Should generate MipMaps but texture data is float and not power of two in size!");
            else
                texelSource = scaleImage(texelSource, width, height);
        }

        if (texelSource instanceof HTMLElement) {
            gl.texImage2D(gl.TEXTURE_2D, 0, format, format, type, texelSource);
        } else {
            if (texelSource.data instanceof Uint8ClampedArray) {
                // WebGL does not support Uint8ClampedArray, which is (correctly) used by async. Xflow. We just build a new view
                // on top of the underlying array buffer which should be relatively fast
                gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, new Uint8Array(texelSource.data.buffer));
            } else {
                gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, texelSource.data);
            }
        }

        if (this.generateMipMap)
            gl.generateMipmap(this.textureType);

        this.created();
    },

    createTex2DFromData: function (internalFormat, width, height, sourceFormat, sourceType, opt) {
        var gl = this.context.gl;

        var opt = opt || {};
        var texels = opt.texels;

        if (!texels) {
            if (sourceType == gl.FLOAT) {
                texels = new Float32Array(width * height * 4);
            } else {
                texels = new Uint8Array(width * height * 4);
            }
        }
        this.width = width;
        this.height = height;
        this.handle = gl.createTexture();
        this._bind();

        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, opt.flipY);
        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_S, opt.wrapS);
        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_T, opt.wrapT);
        gl.texParameteri(this.textureType, gl.TEXTURE_MIN_FILTER, opt.minFilter);
        gl.texParameteri(this.textureType, gl.TEXTURE_MAG_FILTER, opt.magFilter);

        if (!opt.isDepth) {
            if (texels instanceof Uint8ClampedArray) {
                gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, sourceFormat, sourceType, new Uint8Array(texels.buffer));
            } else {
                gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, sourceFormat, sourceType, texels);
            }
        } else {
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, sourceFormat, sourceType, null);
        }

        if (opt.generateMipmap) {
            gl.generateMipmap(this.textureType);
        }
        this.created();
    },

    lostTextureUnit: function() {
        this.unit = -1;
    }

});

StateMachine.create({
    target: GLTexture.prototype,
    initial: GLTexture.State.NONE,
    events: [{name: 'created', from: '*', to: GLTexture.State.READY}, {
        name: 'failed', from: '*', to: GLTexture.State.ERROR
    }, {name: 'loads', from: '*', to: GLTexture.State.LOADING}]
});

//noinspection JSValidateJSDoc
/**
 * @param {GLContext} context
 * @constructor
 */
var GLCubeMap = function (context) {
    GLTexture.call(this, context, context.gl.TEXTURE_CUBE_MAP);
    var gl = context.gl;
    this.textureType = context.gl.TEXTURE_CUBE_MAP;
    this.glSides = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];

};
XML3D.createClass(GLCubeMap, GLTexture, {
    updateTextureFromData: function (texelSource) {
        debug.log("updateTextureFromData not implemented for CubeMapping!");
    },

    createTex2DFromData: function (internalFormat, width, height, sourceFormat, sourceType, opt) {
        var gl = this.context.gl;

        var opt = opt || {};
        var texels = opt.texels;

        if (!texels) {
            if (sourceType == gl.FLOAT) {
                texels = new Float32Array(width * height * 4);
            } else {
                texels = new Uint8Array(width * height * 4);
            }
        }
        this.width = width;
        this.height = height;
        this.handle = gl.createTexture();
        this._bind();

        // gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_S, opt.wrapS);
        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_T, opt.wrapT);
        gl.texParameteri(this.textureType, gl.TEXTURE_MIN_FILTER, opt.minFilter);
        gl.texParameteri(this.textureType, gl.TEXTURE_MAG_FILTER, opt.magFilter);

        for(var i = 0; i < this.glSides.length; ++i) {
            if (!opt.isDepth) {
                if (texels instanceof Uint8ClampedArray) {
                    gl.texImage2D(this.glSides[i], 0, internalFormat, width, height, 0, sourceFormat, sourceType, new Uint8Array(texels.buffer));
                } else {
                    gl.texImage2D(this.glSides[i], 0, internalFormat, width, height, 0, sourceFormat, sourceType, texels);
                }
            } else {
                gl.texImage2D(this.glSides[i], 0, internalFormat, width, height, 0, sourceFormat, sourceType, null);
            }
        }

        if (opt.generateMipmap) {
            gl.generateMipmap(this.textureType);
        }
        this.created();
    }
});

GLCubeMap.State = {
    NONE: "none", LOADING: "loading", READY: "ready", ERROR: "error"
};

StateMachine.create({
    target: GLCubeMap.prototype,
    initial: GLCubeMap.State.NONE,
    events: [{name: 'created', from: '*', to: GLCubeMap.State.READY}, {
        name: 'failed', from: '*', to: GLCubeMap.State.ERROR
    }, {name: 'loads', from: '*', to: GLCubeMap.State.LOADING}]
});


module.exports = {
    GLTexture: GLTexture,
    GLCubeMap: GLCubeMap
};



},{"../../../contrib/state-machine.js":52,"../../../xflow/interface/constants.js":187,"../../../xflow/interface/data.js":188,"../constants.js":120,"./utils.js":118}],118:[function(require,module,exports){

module.exports = {
    /**
     * Set uniforms for active program
     * @param {WebGLRenderingContext} gl
     * @param u
     * @param value
     * @param {boolean=} transposed
     */
    setUniform: function (gl, u, value, transposed) {

        //noinspection FallthroughInSwitchStatementJS
        switch (u.glType) {
            case 35670: //gl.BOOL
                if (value && value.length !== undefined) {
                    // Transform a Unit8Array into a JS Array
                    gl.uniform1iv(u.location, Array.prototype.map.call(value, function(v) { return v; }));
                } else {
                    gl.uniform1i(u.location, value || 0);
                }
                break;
            case 5124:  //gl.INT
            case 35678: //gl.SAMPLER_2D
            case 35680: //gl.SAMPLER_CUBE
                if (value && value.length !== undefined) {
                    gl.uniform1iv(u.location, value);
                } else {
                    gl.uniform1i(u.location, value || 0);
                }
                break;

            case 35671: // gl.BOOL_VEC2
            case 35667:
                gl.uniform2iv(u.location, value);
                break; // gl.INT_VEC2

            case 35672: // gl.BOOL_VEC3
            case 35668:
                gl.uniform3iv(u.location, value);
                break; // gl.INT_VEC3

            case 35673: // gl.BOOL_VEC4
            case 35669:
                gl.uniform4iv(u.location, value);
                break; // gl.INT_VEC4

            case 5126:
                if (value.length != null)
                    gl.uniform1fv(u.location, value); else
                    gl.uniform1f(u.location, value);
                break; // gl.FLOAT
            case 35664:
                gl.uniform2fv(u.location, value);
                break; // gl.FLOAT_VEC2
            case 35665:
                gl.uniform3fv(u.location, value);
                break; // gl.FLOAT_VEC3
            case 35666:
                gl.uniform4fv(u.location, value);
                break; // gl.FLOAT_VEC4

            case 35674:
                gl.uniformMatrix2fv(u.location, transposed || false, value);
                break;// gl.FLOAT_MAT2
            case 35675:
                gl.uniformMatrix3fv(u.location, transposed || false, value);
                break;// gl.FLOAT_MAT3
            case 35676:
                gl.uniformMatrix4fv(u.location, transposed || false, value);
                break;// gl.FLOAT_MAT4

            default:
                XML3D.debug.logError("Unknown uniform type " + u.glType);
                break;
        }
    },

    getUniqueCounter: function () {
        var c_counter = 0;
        return function () {
            return c_counter++;
        }
    },

    checkError: function (gl, text) {
        var error = gl.getError();
        if (error !== gl.NO_ERROR) {
            var textErr = "" + error;
            switch (error) {
                case 1280:
                    textErr = "1280 ( GL_INVALID_ENUM )";
                    break;
                case 1281:
                    textErr = "1281 ( GL_INVALID_VALUE )";
                    break;
                case 1282:
                    textErr = "1282 ( GL_INVALID_OPERATION )";
                    break;
                case 1283:
                    textErr = "1283 ( GL_STACK_OVERFLOW )";
                    break;
                case 1284:
                    textErr = "1284 ( GL_STACK_UNDERFLOW )";
                    break;
                case 1285:
                    textErr = "1285 ( GL_OUT_OF_MEMORY )";
                    break;
            }
            var msg = "GL error " + textErr + " occured.";
            if (text !== undefined)
                msg += " " + text;
            XML3D.debug.trace(msg);
        }
    },

    supported: function () {
        var canvas = document.createElement("canvas");
        try {
            return !!(window.WebGLRenderingContext && (canvas.getContext('experimental-webgl')));
        } catch (e) {
            return false;
        }
    }

};


},{}],119:[function(require,module,exports){
var AbstractCanvasHandler = require("../renderer/canvas-handler.js");
var Options = require("../../utils/options.js");
var Util = require("../../utils/misc.js");

var MAXFPS = 30;

var OPTION_CONTINUOUS = "renderer-continuous";
Options.register(OPTION_CONTINUOUS, false);

/**
 * GLCanvasHandler class.
 * Registers and handles the events that happen on the canvas element.
 *
 * @param xml3dElem
 *            the root xml3d node, containing the XML3D scene structure
 * @constructor
 * @extends AbstractCanvasHandler
 */
function GLCanvasHandler(xml3dElem, canvas) {
    AbstractCanvasHandler.call(this, xml3dElem, canvas);
    this.renderInterface = {};

    this.lastPickObj = null;

    // Initialized later
    this.lastKnownDimensions = {width: 0, height: 0};

    this.initialize();
}

XML3D.createClass(GLCanvasHandler, AbstractCanvasHandler);

GLCanvasHandler.prototype.setRenderer = function (renderer) {
    this.renderer = renderer;
};

GLCanvasHandler.prototype.initialize = function () {
     this.configureCanvas();

    // This function is called at regular intervals by requestAnimationFrame to
    // determine if a redraw
    // is needed
    var that = this;
    this.tick = function () {

        if(!that.renderer)
            return;

        XML3D.updateXflowObserver();
        XML3D.flushDOMChanges();

        if (that.canvasSizeChanged() || that.renderer.needsRedraw() || Options.getValue(OPTION_CONTINUOUS)) {
            that.draw();
        }

        window.requestAnimationFrame(that.tick, MAXFPS);
    };

      // Block the right-click context menu on the canvas unless it's explicitly toggled
    var cm = this._xml3dElement.getAttribute("contextmenu");
    if (!cm || cm == "false") {
        this._canvas.addEventListener("contextmenu", function (e) {
            e.preventDefault && e.preventDefault();
            e.stopPropagation && e.stopPropagation();
        }, false);
    }
};

GLCanvasHandler.prototype.configureCanvas = function () {
    var xml3dElement = this._xml3dElement;
    var canvas = this._canvas;

    var parent = xml3dElement.parentNode;
    if (!Util.elementIs(parent, "div") || parent.getAttribute("class") !== "_xml3d_hideDiv") {
        // Place xml3dElement inside an invisble div
        var hideDiv = parent.ownerDocument.createElement('div');
        hideDiv.setAttribute("class", "_xml3d_hideDiv");
        //hideDiv.style.display = "none";
        parent.insertBefore(hideDiv, xml3dElement);
        hideDiv.appendChild(xml3dElement);

        // Create canvas and append it where the xml3d element was before
        parent.insertBefore(canvas, hideDiv);
    } else {
        // The invisible div already exists (probably from an earlier configuration)
        parent.parentNode.insertBefore(canvas, parent);
    }

    var style = canvas.ownerDocument.defaultView.getComputedStyle(xml3dElement);
    if (!canvas.style.backgroundColor) {
        var bgcolor = style.getPropertyValue("background-color");
        if (bgcolor && bgcolor != "transparent")
            canvas.style.backgroundColor = bgcolor;
    }
    // Need to be set for correct canvas size
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    this.lastKnownDimensions = {width: canvas.width, height: canvas.height};
    return canvas;
};

/**
 * Binds the picking buffer and passes the request for a picking pass to the
 * renderer
 *
 * @param {number} canvasX
 * @param {number} canvasY
 * @return {Drawable|null} newly picked object
 */
GLCanvasHandler.prototype.getPickObjectByPoint = function (canvasX, canvasY) {
    // TODO
    //if (!this.renderOptions.pickingEnabled)
    //    return null;
    return this.renderer.getRenderObjectFromPickingBuffer(canvasX, canvasY);
};

/**
 *
 * @returns {HTMLElement}
 */
GLCanvasHandler.prototype.getPickedObject = function() {
    return this.renderer.pickedObject ? this.renderer.pickedObject.node : null;
};

/**
 * @param {number} canvasX
 * @param {number} canvasY
 * @return {vec3|null} The world space normal on the object's surface at the given coordinates
 */
GLCanvasHandler.prototype.getWorldSpaceNormalByPoint = function (canvasX, canvasY) {
    return this.renderer.getWorldSpaceNormalByPoint(canvasX, canvasY);
};

/**
 * @param {number} canvasX
 * @param {number} canvasY
 * @return {vec3|null} The world space position on the object's surface at the given coordinates
 */
GLCanvasHandler.prototype.getWorldSpacePositionByPoint = function (canvasX, canvasY) {
    return this.renderer.getWorldSpacePositionByPoint(canvasX, canvasY);
};

GLCanvasHandler.prototype.canvasSizeChanged = function () {
    var canvas = this._canvas;
    if (canvas.clientWidth !== this.lastKnownDimensions.width || canvas.clientHeight !== this.lastKnownDimensions.height) {

        this.lastKnownDimensions.width = canvas.width = canvas.clientWidth;
        this.lastKnownDimensions.height = canvas.height = canvas.clientHeight;
        this.renderer.handleResizeEvent(canvas.width, canvas.height);
        this.dispatchResizeEvent({width: canvas.width, height: canvas.height});
        return true;
    }
    return false;
};

var c_timer = window.performance || Date;

/**
 * Called by tick() to redraw the scene if needed
 */
GLCanvasHandler.prototype.draw = function () {
    XML3D.flushDOMChanges();
    try {
        var start = c_timer.now();
        var stats = this.renderer.renderToCanvas();
        var end = c_timer.now();


        var factory = XML3D.xml3dFormatHandler.getFactory("scene", this.id);
        var xml3dAdapter = factory.getAdapter(this._xml3dElement);
        xml3dAdapter.onFrameDrawn();
        this.dispatchFrameDrawnEvent(start, end, stats);

    } catch (e) {
         // Avoid endless rendering due to error. Without a change, the renderer will not get back into normal operation
        this.renderer.needsDraw = false;
        XML3D.debug.logException(e);
    }

};

GLCanvasHandler.prototype.getMousePosition = function (evt) {
    var rct = this._canvas.getBoundingClientRect();
    return {
        x: (evt.clientX - rct.left), y: (evt.clientY - rct.top)
    };
};

GLCanvasHandler.prototype.destroy = function() {
    this.renderer.dispose();
    this.renderer = null;
};

module.exports =  GLCanvasHandler;


},{"../../utils/misc.js":182,"../../utils/options.js":183,"../renderer/canvas-handler.js":90}],120:[function(require,module,exports){
// 01.10.2015: Workaround for Safari bug on iOS 9 (https://bugs.webkit.org/show_bug.cgi?id=148449)
module.exports = WebGLRenderingContext.ONE ? WebGLRenderingContext : WebGLRenderingContext.prototype;

},{}],121:[function(require,module,exports){
var GLProgramObject = require("../base/program.js");
var XflowUtils= require("../xflow/utils.js");

/**
 * A ShaderClosure connects a mesh-specific GLProgram with it's Xflow data
 * @param {GLContext} context
 * @constructor
 */
var AbstractShaderClosure = function (context) {
    /**
     * @private
     * @type {GLProgramObject|null}
     */
    this.program = null;
    this.context = context;
    /**
     * A flag used by shadercomposer to sort out obsolete shaderclosures
     * @type {boolean}
     */
    this.obsolete = false;
    this.id = "";

    this.uniformCollection = {
        envBase: {}, envOverride: null, sysBase: null
    };

    /**
     * Stores, if the underlying shader has semi-transparencies
     * and thus needs to considered for alpha-blending
     * @type {boolean}
     */
    this.isTransparent = false;

    /**
     * The source of a shader
     * @private
     * @type {{vertex: string, fragment: string}}
     */
    this.source = {
        vertex: "", fragment: ""
    }
};

Object.defineProperties(AbstractShaderClosure.prototype, {
        attributes: {
            writeable: false, get: function () {
                return this.program ? this.program.attributes : {}
            }
        }, uniforms: {
            writeable: false, get: function () {
                return this.program ? this.program.uniforms : {}
            }
        }, samplers: {
            writeable: false, get: function () {
                return this.program ? this.program.samplers : {}
            }
        }
    });
XML3D.createClass(AbstractShaderClosure, null, {

    equals: function (that) {
        return this.source.vertex === that.source.vertex && this.source.fragment === that.source.fragment;
    },

    hasTransparency: function () {
        return this.isTransparent;
    },

    compile: function () {
        if (!this.source.fragment || !this.source.vertex) {
            XML3D.debug.logError("No source found for material", this);
            return;
        }

        var programObject = new GLProgramObject(this.context.gl, this.source);
        this.program = programObject;
        this.id = programObject.id;
    },

    bind: function () {
        this.program.bind();
    },

    unbind: function () {
        this.program.unbind();
    },

    isValid: function () {
        return this.program.isValid();
    },

    /**
     * @param {Xflow.ComputeResult} xflowResult
     */
    updateUniformsFromComputeResult: function (xflowResult) {
        var map = xflowResult.getOutputMap();

        var envBase = this.uniformCollection.envBase = {};
        this.setDefaultUniforms(this.uniformCollection.envBase);

        for (var name in map) {
            envBase[name] = XflowUtils.getGLUniformValueFromXflowDataEntry(map[name], this.context);
        }
        var names = Object.keys(envBase);
        this.setUniformVariables(names, null, this.uniformCollection);

        this.isTransparent = this.getTransparencyFromInputData(map);
    },

    setUniformVariables: function (envNames, sysNames, uniformCollection) {
        this.program.setUniformVariables(envNames, sysNames, uniformCollection);
    },

    setSystemUniformVariables: function (sysNames, sysValues) {
        this.uniformCollection.sysBase = sysValues;
        this.setUniformVariables(null, sysNames, this.uniformCollection);
    },

    changeUniformVariableOverride: function (prevOverride, newOverride) {
        var overrideNames = prevOverride ? Object.keys(prevOverride) : [];
        if (newOverride) overrideNames.push.apply(overrideNames, Object.keys(newOverride));
        this.uniformCollection.envOverride = newOverride;
        this.setUniformVariables(overrideNames, null, this.uniformCollection);
    }
});

module.exports = AbstractShaderClosure;


},{"../base/program.js":115,"../xflow/utils.js":159}],122:[function(require,module,exports){
var GLScene = require("../scene/glscene.js");
var GLLights = require("../scene/gllights.js");
var MaterialEvents = require("../materials/events.js");
var EventEmitter = require("events").EventEmitter;
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;
var XC = require("../../../xflow/interface/constants.js");

/**
 * @interface
 */
var IShaderComposer = function () {
};

/**
 * @enum
 */
IShaderComposer.UpdateState = {
    SHADER_UPDATED: 1, SHADER_COMPILED: 2, SHADER_UNCHANGED: 3
};

IShaderComposer.State = {
    OK: 1, NO_SCRIPT: 2, NO_PROGRAM: 3
};

/**
 * @param {scene} scene
 * @param {{}=} opt
 */
IShaderComposer.prototype.update = function (scene, opt) {
};

/**
 *
 * @returns AbstractShaderClosure|null
 */
IShaderComposer.prototype.getShaderClosure = function (scene) {
    return null;
};

/**
 * @returns {Array.<string>}
 */
IShaderComposer.prototype.getRequestFields = function () {
    return [];
};

/**
 * @returns {{}}
 */
IShaderComposer.prototype.getShaderAttributes = function () {
    return {};
};

/**
 * @constructor
 * @extends EventEmitter
 */
var AbstractShaderComposer = function (context, shaderInfo) {
    EventEmitter.call(this);
    this.context = context;
    this.shaderClosures = [];
    this.dataChanged = false;
    this.updateLightValues = false;
    this.request = null;
    this.setMaxListeners(0);
};

XML3D.createClass(AbstractShaderComposer, EventEmitter, {

    // Implemented by subclass
    setShaderInfo: null,


    updateRequest: function (xflowDataNode) {
        if (this.request) this.request.clear();

        this.request = new ComputeRequest(xflowDataNode, this.getRequestFields(), this.onShaderRequestChange.bind(this));
        this.setShaderRecompile();
    },

    onShaderInfoChanged: function (shaderInfo) {
        this.setShaderInfo(shaderInfo);
        this.setShaderRecompile();
        this.context.requestRedraw("Material model changed");
    },

    onShaderRequestChange: function (request, changeType) {
        this.dataChanged = true;
        if (changeType == XC.RESULT_STATE.CHANGED_STRUCTURE)
            this.setShaderRecompile();
        this.context.requestRedraw("Material data changed");
    },

    /**
     * @param {Scene} scene
     * @param {{}=} opt
     */
    update: function (scene, opt) {
        opt = opt || {};
        var that = this;

        // Clean up shaderClosures that are not used!
        var i = this.shaderClosures.length;
        while (i--) {
            if (this.shaderClosures[i].obsolete) this.shaderClosures.splice(i, 1);
        }

        if (!this.shaderClosures.length)
            return;

        if (this.dataChanged) {
            var result = this.getShaderDataResult();
            this.shaderClosures.forEach(function (shader) {
                that.updateClosureFromComputeResult(shader, result);
            });
            this.dataChanged = false;
        }

        if (this.updateLightValues) {
            this.shaderClosures.forEach(function (shader) {
                that.updateClosureFromLightParameters(shader, scene);
            });
        }
    },

    /**
     * @param {AbstractShaderClosure} shaderClosure
     * @param {Xflow.ComputeResult} result
     */
    updateClosureFromComputeResult: function (shaderClosure, result) {
        if (!result || !result.getOutputMap) {
            return;
        }
        shaderClosure.bind();
        shaderClosure.updateUniformsFromComputeResult(result);
    },

    updateClosureFromLightParameters: function (shaderClosure, scene) {
        shaderClosure.bind();
        shaderClosure.setSystemUniformVariables(GLLights.ALL_PARAMETERS, scene.systemUniforms);
    },

    updateSystemUniforms: function (names, scene) {
        this.shaderClosures.forEach(function (shader) {
            shader.bind();
            shader.setSystemUniformVariables(names, scene.systemUniforms);
        });
    },


    createShaderClosure: function () {
        throw new Error("AbstractComposer::createShaderClosure needs to be overridden");
    },

    createObjectDataRequest: function (objectDataNode, callback) {
        throw new Error("AbstractComposer::createObjectDataRequest needs to be overridden");
    },

    distributeObjectShaderData: function (objectRequest, attributeCallback, uniformCallback) {
        throw new Error("AbstractComposer::distributeObjectShaderData needs to be overridden");
    },

    getShaderClosure: function (scene, vsRequest) {
        var shader = this.createShaderClosure();

        try {
            shader.createSources(scene, this.getShaderDataResult(), vsRequest)
        } catch (e) {
            throw new Error("Shader: " + e.message)
        }

        for (var i = 0; i < this.shaderClosures.length; i++) {
            if (this.shaderClosures[i].equals(shader)) {
                this.shaderClosures[i].obsolete = false;
                return this.shaderClosures[i];
            }
        }

        this.initializeShaderClosure(shader, scene);
        return shader;
    },

    initializeShaderClosure: function (shaderClosure, scene) {
        shaderClosure.compile();

        scene.emit(MaterialEvents.MATERIAL_INITIALIZED);
        this.updateClosureFromComputeResult(shaderClosure, this.getShaderDataResult());
        this.updateClosureFromLightParameters(shaderClosure, scene);
        this.shaderClosures.push(shaderClosure);
    },

    setShaderRecompile: function () {

        for (var i = 0; i < this.shaderClosures.length; ++i) {
            this.shaderClosures[i].obsolete = true;
        }
        this.emit(MaterialEvents.MATERIAL_STRUCTURE_CHANGED);
        this.dataChanged = true;
        this.updateLightValues = true;
    },


    /**
     * @returns {Xflow.ComputeResult|null}
     */
    getShaderDataResult: function () {
        return this.request ? this.request.getResult() : null;
    }


});


/**
 * @implements IShaderComposer
 * @constructor
 */
var DefaultComposer = function (context) {
    this.context = context;
};
XML3D.createClass(DefaultComposer, AbstractShaderComposer, {
    update: function () {
    },

    getShaderClosure: function (scene, vsRequest) {
        return this.context.programFactory.getFallbackProgram();
    },

    getShaderAttributes: function () {
        return {color: null, normal: null /* for picking */};
    },

    getRequestFields: function () {
        return ["diffuseColor", "useVertexColor"];
    },

    createObjectDataRequest: function (objectDataNode, callback) {
        return new ComputeRequest(objectDataNode, ["position", "color", "normal", "diffuseColor", "useVertexColor"], callback);
    },

    distributeObjectShaderData: function (objectRequest, attributeCallback, uniformCallback) {
        var result = objectRequest.getResult();

        var dataMap = result.getOutputMap(), requestFields = this.getRequestFields();
        for (var name in dataMap) {
            if (requestFields.indexOf(name) != -1)
                uniformCallback(name, dataMap[name]); else
                attributeCallback(name, dataMap[name]);
        }
    }
});


module.exports = {
    AbstractShaderComposer: AbstractShaderComposer,
    DefaultComposer: DefaultComposer
}


},{"../../../xflow/interface/constants.js":187,"../../../xflow/interface/request.js":190,"../materials/events.js":123,"../scene/gllights.js":154,"../scene/glscene.js":155,"events":12}],123:[function(require,module,exports){
module.exports = {
    MATERIAL_STRUCTURE_CHANGED: "material_structure_changed",
    MATERIAL_INITIALIZED: "material_initialized"
};

},{}],124:[function(require,module,exports){
var AbstractShaderClosure = require("./../abstractshaderclosure.js");
var JSShaderComposer = require("./jsshadercomposer.js");
var SystemNotifier = require("../../system/system-notifier.js");
var getJSSystemConfiguration = require("./jssystemconfiguration.js");
var XC = require("../../../../xflow/interface/constants.js");
var Options = require("../../../../utils/options.js");


var c_jsShaderCache = {};


function convertEnvName(name) {
    return ("_env_" + name).replace(/_+/g, "_");
}

function addDefaultChanneling(vsConfig, inputName) {
    var outputName = convertEnvName(inputName);
    vsConfig.channelAttribute(inputName, outputName, null);
}


function channelVsAttribute(vsConfig, inputName, spaceInfo) {
    if (!spaceInfo || !spaceInfo[inputName]) {
        addDefaultChanneling(vsConfig, inputName);
        return;
    }

    var i = spaceInfo[inputName].length;
    while (i--) {
        var entry = spaceInfo[inputName][i];
        var outputName = convertEnvName(entry.name), code = null;
        switch (entry.space) {
            case Shade.SPACE_VECTOR_TYPES.OBJECT:
                break;
            case Shade.SPACE_VECTOR_TYPES.VIEW_POINT:
                vsConfig.addInputParameter(XC.DATA_TYPE.FLOAT4X4, "modelViewMatrix", true);
                code = outputName + " = ( modelViewMatrix * vec4(#I{" + inputName + "}, 1.0) ).xyz;";
                break;
            case Shade.SPACE_VECTOR_TYPES.VIEW_NORMAL:
                vsConfig.addInputParameter(XC.DATA_TYPE.FLOAT3X3, "modelViewMatrixN", true);
                code = outputName + " = normalize( modelViewMatrixN * #I{" + inputName + "} );";
                break;
            case Shade.SPACE_VECTOR_TYPES.WORLD_POINT:
                vsConfig.addInputParameter(XC.DATA_TYPE.FLOAT4X4, "modelMatrix", true);
                code = outputName + " = ( modelMatrix * vec4(#I{" + inputName + "}, 1.0) ).xyz;";
                break;
            case Shade.SPACE_VECTOR_TYPES.WORLD_NORMAL:
                vsConfig.addInputParameter(XC.DATA_TYPE.FLOAT3X3, "modelMatrixN", true);
                code = outputName + " = normalize( modelMatrixN * #I{" + inputName + "} );";
                break;
            default:
                throw new Error("Can't handle Space Type: " + entry.space);
        }
        vsConfig.channelAttribute(inputName, outputName, code);
    }
}


/**
 * @param {XC.DATA_TYPE} xflowType
 */
var convertXflow2ShadeType = function (xflowType, source) {
    var result = {}
    switch (xflowType) {
        case XC.DATA_TYPE.BOOL:
            result.type = Shade.TYPES.BOOLEAN;
            break;
        case XC.DATA_TYPE.INT:
            result.type = Shade.TYPES.INT;
            break;
        case XC.DATA_TYPE.FLOAT:
            result.type = Shade.TYPES.NUMBER;
            break;
        case XC.DATA_TYPE.FLOAT2:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.FLOAT2;
            break;
        case XC.DATA_TYPE.FLOAT3:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.FLOAT3;
            break;
        case XC.DATA_TYPE.FLOAT4:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.FLOAT4;
            break;
        case XC.DATA_TYPE.FLOAT3X3:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.MATRIX3;
            break;
        case XC.DATA_TYPE.FLOAT4X4:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.MATRIX4;
            break;
        case XC.DATA_TYPE.TEXTURE:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.TEXTURE;
            break;
        case XC.DATA_TYPE.UNKNOWN:
        default:
            throw new Error("Unknown Xflow DataType: " + xflowType);
    }
    result.source = source;
    return result;
}

/**
 * @param context
 * @param sourceTemplate
 * @param dataCallback
 * @constructor
 */
var JSShaderClosure = function (context, sourceTemplate, extractedParams) {
    AbstractShaderClosure.call(this, context);
    this.sourceTemplate = sourceTemplate;
    this.extractedParams = extractedParams;
    this.uniformSetter = function () {
    };
    this.uniformConverter = [];
};

XML3D.createClass(JSShaderClosure, AbstractShaderClosure, {
    /**
     *
     * @param {GLScene} scene
     * @param {Xflow.ComputeResult} shaderResult
     * @param objectData
     */
    createSources: function (scene, shaderResult, vsRequest) {

        var vsDataResult = vsRequest.getResult();

        var systemParameters = getSystemParameters(this.context, scene.systemUniforms);
        var environmentParameters = {};



        var shaderEntries = shaderResult && shaderResult.getOutputMap(), vsShaderOutput = vsDataResult && vsDataResult.outputNames;

        for (var i = 0; i < this.extractedParams.length; ++i) {
            var paramName = this.extractedParams[i];
            if (vsShaderOutput && vsShaderOutput.indexOf(paramName) != -1) {
                environmentParameters[paramName] = convertXflow2ShadeType(vsDataResult.getOutputType(paramName), vsDataResult.isOutputUniform(paramName) ? Shade.SOURCES.UNIFORM : Shade.SOURCES.VERTEX);
            } else if (shaderEntries && shaderEntries[paramName]) {
                environmentParameters[paramName] = convertXflow2ShadeType(shaderEntries[paramName].type, Shade.SOURCES.UNIFORM);
            }
        }

        var contextData = {
            "this": { "type": "object", "kind": "any", "info": systemParameters },
            "global.shade": [{"extra": {"type": "object", "kind": "any", "global": true, "info": environmentParameters }}]
        };

        XML3D.debug.logDebug("CONTEXT:", contextData);

        var options = {
            propagateConstants: true,
            validate: true,
            sanitize: true,
            transformSpaces: Options.getValue("shadejs-transformSpaces"),
            extractUniformExpressions: Options.getValue("shadejs-extractUniformExpressions")
        };
        var compileOptions = {
            useStatic: true, uniformExpressions: options.uniformExpressions
        };
        var implementation = scene.deferred ? "xml3d-glsl-deferred" : "xml3d-glsl-forward";

        var jsShaderKey = implementation + ";" + JSON.stringify(options) + ";" + JSON.stringify(environmentParameters) + ";" + this.sourceTemplate;

        var cacheEntry;
        if (!(cacheEntry = c_jsShaderCache[jsShaderKey])) {
            try {
                var workSet = new Shade.WorkingSet();
                workSet.parse(this.sourceTemplate, {loc: true});
                workSet.analyze(contextData, implementation, options);
                var spaceInfo = workSet.getProcessingData('spaceInfo');
                var glslShader = workSet.compileFragmentShader(compileOptions);

                cacheEntry = {
                    source: glslShader.source, uniformSetter: glslShader.uniformSetter, spaceInfo: spaceInfo
                };
                cacheEntry.hasTransparentShaderClosure = workSet.getProcessingData("isTransparent");

                this.uniformSetter = glslShader.uniformSetter;
                this.source = {
                    fragment: glslShader.source, vertex: this.createVertexShader(vsRequest, vsDataResult, spaceInfo)
                }

                if (scene.deferred) {
                    cacheEntry.signatures = workSet.getProcessingData("colorClosureSignatures");
                }
                if (Options.getValue("shadejs-cache"))
                    c_jsShaderCache[jsShaderKey] = cacheEntry;
            } catch (e) {
                SystemNotifier.sendEvent('shadejs', {
                    shadejsType: "error", event: e, code: this.sourceTemplate
                });

                var errorMessage = "Shade.js Compile Error:\n" + e.message + "\n------------\n" + "Shader Source:" + "\n------------\n" + XML3D.debug.formatSourceCode(this.sourceTemplate);
                throw new Error(errorMessage);
            }
        }
        this.source = {
            fragment: cacheEntry.source, vertex: this.createVertexShader(vsRequest, vsDataResult, cacheEntry.spaceInfo)
        };
        this.hasTransparentShaderClosure = cacheEntry.hasTransparentShaderClosure;

        this.uniformSetter = cacheEntry.uniformSetter;
        if (scene.deferred) {
            scene.colorClosureSignatures.push.apply(scene.colorClosureSignatures, cacheEntry.signatures);
        }

        // TODO: Handle errors.
        XML3D.debug.logDebug(this.source.vertex);
        XML3D.debug.logDebug(this.source.fragment);

        SystemNotifier.sendEvent('shadejs', {
            shadejsType: "success", vertexShader: this.source.vertex, fragmentShader: this.source.fragment
        });

        return true;
    },

    createVertexShader: function (vsRequest, vsDataResult, spaceInfo) {
        var vsConfig = vsRequest.getConfig();
        var names = vsDataResult.outputNames;
        for (var i = 0; i < names.length; ++i) {
            channelVsAttribute(vsConfig, names[i], spaceInfo);
        }
        vsConfig.addInputParameter(XC.DATA_TYPE.FLOAT4X4, "modelViewProjectionMatrix", true);
        vsConfig.addCodeFragment("gl_Position = modelViewProjectionMatrix * vec4(#I{position}, 1.0);");
        return vsRequest.getVertexShader().getGLSLCode();
    },

    setUniformVariables: function (envNames, sysNames, inputCollection) {
        this.uniformSetter(envNames, sysNames, inputCollection, this.program.setUniformVariable.bind(this.program));
    },

    getTransparencyFromInputData: function (dataMap) {
        // TODO: Compute Transparency
        return this.hasTransparentShaderClosure;
    },

    /* Default values are compiled into shade.js */
    setDefaultUniforms: function () {
    }

});

/**
 * @param {GLContext} context
 * @param {{}} globals
 * @returns {{}}
 */
function getSystemParameters(context, globals) {
    var result = getJSSystemConfiguration(context);

    // Update light parameters which vary in their size depending on number of lights defined
    ["point", "directional", "spot"].forEach(function(model) {
        var on = model + "LightOn";
        result["MAX_" + model.toUpperCase() + "LIGHTS"].staticValue = globals[on] && globals[on].length;
    });

    for (var global in globals) {
        var entry = result[global];
        if(entry && entry.staticSize) {
            var aLength = globals[global].length;
            if (aLength) {
                var tupleSize = getTupleSize(entry);
                entry.staticSize = aLength / tupleSize;
            } else {
                // Do not allow a array of size 0, remove entry instead
                // TODO(ksons): Remove once we can check array size in shade.js
                delete result[global];
            }
        }

    }
    return result;
}

/**
 * @param {{}} desc Object type descriptor
 * @returns {number}
 */
function getTupleSize(desc) {
    if(desc.type == "array") {
        var elements = desc.elements;
        if (elements.type == "object") {
            switch(elements.kind) {
                case "texture":
                case "float": return 1;
                case "float2": return 2;
                case "float3": return 3;
                case "float4": return 4;
                case "matrix4": return 16;
                default: throw ("Unknown array element kind:" + elements.kind);
            }
        }
    }
    return 1;
}

module.exports = JSShaderClosure;


},{"../../../../utils/options.js":183,"../../../../xflow/interface/constants.js":187,"../../system/system-notifier.js":158,"./../abstractshaderclosure.js":121,"./jsshadercomposer.js":125,"./jssystemconfiguration.js":126}],125:[function(require,module,exports){
var AbstractShaderComposer = require("./../abstractshadercomposer.js").AbstractShaderComposer;
var JSShaderClosure = require("./jsshaderclosure.js");
var VSConfig = require("../../../../xflow/processing/vs-connect.js").VSConfig;
var VertexShaderRequest = require("../../../../xflow/interface/request.js").VertexShaderRequest;
var XC = require("../../../../xflow/interface/constants.js");

/**
 *
 * @param {GLContext} context
 * @param {MaterialConfiguration} config
 * @extends AbstractShaderComposer
 * @constructor
 */
var JSShaderComposer = function (context, config) {
    AbstractShaderComposer.call(this, context, config);

    if (!window.Shade)
        throw new Error("shade.js library not found");

    this.context = context;

    /** @type string*/
    this.sourceTemplate = config.model.script;

    /**
     * @private
     * @type {Array.<string>}
     */
    this.extractedParams = [];

    /**
     * @private
     * @type {Xflow.ComputeRequest|null}
     */
    this.request = null;

    this.setShaderInfo(config);
};

JSShaderComposer.convertSysName = function (name) {
    return name;
};

XML3D.createClass(JSShaderComposer, AbstractShaderComposer, {
    setShaderInfo: function (config) {
        try {
            var ast = Shade.parse(this.sourceTemplate, {loc: true});
            this.extractedParams = Shade.extractParameters(ast, {implementation: "xml3d-glsl-forward"}).shaderParameters;
            // FIXME: Shader.js should always request position (in case
        } catch (e) {
            // We ignore errors here. They will reoccur when updating connected mesh closures
            this.extractedParams = [];
        }
        if (this.extractedParams.indexOf("position") == -1) this.extractedParams.push("position");

        // The composer is interested in changes of all possible shader parameters (extracted)
        // the instances (closures) will only set those, that occur in the instance
        if (this.extractedParams.length) {
            this.updateRequest(config.dataNode);
        }
    },

    getRequestFields: function () {
        return this.extractedParams;
    },

    getShaderAttributes: function () {
        return {color: null, normal: null, texcoord: null};
    },

    createShaderClosure: function () {
        return new JSShaderClosure(this.context, this.sourceTemplate, this.extractedParams);
    },

    createObjectDataRequest: function (objectDataNode, callback) {

        var vsConfig = new VSConfig();
        var names = this.extractedParams.slice();
        //if(names.indexOf("position") == -1) names.push("position");
        vsConfig.addAttribute(XC.DATA_TYPE.FLOAT3, "position", true);
        for (var i = 0; i < names.length; ++i) {
            var name = names[i];
            if (name == "position") continue;
            var xflowInfo = objectDataNode.getOutputChannelInfo(name);
            if (xflowInfo) {
                vsConfig.addAttribute(xflowInfo.type, name, true);
            }
        }
        return new VertexShaderRequest(objectDataNode, vsConfig, callback);
    },

    distributeObjectShaderData: function (objectRequest, attributeCallback, uniformCallback) {
        var vertexShader = objectRequest.getVertexShader();
        var inputNames = vertexShader.inputNames;
        var i, name, entry;

        for (i = 0; i < inputNames.length; ++i) {
            name = inputNames[i];
            entry = vertexShader.getInputData(name);
            if (vertexShader.isInputUniform(name))
                uniformCallback(name, entry); else
                attributeCallback(name, entry);
        }
        var outputNames = vertexShader.outputNames;
        for (i = 0; i < outputNames.length; ++i) {
            name = outputNames[i];
            if (vertexShader.isOutputFragmentUniform(name)) {
                uniformCallback(vertexShader.getOutputSourceName(name), vertexShader.getUniformOutputData(name));
            }
        }
    }

});


module.exports = JSShaderComposer;



},{"../../../../xflow/interface/constants.js":187,"../../../../xflow/interface/request.js":190,"../../../../xflow/processing/vs-connect.js":237,"./../abstractshadercomposer.js":122,"./jsshaderclosure.js":124}],126:[function(require,module,exports){
var GLContext = require("../../base/context.js");
var singleton = null;

var SYSTEM_CONTEXT_TEMPLATE =  {
        "coords": {"type": "object", "kind": "float3", "source": "uniform"},
        "cameraPosition": {"type": "object", "kind": "float3", "source": "uniform"},
        "viewMatrix": {"type": "object", "kind": "matrix4", "source": "uniform"},
        "viewInverseMatrix": {"type": "object", "kind": "matrix4", "source": "uniform"},
        "modelMatrix": {"type": "object", "kind": "matrix4", "source": "uniform"},
        "modelViewMatrix": {"type": "object", "kind": "matrix4", "source": "uniform"},
        "modelViewProjectionMatrix": {"type": "object", "kind": "matrix4", "source": "uniform"},
        "modelMatrixN": {"type": "object", "kind": "matrix3", "source": "uniform"},
        "modelViewMatrixN": {"type": "object", "kind": "matrix3", "source": "uniform"},

        "MAX_POINTLIGHTS": {"type": "int", "source": "constant", "staticValue": 5},
        "pointLightOn": {"type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"},
        "pointLightAttenuation": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightIntensity": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightPosition": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightCastShadow": {
            "type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightShadowBias": {
            "type": "array", "elements": {"type": "number"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightShadowMap": {
            "type": "array", "elements": {"type": "object", "kind": "texture"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightMatrix": {
            "type": "array",
            "elements": {"type": "object", "kind": "matrix4"},
            "staticSize": 5,
            "source": "uniform"
        },
        "pointLightProjection": {
            "type": "array",
            "elements": {"type": "object", "kind": "matrix4"},
            "staticSize": 5,
            "source": "uniform"
        },
        "pointLightNearFar": {
            "type": "array",
            "elements": {"type": "object", "kind": "float2"},
            "staticSize": 5,
            "source": "uniform"
        },

        "MAX_DIRECTIONALLIGHTS": {"type": "int", "source": "constant", "staticValue": 5},
        "directionalLightOn": {"type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"},
        "directionalLightIntensity": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "directionalLightDirection": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "directionalLightCastShadow": {
            "type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"
        },
        "directionalLightShadowBias": {
            "type": "array", "elements": {"type": "number"}, "staticSize": 5, "source": "uniform"
        },
        "directionalLightShadowMap": {
            "type": "array", "elements": {"type": "object", "kind": "texture"}, "staticSize": 5, "source": "uniform"
        },
        "directionalLightMatrix": {
            "type": "array",
            "elements": {"type": "object", "kind": "matrix4"},
            "staticSize": 5,
            "source": "uniform"
        },

        "MAX_SPOTLIGHTS": {"type": "int", "source": "constant", "staticValue": 5},
        "spotLightOn": {"type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"},
        "spotLightAttenuation": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightIntensity": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightPosition": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightDirection": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightCosCutoffAngle": {
            "type": "array", "elements": {"type": "number"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightCosSoftCutoffAngle": {
            "type": "array", "elements": {"type": "number"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightCastShadow": {
            "type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightShadowBias": {
            "type": "array", "elements": {"type": "number"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightShadowMap": {
            "type": "array", "elements": {"type": "object", "kind": "texture"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightMatrix": {
            "type": "array",
            "elements": {"type": "object", "kind": "matrix4"},
            "staticSize": 5,
            "source": "uniform"
        },
        "ssaoMap": {"type": "object", "kind": "texture", "source": "uniform"},
        "environment": {"type": "object", "kind": "texture", "source": "uniform"}
};

function createSystemConfiguration(context) {
    var result = SYSTEM_CONTEXT_TEMPLATE;
    var ext = context.getExtensionByName(GLContext.EXTENSIONS.STANDARD_DERIVATES);
    if (ext) {
        result.fwidth = {type: Shade.TYPES.FUNCTION};
        result.dx = {type: Shade.TYPES.FUNCTION};
        result.dy = {type: Shade.TYPES.FUNCTION};
    }
    return result;
}


module.exports = function (context) {
    if (!singleton) {
        singleton = createSystemConfiguration(context);
    }
    return singleton;
};




},{"../../base/context.js":112}],127:[function(require,module,exports){
var JSShaderComposer = require("./js/jsshadercomposer.js");
var URNShaderComposer = require("./urn/urnshadercomposer.js");
var DefaultComposer = require("./abstractshadercomposer.js").DefaultComposer;

/**
 * @param {GLContext} context
 * @constructor
 */
var ShaderComposerFactory = function (context) {
    this.context = context;
    /** @type {Object.<number, IShaderComposer>} */
    this.composers = {};
    this.defaultComposer = new DefaultComposer(context);
    this.lightValuesDirty = true;
};


XML3D.extend(ShaderComposerFactory.prototype, {
    /**
     *
     * @param {MaterialConfiguration} materialConfiguration
     * @returns {IShaderComposer}
     */
    createComposerFromMaterialConfiguration: function (materialConfiguration) {
        if (!materialConfiguration) {
            return this.defaultComposer;
        }
        var result = this.composers[materialConfiguration.id];
        if (!result) {
            try {
                var modelType = materialConfiguration.model.type;
                switch (modelType) {
                    case "urn":
                        result = new URNShaderComposer(this.context, materialConfiguration);
                        break;
                    case "text/javascript":
                    case "application/javascript":
                    case "text/shade-javascript":
                        result = new JSShaderComposer(this.context, materialConfiguration);
                        break;
                    default:
                        XML3D.debug.logError("Can not create shader of type:", modelType, materialConfiguration.model)
                }

            } catch (e) {
                XML3D.debug.logError("No shader could be created for '" + materialConfiguration.name + "':", e.message);
                result = this.defaultComposer;
            }
            if (result) {
                this.composers[materialConfiguration.id] = result;
                this.context.getStatistics().materials++;
            }
            return result || this.defaultComposer;
        }
        return result;
    },

    getTemplateById: function (id) {
        return this.composers[id];
    },

    update: function (scene) {
        for (var i in this.composers) {
            this.composers[i].update(scene, {updateLightValues: this.lightValuesDirty});
        }
        this.lightValuesDirty = false;
    },

    setLightStructureDirty: function () {
        this.setShaderRecompile();
    },

    setShaderRecompile: function () {
        for (var i in this.composers) {
            this.composers[i].setShaderRecompile();
        }
    },

    updateSystemUniforms: function (names, scene) {
        for (var i in this.composers) {
            this.composers[i].updateSystemUniforms(names, scene);
        }
    },

    setLightValueChanged: function () {
        for (var i in this.composers) {
            this.composers[i].updateLightValues = true;
        }
    }

});

module.exports = ShaderComposerFactory;



},{"./abstractshadercomposer.js":122,"./js/jsshadercomposer.js":125,"./urn/urnshadercomposer.js":136}],128:[function(require,module,exports){
var EVENT_TYPE = require("../../renderer/scene/constants.js").EVENT_TYPE;
var Targets = require("../base/rendertarget");

var LightPass = require("../render-passes/light-pass");
var PointLightPass = require("../render-passes/pointlight-pass");

/**
 * @param {GLContext} context
 * @param {GLScene} scene
 * @constructor
 */
var ShadowMapService = function (context, scene) {
    this.context = context;
    scene.on(EVENT_TYPE.LIGHT_STRUCTURE_CHANGED, this.onLightStructureChanged.bind(this));
    scene.on(EVENT_TYPE.LIGHT_VALUE_CHANGED, this.onLightValueChanged.bind(this));
    scene.on(EVENT_TYPE.SCENE_SHAPE_CHANGED, this.onSceneShapeChanged.bind(this));

    this.shadowMapInfos = [];
    this.dirty = true;
};

XML3D.extend(ShadowMapService.prototype, {
    onLightStructureChanged: function (light, removed) {
        var shadowMapInfos = this.shadowMapInfos;
        if (removed) {
            removeLight(shadowMapInfos, light);
        } else {
            if (lightNeedsShadowMap(light)) {
                addLight(shadowMapInfos, light);
                this.requestRendering("light added");
            }
        }
    },

    onLightValueChanged: function () {
        this.requestRendering("light value changed");
    },

    onSceneShapeChanged: function () {
        this.requestRendering("scene shape changed");
    },

    requestRendering: function(/*reason*/) {
        this.dirty = true;
    },

    updateForRendering: function() {
        if(this.dirty) {
            var shadowMaps = this.shadowMapInfos;
            for (var i = 0; i < shadowMaps.length; i++) {
                shadowMaps[i].pass.renderScene();
            }
            this.dirty = false;
        }
    },

    fillGlobalParameters: function(globals) {
        var shadowUnits = mergeShadowParameters(this.shadowMapInfos);
        XML3D.extend(globals, shadowUnits);
    }

});

function lightNeedsShadowMap(light) {
    return !!light.model.getParameter("castShadow")[0];
}

function addLight(shadowMapInfos, light) {
    var context = light.scene.context;
    var passInfo = createPassInfo(light, context);
    shadowMapInfos.push(passInfo);
}


function removeLight(shadowMapInfos, light) {
    for (var i = 0; i < shadowMapInfos.length; i++) {
        if (shadowMapInfos[i].light === light) {
            shadowMapInfos.splice(index, 1);
            // TODO: Free pass and other resources, free texture slot
            return;
        }
    }
}

function createPassInfo(light, context) {
    var size = Math.max(context.canvasTarget.width, context.canvasTarget.height) * 2;
    var params = {
        width: size,
        height: size,
        colorFormat: context.gl.RGBA,
        depthFormat: context.gl.DEPTH_COMPONENT16,
        stencilFormat: null,
        depthAsRenderbuffer: true
    };

    var pass = light.model.id == "point" ? createPointLightPass(light, context, params) : createLightPass(light, context, params);
    pass.init(context);

    // Bind target in order to create texture map
    pass.output.bind();

    // TODO: Better way to fix the texture unit?
    var unitEntry = context.textureManager.getEntry(pass.output.colorTarget.handle.id);
    unitEntry.fixed = true;

    pass.output.unbind();

    return {
        light: light, pass: pass, slot: unitEntry.slot
    };
}


function createLightPass(light, context, params) {
    var lightFramebuffer = new Targets.GLRenderTarget(context, params);
    return new LightPass({context: context}, lightFramebuffer, light);
}

function createPointLightPass(light, context, params) {
    var lightFramebuffer = new Targets.GLCubeMapRenderTarget(context, params);
    return new PointLightPass({context: context}, lightFramebuffer, light);
}

function mergeShadowParameters(shadowMapInfos) {
    var result = {};
    ["spot", "point", "directional"].forEach(function(model) {
        var sameModel = shadowMapInfos.filter(function(info) { return info.light.model.id == model; });
        result[model + "LightShadowMap"] = sameModel.map(function (info) {
            return info.slot;
        });
    });
    return result;
}

module.exports = ShadowMapService;

},{"../../renderer/scene/constants.js":98,"../base/rendertarget":116,"../render-passes/light-pass":142,"../render-passes/pointlight-pass":146}],129:[function(require,module,exports){
XML3D.materials.register("diffuse", {

    vertex : [
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec3 color;",
        "attribute vec2 texcoord;",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "uniform mat4 modelViewProjectionMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat3 modelViewMatrixN;",
        "uniform vec3 eyePosition;",

        "void main(void) {",
        "    vec3 pos = position;",
        "    vec3 norm = normal;",

        "    gl_Position = modelViewProjectionMatrix * vec4(pos, 1.0);",
        "    fragNormal = normalize(modelViewMatrixN * norm);",
        "    fragVertexPosition = (modelViewMatrix * vec4(pos, 1.0)).xyz;",
        "    fragEyeVector = normalize(fragVertexPosition);",
        "    fragTexCoord = texcoord;",
        "    fragVertexColor = color;",
        "}"
    ].join("\n"),

    fragment : [
        "uniform float ambientIntensity;",
        "uniform vec3 diffuseColor;",
        "uniform vec3 emissiveColor;",
        "uniform float opacity;",
        "uniform mat4 viewMatrix;",
        "uniform bool useVertexColor;",

        "#if HAS_EMISSIVETEXTURE",
        "uniform sampler2D emissiveTexture;",
        "#endif",
        "#if HAS_DIFFUSETEXTURE",
        "uniform sampler2D diffuseTexture;",
        "#endif",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "#if MAX_POINTLIGHTS > 0",
        "uniform vec3 pointLightAttenuation[MAX_POINTLIGHTS];",
        "uniform vec3 pointLightPosition[MAX_POINTLIGHTS];",
        "uniform vec3 pointLightIntensity[MAX_POINTLIGHTS];",
        "uniform bool pointLightOn[MAX_POINTLIGHTS];",
        "#endif",

        "#if MAX_DIRECTIONALLIGHTS > 0",
        "uniform vec3 directionalLightDirection[MAX_DIRECTIONALLIGHTS];",
        "uniform vec3 directionalLightIntensity[MAX_DIRECTIONALLIGHTS];",
        "uniform bool directionalLightOn[MAX_DIRECTIONALLIGHTS];",
        "#endif",

        "#if MAX_SPOTLIGHTS > 0",
        "uniform vec3 spotLightAttenuation[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightPosition[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightIntensity[MAX_SPOTLIGHTS];",
        "uniform bool spotLightOn[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightDirection[MAX_SPOTLIGHTS];",
        "uniform float spotLightCosCutoffAngle[MAX_SPOTLIGHTS];",
        "uniform float spotLightCosSoftCutoffAngle[MAX_SPOTLIGHTS];",
        "uniform float spotLightSoftness[MAX_SPOTLIGHTS];",
        "#endif",

        "void main(void) {",
        "  float alpha =  max(0.0, opacity);",
        "  vec3 objDiffuse = diffuseColor;",
        "  if(useVertexColor)",
        "    objDiffuse *= fragVertexColor;",
        "  #if HAS_DIFFUSETEXTURE",
        "    vec4 texDiffuse = texture2D(diffuseTexture, fragTexCoord);",
        "    alpha *= texDiffuse.a;",
        "    objDiffuse *= texDiffuse.rgb;",
        "  #endif",
        "  if (alpha < 0.05) discard;",

        "  #if HAS_EMISSIVETEXTURE",
        "    vec3 color = emissiveColor * texture2D(emissiveTexture, fragTexCoord).rgb + (ambientIntensity * objDiffuse);",
        "  #else",
        "    vec3 color = emissiveColor + (ambientIntensity * objDiffuse);",
        "  #endif",

        "  #if MAX_POINTLIGHTS > 0",
        "    for (int i=0; i<MAX_POINTLIGHTS; i++) {",
        "      if (!pointLightOn[i])",
        "         continue;",
        "      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
        "      vec3 L = lPosition.xyz - fragVertexPosition;",
        "      float dist = length(L);",
        "      L = normalize(L);",
        "      float atten = 1.0 / (pointLightAttenuation[i].x + pointLightAttenuation[i].y * dist + pointLightAttenuation[i].z * dist * dist);",
        "      vec3 Idiff = pointLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
        "      color = color + atten*Idiff;",
        "    }",
        "  #endif",

        "#if MAX_DIRECTIONALLIGHTS > 0",
        "  for (int i=0; i<MAX_DIRECTIONALLIGHTS; i++) {",
        "      if (!directionalLightOn[i])",
        "         continue;",
        "    vec4 lDirection = viewMatrix * vec4(directionalLightDirection[i], 0.0);",
        "    vec3 L =  normalize(-lDirection.xyz);",
        "    vec3 Idiff = directionalLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
        "    color = color + Idiff;",
        "  }",
        "#endif",

        "#if MAX_SPOTLIGHTS > 0",
        "  for (int i=0; i<MAX_SPOTLIGHTS; i++) {",
        "      if (!spotLightOn[i])",
        "         continue;",
        "    vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
        "    vec3 L = lPosition.xyz - fragVertexPosition;",
        "    float dist = length(L);",
        "    L = normalize(L);",
        "    float atten = 1.0 / (spotLightAttenuation[i].x + spotLightAttenuation[i].y * dist + spotLightAttenuation[i].z * dist * dist);",
        "    vec3 Idiff = spotLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
        "    vec4 lDirection = viewMatrix * vec4(-spotLightDirection[i], 0.0);",
        "    vec3 D = normalize(lDirection.xyz);",
        "    float angle = dot(L, D);",
        "    if(angle > spotLightCosCutoffAngle[i]) {",
        "       float softness = 1.0;",
        "       if (angle < spotLightCosSoftCutoffAngle[i])",
        "           softness = (angle - spotLightCosCutoffAngle[i]) /  (spotLightCosSoftCutoffAngle[i] -  spotLightCosCutoffAngle[i]);",
        "       color += atten * softness * Idiff;",
        "    }",
        "  }",
        "#endif",

        "  gl_FragColor = vec4(color, alpha);",
        "}"
    ].join("\n"),

    addDirectives: function(directives, lights, params) {
        ["point", "directional", "spot"].forEach(function (type) {
            var numLights = lights.getModelCount(type);
            directives.push("MAX_" + type.toUpperCase() + "LIGHTS " + numLights);
        });
        directives.push("HAS_DIFFUSETEXTURE " + ('diffuseTexture' in params ? "1" : "0"));
        directives.push("HAS_EMISSIVETEXTURE " + ('emissiveTexture' in params ? "1" : "0"));
    },
    hasTransparency: function(params) {
        return params.opacity && params.opacity.getValue()[0] < 1;
    },
    uniforms: {
        diffuseColor    : [1.0, 1.0, 1.0],
        emissiveColor   : [0.0, 0.0, 0.0],
        opacity         : 1.0,
        ambientIntensity: 0.0,
        useVertexColor : false
    },
    samplers: {
        diffuseTexture : null,
        emissiveTexture : null
    },
    attributes: {
        normal : {
            required: true
        },
        texcoord: null,
        color: null
    }
});

},{}],130:[function(require,module,exports){
XML3D.materials.register("matte", {

    vertex: [
        "attribute vec3 position;",
        "attribute vec3 color;",

        "varying vec3 fragVertexColor;",

        "uniform mat4 modelViewProjectionMatrix;",

        "void main(void) {",
        "   fragVertexColor = color;",
        "   gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment: [
        "uniform vec3 diffuseColor;",
        "uniform bool useVertexColor;",

        "varying vec3 fragVertexColor;",

        "void main(void) {",
        "    vec3 color = diffuseColor;",
        "    if (useVertexColor)",
        "       color *=  fragVertexColor;",
        "    gl_FragColor = vec4(color, 1.0);",
        "}"
    ].join("\n"),

    uniforms: {
        diffuseColor : [1.0, 1.0, 1.0],
        useVertexColor: false
    },
    attributes: {
        color: null,
        normal: null // For picking
    }
});

XML3D.materials.register("flat", XML3D.materials.getScript("matte"));

},{}],131:[function(require,module,exports){
XML3D.materials.register("phong", {

    vertex : [
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec3 color;",
        "attribute vec2 texcoord;",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "#if (HAS_POINTLIGHT_SHADOWMAPS || HAS_DIRECTIONALLIGHT_SHADOWMAPS || HAS_SPOTLIGHT_SHADOWMAPS)",
        "varying vec3 fragWorldPosition;", //needed by any of the light types
        "#endif",

        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewProjectionMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat3 modelViewMatrixN;",
        "uniform vec3 eyePosition;",

        "void main(void) {",
        "    vec3 pos = position;",
        "    vec3 norm = normal;",
        "    gl_Position = modelViewProjectionMatrix * vec4(pos, 1.0);",
        "    fragNormal = normalize(modelViewMatrixN * norm);",
        "    fragVertexPosition = (modelViewMatrix * vec4(pos, 1.0)).xyz;",
        "    fragEyeVector = normalize(fragVertexPosition);",
        "    fragTexCoord = texcoord;",
        "    fragVertexColor = color;",
        "#if (HAS_POINTLIGHT_SHADOWMAPS || HAS_DIRECTIONALLIGHT_SHADOWMAPS || HAS_SPOTLIGHT_SHADOWMAPS)",
        "    fragWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;",
        "#endif",
        "}"
    ].join("\n"),

    fragment : [
        "uniform float ambientIntensity;",
        "uniform vec3 diffuseColor;",
        "uniform vec3 emissiveColor;",
        "uniform float shininess;",
        "uniform vec3 specularColor;",
        "uniform float opacity;",
        "uniform mat4 viewMatrix;",
        "uniform bool useVertexColor;",
		"uniform vec3 coords;",

        "#if HAS_EMISSIVETEXTURE",
        "uniform sampler2D emissiveTexture;",
        "#endif",
        "#if HAS_DIFFUSETEXTURE",
        "uniform sampler2D diffuseTexture;",
        "#endif",
        "#if HAS_SPECULARTEXTURE",
        "uniform sampler2D specularTexture;",
        "#endif",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "#if (HAS_POINTLIGHT_SHADOWMAPS || HAS_DIRECTIONALLIGHT_SHADOWMAPS || HAS_SPOTLIGHT_SHADOWMAPS)",
        "varying vec3 fragWorldPosition;",  //if there is Shadow we need world position and unpacking function
        "float unpackDepth( const in vec4 rgba_depth ) {",
        "  const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
        "  float depth = dot( rgba_depth, bit_shift );",
        "  return depth;",
        "}",
        "#endif",

        "#if MAX_POINTLIGHTS > 0",
        "uniform vec3 pointLightAttenuation[MAX_POINTLIGHTS];",
        "uniform vec3 pointLightPosition[MAX_POINTLIGHTS];",
        "uniform vec3 pointLightIntensity[MAX_POINTLIGHTS];",
        "uniform bool pointLightOn[MAX_POINTLIGHTS];",
        "uniform bool pointLightCastShadow[MAX_POINTLIGHTS];",
            "#if HAS_POINTLIGHT_SHADOWMAPS",
            "uniform samplerCube pointLightShadowMap[MAX_POINTLIGHTS];",
            "uniform float pointLightShadowBias[MAX_POINTLIGHTS];",
            "uniform vec2 pointLightNearFar[MAX_POINTLIGHTS];",
            "float vecToDepth(vec3 vec, float n, float f){",
                "vec3 absVec = abs(vec);" +
                "float maxComp = max(absVec.x, max(absVec.y, absVec.z));",
                "float res = (f+n)/(f-n)-(2.0*f*n)/(f-n)/maxComp;",
                "return res*0.5+0.5;",
            "}",
            "#endif",
        "#endif",

        "#if MAX_SPOTLIGHTS > 0",
        "uniform vec3 spotLightAttenuation[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightPosition[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightIntensity[MAX_SPOTLIGHTS];",
        "uniform bool spotLightOn[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightDirection[MAX_SPOTLIGHTS];",
        "uniform float spotLightCosCutoffAngle[MAX_SPOTLIGHTS];",
        "uniform float spotLightCosSoftCutoffAngle[MAX_SPOTLIGHTS];",
        "uniform float spotLightSoftness[MAX_SPOTLIGHTS];",
        "uniform bool spotLightCastShadow[MAX_SPOTLIGHTS];",
            "#if HAS_SPOTLIGHT_SHADOWMAPS",
            "uniform mat4 spotLightMatrix[ MAX_SPOTLIGHTS ];",//used for shadowmapcoord calculation
            "uniform sampler2D spotLightShadowMap[MAX_SPOTLIGHTS];",
            "uniform float spotLightShadowBias[MAX_SPOTLIGHTS];",
            "#endif",
        "#endif",


        "#if MAX_DIRECTIONALLIGHTS > 0",
        "uniform vec3 directionalLightDirection[MAX_DIRECTIONALLIGHTS];",
        "uniform vec3 directionalLightIntensity[MAX_DIRECTIONALLIGHTS];",
        "uniform bool directionalLightOn[MAX_DIRECTIONALLIGHTS];",
        "uniform bool directionalLightCastShadow[MAX_DIRECTIONALLIGHTS];",
            "#if HAS_DIRECTIONALLIGHT_SHADOWMAPS",
            "uniform mat4 directionalLightMatrix[MAX_DIRECTIONALLIGHTS];",
            "uniform sampler2D directionalLightShadowMap[MAX_DIRECTIONALLIGHTS];",
            "uniform float directionalLightShadowBias[MAX_DIRECTIONALLIGHTS];",
            "#endif",
        "#endif",


		"uniform sampler2D ssaoMap;",

        "void main(void) {",
        //calculate shadowmap coords (vector for pointlight)
        "#if MAX_POINTLIGHTS > 0 && HAS_POINTLIGHT_SHADOWMAPS",
        "    vec3 pointLightShadowMapDirection[MAX_POINTLIGHTS];",
        "    for(int i = 0; i < MAX_POINTLIGHTS; i++) {",
        "       pointLightShadowMapDirection[i] = fragWorldPosition - pointLightPosition[i];",
        "    }",
        "#endif",
        "#if MAX_SPOTLIGHTS > 0 && HAS_SPOTLIGHT_SHADOWMAPS",
        "    vec4 spotLightShadowMapCoord[MAX_SPOTLIGHTS];",
        "    for(int i = 0; i < MAX_SPOTLIGHTS; i++) {",
        "      spotLightShadowMapCoord[i] = spotLightMatrix[i] * vec4(fragWorldPosition, 1.0);",
        "    }",
        "#endif",
        "#if MAX_DIRECTIONALLIGHTS > 0 && HAS_DIRECTIONALLIGHT_SHADOWMAPS",
        "    vec4 directionalLightShadowMapCoord[MAX_DIRECTIONALLIGHTS];",
        "    for(int i = 0; i < MAX_DIRECTIONALLIGHTS; i++) {",
        "      directionalLightShadowMapCoord[i] = directionalLightMatrix[i] * vec4(fragWorldPosition, 1.0);",
        "    }",
        "#endif",

        "  float alpha =  max(0.0, opacity);",
        "  vec3 objDiffuse = diffuseColor;",
        "  if(useVertexColor)",
        "    objDiffuse *= fragVertexColor;",
        "  #if HAS_DIFFUSETEXTURE",
        "    vec4 texDiffuse = texture2D(diffuseTexture, fragTexCoord);",
        "    alpha *= texDiffuse.a;",
        "    objDiffuse *= texDiffuse.rgb;",
        "  #endif",
        "  if (alpha < 0.05) discard;",
        "  #if HAS_EMISSIVETEXTURE",
        "    vec3 color = emissiveColor * texture2D(emissiveTexture, fragTexCoord).rgb + (ambientIntensity * objDiffuse);",
        "  #else",
        "    vec3 color = emissiveColor + (ambientIntensity * objDiffuse);",
        "  #endif",
        "  vec3 objSpecular = specularColor;",
        "  #if HAS_SPECULARTEXTURE",
        "    objSpecular = objSpecular * texture2D(specularTexture, fragTexCoord).rgb;",
        "  #endif",
		"  #if HAS_SSAOMAP",
		"	 float ssao = 1.0 - texture2D(ssaoMap, gl_FragCoord.xy / coords.xy).r;",
        "  #endif",

        "  float shadowInfluence = 0.0;", //used for sampling shadow

		"#if MAX_POINTLIGHTS > 0",
        "  for (int i = 0; i < MAX_POINTLIGHTS; i++) {",
        "    shadowInfluence = 1.0;",
        "    if(pointLightOn[i]){",
        "   #if HAS_POINTLIGHT_SHADOWMAPS",
        "       if(pointLightCastShadow[i]){",
        "           shadowInfluence = 0.0;",
        "           float lsDepth = vecToDepth(pointLightShadowMapDirection[i], pointLightNearFar[i].x, pointLightNearFar[i].y );",
        "		    float depth = unpackDepth( textureCube(pointLightShadowMap[i], pointLightShadowMapDirection[i])) +  pointLightShadowBias[i];",
        "           if(lsDepth < depth)",
        "               shadowInfluence = 1.0;",
        "       }",
        "       if(shadowInfluence > 0.0){",
        "   #endif",
        "       vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
        "       vec3 L = lPosition.xyz - fragVertexPosition;",
        "       float dist = length(L);",
        "       L = normalize(L);",
        "       vec3 R = normalize(reflect(L,fragNormal));",
        "       float atten = 1.0 / (pointLightAttenuation[i].x + pointLightAttenuation[i].y * dist + pointLightAttenuation[i].z * dist * dist);",
        "       vec3 Idiff = pointLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
		"   #if HAS_SSAOMAP",
		"       Idiff *= ssao;",
		"   #endif",
        "       vec3 Ispec = pointLightIntensity[i] * objSpecular * pow(max(dot(R,fragEyeVector),0.0), shininess*128.0);",
        "       color = color + (atten*shadowInfluence*(Idiff + Ispec));",
        "   #if HAS_POINTLIGHT_SHADOWMAPS",
        "       }",  //pointlight visible
        "   #endif",
        "     }", //pointLight on
        "  }", //pointLight loop
        "#endif",

        "#if MAX_SPOTLIGHTS > 0",
        "  for (int i=0; i<MAX_SPOTLIGHTS; i++) {",
        "    shadowInfluence = 1.0;",
        "    if(spotLightOn[i]) {",
        "  #if HAS_SPOTLIGHT_SHADOWMAPS",
        "       if(spotLightCastShadow[i]){",
        "           shadowInfluence = 0.0;",
        "           vec4 lspos = spotLightShadowMapCoord[i];",
        "			vec3 perspectiveDivPos = lspos.xyz / lspos.w * 0.5 + 0.5;",
        "			float lsDepth = perspectiveDivPos.z;",
        "			vec2 lightuv = perspectiveDivPos.xy;",
        "			float depth = unpackDepth(texture2D(spotLightShadowMap[i], lightuv)) + spotLightShadowBias[i];",
        "           if(lsDepth < depth)",
        "               shadowInfluence = 1.0;",
        "       }",
        "       if(shadowInfluence > 0.0){",
        "  #endif",
        "       vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
        "       vec3 L = lPosition.xyz - fragVertexPosition;",
        "       float dist = length(L);",
        "       L = normalize(L);",
        "       vec3 R = normalize(reflect(L,fragNormal));",
        "       float atten = 1.0 / (spotLightAttenuation[i].x + spotLightAttenuation[i].y * dist + spotLightAttenuation[i].z * dist * dist);",
        "       vec3 Idiff = spotLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
        "   #if HAS_SSAOMAP",
        "	    Idiff *= ssao;",
        "   #endif",
        "       vec3 Ispec = spotLightIntensity[i] * objSpecular * pow(max(dot(R,fragEyeVector),0.0), shininess*128.0);",
        "       vec4 lDirection = viewMatrix * vec4(-spotLightDirection[i], 0.0);",
        "       vec3 D = normalize(lDirection.xyz);",
        "       float angle = dot(L, D);",
        "       if(angle > spotLightCosCutoffAngle[i]) {",
        "           float softness = 1.0;",
        "           if (angle < spotLightCosSoftCutoffAngle[i])",
        "               softness = (angle - spotLightCosCutoffAngle[i]) /  (spotLightCosSoftCutoffAngle[i] -  spotLightCosCutoffAngle[i]);",
        "           color += atten*softness*shadowInfluence*(Idiff + Ispec);",
        "       }",
        "   #if HAS_SPOTLIGHT_SHADOWMAPS",
        "       }", //light visible if shadow enabled
        "   #endif",
        "   } ", // spotlight on
        "  }", // light loop
        "#endif",

        "#if MAX_DIRECTIONALLIGHTS > 0",
        "  for (int i=0; i<MAX_DIRECTIONALLIGHTS; i++) {",
        "   shadowInfluence = 1.0;",
        "   if(directionalLightOn[i]){",
        "   #if HAS_DIRECTIONALLIGHT_SHADOWMAPS",
        "       if(directionalLightCastShadow[i]){",
        "           shadowInfluence = 0.0;",
        "           vec4 lspos = directionalLightShadowMapCoord[i];",
        "           vec3 orthogonalDivPos = lspos.xyz / lspos.w *0.5 + 0.5;",
        "           float lsDepth = orthogonalDivPos.z;",
        "           vec2 lightuv = orthogonalDivPos.xy;",
        "               float depth = unpackDepth(texture2D(directionalLightShadowMap[i], lightuv))+directionalLightShadowBias[i];",
        "               if(lsDepth < depth) shadowInfluence = 1.0;",
        "       }",
        "       if(shadowInfluence > 0.0){",
        "   #endif",
        "       vec4 lDirection = viewMatrix * vec4(directionalLightDirection[i], 0.0);",
        "       vec3 L =  normalize(-lDirection.xyz);",
        "       vec3 R = normalize(reflect(L,fragNormal));",
        "       vec3 Idiff = directionalLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
		"   #if HAS_SSAOMAP",
		"       Idiff *= ssao;",
		"   #endif",
        "       vec3 Ispec = directionalLightIntensity[i] * objSpecular * pow(max(dot(R,fragEyeVector),0.0), shininess*128.0);",
        "       color = color + shadowInfluence*((Idiff + Ispec));",
        "   #if HAS_DIRECTIONALLIGHT_SHADOWMAPS",
        "       }", //light visible
        "   #endif",
        "   }", //dirLight on
        "  }", // dirLight loop
        "#endif",
        "  gl_FragColor = vec4(color, alpha);",
        "}"
    ].join("\n"),

    addDirectives: function (directives, lights, params) {
        ["point", "directional", "spot"].forEach(function (type) {
            var numLights = lights.getModelCount(type);
            var castShadows = false;
            if(numLights) {
                castShadows = Array.prototype.some.call(lights.getModelEntry(type).parameters["castShadow"], function (value) {
                    return value;
                });
            }
            directives.push("MAX_" + type.toUpperCase() + "LIGHTS " + numLights);
            directives.push("HAS_" + type.toUpperCase() + "LIGHT_SHADOWMAPS " + (castShadows ? 1 : 0));
        });

        directives.push("HAS_DIFFUSETEXTURE " + ('diffuseTexture' in params ? "1" : "0"));
        directives.push("HAS_SPECULARTEXTURE " + ('specularTexture' in params ? "1" : "0"));
        directives.push("HAS_EMISSIVETEXTURE " + ('emissiveTexture' in params ? "1" : "0"));
        directives.push("HAS_SSAOMAP " + (XML3D.options.getValue("renderer-ssao") ? "1" : "0"));
    },
    hasTransparency: function(params) {
        return params.opacity && params.opacity.getValue()[0] < 1;
    },
    uniforms: {
        diffuseColor    : [1.0, 1.0, 1.0],
        emissiveColor   : [0.0, 0.0, 0.0],
        specularColor   : [0.0, 0.0, 0.0],
        opacity         : 1.0,
        shininess       : 0.2,
        ambientIntensity: 0.0,
        useVertexColor : false
    },

    samplers: {
        diffuseTexture : null,
        emissiveTexture : null,
        specularTexture : null,
        directionalLightShadowMap : null,
        spotLightShadowMap : null,
        pointLightShadowMap : null,
		ssaoMap: null
    },

    attributes: {
        normal : {
            required: true
        },
        texcoord: null,
        color: null
    }
});

},{}],132:[function(require,module,exports){
XML3D.materials.register("point", {

    vertex : [
        "attribute vec3 position;",
        "attribute vec3 color;",
        "attribute vec2 texcoord;",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "uniform mat4 modelViewProjectionMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat3 modelViewMatrixN;",
        "uniform vec3 eyePosition;",
        "uniform vec3 coords;",
        "uniform float pointSize;",

        "void main(void) {",
        "    vec3 pos = position;",

        "    gl_Position = modelViewProjectionMatrix * vec4(pos, 1.0);",
        "    fragVertexPosition = (modelViewMatrix * vec4(pos, 1.0)).xyz;",
        "    fragEyeVector = normalize(fragVertexPosition);",
        "    fragTexCoord = texcoord;",
        "    fragVertexColor = color;",
        "    vec4 pos2 = vec4(fragVertexPosition, 1.0); pos2.x += pointSize;",
        "    gl_PointSize = distance( gl_Position.xy, (projectionMatrix * pos2).xy ) * coords.x / gl_Position.w;",
        "}"
    ].join("\n"),

    fragment : [
        "uniform vec3 diffuseColor;",
        "uniform float opacity;",
        "uniform mat4 viewMatrix;",
        "uniform bool useVertexColor;",
        "uniform vec2 texCoordOffset;",
        "uniform vec2 texCoordSize;",

        "#if HAS_DIFFUSETEXTURE",
        "uniform sampler2D diffuseTexture;",
        "#endif",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "void main(void) {",
        "  float alpha =  max(0.0, opacity);",
        "  vec3 objDiffuse = diffuseColor;",
        "  if(useVertexColor)",
        "    objDiffuse *= fragVertexColor;",
        "  #if HAS_DIFFUSETEXTURE",
        "    vec2 texCoord = fragTexCoord + texCoordOffset + gl_PointCoord*texCoordSize;",
        "    texCoord.y = 1.0 - texCoord.y;",
        "    vec4 texDiffuse = texture2D(diffuseTexture, texCoord);",
        "    alpha *= texDiffuse.a;",
        "    objDiffuse *= texDiffuse.rgb;",
        "  #endif",
        "  if (alpha < 0.05) discard;",
        "  gl_FragColor = vec4(objDiffuse, alpha);",
        "}"
    ].join("\n"),
    addDirectives: function(directives, lights, params) {
        directives.push("HAS_DIFFUSETEXTURE " + ('diffuseTexture' in params ? "1" : "0"));
    },
    hasTransparency: function(params) {
        return params.opacity && params.opacity.getValue()[0] < 1;
    },
    uniforms: {
        diffuseColor    : [1.0, 1.0, 1.0],
        texCoordOffset  : [0, 0],
        texCoordSize    : [1, 1],
        opacity         : 1.0,
        useVertexColor  : false,
        pointSize       : 1.0
    },
    samplers: {
        diffuseTexture: null
    },
    attributes: {
        texcoord: null,
        color: null
    }
});

},{}],133:[function(require,module,exports){
var c_globalScripts = {};

module.exports = {

    register: function (name, script) {
        c_globalScripts[name] = script;
        script.name = name;
    },

    getScript: function (script) {
        return c_globalScripts[script];
    }
};

},{}],134:[function(require,module,exports){
var ShaderDescriptor = function () {
    this.uniforms = {};
    this.samplers = {};
    this.attributes = {};
    this.name = "";
    this.fragment = "";
    this.vertex = "";
};
ShaderDescriptor.prototype.addDirectives = function () {
};
ShaderDescriptor.prototype.hasTransparency = function () {
    return false;
};

module.exports = ShaderDescriptor;

},{}],135:[function(require,module,exports){
var AbstractShaderClosure = require("./../abstractshaderclosure.js");
var SystemNotifier = require("../../system/system-notifier.js");

/**
 * A ShaderClosure connects a mesh-specific GLProgram with it's Xflow data
 * @param {GLContext} context
 * @param descriptor
 * @constructor
 */
var ShaderClosure = function (context, descriptor) {
    AbstractShaderClosure.call(this, context);
    this.descriptor = descriptor;
};

XML3D.createClass(ShaderClosure, AbstractShaderClosure);

XML3D.extend(ShaderClosure.prototype, {

    setDefaultUniforms: function (dest) {
        XML3D.extend(dest, this.descriptor.uniforms);
    },

    createSources: function (scene, shaderData, vsRequest) {

        var objectData = vsRequest && vsRequest.getResult();
        var directives = [];

        var inputData = {};
        shaderData && XML3D.extend(inputData, shaderData.getOutputMap());
        objectData && XML3D.extend(inputData, objectData.getOutputMap());


        for (var attrName in this.descriptor.attributes) {
            var entry = this.descriptor.attributes[attrName];
            if (entry && entry.required && !inputData[attrName]) {
                throw new Error("Mesh is missing '" + attrName + "' attribute.");
            }
        }

        this.descriptor.addDirectives(directives, scene.lights || {}, inputData);
        this.source = {
            fragment: this.addDirectivesToSource(directives, this.descriptor.fragment),
            vertex: this.addDirectivesToSource(directives, this.descriptor.vertex)
        };

        SystemNotifier.sendEvent('urnshader', {
            urnshaderType: "code", vertexShader: this.source.vertex, fragmentShader: this.source.fragment
        });

        return true;
    },

    addDirectivesToSource: function (directives, source) {
        var header = "";
        directives.forEach(function (v) {
            header += "#define " + v + "\n";
        });
        return header + "\n" + source;
    },

    getTransparencyFromInputData: function (dataMap) {
        return this.descriptor.hasTransparency(dataMap);
    }
});

module.exports = ShaderClosure;


},{"../../system/system-notifier.js":158,"./../abstractshaderclosure.js":121}],136:[function(require,module,exports){
var AbstractShaderComposer = require("../abstractshadercomposer.js").AbstractShaderComposer;
var URNShaderClosure= require("./urnshaderclosure.js");
var ShaderDescriptor = require("./shader-descriptor.js");
var ComputeRequest = require("../../../../xflow/interface/request.js").ComputeRequest;
var addFragmentShaderHeader = require("../../shader/shader-utils.js").addFragmentShaderHeader;
require("./diffuse.js");
require("./phong.js");
require("./matte.js");
require("./point.js");
require("./utility.js");

/**
 * @param {string} path
 * @returns {*}
 */
var getShaderDescriptor = function (path) {
    var shaderName = path.substring(path.lastIndexOf(':') + 1);
    return XML3D.materials.getScript(shaderName);
};


/**
 * @implements {IShaderComposer}
 * @extends AbstractShaderComposer
 * @constructor
 */
var URNShaderComposer = function (context, materialConfiguration) {
    AbstractShaderComposer.call(this, context, materialConfiguration);
    this.descriptor = null;
    this.setMaterialConfiguration(materialConfiguration);
};

XML3D.createClass(URNShaderComposer, AbstractShaderComposer, {
    /**
     *
     * @param {MaterialConfiguration} materialConfiguration
     */
    setMaterialConfiguration: function (materialConfiguration) {
        var shaderScriptURI = materialConfiguration.model.urn;
        this.setShaderScript(shaderScriptURI);

        if (this.descriptor) {
            materialConfiguration.dataNode && this.updateRequest(materialConfiguration.dataNode);

            this.descriptor.fragment = addFragmentShaderHeader(this.descriptor.fragment);
        }
    },

    setShaderScript: function (uri) {

        if (!uri) {
            XML3D.debug.logError("Material has no script attached: ", this.adapter.node);
            return;
        }
        if (uri.scheme != "urn") {
            XML3D.debug.logError("Material model reference should start with an URN: ", this.adapter.node);
            return;
        }
        var descriptor = getShaderDescriptor(uri.path);
        if (!descriptor) {
            throw new Error("Unknown URN: " + uri);
        }

        this.descriptor = new ShaderDescriptor();
        XML3D.extend(this.descriptor, descriptor);
    },

    getRequestFields: function () {
        return Object.keys(this.descriptor.uniforms).concat(Object.keys(this.descriptor.samplers));
    },

    /**
     * Get the attributes required by the shader
     * @returns {Object<string, *>}
     */
    getShaderAttributes: function () {
        return this.descriptor.attributes;
    },

    createShaderClosure: function () {
        return new URNShaderClosure(this.context, this.descriptor);
    },

    createObjectDataRequest: function (objectDataNode, callback) {
        var requestNames = ["position"];
        requestNames.push.apply(requestNames, Object.keys(this.descriptor.attributes));
        requestNames.push.apply(requestNames, Object.keys(this.descriptor.uniforms));
        requestNames.push.apply(requestNames, Object.keys(this.descriptor.samplers));
        return new ComputeRequest(objectDataNode, requestNames, callback);
    },

    distributeObjectShaderData: function (objectRequest, attributeCallback, uniformCallback) {
        var result = objectRequest.getResult();

        var dataMap = result.getOutputMap();
        for (var name in dataMap) {

            if (name == "position" || this.descriptor.attributes[name] !== undefined)
                attributeCallback(name, dataMap[name]); else if (this.descriptor.uniforms[name] !== undefined || this.descriptor.samplers[name] !== undefined) {
                uniformCallback(name, dataMap[name]);
            }
        }
    }

});

module.exports = URNShaderComposer;



},{"../../../../xflow/interface/request.js":190,"../../shader/shader-utils.js":157,"../abstractshadercomposer.js":122,"./diffuse.js":129,"./matte.js":130,"./phong.js":131,"./point.js":132,"./shader-descriptor.js":134,"./urnshaderclosure.js":135,"./utility.js":137}],137:[function(require,module,exports){
XML3D.materials.register("pickobjectid", {
    vertex : [
        "attribute vec3 position;",
        "uniform mat4 modelViewProjectionMatrix;",

        "void main(void) {",
        "    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "uniform vec3 id;",

        "void main(void) {",
        "    gl_FragColor = vec4(id, 0.0);",
        "}"
    ].join("\n"),

    uniforms : {}
});

XML3D.materials.register("pickedposition", {
    vertex : [
        "attribute vec3 position;",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewProjectionMatrix;",
        "uniform vec3 bbox[2];",  // min = bbox[0], max = bbox[1]

        "varying vec3 worldCoord;",

        "void main(void) {",
        "    worldCoord = (modelMatrix * vec4(position, 1.0)).xyz;",
        "    vec3 diff = bbox[1] - bbox[0];",
        "    worldCoord = worldCoord - bbox[0];",
        "    worldCoord = worldCoord / diff;",
        "    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "varying vec3 worldCoord;",

        "void main(void) {",
        "    gl_FragColor = vec4(worldCoord, 1.0);",
        "}"
    ].join("\n"),

    uniforms : {}
});


XML3D.materials.register("pickedNormals", {
    vertex : [
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "uniform mat4 modelViewProjectionMatrix;",
        "uniform mat3 modelViewMatrixN;",

        "varying vec3 fragNormal;",

        "void main(void) {",
        "    fragNormal = normalize(modelViewMatrixN * normal);",
        "    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "varying vec3 fragNormal;",

        "void main(void) {",
        "    gl_FragColor = vec4((fragNormal+1.0)/2.0 * (254.0 / 255.0), 1.0);",
        "}"
    ].join("\n"),

    uniforms : {}
});

XML3D.materials.register("light-depth", {

    vertex: [
        "attribute vec3 position;",
        "varying vec4 worldPosition;",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewProjectionMatrix;",

        "void main(void) {",
        "   worldPosition = modelMatrix * vec4(position, 1.0);",
        "   gl_Position   = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment: [
        "varying vec4 worldPosition;",
        "uniform mat4 viewMatrix;",

        "vec4 pack_depth( const in float depth ) {",
        "const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
        "const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
        "vec4 res = fract( depth * bit_shift );",
        "res -= res.xxyz * bit_mask;",
        "return res;",
        "}",


        "void main(void) {",
        "    gl_FragColor = pack_depth( gl_FragCoord.z );",
        "}"
    ].join("\n"),

    uniforms: {}
});

XML3D.materials.register("render-normal", {
    vertex : [
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "uniform mat4 modelViewProjectionMatrix;",
        "uniform mat3 modelMatrixN;",

        "varying vec3 fragNormal;",

        "void main(void) {",
        "    fragNormal = modelMatrixN * normal;",
        "    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "varying vec3 fragNormal;",

        "void main(void) {",
        "   gl_FragColor = vec4((normalize(fragNormal) + 1.0) / 2.0, 1.0);",
        "}"
    ].join("\n"),

    uniforms : {}
});

XML3D.materials.register("render-position", {
    vertex : [
        "attribute vec3 position;",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewProjectionMatrix;",

        "varying vec3 worldCoord;",

        "void main(void) {",
        "    worldCoord = (modelMatrix * vec4(position, 1.0)).xyz;",
        "    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "varying vec3 worldCoord;",

        "void main(void) {",
        "    gl_FragColor = vec4(worldCoord, 1.0);",
        "}"
    ].join("\n"),

    uniforms : {}
});

XML3D.materials.register("boxblur", {
    vertex: [
        "attribute vec3 position;",

        "void main(void) {",
        "   gl_Position = vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment: [
        "uniform sampler2D sInTexture;",
        "uniform vec2 canvasSize;",
        "uniform vec2 blurOffset;",

        "const float blurSize = 1.0/512.0;",

        "void main(void) {",
        "   vec2 texcoord = (gl_FragCoord.xy / canvasSize.xy);",
        "   vec4 sum = vec4(0.0);",
        "   float blurSizeY = blurOffset.y / canvasSize.y;",
        "   float blurSizeX = blurOffset.x / canvasSize.x;",

        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y - 1.5*blurSizeY));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y - 2.0*blurSizeY));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y - blurSizeY));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y + blurSizeY));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y + 2.0*blurSizeY));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y + 1.5*blurSizeY));",

        "   sum += texture2D(sInTexture, vec2(texcoord.x - 1.5*blurSizeX, texcoord.y));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x - 2.0*blurSizeX, texcoord.y));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x - blurSizeX, texcoord.y));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x + blurSizeX, texcoord.y));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x + 2.0*blurSizeX, texcoord.y));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x + 1.5*blurSizeX, texcoord.y));",

        "   gl_FragColor = sum / 12.0;",
        "}"
    ].join("\n"),

    uniforms: {
        canvasSize : [512, 512],
        blurOffset : [1.0, 1.0]
    },

    samplers: {
        sInTexture : null
    }
});

XML3D.materials.register("ssao", {
    vertex : [
        "attribute vec2 position;",

        "void main(void) {",
        "    gl_Position = vec4(position, 0.0, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "#ifdef GL_ES",
        "precision highp float;",
        "#endif",

        "uniform vec2 canvasSize;",
        "uniform sampler2D sPositionTex;",
        "uniform sampler2D sNormalTex;",
        "uniform sampler2D sRandomNormals;",
        "uniform vec2 uRandomTexSize;",
        "uniform float uSampleRadius;",
        "uniform float uScale;",
        "uniform float uBias;",
        "uniform float uIntensity;",
        "uniform vec2 uConstVectors[4];",
        "uniform mat4 viewMatrix;",

        "vec3 getPosition(vec2 uv) {",
        "return texture2D(sPositionTex, uv).xyz;",
        "}",

        "float calcAmbientOcclusion(vec2 screenUV, vec2 uvOffset, vec3 origin, vec3 cnorm) {",
        "   vec3 diff = getPosition(screenUV + uvOffset) - origin;",
        "   vec3 v = normalize(diff);",
        "   float dist = length(diff) * uScale;",
        "   return max(0.0, dot(cnorm, v) - uBias) * (1.0/(1.0 + dist)) * uIntensity;",
        "}",

        "void main(void) {",
        "   vec2 screenUV = gl_FragCoord.xy / canvasSize.xy;",
        "   vec2 rand = normalize(texture2D(sRandomNormals, gl_FragCoord.xy / uRandomTexSize).xy * 2.0 - 1.0 );",
        "   vec3 norm = normalize(texture2D(sNormalTex, screenUV).xyz * 2.0 - 1.0 );",
        "   vec3 origin = getPosition(screenUV);",
        "   float radius = uSampleRadius / (viewMatrix * vec4(origin, 1.0)).z;",
        "   float ao = 0.0;",

        "   const int iterations = 4;",
        "   for (int i = 0; i < iterations; ++i) {",
        "       vec2 coord1 = reflect(uConstVectors[i], rand) * radius;",
        "       vec2 coord2 = vec2(coord1.x*0.707 - coord1.y*0.707, coord1.x*0.707 + coord1.y*0.707);",
        "       ao += calcAmbientOcclusion(screenUV, coord1*0.25, origin, norm);",
        "       ao += calcAmbientOcclusion(screenUV, coord2*0.5, origin, norm);",
        "       ao += calcAmbientOcclusion(screenUV, coord1*0.75, origin, norm);",
        "       ao += calcAmbientOcclusion(screenUV, coord2, origin, norm);",
        "   }",
        "   ao /= (float(iterations) * 4.0);",
        "   gl_FragColor = vec4(ao, ao, ao, 1.0);",
        "}"
    ].join("\n"),

    uniforms: {
        canvasSize      : [512, 512],
        uConstVectors   : [1,0, -1,0, 0,1, 0,-1],
        uRandomTexSize  : [64,64],
        uSampleRadius   : 0.9,
        uScale          : 0.9,
        uBias           : 0.2,
        uIntensity      : 1.0
    },

    samplers: {
        sPositionTex   : null,
        sNormalTex     : null,
        sRandomNormals : null
    },

    attributes: {
    }
});

},{}],138:[function(require,module,exports){
// Note: This context should only be used to access GL constants
var GL = require("./constants.js");
var Targets = require("./base/rendertarget.js");
var FullScreenQuad = require("./base/fullscreenquad.js");
var ForwardRenderTree = require("./render-trees/forward.js");
var ForwardRenderPass = require("./render-passes/forward.js");

/**
 *
 * @param {GLContext} context
 * @param {Scene} scene
 * @constructor
 */
var GLRenderInterface = function (context, scene) {
    this.context = context;
    this.scene = scene;
    this.shaders = {};
    this.options = {
        pickingEnabled: true,
        mouseMovePickingEnabled: true,
        glBlendFuncSeparate: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA, GL.ONE, GL.ONE_MINUS_SRC_ALPHA]
    };
    this.renderTree = null;
};

XML3D.extend(GLRenderInterface.prototype, {
    getRenderTree: function () {
        return (this.renderTree = this.renderTree || new ForwardRenderTree(this.context));
    },

    setRenderTree: function (tree) {
        //TODO cleanup old pipeline
        this.renderTree = tree;
        this.context.requestRedraw("Pipeline changed");
    },

    createRenderTarget: function(opt) {
        return new Targets.GLRenderTarget(this.context, opt);
    },

    createScaledRenderTarget: function(maxDimension, opt) {
        return new Targets.GLScaledRenderTarget(this.context, maxDimension, opt);
    },

    getShaderProgram: function(name) {
        if (!this.shaders[name] || !this.shaders[name].isValid()) {
            this.shaders[name] = this.context.programFactory.getProgramByName(name);
        }

        return this.shaders[name];
    },

    createFullscreenQuad: function() {
        return new FullScreenQuad(this.context);
    },

    createSceneRenderPass: function(target) {
        return new ForwardRenderPass(this, target || this.context.canvasTarget);
    }
});

module.exports = GLRenderInterface;


},{"./base/fullscreenquad.js":113,"./base/rendertarget.js":116,"./constants.js":120,"./render-passes/forward.js":141,"./render-trees/forward.js":151}],139:[function(require,module,exports){
/**
 * @constructor
 */
var BaseRenderPass = function (renderInterface, output, opt) {
    this.renderInterface = renderInterface;
    this.output = output;
    opt = opt || {};
    this.inputs = opt.inputs || {};
    this.id = opt.id || "";
    this.prePasses = [];
    this.postPasses = [];
    this.processed = false;
};

XML3D.extend(BaseRenderPass.prototype, {
    addPrePass: function (pass) {
        if (this.prePasses.indexOf(pass) === -1) {
            this.prePasses.push(pass);
            pass.postPasses.push(this);
        }
    },

    removePrePass: function (pass) {
        var idx = this.prePasses.indexOf(pass);
        if (idx !== -1) {
            this.prePasses.splice(idx, 1);
            pass.postPasses.splice(pass.postPasses.indexOf(this), 1);
        }
    },

    clearPrePasses: function () {
        var i = this.prePasses.length;
        while (i--)
            this.removePrePass(this.prePasses[i]);
    },

    setProcessed: function (processed) {
        if (this.processed && !processed) {
            var i = this.postPasses.length;
            while (i--)
                this.postPasses[i].setProcessed(false);
        }
        this.processed = processed;
    },

    renderTree: function (scene) {
        if (this.processed)
            return;
        this.processed = true;
        var i = this.prePasses.length;
        while (i--)
            this.prePasses[i].renderTree(scene);
        this.render(scene);
    },

    /**
     * Reads pixels from the pass's target
     *
     * @param {number} glX OpenGL Coordinate in the target
     * @param {number} glY OpenGL Coordinate in the target
     * @returns {Uint8Array} pixel data
     */
    readPixelDataFromBuffer: (function () {
        var c_data = new Uint8Array(8);

        return function (glX, glY, target) {
            var gl = this.renderInterface.context.gl;
            var scale = target.getScale();
            var x = glX * scale;
            var y = glY * scale;

            target.bind();
            try {
                gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, c_data);
                target.unbind();
                return c_data;
            } catch (e) {
                XML3D.debug.logException(e);
                target.unbind();
                return null;
            }
        }
    }())

});

module.exports = BaseRenderPass;


},{}],140:[function(require,module,exports){
var BaseRenderPass = require("./base.js");
var FullscreenQuad = require("../base/fullscreenquad.js");

var BoxBlurPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
    this._program = this.renderInterface.context.programFactory.getProgramByName("boxblur");
    this._screenQuad = new FullscreenQuad(this.renderInterface.context);
    this._uniformsDirty = true;
};

XML3D.createClass(BoxBlurPass, BaseRenderPass);

XML3D.extend(BoxBlurPass.prototype, {
    render: (function () {
        return function () {
            var gl = this.renderInterface.context.gl;
            var target = this.output;

            target.bind();
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.disable(gl.DEPTH_TEST);

            this._program.bind();
            this._setNonVolatileShaderUniforms();

            this._screenQuad.draw(this._program);

            this._program.unbind();
            target.unbind();
        }
    }()),

    _setNonVolatileShaderUniforms: (function () {
        var uniforms = {};
        var uniformNames = ["canvasSize", "sInTexture", "blurOffset"];

        return function () {
            if (!this._uniformsDirty)
                return;

            var program = this._program;
            var target = this.output;

            uniforms["canvasSize"] = [target.width, target.height];
            uniforms["sInTexture"] = [this.inputs.buffer.colorTarget.handle];
            uniforms["blurOffset"] = [1.0, 1.0];
            program.setSystemUniformVariables(uniformNames, uniforms);

//                this._uniformsDirty = false;
        }
    })()
});

module.exports = BoxBlurPass;


},{"../base/fullscreenquad.js":113,"./base.js":139}],141:[function(require,module,exports){
var SceneRenderPass = require("./scene-pass.js");
var ObjectSorter = require("../../renderer/tools/objectsorter.js");
var mat4 = require("gl-matrix").mat4;

var ForwardRenderPass = function (renderInterface, output, opt) {
    SceneRenderPass.call(this, renderInterface, output, opt);
    this.sorter = new ObjectSorter();
    this.lastRenderStats = {};
};

XML3D.createClass(ForwardRenderPass, SceneRenderPass);

XML3D.extend(ForwardRenderPass.prototype, {


    render: (function () {
        /**
         * @type mat4
         */
        var c_worldToViewMatrix = mat4.create();
        var c_viewToWorldMatrix = mat4.create();
        var c_projectionMatrix = mat4.create();
        var c_programSystemUniforms = ["viewMatrix", "viewInverseMatrix", "projectionMatrix", "cameraPosition", "coords", "ssaoMap", "width"];

        return function (scene) {
            var gl = this.renderInterface.context.gl, count = {
                    objects: 0,
                    primitives: 0
                }, target = this.output, systemUniforms = scene.systemUniforms, width = target.getWidth(), height = target.getHeight(), aspect = width / height;

            target.bind();
            this.setGLStates();

            scene.updateReadyObjectsFromActiveView(aspect);
            scene.getActiveView().getWorldToViewMatrix(c_worldToViewMatrix);
            scene.getActiveView().getViewToWorldMatrix(c_viewToWorldMatrix);
            scene.getActiveView().getProjectionMatrix(c_projectionMatrix, aspect);

            var sorted = this.sorter.sortObjects(scene.ready, c_worldToViewMatrix);

            systemUniforms["viewMatrix"] = c_worldToViewMatrix;
            systemUniforms["viewInverseMatrix"] = c_viewToWorldMatrix;
            systemUniforms["projectionMatrix"] = c_projectionMatrix;
            systemUniforms["cameraPosition"] = scene.getActiveView().getWorldSpacePosition();
            systemUniforms["coords"] = [target.width, target.height, 1];

            if (this.inputs.ssaoMap)
                systemUniforms["ssaoMap"] = [this.inputs.ssaoMap.colorTarget.handle];

            //Render opaque objects
            for (var i in sorted.zLayers) {
                var zLayer = sorted.zLayers[i];
                gl.clear(gl.DEPTH_BUFFER_BIT);
                for (var program in sorted.opaque[zLayer]) {
                    this.renderObjectsToActiveBuffer(sorted.opaque[zLayer][program], scene, target, systemUniforms, c_programSystemUniforms, {
                        transparent: false,
                        stats: count
                    });
                }
                if (sorted.transparent[zLayer].length) {
                    for (var k = 0; k < sorted.transparent[zLayer].length; k++) {
                        var objectArray = [sorted.transparent[zLayer][k]];
                        this.renderObjectsToActiveBuffer(objectArray, scene, target, systemUniforms, c_programSystemUniforms, {
                            transparent: true,
                            stats: count
                        });
                    }
                }
            }

            scene.lights.changed = false;
            target.unbind();
            this.lastRenderStats.count = count;
        }
    }()),

    getRenderStats: function () {
        return this.lastRenderStats;
    }

});


module.exports = ForwardRenderPass;


},{"../../renderer/tools/objectsorter.js":110,"./scene-pass.js":147,"gl-matrix":1}],142:[function(require,module,exports){
var SceneRenderPass = require("./scene-pass.js");
var ObjectSorter = require("../../renderer/tools/objectsorter.js");
var mat4 = require("gl-matrix").mat4;

/**
 * @param {GLRenderInterface} renderInterface
 * @param {string} output
 * @param {RenderLight} light
 * @param {*} opt
 * @extends {SceneRenderPass}
 * @constructor
 */
var LightPass = function (renderInterface, output, light, opt) {
    SceneRenderPass.call(this, renderInterface, output, opt);
    this.light = light;
    this.program = null;
};

XML3D.createClass(LightPass, SceneRenderPass, {

    init: function (context) {
        this.sorter = new ObjectSorter();
        this.program = context.programFactory.getProgramByName("light-depth");
    },

    renderScene: function() {
        this.render(this.light.scene);
    },

    render: (function () {
        var c_viewMat_tmp = mat4.create();
        var c_projMat_tmp = mat4.create();
        var c_programSystemUniforms = ["viewMatrix", "projectionMatrix"];

        return function (scene) {
            var gl = this.renderInterface.context.gl, target = this.output, width = target.getWidth(), height = target.getHeight(), aspect = width / height, frustum = this.light.getFrustum(aspect), program = this.program;

            target.bind();
            gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            var count = {objects: 0, primitives: 0};

            this.light.model.getLightViewMatrix(c_viewMat_tmp);
            frustum.getProjectionMatrix(c_projMat_tmp, aspect);

            scene.updateReadyObjectsFromMatrices(c_viewMat_tmp, c_projMat_tmp);
            var objects = this.sorter.sortObjects(scene.ready);

            var parameters = {};
            parameters["viewMatrix"] = c_viewMat_tmp;
            parameters["projectionMatrix"] = c_projMat_tmp;

            //Render opaque objects
            for (var i in objects.zLayers) {
                var zLayer = objects.zLayers[i];
                gl.clear(gl.DEPTH_BUFFER_BIT);
                for (var prg in objects.opaque[zLayer]) {
                    this.renderObjectsToActiveBuffer(objects.opaque[zLayer][prg], scene, target, parameters, c_programSystemUniforms, {
                        transparent: false,
                        stats: count,
                        program: program
                    });
                }
            }

            // Do not render transparent objects (considered to not throw shadows
            target.unbind();
            return {count: count};
        }
    }())
});

module.exports = LightPass;


},{"../../renderer/tools/objectsorter.js":110,"./scene-pass.js":147,"gl-matrix":1}],143:[function(require,module,exports){
var BaseRenderPass = require("./base.js");
var vec3 = require("gl-matrix").vec3;
var mat4 = require("gl-matrix").mat4;
var mat3 = require("gl-matrix").mat3;

var PickNormalRenderPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
};

XML3D.createClass(PickNormalRenderPass, BaseRenderPass, {
    render: (function () {
        var c_modelViewProjectionMatrix = mat4.create();
        var c_worldMatrix = mat4.create();
        var c_normalMatrix3 = mat3.create();
        var c_uniformCollection = {
                envBase: {},
                envOverride: null,
                sysBase: {}
            }, c_systemUniformNames = ["modelViewProjectionMatrix", "modelViewMatrixN"];

        return function (object, viewMatrix, projMatrix) {
            var gl = this.renderInterface.context.gl, target = this.output;

            target.bind();
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.BLEND);

            if (viewMatrix && projMatrix) {
                object.updateModelViewMatrix(viewMatrix);
                object.updateModelViewProjectionMatrix(projMatrix);
            }

            object.getModelViewProjectionMatrix(c_modelViewProjectionMatrix);

            object.getWorldMatrix(c_worldMatrix);
            if (!XML3D.math.mat3.normalFromMat4(c_normalMatrix3, c_worldMatrix)) {
                mat3.identity(c_normalMatrix3);
            }

            var program = this.renderInterface.context.programFactory.getPickingNormalProgram();
            program.bind();

            c_uniformCollection.sysBase["modelViewProjectionMatrix"] = c_modelViewProjectionMatrix;
            c_uniformCollection.sysBase["modelViewMatrixN"] = c_normalMatrix3;

            program.setUniformVariables(null, c_systemUniformNames, c_uniformCollection);
            object.mesh.draw(program);

            program.unbind();
            target.unbind();
        }
    }()), /**
     * Read normal from picking buffer
     * @param {number} glX OpenGL Coordinate of color buffer
     * @param {number} glY OpenGL Coordinate of color buffer
     * @returns {Object} Vector with normal data
     */
    readNormalFromPickingBuffer: (function () {
        var c_pickVector = vec3.create();
        var c_one = vec3.fromValues(1, 1, 1);

        return function (glX, glY) {
            var data = this.readPixelDataFromBuffer(glX, glY, this.output);
            if (!data) {
                return null;
            }
            c_pickVector[0] = data[0] / 254;
            c_pickVector[1] = data[1] / 254;
            c_pickVector[2] = data[2] / 254;

            vec3.scale(c_pickVector, c_pickVector, 2);
            return vec3.subtract(vec3.create(), c_pickVector, c_one);
        }
    }())
});


module.exports = PickNormalRenderPass;


},{"./base.js":139,"gl-matrix":1}],144:[function(require,module,exports){
var BaseRenderPass = require("./base.js");
var mat4 = require("gl-matrix").mat4;
var ObjectSorter = require("../../renderer/tools/objectsorter.js");

var PickObjectRenderPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
    this.sorter = new ObjectSorter();
};
XML3D.createClass(PickObjectRenderPass, BaseRenderPass);

XML3D.extend(PickObjectRenderPass.prototype, {
    render: (function () {
        var c_mvp = mat4.create(), c_uniformCollection = {
                envBase: {},
                envOverride: null,
                sysBase: {}
            }, c_systemUniformNames = ["id", "modelViewProjectionMatrix"];

        return function (objects, viewMatrix, projMatrix) {
            var gl = this.renderInterface.context.gl, target = this.output;
            target.bind();
            var sortedObjects = this.sorter.sortObjects(objects, viewMatrix);

            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.BLEND);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            var program = this.renderInterface.context.programFactory.getPickingObjectIdProgram();
            program.bind();
            var objCount = 0;
            for (var j = 0, n = sortedObjects.zLayers.length; j < n; j++) {
                var zLayer = sortedObjects.zLayers[j];
                gl.clear(gl.DEPTH_BUFFER_BIT);
                for (var ind in sortedObjects.opaque[zLayer]) {
                    var objs = sortedObjects.opaque[zLayer][ind];
                    for (var i=0; i < objs.length; i++) {
                        var obj = objs[i];
                        var mesh = obj.mesh;

                        if (!obj.visible)
                            continue;

                        if (viewMatrix && projMatrix) {
                            obj.updateModelViewMatrix(viewMatrix);
                            obj.updateModelViewProjectionMatrix(projMatrix);
                        }

                        obj.getModelViewProjectionMatrix(c_mvp);

                        var objId = ++objCount;
                        obj.pickId = objId;
                        var c1 = objId & 255;
                        objId = objId >> 8;
                        var c2 = objId & 255;
                        objId = objId >> 8;
                        var c3 = objId & 255;

                        c_uniformCollection.sysBase["id"] = [c3 / 255.0, c2 / 255.0, c1 / 255.0];
                        c_uniformCollection.sysBase["modelViewProjectionMatrix"] = c_mvp;

                        program.setUniformVariables(null, c_systemUniformNames, c_uniformCollection);
                        mesh.draw(program);
                    }
                }

            }
            program.unbind();
            target.unbind();
        };
    }()),

    /**
     * Reads pixels from the screenbuffer to determine picked object or normals.
     *
     * @param {number} x Screen Coordinate of color buffer
     * @param {number} y Screen Coordinate of color buffer
     * @param {Array} objects List of objects that were rendered in the previous picking pass
     * @returns {RenderObject|null} Picked Object
     */
    getRenderObjectFromPickingBuffer: function (x, y, objects) {
        var data = this.readPixelDataFromBuffer(x, y, this.output);

        if (!data)
            return null;

        var result = null;
        var objId = data[0] * 65536 + data[1] * 256 + data[2];

        if (objId > 0) {
            for (var i=0; i < objects.length; i++) {
                if (objects[i].inFrustum && objects[i].pickId === objId) {
                    result = objects[i];
                    break;
                }
            }
        }
        return result;
    }
});

module.exports = PickObjectRenderPass;


},{"../../renderer/tools/objectsorter.js":110,"./base.js":139,"gl-matrix":1}],145:[function(require,module,exports){
var BaseRenderPass = require("./base.js");
var mat4 = require("gl-matrix").mat4;
var vec3 = require("gl-matrix").vec3;

var PickPositionRenderPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
    this.objectBoundingBox = new XML3D.Box();
};
XML3D.createClass(PickPositionRenderPass, BaseRenderPass, {
    render: (function () {

        var c_modelMatrix = mat4.create();
        var c_modelViewProjectionMatrix = mat4.create(), c_uniformCollection = {
                envBase: {},
                envOverride: null,
                sysBase: {}
            }, c_systemUniformNames = ["bbox", "modelMatrix", "modelViewProjectionMatrix"];

        return function (obj, viewMatrix, projMatrix) {
            var gl = this.renderInterface.context.gl, target = this.output;

            target.bind();
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.BLEND);

            if (viewMatrix && projMatrix) {
                obj.updateModelViewMatrix(viewMatrix);
                obj.updateModelViewProjectionMatrix(projMatrix);
            }
            obj.getWorldMatrix(c_modelMatrix);

            obj.getObjectSpaceBoundingBox(this.objectBoundingBox);
            this.objectBoundingBox.transformAxisAligned(c_modelMatrix);

            var program = this.renderInterface.context.programFactory.getPickingPositionProgram();
            program.bind();
            obj.getModelViewProjectionMatrix(c_modelViewProjectionMatrix);

            c_uniformCollection.sysBase["bbox"] = this.objectBoundingBox.data;
            c_uniformCollection.sysBase["modelMatrix"] = c_modelMatrix;
            c_uniformCollection.sysBase["modelViewProjectionMatrix"] = c_modelViewProjectionMatrix;

            program.setUniformVariables(null, c_systemUniformNames, c_uniformCollection);
            obj.mesh.draw(program);

            program.unbind();
            target.unbind();
        };
    }()),

    readPositionFromPickingBuffer: (function () {

        var c_vec3 = vec3.create();

        return function (x, y) {
            var data = this.readPixelDataFromBuffer(x, y, this.output);
            if (data) {

                c_vec3[0] = data[0] / 255;
                c_vec3[1] = data[1] / 255;
                c_vec3[2] = data[2] / 255;

                var size = this.objectBoundingBox.size();
                vec3.mul(c_vec3, c_vec3, size.data);
                return vec3.add(vec3.create(), c_vec3, this.objectBoundingBox.min.data);
            } else {
                return null;
            }
        }
    }())
});

module.exports = PickPositionRenderPass;


},{"./base.js":139,"gl-matrix":1}],146:[function(require,module,exports){
var SceneRenderPass = require("./scene-pass.js");
var ObjectSorter = require("../../renderer/tools/objectsorter.js");
var mat4 = require("gl-matrix").mat4;

/**
 * @param {GLRenderInterface} renderInterface
 * @param {string} output
 * @param {RenderLight} light
 * @param {*} opt
 * @extends {SceneRenderPass}
 * @constructor
 */
var PointLightPass = function (renderInterface, output, light, opt) {
    SceneRenderPass.call(this, renderInterface, output, opt);
    this.light = light;
    this.program = null;
};

XML3D.createClass(PointLightPass, SceneRenderPass, {

    init: function (context) {
        this.sorter = new ObjectSorter();
        this.program = context.programFactory.getProgramByName("light-depth");
    },

    renderScene: function() {
        this.render(this.light.scene);
    },

    render: (function () {
        var c_viewMat_tmp = mat4.create();
        var c_projMat_tmp = mat4.create();
        var c_programSystemUniforms = ["viewMatrix", "projectionMatrix"];

        return function (scene) {

            var gl = this.renderInterface.context.gl, target = this.output, width = target.getWidth(), height = target.getHeight(), aspect = width / height, frustum = this.light.getFrustum(aspect), program = this.program;
            for (var side = 0; side < target.glSides.length; side++) {
                //calculate rotationmatrix for that face
                var mat_rot = new XML3D.Mat4();

                if (side == 0) { //look into +x o
                    mat_rot.m11 = 0;
                    mat_rot.m12 = 0;
                    mat_rot.m13 = -1;
                    mat_rot.m21 = 0;
                    mat_rot.m22 = -1;
                    mat_rot.m23 = 0;
                    mat_rot.m31 = -1;
                    mat_rot.m32 = 0;
                    mat_rot.m33 = 0;

                } else if (side == 1) { //look into -x
                    mat_rot.m11 = 0;
                    mat_rot.m12 = 0;
                    mat_rot.m13 = 1;
                    mat_rot.m21 = 0;
                    mat_rot.m22 = -1;
                    mat_rot.m23 = 0;
                    mat_rot.m31 = 1;
                    mat_rot.m32 = 0;
                    mat_rot.m33 = 0;

                } else if (side == 2) { //look into +y
                    mat_rot.m11 = 1;
                    mat_rot.m12 = 0;
                    mat_rot.m13 = 0;
                    mat_rot.m21 = 0;
                    mat_rot.m22 = 0;
                    mat_rot.m23 = -1;
                    mat_rot.m31 = 0;
                    mat_rot.m32 = 1;
                    mat_rot.m33 = 0;

                } else if (side == 3) { //look into -y
                    mat_rot.m11 = 1;
                    mat_rot.m12 = 0;
                    mat_rot.m13 = 0;
                    mat_rot.m21 = 0;
                    mat_rot.m22 = 0;
                    mat_rot.m23 = 1;
                    mat_rot.m31 = 0;
                    mat_rot.m32 = -1;
                    mat_rot.m33 = 0;

                } else if (side == 4) { //look into +z
                    mat_rot.m11 = 1;
                    mat_rot.m12 = 0;
                    mat_rot.m13 = 0;
                    mat_rot.m21 = 0;
                    mat_rot.m22 = -1;
                    mat_rot.m23 = 0;
                    mat_rot.m31 = 0;
                    mat_rot.m32 = 0;
                    mat_rot.m33 = -1;

                } else if (side == 5) { //look into -z
                    mat_rot.m11 = -1;
                    mat_rot.m12 = 0;
                    mat_rot.m13 = 0;
                    mat_rot.m21 = 0;
                    mat_rot.m22 = -1;
                    mat_rot.m23 = 0;
                    mat_rot.m31 = 0;
                    mat_rot.m32 = 0;
                    mat_rot.m32 = 1;
                }

                target.bind(side);

                gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
                gl.enable(gl.DEPTH_TEST);

                var count = {objects: 0, primitives: 0};

                this.light.model.getLightViewMatrix(c_viewMat_tmp);
                //rotate for the apropriate side of the cubemap
                XML3D.math.mat4.mul(c_viewMat_tmp, mat_rot.data, c_viewMat_tmp);

                frustum.getProjectionMatrix(c_projMat_tmp, aspect);

                scene.updateReadyObjectsFromMatrices(c_viewMat_tmp, c_projMat_tmp);
                var objects = this.sorter.sortObjects(scene.ready);

                var parameters = {};
                parameters["viewMatrix"] = c_viewMat_tmp;
                parameters["projectionMatrix"] = c_projMat_tmp;

                //Render opaque objects
                for (var i in objects.zLayers) {
                    var zLayer = objects.zLayers[i];
                    gl.clear(gl.DEPTH_BUFFER_BIT);
                    for (var prg in objects.opaque[zLayer]) {
                        this.renderObjectsToActiveBuffer(objects.opaque[zLayer][prg], scene, target, parameters, c_programSystemUniforms, {
                            transparent: false,
                            stats: count,
                            program: program
                        });
                    }
                }

                // Do not render transparent objects (considered to not throw shadows
                target.unbind();
            }
            return {count: count};
        }
    }())
});


module.exports = PointLightPass;


},{"../../renderer/tools/objectsorter.js":110,"./scene-pass.js":147,"gl-matrix":1}],147:[function(require,module,exports){
var BaseRenderPass = require("./base.js");
var Options = require("../../../utils/options.js");
var mat4 = require("gl-matrix").mat4;
var mat3 = require("gl-matrix").mat3;

var OPTION_FACECULLING = "renderer-faceculling";
var OPTION_FRONTFACE = "renderer-frontface";

Options.register(OPTION_FACECULLING, "none");
Options.register(OPTION_FRONTFACE, "ccw");

/**
 * @constructor
 */
var SceneRenderPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
    /**
     * @type {function}
     */
    this.setFaceCulling = getGlobalFaceCullingSetter(Options.getValue(OPTION_FACECULLING));
    /**
     * @type {function}
     */
    this.setFrontFace = getGlobalFrontFaceSetter(Options.getValue(OPTION_FRONTFACE));

    var that = this;
    Options.addObserver(OPTION_FACECULLING, function (key, value) {
        that.setFaceCulling = getGlobalFaceCullingSetter(value);
    });
    Options.addObserver(OPTION_FRONTFACE, function (key, value) {
        that.setFrontFace = getGlobalFrontFaceSetter(value);
    });
};

XML3D.createClass(SceneRenderPass, BaseRenderPass, {
    setGLStates: function () {
        var gl = this.renderInterface.context.gl;
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
        this.setFaceCulling(gl);
        this.setFrontFace(gl);
        gl.enable(gl.DEPTH_TEST);
    }, /**
     * @param Array
     */
    renderObjectsToActiveBuffer: (function () {
        var tmpModelMatrix = mat4.create();
        var tmpModelMatrixN = mat3.create();
        var tmpModelView = mat4.create();
        var tmpModelViewProjection = mat4.create();
        var tmpModelViewN = mat3.create();
        var c_objectSystemUniforms = ["modelMatrix", "modelMatrixN", "modelViewMatrix", "modelViewProjectionMatrix", "modelViewMatrixN"];

        return function (objectArray, scene, target, systemUniforms, sceneParameterFilter, opt) {
            var objCount = 0;
            var primitiveCount = 0;
            var stats = opt.stats || {};
            var transparent = opt.transparent === true || false;
            var gl = this.renderInterface.context.gl;
            var program = opt.program || objectArray[0].getProgram();

            if (objectArray.length == 0) {
                return stats;
            }

            if (transparent) {
                gl.enable(gl.BLEND);
                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            }

            // At this point, we guarantee that the RenderObject has a valid shader
            program.bind();

            //Set global data that is shared between all objects using this shader
            program.setSystemUniformVariables(sceneParameterFilter, systemUniforms);

            var prevOverride = null;

            for (var i = 0, n = objectArray.length; i < n; i++) {
                var obj = objectArray[i];
                if (!obj.visible)
                    continue;

                var mesh = obj.mesh;
                XML3D.debug.assert(mesh, "We need a mesh at this point.");

                obj.getWorldMatrix(tmpModelMatrix);
                systemUniforms["modelMatrix"] = tmpModelMatrix;

                obj.getModelMatrixN(tmpModelMatrixN);
                systemUniforms["modelMatrixN"] = tmpModelMatrixN;

                obj.getModelViewMatrix(tmpModelView);
                systemUniforms["modelViewMatrix"] = tmpModelView;

                obj.getModelViewProjectionMatrix(tmpModelViewProjection);
                systemUniforms["modelViewProjectionMatrix"] = tmpModelViewProjection;

                obj.getModelViewMatrixN(tmpModelViewN);
                systemUniforms["modelViewMatrixN"] = tmpModelViewN;

                program.setSystemUniformVariables(c_objectSystemUniforms, systemUniforms);

                program.changeUniformVariableOverride(prevOverride, mesh.uniformOverride);
                prevOverride = mesh.uniformOverride;

                primitiveCount += mesh.draw(program);
                objCount++;
            }

            if (transparent) {
                gl.disable(gl.BLEND);
            }

            program.changeUniformVariableOverride(prevOverride, null);

            program.unbind();
            stats.objects += objCount;
            stats.primitives += primitiveCount;
            return stats;
        }
    }())


});

function getGlobalFrontFaceSetter(mode) {
    if (mode.toLowerCase() == "cw") {
        return function (gl) {
            gl.frontFace(gl.CW);
        };
    }
    return function (gl) {
        gl.frontFace(gl.CCW);
    };
}

function getGlobalFaceCullingSetter(mode) {
    //noinspection FallthroughInSwitchStatementJS
    switch (mode.toLowerCase()) {
        case "back":
            return function (gl) {
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.BACK);
            };
            break;
        case "front":
            return function (gl) {
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.FRONT);
            };
            break;
        case "both":
            return function (gl) {
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.FRONT_AND_BACK);
            };
            break;
        case "none":
        default:
            return function (gl) {
                gl.disable(gl.CULL_FACE);
            };
    }
}

module.exports = SceneRenderPass;

},{"../../../utils/options.js":183,"./base.js":139,"gl-matrix":1}],148:[function(require,module,exports){
var BaseRenderPass = require("./base.js");
var VertexAttributePass = require("./vertexattribute-pass.js");
var GLRenderTarget = require("../base/rendertarget.js").GLRenderTarget;
var FullscreenQuad = require("../base/fullscreenquad.js");
var Options = require("../../../utils/options.js");

var base64RandomNormals = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAnRxJREFUeNoE4XeMpnmCGOb90pvDl3N9lau6qrs6T3dP3tmd3b3bS7yjjqIYZJKwLMKWLcuCSdiwDMg2LEA2DQMGBFiwqT8s+cR4PpG35OaZ2cnTuatD5fjl/L05/IKfB/7D/zX/AfZcU/p/LrtXs1qhr11w9vf7071c7r8KJne98t8ORl+ykvdurNrJl9M0e2h/2OCN5f7PuKXtZr1jHjrJX79KD5j57apf7OunMPgwNMgIWBLnCLC62FOFmOLlCH57HtXqalaHsJmkj6R3i/4/i9Wdq3T1WPw3c/4/rfMxV54tUQZA13Ljnvp3j+S2q+zeTe4eSv9dMt/ck//4J+y4b/vLaeM5/IuF9GOorNQnn9UForgmwDevjdYr7x8epbSo/6NScuOedcvBnxrJ33HoEKq/Mbg+VM5x8LeptKEPP8fVp4UoU0iAHR5fSitutjEnhXooQhykWDg4n4kjRxrNyGs/eZ7t/NXZsh6JRZx+Z0srEEwp3MvE/+Ew/MeuphH0H1Ym51eU/1sr2kGFxUPywoj/QW3WiTP/9UVy5WlsmKpb1wwdIwQcn92RBYQgV2KkQom6JvolgECaU5EbgQ2ZWSfSkBjiAt4bFcyXg8cL9ptbrGQnpaGSpxIVQunirlRmGKxVo9OempmTPU8da/DqwAifMSbocUNcV0GdBd/E5kyniwymCjhNAb4NLSisC5COJDykl2VtpsVE524TVRfRQOfVkxgC8tL1t/JYCUynSlMF6gyZHr3W0cHA+fqrfLQNyvm4VALLA7M7Fotd/TzhVSRZBR/qvHxNT66AiYUziJf6SmkvKLdFV8OjAum/7a5lpJKGx3O8ZAK3EiLO8q56OZXzZ3LTlS9nzLGU20lCLbBHRNOIghzrbNFGLA3Os5Xd2KHgxYIMMUhW0/JjfJpDB6ZdXedBCCZYdSRoV3EuAWoFNruSwzQwYWVDmywS3VRro8Qbp22F46YCFKSmvJuRQQ7iP0z+0zfUPNRRZaqv/BypL9PRSCTXZF0Rd7vuGdBfGSK5Jsg32tWv/flr5HgMRvJhC+oG+UE0SVN9iHDYoa2M0OfY2IBTGVFbbGuirIaHE/UsobUzUs6yaA9IXOrvJ24Rb/XSyoLwvgmPR0n0Ql6LsBEow98AoCmtPmEHsPFTFJ7xbEUGmjhqw+ayADeg+yFJB7JGUNxRmoU434VfKCyVdDohxbbMLjWikLsxRhh8onCQosZArvf9he78eES/ktNRNdkqKllXyvbgwqm/d1ToPBeF71B7N8mFyj0neBVB9E18oxWwzyP3i4h+K7oX+tkCszA2Y/W+m3hc+iLvr04VUYAOxU2KUAhAG/UQ96GWIKyl6sKAhDGscCB6XGGsdUWjVwG5ygZFqXIHOTUi26hsQGCCNEHpPiajqi7e+OpUrU0TtS63BmJhXXozgbU19lal1+TrvzqfSOf4e5ni4lby38dyAnjlBu2H0MMs2FfpqvCvhZsJ1o6UuSaCeryiS+ctdn4kqh/C6gz2fBIOKFNwrwRCQXPLyg2bebfJqyz7Qz+ZnOh/QdrvnFfVCm4paGUlncbQXsL1nPpEFU8o+EHK1hfxZ9n0Rjm67+HLut5+HgOPgnUUX4FKI3Cz7pWDnNFl+8/TbgIlJhdVmbjs/hgvZeL52zr692liwPncUXpG5UAWrxMzjg8Xi5cyu7WukgTGClUQzFxQHKt+LDGb9+oW4DBeBgcgSmeo0NF2Ih4+EOCAZJDiTtLsr4B3DZWpeLXI9C55i5DJDMJLgoW4zIBlKIqLqbcjxeU0ewCTxygNxNoSSX3gzuLllmhruFAmTRbNR4CM3gZ8qLtRmoNy5n4a2mwcA3EgeS15vqFiLSguRdpBSSn6rou1XGTN1PG5jC7TpXYyXVf2ZbA4U662/X/znLGQ0l8noaVklzWrgKKnUrgIVvpYs+CbS6rdksGV0B+K5JCY52GwpFnl6CMq/tlZ9Aojto6kba8z0PQ++r7POhy2XO/dc6Uw6/8yUGYoOSrkqwX16mqcX5N3x/iFRKp92jzIPh/PdiBTNtHZW+JmotoZ7mRYHLGcDzsjab9Jf0KSGiTgwiw+0dW+17dV66YeXUvqQqgJ9HeVZlueTbxQpUYOjLbxaFGaXetZttslSW5mXf188aTF9csEa9osD5Z0Mq9yOSLGBKqCV06k5AqNdnFf54CI2xaYeVC6jI+bSn+Bfz/LbSym98XU5aUArD1yQT+ZZJTTLF6vqB/OJkFeIoPd+E7e1Dja3UjHh7LeELdPw18h+aKXuJ2CdE3TqWzNZO8Z2r2uEy0oatAU4o4C5Tz6KlXOXoY3UilNhP5A11UxOBOUCBdxKQfiPXDuircMPrkGD3mi5+L6vrXQFrrB5RLu0OhFrrR543Itql1MQRpFW4GUS4W6TMlzgAWAHJB3ZSm28t1sOo2kAPoS7BYIArxSRvANH3dBGiVlqCiGmMwxXY58yPgplh6xUgzzZtgrmeRnvM3yByFrXJF3NElbSx1Cws2kO8O/04fmC++/V1jDVtUdeyRTU4dH2D+DeuYXtS6rybtJIUM45zUJ0fvqywm4mmfsHP4LNXy3YNYpPwuQtO+h1xAn7Fpe/q6GBpe45IQXEunHNAWifZm9Wp5Bbj4dQdXmsz+RoYHVoVJ9Ced77KBWtH44I0t/zI0Tpn5JkzEbRfE7h/JUx7abhCX8BGe8Mcx7ZMeDZpx+eYaDtlSvSysiSmX0zTW1m4nKkqRmw+ww8vKyvqf9LvL+0ShKwvhPg1xwj/RmsWohJSbAQ1uvdfraOVszIpOsfhiABBzXk0Uo1pec9ihJdq3iU8PRAG8m2bdnSWChU2QPQdKA4VJcdeT2CfPCcP3XkGcIxUgUEVuBVoP1tKTv6FEbZV/IDQmKkJ5dx2aLsEVxMEi/LwHTD/9iCdlXYZ0LeonHg1R8DpcDVMp6B+vZYlVkDd7qIzgDo3MwK1AQSzIT2eOECyAPE3xNneeAUmSrXRgMwB7nN8ckgNFQI1sNtv+BGbticCvBYykKkwIl5YwY5UT+kbTXD8+IVFb0YCI3zllURlMTVSuzsBBk5IxyKF1WYSaLCH1pxFlw9Vb6PNLSN7Ffk0eLoFhI+5j2taQkUE3i/kARtmAdYfWJ9Eh4CGp1ATCgmG/vq3zIDkJJJ6Qw98KMUDEp2Ho3kYNvxWqWjM/Y50W6M1BW2tOvdCmwOKsznUg5Jqq/UXsHKIbylYI8iFngxtOiFByDZMvwgLKTIO2p8+Zz5l6F9ia6V4HHI9ItAr6IBAMLxWgvVA7HfGWWteqxHnN1C784YQ9uQIwE3wIYMFDA9WvBianM+079yAQzHi0idJuXejIbiVFWC7aTgRytvMlcf52c6FJY4RlDsUKxBoPdht66wrYvpJMEKF9G9TCZQBzfNGmd3gzIdy18UEiu21yXyLGVVhBfLsXyWPEmMDiWXqtgjcB1Vz0Q3odTvNigJ5s4mICjh2n6tFRbBrWGD4vi512IvrNI5uc+XTQ678iJGRmbaKWX/NxDUCMrETw6Z42RGNrydAX87pQqR+Q3TnAsqSur/GRBvhzHd79RS4f9U6iwH+eaJltW2XPZmOTPt+SSNwDTgVTKMeBiEwDtJpdN6Fpe2KO3upnZ1+o8jrbxzCnJR0q6M4Ymhwc6LMwYyaJXz5TsXVDapOYNaF6a4gS8iIKrGY28FQmZU5Uu9NT4THpJo2ZRrrpi/FK2Q14toM4GE1goLxAtopGv2jXITmS3qOk0/ngvkKb+Ly4Usm2tJ1R0418QpX8W/U1Jk4LkuKGgFTaIA4NJjXH4hmgnayyrimItsc7wL2qooVnZVf5vy6PNebZcmXl6Lq174kJXsAh9Fj9VtSmTJskgBVwk9wURiB2bYlaOxlq+b0IQgW1OxSWYB/PzV5AsmNeCaU3JviQx4b9rjS+F8RjzDYA34/wE1nva/nP3A1lbzhDHT3gOd2fJyFCuotmrTDYexR2h7e+J23UlUxf8er6Jwb8y3BqRd2znWALKVL9DpUsPy/U04rC34FXOTLsLjng2yvmlQJXGsNaJowmdFMjFTSNZ6VMVqBEu9VU6RTFL4yvkLIQGE7HOc9uzilY6uXAziZFq8iFMPzjS8lHaSmE9ryRnIjRhaoDwDh2OscqQdc40CQ6gUCmTQunS04rn6UKqGnLy6vu1wWz2ICaA0va2ERbj9XN9wsR0GRWawTGEpZfaSht5Mi8S1t1Hbi+mBdRqSNIDL8vS9lQLPkMb/fRsrdDO+u++KU0DOlCxWUPNCbLNNEnAeEl9vUgSja4NybtfsfkxaLF4tKHChlg23fPt3PgScoscKHDrI0JUBigjd0Typqw8PY0Wf81OfpOe38revpEcRwp5A6UNmGXEicXs2Sh9UIveRrrEzC81uBumCe25Rr6Ekhx/IUGtpZQUyfWysikbh9jxZCDgrC4JSWSQes1N+mM5eu5nbBhqqbUF4D1MIvWVLkKd5yPD1VBeYnDbyU1UN0B6GyAKTh+KbN2Wq3Hj+iS3yCZvhPE1VAOgKSkpcoChuZ+O0/S0qmxdQemp0jyi8jx52lS0DbE1ByclmVww9A7tMAJMKpmxbUzzUwim/JChlYazPyS+RjINeu7IakiktmTn+eJMECqezRDjbC3m0ZBFIZ53QRtrSyNv1UMOT1unkNRQcx4HHEYoTQK4OAwNkT7CRrsY3UgkXEuicgBuM/JaNU+1+WUaT4Gfk9O7ifQOvf9GunzGvv65OV3HugFI9qErLDLeTD5YMFuefBzD+0BUUqV7F1jfsmYteX0IpzdQcsKop2BPUj9KOhN1fY70N/RXw/AGMlYWKbTghRKXPb0agRUgC1U4Y84kOJmxhaE0wkJaYZsVZXAJ2557xrXiQrjJEi+UfnPCM5eSOueHkrxew5LLXgk2AKhQIdkcoS+T8VjxPyOlDQgxMNbR0lDNTd1vEqu7lb5/m36p8e7UX8V606HdVWmGSVSgicp3Eq5g8kZHg4GSnXP9Nvx1mAGC/u6FOiPwzSlfODfhKGneB8eh7Mn8wS9jkYiUCyUL2pIsraKNPJ3Y6lPE/YTfvDAhEXxZazTBJRdkKmkO4AaxIhakEB1GdhZ28sb5jWCJq/ld8OwvYQNp9T9EuXyypjsj1zqO/eMlQ26jnEFK30wGxPosnVan+UWhEP5AKbSgk8bQNFYr+LuXrnVu3xPpnJNXRXh7KUbX9MJYX7wMjr+iEEaxayfL6G4Y/mVFmadpLsO/64pMDr53IAU6wq/TnEGfUMireO0Zi9xE703mN0vnLvr4B/OMZQvAg5Ho9JXqLK3uuS9HxAiZKlgA4Nklv1ZW8r4It+R4wEa32RWZxAxGPVH7MuIqhkzEZaXvEwVy8QLuvyOJKTYgDcZErPkVOerowOvImx212hudzTIa5LM5d6bJxhfBLhHrGdPYYt9OxPVhmsVM6rjzca4fRzt3c3ZNuK7UhUn7upTJxbirDA6xq4DgPVctBQsr+HJudhKIsklEkkXLYAFS97hUEtYlcre0VzWyKCUwwqNv2MfNuJfXfAyf/RMvrpKsna4TvrsAL47Axix+PkuTD8zF5cRAkn/GBAPkIjSADhnnu3240xCNd6XSIZ9l8PmRqL1P6QmZIGEeygulsU8K/3olXeiI0kykGsrfoh0X+lwAJCwFNCZe7zGdjKLp3eqwQasPouyuaim6lxjTUFAmvN9YVhObVJu6fOsVLwgHAuE1zaCM35IYp9I4J6wwNhTtq9b01mpOj0C6wophEm9it2/S55RCuHQ+z2+p/yx1QRnp+2beI4YlS+c07avRBZVVgqPUMigFsBFEraLer9HfL2J6nD1PHTSHCwVUNaXyXbrLjJULC0zYN2y2w8B8nei5pKJSeC4rn2Ec046Eu4t0fASKx/maFMOZ/LQkGg8VeYm5IbabSbxBsw79wIv/7VDae+LXDSJ7CawZvk7qa1B0+RMoWor/ZqOA1gI9Zvnv0GYheJ61/7IR3+bSu/vmo+NwImISXo2yZnCtnSldoIO2aMvJTxR4iGV6ixGHXFRgtktqvxNMUtxdmlQ5K4sg62gv7Wh+bl/LKfgh8vJx5jHWm8zfzClbYdAH2T2C/1t+voZXQ56WxKTLvGu0O9M4BdlILiKMl1CvYDfN+a1E+oQGT5ZQtjJPYuJ35Cylq8IeZOJgwrdjuXLgj+zsuRAfvE2/w/IszFcXomyKtrg6/xZkj3xvHjlCvJjrzbp6g6f/LCumKsE3kq6myiSwOsocwcyH/qKvEDN9NIc3eQz1pDtFf+Ot2aNW2eklUiL2O/pJxq+60uphnERiUtDkNT6XQtTGzUBuc1wfuOo888yL3jlSZhN6sMeX7pEon0i/z+Spfhomcl281c0dxuD8i6hWSSeWDH9oGUFwMkALgbkwBbk8F6diWEz7n7gfG7mycL/Ik6mRkl4pMGfyCpXUBFxCpjxE+r049xSfZVC4H2v3ZEdlnR7o1LVSX0gtg3SUcj/9JmOtHaclSVx0ZjAvhgV5XpJQ3R/ZSX6oLK3DUyIbBkAxSF8LrU7mQ4abVBUgDOjOAVdmSWcfT+8UuxZAGR5daAvn6rgLo8U0JaiuorPXnKapPQdzVYW+uPXGC3UcdiaZv5M/nUh+c1r92twYh24YRylrrZtxE5sPkrrPzQAbz/nsYaazrFqyyBygSwROF627WHy3x+cea9rpaWzpl6mehdEoLRbMQcTcmSieKSqB0mYUfJy+0kIFwpW+jriS7dO2gqyr2vo5Q0DuH4UsL2sT9vAr9IMlrX6tXxeZ1lIaPM9667S/x6/+oTSxaWp7OZmfnHH9GFZ/MxCTtCdJ8k42myLf1o+hXLPCD8/kR78d4t9t/+/zT7nahrNFqaPQmqZ5Z7IJxeowfg3BRYJkDWdbsv5Ygq+kyYzIBDUs1kpRri5Xivz0lq5jtcHhqxYBz0nupTr1sHLHi29NNwOlMkmPM/JFPsIR2vqS0kNxNIrfi2gAyecQbEJUC3nrjAwuo/yeWE74qE9OILiSYxzKXZLcPGJkFR2r8uJN5mJtb1tmAzQ5p2bb3Fxm5H4c/gFNf0QGN6MklvMjbaHN6Ujd3O31T5Jfn44+nBs6FWcxlw9ouQ+8Pp/ytGrq/QYkH8RX1XBcs3sKRDahRVjgGE2pZ6rzmSrP1XRfmwegYaDNIJ1PRBoTpCM+5fOKRFREbxP7hJEube8ZpaPY+yVFTyelFxRMyXlFvlCYkU9DX84o5EYxgdeU6IFNl6x4G7QMWjFVRYPdBXy1EhmoQOYyGi8ZqQL9FFQ72KhAGjJ4D0RE4hatXcrsZdoTdDrhyX09WIofhBT64MIKa9fATI0VhRtL5rgvG6ekmmHOPp+YPPqviV6sKCxlGQhCUXkDfIV3lrRIgzUi8WJoc56/QkefaPlBys7n8rpZXFOg4O55qozY4UhrRhTE6i7iqC2rV1mu5Ly85WSltHpRlM/l/nkaPsJg03jOyV07KZ4VRhc806cXtqxgUfsTdCYVaTy1WuK0TOQDtqqi50LgDLktyd+cxIqm1D3SK8l56i8fmoNhkmZAbo2gdfxsyt46FtmE/8oNFkzDKoPRogzW4KQPGxW6eCN9aaY5T12ZS+qKjB0+ZPBKg4Z6rn1Fhxy1eFr7BvGeJPY1TQWeyhwFaDfHDcqLlv7rr/RZOb0OlEEA/ITgrRj/L3v4w//4/yTrMCe48yo90hMu4coO7MrAFkDX4PQSbwdUTPhsSxtj4A1FfUgmBmlZad3RtXO109c2Q1gsRWgqZRMaDsVzOYYAbzssKSnpFXC8HWmbeB0qwIC+IuQJjIUS9clFKjUV2Lg/3fsBBCW8ACQVCCVLRIrPhq5qK5kCHt8DlECR59K5Ec+M+XO7gpHh40BGKMH+FA4u0eKukp3gWpeVB+5XEuyui9pHw9FiwKv0fQ88d/WVRJSW+D9fGm3ck+9i6h7Cs70x/TJZlu0oVDK2MM/R/szNHZGtIN3rcM2WqxZ/vomcrFj3ke2xICGbQfj5FO/poJwFwkxvvYLwCutr0vR7fpXiaDNlp/q1PjiYkYuGVynJtTdsMGTGcRopysmedmMoiq/j52U97rAPHY6/mn/leE4rX05yZGkOwEnaH1B+Q0dZ7lsJkCU5gWMfLz1JxBKcPiBLc/yrYTobRe9xK1tMOxeyIcuzTqpwUFWRGzLqim3UP2D64XXj/Tk52wSzKQYKaHVB0zHkhaSngeIRTwaRYUoOI7UyM6bk9X13LRTIV/Q9LauzQYYYhSR3DZC+PsxTVYYkgtoM+RfifAVtPktAjFtPU/ttvO7ipUzybRedFd2/QnUa8SMF07fyXhJVeuTo/7E8s9HvO6FTAedpdHeHpyPJp2E8LtuWs/2u9dLJXAasl5MpAlcizypo6gnwvfi5beSycMuOnwWKZ3hXc/baPPjWM954wcY1sOiTx9NUG6k1E7Nq5DNsyiI9M0aQF38KlSNv3B1fbpDNXPmeyfeykmfxuiNdJLwVBuwmZVdSpeCoJ6oyEItXNYsJsD9FX81IbjGId5jQATAHoCUDV56M8I12osRs9sY/IJlIiL+94eUahtNHV724uwtOElfVJLitCgVwAJvHiUioh7XuDatb86+mWnomLnX2Vk7M5vj4PGmekuJVsfAgyvTU5zGIY3YlBFKP73V4H2a+57DzJD2TEMmL4jH0ZanJwPSr8DlJ76YKXSEHcqIbSr0RnBjZToeudoTw2SuARR1VJaOTJdUwfUsJplN5ErjKXDaYpLdZWkQdbKxYcFD1Jgm+ni6k/zZ9vpNfeH9QsqjaylU+jV924DArz+4g6V1ITK7P0jkQo65UmoK0LSYhyxbDcM0wZOytzntTYMiR9KXS3EuSOnkigZVbUX5PYxmwkE/m/2M8MYtaGLSPk/HILK7ycynhedA40OZC2d831hue1jE2fKTknEfvcAzDm6+LV76j+F7u/3hpqH4xmZ4btYm+2JLDrlhktJ3X+B+hUQV0Mu6/ux/2nMKL09nHHgqrmldVmxC/GQU0ImuySJdQoSLOPpS/w2E+h94ZsFaVHBRmb9lo45LOJ/ipGsRVVKmkKMeqLTI7Y1GK8yY81Wkuo18r+0+uai5D97T0CMi9lNuboOZhywE9IMYLuI4kcMChUGxLnKzHm+dELkKB0DjLR2fhzpRkJokU8U976LKR3n07q+5gW1fFVfyFnVwDODqW0x5s+qTtJFJP9N3s9EwrMnlJUNWUJnXJTdEsn4YxQgDVHGnL9w9tedjnt0ZSLgG/QkJQWHxs+a5USNX1OVi+GP/LVspTfMVQZgKuumlUhG80QhQ+OdNMKK2WwDON6i3lbou3hqjFUyJIiQEZ4DmEKSGyKwPHyG/Mk98Zk29C3/5OvtbNoECYWZh6AusQFqCt06gvSZcoDuCxVuQa2FjNizjuLnMa8bIPyUS0cHA9MSSLS0q6dQg+2xN8mjolZWimaQ1qbbicDL69sDHy54fBq2bhe1cpqkeyrM8JKCRAraA9P/094Vk0c1iNeYkOC6koeZZAxR3oDzKsS9gRgylILbS7IVYlsejp2o20Y8NTwGtdtWTbjsvkkFTvcuVvhisTGbzA5/vhW+tofo59Oc7b9JLICuOaAtcWDDRln+y1y5X8tTxHTTpZoD2KMhf6zn/Fp4NZRoC9K0VYtTYW6RtdFjUyGMj8OJFXdFkGqgfbB9E7SbhQ9Dq+zi1+70t7ceL7Kv68ocsLuKSSks0CyF0f3fsGXqb0cJxka7g5QV6J+w7SopTm5V0GTIbMPuJ7eSlvEOd3U2Og15/5zyCo9kj9utzNsJAj7SV9PYFQhitLmbDOiZ2majhMySSETY0vPphSFccRlwJ5H2DTJMtDz14rxCN6+QEqDkjiaJCL+Tsa+GvIci34VFv6wps+dcOFvPs2H647OUVpOkQLyZia/YitWLLPQKdPN4L84k8Tv6CWYzhfRD0RvWWRgxx8TedXkLV6AX1F7nXgSpWbXOyXhL4MR6tUyAk/zpWeIDZKtJosKQLGUGBwZhO7GYV1fzoySiGEHqZcoogf97WSKhXHjHNSThi9Z77AWjomZhZJCjhVJH0jWRJJ8JaovDBaInRiYzXD+IynK+rr7TpaGJViTW9hNTYihGYSqxqQEB7NoYLx5lPvyDYP7OSPfyzRC9h+wnoz7+Vi9vY1YE+guAArYXq2JH8r+O2hQpa51VSIXKCgjHGXzBPoP6OL1EldPrhWmC+HVl6MntleC2YDpFoUYNwjOMgaJpeVcy6NuOSw03tW8e7kju58BaPhbq2OADshL3ZIscLqSqxL+NlWlGsYkmP+AnG7nmzP7RAA0Ed3zsPzRSsM2V3BfvYauRprCl0u0b6G95fBdUjlq9q+C6YOtWdqmOJlEvf6OAyY9G1qpIkFJc+QSF4bq4YFQP4tCmLkJODsuSgVgRrjyVORE2S4mk8Vsbrm9lRFwazxRLeB6Mrw5oRRIr2w8MfvX1431CMp1I/L80AKhhgAkTCcOjhzhaeXamEYkYGwmTgV2tM0vTotswm5aKOP12afKtlxEKylWdrDKxfcfjNJRJwWSH8r/FYy318Pt7Zxb2RIHmKYz+rMhHiY4PgsubYqZyxKKjK0TCbfSyRXo1nBOyBpQqCTvB+xPp8dBQtxJrkOkqxgyxxegKwHXADSDiw6QhlEc4NcmvDqKX0CFiMD3Ezg7GmsKGhBx2cuT/5M+d7E+TeO7GyJtXdnb+4SN4q3XtSiA0qPZ6uG7BTlb3xRhKRxMZoIDSowZ9DpChgZESm5Yc9cOlHPA3xOolWoGaP0IKsYb7Msl8yIuFC/yEdrM6W0y8OA5TVx8kIaO2kD43CRtEu8NJGzGL2JuHHEy1l01slkiNhuFyhPhjoRfZCnHi2ox0b43helVqyMcfSxQiY5ODvhywfSZJZ2riryevo2QfGOMjkWi99LvpvBEzr/4y8KiIl9QvdnuWUoxl6uH7O8QZrrPM3nWZ0eBhj5cf5TIuW4cx9OrKCch9EbqZKDykZCbUrPtcuxmHqYlP7fvsbobtaYVuN7RcNxefUMXN60wIZSfxBrPyvyCXvoJ/eAvPOYjx2+X0r0VZzI2AJkq6+6EzQlCQvgi2mazeDfIeGb31cuh/g6568HfGEcN5qx9EqO+85f/LQir6lvR2DnZPgl1MyKOakrZzVgm3x5CgcVM/KolSHsWxofkn1FoEr+do0VafDaMlgsChTWUTxti8MhqKwqBku7FQzmRFqM2IKYcDQMsDkAO1kYUHCR90WKakW0PuPnBBlTWQ3B6WmqVKRcTgptgIZiVgaQk0I/HUzmIc5dq4M3UiyPUALIsEjfj+kjVT1NgkZPVXM0K8cv1+THmQSRqBGiQiV2QzkQ1FVx8YSvTdGn7XnnSl5f47Ub01MDZyfah29yB2mATnH5hBUNNZuVg3VxlvAVhyTnslVhRQt5GUDMdSNWcMsEWi3VfD4VpNIHLw9Q3jXeWXM/eYspe3JwHmlvOlIa7JqZFKlrrjbMS1ICpnfhYRHLtlgd09OYRN+lupnsFhW1QbfO5+0Dc3jF8Oth7nox6KfHkngrD4gk8I6qct3T2LV99rOAVR7xJTN9rJsZObn6CvX9FEOWkyHbd45rVvyWliuypddabkZhyGZ5Qo8cPE58wQ6rylnR+2iYRyXmYpKu+EYhOjFS49wuTtXTCW0gYp0F2X0uCiBNefSO1NLYW1bSOdKea3FWk2YrAK6LHNJGBJK+MOdyz1TUSBTWwJShopySQzTsJAtn4RuUucQgu6j0pHTHlYmXzlJiQcRGXJITVlPi63hK4n4olVumAIrkow01SW5pk1rMAS5fyOrDeH7OcVMZ2HBTZtorNm/Hej8g2b85GmGpGzDJVwgghEvVD8IXI+O33F2cajfL/KQuLFOpL+ejtdwwH+b3jepXwZOzhFiK1jBQla3opMtweRctTZJv5uoldH6cy6tqyje1s2vzM0lvrrXunhR7r0X/s7B2RX/1ABs43DojB1zRXVFfk48XlUsjeWuqFDh9fE17N5Mep2TUh4ohGSFonPBch8bjZLBoWHUMb9nRBR4WRJoJlQyFPT4MpPRUiJfmJRCVDLo5dn7DjR5zcpqZNCRRUgoCehHwkzhBkA2losFsUyq+FsO2GVZwQ7f2UriTgHepcVrgm68ZI+QhFX8kB4dEvxjNBwXDWUHrfTDuAO8swBYqxm7bUUw3znH6eKvgYrAWWs4B7U6TnSoSABlVGGTh2I5yjrwcszMFDP49IY8Ujrg5xI4BcYxKO3hwPU/mn1dchIqY1Y9gZAknRtY1qXSOZg3jBJEIJ5lm2KDgbGkaM1yfa7k64/8jgBRpqyc/PRL7++4foyytCLMJyj+MXkVW9lgjfXCQKeZ/f+TOw4uCWvOUIoENTWtfYfMJ03+jcQGUcmLeTDI9skDS3iM0LTAZCOc2GLgxkOGHu/FfVqVXnvP+GYi7wW4xs3THOL2adt34ej11G9BRKOkTdqxIFOgmD++L4iUKIXJPqGRxOOFRU0AdaTC1q3I4gd1mcuufJ1ZvcpgwZ6dm2tJS1+3thgd5+XoMU4xeZKSrOWVyyGGccgpmNMENnuvzy2VZTjlrw6MKaw6wet8w5nieM8ZZXI41A6QXEecpv/MMuO34jSFeUFu9IuQAWM/ZUkscKqGW4uWCmH0FA1VcsCTSxTs5rFWZKZIoRWTiImyCLMJEB17AIyjcAbY5xx3UdtlmIPewrHAgf6kdKSCvoNV6lPgK10WQYK0CskwpztPpa2SP4/i5/rwQ1ksmyILzMgpOsqWJ6R4oRiJuLvt+FRwqbPuhRs+j9tAPb9m7c3Bbg+QsfZjH2YBkFvnoCTZtKHfiUVHrpm4WKeU7wZhnYapqrug8hLEKlFP9dV6IDFv0JBzIsxS7EgI+z9jUhSh3F7FmmEio2taSPnJfg4sq34RwEcrJ92Qr1s5qKQzQD1OweA3uo6rHoyKTz30y8kNdQ0SR2isQRKAaqpcKlXNkpSR+c4mXqdiRQIREKSSnU85XMKyHJTnWe9I0lGwTF94XpYn6qi+mvaT4WpqXANmSjTW45MOqx7sI7WnJj0bxRJIv43jCjHQgGQFlicB/4+7/ru9A/yxZ3sCtCrJtRHzhYxQURcbHaY/3Okm5TFIB/RJYjkUfkO4ZXmmjPOFdGfUy/k1XthELPbivKDPI366p8gFXHkbpv+2PDwN6yeUxAoHai+WNb0WV0FNJ6vxIckqkxiWrQQumGH4UeTYkmwkZqltMTHw0elukZbAUaCUgXi9KnavTGlAgkEaU4jKR5zAfE9gChg9Jj/a6KZyjaix6gFBZ5BMJ7huFF3h0ydX7Ml0RnY1AS6W3VkfO1XC3PLNy0C4JW+Z+g/VCuJSF5Ui8KCaORpabKYxxbwDXBPZHJLR54xmcGqiEwGUCs+dUbaVHNgeOpH2H848x2BNToqctLhdkuZ7Ml7gNteJpHJ8nOpaVPO+oIAWoyWmmQsJtdKZCf4HLWFJW2WrZscspfpD7B4d5uKzKpU705DyWkVwhgseg5bMHk0TE4inzbnoSV/FukFQ8Uumlrkn8BphyrHWh+QxppqQWufITt3udXyx53NWbebgNgqBUaHOYpWhoY61PoyWJFkj8Y298M2muOSDQogK9ciamNvn2V6zqG5WvsbEGIozaH4VdD8oCvTUCR0BJW3iLyd16AusxbFIu0BpHrZmYKPx9QTNeennpG8PYdeALGt08hJVvJy8PYzOj6ovSfg5I5yTFWJ3hUgdf/oWs/gvKnsvsQF1m8LBlshCtTLHn47nAAoGAYT1Gm32onNBOhwaYKE2IQ4gdkG+ltSVxVFOOq94a0EoQcJukd/HpQqrZRO9iFJBYA9nl8IZML4Fx+GyIxlKpL8wiOjRQz6ZmLV2SkBEprU5y51kiEvmTJEPE31USHOUxxWdSMkSZPExSMNqiD35K7Rz7ckKNq8bsdTrygSxz6aYYCgkBYfdAqAOL85mBnwf8T7sBfyW9HIb1bLZRxqMF0PiTgFoRYMw+ruhH8mXEi69S8h5+/tLEm372N/WFEbd7cXLuqBiaQrwp8m2hOxGeA6BSJBJYEqRY94eKfjAV4JB4HS2nwpIAyREtzeYnJaulxWKZZIQo5wruodtryIhHCzmhBZDmM28aYDULJ22mYdw4wJeE50C0eVU9XSu3eaBFxM2BkZwqyxFLIDIpHsvAJYuvpWgJOBWQ2RYrL8gThR8IvnM/SUIScTCVGIDRR59m7X50qKLGDWlkijQFVxupCPHpCIALrBYMWnMzPw61u4UO5mRXXupHF5c8U1NaL5VKEecu6esCL47GI6X0SJ3hzN/8X/lz8D0kRI4qwADfJke9uDiRa4vwbEVRCmpcF3RJ0e+xXpMaCmlgxhXYiaCigxWa0hUy6rLrMJ30xedXoVpSSobkHfME2DyVF2M1y8ARgMUVdmUMDp8kwVfDzLck1xPrSXjmYPFOpv+uJu4pPgPyonolTh/PmXiC7Ei2zkTuIBm9ggHHjSLqBDzAYLHN1DXsrquKwMyFY4eUPozJA2/2A+ZXEMhK7+A0u8x+raot7m6FOmuA0gzlW3Fw6FsOOGiY2UUQYDyXmdDlbsVfdjXFJ1FXy/Xl9BIaPUpeR60QqTVsboXeXHH2EmmkrbYEF+SoKxkR+d7h4NLBn8Lxtp1x26gfpHeOZUmGExtmBVJ6DLr4lChgxY8BUNaT+5H7qJB5lk4fMN2UhGLDKEcaP4InW9JuYUIW/4twpqAn9dwGos1qGgTx83V55oXXHkTZi8x4I83/CoMq7F+QaoClMQvbM91QyjELLfXLJTUs8fotwioJM3FGdeEIb71Gj7akw4dJcUnN9ahWgPfm/CiEXGZ3EPtpSR9HXBNgmDGqNTCtiCkAxbF0eZDEaQpHHl83TnPJzhWkhsiKQaoroAVSBFUK/Qx3q6hoxTMC1wdgnJEP+47imBkSN6y48dx47rA9U7lZTPJNcBkncSZCc5KucHMDVCaZmcZ6jF2dweU2eYS9wktuy9Jld6ZeLfga3ICpjwjclEsxOh7w57+NfnBDbVRpqwhmF4ILSAeQcVEdiuLNeLqQnyG/OkjYpTR6krYzEg9AIQuXDxzSc74NwJt9+PZSzcyieIVFTfeO4c+HRjsWaYZmVbF+qBzrxDiQf+Qu4g/+t/9XmDFz/TQpKtE6zv4kHCNNwtLFvhrq+J04flOQrD4EkUh9Vm/KtQL2bdXFxMvJ+8tRvgbXq6GDpT5ByUkOHihXY65dAHlCwePBVFEiiWgGjAWabxLtD3z2PeDfkBaaulEQcYgepeLkInj/CjNUY1KGN1TRyWhdGi6eqc3DUALoUR9rBWS3eIrQYJRQQjYO+GCf2DZI6rC9wJNzHM2lmwdQ0/gehpu6WO7OHh/bx5Fj0kwxwcVCMs+zasXnFj9+jutVONSgsx09GODa7uA1T2k3JiXDiAXEyHWEmoExwcqI9V9HzFHWfKnDOMuRJTudWNhjaAfNvgSZw8Hso4yNAUpN1S2iYZWvSWBT8ZKCFVh25LCz4ZTOhd1G1RFuXxpnU7Y0lII+ylBpcxJ99VIqvkxujx0iJVDJg4sfy6iUNiDKMPzWMWj12bPhJCNVuk0FrIV3VfRVooYOjmrcybPKnF2W4KU+B6FQjsrzl7Lhcb2Ilto8zqODCpGWeXY5mbUrQym91QaZZvhMgRWTtSEGjFeyzBUJSeH90D01shfV9KJB00q6BcQZhcoZL1xqSY9KlJ0jU5nTq3XYTgCwAPHBrJNEWXJLiffz2i5PFpfgyht4cRB3GNd/hGcFD06MaUUdx2lVWDe+YPb58FMJJbb0t24qU6g3azDKJLHK755kmtbw9Q8Wjpa7+qSIJAA8rGqiHcISANUKSE3tDZO8DsMEWxSRgSDjdCHkk5DvbVTgPi1b2ckBFjcg+MjHLbXSI7lu1L9iTLeiSsJ6+/kjf1LyzQ2HfeOosx3wvSY6i6nzStRa0rwoXXWg/h7uSxK+F/0vVt64ylB68nIqhL3zkJWKiYfUpzsp7KPrfTb7Fc84uHsmZpBn9+CYa7ot3ELSPVM2D3Obr9M9ANYFgxC2A6Ha+MRj5WVmC+GszdWJ4Zuil0pJJtk80mePtM4bnIuNnCRsxMGafwSl+jdm5s+CZy+Boec0QxQ0ZpRRUsOr19JXy0Cp40wMnzTT+wVxWYfWOboTBKND+t2QKfupeamuXDoRkXoRnTL1eB79TyYj0gP/hFPb0xZyWpg3nG09qUibEA41Mt0Kxww0BvLiIO1rRvoH4xnXr2vy/BlvV6FVF9c4jVvg+Xlib+PVKaxdxIMXk7YXh5isqpAY6NyU6qpws8pBxa2OjJwnxt+hJEAbe2Ggy7tAFjVR073Miv+y5qo1/GEmOb2DXlizRUPauYQBVUAMiIJKiKoXtP0oJvQ/h9c/k1/9wpkq/dpTNb5jDq9wmA0WOGqm6sjhvIjdLRKkILcZy4+Ipwj2FOefmORkynLypKmsRxwkvN3j/DrZeuxqZ8Gjn83NbG6jnl8FbFJQnil0Z6qXUfQFIkZJbnwW9Fw6BCC7k29K8mgVJLjA7Qg+pL2+XpQEb/IoAmoE4Cslj6HNk1kpVfrKxlhq+3E3wfEtK2PAgR1f/02ybc8/werRW8kfpah+JF+ouTiBEEUbfXKr6TzZNoc8llLUGisDQ7A97eopvXm0/zjIfbqpgyemBvCVVnqYkxZasPgkmiUiMUFWkfbO6ZaQr/1EfDHMSwLULEmKYztNCxPp5ybOVOgayiQfAnwKWQjNmSg34W6VvFDnHx/ZsypEY1JMMmkCpZI3CaGxZ95uR62J1F2AZAHbCC2nTjdWunWVlLomuN0n75sEKvGBqoTsuK9SVVzp6jXMIhuuGUR0BXkySb+WX5cEKJFcSV4Nks31Ao54O2QFCRnraPlAHMzhqa5Zf8VMZ7YhqS6DbI3BEOIUGgG0VFqZKIPzKBWwIKO9jNR6E8McEHlZ/TjIjUnXgZvPPaRi8HnEVs0xk7Q6HJhCyaPqpcaJ8FVY/SNMTdYrj2gKN8fm1Qfc8XOHqa/WUKObzIEyzoD8Qqyv0P1x+JNT0H7K1w+jKhenedatocyafHU+ymeTJyE7KIz/4Jt6uULmkC0I3MKUQ9L4m7xdDM1MSH5dTVbiUTmqfnzJesXgda5P5ZoWpSWeN3kSwsyFcuU8aVsKvS8cRQwgUVyeSrTyhspvwIXL1QLK9tlZwXYQf5+okRNCzmNFkBYv5MXjRm7ho9GOERD5Z9B/P8O2YzWVrAWqPUaZ/XTwGUu0NLsuTi/w3MY0AdrvFbNHXEYCfhUPfozJQpqzvMK/srr7wayokQVppxLZx3Cwg8CHPUMKcue1yaUyJ2y7kry3Kyt58SqxJxt8ea4nV+h0yU+JW3AUxwNPO86Pv7XXZMg2eEOWjxycBDRK2aWl5C0RKCBp4d97MfVT+DhLbabxSFJfFkAkIMPmYtfNAw59ZVjc6I8kKfP/AnRTMd45NYYxD7JRbVNM3rGdCWYDgaKETkT2Dp3fQ5GeFmlU+pkEL+mXnC2VSW0LFe+AYEq8L6SFxJwR8WUQy//crKiZbpAuW8LdQiWA6pX4X53zkqr80KPthvrCjjazyGBwQsT6eXp334xPRlISvtgqozG4YUrDPW9aoPHdcvB9zBSAu1z6Lci13PNC9hAVzC2XEAl+9a3+6g0pqdb3EqwLNyzp5wvpPaZgPRg3JXPNzRuRqaaze9Z8TyNHcv6n4cSUSFnfuju/V7KePktm/9/x7IMSXsUDKRn/l6ZWLmYrZJ7nowFYOqVoFvwroFd3tI1r8aXqJ2PN6Oo3HpqzbRDuwoUd2OqK/BqnA4zeigWUpVV/8XmJpyD6POUGGrqs8rE5U3CqTpSBjKC0NKcXFPk5oIzA57mMcaJfM0w3C8UdUOioUBXtiGY0PFXJnMLK+lz3pWRdGp5Dscc5Qf395U55Vp4tLGwEwy0S2pElx5cBniT47qWsF/EYwHdizzvTuklcZiJoygtJcvAdfci4XVbXc5AjkNg8uRG6kyhzni1+On9e0GBWut5gRduY4/zJxnQxzTZK4Ztb2Xqba2+SV8+1+rsExbz41+N4rlzMuN2SzFEOv/9/+N/QLVY0lEgBsiNV6nS8AweL3opQyh499OVLyPFeNvfIEsdaqSHyZYihehhGQQbdyNIciffLxsWmRN9N5HX/ZkzsPfzMm/uKUqoge0CW0sS5qbpX5H457l2QrIpuPYXBIxG9nqYTaaQiycJigefPSMHlflcWXQL3LPiCuQxHBfK2HJ/VlYtr4cbyuG2I+XNyJZZxLFomXHqSmHP4y3P5WlezxzjV5Sbyv/Gk6cNwy9MUhs4gRgwuPFL6R2rsSjVG4iowJM2ZSp2p+u5XKNHVZyGsCTl8rgeHaDOSyVYkN1Nvy3NMta7iZYwOEQ5ien0evUowbaolC50Shl1QT8TuGcq+gCsz4RoKyhAlh/DNxP2+O/hg3MLwaoNYkYwLTDXIQ52WZcWUQTDFhVgmMfKWkm4lQolMZkfqpBrlTVofyqU6P6rJZ4AvfVGsjeKBLA+NVJ7JO7NIscATJsEh+PiEehvgqYlyDL36XF8p0+bH/sh03HZ++YmR8+PkI6L37LPIze9mF7PCyNJvJKMbsGainPZY9lDOUWeqG5f/UW7OhFX32aHhUt5kiSfwYw7WY0BkoJawtswnMUpM4R3ww09Sm9V/7Kc9joc9Hy1qlT4PF5QQiMYY0xw8nSVJQ7nz7WypkH1U97GE7KPokqa4qKAsojloJ8DRRQR4tBmFmaTQMUhO7pyh4kwsePQc8qAGlcPUfwp7k1gxVXNLUm5Fg02QBrB0oYKFeN1Vvs2F3T7+XSo9z6OXHDZdSFWpb4LkgdMcyQfnyvQXUvmd0kktaEKx8caYXiI3hVv5lKna9HY8oTBp8LXf8rMpYn/Jry2YrgTwvdp/VvwyLfRkd8wnNeQNpYrA9RhIReBkMKtDeYREXk4QzjLk7CfNefqmqJ3E3vcllcRAUcHPeyD+WvrRSzw8pfGSlmmGrikNGV24xFdA6nXBb+fC0qQGBmpA8Iy525p+LzqwY5ai4kT1U3j3G17iyRMqj27H7y3G4zVxWmNLl1g8SgJXOV+h68QshMAJgbGMoxQPdRRlUf7txFuAeBOkTe42eW4l3mr4j67JnZz/70I0V9RLBiQONxltUfKGxdcjPO6K0YnSvFBhpJgmgwDJFM4MfHqF2StiOY8wJlZRdSn42k5MqF3Jem0VsXWnYLIIY+nUiAOoITzThKKC7YQmEv7a8xovje99ffGkq7xSgsWZRv4iZAcynOAmTmmGdM+AN+XeKypc8k4f6WX+pKlIS4rZorgTkNwfMnBpuo+ojeDkGZNiGudJr4Zqi4mDhNaSyhogMT9pgrLKtNu4owEP+0uesjgLTjw9cnn+SZAaJMzh8e/gnkYrQr4/FiG1xjk+hRJ4V1ofkkuYtg/w+1IQCPDLJyLf0RKLAQCWUhDHiC9IaBZLicj9WdzH6BTH9ZKx7AxTZP9r7AJD/L1p9MlIT3xqeaj/HjcMBlXqdLRlxtdn8X9jwoTxD7sqFvj6L6VPzPizqnnvB32LK4UXGe1VdBDTatNACnBlsdwH5wDJLg/nxJHhxu3gywwthFLpUHM1rt2OZ1lWPtP8S+n5QUjn+eutZDojj1P27g5GCn80Cq7UrWwPSwjEXarRlBdEOKHGKsqfoaorocNJQlnzUfuymJuUbfQ9xXoPVvMJ7aj6rmDP+2c3ytMSvfF+UsrJ88gkS3NQtNyH960O5+tPxcTER1G8mWjKCzIqoCuxsGrppyOiclBBdKSAs4orde0PxsR5kihxrG7iywXpPs4MA3DY9t8XhkNAJycWCgJCSUgsHqHagLXbwXmRvLVBnOsoHQlA4WYPa+P0acJzaZK9T+IZDtdRX1a2ryoIinmWGx5MV1N4DNCU+Cpq/FH6MkFgAMiADLMJAqSGRfUgupB12veXFgxnDIaFzNVkVI0zX7cHNw6z5QwkhsA/oYW+dSrcO465XpXO66yS4SxCpQlTuujFoXaZ8T6Ya4bP/ddUKUrZRMrq/LnHXJP6tlgr+LvCvAxiEGMLsaKuTU64YGKWR+pHYI3FmZ7MNvBoVUgize6bSc8id8OVof31VAQ4/fs8PpsoX52Bv5IwFKWTZm4wSVuSV/5pXv2AqjmX6GMIB1iz4FYbzLelIBGSTdwTbrW9+ankqvKClixNQYvS/2EBZXPy1e9KbEgjSUjXJFDne9WwpLtZkMw7Vu1A5RFwUq4bouKBiSXi5xw7sSGYVtGHOHgN9GwpeL+ZvjkzJ5fwrsqfF3A1wh0XzTakW7Wgukp2WdJJ43fLqFtAsczWuJ10wLmMonNYybNpiOZJUnsmpYy7BZzTo3ZTnU6TUkExAcblRPwNJgLq7Cf8CyYS3Cyms7rl++IGsw8cnjri/VH6ZQQ1FW7l2VmA2ShtdtPMYnpkY/sjrLzmfgqHDBfvCgej8ZDpmcR4Ox5Qt5UX9lhuYLT6BTznuFeMY4Ut2+Hduf5mzJ/0VmpvOfJHl2mg1U/tzfFYGxef2kcX6nWaFUzhV8JpUJQ/WZSXPMWWpPZFWqAYhDLpfZaaNzQGAF9G1OQTLdmcKU2ROk0DMBDa0pQB1pSWDvE8TNIgrXhsF5DujnytGQ4W/VHHEDPbdtVmG3CGZw73izw6IdlzNzS1SY6sfEQX39BHEXJbbsuTuy/InbxaVvF6Ji7xuDfhxWZubcY5QuPP1HMLDpOokrW8c3xZYstd2rT4MweNOXcPk3hNvVWjmpD2LWZ0OHTjaV5Jx4AY0DiAnSWc3bfqM9CIcnmPBTlyILObIT09U2TAGpb4ukSLsZTuSIUXgKVC7YQ3RPSbOT7NU5qHUoNXMky9n2xPxKuJ9U1nupFkqhEOYqkTm8wIcKKPypGJRO1Hs/0wM99Ltj+xhpIqtsSmhPF+enZudK8YayVgOoJPoaUT3dfyWdq1BcqmajuezvSzQXTHklSIPSuxvjP985TINaWL8djmazV//NwKdJDp8c7bMJuKmyF+zSjIgdJGN/ieFF4QfKybFZpNpccwNA910tfqI6jN+RsI/noyEJ71/xuFJDVDG5u3oAhwr0lXA6zVYnEO4nexJGTOAOSQ12lfEZqHl7tWwYVDhg7a8e0b8jtK8qyvHfWD9UMxWtO9nLJR8u+MyGSKHtdZJcfPFSQksFoH2Yw0mMDZjC+NJtmYH4IeMOtgCfieAiJgmSStI0MRVkx9WRtKsa6B+pkSYzGwYO1HdILhyXeZ22Iq2xbPMaLD8SAFXWmlALLCOcGm0Pk2wACCY26DGJiBmvwUMKzNijibo7at6lNOdHQi+NUTgUrsfFOeAZ75OlpVmayCzu8rE22an+rHj4n/S/92DL0iamcVewzPigS70l1NzV66YSSIc+wf78dBWW2XLKUCSAyDTbh1RFuOAnqpZKALKPTflPJ5UDKhpML5GE1CyBB0bb42hott9+Vx+uUigDaQNvG0LtUBrvdoKMihJlAbW/suX8dKFWVTYz6gMkIXVeIeosJNrmTCzEbivMqtUO56yomWUFcpAtjSibVBMudh+1jM9vCCHV9U7SmdWZYU+8ptNTk5Vy5kcF1JJ9eVKZHz5Xgc0spvRfgGFKbeMpJf4Givandr8XAL5KJkkarsBcEA4Ej0D2nRgkWCknUwXQGTxRYZ4O3vMmcH4sLyZ4FeuQGzuaQy0mELjHss+hFHSbqaqNKMDEMxwkz0udQTqkkWMf3EEuNjqGUwrbJKPdQsfXIszlNYixXd5XdgZinHW9uGh8G4SgyZIYM7Q74iVKNFVcwbdYV4L/dPNyw3az5o2ps02dXE0UisjYXFaGtZ0ROxcJG4A/c80MJFVKUyOo2qkLR1MHTpgiHlyonayE/9QVqRwiWqKsliy7LO4uErOqqwTVsX9+Q3il4LgHiu+gfDAoOOqQAEXwws2zevlqQXNcgTBHzQfxncz+Etdf7YUV9uku111ZWFv4dXUff8XNH6wcKn4nmRlqi1jd2nPu7WjGkFajvOCodRS3KKWPUSLQvCFB9X5vlF8/fONLwfuYcuKWqHEr+yILUg3iuLsq2wnHAXY1EQZG5eV2GzGUwsXT2GXYIrr/VuhWx9J7QyG8b02m/IJAYb/Si6I88RM8sY9UBsoL4UWFOVByi5olzrep/3cfFX5E/fch4/0IdVh6nCHGk/fCpOBvLUENkVMAgVH0NA4owBLJ3nUwjuKCNfIfRXVaWFgxEfdUFxBs0DUZ9F/DZxC4TW4+K+gt6RGZeRxuElkwTwbyohRGwi9C4HAEg2ty2mjsm3cq7fB40GvHcUmvXkn0CrVZ98rCmFWfhzy1zjYvPv+GdfNJaPokcvu1hVzntJ9kb1RjYhEdB9vqBjv2CdcMQmVlPHZ+Nk9Yp0s+4CaMTnyu6iRDbztb7R2Z+UJHZUzb5aSt/LkcQB8z83KzNRUMH95VgxRb+UoTWahSj7ioS95CBE0YPidVO8rIhHVJQb8TKHvhJAiuQYub8tFg/S1Ge9O/KaxGZ1+cBLryH84JBHGfIqg9wrINMB8XF6bd57+OeDo3y60Gwe/8DmerrjWpXeNNPShkdxEnpBTe2pUuISdybbv8g0Lj3U6YaEn8hGfzvjcG2NiLABoz28mgH+CE7qMGjwUX5KqloomAWfy0UuhstYusmuXZC9uXI6oX/Spg8zSgIAueFUf5spnrKO4yxZeCcIvsait4jydYWGiM2RkVfMMfAPUzcnz4lwPmJ6xBZjY3BEar4SCxStp4nCF/+gXU4o8zJEIHrOp3WncC52uvB4DAcVXimQXCi6m9IW569p+tW/jf5aWXcs4t8Wq5VpkJ06QC6PLdpS+yFctZExEMF+Kst4dBen9fg8IRXERD3QZ5axl5X26a216GRBf6lQp0u6Z8n1uVR7CD6fBrKEYVXdmQsgJWMCmw150AF+hmSupCORFr0oTq0Di8xZihSQux7wNY1lCs5ZrjpMEo//LAKbRVoyQQqwfVWPejCb5ctdexTE33Tk/dXoxkfkylfIy5eFglNbuWxO7l5o6g365RRlGrgwp8e6nIUAHmiBpeD/fPAPSg+zB/0gI5lyR4w9tKjCwyIY1IO7y4lbF50UkL72B+c9LYY/p15azFzPs33bbMnzDZi5pnnPF9T+sreQI8iUU4boHaHIjM4U/JSsP5/FO8avwGzb1Cr/WJzMi4GtoCtdUwYeI/GRdm2Erib9PZZ5Hbo3F+VhAexbwdUAS2NdjjCiOK0ivchOvyycHMjlT/IfyGw+V7+KQuNSLVIIr2DpThL3ifGGZAfI0SV5Kjc/4RdTjBelWg4cvSCtN9GiKkdVtDAQjf32pOV2YOpq6MaathU67UB+jCJRJGUTTkco6sEFQvRGEpbhLvQNKJUlshZ7qhXtrQixFV1COp+m7xwYi0MRyJLfYOKal5RgoEkVXxkhkUCwnRfwXgh+PG99kHglmTnK5sNYO0wfXsykulEjUrTIPCgghFIXE0NPxy683AmrWQ6rqPAGG2FUvVBel4XDrWCBAMoVB80/JFUn1LgdY9697gs8L+9a8DvWzVpzGdmnmVWQzgDrqPjga8EG0nXZeyYZs9XMOMSM8uwJrmjp7ovgk33/w8KGQXkwSmrTkEvxpKB4Baj3gPhno1iVqE5bPzAUBOQ/YPBz4gxA7wvcWKPf2GzchHAXmoxeHRF/UUwhhtmk+0ouj6AWi5eYX30FqxPXLRpmjPhJSp2omYVP3gPHGl2KcHmHig8LvAz8Fg07fF6A9izSpjo5cIozMhfA9aK0LF0sqmqeZ3Cy2LfSiUh8PKgYfmBXW+iGxMJB2slE8OkoZuljVTcxrubUCQV3isnZBn564ldH8v5X4dZGZiGjRiUDF2ne4rn/AOW+4hqT5t9OO40qCrGSgozBp2VBXpsL7oekbhv8RIAULmXFK1sZdNgSNfaOWdURcxN7JT4zcFwPNgh6c568uChcU7gxUTsWfKhoiZGu+FLUos8tfNtJ0/PQ6zqvV4uPr8Z/9HY8OrNFylbOvfo17xXCPRYAXlrqBNOcFjIwXLLcumg0qBRaaB9eJElxDqcv2fowrL+Cv5G95pbVuEOeLkH5FdIXxZmlKcuBOdDPwsQ+VRd+CaUTB9/KhgjQRTHsk/UP4cigiDBrrA01xctE2hR6c75ywKwi3cWmtzZcKRpOTAbfUONavLEE/6mSgBH8u176eWp7LTf+p/OTnNJYM7LLonxCrdZwpCidt7OrC6yXSOE0/t6ZMl2zFMLDu9j1QCYDyQTTOL1konZTK+S52ss6XbDPiU+AYrI1Dks81W+mIQeTJZ4aAvkgx0Eyg0NFYPv//J/2F4Y5GyJHt8/lZZgKGTZN0EFwXAGZAo5CYJyL1+eKiazGXB5JZHKCqm3t4zdn3XPyb9goC8zbCwnKw8MrSWGLLuyk85vFy7o0NKNEku/O4TTSi7uixvxXx+ac0nXPsHUwLErGNVw26dfr9IQkfwz9Bon+uR3o60qhIKey3PDis6yiDLlxBz2cCrMgbe6hM4HWpyBdoOee2F5Aqoxb78pzC2wP2OyIO7NUWtQKn8ONp+D1d3RoaA5B+ZaxMCLUQhjCM5ccPOFvDc3cmMRzZpX1bk6ebYdaGVRuB6AoFafGnMJDJbSaWt2B9hUg1vWzK5pHxR0tiPPIrZNbDD5dxvPrgC8EopzeTliqw+4CPy/55WZy9bU6DHBK4PRBEBfjYkczfy2877inmhSpIgvtNzIeg+sXzrTN9y8dvPL3/yPUybx3mdclnO/BzDz97pD7VTk/gUIg3QGuARQLARNGY6wD6J/LcoqMECxtJ7Vp8lkonL3RNZrTOmz3COHIWC16/vb8pZVUXmfWPhVnbSQovrbDxDL8xW2aF/ZyDzZcX9oPd0/T6ZmY+LI5VGsaxDE89U2rRXgeXN0MlzbcP8tHpjA/aAdfObCUla8Ok/3LdNaBfKqqYwJTHBSEueyXjtV1xf9M4MudqOYYVyw/0JXflthaSwJ7QFCU4WC+ypdhjCvgxSTO2OoqZaU6uuzIr4tcvNZpV2q+scsJaFai9g3lzEp32gr/ZjKGGqwgdS08oQJWiR4DN89LTTqAZIKpvmcAis2u0pymyZF8dC6sx3qjm8IEHeZ4yJDd1RZDvsF957rxTALjug8n0oIi2xrMl8Gsrg0WJfynW//3tZ+JN996wR7/KHFeBfpIFtcb4ARBkyDHFRmAzIzwTzmIAW1xkcP6SNihMDWobye/XiOhJq0aNjGwBaXxXjge2NKpVQv1fB/mzx1/Ro89H942w8XUKjG7AIuS4mzIo2uq/Ba27kOeyMMwrRE5veeEVShM3D+gTaHkA/4CaNVbqWEoJ2VujuWfjC8OQO63jdkHBW3RY1+MowmHWyeKPmbRGm4vQrsI1edk4VboXElP3u5lt3CxpBhjUpimj05Tr6mV9dRfhSSVQAnEGxHJI+4RfCwyU3gRcVSQNvPTg7Elv0HXzt1uydyDMfeJ2ZUrY4J94k+wLcNWli1H2PdI/zReBEpZYbNlUOwzeMj357Mb143Dt/ie6izHxuYYRBaEWxQZ/PUUWqfy0li+szuePHO+kTV6S5CtgKy8CC2dPq4YqIz1fJiV0Dim7UOkE4htkF5njgNIgqp1rKe8JRMwYLiIlfO4/RrDFWN9TX75Vrcf0FUQxaF2VFCqbdDHKPdVZH2M/buWWwvEmdoNAD6zs12UeJCXuF6NpXoQCngRYGUR3m2g7xx+5XXpnhY+VoVpSvaY7RfsJDODoW4UwquB4RggWdWyGcIHwp2gZuDGGA+HTpnoaon/hVDcNL29b1jj8Mln2Z4mrki5lXkKEuH03d2sDDjjIWz76nKWDzwYOyjra1Et5Rqy34PKGZFScepyqZ6vbXmldSQAIYiaPhy7SQlJMoXeOV4YJPtTcvEc3WtS19OmWYx7/I2Bf/DKKaveI567uEd/acPbLhp2sqEPfA3OUpgfybmEbiL5jRf6GvvrvKs68b/57nTji+wHqkwyTZhBnFzyY80djo2MxDQHekU4W031AsUT+T5O92fK4UZyj0HZAN4xMXPCKiCqok8kOfsC3owbR3N/p2FkClxpgHAFpAyWl0EwQhON77wwzqz49MQvyplyiXWySJRT+UA9uJDzDvnQTvZsPA2QnaXeHvKKSrWFCgTuYqwMYBNlBk/ZHFlr/fgiEf37NnfRdlAYT2jvillYSkYzxgScETLpsZqm5k02+lvCDWjVwxs/dy4nPE554Y+y/kJS5or2c9rrB7igkg2ZQzDf42FewWuikKNNzh630a4ybkrVt3n42jQ+yyT1DFik+CThjV1eDsNf+PIqEZChC3U6LxRwmS6EZKUb/1Yi/pSP/sSqvjbfG2uvv7mEcv5qRhuPg74uVST40pbuYlZa4mNDkTEM/nZWq8bBhVz67zJWr03aTckxwMqiNG8Bj+O8ngQVPMunJVfqODA3weWRsyuI+7NQ3dF9RIwaV85Ru4ZzCk1X59mCxoeScqJpnJ8kittNr2fh5JwMVlHmgsevQLw/uJWIDkta1TQ19Vsl+OgkNtVkGeOjbHoGiAu5DcQkA0srwkOILcMqoHNKoAf8C1b2sE3SWU6hy3iXykqWrywAL0JRDHLPNGgEjiOVjbg8Uc4yoZzXlyFnCcpNYXlT+Ir9y5VoC3LmIH+Cr94RE8NIKMh3ILFAYQG1IOw9S2RbtiIne9umfTBG4qynJwLmRopcBYvHdIhJjwK7qoRVAm3KsChOLG9Pkmd8K4rx0FdmaXIr+zMgqX9l8rf+Bf2fF8UlTv+9CnwE1K8SB2dzW1k+Z7I7h2sz+hmJPw3q93Mv3lpQF26CbNfEP/zT/0zNJGzR79o8vwHsDGNEH77k6X5S7KEoFZtL/LyhDhvASBQcQpQgBGF2wNuhBD8l2SJJIhxvxlcvQCshJ164Opc5B3MHFe7Fi8tMfaAOi8WzG5qUSmlRthxA3zWTDRmvSaMsWM9jtoQHWwxaEBeYgcAGC31HenPB1iXoTEHF4YVp8ColEw2VOJzI0JijiIAjhVYVfOMZ8TvJC5eUrkvlEzQ9jc8fs0qs5nIM3A7qabzr6pOfh8uhNjBZbo0a1ag9xuWE1N+ELVOWj+LQwvmns5u289/2Ybcw+w9aSlqSvlLZMiLpPpu5oAxgxRKzRbxvJKVm0nyuwJdo/nTkx6JmI/WG0i9kzu6DZz33TyxQXxp8umM5lfT7I0WqSl9X0+KilkFotAzmADbfDrqL6ATEpVcL5fOClE8uFj0yGZLqVyQ/EPfaflCR/3xVv1tHel7x5pTLMPDjkavGLjDX4cRgRBH3XqYXcynsx35WgrNk9LnihUm1oXMpqs0pYaKjA/yAUgaNDrbG6e6yVltM46J4KmhpVVQ62Muz71DwgS7fm+H4CyoGkR6lFzkgmJS31YklDYvkVllAIGIkNrJ8kFqXdb48A94CbIeprpH3n/i7ntI16G1JPHpLdyRa2AismWFegq/8aIDEki8uXhTjQmRoQvl7+OqT9NVc+P8Xpwi4IUXRlUJ3TYuKfK0C8zN0uZb5einHZP86XIiBONpNs0gsJMHjkuHdAz8O6XGgvN6Ll6Ea7GnAZT8shd+YpZOaqC4Lb90pSs5FjBhI2SjjKNmibJgpRkU2LYFCR0svQBSLsAKWIacz+bDl7KxZxpwfK/Lku5Jdz+G/B/9jztGxIHbTdD26Z0Zbi7KyHnoFCVgoMBAokaHOmzOJnILCsTA8+saWF2u4wMDBuuQSYF+Tlx97UVa9JHh2nS+OiHMBwy6sRGBSkQdVmsvEUV8zoVz8Brk+8b+NzgDbOlFXT30XS3uL0kJZl6A8RqxiKeYyHNaBaFBJBqoigbssqOP5VuCUxXUE+BnxZCDp0sUGikNw68fumwUWK+LOTzHOo6whnq7T5JxtjcVxQvIVUbLYMy1sAnXJkTCTpjl9sKrVYpgQOBmJYIdLCV744exyiQYSurGnOQl0t5WFHCn7yWPOB15y20U2599lUzsjVyDI1EXd9Hd183kylpG+9lq1v1a8P2dnw8TSCrVACN92DmF0k3BFKItUkUiwxpIJud3yR4/BcSfcPDM0T/QtchLHsiuT/FvqYJlMqvHGcjv2bP80lb6y8r9OR7LUrYHperyYlWTIpQmUHJjpxcm2PGykqB7VnxLRI/KMqyFWZNiacEcTOU8+WGEPnvJ9Hb9eJg8WZ88dE2pKYdm7NMOrsGCB9NdbioI5nCCko96tEGXnBQTqn9ZaE/lbP1lvEr2HygEcc1zK0NZM1sfo2n7mtzA8LhP7Bss+Q2uWl4ytz2v0Xzmm8UZ6WxLHMb2opPcb6c1EmctEmdJSDL96gRfafIXrs22pvJSEfziPE0kVLGpn4kNSHUD3SyndBNKxsTsVm0P1gen8fyo6KsZ/NHV3P8iezqa304KSRieRLDKJGcKoxi8ArBt4m8UHsTYbMJ5gEzN5y9YEH7ZpUJYXLqILgIN/HIeb5nwD3cDA3MXdp177Lf38xyCX0TOf4jRm8DhNFlgoOJki+ddp6vLg6mm1xvn73dLUBGLB8raAdYl4V41+lWAD0yyw18RyNv1VYuxf9P80MPNZX+PFXj1q9GHtx/wZQ8fIX5+b9wdIXxX7ILzzSnOfKakXja4bZWHVqpZuRZOMmMzoX/0VAs7sz3Oq3VXlsebG4jZt/8quvEKD27NFReEzhrN9jjPgbEJvbGIZQ+GBqycJV9AzGVo9ddIP5AKcm2BLk6UCm97kNU9yhqT0CMgNPLgUcxMkDWC+jVOK6BHsenKwW+QqN+Z4FdOTK0nrelo41Z0RdCbSbQ2DptjN66LkVY4zphvlhyzNUiQBFImJDWOHaSqQjqGho+mqerQULnZ14kpjG5jXvYzmySd4cEl5AMpXUhQqY6IxyHqD6GOo5IfBZdl4viD0DNuycPoOjySh78vL+0w6H5PBo1CV+DQnnZWN7SZtZCm44UM5lVWeFDLLj1SnIicBDQwI2gBVuWsyCDmR2dkCMcv9GwyjMX8FYSZMNzQQnDE0h6GFkpRdrXLT4XMd6xI/uwBaB9AscSukSMVOsfcQ5B4tjP4d2LyliC9T8db3rWyNx0648FVaGDhf+PL5FaO0BdZsYgI+suBdpJ+M+UkvuvUxeDDpf3698ZvZNIc0f4n5CEy16O4TKX4Tem668ip1MaFF3UHiWQ7fTyGosF+5yc1X6qYiDs7SmQSIgHxDXYr5XMEvqvA2YE84iF6SHw7Uk1FwkM92yxLiKFQ4WaKNkL86xXNFFAO2B2H6QjN9dYELs5d+6cKzYf52GdziyKWiB4BWA0tzEL4XfHXJtUhefzWZFowESe2DILeXbBIJZ4S/oViySHfUszom6X8Cwi6pfKfWdt1XF7K2pgps3v+FX37T+5dyPL5eufMOmr+WZ0fRJGLjQC0BCHLoGbcLShyF6o0nksfww4hdyxGjJ0+PXPmB/msO87ayqY4/sWqT4nTjWDe2hOiAXgbOj1iugd33sbvkaUGQTR3CWKCwSyLMKbp+uKL2gskonS8YnVy8MNWqLn86g8NK8od1YVXTniodzMH3XZioMJ6njVzO/UqMS0BNrR111G+a34lMtev1SsZu4gmOK1+gROb5FYB1mFkRaYD8Gyhn0WcUplOe1zjri9EC84FcsTg+B83LzkOj/Of3pXe/d7k1V8Kxb5xSU/DKCHtV/mQJLt8IeVuzP6OuRYAv8CYZtENTyJU5OCLJHU6Ux+ggK0pfZFbnLJilA9N0CjKOwcZEWUujPSzeQO+Gmctl6b0oyhOT2P9cVUsAmqCWgYd97zhwfvxQLmbd9mL5fI3lrySFthLWgB4oigVfEtiR2E9eZzKj8SdfRGo9W6xGY80cN5LVObsoKBPJiphwL5LrY+zKhPQdeAd3knSdS2bM3ARHOlR08SgqyJ202NcmA9MspbIiziSkj/B9BHJ3kqho+TpozSZpp1HIJ9EGyREcEsZaOiXQ/iZF7zCm8UpVZx2REvDOE//xLHhlK8Z7UqpD769ww0kKGMrfarWUvgYMDYmyDiERBuc3GOqfS/NadBtpytw/IpIfxuECCQNU/lGg/p6Icu54wuwvao1LeW/qH9VNeT167yPpsynv0fDWQzMSEBbJrIHyNVHGdKZIrAPqZ9Ospf88m/4kKy8ouD9kxETbiUxt0Y7lNUzbTbK/k011pskctMFkRhZf8NxoTkg/gn0Wb2vr2/7z7erefleHaPpOPrkaq6pzto8yajFP43/xtpxPSFlnK2eytIwCJkKb+DqnN8RYoloKcnF4iNX5dgx6pDGX82G0b+faP8BmEkEb5hzu78AgFsqNlFzKF0O0/FjZRsAxBH3CcxIZWHC7JhYWvWlLHSRk5xeR5+PUGx5fyR2VnfcmWeXSVZIEVTKTa9LRinkZpz8MtOcJIHnUsMm/jiwtJb2M1C4GVyjoaRy5xLhNc5tIGpDLPle+ZufbcqihJT1uaWocs1U1pSEyIFxry+03SYYCeKxNNqszCUnnjJynK7NQSsAzDAxq3H4wLvfy50EqHwRSXW2/LTjjfYyUh1K5BiYNkLmlLOzpX2edcUZJ6gEL4RKGEwhOErzwJtE99pBDcjMsufJpJNwWuxsldeyAgk2qP8Rr3yn/ctz+ZWP5xspsnC+xKfwNgaIrL8VW9pDNl6E3IhykORfpMTh2xQ8W/PZ9FHt87ZX13acsBWAHKodZxVdBPlCpxtcLIHhbHsdwtekctuE4YQpR26agDBdmJPM6LYzTAxOP1mHlqsieg7KHD/eDeZcIpGzDeU/JGULkVgv9I+/Oxbz02uFZMi/o8f3cAIRvCxz/yggVshn4j5H2uhh87/te3QYnAJPdwtYrQ/6qv7+hSGWydTO1ZrAdwZnKpJLkztnOHGzN+5/zWsea2lZBKdD5kSRzkJnEPGGvR85B27yZlTUdjdbgfI3NrNTfE+U2n3+eNWz4wzifGMmLiM9eiQ88EuloYsKbPmWntHfFGG2mHKZtF77zCSJv5p+fu0eLOv2TivLxDMtBvVdsP9GVl8n1AM+XQM9UlTuZbkkQKRHS9zD1QX8pWA7Jwu35eKyTkZyPsflUJBb45gjdv5Y2Z0pnJvIU3MrR8AV4eC4XpqCWhW0FKATVKugiBySF5304G8FyjqUdEnV4/xfKAmeOjZSxm8hqF0bNrCoZUAM4Isgfx40/w1V1cnAujcsEVe27VRxskzM1eac4a3DtHCYTqjLfThK5ELP9xiwYUJnjCZK4yliWLQ0kGoMnPzOdTFpdY1qbnWcQuJdzVsMYhtqFNWG42UyvjOEXK+D81F+u2U2ckRW00itij+06VvWjdHPMvvvQ5C6q2PxUiRb2yfIo/O7reBgYV4tqJ8ejAO1bouqKZj75RpG3W+ngUfQCcWvNVhZgNyCVVdCbIS6BO2mhL+g0wLcbSVJqTtLh8BW7vmery2pHkRo2NH9Ist+hN8N0REFmSTvPpiQY4KgsdCS1H2NwkFZ165ur0MpxUaHWjrJO8P6chh1ppZ3MBT5cwO9cxHXJOxoFK4v5d7DzjzTUKGqWYKc9nHPBlbnziGoPCf8YoPwDXjyWRwXu9pKyjbZeeLETh+Hw+L3F3F25ovHD42Rxj+nu6KVS6d7mxW0aOJLPpOyppnb5+a4Uv63UFbFmSNMJfumr7oFWoLRW4e3leHEimy3QdbkL0pRItSPQ7ivXeHjlCn15D9MkzbdNRiAsMU7BGZXIk/R6rFdOwtFdvV8JGp4x1dkhYYu1wJwjTGXMYO0C7T6PoSxLOuXX7MnlbLevbhc1tM7DECqWmGQwu+0DAHJDQz8kUZcePQx3dszM7TnF6uWZeGtiFhGOvx9bysRuyNEzMDtJv5nIDybKRhFVcuHLHLD//XhzLl8e6ReP0vhzQI7+2OtNlD/4biEcsmMZb8aR/rMUGbJGEFoBu5BOarGmKagAoCnimTDrCVZTqkMx4GIEjC5yAgpHYpGzlwa4D9hqEX5+OQdXSvoMP9+OLI3fFEawE1dkTckX2w/D48VYRfBvyDSFefffoUEhAeth2ktzp4Vymn421K8hoXARrQtI+OipuTSgiUftJUmYaJQTZxM1HIKNi4BNA8jIatPAGejWsOaCwY4SRXgwYduPs0KFZ30q56WCYLWbqcKkgRCDb2PjLx1C49KyOtyS+oXg1r+x8sqQDw3uJpIMjJw+eA82NXRHdQcHVpiySQRiwjefM2sZ/7zDkIbvLfhyJX7YJNMzdXNmFL/03/xaGmZh821VASD14MkzpWUvNz41P6CAH7rtt/CFqroWnTvazc+C9s2MP0aVd12HW2UikcKhdUkAr4jlLDjBRGCpOLAO3swrU6rvpiKHrB7Qs/Qsr01ddq/FRwV9YBgVKzUTcr6sLF4XuedqHwnnCi/LYtbgpzzSUhF2hPYNt1e1Uyf6a3oa9IzJA7ax2jr4I2p/U525tHdurpoCDdFRMYu/k+ovU3rojctK0wS0DlslhWSjtC9V84m/CTyHhHOYPUm1hF5m8YKMSuuUlYwhxwt9FA15vMIrNTzAKEvB9gxdctEzhVfG24sMIzYYKJbClx3Y+/vIxkrxML8vJ1bIbyV6xo2Ojby2jitZ3oEoXRyDmd2P5OYF2UmkLzpR6EHzGIZLshIwboLST0HPV5CKi3f09IafM8HVavBnvj1Fye0TKB+7iIOJyqNVXLTosxLmJbN2xMD5OE9Z2rBpmnb+dSJFtD7IReuiaFL8P9P+k8Ebaa6SGzw6lAj2SP2uoywZk/fh7D4qZ43S8+TsMnqug8KidDsfH2QVPwPutDG/gAeXUAKyWWfD1ZToPBVg9RK3Iy2JSd0U7joQKcY9uJGm+1B9vR4sH2dyA0v5Jbrw06Ijv6U5n83V1yfgqiObsjx/G1cNwmw4mYJJSsIA5RJpM6ZBKKUn6N7RuH/kHtIglrFVVDNFMWhAaqEHqThh+BA474QyOhTBq9BoJ3MJz3yqUky65Izjsil2PO+Fop72+IeCCiB96c9NrrzvUpun7VCZUUSX2KULohQtf6NKGHt5cNVyx6Y5xNxYksG1JF2nrMmqim4CgurSRYueXtKdvrL0Qb/fyPkuMZ45poxOt4zIQssWOVEVXuLaZgSrUmZDN4U6m6VrNejkzcv76gXkaVVsySkZ3bUnKSKewB1GiXi+RR+cmeVCeubAZqCsgvTl75gZzUiSoCNFipVQnciXclYPvygr8gyaxyKKyGglqQ61B8PkfKqc6LQRq42Z36qYeisGOvnKVFUL4KdmZ4RWUbL2Nvg6gVOBRqpiWrzKcSI4AaIr+ytZfTuMf1qXS4680SG7cnpYVpo+ta4R1ZCLP87GgyDM8HHKuCIG58ZCF1TT2ZmQfDUuKaFWkb++roMitfOReaZGpyCKRXYKEwO2FhTFjhaeKZNHwAoSs670pZCvEYHpWKHzhJoJ2qZ496kSW4jbfJBJHrhh2TDbGdGYgfY/5TNLqlOwmE8Oq8qhmdSuoB//nEwl/u3ny+s6K8eonde8LW0KY5blw5x0XnU1CBeOdA0JWWLWXTp0jEcCZLKMaGxYibaHGf00Ji7Elg1kGzCCix7KfpLA7tRBqNdAbh1c3RDZmx4d6Dd+pu0f978sFa5I1DXRSU6rfOhzBp0Axy/kO/9CFMa9lxHgd8oWwOkCdIl2xPjWNWXToL9BrO6gehd6FRhUUYGlxMVTwSxOJ1RJYpT3oTNidiTHZTnUwHYktVzey4pbHYR9cC5L0mY8uuNCEBTncvhbjYfCfQ41mc5MPNuWV1I1v0tm/eDVmqkUgDrGe68NtMgqV0XMmDfA1acMLZBphBrrXMqBU02xfAhHgP+Szq4bpi8Nb0RvjtDH5bSWV/r51BoRZarJvlMCIJbZDMPFZeURpACSjTodGmk2y66HLPhI6rfxEIH3FwPTTp7YuDgikiMgAMYUzGKpfqkaNj87BUsaghgu5Pg5Qv0WNhGKRexzIDcAJtf+IZzi9wrJGCsXq7SMVekdrbVo+NvgqqHCCf7NHn83kDet5LdreKePKzp7YiutTTpKxO2QwEDSEGow0V7IGLfMfhU4ISsJkl1l/rW0YjEW4oNLtj6GSQb3YxrYuDYT04w8NpP3dgN3qr8aBUvX8BrhL6EYAfZx7EcD9FRi61BWi+j4PFEtkr5GHdVAfaNJ0PoLAt54fBS2C5qzA+UF6gNco3JUUoc5UBkD5WGYdOhlIqiMVxNScmGGsfNzHszpkgM9SLpVlruQ5QRp5/E51GYKXD1EQYoqPagYsHfMHIe++9LPOcFftlCOq2odd65Fym0/XwWGzXpdxd4l9NPYtOVmxPRL+t0x6qpWoczUgMQIRiOoUHne4dfnLJEQULF8lZ+uC6OehAuJn+VwKS4FxjtuRKaMNDcV28XzQ2AKqo+V5F0fVBxDYhsPa+lvo4uEWQpNN6HXRHWizt+Te5gMSoGB4fqpMfGAJ4OSxuU/nlci5USB+FPr2hwPD4LP+sjMyMACExUt3OG5lKoHsJOA08vkg4306lAaHwooQwdBjmDuX7q9nJ5mKa5K5Cyxqnor8a5N5QLlx0vy2Wqycankfx1f5KUNF8l3wWwlm14PpBmIxqD9wngwDmf36a+tsKBCQ0DjHSg0QJ9BMAbLZ547Yac5Hawr3nbIHsJ8O3r8LN0mUjsnJR9moAQmuXhrQAb5+HKmLSvpDsejAXNSEJqGv6FxjTtKTGfiwVEeOeBowK6LlMRsd13vAfSekmZJ/D/YYjGUtEPDBvz6C/4wYU6OVyWJX2e7Z7xym+kRbOO0YaZrM+lzLSUBWSvTliKTmUKSDSc/MCQFDYGkD8Hpb5VCt1DOEXMY65vkBVK1lB6maDyV7sWwUQr/cixjIm1/h06TWCa4jIWc8G/286SM34LJoQxhAwdrSm4IN87iyw1Nc0W8yEd9pbyWuJgaA0V7E+Wej1an6ctrRSbzzIYymEmTtwmHsWWD2YaccwKDYGmAnQwY4vD61DAzPFhXlL3YzRP9Auo/ci9QvBzjt+bo4DDZK6jOBbD65Ed9rzUFn93Va3W0nOOTqVANARvqqxy/Y/Oiq0w3QBMz2DUIxKkqdgvxtUhuPpFkmKIeFDXgqzB5V1SniiJJURLNrECX8dVX1ss47B36C/cM/zayMnF+yn4JUYo4WQx4ZS5TNJvRH35nURf2I5Au4dY8/r2RAPtJy2bqWd5IIWipoq9GBnQkuuJLd8LpYSX75k6M/6ryX5S6YJbDQZk2silzZe0yURkY3FLtq9GFDWIZ2DU4yEXrdd7H0qVJf+8rDhPxQmXyHfmtnpc5Hn56Np5ntNtVAAwIRqBnCxzCTS/9ZBq0Nb6c6FgC706GD+fWuBv+oJj66zb8XeNZDXqL/GaFT3/ghQSmAuaeKJkqhi7uQDWyeSOEQwXor2BGhywrqldEdxGeUgD31eqf8+VvQqmXHqo43SD2AFgxjD3wellVMCqN4MrrxE3wcppc7Gjf8NmGqYlHIFeEKgVyHWIfPZr5tbFan4qpjaGB0w6nLjgKxOpGuqE4jwtolocFLI8DsXmOtQiHOUlW0ClOVxheOZ8Ov5Gft4ZUr1oGGfn6+sDe7IRnGQ1soMktb1aiP1ymsWpMO8g79/0BbQAZ92LJwK2AZyxScdPzFvA+C8hYh2qZiAmoHMBYkxJF1P6I7AZwVnEaTLpGRMsk8zY0Rv//guArxtLsQAzzSf/5839zqlt1K8fO3dPdEznkcEkutdpdaSEIkmF59eQn+2UBAwJsWI8G/GY/6cmADRleYAHL1FK7S3LJ4QwndZjuru7qCl256uZ8/5zOOf4+SjiIqlJJIup2mEykhCThHgOrRPwwBwTudgI3yEgAtPMoc8g3WCptSH3F32hQ0hITg0/7WnGCIJa7ltS751IGrIGunSjtE9F+jh462PFjEiXtXwh5h6xG9G0lsockV5HAfTAzGGkTWkr9U3V5nkVjoJUVPQbHUA7eA6zHshgvSQz8CLsVX3Jo5NFCNwpl6Wkxk/PF/cNcmkX9CqcWV7rSRid8q0i+loAGi0Ns5WILMLqJ1SHmZ+LilxAZdF2DzRXQ98QtT87PpfsqnBaD+ROjtgcuMtJDEq3eVv7aD5PXidc0GUtLGYiqYjafdKo27ekbDM/UAH5o1+8YT4Z4oWtujqKDde1CiJJMZQF7H6vyQshtDf83f/Lvs2ex/2LWd8FhDtdX4AqL3nDUmoTrOWmpxfZT4g35QwmDVnR4EaYOmLsJ3LoYZWF+RLOL3FsOLSjb13K6Lwp1pKm8twyGC5Dd9kWgp8dEvIkLHinuJHJeOlgL2ZnBgFw8o6vH4mACW3r80JHWQPBmykaPUXlZSWtCTVDPF0TD946jCxf738TrGL5o0bQEVgB3VHRv0evcpeerECdo8QzKCuxARPro3bd+5Youpkh9n3eobD+yF08krYJ3z71kHT7uQXOQDGX5eIHLWbx6LbcdMIigwcjaSBT24uGr8cANO8vqXANkdgV+Gc1m4nqBmALVhzIKxKiG0jzcuOEOHwdvamnZzK+exKKVkqtgxI2LPgp8We5IhZCEU1kNiLE2sVOtQpDR4Wc5LClwDsB9I8VT2gBiTDD+NPrvJjHytzK5n+GuDLQ+KT3znache+M1D+AdT8SKdoaTRxk+W5UZoLRCXp3yNZlsHoMuwruX/MxRH02hWqALM0CeTodfT6S95DUF6J3+UVs47+Ih5WRB9lwlr6XdKdUktPWVh9rpEVC6/8TBq+Fn+Viy0bcMSjayKWi42IS8HSFH8NtJMu2AUy2tr8nDmpA1sdVPp1PSKknGGMfVFD0ljU3QuuQ5Fa107WNJGuO04BJmymkHjs5x9ZrVFtkrE3AbbFxyOQMu8nSWCjFBqQ8TWdQFrvfTwQBlC2J+S91fVztjb1NS6ml0VtXjWGR6wr2I+XkYExwWYN5DlNLTi5yHyH1ATQ3ZdRXL9LAKVseg8Cba79mf7dn2tfjdRZQG5Y0z/P7L9rALfoU8ryHuN4SXSIkL0Ds4aCNS/UsLaezL+fHJVFpFmg7F+L+SqjJODvPTp35Ll8MBNwEajNDVIzb/g1R6IYdH/tkpXsY8UzYuQFqZqtNNwSjj/zSIJhYvqqinRAO3usfns/6vt1UjwdZJEjfdoKYOjJC+p9GPiZ2DkDLc0vLfAom6ronpQzi+incuCCXpKCdlY0F9oIOIL+qDJefIlKHCN19JXZe6KqyMoXqZOBNFLUI678meniPsOpuhZjp3iZsUtI7Y6mN4NYXpR7yTwIcjLTqLz7x07gPpmqV5hukUTu+HXiJKHTpJsb0Nq+tusxyCrlo/NqN3gi3D6lL4wgWbX+AMBwOK2xnR6dk/HSPvtXgrgpuy5vN0UKfyw0TZYKUr+XpZrGS1jXPcVpMZQmCdOqdRbY7nJfs4U1bOeo+Oyfck6RfjrYemKWA5Qrg49z83L/B1B+p99VOSjCzk2HQ9ScZZ2LPQKsKjocAySlV8ehUvWtKCFJGGcVwl7IeS9QPHzaieC9wLnB3jBcTYXHjSGGlzrpSV9GWs1kF3HlhFRG2pPC+fK2RgsKqQ9YUUznmDjhYeQjOC6CdoeDsuVhOsqABIloFZCKwEuB4PdBWpqN1h0ve8uoc0ipxtVJCE7aNZifTn4608V4/JCYTF7ehqxynU4mUFnxjcwNLja/9sX7QusRPR0hKbK4PeknzeBxUd1YTwRvB6P+Fn4K4E3FU4dZF8rQTPrIyvWRokGPdU0gxQtZ5UHjmjh0BalusvgH/myylVNHxVVYxOzIryXiHNpnSjl0xPYKfGazuJeZ/hD3n/Hgoq7OapNAux9SnGP4meb0IFFdSK6i6hRZfoSMx8SFQOVyzkMblLgvhMRgmaztiFoW2LpFampwOgNXAqgbc534gkf4a7dVSa76JYaUJ+d09PCH6JGNxEgcp3Y1Xd1ch3WUHgRpkxg52ZojKlFci9He6t204MF7oaeCa+PAd/GiqfmO7vAs3+kXjF4UJA86/l8wDc9EC16fyWUVqjy3cxzrLuEJEyVIoaY6gYhehL8b2KyssyejRRxnLjQFzNFAPC0yl9N2Yf1eFa6hwMC2Ocomnil2WHJ0VGc4ipKdA0UXzi9SHch7z8MEMUSU5gaIl3E1RPYXEQHYWk0BcqBKM62uomNiN7e2DjVqaoIAfC7VJ4nRhHGtp6KCV1m/xcKjpstC91TxJjWVn+NHgasud9+m+z/heSBQ7po5GwS6gE2NOq2gfJZ3cca7N1MTG8Aei+lebmE7KFSPZfBO6p7j0JWZ41c/I8ickqiXx0oqG2ka7cS2I9FRO50VdqbeiO2ctr8C+L+Z/vR7868b6Dif6jWroYSxRvPk/SUfJEor4kKjq9vhSkKsklaWuShiE+SKE1y/pG8pMpGBBwCdiooSm5UA+li9+5qs2ZplRy4cMBvIDYjIG1Jh9lg0yOrp2D+T6/xKgoQJgVx5fodjCbDOnxuc1+D7Z7MzMXfFuq+8vSzlvFE6l0lZXVsD4GiQuzCynbTnrp7GdnyvkvWC1JlSUJ3TazEjxm/npGFBPSiuNTR94cpiUcR6O0pBKXib4GBeEmSyWGR7H78qR0k/Ic5fhWuvAJPjzBl31IjzR0C7OXoD5OTkxxnmCV4HlbGUbJ6XV+m7B+nyGfVQlwAvH6f4+UrFpPagGE8jTc4aKWC3tfh8OMTKz/DTgbEN0nhg6kkUgJdBxktdkciDtAenIT/PNrZRiQw/1Z0Q1aqtKqhxNRWq7xQqHuLAOjJUgXux1upuFY4GspKq3qIgfSAFEJ4CHESOSdKDDoYMDqDjVQwBAkBvEDONYpK/FMTp5KycaVMDvBRQf0Fw3+x1owZ6M2VpukAN1pRXc7kTxGvofje7RUD6+4Fb1Ql6dIWcryVbcvQGE9zfREwdamr+PpqlLKsmYB7wd5Zz/WdaPuBu7HelcTSiUuZDwOSByE/Gs1P+GXlI0Wea0OfIa1MWpMxa8yQMoBzWTegzRDWT6Qlg6gb6O2QW6MUzxTCgmcesxOY+ULqlRw47b4nvBuz/nhd/RIAaHKYJkUTgNTw7td+MUO/lNCbsLC3w0HN0R+Mw5eVy145gd2LOwwPw3I5L+WpwXbogk6yjgzuN7x45CeFGTik5Cl5f/HkUTMFIOVZONnqqNgpYWIBk/vkNx8VxwXLq6hP46XKkaduuNqqYn7ZV3iAkeC3z8i06O0aZFGAXvLSTqFDRdEAWa+2ObSrh/c6hNzm0xjaDGyPxZbd4ztj4LzRHp1Gaz2zTlVJAC4OVLnoV6VUkA9yJKEabuiUKL9j6eozD0p3aexNcOpK9dH8i2XpnF4ZqvyjO9UeSclvuGXXCWYYyNFwGrkvlFDXWYprGbV7aLnjdHfcdvaBevl+Ds5S2/G8xkHB1Jk43wsJx1VH2IaJ+2x2IGpHUt9IFNFyGWwJKNJEZ4G8MF80EtQZVcxoXrWjwebqQkkH0CxgGId+x+iOSMWccw0kGnT0YK73BNexjdmdAMGX1kmVFOS6Kn0rcWOQhrG+SWEEoYRICeesSTrRBo8yPRukanB1aorrqh1ImMfHo2hG+vVJ+ajMLisKN8N+RCxE704SUljWJTe4WsE6oCocuJlpX4e5w2YscEV8DOUAAKGSySRxL1I8WboXZKsBBIfp3UDjE3UXAIZP6w2FXiWShyANXwJ5EI2zhEAA6HaJHZEyvF4LHxbmvPVS4qpz1csdJqGl2XpseR0l9T/DOLNZeUHiTMOLPka1Cb81Zwy8dI7Ju3PWDFKXQb8ptNZN0OdaCUl5NDrgZmcplxaXlBuHCjf8eA8DRbXNSzg+zNJLYFzSseFdInEniBvDf+W0EoQjS1fbqmSyu5PuB2AgxLSuqIQAefzSfuDzHg9kTIh2jfFBVNcxOfDyZU6XIoLgim5CLhiJrjQPMKfq7UU2NuqORZ9Faqf6VbN6RCUcwiVkh0OpSA5iYR5qfsRvMtZKTbHLV967SGJ7N7OcRdCA+nvkvQm6hJ0ryPHqnjhzpbz2WV//I7Unpu2sqbILlp0tM2XrVmfn3lSrpI9WJaTNXavSQzCLiH8vMqyr/DdrgWKYOthlHfp83bcOokLHypKJb57qinXgD+dOMvmcM0EjSRqpg7CE53pdZjxAAQAlBK7wZjhFMZqogQDwvNklulLd/8Admfpker8OSZD04ymLOaQG/SKSotZ3hCGrSZaDnZLvCe7f9Qjm+Xo1TVUAxRegt4tnttOHI/MHQoak11M8vNpo2tRTUxGIOMZip12E7pWiFRE/lN19tgu1hGYMKs/g6+eojUjc8dMgjsiGaGiLMWHPOOByyupNU9u+LaB9IvzkFiLPK/FHZ1nrlTDBYcOvSVrS3nuKqx+pg099PVJWKsqjYvEvksy1RQuQAy0ZYskLe/wfIYKyuIHsp8HVxfQi0F1UxAB1p4Z5d3Bu4C9rc9IDBSbQiEaV4niON9L9VePwj9XtGUn/fvvA0rUynD2G4xNzaiU8GAgWgNeHWu5uy78GPFLos1w9AtteexMiNxeN/w10QdK6YKqU5p1Yi9hwy1F1TlWOfgNycri0sgBjauX3Gcop3E4L1GDpTLxowRliDwF3p/TcshzRfH6W+FOkJwyVhSH83oGgKxt2Wp6eSOp30JgQF8fpsY5fsChM0UUs1kTDDNiTkI3XsdfS2KCgh8XrBkhNBJJAQ7rmABAF1KVJu2fRKUj05+mEaN5Ep8N1fl+su+Bi4yvd7ihG7uxP31MMpiTNYNc/PW0m1NNSdrM+sOz5MCNRm58XDdLunoX2xcFE78HS3qqYHJ6JHhe2l70n/8UTfOBhURvEjYi+f7fBW890hOip0KrCGsuLP0YkYucvBxHZhSESfnbFF0nM5WEf2lN3utth2i5Dzr/IVvqRYHrHn1Sm25MMz2EJ6Jx5cQOeNpKFu5lNqvic5HQ55GcsHBend4h6dawMDamCRJtoRZFdEKShPeb8X0kmS2UgPQptEYZsAkRvQf3I/JT26vNyMn7fA5FBgTjc9m4F51nkpCAWwOYW4bjcpCTYCJHdpdqMdTb0LHw4CupMc9DAq+208o5PXouGOA/uu9+t6mFNFl+CqcN2lci3gBLHe8ly1yXuDQvelqwPTZphwxPUdlS60OnPsXHYFzKZnIykyVGUyIMQT7gBSUVJ6jZUaEhqjseUdczXhUYgszqHK7JjyNLP4jaVqQQUrgZtSeyYyf3hma4E5GbIGJweKnM8glsG9n1waqQ3cS3duTVCf5/1VijhL+iBTcsZeHRh2mnOq2O9Z1OGVlcr1K7QP42qb59O/3kqjD3dhTexblS/rISUMlpJPiOB099gX+q5zRmXCqtA+F+zz7ikM/Rs3mY3PSKu1j5Q/Zqat9eyaUN4NejUsPfEMr+a5zfDbTr4TeGpWJtqIqZCT7WUjPPOySVg/AcpQsdfTVrNVVJZmn990ZI4XguzW46HZAGTWtnT20Nkuw0aWzL34/gOJ8sXxPFFVZM8m6UKOi8gc+QYfhI6kmWN77cpp3p9CfX88nl9Bwn6gPUtOXaMdI9eOom7xWIcRG6Fm3ETAby3sT/wZoGbjC7j0ACJpd6ZEiLDugPhXfl3/xbQKI/9cS5Wj/ns1M6ucFuyfboJp69DknJ8A7VnJCSQdwuAkuXpWLKZe7cCHiEQiBabyqFJrkbMMOanjzE05lTC/O1ITeuptffJU++g2An837dXD4JGAfTOfV40fen/OPPcw/m7et6xnngFzm61Nykre10rPW22wn0ZA9Jq5DR2P4h0QJacfmwB9vXYZuQf5uGqxX9aJHYOcw04Z1TX8ere0JrMWU867y/cGC5NwUlx0kiAxlAz5dZVskV0WvZvxFCx1FUX4RTKdThwjR95sDyr6yyAY3jOK/ElwuUL9FIY2ke5ooQARZ4WLOlpCDoDMo90T3kGTdqV2hUpv0ZYSHfmKaZTFw8o72/CScI1AAsZOQTzLuPycYSCuZCTwFb1+qvL9neAD6Y0gzCiURnLtFi/h4Ur/ME2LTuBCT+G7oxSEiGvx1HlTPFmdPbH4iH84rp42Nq3CmAbypqqxUHHUk/w8uJSLjMR0mWA2VsX1a1mUUqkgq+V9fGZLGbRiJhN6zoLyTXtauvSWUvnJXoyV3OqvYmR1czZNZRD2jRDCX/xfwGhR+cWJGM31F/7s9IYvmNXY38xsmakrOJRovJByRowWwX+B/18+q6a1IpSeLZOcwc8SuUuAGaX+JJUe4+yHatWS07LbsJOc2868RDWVkI4DiFg6nYkvQUicEkLRaJSoXaiHSX2wkgqnxT52GOEDkxj4G3xE/bqFQAzTfAmYCtbGD3pd05sJyh5S0+WpOqCl5v47Em5GdxKWe4CbjYyNpbqDbWZpdskfi/4fLp3LjOdC0Qs7fGTAM3S/5G1rhaCHpH6vIO03+DWQ1cnAH6Q7j4gufnIWxTcq34jfcL+UVvKiMDgItC4A6UTVk4x+jsTngnFJsDhb9zxzB6WxJ3ZGpe2jMiZQGdn1OOEIgqAlYYGAJmoYab7pZVpcaXqFsaGdVmNB56QVOpvYbfmuyc81tmRtnmrxfQIy8qRuDra6TdVq4YGOk+mpL8QJ4vumd/alzOPCuKi23KC6G+7hdj7Mti0DSDsbTjZqvtqe+nIouaeXOOgzyIjw7Vr2Pvtt3Ia6AdwXpNzpylDiF8xlIItHZopGnPiDOVYl0VzQhsB3wZqk4CwTUGOvT7hKZA/0N8tkpuvGBFLg4Z17GUXZTCaTA/EFpTXHuguy0LDqiC1+bZ6Uj7LfZ/ntU2VxypQvTA/J1pNGvORg3Sl6DXp9TlTg5cEL1RDdt6XGtLyS44ZemY0Nk9Vi+G/CfCnDGlDPDdf/3v4RwXY0WoYONEejnG6ES6y9O0BftD4lxLH3ZmuYTvNSdtNV5aKdQ/jl+8j6XH+OGSf+1Zp6cjGuXMBbZQEt4aHulgSAV+JW87wLmhjX8u848wMUxziGshQn3vFSETDj4rT65MrWmTO+vRLgXRUlD6Xhu3xK2Rn2fsbU+yeZJtQi2nHLaoFcvrI8BU1LnJallJfojshtm7J8w83WoFsx58euErQHnc4vF5iNtxdBJfAwwK0g0rvKZ0LhBzcvo59kejeA6ZN16l2lF4+jzuhny1mRo291vposw6EdqNZ3cqRrJA3jwIP84B1GDPeZqd1+KUMJ3EY16yUElO1WriaNpUcOkVuHgKs2eyviZaG17AROEy8+BbVwLwOCXOZqI3JVWCB+fgMzMkNthdl3CD8xi5hxREdLEya68lpOYqV06w0CTmity8ZI978YDy50Npax7ce+78ogwfFGTrn4/R+Xycjp4HaaWRmgExRzI/ZfoCUOqaI/OFUDQ1OM7Gd1zJD5FfQuieD+OUx1CNceGj0egx6bpoqZX3/TgdpNFMMYdw7Sb/g00pEY8OCjAD4o/DEwuLAC3GqHOtRCUUMagpQAA4zYGdMB7sKcOCqHrAryXejA3NJPksyaB4Z5Y7/SI5XJJhTtYX2PoLnGKw76X5bVklXHzIbALwWCpdZ/hRGiciqSooS8s5lBTAMIMqCetkkFtOt3uFkQGUGMQknWgK6cFqTIorcZrFZN1O3lr+CIxewjzh0ZIYFUOwnClzCSwEIILhkQaPYh0A+Y7UMaW2EuemdDFh7c+ZCtJ8xrFx/p0/Lrwp354kbyJwds3qtCDxAP/lX/0PN94qvB2fHc5qi7pYovtzoESlUiUpFME3FZEsKqV8xNb9IUCeB6qjbGZfXjtJxky+XEvZhr1+bpID5lzAUw5+2nRKf+j+ct+/bmnFllJ6xvpfOM6hsXUtF2zlsBxDDG61ZbqX7DJVUUgyRvU2nrkiHbPcPrweaUZFqPPOFBFgMAkQJANzhEQE68Nwepp676JJGw8CSbKJAvG9YQIC6auZZK5hdZ7nSqwsxGSRH1qcJmSd86sxzmSFNiYjIFtdWugkxpxUwHGrrJ6dzXBDCRZT844Trtk4ptsBePeU7YXR7bdanuOui9Nb6dkZKiXEeqfyIfrweupMxIt5wyuy7FZKi0kWQ7irDH+V5K94Qkm/LtaqgisgbFLUFL6Fa4uwn5NqVBYZfKhgmODGQxGVJRlK4yPxbkZJe9e4w0PlhvRuyvM18CPo7cr0tBgZBWGtOZ+clr8ee8bz0r2l0P+DeKtH7xx3bttUlsBZCR7Pove+Kz+2e782ywdSlE2pP0+1DzTFUqYtsYJjwsV5kg0icO4TBEB8gj64AhaK3sXE3YAzxBdkVNZZz0MLOTS9jFunfmmfRNlsUgJmCSsA5afM9jhvhfYGdf4MuaVgc4QKA/idw7Kn6NRVxApd3WGi4vd3LfsMghEnd6XFWsofe6ddlYdcf02uEa42kxtS8nZRbtaEkcg3+1FvwfAv0kksSqe50iw5jbHsBaUN3e+hoIBfqmBFBpsn0ospjwtwkOeqCiql8LmaOamOyxrxXZR7Yay5wSBNS+vSIC8d0ElZUc3ddDaBZOTMqfiJRNyS9F6VjSkYK9wQ6fY18TpgiPmnKP1HC11FLum/9cv3ovYWZHGwds0vjpWxHH4Ua5CAnp+/6cz+oIonOW+1huv/VG5HlDWRWhdHBSwwq3Ml7zKlwkexEKsC2GD/HtvS3WJh5oHCzNfNAN5m4okL1Ymo5fnBMBmXNFrCuUb63dSpJdqaGR0s4tDmDRHnc/I3BA572krCWkPmjRnzITfgzJSqd5WE8v4Qrjq67aN+j98domvAB3cUaSmaDaW5X6jW2LnYNPkiGQfi6PvoVsO458ZvFPmoIB6BcGDRJwkmS7EqCbs+LdhIGNw9zMoMJW2QU1JtHffmUJ4H3FNxJ32OomxO/+xF57tY+VbnH28Vq2nay5vTagTGdP33ercT4TQoSJN9rfy0gebn2M7bzGQWnxu68YhtU+Xal87cQYUVIxerCFQu4ZKrXGFGAFzlsMEmMzUzVF3iYP5/R1bjDM1lSZzA+a3ITCW7D1feeT5Eg/esnJKGZtIKZONeX+UQ7ShgLzO8JDvN1FawWIXddUW6QFlb9s/jt9RQO+a8igwB2TxD16KQS2eJmG3A4hTUt1Qzm/Y50mekMtATl/fr8nQG1lUeQihS8OnIjFrxZYbMKKv6WEagNUdzMw5K4ncT8P4eK+5d/QEo8EbZfyBFOB0mAr9VbrYjPAcP72RGNMlPkdkXNUdypqmb8DyPDhfBukrFZnxjTz79Tur1fKtQfuBdPz6W/14f06w2uCmZShyfKpen0meXXqkI/gamThBtTRC5pYwMCRhCvhDRVFxIWvoUPJ7QuOmNVbC9oI/z+XclnqvxsofDJeL0SYGk+iB5EmnjBjfmiTSGuAlynQB4adNh/H5mfRuXW5z1MGhGhk6IAtF0HG8f4Yap9g1YsgiTubfAiw/So5JoJUk+hegrY3AQnv02s6hTUcShJ0oYJATakCd1USLS+g13eGq8mgd8yHMWsEPARoB1RIAE1VGUjVCFh/N8yZXSt4pzEpsVMslFN+bUvg2lMy4r+HlZ+8HmTB4qvyzjBsIPi/RNyvI+Dc00OiOF40RjMHdTGB+WZgPNI6w+hgYjvJUSIngds5U0cXkMmZEhSla0TlD5MvIoRJwPx8H+XGGbg/HNuH5OtVg1r/zrbFaaJ3GdOV6ypcAhUtbdBHRAf8FcVMN6UW9P/KmkVBpBgmMlkfIqkzXxdQZoHVhb5a9+TEnBq19HJGS8iU88Vj+R1u7wSYQOAM5M8MpWOvFwY89YaTnPMVwo4bmlUGPF77UOPan8mTwarulWKlcuIf6L//XfuRNZ8tGUsW6BPwricaKmFzyX0Oal3nNRpq9+5oeBopxMXIuTUtN3OfQglG4iZYRGPTF5jspFyXJAJyPiodhSoHAhB8jnwLuFxzURcmQdq8Xf8sYLr3MS92pUmiNjM5UpqgdQngmPw3bMrSWxguzeLfZacVckaW5I2ynoOez2HV9FqOmQigxnaynfCCvH5tl5gGy+Y+FRwCNK2o40NwL6JT5KmWbi/MMIrcizT1O6TWYNJPUlekpWAh4t8FglKxQc/Jjwv+jr7/nXFlBGWnU+pQuJ/T5LqwAvxy/UWKqAzzB/AY0jz/9MymQwT1R4FcFyFbDF+AX3V2fm+mV60dL4Zar3IVeINobjgC9qyPs4umr42AQrrnxvOozPwtdUm65kp3cC24WZQF7eYoPVRLwXVW9T/K/+2f9IDSzWGd9iOiFzsthjKMmBch+2CZj3yNJBNJPpsIiDR2DBlIsYXqika3IFE5wHYQRvjePOOQzG4L2D4M3AH7l07gYCd6OkgrtWInlkrU0mLrDGyfwd8eymNfpkenMkuxcYfR82hvG4oRwaiVyAoKlATYpcJRzL77/j8lHyvc89Ny1U5aya5FeS7zC6TtGjVGRLSWsLSjtCvxuE84RkYKiKjXIEfHIEEyrI+gBlx+L5MbEXk+JULSDEztIRl/A5vOV40wr9azDSRPYHL43Tvo4nqDEmAmA4kLVzfJXKo0xo5XgD4nwLnYR46QkgEd7DRKwkj9vp4Fty8sy5s4fVvNS+DbQ/8qOSMqqxikqWZdC85gff+ZUTSxnLtyseaEhPbxVxjU5koVCoxwqOEGxp1TdA7huttkLq58CrgBdxuthX5w95W5Z5ht9q8HYVlXr41pf9dtP7rm5NP1DuZBCPeVVEq1f49cxZPFG3suKdSfYfaUsDMU1hpT9bs5XZu7PkteynvGVp7TyOytnSuryTMvRjsotld3nKOrKhsI+Z+J2FPY+HgZha8cOu3nX5S0FXs2K9h8TZVGN8UICEQ/q5cpA3avfCOUtcRGI4U+cWR+V+/iSJ8cRYbzgLV3T/a/QiQ5S7MJ9F4JWwXveGPgxhon2jgDmiLsj+RxhIfH4/HZbULy1eA+bK7zTHS5QSAks8bpKpL2WuUmOdXw2R70t3TqykJpwYF2UUl7BXB2E1gQkklbQSSFUt72A6HKbm70E0lqcNkEqwoif+OZ8WJGbIsY7kXhp2gXZTLOz4b3Hstmiur1Q4zkWgNUhXx6F86NsOI8MS8l3cmOj1AXPXcL+SYDnOvFHlMbh2UvyBUVrRohZxmD/9pZl/XwyWkbEWrh/noAHfBsIrRPVyqs+lYkbFAy3ChsNV8qVSHERnEvbM4D6iswD2MiSfia8YW9jP0VPhWKBQS+rv4yOGmM8KrhxGsExE6zRBF7NMRT/ayN5ctm/uG2edSXQ1pBi/egJrqrzJeN9xHFXBVaBkqAsFeW4SNTA21OMCvz0CTNCzUnzjx/5zdfGId/44KZNrcRqzapuUxikDYhLi8+Lk5rTQINHAg5bLh+cxlgX2aH+JlGEQ5jlsgZwK+jO8oCQ5Xbq45VUVELnw4eeytAC4Be6ptHma+g5bYekg4FE7NXNqO8Q7Vc9h9G0myiO5eAP7lvSWKldu9ANHP4R4yqFJgMgDugXDCggNzlRG7H+Ao7yIF/lOjtcOwug/RV0WnizJeQ0tbcDWCuwtu49I7stn8njm73yhtJd0sJO8Nx8rAf48i2w9ZF9beju4MvG3/1IvZYNifRDeRUT1wDhf3s+HL+BJy116rAmbZAVYfxONe+mehsv3VAkkrBguXhnyAM5Cke2Fm07cZmAMobMZ3ozBZgUcC5reK+SH7LqXKE2/DNNDzseAWTLSIRiwuI+Uwh2AN3vMkfiTArgCsA6a9/F1vn9npN3oB5+HNJL4QovriPtLpJmCXFOvTwAqAr5FtWvhoLBZlKUa980UXYGcIjEFKKuMvAOdmESv43EP3TgFOYJGXuginUhgqR7aEg3fJ8DE6YNhcKyu25h78NkGUqM4O5YKp2gl5geQznvCJNqzES9A9N47d5cBmKP3FRBG2kVBYXdjYh8OE0NOxkZrXa2VAc7q2iSZUxBS4JspKP69hKaZNSt63VCDBWQO2JM3drmp3df9tmw41+6GDRfG1/uFQlMT9KUcR1IJZNUsWJgLLEJuDbG9xYkjtYww7ik/aXmI8INVy5lPQSbZeEtSVe8JeGcpueD4YVEAJL2tGF05nExTrpLi3dEcJAFwLAcYBkAtKxPGHCqdgk0OcRbAjpfMNvhbpiYv9T9+l+SLzv8h6DAKneMy1+WMkqbX0nYWz2wiR6k3R760oj+xReMA/UaMM1Nrc83pqVZoCmXM1Yu0MwoHO/pYS/ECh02SI6mwJE/CMgSSCkIVb0rJLoHTmG1YSWlefiExt0vobqkSgqIHvsXx8pTW67MG1GgITloonAIlELOJmE8F0IVz38gwOOCMXyXNgnLJkswbiXj/U1E+lMOLJHzlk58j594Emk74et6bSvMttC37X2OyRzSiAVpF+hy3qHkyiAYNtWA49+byLwZRe2lB3J4MQ/vDN3OeS87GcQbR6KWkUwksp02DSblk9Yk+I4AbWK+nsgPHUVT/B5xDIW87vccFx5QeIOYaxNZRv+SCFDQGRi/H+iO5zsH679PdguKXxOrGpINkX3KykOe24vIYP0tj7aWMJJjbt8kS6R1zuAHxlXg50uGEbdyUrxtpJWVZV7qskEgHmSb1DSh9BhVdnglonEVaEYrzxLUghHBHJ6cxjL1k3tDOU/TDmhsNEImhj4X4IQGK8Foq6oOOnswuFbjM8BBNl8KV1wotQFsR719J716nX/nKzQVlJ7T/QTffyd7PNhJtqv+DgDsOYRvhOAQVjs085CthIMJyrJFsPrA2BJvKZzP+/30RaU+tRr5UW4mvTDa8HWfdoCZyVyGMz1l5QnkYDvIJrYBmlVtMLj8cLDDa0Wdhy1zxLJ0LMhJmio6u4vwKVhJxhiAfki2ZrF/b3/n4SVnZvsEDza/16N1lEVbU6ZDICvR+5eZw2iybrVVCFXnltVLsx+OT2aWKP5QRmlPepq7FaeWpaAr9OGP/6Ym1GLj/eQJRgS1FwfMU3srSjBa5HHCfz7ivWDmQIe/GfOEI5zJpjwNji006aKIl0xV4xwlyvt59Bdk8KgzTWzOd9f3esjr5Z6l9IlbPVPBrmwswraGTDNbKMD9C3Sd8aqIPGuPrRnEiBbGq9+rRmqxcIdyZ48ZiAl0yj4Vek6YjoJQBGOHY5WvfAvfz+GlOFe8RVmTnU3T/DaqG4S81JTmFm3pOayf4j27/LwWULoug+558oEXZVbk4wYoD2Z5wORV1iKq+hlHunVR8Oe6OxCvswSrOT/VCAigGxx51rtXGiWqNMTeFWeAaIbzLS8cRHfLvz7z8iVB6KFPBwab2uhgtJ7KcT2FPqWwFp77ivm9LTN6oyNuW932gtXhKT+BcBEAKujdMd4tmH8vkYdiaE5lAXubgIEv7Nf9jisk87EPdSqSVNNkzcPgDKi0j8WdOiqzrarDR0YUBo6mozxIPkKGKHQKNFKo5dDBhc75sTomXReXVWC5y+z45KsNggb0XYMMhCoDXZeItyxuLsL8Og5UwrQDSgIYgq3E4vJI7JwlJjdM+3LRA9ivoTaH0HRs5eCUvCjHYy6bgLSp9EnOiFKBkjMNnDWqL5C6Uwl2UlEjVj4RD0FXo9UOfCbw2/W/ZuaQ9xi+IoIvx1liXU3QlwUXIeyl6afP7CON8GNXR8kcM6tZX1al6Kt0OlSub5J+Cyktx0RTCIuUldu5CbctrcDael3AXRWXKEyxVZU+CO6tRR5beEe/DL+M3byi7TksN/L3C7jeN3CWOCpAvQZylvQAwj23cwdEOGH08xDlglcPznp4L6MYu6C1J3VwqQ3yXJ4qaPJvHuIyWIOoAQnYTrU3Oy7KmCJAooYtzDG54sWrAv8/y4GGwVGZ5SVwOYP3zqFFD5xPMP/C7TXM7P8mF6OusL0nowVcgnKFLApMPwh2NRBh9OQs1KH1gwxShAz+9m4l9SXEspTOJEijuZER/HU024sVQLXriYjcKmaT3EaqTnk9vgGizPPv2cfZNZVJH5tabZBoIr0zmtlKYJ2dVysuy9REmR0uIYGm5jYdxfDstkCG7yvD6Fq/b/gvPGnV8/VpyuT65I7FNZ/rDib5HG8Rgl7FDIS7jEkjMVjppuuwLHC3q777BC5+ibJ7D/37IU6yF0ta+8c0VfLanSirIY6W+4PjIGNTjOz7mBiM2kDk/O4WKJivv9cup5DtUe0F2Pdz6SvsTG1+4qJuJ3lvTVzX3q5caPLI3EPovOXnthvmvsf1Lw3q9CX44S/9eJv5ZNPtW+lkMDYt+kXo/cnHtsvsfSbG15H3cLQfnsArTrA9rdXX6+9ksYsGJEt9KYaCMFC11+I2eOV8bfqeok/mgumcEPS4nLG/ReITaKc7044+miZMj+6vI2olhXxqdJ5PfiOCGJGoQ/XTGr3RlohdicUEAN2NlSHJOZM/J4z760KmmV+nRvBpvJnYcnxN59cawlIGga9W+lkn0L2JtIiW/j5SBC9L4fMtANdTv48wgWOqreyyJQzhM0du3kTwp3dyePUxzRYo8A9pJDEpEyUD+yBx0g1KPniZwjGNnl/gADS8rJkbz1UQaArWGagoIFZA7hFImnbjRBETjmeUbaXY5JVV2KTPzwthpZrknB4up5PGsLg10yWygzJAYEeuPxAYGlgynZU3VSXeRazfi9RCYXRgd4NkGf3SPXzwm+wfuqJgrXbHNgTweBMr9ymwZACGk18CIOVF4iSNlFeqhUsiqX84G5QGReWITjBY51kCYhTZL5D4tdVmwiM+rLDaD+VPLsthKGh4Zxm89rgXw5lfg7Ng/K8eHCzk3m5gneP0QpxP/t1vW+ZRv5fDpoQgsnqyCK0mGUlogqK/g6UK03ZEOObgeQw3mc19KZszHHUY+fddYuk7YMNqS9JM67ErOnDA2mhCVBBBkIczqrtdsqO1893ZBve6aK1NoZtnXOtRWkX2IaQOXDM7KSJ2m/pVMiTod4WbMKscQMeaeosqNdKeNxxTFz8NNAo5pdiKH5armVUgWgWuAqcCftmHq8TdvU3WJdq84uRdJHMU7fmEEr2rWtMPLfTxeloO5pLg9gl0rbcLq/wmVJd7ica1G20MKAVCXo/WuKWWANxbVhtTelgY/7lRtRXtXcCjYMnmzLPV70Kgl+SwTc+Gk7//0opJeOy+5Hyciu5Xafa3kUToRBRb3D3h/N4qqElsU/ArxPCLzzDD5xBbXA3mxjo64IlJQPMF0ys56bLZoaldiQ4HpF85VOV05o7EknYzJvZIIqDiZt3WChUw2x+g6BUd7pJEHldt2vyrwv/mrv1ouBq331e4/8ctZvR8J/CbdsYhF2VFRFQ1QmsMHAmZPqfk0bY/AgzBMcvhFO7p5LZMJ+9bAQQznQiozBLOoFpAIQJBDcRUJiLJc9Mc4INAoC7CFyQ/D0Qe+u5mUahxOlJ19zl94p2+C1atA74f7G0ZrK9ZMrMzUcIqhSzd2k2GizGTwwOTvsHQQJluDTPUAD19Laxi80Y1pBfws5z99wwHCa29Yt0FGb9I7eRbX0T/U+4WL8gefw+Q5O6dsLiLFXnJp4TYC2k3PZPBCoEaNbBW8Nzd1pytMX8tIQNNAkIHCxIN51C0zK5asCMsaVO56fkBLB4R8w662AL3rrnXV4xfusGv/RIfKsvLNLY4aYEEVNTvZFzhQwM5rp+3h6CBoMSk8YNmeWsqiNCPMFAYzMMlBqOHzABPpc23SSM/mQhaQhVw0mWgXiz5AUHaSpMcVBUkFAKbCVRnb1O1y4hXxOIHyvNh8Erxd0+1OeKsuiwnsFQBHgi8m6iUZqiLfRXCZuz6OTK7M+4CmPoSrb+l3zJiO3XsjbZowQeH4x2buSiwWZ687Zq8RkwtYQUQepl0MuA7Lee8PsXWszH5eUa1ryY1Te0o/DZr8WNqtFr9ZnZg3w8IV3Fyb+xr6dyf44UB8CdhpWT2DTDkz7p3HiYLotiLBxKZEDsBYS7MnmIf5vo9MKiUWpTjdfi23T91eMjO2MzvZ4ExVFAlUl/1jEMiRlhwTAMHoVXYgo3tVd1jVZmep/Sbz2ezSiHL/V+K9NIuTLTbxog9iFWST6b9JP3mW/8fEGxdK+QaeYLFwCWdUDg8m42O5QACrqX0ThEP+/tNQGyfk2Ut70c8qU2U8THINXkKINZTBJZ7ltaqBdifp+ZA+AuLJBr1Mw0UinwSEWaw0F6M/i90EhIO02KWTnlD24qmGB7fQ/cUoCqTRRBTHyFXFzExEXzI9NetD0gmkVGRclK+AnobFdihZAXrA7A4kGyk6gSkQpRnHjOdsMZgyt0LnuiGk8atJ3rqVLtgqrSAeKORR/gWI1Cvpj15bB4T3Pk4y1YDeROaR4lag0uZBDkRpqt2FMBa2zo0zLDt8sIBtNcg1qPQtymOw0ceDOLik1nwmXNzOX3LfivlYlhKdAQKuT9XF5+ROEL90Z5eq9HjmxrXsFx9o9R17Lat3ToWxyHhebfcnqoxmDiBZAcaQ7iF3kNVMVkRSd4vFejSzvNqC8ekJ/V4rvI2iPwlRb5V4drRakoMQTRcI4f8OXsRurq+tNODRkC53mdESzwrByhauZafHWPIDqZSwq0lQudQfDP1fSEjWyE01p7ozw6XzSDIdd6+g3iNiGvFvXvZ3GjW5AtWK0Ppg7ILiE4HtiIZxz1TdTynIidhIvZBHgr91yfqvJb0K35nIWvcfVZU9mbWr6MdR3AzM7tgmSOBFGkLgd5L6MyQLcJLj790mfKulk+jGr3dEM/51AVSJMH1FeMBccjQqt+ekwgSrA8u/TEUrMRTwLhuvBemrZ7QnT9bvzYNPwjETalfKDOlEp2QhXp2Cs77osHiJSplTbBo86vGdPCGtiLqxDlCvaF0QcNR0Nl+oS3fTPQOc3lbWp70bDePNV5ELkkJHqaNwj6mDrvjZvH/umM+G/rKmLiuqXIx1LSneJQMXRBk+8njjUqq/9U82NPIjj/D/qE2yXNGwusXqXVYY+6MZcrT0HwfGTwOYrYuoRfOyl+toch0ruuAAOTErXyUjlaazRF5Urg1jbhHpEoeurLQ1712UNIkuQaBCuZckFE2qClmxKgN2PcPSk3BpyertuRVTSkahRsThVBlvSu87JKlE85hWLoF24XsVY1aLhzdhInsVykqnmP4+Fk5KffnMKYy+LdU60Yfz7tv3jAu1p7WKW89xooijlWJBhpX18I0r0AbPfembOHzd5tclL7yRyUhE3ldHL6N+T1upxD7ggIHRAB048vuyuJ0aTTu8es5LgGfCMEnRKg4uN3J778M7KxI3k7wAuZbUuLAv/l66mptNzMrCbufuvvQNGtifqMYSUpz0RhI8H6pfDkyEQKUmDS/TR710L8Rgna4P2LdJMm1bWk4s5Vgq0b2+vfS3Bsm97vdKuFfNKLG2NB1nrPgfk0KiJZ1Lf1IylAhqAQAzJCKhO9jXhJXiKUwKFrO3ZW9Kxa1wJKCaoCAEFchKDQ1wMutGeRnDBFomcdZIZ8nRl+zNDml1La1JoM1DAqtpesiYnKcTE76Lxzeuy1LATQCWvUDn4f50Fqgx9LUTW9Eguuf4WiP5/UxzwuDDJpiESHEjv6h9fxEZmrrSBZbgSSCe9dPFGMeBOp56nzygleUggDTCigeGr3OFh8ZkU8pcHPq0h3ZGycyXzJEvyaSdTfmmtUr51RAkbqrXZMpxygns+e9S5Fg+LciXEb8TqPf6ar3QuwiKIzw53m/8ROreyxv/YWmoQ/OOZgAWp5dooRUdqGRSB5YErRAX1GCqSFEKPxFpWagnIctiuJkfv1jLuWdibgj+f68Wy1ygV5GEAAAAAElFTkSuQmCC"

var OPTION_SSAO_SCALE = "renderer-ssao-scale";
var OPTION_SSAO_INTENSITY = "renderer-ssao-intensity";
var OPTION_SSAO_BIAS = "renderer-ssao-bias";
var OPTION_SSAO_RADIUS = "renderer-ssao-radius";
var FLAGS = {};
FLAGS[OPTION_SSAO_SCALE] = {defaultValue: 1};
FLAGS[OPTION_SSAO_INTENSITY] = {defaultValue: 5};
FLAGS[OPTION_SSAO_BIAS] = {defaultValue: 0.2};
FLAGS[OPTION_SSAO_RADIUS] = {defaultValue: 1};
for (var flag in FLAGS) {
    Options.register(flag, FLAGS[flag].defaultValue);
}

var SSAOPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
    var context = this.renderInterface.context;
    this._program = context.programFactory.getProgramByName("ssao");
    this.randomVectorTexture = this.createRandomVectorTexture(context);
    this.loadRandomVectorImage();
    this._screenQuad = new FullscreenQuad(context);
    this._uniformsDirty = true;
//		if (!this.inputs.positionBuffer)
//			this._positionPass = this.createVertexAttributePass("render-position");
//		if (!this.inputs.normalBuffer)
//			this._normalPass = this.createVertexAttributePass("render-normal");
};

XML3D.createClass(SSAOPass, BaseRenderPass);

XML3D.extend(SSAOPass.prototype, {
    createRandomVectorTexture: function (context) {
        var gl = context.gl;
        var tex = context.createTexture();
        tex.createTex2DFromData(gl.RGBA, 64, 64, gl.RGBA, gl.UNSIGNED_BYTE, {
            wrapS: gl.REPEAT, wrapT: gl.REPEAT, minFilter: gl.LINEAR, magFilter: gl.LINEAR
        });
        tex.isTexture = true;
        return tex;
    },

    loadRandomVectorImage: function () {
        var img = new Image();
        img.src = base64RandomNormals;
        var gl = this.renderInterface.context.gl;
        var texhandle = this.randomVectorTexture.handle;

        img.onload = function () {
            gl.bindTexture(gl.TEXTURE_2D, texhandle);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        }
    },

    createVertexAttributePass: function (programName) {
        var context = this.renderInterface.context;
        var buffer = new GLRenderTarget(context, {
            width: context.canvasTarget.width,
            height: context.canvasTarget.height,
            colorFormat: context.gl.RGBA,
            colorType: context.gl.FLOAT,
            depthFormat: context.gl.DEPTH_COMPONENT16,
            stencilFormat: null,
            depthAsRenderbuffer: true
        });
        return new VertexAttributePass(this.renderInterface, buffer, {
            programName: programName
        });
    },

    render: (function () {
//			if (this._positionPass)
//				this._positionPass.setProcessed(false);

        var viewMatrix = XML3D.math.mat4.create();
        var uniformNames = ["viewMatrix"];
        return function (scene) {
            var gl = this.renderInterface.context.gl;
            var target = this.output;

            target.bind();
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.disable(gl.DEPTH_TEST);

            this._program.bind();
            this._setNonVolatileShaderUniforms();

            var uniforms = {};
            scene.getActiveView().getWorldToViewMatrix(viewMatrix);
            uniforms["viewMatrix"] = viewMatrix;
            this._program.setSystemUniformVariables(uniformNames, uniforms);
            this._screenQuad.draw(this._program);

            this._program.unbind();
            target.unbind();
        }
    }()),

    _setNonVolatileShaderUniforms: (function () {
        var uniformNames = ["canvasSize", "sPositionTex", "sNormalTex", "sRandomNormals", "uRandomTexSize", "uScale", "uBias", "uIntensity", "uSampleRadius", "uConstVectors"];

        return function () {
            if (!this._uniformsDirty)
                return;

            var uniforms = {};
            var program = this._program;
            program.bind();
            var target = this.output;

            uniforms["canvasSize"] = [target.width, target.height];
            uniforms["sPositionTex"] = [this.inputs.positionBuffer.colorTarget.handle];
            uniforms["sNormalTex"] = [this.inputs.normalBuffer.colorTarget.handle];
            uniforms["sRandomNormals"] = [this.randomVectorTexture];
            uniforms["uRandomTexSize"] = [64, 64];
            uniforms["uScale"] = Options.getValue(OPTION_SSAO_SCALE);
            uniforms["uBias"] = Options.getValue(OPTION_SSAO_BIAS);
            uniforms["uIntensity"] = Options.getValue(OPTION_SSAO_INTENSITY);
            uniforms["uSampleRadius"] = Options.getValue(OPTION_SSAO_RADIUS);
            uniforms["uConstVectors"] = [1, 0, -1, 0, 0, 1, 0, -1];

            program.setSystemUniformVariables(uniformNames, uniforms);
            program.unbind();

//                this._uniformsDirty = false;
        }
    })()
});

module.exports = SSAOPass;


},{"../../../utils/options.js":183,"../base/fullscreenquad.js":113,"../base/rendertarget.js":116,"./base.js":139,"./vertexattribute-pass.js":149}],149:[function(require,module,exports){
var SceneRenderPass = require("./scene-pass.js");

var VertexAttributePass = function (renderInterface, output, opt) {
    SceneRenderPass.call(this, renderInterface, output, opt);
    this._program = this.renderInterface.context.programFactory.getProgramByName(opt.programName);
};

XML3D.createClass(VertexAttributePass, SceneRenderPass);

XML3D.extend(VertexAttributePass.prototype, {
    render: function (scene) {
        var gl = this.renderInterface.context.gl;
        var target = this.output;
        var width = target.getWidth();
        var height = target.getHeight();
        var aspect = width / height;

        target.bind();
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.enable(gl.DEPTH_TEST);

        scene.updateReadyObjectsFromActiveView(aspect);

        this.renderObjectsToActiveBuffer(scene.ready, scene, target, scene.systemUniforms, [], {
            transparent: false,
            program: this._program
        });

        target.unbind();
    }
});

module.exports = VertexAttributePass;


},{"./scene-pass.js":147}],150:[function(require,module,exports){
var BaseRenderTree = function (renderInterface) {
    this.mainRenderPass = null;
    this.renderInterface = renderInterface;
};

XML3D.extend(BaseRenderTree.prototype, {
    render: function (scene) {
        this.mainRenderPass.renderTree(scene);
    },

    getRenderStats: function() {
        return {};
    }
});

module.exports = BaseRenderTree;


},{}],151:[function(require,module,exports){
var BaseRenderTree = require("./base.js");
var GLRenderTarget = require("../base/rendertarget.js").GLRenderTarget;
var ForwardRenderPass = require("../render-passes/forward.js");
var BoxBlurPass= require("../render-passes/boxblur.js");
var VertexAttributePass = require("../render-passes/vertexattribute-pass.js");
var SSAOPass = require("../render-passes/ssao-pass.js");
var EVENT_TYPE = require("../../renderer/scene/constants.js").EVENT_TYPE;

/**
 *
 * @param {GLRenderInterface} renderInterface
 * @param {boolean} enableSSAO
 * @param {GLRenderTarget} target
 * @constructor
 */
var ForwardRenderTree = function (renderInterface, enableSSAO, target) {
    BaseRenderTree.call(this, renderInterface);
    var scene = renderInterface.scene;
    this._enableSSAO = enableSSAO;
    this.mainPass = null;
    this.target = target || renderInterface.context.canvasTarget;
    this.createMainPass();
};

XML3D.createClass(ForwardRenderTree, BaseRenderTree);

XML3D.extend(ForwardRenderTree.prototype, {

    createMainPass: function () {
        if (this._enableSSAO) {
            var positionPass = this.createVertexAttributePass("render-position");
            var normalPass = this.createVertexAttributePass("render-normal");
            var ssaoPass = this.createSSAOPass(positionPass.output, normalPass.output);
            ssaoPass.addPrePass(positionPass);
            ssaoPass.addPrePass(normalPass);
            var blurPass = this.createBlurPass(ssaoPass.output);
            blurPass.addPrePass(ssaoPass);
            this._blurPass = blurPass;
            this._ssaoPass = ssaoPass;
            this._positionPass = positionPass;
            this._normalPass = normalPass;
            this.mainPass = new ForwardRenderPass(this.renderInterface, this.target, {
                inputs: {
                    ssaoMap: blurPass.output
                }
            });
            this.mainPass.addPrePass(blurPass);
        } else {
            this.mainPass = new ForwardRenderPass(this.renderInterface, this.target);
        }
        this.mainRenderPass = this.mainPass;
    },

    createVertexAttributePass: function (programName) {
        var context = this.renderInterface.context;
        var buffer = new GLRenderTarget(context, {
            width: context.canvasTarget.width,
            height: context.canvasTarget.height,
            colorFormat: context.gl.RGBA,
            colorType: context.gl.FLOAT,
            depthFormat: context.gl.DEPTH_COMPONENT16,
            stencilFormat: null,
            depthAsRenderbuffer: true
        });
        return new VertexAttributePass(this.renderInterface, buffer, {
            programName: programName
        });
    },

    createSSAOPass: function (positionBuffer, normalBuffer) {
        var context = this.renderInterface.context;
        var ssaoBuffer = new GLRenderTarget(context, {
            width: context.canvasTarget.width,
            height: context.canvasTarget.height,
            colorFormat: context.gl.RGBA,
            depthFormat: context.gl.DEPTH_COMPONENT16,
            stencilFormat: null,
            depthAsRenderbuffer: true
        });

        return new SSAOPass(this.renderInterface, ssaoBuffer, {
            inputs: {
                positionBuffer: positionBuffer, normalBuffer: normalBuffer
            }
        });
    },

    createBlurPass: function (inputBuffer) {
        var context = this.renderInterface.context;
        var blurBuffer = new GLRenderTarget(context, {
            width: inputBuffer.width,
            height: inputBuffer.height,
            colorFormat: context.gl.RGBA,
            depthFormat: context.gl.DEPTH_COMPONENT16,
            stencilFormat: null,
            depthAsRenderbuffer: true
        });

        return new BoxBlurPass(this.renderInterface, blurBuffer, {
            inputs: {
                buffer: inputBuffer
            }
        });
    },

    render: function (scene) {
        if (this._enableSSAO) {
            this._positionPass.setProcessed(false);
            this._normalPass.setProcessed(false);
            this._ssaoPass.setProcessed(false);
            this._blurPass.setProcessed(false);
        }
        this.mainRenderPass.setProcessed(false);
        BaseRenderTree.prototype.render.call(this, scene);
    },

    getRenderStats: function () {
        return this.mainPass.getRenderStats();
    }
});

module.exports = ForwardRenderTree;


},{"../../renderer/scene/constants.js":98,"../base/rendertarget.js":116,"../render-passes/boxblur.js":140,"../render-passes/forward.js":141,"../render-passes/ssao-pass.js":148,"../render-passes/vertexattribute-pass.js":149,"./base.js":150}],152:[function(require,module,exports){
var GLContext = require("./base/context.js");
var GLScene = require("./scene/glscene.js");
var GLScaledRenderTarget = require("./base/rendertarget.js").GLScaledRenderTarget;
var DataChangeListener = require("../renderer/tools/datachangelistener.js");
var RenderInterface = require("./render-interface.js");
var PickObjectRenderPass= require("./render-passes/pick-object.js");
var PickPositionRenderPass = require("./render-passes/pick-position.js");
var PickNormalRenderPass = require("./render-passes/pick-normal.js");
var ForwardRenderTree = require("./render-trees/forward.js");
var GLU = require("../../contrib/glu.js");
var Options = require("../../utils/options.js");
var MAX_PICK_BUFFER_DIMENSION = 512;
var vec3 = require("gl-matrix").vec3;
var quat = require("gl-matrix").quat;
var mat4 = require("gl-matrix").mat4;

var OPTION_SSAO = "renderer-ssao";
var FLAGS = {};
FLAGS[OPTION_SSAO] = {defaultValue: false, recompileOnChange: true};
for (var flag in FLAGS) {
    Options.register(flag, FLAGS[flag].defaultValue);
}

/**
 * Convert the given y-coordinate on the canvas to a y-coordinate appropriate in
 * the GL context. The y-coordinate gets turned upside-down. The lowest possible
 * canvas coordinate is 0, so we need to subtract 1 from the height, too.
 *
 * @param {HTMLCanvasElement} canvas
 * @param {number} y
 * @return {number} the converted y-coordinate
 */
var canvasToGlY = function (canvas, y) {
    return canvas.height - y - 1;
};
/**
 * @interface
 */
var IRenderer = function () {
};

IRenderer.prototype.renderToCanvas = function () {
};
IRenderer.prototype.handleResizeEvent = function (width, height) {
};
IRenderer.prototype.requestRedraw = function (reason) {
};
IRenderer.prototype.needsRedraw = function () {
};
IRenderer.prototype.getWorldSpaceNormalByPoint = function (obj, x, y) {
};
IRenderer.prototype.getWorldSpacePositionByPoint = function (obj, x, y) {
};
IRenderer.prototype.getRenderObjectFromPickingBuffer = function (x, y) {
};
IRenderer.prototype.generateRay = function (x, y) {
};
IRenderer.prototype.dispose = function () {
};

/**
 * @param {Element} element The <xml3d> Element
 * @implements {IRenderer}
 * @constructor
 */
var GLRenderer = function (element, canvasHandler) {

    this._canvasHandler = canvasHandler;
    var canvas = this._canvasHandler.getCanvas();
    this.context = new GLContext(canvas, this._canvasHandler.id);
    this.scene = new GLScene(this.context);

    var factory = XML3D.xml3dFormatHandler.getFactory("scene", this._canvasHandler.id);
    factory.setScene(this.scene);
    factory.setRenderer(this);

    var xml3dAdapter = factory.getAdapter(element);
    xml3dAdapter.traverse(function () {
    });

    /** @type {RenderObject} */
    this.pickedObject = null;

    this.needsDraw = true;
    this.needsPickingDraw = true;
    this.context.requestRedraw = this.requestRedraw.bind(this);

    //Currently used as a helper to calculate view and projection matrices for ray casting, since the scene
    //must be rendered from the point of view of the ray
    this.rayCamera = this.scene.createRenderView();

    this.initGL();
    this.changeListener = new DataChangeListener(this);

    this.renderInterface = this.createRenderInterface();

    this.handleResizeEvent(canvas.clientWidth, canvas.clientHeight);

    Options.addObserver(this.onFlagsChange.bind(this));
};

// Just to satisfy jslint
GLRenderer.prototype.generateRay = function () {
};

XML3D.extend(GLRenderer.prototype, {
    initGL: function () {
        var gl = this.context.gl;

        gl.clearColor(0, 0, 0, 0);
        gl.clearDepth(1);
        gl.clearStencil(0);

        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);

        gl.frontFace(gl.CCW);
        gl.cullFace(gl.BACK);
        gl.disable(gl.CULL_FACE);

        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.disable(gl.BLEND);

        gl.viewport(0, 0, this.width, this.height);

        gl.pixelStorei(gl.PACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.BROWSER_DEFAULT_WEBGL);

    },

    handleResizeEvent: function (width, height) {
        if (width <= 0 || height <= 0) {
            XML3D.debug.logWarning("xml3d element has invalid width or height! Ensure you're not using 'display: none' and that width and height are greater than 0.");
            width = 800;
            height = 600;
        }
        this.width = width;
        this.height = height;
        this.context.handleResizeEvent(width, height);
        this.createDefaultTree();
        this.scene.handleResizeEvent(width, height);
        this.needsDraw = this.needsPickingDraw = true;
    },

    createDefaultTree: function () {
        var tree = new ForwardRenderTree(this.renderInterface, Options.getValue(OPTION_SSAO));
        this.renderInterface.setRenderTree(tree);

        var pickTarget = new GLScaledRenderTarget(this.context, MAX_PICK_BUFFER_DIMENSION, {
            width: this.context.canvasTarget.width,
            height: this.context.canvasTarget.height,
            colorFormat: this.context.gl.RGBA,
            depthFormat: this.context.gl.DEPTH_COMPONENT16,
            stencilFormat: null,
            depthAsRenderbuffer: true
        });
        this.pickObjectPass = new PickObjectRenderPass(this.renderInterface, pickTarget);
        this.pickPositionPass = new PickPositionRenderPass(this.renderInterface, pickTarget);
        this.pickNormalPass = new PickNormalRenderPass(this.renderInterface, pickTarget);
    },

    createRenderInterface: function () {
        return new RenderInterface(this.context, this.scene);
    },

    requestRedraw: function (reason) {
        XML3D.debug.logDebug("Request redraw because:", reason);
        this.needsDraw = true;
        this.needsPickingDraw = true;
    },

    getWorldSpaceNormalByPoint: function (x, y, object) {
        var obj = object || this.pickedObject;
        if (!obj)
            return null;
        y = canvasToGlY(this._canvasHandler.getCanvas(), y);
        this.pickNormalPass.render(obj);
        this.needsPickingDraw = true;
        return this.pickNormalPass.readNormalFromPickingBuffer(x, y);
    },

    getWorldSpacePositionByPoint: function (x, y, object) {
        var obj = object || this.pickedObject;
        if (!obj)
            return null;
        y = canvasToGlY(this._canvasHandler.getCanvas(), y);
        this.pickPositionPass.render(obj);
        this.needsPickingDraw = true;
        return this.pickPositionPass.readPositionFromPickingBuffer(x, y);
    },

    getRenderObjectByRay: function (xml3dRay, viewMat, projMat) {
        var intersectedObjects = this.scene.findRayIntersections(xml3dRay);
        this.pickObjectPass.render(intersectedObjects, viewMat, projMat);
        //Target the middle of the buffer
        var x = Math.floor(this.pickObjectPass.output.getWidth() / 2 / this.pickObjectPass.output.getScale());
        var y = Math.floor(this.pickObjectPass.output.getHeight() / 2 / this.pickObjectPass.output.getScale());
        return this.pickObjectPass.getRenderObjectFromPickingBuffer(x, y, intersectedObjects);

    },

    getWorldSpaceNormalByRay: function (ray, intersectedObject, viewMat, projMat) {
        if (!intersectedObject)
            return null;
        this.pickNormalPass.render(intersectedObject, viewMat, projMat);
        var x = Math.floor(this.pickNormalPass.output.getWidth() / 2 / this.pickNormalPass.output.getScale());
        var y = Math.floor(this.pickNormalPass.output.getHeight() / 2 / this.pickNormalPass.output.getScale());
        return this.pickNormalPass.readNormalFromPickingBuffer(x, y);

    }, getWorldSpacePositionByRay: function (ray, intersectedObject, viewMat, projMat) {
        if (!intersectedObject)
            return null;
        this.pickPositionPass.render(intersectedObject, viewMat, projMat);
        var x = Math.floor(this.pickPositionPass.output.getWidth() / 2 / this.pickPositionPass.output.getScale());
        var y = Math.floor(this.pickPositionPass.output.getHeight() / 2 / this.pickPositionPass.output.getScale());
        return this.pickPositionPass.readPositionFromPickingBuffer(x, y);

    },

    calculateMatricesForRay: function (ray, viewMat, projMat) {
        mat4.multiply(viewMat, mat4.fromTranslation(viewMat, ray.origin.data), this.calculateOrientationForRayDirection(ray));
        this.rayCamera.setLocalMatrix(viewMat);
        this.rayCamera.getWorldToViewMatrix(viewMat);
        var aspect = this.pickObjectPass.output.getWidth() / this.pickObjectPass.output.getHeight();
        this.rayCamera.getProjectionMatrix(projMat, aspect);
    },

    calculateOrientationForRayDirection: (function () {
        var tmpX = vec3.create();
        var tmpY = vec3.create();
        var tmpZ = vec3.create();
        var up = vec3.create();
        var q = quat.create();
        var m = mat4.create();

        return function (ray) {
            vec3.set(up, 0, 1, 0);
            vec3.cross(tmpX, ray.direction.data, up);
            if (!vec3.length(tmpX)) {
                vec3.set(tmpX, 1, 0, 0);
            }
            vec3.cross(tmpY, tmpX, ray.direction.data);
            vec3.negate(tmpZ, ray.direction.data);

            XML3D.math.quat.setFromBasis(q, tmpX, tmpY, tmpZ);
            mat4.fromRotationTranslation(m, q, [0,0,0]);
            return m;
        }
    })(),

    needsRedraw: function () {
        return this.needsDraw;
    },

    renderToCanvas: function () {
        this.prepareRendering();
        this.renderInterface.getRenderTree().render(this.scene);
        var stats = this.renderInterface.getRenderTree().getRenderStats();
        this.needsDraw = false; //Set this late, because redraw might be triggered during rendering (TODO: avoid that!)
        XML3D.debug.logDebug("Rendered to Canvas");
        return stats;
    },

    getRenderObjectFromPickingBuffer: function (x, y) {
        y = canvasToGlY(this._canvasHandler.getCanvas(), y);
        var worldToViewMatrix = mat4.create();
        if (this.needsPickingDraw) {
            this.needsPickingDraw = false;
            this.prepareRendering();
            this.scene.updateReadyObjectsFromActiveView(this.pickObjectPass.output.getWidth() / this.pickObjectPass.output.getHeight());
            this.scene.getActiveView().getWorldToViewMatrix(worldToViewMatrix);
            this.pickObjectPass.render(this.scene.ready, worldToViewMatrix);
            XML3D.debug.logDebug("Rendered Picking Buffer");
        }
        this.pickedObject = this.pickObjectPass.getRenderObjectFromPickingBuffer(x, y, this.scene.ready);
        return this.pickedObject;
    },

    prepareRendering: function () {
        this.scene.update();
    },

    /**
     * Uses gluUnProject() to transform the 2D screen point to a 3D ray.
     * Not tested!!
     *
     * @param {number} canvasX
     * @param {number} canvasY
     */
    generateRay: (function () {

        var c_viewMatrix = mat4.create();
        var c_projectionMatrix = mat4.create();

        return function (canvasX, canvasY) {

            var glY = canvasToGlY(this._canvasHandler.getCanvas(), canvasY);

            // setup input to unproject
            var viewport = new Float32Array(4);
            viewport[0] = 0;
            viewport[1] = 0;
            viewport[2] = this.width;
            viewport[3] = this.height;

            // get view and projection matrix arrays
            var view = this.scene.getActiveView();
            view.getWorldToViewMatrix(c_viewMatrix);
            view.getProjectionMatrix(c_projectionMatrix, viewport[2] / viewport[3]);

            var ray = new XML3D.Ray();

            var nearHit = new Float32Array(3);
            var farHit = new Float32Array(3);

            // do unprojections
            if (false === GLU.unProject(canvasX, glY, 0, c_viewMatrix, c_projectionMatrix, viewport, nearHit)) {
                return ray;
            }

            if (false === GLU.unProject(canvasX, glY, 1, c_viewMatrix, c_projectionMatrix, viewport, farHit)) {
                return ray;
            }

            // calculate ray
            mat4.invert(c_viewMatrix, c_viewMatrix);
            ray.origin = vec3.fromValues(c_viewMatrix[12], c_viewMatrix[13], c_viewMatrix[14]);
            ray.direction = vec3.fromValues(farHit[0] - nearHit[0], farHit[1] - nearHit[1], farHit[2] - nearHit[2]);

            return ray;
        }
    }()),

    dispose: function () {
        this.scene.clear();
    },

    getRenderInterface: function () {
        return this.renderInterface;
    },

    onFlagsChange: function (key) {
        if (key == OPTION_SSAO) {
            this.scene.shaderFactory.setShaderRecompile();
            this.createDefaultTree();
        }
        this.requestRedraw("global option changed");
    }
});

module.exports = GLRenderer;

},{"../../contrib/glu.js":50,"../../utils/options.js":183,"../renderer/tools/datachangelistener.js":108,"./base/context.js":112,"./base/rendertarget.js":116,"./render-interface.js":138,"./render-passes/pick-normal.js":143,"./render-passes/pick-object.js":144,"./render-passes/pick-position.js":145,"./render-trees/forward.js":151,"./scene/glscene.js":155,"gl-matrix":1}],153:[function(require,module,exports){
var XflowMesh = require("../xflow/xflow-mesh.js");

/**
 * @constructor
 */
var DrawableFactory = function () {};

XML3D.extend(DrawableFactory.prototype, {
    createDrawable: function (obj, context) {
        XML3D.debug.logDebug("DrawableFactory::createDrawable", obj);
        try {
            var result = new XflowMesh(context, obj.configuration, {boundingBoxChanged: obj.setObjectSpaceBoundingBox.bind(obj)});
            obj.mesh = result.getMesh();
            return result;
        } catch (e) {
            XML3D.debug.logError(e, obj.node);
            return null;
        }
    }
});

module.exports = DrawableFactory;



},{"../xflow/xflow-mesh.js":160}],154:[function(require,module,exports){
var lightModels = {
    point: {
        parameters: [ "pointLightPosition", "pointLightAttenuation", "pointLightIntensity", "pointLightOn", "pointLightCastShadow", "pointLightMatrix", "pointLightShadowBias", "pointLightNearFar", "pointLightShadowMap"]
    },
    directional: {
        parameters: ["directionalLightDirection", "directionalLightIntensity", "directionalLightOn", "directionalLightCastShadow", "directionalLightMatrix", "directionalLightShadowBias", "directionalLightShadowMap"]
    },
    spot: {
        parameters: ["spotLightAttenuation", "spotLightPosition", "spotLightIntensity", "spotLightDirection", "spotLightOn", "spotLightSoftness", "spotLightCosCutoffAngle", "spotLightCosSoftCutoffAngle", "spotLightCastShadow", "spotLightMatrix", "spotLightShadowBias", "spotLightShadowMap"]
    }
};

var ALL_PARAMETERS = lightModels.point.parameters.concat(lightModels.directional.parameters).concat(lightModels.spot.parameters);

module.exports = {
    ALL_PARAMETERS: ALL_PARAMETERS
};

},{}],155:[function(require,module,exports){
var Scene = require("./../../renderer/scene/scene.js");
var DrawableFactory = require("./drawable-factory.js");
var C = require("./../../renderer/scene/constants.js");
var FrustumTest = require("./../../renderer/tools/frustum.js").FrustumTest;
var ShaderComposerFactory = require("../materials/shadercomposerfactory.js");
var Options = require("../../../utils/options.js");
var ShadowMapService = require("../materials/shadowmap-service");
var mat4 = require("gl-matrix").mat4;

var OPTION_FRUSTUM_CULLING = "renderer-frustum-culling";
var OPTION_SHADEJS_EXTRACT_UNIFORMS = "shadejs-extractUniformExpressions";
var OPTION_SHADEJS_TRANSFORM_SPACES = "shadejs-transformSpaces";
var OPTION_SHADEJS_CACHE = "shadejs-cache";


// All the shader flags
var FLAGS = {};
FLAGS[OPTION_SHADEJS_EXTRACT_UNIFORMS] = {defaultValue: false, recompileOnChange: true};
FLAGS[OPTION_SHADEJS_TRANSFORM_SPACES] = {defaultValue: true, recompileOnChange: true};
FLAGS[OPTION_FRUSTUM_CULLING] = {defaultValue: true, recompileOnChange: false};
FLAGS[OPTION_SHADEJS_CACHE] = {defaultValue: true, recompileOnChange: false};

for (var flag in FLAGS) {
    Options.register(flag, FLAGS[flag].defaultValue);
}


/**
 *
 * @param {GLContext} context
 * @extends {Scene}
 * @constructor
 */
var GLScene = function (context) {
    Scene.call(this);
    this.context = context;
    this.shaderFactory = new ShaderComposerFactory(context);
    this.drawableFactory = new DrawableFactory();

    this.shadowMapService = new ShadowMapService(context, this);
    /**
     * @type {Array.<RenderObject>}
     */
    this.ready = [];
    this.queue = [];
    this.lightsNeedUpdate = true;
    this.systemUniforms = {};
    this.deferred = window['XML3D_DEFERRED'] || false;
    this.colorClosureSignatures = [];
    this.doFrustumCulling = !!Options.getValue(OPTION_FRUSTUM_CULLING);
    this.addListeners();
};

XML3D.createClass(GLScene, Scene);

function removeSafe(arr, obj) {
    var index = arr.indexOf(obj);
    if (index != -1) {
        arr.splice(index, 1);
        return true;
    }
    return false;
}

XML3D.extend(GLScene.prototype, {
    remove: function (obj) {
        removeSafe(this.queue, obj);
        removeSafe(this.ready, obj);
    },

    clear: function () {
        this.ready = [];
        this.queue = [];
        this.activeView.remove();
    },

    moveFromQueueToReady: function (obj) {
        if (removeSafe(this.queue, obj)) {
            this.ready.push(obj);
        }
    },

    moveFromReadyToQueue: function (obj) {
        if (removeSafe(this.ready, obj)) {
            this.queue.push(obj);
        }
    },

    update: function () {
        if (this.lightsNeedUpdate) {
            this.lightsNeedUpdate = false;
            this.updateLightParameters();
            this.lights.lightValueChanged();
        }
        this.updateObjectsForRendering();

        // Render shadow maps if necessary
        this.shadowMapService.updateForRendering();

        // Make sure that shaders are updates AFTER objects
        // Because unused shader closures are cleared on update
        this.updateShaders();
    }, updateLightParameters: function () {
        var parameters = this.systemUniforms;

        this.lights.fillGlobalParameters(parameters);
        this.shadowMapService.fillGlobalParameters(parameters);

        // Derived parameters that are implementation specific.
        // TODO: Put those to an appropriate place
        var spotLightCutoffAngle = parameters["spotLightCutoffAngle"];
        var spotLightSoftness = parameters["spotLightSoftness"];
        if(spotLightCutoffAngle) {
            // Map both parameters into cosinus space
            var spotLightCosSoftCutoffAngle = [];
            var spotLightCosCutoffAngle = [];
            for (var i = 0; i < spotLightCutoffAngle.length; i++) {
                spotLightCosCutoffAngle[i] = Math.cos(spotLightCutoffAngle[i]);
                spotLightCosSoftCutoffAngle[i] = Math.cos(spotLightCutoffAngle[i] * (1.0 - spotLightSoftness[i]));
            }
            parameters["spotLightCosCutoffAngle"] = spotLightCosCutoffAngle;
            parameters["spotLightCosSoftCutoffAngle"] = spotLightCosSoftCutoffAngle;
        }


    },

    updateSystemUniforms: function (names) {
        this.shaderFactory.updateSystemUniforms(names, this);
    },

    updateShaders: function () {
        this.shaderFactory.update(this);
    },

    updateObjectsForRendering: function () {
        this.forEach(function (obj) {
            obj.updateForRendering();
        });
    },

    forEach: function (func, that) {
        this.queue.slice().forEach(func, that);
        this.ready.slice().forEach(func, that);
    },

    updateReadyObjectsFromActiveView: (function () {
        var c_worldToViewMatrix = mat4.create();
        var c_viewToWorldMatrix = mat4.create();
        var c_projMat_tmp = mat4.create();
        var c_bbox = new XML3D.Box();
        var c_frustumTest = new FrustumTest();

        return function (aspectRatio) {
            var activeView = this.getActiveView(), readyObjects = this.ready, i, l, obj;

            // Update all MV matrices
            activeView.getWorldToViewMatrix(c_worldToViewMatrix);

            for (i = 0, l = readyObjects.length; i < l; i++) {
                obj = readyObjects[i];
                obj.updateModelViewMatrix(c_worldToViewMatrix);
                obj.updateModelMatrixN();
                obj.updateModelViewMatrixN();
            }
            this.updateBoundingBox();

            activeView.getProjectionMatrix(c_projMat_tmp, aspectRatio);
            activeView.getViewToWorldMatrix(c_viewToWorldMatrix);

            var frustum = activeView.getFrustum();
            var doFrustumCulling = this.doFrustumCulling && frustum;

            if(doFrustumCulling) {
                c_frustumTest.set(frustum, c_viewToWorldMatrix);
            }

            for (i = 0, l = readyObjects.length; i < l; i++) {
                obj = readyObjects[i];
                obj.updateModelViewProjectionMatrix(c_projMat_tmp);
                obj.getWorldSpaceBoundingBox(c_bbox);
                obj.inFrustum = doFrustumCulling ? c_frustumTest.isBoxVisible(c_bbox) : true;
            }
        }
    }()),
    updateReadyObjectsFromMatrices: function (worldToViewMatrix, projectionMatrix) {
        var readyObjects = this.ready;
        for (var i = 0, l = readyObjects.length; i < l; i++) {
            var obj = readyObjects[i];
            obj.updateModelViewMatrix(worldToViewMatrix);
            obj.updateModelMatrixN();
            obj.updateModelViewProjectionMatrix(projectionMatrix);
        }
    },
    addListeners: function () {
        this.on(C.EVENT_TYPE.SCENE_STRUCTURE_CHANGED, function (child, removed) {
            if (removed) {
                this.removeChildEvent(child);
            } else {
                this.addChildEvent(child);
            }
        });
        this.on(C.EVENT_TYPE.VIEW_CHANGED, function (/*newView*/) {
            this.context.requestRedraw("Active view changed.");
        });
        this.on(C.EVENT_TYPE.LIGHT_STRUCTURE_CHANGED, function (/*event*/) {
            this.lightsNeedUpdate = true;
            this.shaderFactory.setLightStructureDirty();
            this.context.requestRedraw("Light structure changed.");
        });
        this.on(C.EVENT_TYPE.LIGHT_VALUE_CHANGED, function (light) {
            this.lightsNeedUpdate = true;
            this.shaderFactory.setLightValueChanged();
            this.lights.lightValueChanged(light);
            this.context.requestRedraw("Light value changed.");
        });
         this.on(C.EVENT_TYPE.SCENE_SHAPE_CHANGED, function (/* event */) {
            // Need to update light frustum. Defer this until the next render phase
            // TODO(ksons) Only light frustum and shadow maps need update, not the whole scene
             this.lightsNeedUpdate = true;
        });

        Options.addObserver(this.onFlagsChange.bind(this));
    },

    addChildEvent: function (child) {
        if (child.type == C.NODE_TYPE.OBJECT) {
            this.queue.push(child);
            this.context.requestRedraw("Object was added to scene.");
        }
    },

    removeChildEvent: function (child) {
        if (child.type == C.NODE_TYPE.OBJECT) {
            this.remove(child);
            child.dispose();
            this.context.requestRedraw("Object was removed from scene.");
        }
    },


    createDrawable: function (obj) {
        return this.drawableFactory.createDrawable(obj, this.context);
    },

    requestRedraw: function (reason) {
        return this.context.requestRedraw(reason);
    },

    onFlagsChange: function (key, value) {
        if (FLAGS[key] && FLAGS[key].recompileOnChange)
            this.shaderFactory.setShaderRecompile();
        if (key == OPTION_FRUSTUM_CULLING) {
            this.doFrustumCulling = !!value;
        }
    }
});
module.exports = GLScene;


},{"../../../utils/options.js":183,"../materials/shadercomposerfactory.js":127,"../materials/shadowmap-service":128,"./../../renderer/scene/constants.js":98,"./../../renderer/scene/scene.js":107,"./../../renderer/tools/frustum.js":109,"./drawable-factory.js":153,"gl-matrix":1}],156:[function(require,module,exports){
var ShaderUtils = require("./shader-utils.js");
var ShaderDescriptor = require("../materials/urn/shader-descriptor.js");
var URNShaderClosure = require("../materials/urn/urnshaderclosure.js");

var ProgramFactory = function (context) {
    this.context = context;
    this.programs = {
        fallback: null, picking: {
            id: null, normal: null, position: null
        }
    }
};



XML3D.extend(ProgramFactory.prototype, {

    getProgramByName: function (name) {
        var scriptDescriptor = XML3D.materials.getScript(name);
        if (!scriptDescriptor || !scriptDescriptor.vertex) {
            XML3D.debug.logError("Unknown shader: ", name);
            return null;
        }
        var descriptor = new ShaderDescriptor();
        XML3D.extend(descriptor, scriptDescriptor);
        descriptor.fragment = ShaderUtils.addFragmentShaderHeader(descriptor.fragment);
        var shader = new URNShaderClosure(this.context, descriptor);
        shader.createSources({}, null, null);
        shader.compile();
        return shader;
    },

    getFallbackProgram: function () {
        if (!this.programs.fallback) {
            var descriptor = new ShaderDescriptor();
            XML3D.extend(descriptor, XML3D.materials.getScript("matte"));
            descriptor.fragment = ShaderUtils.addFragmentShaderHeader(descriptor.fragment);
            var shader = new URNShaderClosure(this.context, descriptor);
            shader.uniformCollection.envBase.diffuseColor = [1, 0, 0];
            shader.createSources({}, null, null);
            shader.compile();
            this.programs.fallback = shader;
            this.programs.fallback.bind();
            this.programs.fallback.setUniformVariables(["diffuseColor"], null, {envBase: {diffuseColor: [1, 0, 0]}});
            this.programs.fallback.unbind();
        }
        return this.programs.fallback;
    },

    getPickingObjectIdProgram: function () {
        var picking = this.programs.picking;
        if (!picking.id) {
            picking.id = this.getProgramByName("pickobjectid");
        }
        return picking.id;
    },

    getPickingPositionProgram: function () {
        var picking = this.programs.picking;
        if (!picking.position) {
            picking.position = this.getProgramByName("pickedposition");
        }
        return picking.position;
    },

    getPickingNormalProgram: function () {
        var picking = this.programs.picking;
        if (!picking.normal) {
            picking.normal = this.getProgramByName("pickedNormals");
        }
        return picking.normal;
    }

});

module.exports = ProgramFactory;


},{"../materials/urn/shader-descriptor.js":134,"../materials/urn/urnshaderclosure.js":135,"./shader-utils.js":157}],157:[function(require,module,exports){
var FRAGMENT_HEADER = ["#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "#else", "precision mediump float;", "#endif // GL_FRAGMENT_PRECISION_HIGH", "\n"].join("\n");

module.exports = {
    addFragmentShaderHeader: function (fragmentShaderSource) {
        return FRAGMENT_HEADER + fragmentShaderSource;
    }
};

},{}],158:[function(require,module,exports){
var SystemNotifier = {
    node: null,

    setNode: function (node) {
        this.node = node;
    },

    sendEvent: function (type, data) {
        if (this.node) {
            var event = document.createEvent('CustomEvent');
            data.systemtype = type;
            event.initCustomEvent('xml3dsystem', true, true, data);
            this.node.dispatchEvent(event);
        }
    }
};

module.exports = SystemNotifier;

},{}],159:[function(require,module,exports){
var XC = require("../../../xflow/interface/constants.js");
var GL = require("../constants.js");

function convertToJSArray(value) {
    var jsArray = [value.length];
    for (var i = 0; i < value.length; i++) {
        jsArray[i] = value[i];
    }
    return jsArray;
}

/**
 * @param {GLContext} context
 * @param {Uint32Array} data
 * @param {number} maxIndex
 */
var createElementBuffer = function (context, data, maxIndex) {
    var gl = context.gl;
    var bufferData = data;
    var glType = gl.UNSIGNED_INT;

    if (maxIndex < (1 << 8)) {
        glType = gl.UNSIGNED_BYTE;
        bufferData = new Uint8Array(data);
    } else if (maxIndex < (1 << 16)) {
        glType = gl.UNSIGNED_SHORT;
        bufferData = new Uint16Array(data);
    } else if (!context.extensions["OES_element_index_uint"]) {
        XML3D.debug.logError("Trying to use index data with indices larger than 65535, but this is not supported on your platform. Indexing errors will occur.");
        glType = gl.UNSIGNED_SHORT;
        bufferData = new Uint16Array(data);
    }

    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, bufferData, gl.STATIC_DRAW);
    buffer.bytesPerElement = bufferData.BYTES_PER_ELEMENT;
    buffer.length = data.length;
    buffer.glType = glType;
    return buffer;
};

/**
 * @param {GLContext} context
 * @param {Object} data
 */
var createArrayBuffer = function (context, data) {
    var gl = context.gl;

    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
    buffer.length = data.length;
    buffer.glType = getGLTypeFromArray(data);
    return buffer;
};

var getGLTypeFromArray = function (array) {
    if (array instanceof Int8Array)
        return GL.BYTE;
    if (array instanceof Uint8Array)
        return GL.UNSIGNED_BYTE;
    if (array instanceof Int16Array)
        return GL.SHORT;
    if (array instanceof Uint16Array)
        return GL.UNSIGNED_SHORT;
    if (array instanceof Int32Array)
        return GL.INT;
    if (array instanceof Uint32Array)
        return GL.UNSIGNED_INT;
    if (array instanceof Float32Array)
        return GL.FLOAT;
    return GL.FLOAT;
};


module.exports = {
    getGLUniformValueFromXflowDataEntry: function (xflowDataEntry, context) {
        var value;
        if (!xflowDataEntry)
            return null;
        if (xflowDataEntry.type == XC.DATA_TYPE.TEXTURE) {
            var webglData = context.getXflowEntryWebGlData(xflowDataEntry);
            var texture = webglData.texture || context.createTexture();
            if (webglData.changed)
                texture.updateFromTextureEntry(xflowDataEntry);

            webglData.texture = texture;
            webglData.changed = 0;
            value = [texture];
        } else if (xflowDataEntry.type == XC.DATA_TYPE.BOOL) {
            //TODO Can we get Xflow to return boolean arrays as normal JS arrays? WebGL doesn't accept Uint8Arrays here...
            //TODO Alternatively we could set boolean uniforms using uniform1fv together with Float32Arrays, which apparently works too
            value = convertToJSArray(xflowDataEntry.getValue());
        } else {
            value = xflowDataEntry.getValue();
        }

        return value;
    },

    getGLBufferFromXflowDataEntry: function (xflowDataEntry, context, elementBuffer) {
        var webglData = context.getXflowEntryWebGlData(xflowDataEntry);
        var buffer = webglData.buffer;
        var gl = context.gl;

        // Also write min and max values for elementBuffers
        if (webglData.changed && elementBuffer) {
            var indexValue = xflowDataEntry.getValue();
            var minIndex = 100000000, maxIndex = 0;
            var i = indexValue.length;
            while (i--) {
                minIndex = Math.min(minIndex, indexValue[i]);
                maxIndex = Math.max(maxIndex, indexValue[i]);
            }
            webglData.maxIndex = maxIndex;
            webglData.minIndex = minIndex;
        }

        //noinspection FallthroughInSwitchStatementJS
        switch (webglData.changed) {
            case XC.DATA_ENTRY_STATE.CHANGED_VALUE:
                if (elementBuffer) {
                    var bufferData = xflowDataEntry.getValue();
                    switch (buffer.glType) {
                        case gl.UNSIGNED_BYTE:
                            bufferData = new Uint8Array(bufferData);
                            break;
                        case gl.UNSIGNED_SHORT:
                            bufferData = new Uint16Array(bufferData);
                            break;
                        case gl.UNSIGNED_INT:
                            // This is what we expect anyway
                            break;
                        default:
                            XML3D.debug.logError("Unknown GL type for element buffer: ", buffer.glType);
                            return null;
                    }
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
                    gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, bufferData);
                } else {
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.bufferSubData(gl.ARRAY_BUFFER, 0, xflowDataEntry.getValue());
                }
                break;
            case XC.DATA_ENTRY_STATE.CHANGED_NEW:
            case XC.DATA_ENTRY_STATE.CHANGED_SIZE:
            case XC.DATA_ENTRY_STATE.CHANGED_SIZE_TYPE:
                if (elementBuffer) {
                    buffer = createElementBuffer(context, xflowDataEntry.getValue(), webglData.maxIndex);
                } else {
                    buffer = createArrayBuffer(context, xflowDataEntry.getValue());
                }
                buffer.tupleSize = xflowDataEntry.getTupleSize();
                webglData.buffer = buffer;
                break;
        }

        webglData.changed = 0;
        return buffer;
    },

    /**
     * Calculate bounding box from positions and optional indices
     * TODO: Remove FloatArray creation
     * @param {Float32Array} positions
     * @param {Int16Array|null} index
     * @returns {Float32Array}
     */
    calculateBoundingBox: function (positions, index) {
        var box = new XML3D.Box(), i;

        if (!positions || positions.length < 3)
            return box;

        var bbox = box.data;

        if (index) {
            var i0 = index[0] * 3;
            bbox[0] = positions[i0];
            bbox[1] = positions[i0 + 1];
            bbox[2] = positions[i0 + 2];
            bbox[3] = positions[i0];
            bbox[4] = positions[i0 + 1];
            bbox[5] = positions[i0 + 2];

            for (i = 1; i < index.length; i++) {
                var i1 = index[i] * 3;
                var p1 = positions[i1];
                var p2 = positions[i1 + 1];
                var p3 = positions[i1 + 2];

                if (p1 < bbox[0])
                    bbox[0] = p1;
                if (p2 < bbox[1])
                    bbox[1] = p2;
                if (p3 < bbox[2])
                    bbox[2] = p3;
                if (p1 > bbox[3])
                    bbox[3] = p1;
                if (p2 > bbox[4])
                    bbox[4] = p2;
                if (p3 > bbox[5])
                    bbox[5] = p3;
            }
        } else {
            bbox[0] = positions[0];
            bbox[1] = positions[1];
            bbox[2] = positions[2];
            bbox[3] = positions[0];
            bbox[4] = positions[1];
            bbox[5] = positions[2];

            for (i = 3; i < positions.length; i += 3) {
                if (positions[i] < bbox[0])
                    bbox[0] = positions[i];
                if (positions[i + 1] < bbox[1])
                    bbox[1] = positions[i + 1];
                if (positions[i + 2] < bbox[2])
                    bbox[2] = positions[i + 2];
                if (positions[i] > bbox[3])
                    bbox[3] = positions[i];
                if (positions[i + 1] > bbox[4])
                    bbox[4] = positions[i + 1];
                if (positions[i + 2] > bbox[5])
                    bbox[5] = positions[i + 2];
            }
        }
        return box;
    }
};

},{"../../../xflow/interface/constants.js":187,"../constants.js":120}],160:[function(require,module,exports){
var DrawableClosure = require("../../renderer/scene/drawableclosure.js");
var GLMesh = require("../base/mesh.js");
var XflowUtils = require("./utils.js");
var EVENT_TYPE = require("../../renderer/scene/constants.js").EVENT_TYPE;
var MaterialEvents = require("../materials/events.js");
var XC = require("../../../xflow/interface/constants.js");
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;
var assert = require("assert");
var GL = require("../constants.js");

var CHANGE_STATE = {
    NOTHING_CHANGED: 0,
    STRUCTURE_CHANGED: 1,
    TYPE_DATA_CHANGED: 2,
    VS_DATA_CHANGED: 4,
    TYPE_CHANGED: 2 + 1,
    VS_CHANGED: 4 + 1,
    SHADER_CHANGED: 32
};
var SHADER_CLOSURE_NEEDS_UPDATE = CHANGE_STATE.STRUCTURE_CHANGED | CHANGE_STATE.SHADER_CHANGED;

var READY_STATE = DrawableClosure.READY_STATE;


var MESH_PARAMETERS = {
    attributeData: {"position": XC.DATA_TYPE.FLOAT3},
    typeData: {
        "index": XC.DATA_TYPE.INT, "solid": XC.DATA_TYPE.BOOL, "vertexCount": XC.DATA_TYPE.INT, "type": XC.DATA_TYPE.STRING
    }, bboxFix: {
        "boundingBox": XC.DATA_TYPE.FLOAT3
    }, bboxCompute: {
        "position": XC.DATA_TYPE.FLOAT3
    }
};


/**
 * Class that synchronizes data changes from Xflow with a GLMesh instance
 *
 * @param {GLContext} context
 * @param {object} meshConfig
 * @param {object} opt
 * @extends {DrawableClosure}
 * @constructor
 */
var XflowMesh = function (context, meshConfig, opt) {
    DrawableClosure.call(this, context, DrawableClosure.TYPES.MESH);
    assert(meshConfig.data);
    assert(meshConfig.type);
    opt = opt || {};

    this.mesh = new GLMesh(context);

    /**
     * Data Node of the renderObject
     * @type {Xflow.DataNode}
     */
    this.dataNode = meshConfig.data;

    this.primitiveType = meshConfig.type;

    /**
     * Shader Composer that will provide ShaderClosure and Program
     * @type {AbstractShaderComposer}
     */
    this.shaderComposer = null;

    /**
     * Shader Closure used by this mesh
     * @type {AbstractShaderClosure}
     */
    this.shaderClosure = null;

    /**
     * Attributes required to create the GLMesh
     * @type {ComputeRequest}
     */
    this.typeRequest = null;

    /**
     * Are all attributes required by drawable available?
     * @type {boolean}
     */
    this.typeDataValid = true;

    /**
     * Attributes and uniforms values for the shader
     * @type {Xflow.Request}
     */
    this.objectShaderRequest = null;

    /**
     * Bitfield that records the changes reported by Xflow
     * @private
     * @type {number}
     */
    this.changeState = CHANGE_STATE.STRUCTURE_CHANGED;

    /**
     * Callback if bounding box has changed. Gets only called if
     * this.boundingBoxRequired is true.
     * @type {*|function(Float32Array)}
     */
    this.boundingBoxChanged = opt.boundingBoxChanged || function () {
    };

    this.initialize();
};

XML3D.createClass(XflowMesh, DrawableClosure, {
    initialize: function () {
        this.typeDataChanged(this.typeRequest, XC.RESULT_STATE.CHANGED_STRUCTURE);
        this.shaderChanged();
    },

    setShaderComposer: function (shaderComposer) {
        if (!this.bindedShaderChanged) this.bindedShaderChanged = this.shaderChanged.bind(this);

        if (this.shaderComposer)
            this.shaderComposer.removeListener(MaterialEvents.MATERIAL_STRUCTURE_CHANGED, this.bindedShaderChanged);

        this.shaderComposer = shaderComposer;
        if (this.shaderComposer)
            this.shaderComposer.on(MaterialEvents.MATERIAL_STRUCTURE_CHANGED, this.bindedShaderChanged);

        this.changeState |= CHANGE_STATE.SHADER_CHANGED;
    },

    update: function (scene) {
        if (this.changeState === CHANGE_STATE.NOTHING_CHANGED) {
            return;
        }
        XML3D.debug.logDebug("Update mesh closure", this.changeState);

        var oldValid = !!this.shaderClosure && this.typeDataValid, someError = null, typeDataResolved = false;

        try {
            if (this.changeState & SHADER_CLOSURE_NEEDS_UPDATE) {
                this.mesh.clear();
            }

            if (this.changeState & CHANGE_STATE.TYPE_CHANGED) {
                this.updateTypeData();
            }

            typeDataResolved = true;

            if (this.changeState & (SHADER_CLOSURE_NEEDS_UPDATE | CHANGE_STATE.TYPE_CHANGED)) {
                this.updateIndexBuffer();
            }

            if (this.changeState & SHADER_CLOSURE_NEEDS_UPDATE) {
                this.updateObjectShaderRequest();
                this.updateShaderClosure(scene);
                this.updateObjectShaderData();
            } else if (this.changeState & CHANGE_STATE.VS_CHANGED) {
                this.updateObjectShaderData();
            }

            if (this.dataNode.isSubtreeLoading()) {
                this.shaderClosure = null;
                this.typeDataValid = false;
            }
        } catch (e) {
            someError = e;
            if (!typeDataResolved)
                this.typeDataValid = false; else
                this.shaderClosure = null;
        }


        var newValid = !!this.shaderClosure && this.typeDataValid;

        if (oldValid != newValid) {
            this.emit(EVENT_TYPE.DRAWABLE_STATE_CHANGED,
                newValid ? READY_STATE.COMPLETE : READY_STATE.INCOMPLETE,
                oldValid ? READY_STATE.COMPLETE : READY_STATE.INCOMPLETE
            );
        }
        this.changeState = CHANGE_STATE.NOTHING_CHANGED;

        if (someError) throw someError;
    },

    calculateBoundingBox: (function () {
        var c_empty = new XML3D.Box();

        return function () {
            // compute bounding box from positions and indices, if present
            var dataResult = this.typeRequest.getResult();
            var boundingBoxEntry = dataResult.getOutputData("boundingBox");
            if (boundingBoxEntry) {
                this.boundingBoxChanged(XflowUtils.calculateBoundingBox(boundingBoxEntry.getValue(), null));
                return;
            }
            var positionEntry = dataResult.getOutputData("position");
            if (!positionEntry) {
                this.boundingBoxChanged(c_empty);
                return;
            }
            var indexEntry = dataResult.getOutputData("index");
            this.boundingBoxChanged(XflowUtils.calculateBoundingBox(positionEntry.getValue(), indexEntry ? indexEntry.getValue() : null));
        }
    }()), /**
     *
     * @param {ComputeRequest} request
     * @param {XC.RESULT_STATE} state
     */
    typeDataChanged: function (request, state) {
        this.changeState |= state == XC.RESULT_STATE.CHANGED_STRUCTURE ? CHANGE_STATE.STRUCTURE_CHANGED : CHANGE_STATE.TYPE_DATA_CHANGED;
        this.emit(EVENT_TYPE.SCENE_SHAPE_CHANGED);
        this.context.requestRedraw("Mesh Type Data Change");
        XML3D.debug.logDebug("XflowMesh: Type data changed", request, state, this.changeState);
    },

    getMesh: function () {
        return this.mesh;
    },

    updateObjectShaderRequest: function () {
        if (this.objectShaderRequest) this.objectShaderRequest.clear();
        this.objectShaderRequest = null;
        if (this.dataNode.isSubtreeLoading())
            return;

        this.objectShaderRequest = this.shaderComposer.createObjectDataRequest(this.dataNode, this.shaderInputDataChanged.bind(this));
    },

    updateShaderClosure: function (scene) {
        this.shaderClosure = null;
        if (!this.dataNode.isSubtreeLoading() && !this.dataNode.getOutputChannelInfo("position")) {
            throw new Error("Mesh does not have 'position' attribute.");
            //XML3D.debug.logError("Mesh does not have 'position' attribute.", this.mesh, this.getMeshType());
        } else if (!this.dataNode.isSubtreeLoading()) {
            var objectShaderResult = this.objectShaderRequest.getResult();
            if (!objectShaderResult.loading)
                this.shaderClosure = this.shaderComposer.getShaderClosure(scene, this.objectShaderRequest);
        }
    },

    updateIndexBuffer: function () {
        // Add Index buffer, if available
        var dataResult = this.typeRequest.getResult();
        var entry = dataResult.getOutputData("index");
        if (entry && entry.getValue())
            this.handleBuffer("index", entry, true);
    },

    updateObjectShaderData: function () {
        if (!this.shaderClosure) {
            return; // if only the data has changed, it can't get valid after update
        }

        if (!this.bindedHandleBuffer) this.bindedHandleBuffer = this.handleBuffer.bind(this);
        if (!this.bindedHandleUniform) this.bindedHandleUniform = this.handleUniform.bind(this);

        this.shaderComposer.distributeObjectShaderData(this.objectShaderRequest, this.bindedHandleBuffer, this.bindedHandleUniform);

        if (!this.mesh.isReadyToRender()) {
            throw new Error("Mesh has empty vertex attributes.");
        }
    },

    updateTypeData: function () {
        if (!this.typeDataValid && !(this.changeState & CHANGE_STATE.STRUCTURE_CHANGED)) {
            return; // only if structure has changed, it can't get valid after update
        }
        // Be pessimistic. We set this to true if mesh passes all checks;
        this.typeDataValid = false;

        this.updateTypeRequest();

        this.calculateBoundingBox();

        var dataResult = this.typeRequest.getResult();

        var entry = dataResult.getOutputData("vertexCount");
        this.mesh.setVertexCount(entry && entry.getValue() ? entry.getValue() : null);

        var primitiveType = this.primitiveType;
        if(primitiveType == "derived") {
            entry = dataResult.getOutputData("type");
            primitiveType =  entry ? entry.getValue()[0] : null;
        }

        var glType = getGLTypeFromString(primitiveType);
        if(glType == undefined) {
            if (this.primitiveType == "derived") {
                if (this.dataNode.isSubtreeLoading()) {
                    return; // There might be a type coming
                }
                if (primitiveType == null) {
                    throw new Error("Could not derive primitive type");
                }
            }
            throw new Error("Unknown primitive type: " + primitiveType);
        }
        this.mesh.setPrimitiveType(glType);
        this.typeDataValid = true;
    },

    /**
     * @param {string} name
     * @param {Xflow.BufferEntry} xflowDataEntry
     * @param {boolean=} isIndex
     */
    handleBuffer: function (name, xflowDataEntry, isIndex) {
        isIndex = isIndex || false;
        var mesh = this.mesh;

        if (name == "position" && !xflowDataEntry) {
            throw new Error("'position' attribute of mesh is empty.");
        }

        if (!xflowDataEntry) {
            this.mesh.removeBuffer(name);
            return;
        }

        if (xflowDataEntry.type == XC.DATA_TYPE.TEXTURE) {
            XML3D.debug.logError("Texture as mesh parameter is not yet supported");
            return;
        }

        var buffer = XflowUtils.getGLBufferFromXflowDataEntry(xflowDataEntry, this.context, name == "index");
        if (isIndex) {
            this.updateIndexRange(xflowDataEntry);
        } else {
            this.mesh.checkBufferCompatible(name, xflowDataEntry);
        }
        // In every case, set the buffer, because other meshes might have already
        // performed one or more of the tasks above
        mesh.setBuffer(name, buffer);
    },

    updateIndexRange: function (xflowDataEntry) {
        var webglData = this.context.getXflowEntryWebGlData(xflowDataEntry);
        this.mesh.setIndexRange(webglData.minIndex, webglData.maxIndex);
    },

    /*checkBufferSize: function(name, xflowDataEntry){
     if(xflowDataEntry.getIterateCount){
     var cnt = xflowDataEntry.getIterateCount();
     if(cnt >= this.mesh.maxIndex)
     throw new Error("Index range of [" + this.mesh.minIndex + ", " + this.mesh.maxIndex + "] " +
     " goes beyond element count " + cnt + " of attribute '" + name + "'");
     }
     },*/

    handleUniform: function (name, xflowDataEntry) {
        var value = XflowUtils.getGLUniformValueFromXflowDataEntry(xflowDataEntry, this.context);
        this.mesh.setUniformOverride(name, value);
    }, /**
     *
     */
    updateTypeRequest: function () {
        var requestNames = this.getTypeRequestNames(MESH_PARAMETERS);

        if (!this.typeRequest || this.typeRequest.filter != requestNames) {
            if (this.typeRequest) this.typeRequest.clear();
            this.typeRequest = new ComputeRequest(this.dataNode, requestNames, this.typeDataChanged.bind(this));
        }
    },

    getTypeRequestNames: function (meshConfig) {
        var requestNames = [];
        requestNames.push.apply(requestNames, Object.keys(meshConfig.typeData));
        // We always request fixed bounding box values: that way we can react, when those values get available
        requestNames.push.apply(requestNames, Object.keys(meshConfig.bboxFix));
        var computeBBox = !this.checkXflowTypes(this.dataNode, meshConfig.bboxFix);

        if (computeBBox) {
            if (!this.checkXflowTypes(this.dataNode, meshConfig.bboxCompute)) {
                this.typeDataValid = false;
            }
            requestNames.push.apply(requestNames, Object.keys(meshConfig.bboxCompute));
        }
        return requestNames;
    },

    checkXflowTypes: function (dataNode, requirements) {
        for (var name in requirements) {
            var info = dataNode.getOutputChannelInfo(name);
            if (!info) return false;
            if (info.type != requirements[name])
                return false;
        }
        return true;
    },

    /**
     * @param {ComputeRequest} request
     * @param {XC.RESULT_STATE} state
     */
    shaderInputDataChanged: function (request, state) {
        this.changeState |= state != XC.RESULT_STATE.CHANGED_DATA_VALUE ? CHANGE_STATE.STRUCTURE_CHANGED : CHANGE_STATE.VS_DATA_CHANGED;
        // TODO: We don't know if the change of data only influences the surface shading or the actual mesh shape
        this.emit(EVENT_TYPE.SCENE_SHAPE_CHANGED);
        this.context.requestRedraw("Mesh Attribute Data Changed");
        XML3D.debug.logDebug("XflowMesh: Attribute data changed", request, state, this.changeState);
    },

    shaderChanged: function () {
        this.changeState |= CHANGE_STATE.SHADER_CHANGED;
    },

    getProgram: function () {
        return this.shaderClosure;
    },

    destroy: function() {
        this.mesh && this.mesh.clear();
        this.objectShaderRequest && this.objectShaderRequest.clear();
        this.typeRequest && this.typeRequest.clear();
        this.setShaderComposer(null);
        delete this.dataNode;
    }

});

/**
 * @param {string} typeName
 */
var getGLTypeFromString = function (typeName) {
    if (typeName && typeName.toLowerCase)
        typeName = typeName.toLowerCase();
    switch (typeName) {
        case "triangles":
            return GL.TRIANGLES;
        case "tristrips":
            return GL.TRIANGLE_STRIP;
        case "points":
            return GL.POINTS;
        case "lines":
            return GL.LINES;
        case "linestrips":
            return GL.LINE_STRIP;
        default:
            return undefined;
    }
};

module.exports = XflowMesh;


},{"../../../xflow/interface/constants.js":187,"../../../xflow/interface/request.js":190,"../../renderer/scene/constants.js":98,"../../renderer/scene/drawableclosure.js":99,"../base/mesh.js":114,"../constants.js":120,"../materials/events.js":123,"./utils.js":159,"assert":11}],161:[function(require,module,exports){

var AdapterHandle = require("../base/adapterhandle.js");
var URI = require("../utils/uri.js").URI;
var URIResolver = require("../utils/uri.js").URIResolver;
var Options = require("../utils/options.js");
var ResourceCounter = require("./counter.js");
var getDocumentCache = require("./fetcher.js").getDocumentCache;

var OPTION_RESOURCE_CORS = "resource-crossorigin-attribute";
Options.register(OPTION_RESOURCE_CORS, "anonymous");

// Proxy adapters that provide the connections between elements (eg. "src" -> "id")
var c_cachedAdapterHandles = {};

var Resource = {};

/**
 * This function is called when an id of an element changes or if that element is now reachable
 * or not reachable anymore. It will update all AdapterHandles connected to the element.
 * @param {Element} node Element of which id has changed
 * @param {string} previousId Previous id of element
 * @param {string} newId New id of element
 */
Resource.notifyNodeIdChange = function(node, previousId, newId) {
    var uri = new URI();
    if (previousId) {
        uri.fragment = previousId;
        clearHandles(uri);
    }
    if (newId) {
        uri.fragment = newId;
        updateMissingHandles(uri, XML3D.xml3dFormatHandler, node);
    }
};

/**
 * This function is called to notify an AdapterHandler about a change (can be triggered through adapters)
 * Note that this function only works with nodes inside window.document
 * @param {Element} element Element of AdapterHandler. Must be from window.document
 * @param {Object} adapterType Type/Aspect of AdapterHandler (e.g. XML3D.data or XML3D.webgl)
 * @param {number} canvasId GLCanvasHandler id of AdapterHandler, 0 if not depending on GLCanvasHandler
 * @param {number} type Type of Notification. Usually Events.ADAPTER_HANDLE_CHANGED
 */
Resource.notifyNodeAdapterChange = function(element, adapterType, canvasId, type) {
    canvasId = canvasId || 0;
    var uri = "#" + element.id;
    if (c_cachedAdapterHandles[uri] && c_cachedAdapterHandles[uri][adapterType] &&
        c_cachedAdapterHandles[uri][adapterType][canvasId]) {
        c_cachedAdapterHandles[uri][adapterType][canvasId].notifyListeners(type);
    }
};

/**
 * Remove the adapter of all AdapterHandles corresponding to the given URL.
 * This is called e.g. when a node is remove from the document, or an id changes
 * @param {URI} uri The URL of all AdapterHandles to be cleared.
 */
function clearHandles(uri) {
    var url = uri.toString();
    for (var adapterType in c_cachedAdapterHandles[url]) {
        for (var canvasId in c_cachedAdapterHandles[url][adapterType]) {
            var handle = c_cachedAdapterHandles[url][adapterType][canvasId];
            if (handle.hasAdapter()) {
                handle.setAdapter(null, AdapterHandle.STATUS.NOT_FOUND);
            }
        }
    }
}

/**
 * Gets (or creates) the requested adapter for the given element and canvasId.
 *
 * @param {HTMLElement} node - The element the adapter is for
 * @param {String} aspect - The aspect of the adapter, usually 'scene' or 'data'
 * @param {?Number} canvasId - The canvasId of the XML3D element that this adapter will belong to
 * @returns {Adapter|?XML3D.base.Adapter}
 */
Resource.getAdapter = function(node, aspect, canvasId) {
    return XML3D.xml3dFormatHandler.getAdapter(node, aspect, canvasId);
};


/**
 * Get any adapter, internal or external.
 * This function will trigger the loading of documents, if required.
 * An AdapterHandle will be always be returned, expect when an invalid (empty) uri is passed.
 *
 * @param {String} baseURI - the base URI from which to look up the reference
 * @param {URI} uri - The URI used to find the referred AdapterHandle. Can be relative
 * @param {Object} aspect The type of adapter required (e.g. XML3D.data or XML3D.webgl)
 * @param {number=} canvasId Id of GLCanvasHandler handler this adapter depends on, 0 if not depending on any GLCanvasHandler
 * @returns {?AdapterHandle} The requested AdapterHandler. Note: might be null
 */
Resource.getAdapterHandle = function(baseURI, uri, aspect, canvasId) {
    canvasId = canvasId || 0;
    uri = XML3D.resource.getAbsoluteURI(baseURI, uri);

    if (!uri)
        return null;

    if (!c_cachedAdapterHandles[uri])
        c_cachedAdapterHandles[uri] = {};

    if (!c_cachedAdapterHandles[uri][aspect]) {
        c_cachedAdapterHandles[uri][aspect] = {};
    }

    var handle = c_cachedAdapterHandles[uri][aspect][canvasId];
    if (handle)
        return handle;

    return createAdapterHandle(uri, aspect, canvasId);
};

var createAdapterHandle = function(uri, aspect, canvasId) {
    var url = uri.toString();
    var handle = new AdapterHandle(url);
    c_cachedAdapterHandles[url][aspect][canvasId] = handle;

    if (uri.isLocal()) {
        var node = URIResolver.resolveLocal(uri);
        if (node)
            updateHandle(handle, aspect, canvasId, XML3D.xml3dFormatHandler, node);
        else
            handle.setAdapter(null, AdapterHandle.STATUS.NOT_FOUND);
    }
    else {
        ResourceCounter.addPendingResource(uri, canvasId);

        var docURI = uri.toStringWithoutFragment();
        var docData = getDocumentCache(docURI);
        if (docData && docData.document) {
            updateExternalHandles(uri, docData);
        } else {
            var priority = aspect === "scene" ? 1 : 0; //Give materials a higher priority
            XML3D.resource.getDocument(docURI, {priority : priority}).then(function(doc) {
                if (doc) {
                    docData = getDocumentCache(docURI);
                    docData.fragments.push(uri.fragment);
                    updateDocumentHandles(docURI);
                } else {
                    invalidateDocumentHandles(uri);
                }
            }).catch(function(e) {
                XML3D.debug.logError(e);
                invalidateDocumentHandles(uri);
            });
        }
    }
    return handle;
};

/**
 * Update a specific AdapterHandle with the provided data.
 * Internally an adapter will be created with 'data' and added to 'handle'
 * All other argument are required to find the correct factory
 * @param {AdapterHandle} handle The AdapterHandle to be updated
 * @param {Object} adapterType The type / aspect of the adapter (e.g. XML3D.data or XML3D.webgl)
 * @param {number} canvasId Id of corresponding canvas handler. 0 if not dependent of canvas handler
 * @param {FormatHandler} format Format handler of the corresponding document
 * @param {Object} data Data for this handle. Possibly a DOM element
 */
function updateHandle(handle, adapterType, canvasId, format, data) {
    var adapter = format.getAdapter(data, adapterType, canvasId);
    if (adapter) {
        handle.setAdapter(adapter, AdapterHandle.STATUS.READY);
    }
}

/**
 * Update all handles of a part from an external document
 * @param {URI} uri The URI of the document
 * @param {Object} docCache The entry in the c_documentCache for the external document
 */
function updateExternalHandles(uri, docCache) {
    // get part of the resource represented by the fragment
    var data = docCache.handler.getFragmentData(docCache.document, uri.fragment);
    if (data) {
        updateMissingHandles(uri, docCache.handler, data);
    } else {
        invalidateHandles(uri);
    }
}

/**
 * Update all AdapterHandles without adapters of a certain url
 * @param {URI} uri The complete url + fragment
 * @param {FormatHandler} formatHandler Format handler
 * @param {Object} data Data of the document corresponding to the url. Possibly a DOM element
 */
function updateMissingHandles(uri, formatHandler, data) {
    var url = uri.toString();
    for (var adapterType in c_cachedAdapterHandles[url]) {
        for (var canvasId in c_cachedAdapterHandles[url][adapterType]) {
            var handle = c_cachedAdapterHandles[url][adapterType][canvasId];
            if (!handle.hasAdapter()) {
                updateHandle(handle, adapterType, +canvasId, formatHandler, data);
                if(!uri.isLocal())
                    ResourceCounter.resolvePendingResource(uri, canvasId);
            }
        }
    }
}

/**
 * Invalidate all AdapterHandles without adapters of a certain url
 * @param {URI} uri The complete url + fragment
 */
function invalidateHandles(uri) {
    var url = uri.toString();
    for (var adapterType in c_cachedAdapterHandles[url]) {
        for (var canvasId in c_cachedAdapterHandles[url][adapterType]) {
            var handle = c_cachedAdapterHandles[url][adapterType][canvasId];
            handle.setAdapter(null, AdapterHandle.STATUS.NOT_FOUND);
            ResourceCounter.resolvePendingResource(uri, canvasId);
        }
    }
}

/**
 * Invalidate all handles of a document, that could not be loaded.
 * @param {URI} uri The URI of the document
 */
function invalidateDocumentHandles(uri) {
    var url = uri.toStringWithoutFragment();
    var docCache = getDocumentCache(url);
    if (!docCache) {
        // The document was never loaded
        invalidateHandles(uri);
        return;
    }
    var fragments = docCache.fragments;
    docCache.fragments = [];
    for (var i = 0; i < fragments.length; ++i) {
        invalidateHandles(uri);
    }
}

/**
 * Update all existing handles of a received document
 * @param {URI} uri The URI of the document
 */
function updateDocumentHandles(uri) {
    var url = uri.toString();
    var docCache = getDocumentCache(url);
    var fragments = docCache.fragments;
    docCache.fragments = [];
    var tempUri = new URI(uri);
    for (var i = 0; i < fragments.length; ++i) {
        tempUri.fragment = fragments[i];
        updateExternalHandles(tempUri, docCache);
    }
}


/**
 * This function is called to load an Image.
 *
 * @param {URI} uri Image URI
 * @param {function(Event, HTMLImageElement)} loadListener Function called when image was successfully loaded.
 *                                It will be called with event as the first and image as the second parameter.
 * @param {function(Event, HTMLImageElement)} errorListener Function called when image could not be loaded.
 *                                 It will be called with event as the first and image as the second parameter.
 * @return {HTMLImageElement}
 */
Resource.getImage = function(uri, loadListener, errorListener) {
    // we use canvasId 0 to represent images loaded in a document
    ResourceCounter.addPendingResource(uri, 0);

    var image = new Image();
    if(!uri.hasSameOrigin(document.location.href)) {
        image.crossOrigin = Options.getValue(OPTION_RESOURCE_CORS);
    }

    image.onload = function(e) {
        loadListener(e, image);
        ResourceCounter.resolvePendingResource(uri, 0);
    };
    image.onerror = function(e) {
        if (image.crossOrigin) {
            XML3D.debug.logIssue("May have attempted to use a cross-origin texture without proper cross-origin handling.", 164);
        }
        errorListener(e, image);
        ResourceCounter.resolvePendingResource(uri, 0);
    };

    image.src = uri.toString(); // here loading starts
    return image;
};

/**
 * This function is called to load a Video.
 *
 * @param {URI} uri Video URI
 * @param {boolean} autoplay
 * @param {boolean} loop
 * @param {Object} listeners  Dictionary of all listeners to register with video element.
 *                            Listeners will be called with event as the first and video as the second parameter.
 * @return {HTMLVideoElement}
 */
Resource.getVideo = function(uri, autoplay, loop, muted, listeners) {
    // we use canvasId 0 to represent videos loaded in a document
    ResourceCounter.addPendingResource(uri, 0);

    // FIXME: In HTML, we create a configured video, play/pause won't work
    var video = document.createElement("video");
    if (!uri.hasSameOrigin(document.location.href)) {
        video.crossOrigin = Options.getValue(OPTION_RESOURCE_CORS);
    }

    var loadCompleteCallback = function(event) {
        if (video.crossOrigin && event.type === "error") {
            XML3D.debug.logIssue("May have attempted to use a cross-origin texture without proper cross-origin handling.", 164);
        }
        ResourceCounter.resolvePendingResource(uri, 0);
        video.removeEventListener("canplay", loadCompleteCallback, true);
        video.removeEventListener("error", loadCompleteCallback, true);
    };


    video.autoplay = autoplay;
    video.loop = loop;
    video.muted = muted;

    function createCallback(listener) {
        return function(event) {
            listener(event, video);
        };
    }

    for (var eventName in listeners) {
        video.addEventListener(eventName, createCallback(listeners[eventName]), true);
    }

    video.addEventListener("canplay", loadCompleteCallback, true);
    video.addEventListener("error", loadCompleteCallback, true);

    video.src = uri.toString(); // here loading starts
    return video;
};


module.exports = Resource;

},{"../base/adapterhandle.js":49,"../utils/options.js":183,"../utils/uri.js":184,"./counter.js":162,"./fetcher.js":163}],162:[function(require,module,exports){

// External resources that haven't been fetched yet, per canvasId. When this reaches 0 the "load" event is dispatched
var c_pendingResources = {};

var ResourceCounter = {};

ResourceCounter.addPendingResource = function(uri, canvasId) {
    ResourceCounter.getOrCreatePendingResources(canvasId).entries.push(uri.toString());
};

ResourceCounter.resolvePendingResource = function(uri, canvasId) {
    // notify all load complete listeners
    var url = uri.toString();
    var pendingResources = c_pendingResources[canvasId];
    if (pendingResources) {
        Array.erase(pendingResources.entries, url);
        if (pendingResources.entries.length == 0) {
            ResourceCounter.notifyLoadCompleteListeners(pendingResources);
        }
    }
};

ResourceCounter.getOrCreatePendingResources = function(canvasId) {
    var pendingResources = c_pendingResources[canvasId];
    if (!pendingResources) {
        pendingResources = {entries: [], listeners: []};
        c_pendingResources[canvasId] = pendingResources;
    }
    return pendingResources;
};

ResourceCounter.notifyLoadCompleteListeners = function(pendingResources) {
    var listeners = pendingResources.listeners;
    var i = listeners.length;
    while (i--) {
        listeners[i](this);
    }
};

ResourceCounter.isLoadComplete = function(canvasId) {
    return !c_pendingResources[canvasId] || c_pendingResources[canvasId].entries.length == 0;
};

/*
 * Register listener that will be fired when all resources for specified canvasId are loaded.
 * Listener is fired only once.
 *
 * @param {number} canvasId
 * @param {EventListener} listener
 */
ResourceCounter.addLoadCompleteListener = function(canvasId, listener) {
    var pendingResources = ResourceCounter.getOrCreatePendingResources(canvasId);
    var idx = pendingResources.listeners.indexOf(listener);
    if (idx == -1) {
        pendingResources.listeners.push(listener);
    }
};

/**
 *
 * @param {number} canvasId
 * @param {function} listener
 */
ResourceCounter.removeLoadCompleteListener = function(canvasId, listener) {
    var pendingResources = c_pendingResources[canvasId];
    if (pendingResources) {
        var idx = pendingResources.listeners.indexOf(listener);
        if (idx != -1)
            pendingResources.listeners.splice(idx, 1);
    }
};

module.exports = ResourceCounter;


},{}],163:[function(require,module,exports){

require("whatwg-fetch");
var URI = require("../utils/uri.js").URI;
var Options = require("../utils/options.js");

var MAX_CONCURRENT_REQUESTS = 100;  // Maximum number of requests awaiting a response

var c_requestHooks = [];    // Request hooks called for each outgoing request
var c_formatHandlers = [];  // All registered FormatHandler plugins
var c_requestQueue = [];    // Requests that haven't been sent out yet
var c_openRequests = 0;     // Number of requests that are currently waiting on a response
var c_cachedDocuments = new Map(); // Already received and processed resources, indexed by URL without the fragment

var Resource = {};

Resource.registerFormatHandler = function(formatHandler) {
    if (formatHandler)
        c_formatHandlers.push(formatHandler);
};

Resource.fetch = function(uriString, opt) {
    opt = initOptions(opt);
    var uri = new URI(uriString);

    return new Promise(function(resolve, reject) {
        for (var i=0; i < c_requestHooks.length; i++) {
            c_requestHooks[i](uri, opt);
        }
        if (opt.abort) {
            throw new RequestAbortedException(uri);
        }
        scheduleRequest({
            opt : opt,
            uri : uri,
            resolve : resolve,
            reject : reject
        });
    });
};

var popRequestQueue = function() {
    var request = c_requestQueue.shift();
    c_openRequests++;

    fetch(request.uri.toString(), request.opt)
        .then(function(response) {
            c_openRequests--;
            request.resolve(response);
        }).catch(function (exception) {
            XML3D.debug.logError("Could not retrieve document at '"+request.uri.toString()+"'. Reason: "+exception);
            c_openRequests--;
            request.reject(exception);
        });
};

Resource.getDocument = function(urlString, opt) {
    return Resource.fetch(urlString, opt)
        .then(function(response) {
            if (!response.ok) {
                throw new RequestFailedException(response);
            }
            response.originalURL = urlString;
            var cache;
            if (cache = c_cachedDocuments.get(urlString)) {
                return cache.pending ? cache.pending : cache.document;
            } else {
                cache = { fragments : [] };
                c_cachedDocuments.set(urlString, cache); // Resource.parseResponse expects this entry to exist already
                cache.pending = Resource.parseResponse(response);
                return cache.pending;
            }
        }).then(function(doc) {
            doc._documentURL = urlString;
            var cache = c_cachedDocuments.get(urlString);
            cache.document = doc;
            delete cache.pending;
            return doc;
        }).catch(function(exception) {
            c_cachedDocuments.has(urlString) && delete c_cachedDocuments.get(urlString).pending;
            throw exception;
        });
};

Resource.parseResponse = function(response) {
    return new Promise(function(resolve, reject) {
        var handlerCandidates = c_formatHandlers.filter(function(handler) {
            return handler.isFormatSupported(response);
        });

        if (response.bodyUsed) {
            XML3D.debug.logError("FormatHandlers should not access the response body in the isFormatSupported function without first cloning the response object!");
            reject(new ResponseBodyUsedException(response));
        }

        if (handlerCandidates.length == 1) {
            //Special case to avoid unnecessary cloning of the response
            handlerCandidates[0].getFormatData(response).then(function(doc) {
                c_cachedDocuments.get(response.originalURL).handler = handlerCandidates[0];
                resolve(doc);
            });
        } else {
            tryFormatHandlers(handlerCandidates, response, function(fh, doc) {
                c_cachedDocuments.get(response.originalURL).handler = fh;
                resolve(doc);
            });
        }
    })
};

function tryFormatHandlers(candidates, response, callback) {
    (function tryNextHandler(index) {
        if (index >= candidates.length) {
            // Reached the end of the array
            throw new TypeError("No FormatHandler could be found for the document "+response.url);
        }
        var fh = candidates[index];
        fh.getFormatData(response.clone()).then(function(doc) {
            callback(fh, doc);
        }).catch(function(e) {
            tryNextHandler(++index);
        })
    })(0);
}

Resource.onRequest = function(callback) {
    c_requestHooks.push(callback);
};

var scheduleRequest = function(obj) {
    if (!c_requestQueue.length) {
        // The request queue was empty before so we're waking up from an idle state
        window.requestAnimationFrame(tickWorkWindow);
    }
    c_requestQueue.push(obj);
    if (obj.opt.priority > 0) {
        // 0 is lowest priority so pushing it to the back is enough, for all other priorities we should to resort the array
        c_requestQueue.sort(prioritySort);
    }
};

var prioritySort = function(a, b) {
    return b.opt.priority - a.opt.priority; //Sort descending, higher priority first
};

var tickWorkWindow = function() {
    // Both of these loops trigger asynchronous work through Promises so working through all queue items shouldn't block the thread for too long
    while (c_requestQueue.length > 0 && c_openRequests < MAX_CONCURRENT_REQUESTS) {
        popRequestQueue();
    }

    if (c_requestQueue.length) {
        // If there's more work to do schedule another call, otherwise idle until more work arrives in the scheduleWork function
        window.requestAnimationFrame(tickWorkWindow);
    }
};

var initOptions = function(opt) {
    opt = opt || {};
    opt.headers = opt.headers || {};
    opt.priority = opt.priority || 0;
    opt.abort = opt.abort || false;
    return opt;
};

// Add a hook to check for file:// requests to warn the user that a server is needed to use XML3D
Resource.onRequest(function(uri, opt) {
    if (uri.toString().match(/(file:)\/+([A-z]:\/)/)) {
        XML3D.debug.logIssue("Encountered a filesystem request: '" + uri + "'. A local server is needed to use XML3D.", 162);
        opt.abort = true;
    }
});


/**
 * This methods returns an absolute URI compatible with the resource manager.
 * This means: Any reference from an external document will be absolute and any id reference from the current
 * document will remain an id reference.
 * @param {String} baseURI - the base URI that the uri is relative to
 * @param {URI} uri - The URI used to find the referred AdapterHandle. Can be relative
 * @returns {URI} The (sometimes) absolute URI
 */
Resource.getAbsoluteURI = function(baseURI, uri){
    if (!uri)
        return null;

    if (typeof uri == "string") uri = new URI(uri);
    if (baseURI != document.URL || !uri.isLocal()) {
        uri = uri.getAbsoluteURI(baseURI);
    }
    return uri;
};

Resource.getDocumentCache = function(urlString) {
    return c_cachedDocuments.get(urlString);
};


function RequestAbortedException(url) {
    this.name = "RequestAbortedException";
    this.message = "Request was aborted by an onRequest listener: "+url;
    this.url = url;
    this.stack = (new Error()).stack;
}
RequestAbortedException.prototype = Object.create(Error.prototype);
RequestAbortedException.prototype.constructor = RequestAbortedException;

function ResponseBodyUsedException(response) {
    this.name = "ResponseBodyUsedException";
    this.message = "The body of the Response was read prematurely.";
    this.response = response;
    this.stack = (new Error()).stack;
}
ResponseBodyUsedException.prototype = Object.create(Error.prototype);
ResponseBodyUsedException.prototype.constructor = ResponseBodyUsedException;

function RequestFailedException(response) {
    this.name = "RequestFailedException";
    this.message = "The request failed with status code "+response.status;
    this.response = response;
    this.stack = (new Error()).stack;
}
RequestFailedException.prototype = Object.create(Error.prototype);
RequestFailedException.prototype.constructor = RequestFailedException;


module.exports = Resource;


},{"../utils/options.js":183,"../utils/uri.js":184,"whatwg-fetch":46}],164:[function(require,module,exports){

/**
 * A format handler is provide functionality for detecting format of resources
 * and providing format-specific services.
 * FormatHandlers are registered with XML3D.resource.registerFormatHandler() function.
 * @constructor
 */
var FormatHandler = function() {
};

//noinspection JSUnusedLocalSymbols
/**
 * Returns true if response data format is supported.
 * response is a Response object as defined by the Fetch API.
 * This function should not read the body of the response without cloning it first.
 *
 * @override
 * @param {Object} response
 * @return {Boolean}
 */
FormatHandler.prototype.isFormatSupported = function (response) {
    return false;
};

/**
 * Converts response data to format data.
 * Default implementation returns value of response.
 *
 * @override
 * @param {Object} response
 * @param {function} callback
 * @return {Object}
 */
FormatHandler.prototype.getFormatData = function (response) {
    return Promise.resolve(response);
};

/**
 * Extracts data for a fragment from document data and fragment reference.
 *
 * @override
 * @param {Object} documentData
 * @param {string} fragment Fragment without pound key which defines the part of the document
 * @return {*}
 */
FormatHandler.prototype.getFragmentData = function (documentData, fragment) {
    if (!fragment)
        return documentData;
    return null;
};

/**
 * Returns an Adapter for the given aspect. Should be overridden.
 * @param {Object} data
 * @param {String} aspect
 * @param {?Number} canvasId
 * @returns {Adapter}
 */
FormatHandler.prototype.getAdapter = function(data, aspect, canvasId) {
    return null;
};

module.exports = FormatHandler;

},{}],165:[function(require,module,exports){
var Resource = {};
XML3D.extend(Resource, require("./coordinator.js"));
XML3D.extend(Resource, require("./fetcher.js"));
Resource.FormatHandler = require("./formathandler.js");

module.exports = Resource;

},{"./coordinator.js":161,"./fetcher.js":163,"./formathandler.js":164}],166:[function(require,module,exports){
var XML3DDataAdapterFactory = require("../data/adapter/factory.js");
var RenderAdapterFactory = require("../renderer/renderer/adapter/factory.js");
var config = require("../interface/elements.js").config;

/**
 *
 * @constructor
 * @extends FormatHandler
 */
var XML3DFormatHandler = function () {
    XML3D.resource.FormatHandler.call(this);
    this.renderAdapterFactories = {};
    this.dataAdapterFactory = new XML3DDataAdapterFactory();
};
XML3D.createClass(XML3DFormatHandler, XML3D.resource.FormatHandler);

XML3DFormatHandler.prototype.isFormatSupported = function (response) {
    if (response.headers.has("Content-Type")) {
        return response.headers.get("Content-Type") === "application/xml";
    }
    if (response.url.match(/\.xml/)) {
        return true;
    }
};

XML3DFormatHandler.prototype.getFormatData = function (response) {
    return response.text().then(function(responseText) {
        var parser = new DOMParser();
        var doc = parser.parseFromString(responseText, "text/xml");

        var xml3dElements = doc.querySelectorAll("xml3d");
        for (var i = 0; i < xml3dElements.length; ++i) {
            config.element(xml3dElements[i]);
        }
        return doc;
    });
};

XML3DFormatHandler.prototype.getFragmentData = function (documentData, fragment) {
    return documentData.querySelector("*[id='" + fragment + "']");
};

XML3DFormatHandler.prototype.getAdapter = function(node, aspect, canvasId) {
    if (aspect === "scene") {
        if (canvasId === undefined) {
            throw new Error("A canvas ID corresponding to an XML3D element must be provided when creating an adapter with the 'scene' aspect");
        }
        if (!this.renderAdapterFactories[canvasId]) {
            this.renderAdapterFactories[canvasId] = new RenderAdapterFactory(canvasId);
        }
        return this.renderAdapterFactories[canvasId].getAdapter(node);
    }
    if (aspect === "data") {
        return this.dataAdapterFactory.getAdapter(node);
    }

    throw new Error("Encountered an unknown aspect '"+aspect+"'");
};

XML3DFormatHandler.prototype.getFactory = function(aspect, canvasId) {
    if (aspect === "scene") {
        if (!this.renderAdapterFactories[canvasId]) {
            this.renderAdapterFactories[canvasId] = new RenderAdapterFactory(canvasId);
        }
        return this.renderAdapterFactories[canvasId];
    }
};

var xml3dFormatHandler = new XML3DFormatHandler();
XML3D.resource.registerFormatHandler(xml3dFormatHandler);
XML3D.xml3dFormatHandler = xml3dFormatHandler;

module.exports = {
    XML3DFormatHandler : XML3DFormatHandler
};
},{"../data/adapter/factory.js":58,"../interface/elements.js":72,"../renderer/renderer/adapter/factory.js":79}],167:[function(require,module,exports){
var vec4 = require("gl-matrix").vec4;
var Vec3 = require("./vec3.js");
var Quat = require("./quat.js");

var AxisAngle = function(vec, y, z, angle) {
    if (this instanceof AxisAngle) {
        this.data = vec4.create();
        if (angle !== undefined) {
            this.data[0] = vec;
            this.data[1] = y;
            this.data[2] = z;
            this.data[3] = angle;
        } else
        if (vec) {
            this.data.set(vec.data ? vec.data : vec);
        } else {
            this.data[2] = 1;
        }
    } else return new AxisAngle(vec, y, z, angle);
};


Object.defineProperty(AxisAngle.prototype, "axis", {
    set: function(vec){
        this.data[0] = vec.data ? vec.data[0] : vec[0];
        this.data[1] = vec.data ? vec.data[1] : vec[1];
        this.data[2] = vec.data ? vec.data[2] : vec[2];
    },
    get: function(){ return Vec3.wrap(this.data) }
});
Object.defineProperty(AxisAngle.prototype, "angle", {
    set: function(a){
        this.data[3] = a;
    },
    get: function(){ return this.data[3]; }
});

AxisAngle.prototype.clone = function() {
   return new AxisAngle(this);
};

AxisAngle.fromQuat = function(q) {
    var out = new AxisAngle();
    out.data.set(XML3D.math.vec4.fromQuat(q.data ? q.data : q));
    return out;
};

AxisAngle.prototype.toDOMString = function() {
    return vec4.toDOMString(this.data);
};

AxisAngle.fromDOMString = function(str) {
    var out = new AxisAngle();
    out.data.set( vec4.fromDOMString(str) );
    return out;
};

AxisAngle.prototype.toQuat = function() {
    var out = new Quat();
    quat.setAxisAngle(out.data, this.data, this.data[3]);
    return out;
};

AxisAngle.wrap = function(vec) {
    var v = AxisAngle();
    v.data = vec.data ? vec.data : vec;
    return v;
};

module.exports = AxisAngle;

},{"./quat.js":173,"./vec3.js":176,"gl-matrix":1}],168:[function(require,module,exports){
var Vec3 = require("./vec3.js");
var vec3 = require("gl-matrix").vec3;

var Box = function(box) {
    if (this instanceof Box) {
        this.data = new Float32Array(6);
        if (box) {
            this.data.set(box.data ? box.data : box);
        } else {
            this.setEmpty();
        }
    } else return new Box(box);
};

Object.defineProperty(Box.prototype, "min", {
    set: function(v){
        var val = v.data ? v.data : v;
        this.data[0] = val[0];
        this.data[1] = val[1];
        this.data[2] = val[2];
    },
    get: function(){
        return Vec3.wrap(this.data.subarray(0,3));
    }
});

Object.defineProperty(Box.prototype, "max", {
    set: function(v){
        var val = v.data ? v.data : v;
        this.data[3] = val[0];
        this.data[4] = val[1];
        this.data[5] = val[2];
    },
    get: function(){
        return Vec3.wrap(this.data.subarray(3,6));
    }
});

Box.prototype.clone = function() {
    return new Box(this);
};

Box.prototype.copy = function(other) {
    this.copyMin(other);
    this.copyMax(other);
    return this;
};

Box.prototype.copyMin = function(other) {
    vec3.copy(this.data, other.data ? other.data : other);
    return this;
};

Box.prototype.copyMax = function(other) {
    vec3.copy(this.data.subarray(3,6), other.data ? other.data.subarray(3,6) : other.subarray(3,6));
    return this;
};

Box.prototype.extend = function(other) {
    var box = other.data ? other.data : other;
    for (var i = 0; i < 3; i++) {
        this.data[i] = Math.min(box[i], this.data[i]);
        this.data[i + 3] = Math.max(box[i + 3], this.data[i + 3]);
    }
    return this;
};

Box.prototype.setEmpty = function() {
    this.data[0] = Number.MAX_VALUE;
    this.data[1] = Number.MAX_VALUE;
    this.data[2] = Number.MAX_VALUE;
    this.data[3] = -Number.MAX_VALUE;
    this.data[4] = -Number.MAX_VALUE;
    this.data[5] = -Number.MAX_VALUE;
    return this;
};

Box.prototype.isEmpty = function() {
    return (this.data[0] > this.data[3] || this.data[1] > this.data[4] || this.data[2] > this.data[5]);
};

Box.prototype.center = function(target) {
    var cen = target || new Vec3();
    cen.x = (this.data[0] + this.data[3]) * 0.5;
    cen.y = (this.data[1] + this.data[4]) * 0.5;
    cen.z = (this.data[2] + this.data[5]) * 0.5;
    return cen;
};

Box.prototype.size = function(target) {
    var size = target || new Vec3();
    size.x = Math.max(this.data[3] - this.data[0], 0);
    size.y = Math.max(this.data[4] - this.data[1], 0);
    size.z = Math.max(this.data[5] - this.data[2], 0);
    return size;
};

Box.prototype.extent = function() {
    return this.size().scale(0.5);
};

Box.prototype.transformAxisAligned = function(mat) {
    if (this.isEmpty()) {
        return this;
    }
    var out = new Float32Array(6);
    var m = mat.data ? mat.data : mat;
    if (m[3] == 0 && m[7] == 0 && m[11] == 0 && m[15] == 1) {

        for (var i = 0; i < 3; i++) {
            out[i] = out[i + 3] = m[12 + i];

            for (var j = 0; j < 3; j++) {
                var a, b;

                a = m[j * 4 + i] * this.data[j];
                b = m[j * 4 + i] * this.data[j + 3];

                if (a < b) {
                    out[i] += a;
                    out[i + 3] += b;
                }
                else {
                    out[i] += b;
                    out[i + 3] += a;
                }
            }
        }
        this.data.set(out);
        return this;
    }
    throw new Error("Matrix is not affine");
};

Box.prototype.transform = function(mat) {
    if (this.isEmpty()) {
        return this;
    }
    vec3.transformMat4(this.min.data, this.min.data, mat.data ? mat.data : mat);
    vec3.transformMat4(this.max.data, this.max.data, mat.data ? mat.data : mat);
    return this;
};

Box.prototype.longestSide = function() {
    if (this.isEmpty()) {
        return 0;
    }
    var x = Math.abs(this.data[3] - this.data[0]);
    var y = Math.abs(this.data[4] - this.data[1]);
    var z = Math.abs(this.data[5] - this.data[2]);
    return Math.max(x, Math.max(y, z));
};

Box.prototype.intersects = function(ray, opt) {
    if (this.isEmpty()) {
        if (opt !== undefined && opt.dist !== undefined) {
            opt.dist = Infinity;
        }
        return false;
    }
    var origin = ray.origin;
    var direction = ray.direction;
    var inverseDirX = 1 / direction.x;
    var inverseDirY = 1 / direction.y;
    var inverseDirZ = 1 / direction.z;

    var t1 = (this.data[0] - origin.x) * inverseDirX;
    var t2 = (this.data[3] - origin.x) * inverseDirX;
    var t3 = (this.data[1] - origin.y) * inverseDirY;
    var t4 = (this.data[4] - origin.y) * inverseDirY;
    var t5 = (this.data[2] - origin.z) * inverseDirZ;
    var t6 = (this.data[5] - origin.z) * inverseDirZ;

    var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
    var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));

    if (opt === undefined || opt.dist === undefined) {
        return tmax > 0 && tmin <= tmax;
    }

    if (tmax < 0 || tmin > tmax) {
        opt.dist = Infinity;
        return false;
    }

    opt.dist = tmin;
    return true;
};

Box.prototype.contains = function(point) {
    var p = point.data ? point.data : point;
    return this.data[0] <= p[0] && p[0] <= this.data[3] &&
           this.data[1] <= p[1] && p[1] <= this.data[4] &&
           this.data[2] <= p[2] && p[2] <= this.data[5];
};

Box.prototype.toString = function() {
    return 'XML3D.Box(' + this.data[0] + ', ' + this.data[1] + ', ' + this.data[2] + ', ' + this.data[3] + ', ' +
        this.data[4] + ', ' + this.data[5] + ')';
};

Box.EMPTY_BOX = new Box();

module.exports = Box;

},{"./vec3.js":176,"gl-matrix":1}],169:[function(require,module,exports){
var XC = require("../xflow/interface/constants.js");
var Resource = require("../resource");

var c_XflowObserverList = [];

var XML3DDataObserver = function(callback){
    this.callback = callback;
    this.observed = [];
};

XML3DDataObserver.prototype.observe = function(node, options){
    if(!node)
        throw new Error("The node to observe is null.");


    if(!node._configured)
        throw new Error("Note to observe is not   (yet). Make sure to pass an XML3D node and to execute " +
            "this function after XML3D has been configured e.g. inside a DOMContentLoaded listener.");


    var dataAdapter = Resource.getAdapter(node, "data");
    if(!dataAdapter)
        throw new Error("Can't observe node. XML3DataObserver can only observe data containers such as <data>, <mesh> or <shader>");

    if(this.observed.length == 0)
        c_XflowObserverList.push(this);

    var entry = {
        node: node,
        changed: false,
        request: null
    };

    var names = options && options['names'];
    var typeOfNames = Object.prototype.toString.call(names).slice(8, -1);
    if (typeOfNames === "String") {
        names = [names];
    }

    entry.request = dataAdapter.getComputeRequest(names, function(request, changeType){
        entry.changed = true;
    });
    // Fetch result to synchronize Xflow structures and connect to callbacks
    // TODO: Find an option to connect request to callback structure without computing result
    entry.request.getResult();

    this.observed.push(entry);
};

XML3DDataObserver.prototype.disconnect = function(){
    for(var i = 0; i < this.observed.length; ++i){
        this.observed[i].request.clear();
    }
    this.observed = [];
    var i = c_XflowObserverList.length;
    while(i--){
        if(c_XflowObserverList[i] == this)
            c_XflowObserverList.splice(i, 1);
    }
};


XML3D.updateXflowObserver = function(){
    for(var i = 0; i < c_XflowObserverList.length; ++i){
        var observer = c_XflowObserverList[i];
        var records = [];
        for(var j = 0; j < observer.observed.length; ++j){
            var entry = observer.observed[j];
            if(entry.changed){
                entry.changed = false;
                var result = entry.request.getResult();
                var dataResult = new XML3DDataResult(result);
                records.push( new XML3DDataRecord(entry.node, dataResult));
            }
        }
        if(records.length > 0 && observer.callback){
            observer.callback(records, observer);
        }
    }
};

var XML3DDataRecord = function(target, result){
    this.target = target;
    this.result = result;
};


var XML3DDataResult = function(result){
    this._entries = {};
    constructDataResult(this, result);
};

XML3DDataResult.prototype.getValue = function(name) {
    if (this._entries[name])
        return this._entries[name].value;
    return null;
};

XML3DDataResult.prototype.getType = function(name) {
    if (this._entries[name])
        return this._entries[name].type;
    return null;
};

XML3DDataResult.prototype.getNames = function(){
    var result = [];
    for(var name in this._entries){
        result.push(name);
    }
    return result;
};

XML3DDataResult.FLOAT  = 0;
XML3DDataResult.FLOAT2 = 1;
XML3DDataResult.FLOAT3 = 2;
XML3DDataResult.FLOAT4 = 3;
XML3DDataResult.FLOAT4X4 = 4;
XML3DDataResult.INT = 10;
XML3DDataResult.INT4 = 11;
XML3DDataResult.BOOL = 20;
XML3DDataResult.TEXTURE = 30;
XML3DDataResult.BYTE = 40;
XML3DDataResult.UBYTE = 50;


function constructDataResult(dataResult, result){
    for(var i = 0; i < result.outputNames.length; ++i){
        var name = result.outputNames[i];
        var entry = result.getOutputData(name);
        var value = entry && entry.getValue();
        if (value !== null) {
            var type = getXML3DDataType(entry.type);
            dataResult._entries[name] = { type: type, value: value};
        }
    }
}

function getXML3DDataType(type){
    switch(type){
        case XC.DATA_TYPE.FLOAT : return XML3DDataResult.FLOAT;
        case XC.DATA_TYPE.FLOAT2 : return XML3DDataResult.FLOAT2;
        case XC.DATA_TYPE.FLOAT3 : return XML3DDataResult.FLOAT3;
        case XC.DATA_TYPE.FLOAT4 : return XML3DDataResult.FLOAT4;
        case XC.DATA_TYPE.FLOAT4X4 : return XML3DDataResult.FLOAT4X4;
        case XC.DATA_TYPE.INT : return XML3DDataResult.INT;
        case XC.DATA_TYPE.INT4 : return XML3DDataResult.INT4;
        case XC.DATA_TYPE.BOOL : return XML3DDataResult.BOOL;
        case XC.DATA_TYPE.TEXTURE : return XML3DDataResult.TEXTURE;
        case XC.DATA_TYPE.BYTE : return XML3DDataResult.BYTE;
        case XC.DATA_TYPE.UBYTE : return XML3DDataResult.UBYTE;
        default: throw new Error("WHAT IS THIS I DON'T EVEN...");
    }
}

var XML3DDataChannelInfo = function(type, origin, originalName, seqLength, seqMinKey, seqMaxKey){
    this.type = getXML3DDataType(type);
    this.origin = origin;
    this.originalName = originalName;
    this.seqLength = seqLength;
    this.seqMinKey = seqMinKey;
    this.seqMaxKey = seqMaxKey;
};

XML3DDataChannelInfo.ORIGIN_CHILD = 1;
XML3DDataChannelInfo.ORIGIN_COMPUTE = 2;
XML3DDataChannelInfo.ORIGIN_PROTO = 3;

module.exports = {
    XML3DDataChannelInfo: XML3DDataChannelInfo,
    XML3DDataResult: XML3DDataResult,
    XML3DDataObserver: XML3DDataObserver
};

},{"../resource":165,"../xflow/interface/constants.js":187}],170:[function(require,module,exports){
var mat2 = require("gl-matrix").mat2;

var Mat2 = function(mat) {
    if (this instanceof Mat2) {
        this.data = mat2.create();
        if (mat) {
            this.data.set(mat.data ? mat.data : mat);
        }
    } else return new Mat2(mat);
};

Object.defineProperty(Mat2.prototype, "m11", {
    set: function(x){ this.data[0] = x; },
    get: function(){ return this.data[0]; }
});
Object.defineProperty(Mat2.prototype, "m12", {
    set: function(x){ this.data[1] = x; },
    get: function(){ return this.data[1]; }
});
Object.defineProperty(Mat2.prototype, "m21", {
    set: function(x){ this.data[2] = x; },
    get: function(){ return this.data[2]; }
});
Object.defineProperty(Mat2.prototype, "m22", {
    set: function(x){ this.data[3] = x; },
    get: function(){ return this.data[3]; }
});

Mat2.prototype.adjoint = function() {
    var out = new Mat2();
    mat2.adjoint(out.data, this.data);
    return out;
};

Mat2.prototype.clone = function() {
   return new Mat2(this);
};

Mat2.prototype.determinant = function() {
    return mat2.determinant(this.data);
};

Mat2.prototype.invert = function() {
    var out = new Mat2();
    mat2.invert(out.data, this.data);
    return out;
};

Mat2.prototype.mul = Mat2.prototype.multiply = function(b) {
    var out = new Mat2();
    mat2.multiply(out.data, this.data, b.data ? b.data : b);
    return out;
};

Mat2.prototype.rotate = function(rad) {
    var out = new Mat2();
    mat2.rotate(out.data, this.data, rad);
    return out;
};

Mat2.prototype.scale = function(vec) {
    var out = new Mat2();
    mat2.scale(out.data, this.data, vec.data ? vec.data : vec);
    return out;
};

Mat2.prototype.transpose = function() {
    var out = new Mat2();
    mat2.transpose(out.data, this.data);
    return out;
};

Mat2.wrap = function(mat) {
    var m = Mat2();
    m.data = mat.data ? mat.data : mat;
    return m;
};

module.exports = Mat2;

},{"gl-matrix":1}],171:[function(require,module,exports){
var mat3 = require("gl-matrix").mat3;

var Mat3 = function(mat) {
    if (this instanceof Mat3) {
        this.data = mat3.create();
        if (mat) {
            this.data.set(mat.data ? mat.data : mat);
        }
    } else return new Mat3(mat);
};

Object.defineProperty(Mat3.prototype, "m11", {
    set: function(x){ this.data[0] = x; },
    get: function(){ return this.data[0]; }
});
Object.defineProperty(Mat3.prototype, "m12", {
    set: function(x){ this.data[1] = x; },
    get: function(){ return this.data[1]; }
});
Object.defineProperty(Mat3.prototype, "m13", {
    set: function(x){ this.data[2] = x; },
    get: function(){ return this.data[2]; }
});
Object.defineProperty(Mat3.prototype, "m21", {
    set: function(x){ this.data[3] = x; },
    get: function(){ return this.data[3]; }
});
Object.defineProperty(Mat3.prototype, "m22", {
    set: function(x){ this.data[4] = x; },
    get: function(){ return this.data[4]; }
});
Object.defineProperty(Mat3.prototype, "m23", {
    set: function(x){ this.data[5] = x; },
    get: function(){ return this.data[5]; }
});
Object.defineProperty(Mat3.prototype, "m31", {
    set: function(x){ this.data[6] = x; },
    get: function(){ return this.data[6]; }
});
Object.defineProperty(Mat3.prototype, "m32", {
    set: function(x){ this.data[7] = x; },
    get: function(){ return this.data[7]; }
});
Object.defineProperty(Mat3.prototype, "m33", {
    set: function(x){ this.data[8] = x; },
    get: function(){ return this.data[8]; }
});


Mat3.prototype.adjoint = function() {
    var out = new Mat3();
    mat3.adjoint(out.data, this.data);
    return out;
};

Mat3.prototype.clone = function() {
   return new Mat3(this);
};

Mat3.prototype.determinant = function() {
    return mat3.determinant(this.data);
};

Mat3.fromMat4 = function(m) {
    var out = new Mat3();
    mat3.fromMat4(out.data, m.data ? m.data : m);
    return out;
};

Mat3.fromQuat = function(q) {
    var out = new Mat3();
    mat3.fromQuat(out.data, q.data ? q.data : q);
    return out;
};

Mat3.prototype.invert = function() {
    var out = new Mat3();
    mat3.invert(out.data, this.data);
    return out;
};

Mat3.prototype.mul = Mat3.prototype.multiply = function(b) {
    var out = new Mat3();
    mat3.multiply(out.data, this.data, b.data ? b.data : b);
    return out;
};

Mat3.normalFromMat4 = function(m) {
    var out = new Mat3();
    mat3.normalFromMat4(out.data, m.data ? m.data : m);
    return out;
};

Mat3.prototype.rotate = function(rad) {
    var out = new Mat3();
    mat3.rotate(out.data, this.data, rad);
    return out;
};

Mat3.prototype.scale = function(vec) {
    var out = new Mat3();
    mat3.scale(out.data, this.data, vec.data ? vec.data : vec);
    return out;
};

Mat3.prototype.transpose = function() {
    var out = new Mat3();
    mat3.transpose(out.data, this.data);
    return out;
};

Mat3.prototype.translate = function(vec) {
    var out = new Mat3();
    mat3.translate(out.data, this.data, vec.data ? vec.data : vec);
    return out;
};

Mat3.wrap = function(mat) {
    var m = Mat3();
    m.data = mat.data ? mat.data : mat;
    return m;
};

module.exports = Mat3;

},{"gl-matrix":1}],172:[function(require,module,exports){
var mat4 = require("gl-matrix").mat4;

var Mat4 = function(mat) {
    if (this instanceof Mat4) {
        this.data = mat4.create();
        if (mat) {
            this.data.set(mat.data ? mat.data : mat);
        }
    } else return new Mat4(mat);
};

Object.defineProperty(Mat4.prototype, "m11", {
    set: function(x){ this.data[0] = x; },
    get: function(){ return this.data[0]; }
});
Object.defineProperty(Mat4.prototype, "m12", {
    set: function(x){ this.data[1] = x; },
    get: function(){ return this.data[1]; }
});
Object.defineProperty(Mat4.prototype, "m13", {
    set: function(x){ this.data[2] = x; },
    get: function(){ return this.data[2]; }
});
Object.defineProperty(Mat4.prototype, "m14", {
    set: function(x){ this.data[3] = x; },
    get: function(){ return this.data[3]; }
});
Object.defineProperty(Mat4.prototype, "m21", {
    set: function(x){ this.data[4] = x; },
    get: function(){ return this.data[4]; }
});
Object.defineProperty(Mat4.prototype, "m22", {
    set: function(x){ this.data[5] = x; },
    get: function(){ return this.data[5]; }
});
Object.defineProperty(Mat4.prototype, "m23", {
    set: function(x){ this.data[6] = x; },
    get: function(){ return this.data[6]; }
});
Object.defineProperty(Mat4.prototype, "m24", {
    set: function(x){ this.data[7] = x; },
    get: function(){ return this.data[7]; }
});
Object.defineProperty(Mat4.prototype, "m31", {
    set: function(x){ this.data[8] = x; },
    get: function(){ return this.data[8]; }
});
Object.defineProperty(Mat4.prototype, "m32", {
    set: function(x){ this.data[9] = x; },
    get: function(){ return this.data[9]; }
});
Object.defineProperty(Mat4.prototype, "m33", {
    set: function(x){ this.data[10] = x; },
    get: function(){ return this.data[10]; }
});
Object.defineProperty(Mat4.prototype, "m34", {
    set: function(x){ this.data[11] = x; },
    get: function(){ return this.data[11]; }
});
Object.defineProperty(Mat4.prototype, "m41", {
    set: function(x){ this.data[12] = x; },
    get: function(){ return this.data[12]; }
});
Object.defineProperty(Mat4.prototype, "m42", {
    set: function(x){ this.data[13] = x; },
    get: function(){ return this.data[13]; }
});
Object.defineProperty(Mat4.prototype, "m43", {
    set: function(x){ this.data[14] = x; },
    get: function(){ return this.data[14]; }
});
Object.defineProperty(Mat4.prototype, "m44", {
    set: function(x){ this.data[15] = x; },
    get: function(){ return this.data[15]; }
});

Mat4.prototype.adjoint = function() {
    var out = new Mat4();
    mat4.adjoint(out.data, this.data);
    return out;
};

Mat4.prototype.clone = function() {
   return new Mat4(this);
};

Mat4.prototype.determinant = function() {
    return mat4.determinant(this.data);
};

Mat4.frustum = function(left, right, bottom, top, near, far) {
    var out = new Mat4();
    mat4.frustum(out.data, left, right, bottom, top, near, far);
    return out;
};

Mat4.prototype.invert = function() {
    var out = new Mat4();
    mat4.invert(out.data, this.data);
    return out;
};

Mat4.lookAt = function(eye, center, up) {
    var out = new Mat4();
    mat4.lookAt(out.data, eye.data ? eye.data : eye, center.data ? center.data : center, up.data ? up.data : up);
    return out;
};

Mat4.prototype.mul = Mat4.prototype.multiply = function(b) {
    var out = new Mat4();
    mat4.multiply(out.data, this.data, b.data ? b.data : b);
    return out;
};

Mat4.ortho = function(left, right, bottom, top, near, far) {
    var out = new Mat4();
    mat4.ortho(out.data, left, right, bottom, top, near, far);
    return out;
};

Mat4.perspective = function(fov, aspect, near, far) {
    var out = new Mat4();
    mat4.perspective(out.data, fov, aspect, near, far);
    return out;
};

Mat4.prototype.rotate = function(rad, axis) {
    var out = new Mat4();
    mat4.rotate(out.data, this.data, rad, axis.data ? axis.data : axis);
    return out;
};

Mat4.prototype.rotateX = function(rad) {
    var out = new Mat4();
    mat4.rotateX(out.data, this.data, rad);
    return out;
};

Mat4.prototype.rotateY = function(rad) {
    var out = new Mat4();
    mat4.rotateY(out.data, this.data, rad);
    return out;
};

Mat4.prototype.rotateZ = function(rad) {
    var out = new Mat4();
    mat4.rotateZ(out.data, this.data, rad);
    return out;
};

Mat4.prototype.scale = function(vec) {
    var out = new Mat4();
    mat4.scale(out.data, this.data, vec.data ? vec.data : vec);
    return out;
};

Mat4.fromQuat = function(q) {
    var out = new Mat4();
    mat4.fromQuat(out.data, q.data ? q.data : q);
    return out;
};

Mat4.fromRotationTranslation = function(q, v) {
    var out = new Mat4();
    mat4.fromRotationTranslation(out.data, q.data ? q.data : q, v.data ? v.data : v);
    return out;
};

Mat4.prototype.transpose = function() {
    var out = new Mat4();
    mat4.transpose(out.data, this.data);
    return out;
};

Mat4.prototype.translate = function(vec) {
    var out = new Mat4();
    mat4.translate(out.data, this.data, vec.data ? vec.data : vec);
    return out;
};

Mat4.wrap = function(mat) {
    var m = Mat4();
    m.data = mat.data ? mat.data : mat;
    return m;
};


module.exports = Mat4;

},{"gl-matrix":1}],173:[function(require,module,exports){
var quat = require("gl-matrix").quat;

var Quat = function(vec, y, z, w) {
    if (this instanceof Quat) {
        this.data = quat.create();
        if (w !== undefined) {
            this.x = vec;
            this.y = y;
            this.z = z;
            this.w = w;
        } else
        if (vec) {
            this.data.set(vec.data ? vec.data : vec);
        } else {
            this.w = 1;
        }
    } else return new Quat(vec, y, z, w);
};

Object.defineProperty(Quat.prototype, "x", {
    set: function(x){
        this.data[0] = x;
    },
    get: function(){ return this.data[0]; }
});
Object.defineProperty(Quat.prototype, "y", {
    set: function(y){
        this.data[1] = y;
    },
    get: function(){ return this.data[1]; }
});
Object.defineProperty(Quat.prototype, "z", {
    set: function(z){
        this.data[2] = z;
    },
    get: function(){ return this.data[2]; }
});
Object.defineProperty(Quat.prototype, "w", {
    set: function(w){
        this.data[3] = w;
    },
    get: function(){ return this.data[3]; }
});

Quat.prototype.add = function(b) {
    var out = new Quat();
    quat.add(out.data, this.data, b.data ? b.data : b);
    return out;
};

Quat.prototype.calculateW = function() {
    var out = new Quat();
    quat.calculateW(out.data, this.data);
    return out;
};

Quat.prototype.clone = function() {
   return new Quat(this);
};

Quat.prototype.conjugate = function() {
    var out = new Quat();
    quat.conjugate(out.data, this.data);
    return out;
};

Quat.prototype.dot = function(b) {
    return quat.dot(this.data, b.data ? b.data : b);
};

Quat.prototype.invert = function() {
    var out = new Quat();
    quat.invert(out.data, this.data);
    return out;
};

Quat.prototype.len = Quat.prototype.length = function() {
    return quat.length(this.data);
};

Quat.prototype.lerp = function(b, t) {
    var out = new Quat();
    quat.lerp(out.data, this.data, b.data ? b.data : b, t);
    return out;
};

Quat.prototype.mul = Quat.prototype.multiply = function(b) {
    var out = new Quat();
    quat.mul(out.data, this.data, b.data ? b.data : b);
    return out;
};

Quat.prototype.normalize = function() {
    var out = new Quat();
    quat.normalize(out.data, this.data);
    return out;
};

Quat.prototype.rotateX = function(rad) {
    var out = new Quat();
    quat.rotateX(out.data, this.data, rad);
    return out;
};

Quat.prototype.rotateY = function(rad) {
    var out = new Quat();
    quat.rotateY(out.data, this.data, rad);
    return out;
};

Quat.prototype.rotateZ = function(rad) {
    var out = new Quat();
    quat.rotateZ(out.data, this.data, rad);
    return out;
};

Quat.prototype.scale = function(s) {
    var out = new Quat();
    quat.scale(out.data, this.data, s);
    return out;
};

Quat.fromAxisAngle = function(axis, rad) {
    var out = new Quat();
    if (rad === undefined) {
        quat.setAxisAngle(out.data, axis.data ? axis.data : axis, axis.data ? axis.data[3] : axis[3]);
    } else {
        quat.setAxisAngle(out.data, axis.data ? axis.data : axis, rad);
    }
    quat.normalize(out.data, out.data);
    return out;
};

Quat.fromBasis = function(x, y, z) {
    var out = new Quat();
    XML3D.math.quat.setFromBasis(out.data, x.data ? x.data : x, y.data ? y.data : y, z.data ? z.data : z);
    quat.normalize(out.data, out.data);
    return out;
};

Quat.fromMat3 = function(m) {
    var out = new Quat();
    quat.fromMat3(out.data, m.data ? m.data : m);
    quat.normalize(out.data, out.data);
    return out;
};

Quat.fromRotationTo = function(from, to) {
    var out = new Quat();
    quat.rotationTo(out.data, from.data ? from.data : from, to.data ? to.data : to);
    quat.normalize(out.data, out.data);
    return out;
};

Quat.prototype.slerp = function(b, t) {
    var out = new Quat();
    quat.slerp(out.data, this.data, b.data ? b.data : b, t);
    return out;
};

Quat.prototype.toDOMString = function() {
    return quat.toDOMString(this.data);
};

Quat.fromDOMString = function(str) {
    var out = new Quat();
    out.data.set( quat.fromDOMString(str) );
    return out;
};

Quat.wrap = function(vec) {
    var v = Quat();
    v.data = vec.data ? vec.data : vec;
    return v;
};

module.exports = Quat;

},{"gl-matrix":1}],174:[function(require,module,exports){
var Vec3 = require("./vec3.js");
var vec3 = require("gl-matrix").vec3;

var Ray = function(ray) {
    if (this instanceof Ray) {
        this.data = new Float32Array(6);
        this.data[5] = -1;
        if (ray) {
            this.data.set( ray.data ? ray.data : ray );
        }
    } else {
        return new Ray(ray);
    }
};

Object.defineProperty(Ray.prototype, "origin", {
    set: function(v){
        var val = v.data ? v.data : v;
        this.data[0] = val[0];
        this.data[1] = val[1];
        this.data[2] = val[2];
    },
    get: function(){
        return Vec3.wrap(this.data.subarray(0,3));
    }
});

Object.defineProperty(Ray.prototype, "direction", {
    set: function(v){
        var val = v.data ? v.data : v;
        vec3.normalize(val, val);
        this.data[3] = val[0];
        this.data[4] = val[1];
        this.data[5] = val[2];
    },
    get: function(){
        return Vec3.wrap(this.data.subarray(3,6));
    }
});

Ray.prototype.setFromOriginDirection = function(origin, direction) {
    this.origin = origin;
    this.direction = direction;
    return this;
};

Ray.prototype.clone = function() {
    return new Ray().copy(this);
};

Ray.prototype.copy = function(other) {
    this.copyOrigin(other);
    this.copyDirection(other);
    return this;
};

Ray.prototype.copyOrigin = function(other) {
    vec3.copy(this.data, other.data ? other.data : other);
    return this;
};

Ray.prototype.copyDirection = function(other) {
    vec3.copy(this.data.subarray(3,6), other.data ? other.data.subarray(3,6) : other.subarray(3,6));
    return this;
};

Ray.prototype.intersects = function(box, opt) {
    return box.intersects(this, opt);
};

Ray.prototype.toString = function() {
    return 'XML3D.Ray(origin: ' + this.data[0] + ', ' + this.data[1] + ', ' + this.data[2] + ', direction: ' + this.data[3] + ', ' +
        this.data[4] + ', ' + this.data[5] + ')';
};

module.exports = Ray;

},{"./vec3.js":176,"gl-matrix":1}],175:[function(require,module,exports){
var vec2 = require("gl-matrix").vec2;

var Vec2 = function(vec, y) {
    if (this instanceof Vec2) {
        this.data = vec2.create();
        if (y !== undefined) {
            this.x = vec;
            this.y = y;
        } else
        if (vec) {
            this.data.set(vec.data ? vec.data : vec);
        }
    } else return new Vec2(vec, y);
};

Object.defineProperty(Vec2.prototype, "x", {
    set: function(x){
        this.data[0] = x;
    },
    get: function(){ return this.data[0]; }
});
Object.defineProperty(Vec2.prototype, "y", {
    set: function(y){
        this.data[1] = y;
    },
    get: function(){ return this.data[1]; }
});

Vec2.prototype.add = function(b) {
    var out = new Vec2();
    vec2.add(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec2.prototype.clone = function() {
    return new Vec2(this);
};

Vec2.prototype.dist = Vec2.prototype.distance = function(b) {
    return vec2.dist(this.data, b.data ? b.data : b);
};

Vec2.prototype.divide = function(b) {
    var out = new Vec2();
    vec2.divide(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec2.prototype.dot = function(b) {
    return vec2.dot(this.data, b.data ? b.data : b);
};

Vec2.prototype.len = Vec2.prototype.length = function() {
    return vec2.length(this.data);
};

Vec2.prototype.lerp = function(b, t) {
    var out = new Vec2();
    vec2.lerp(out.data, this.data, b.data ? b.data : b, t);
    return out;
};

Vec2.prototype.max = function(b) {
    var m = new Vec2();
    vec2.max(m.data, this.data, b.data ? b.data : b);
    return m;
};

Vec2.prototype.min = function(b) {
    var m = new Vec2();
    vec2.max(m.data, this.data, b.data ? b.data : b);
    return m;
};

Vec2.prototype.mul = Vec2.prototype.multiply = function(b) {
    var out = new Vec2();
    var c = b.data ? b.data : b;

    switch (c.length) {
        case 2:
            vec2.mul(out.data, this.data, c);
            break;
        case 4:
            vec2.transformMat2(out.data, this.data, c);
            break;
        case 9:
            vec2.transformMat3(out.data, this.data, c);
            break;
        case 16:
            vec2.transformMat4(out.data, this.data, c);
            break;
        default:
            console.error("Invalid input to Vec2.multiply "+b);
    }

    return out;
};

Vec2.prototype.negate = function() {
    var out = new Vec2();
    vec2.negate(out.data, this.data);
    return out;
};

Vec2.prototype.normalize = function() {
    var out = new Vec2();
    vec2.normalize(out.data, this.data);
    return out;
};

Vec2.random = function(scale) {
    var m = new Vec2();
    vec2.random(m.data, scale);
    return m;
};

Vec2.prototype.scale = function(s) {
    var out = new Vec2();
    vec2.scale(out.data, this.data, s);
    return out;
};

Vec2.prototype.sub = Vec2.prototype.subtract = function(b) {
    var out = new Vec2();
    vec2.sub(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec2.prototype.toDOMString = function() {
    return vec2.toDOMString(this.data);
};

Vec2.fromDOMString = function(str) {
    var out = new Vec2();
    out.data.set( vec2.fromDOMString(str) );
    return out;
};

Vec2.wrap = function(vec) {
    var v = Vec2();
    v.data = vec.data ? vec.data : vec;
    return v;
};

module.exports = Vec2;

},{"gl-matrix":1}],176:[function(require,module,exports){
var vec3 = require("gl-matrix").vec3;

var Vec3 = function(vec, y, z) {
    if (this instanceof Vec3) {
        this.data = vec3.create();
        if (z !== undefined) {
            this.x = vec;
            this.y = y;
            this.z = z;
        } else
        if (vec) {
            this.data.set(vec.data ? vec.data : vec);
        }
    } else return new Vec3(vec, y, z);
};

Object.defineProperty(Vec3.prototype, "x", {
    set: function(x){
        this.data[0] = x;
    },
    get: function(){ return this.data[0]; }
});
Object.defineProperty(Vec3.prototype, "y", {
    set: function(y){
        this.data[1] = y;
    },
    get: function(){ return this.data[1]; }
});
Object.defineProperty(Vec3.prototype, "z", {
    set: function(z){
        this.data[2] = z;
    },
    get: function(){ return this.data[2]; }
});

Vec3.prototype.add = function(b) {
    var out = new Vec3();
    vec3.add(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec3.prototype.clone = function() {
   return new Vec3(this);
};

Vec3.prototype.cross = function(b) {
    var out = new Vec3();
    vec3.cross(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec3.prototype.dist = Vec3.prototype.distance = function(b) {
    return vec3.dist(this.data, b.data ? b.data : b);
};

Vec3.prototype.divide = function(b) {
    var out = new Vec3();
    vec3.divide(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec3.prototype.dot = function(b) {
    return vec3.dot(this.data, b.data ? b.data : b);
};

Vec3.prototype.len = Vec3.prototype.length = function() {
    return vec3.length(this.data);
};

Vec3.prototype.lerp = function(b, t) {
    var out = new Vec3();
    vec3.lerp(out.data, this.data, b.data ? b.data : b, t);
    return out;
};

Vec3.prototype.max = function(b) {
    var m = new Vec3();
    vec3.max(m.data, this.data, b.data ? b.data : b);
    return m;
};

Vec3.prototype.min = function(b) {
    var m = new Vec3();
    vec3.max(m.data, this.data, b.data ? b.data : b);
    return m;
};

Vec3.prototype.mul = Vec3.prototype.multiply = function(b) {
    var out = new Vec3();
    var c = b.data ? b.data : b;

    switch (c.length) {
        case 3:
            vec3.mul(out.data, this.data, c);
            break;
        case 4:
            vec3.transformQuat(out.data, this.data, c);
            break;
        case 9:
            vec3.transformMat3(out.data, this.data, c);
            break;
        case 16:
            vec3.transformMat4(out.data, this.data, c);
            break;
        default:
            console.error("Invalid input to Vec3.multiply "+b);
    }

    return out;
};

Vec3.prototype.negate = function() {
    var out = new Vec3();
    vec3.negate(out.data, this.data);
    return out;
};

Vec3.prototype.normalize = function() {
    var out = new Vec3();
    vec3.normalize(out.data, this.data);
    return out;
};

Vec3.prototype.random = function(scale) {
    var m = new Vec3();
    vec3.random(m.data, scale);
    return m;
};

Vec3.prototype.reciprocal = function() {
    var out = new Vec3();
    XML3D.math.vec3.reciprocal(out.data, this.data);
    return out;
};

Vec3.prototype.scale = function(s) {
    var out = new Vec3();
    vec3.scale(out.data, this.data, s);
    return out;
};

Vec3.prototype.sub = Vec3.prototype.subtract = function(b) {
    var out = new Vec3();
    vec3.sub(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec3.prototype.transformDirection = function(m) {
    var out = new Vec3();
    XML3D.math.vec3.transformDirection(out.data, this.data, m.data ? m.data : m);
    return out;
};

Vec3.prototype.toDOMString = function() {
    return vec3.toDOMString(this.data);
};

Vec3.fromDOMString = function(str) {
    var out = new Vec3();
    out.data.set( vec3.fromDOMString(str) );
    return out;
};

Vec3.wrap = function(vec) {
    var v = Vec3();
    v.data = vec.data ? vec.data : vec;
    return v;
};

module.exports = Vec3;

},{"gl-matrix":1}],177:[function(require,module,exports){
var vec4 = require("gl-matrix").vec4;
var Vec3 = require("./vec3.js");

var Vec4 = function(vec, y, z, w) {
    if (this instanceof Vec4) {
        this.data = vec4.create();
        if (w !== undefined) {
            this.x = vec;
            this.y = y;
            this.z = z;
            this.w = w;
        } else
        if (vec) {
            this.data.set(vec.data ? vec.data : vec);
        }
    } else return new Vec4(vec, y, z, w);
};

Object.defineProperty(Vec4.prototype, "x", {
    set: function(x){
        this.data[0] = x;
    },
    get: function(){ return this.data[0]; }
});
Object.defineProperty(Vec4.prototype, "y", {
    set: function(y){
        this.data[1] = y;
    },
    get: function(){ return this.data[1]; }
});
Object.defineProperty(Vec4.prototype, "z", {
    set: function(z){
        this.data[2] = z;
    },
    get: function(){ return this.data[2]; }
});
Object.defineProperty(Vec4.prototype, "w", {
    set: function(w){
        this.data[3] = w;
    },
    get: function(){ return this.data[3]; }
});

Vec4.prototype.add = function(b) {
    var out = new Vec4();
    vec4.add(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec4.prototype.clone = function() {
   return new Vec4(this);
};

Vec4.prototype.dist = Vec4.prototype.distance = function(b) {
    return vec4.dist(this.data, b.data ? b.data : b);
};

Vec4.prototype.divide = function(b) {
    var out = new Vec4();
    vec4.divide(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec4.prototype.dot = function(b) {
    return vec4.dot(this.data, b.data ? b.data : b);
};

Vec4.prototype.len = Vec4.prototype.length = function() {
    return vec4.length(this.data);
};

Vec4.prototype.lerp = function(b, t) {
    var out = new Vec4();
    vec4.lerp(out.data, this.data, b.data ? b.data : b, t);
    return out;
};

Vec4.prototype.max = function(b) {
    var m = new Vec4();
    vec4.max(m.data, this.data, b.data ? b.data : b);
    return m;
};

Vec4.prototype.min = function(b) {
    var m = new Vec4();
    vec4.max(m.data, this.data, b.data ? b.data : b);
    return m;
};

Vec4.prototype.mul = Vec4.prototype.multiply = function(b) {
    var out = new Vec4();
    var c = b.data ? b.data : b;

    switch (c.length) {
        case 4:
            vec4.mul(out.data, this.data, c);
            break;
        case 16:
            vec4.transformMat4(out.data, this.data, c);
            break;
        default:
            console.error("Invalid input to Vec4.multiply "+b);
    }

    return out;
};

Vec4.prototype.negate = function() {
    var out = new Vec4();
    vec4.negate(out.data, this.data);
    return out;
};

Vec4.prototype.normalize = function() {
    var out = new Vec4();
    vec4.normalize(out.data, this.data);
    return out;
};

Vec4.prototype.random = function(scale) {
    var m = new Vec4();
    vec4.random(m.data, scale);
    return m;
};

Vec4.prototype.scale = function(s) {
    var out = new Vec4();
    vec4.scale(out.data, this.data, s);
    return out;
};

Vec4.prototype.sub = Vec4.prototype.subtract = function(b) {
    var out = new Vec4();
    vec4.sub(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec4.prototype.transformQuat = function(q) {
    var out = new Vec4();
    vec4.transformQuat(out.data, this.data, q.data ? q.data : q);
    return out;
};

Vec4.prototype.toDOMString = function() {
    return vec4.toDOMString(this.data);
};

Vec4.fromDOMString = function(str) {
    var out = new Vec4();
    out.data.set( vec4.fromDOMString(str) );
    return out;
};

Vec4.wrap = function(vec) {
    var v = Vec4();
    v.data = vec.data ? vec.data : vec;
    return v;
};

module.exports = Vec4;

},{"./vec3.js":176,"gl-matrix":1}],178:[function(require,module,exports){
// Add convienent array methods if non-existant
if (!Array.forEach) {
    Array.forEach = function(array, fun, thisp) {
        var len = array.length;
        for ( var i = 0; i < len; i++) {
            if (i in array) {
                fun.call(thisp, array[i], i, array);
            }
        }
    };
}
if (!Array.map) {
    Array.map = function(array, fun, thisp) {
        var len = array.length;
        var res = [];
        for ( var i = 0; i < len; i++) {
            if (i in array) {
                res[i] = fun.call(thisp, array[i], i, array);
            }
        }
        return res;
    };
}
if (!Array.filter) {
    Array.filter = function(array, fun, thisp) {
        var len = array.length;
        var res = [];
        for ( var i = 0; i < len; i++) {
            if (i in array) {
                var val = array[i];
                if (fun.call(thisp, val, i, array)) {
                    res.push(val);
                }
            }
        }
        return res;
    };
}

if (!Array.erase) {
    Array.erase = function(array, object) {
        var erased = false;
        var idx = -1;
        while( (idx = array.indexOf(object) ) != -1){
            array.splice(idx, 1);
            erased = true;
        }
        return erased;
    };
}

if (!Array.set) {
    Array.set = function(array, offset, value) {
        for (var i=0; i < value.length; i++)
            array[offset+i] = value[i];
    };
}

if (!Array.isArray) {
    Array.isArray = function(arg) {
        return Object.prototype.toString.call(arg) == '[object Array]';
    };
}

},{}],179:[function(require,module,exports){
var CSSMatrix = require("./cssMatrix.js");

var css = {};

css.TRANSFORM_PROPERTY = null;

css.init = function () {
    if ('transform' in document.body.style) {
        css.TRANSFORM_PROPERTY = 'transform'
    } else if ('WebkitTransform' in document.body.style) {
        css.TRANSFORM_PROPERTY = '-webkit-transform'
    } else if ('MozTransform' in document.body.style) {
        css.TRANSFORM_PROPERTY = '-moz-transform'
    } else {
        XML3D.debug.logWarning("No supported transform css property found");
    }
};

css.getInlinePropertyValue = function (node, property) {
    var styleValue = node.getAttribute('style');
    if (styleValue) {
        var pattern = new RegExp(property + "\s*:([^;]+)", "i");
        var result = pattern.exec(styleValue);
        if (result)
            return result[1].trim();
    }
    return null;
};

css.getPropertyValue = function (node, property) {
    var value = this.getInlinePropertyValue(node, property);
    if (value)
        return value;

    var style = window.getComputedStyle(node);
    return style.getPropertyValue(property);
};

css.getCSSMatrix = function (node) {
    if (!css.TRANSFORM_PROPERTY || !CSSMatrix)
        return null;

    var style = null;

    if (css.TRANSFORM_PROPERTY != "transform")
        style = css.getInlinePropertyValue(node, "transform");

    if (!style)
        style = css.getPropertyValue(node, css.TRANSFORM_PROPERTY);

    if (!style || style == "none")
        return null;

    var result = null;
    try {
        result = new CSSMatrix(style);
    } catch (e) {
        XML3D.debug.logError("Error parsing transform property: " + style);
    }
    return result;

};


css.convertCssToMat4 = function (cssMatrix, m) {
    var matrix = m || new XML3D.Mat4();
    matrix.m11 = cssMatrix.m11;
    matrix.m12 = cssMatrix.m12;
    matrix.m13 = cssMatrix.m13;
    matrix.m14 = cssMatrix.m14;
    matrix.m21 = cssMatrix.m21;
    matrix.m22 = cssMatrix.m22;
    matrix.m23 = cssMatrix.m23;
    matrix.m24 = cssMatrix.m24;
    matrix.m31 = cssMatrix.m31;
    matrix.m32 = cssMatrix.m32;
    matrix.m33 = cssMatrix.m33;
    matrix.m34 = cssMatrix.m34;
    matrix.m41 = cssMatrix.m41;
    matrix.m42 = cssMatrix.m42;
    matrix.m43 = cssMatrix.m43;
    matrix.m44 = cssMatrix.m44;
    return matrix;
};

(function () {
    var styleElement = document.createElement("style");
    styleElement.textContent = "xml3d * { display: inherit; }" +
        "float,float2,float3,float4,float4x4,int,int4,bool,texture,string,compute { display: none; } " +
        "mesh,model,group { position: absolute; }";
    document.head.appendChild(styleElement);
}());


module.exports = css;


},{"./cssMatrix.js":180}],180:[function(require,module,exports){

/**
 *  class FirminCSSMatrix
 *
 *  The [[FirminCSSMatrix]] class is a concrete implementation of the
 *  `CSSMatrix` interface defined in the [CSS 2D Transforms][2d] and
 *  [CSS 3D Transforms][3d] Module specifications.
 *
 *  [2d]: http://www.w3.org/TR/css3-2d-transforms/
 *  [3d]: http://www.w3.org/TR/css3-3d-transforms/
 *
 *  The implementation was largely copied from the `WebKitCSSMatrix` class, and
 *  the supparting maths libraries in the [WebKit][webkit] project. This is one
 *  reason why much of the code looks more like C++ than JavaScript.
 *
 *  [webkit]: http://webkit.org/
 *
 *  Its API is a superset of that provided by `WebKitCSSMatrix`, largely
 *  because various pieces of supporting code have been added as instance
 *  methods rather than pollute the global namespace. Examples of these include
 *  [[FirminCSSMatrix#isAffine]], [[FirminCSSMatrix#isIdentityOrTranslation]]
 *  and [[FirminCSSMatrix#adjoint]].
 **/

/**
 *  new FirminCSSMatrix(domstr)
 *  - domstr (String): a string representation of a 2D or 3D transform matrix
 *    in the form given by the CSS transform property, i.e. just like the
 *    output from [[FirminCSSMatrix#toString]].
 *
 *  @constructor
 **/
var FirminCSSMatrix = function(domstr) {
    this.m11 = this.m22 = this.m33 = this.m44 = 1;

    this.m12 = this.m13 = this.m14 =
    this.m21 =            this.m23 = this.m24 =
    this.m31 = this.m32 =            this.m34 =
    this.m41 = this.m42 = this.m43            = 0;

    if (typeof domstr == "string") {
        this.setMatrixValue(domstr);
    }
};

/**
 *  FirminCSSMatrix.displayName = "FirminCSSMatrix"
 **/
FirminCSSMatrix.displayName = "FirminCSSMatrix";

/**
 *  FirminCSSMatrix.degreesToRadians(angle) -> Number
 *  - angle (Number): an angle in degrees.
 *
 *  Converts angles in degrees, which are used by the external API, to angles
 *  in radians used in internal calculations.
 **/
FirminCSSMatrix.degreesToRadians = function(angle) {
    return angle * Math.PI / 180;
};

/**
 *  FirminCSSMatrix.determinant2x2(a, b, c, d) -> Number
 *  - a (Number): top-left value of the matrix.
 *  - b (Number): top-right value of the matrix.
 *  - c (Number): bottom-left value of the matrix.
 *  - d (Number): bottom-right value of the matrix.
 *
 *  Calculates the determinant of a 2x2 matrix.
 **/
FirminCSSMatrix.determinant2x2 = function(a, b, c, d) {
    return a * d - b * c;
};

/**
 *  FirminCSSMatrix.determinant3x3(matrix) -> Number
 *  - a1 (Number): matrix value in position [1, 1].
 *  - a2 (Number): matrix value in position [1, 2].
 *  - a3 (Number): matrix value in position [1, 3].
 *  - b1 (Number): matrix value in position [2, 1].
 *  - b2 (Number): matrix value in position [2, 2].
 *  - b3 (Number): matrix value in position [2, 3].
 *  - c1 (Number): matrix value in position [3, 1].
 *  - c2 (Number): matrix value in position [3, 2].
 *  - c3 (Number): matrix value in position [3, 3].
 *
 *  Calculates the determinant of a 3x3 matrix.
 **/
FirminCSSMatrix.determinant3x3 = function(a1, a2, a3, b1, b2, b3, c1, c2, c3) {
    var determinant2x2 = FirminCSSMatrix.determinant2x2;
    return a1 * determinant2x2(b2, b3, c2, c3) -
    b1 * determinant2x2(a2, a3, c2, c3) +
    c1 * determinant2x2(a2, a3, b2, b3);
};

/**
 *  FirminCSSMatrix.determinant4x4(matrix) -> Number
 *  - matrix (FirminCSSMatrix): the matrix to calculate the determinant of.
 *
 *  Calculates the determinant of a 4x4 matrix.
 **/
FirminCSSMatrix.determinant4x4 = function(m) {
    var determinant3x3 = FirminCSSMatrix.determinant3x3,

        // Assign to individual variable names to aid selecting correct elements
    a1 = m.m11, b1 = m.m21, c1 = m.m31, d1 = m.m41,
    a2 = m.m12, b2 = m.m22, c2 = m.m32, d2 = m.m42,
    a3 = m.m13, b3 = m.m23, c3 = m.m33, d3 = m.m43,
    a4 = m.m14, b4 = m.m24, c4 = m.m34, d4 = m.m44;

    return a1 * determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4) -
    b1 * determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4) +
    c1 * determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4) -
    d1 * determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
};

/**
 * FirminCSSMatrix.toMatrixString(transformValue) -> String
 * - transformValue (String): `el.style.WebkitTransform`-style string (like `rotate(18rad) translate3d(50px, 100px, 10px)`)
 *
 * Tranforms a `el.style.WebkitTransform`-style string
 * (like `rotate(18rad) translate3d(50px, 100px, 10px)`)
 * into a `getComputedStyle(el)`-style matrix string
 * (like `matrix3d(0.6603167082440828, -0.7509872467716737, 0, 0, 0.7509872467716737, 0.6603167082440828, 0, 0, 0, 0, 1, 0, 108.11456008937151, 28.482308485824596, 10, 1)`)
 **/
FirminCSSMatrix.toMatrixString = function (transformValue) {
    var rgx = {
        functionSignature: /(\w+)\([^\)]+\)/ig,
        nameAndArguments: /(\w+)\(([^\)]+)\)/i,
        units: /([-\+]?[0-9]+[\.0-9]*)(deg|rad|grad|px|%)*/
    };
    var transformStatements = transformValue.match(/(\w+)\([^\)]+\)/ig);
    var onlyMatrices = transformStatements && transformStatements.every(function (t) { return (/^matrix/).test(t) });
    if (!transformStatements || onlyMatrices) return transformValue;

    var values = function (o) { return o.value };
    var cssFunctionToJsFunction = {
        matrix: function (m, o) {
            var m2 = new FirminCSSMatrix(o.unparsed);

            return m.multiply(m2)
        },
        matrix3d: function (m, o) {
            var m2 = new FirminCSSMatrix(o.unparsed);

            return m.multiply(m2)
        },

        perspective: function (m, o) {
            var m2 = new FirminCSSMatrix();
            m2.m34 -= 1 / o.value[0].value;

            return m.multiply(m2);
        },

        rotate: function (m, o) {
            return m.rotate.apply(m, o.value.map(values))
        },
        rotate3d: function (m, o) {
            return m.rotateAxisAngle.apply(m, o.value.map(values))
        },
        rotateX: function (m, o) {
            return m.rotate.apply(m, [o.value[0].value, 0, 0]);
        },
        rotateY: function (m, o) {
            return m.rotate.apply(m, [0, o.value[0].value, 0]);
        },
        rotateZ: function (m, o) {
            return m.rotate.apply(m, [0, 0, o.value[0].value]);
        },

        scale: function (m, o) {
            return m.scale.apply(m, o.value.map(values));
        },
        scale3d: function (m, o) {
            return m.scale.apply(m, o.value.map(values));
        },
        scaleX: function (m, o) {
            return m.scale.apply(m, o.value.map(values));
        },
        scaleY: function (m, o) {
            return m.scale.apply(m, [0, o.value[0].value, 0]);
        },
        scaleZ: function (m, o) {
            return m.scale.apply(m, [0, 0, o.value[0].value]);
        },

        skew: function (m, o) {
            var mX = new FirminCSSMatrix('skewX(' + o.value[0].unparsed + ')');
            var mY = new FirminCSSMatrix('skewY(' + o.value[1].unparsed + ')');
            var sM = 'matrix(1.00000, '+ mY.b +', '+ mX.c +', 1.000000, 0.000000, 0.000000)';
            var m2 = new FirminCSSMatrix(sM);

            return m.multiply(m2);
        },
        skewX: function (m, o) {
            return m.skewX.apply(m, [o.value[0].value]);
        },
        skewY: function (m, o) {
            return m.skewY.apply(m, [o.value[0].value]);
        },

        translate: function (m, o) {
            return m.translate.apply(m, o.value.map(values));
        },
        translate3d: function (m, o) {
            return m.translate.apply(m, o.value.map(values));
        },
        translateX: function (m, o) {
            return m.translate.apply(m, [o.value[0].value, 0, 0]);
        },
        translateY: function (m, o) {
            return m.translate.apply(m, [0, o.value[0].value, 0]);
        },
        translateZ: function (m, o) {
            return m.translate.apply(m, [0, 0, o.value[0].value]);
        }
    };
    var parseTransformStatement = function (str) {
        var pair = str.match(rgx.nameAndArguments).slice(1);

        return {
            key: pair[0],
            value: pair[1].split(/, ?/).map(function (value) {
                var parts = value.match(/([-\+]?[0-9]+[\.0-9]*)(deg|rad|grad|px|%)*/) || [];

                return {
                    value: parseFloat(parts[1]),
                    units: parts[2],
                    unparsed: value
                };
            }),
            unparsed: str
        };
    };

    var transformOperations = transformStatements.map(parseTransformStatement);
    var startingMatrix = new FirminCSSMatrix();
    var transformedMatrix = transformOperations.reduce(function (matrix, operation) {
        // convert to degrees b/c all CSSMatrix methods expect degrees
        operation.value = operation.value.map(function (operation) {
            if (operation.units == 'rad') {
                operation.value = operation.value * (180 / Math.PI);
                operation.units = 'deg';
            }
            else if (operation.units == 'grad') {
                operation.value = operation.value / (400 / 360); // 400 gradians in 360 degrees
                operation.units = 'deg'
            }

            return operation;
        });

        var jsFunction = cssFunctionToJsFunction[operation.key];
        var result = jsFunction(matrix, operation);

        return result || matrix;
    }, startingMatrix);

    return transformedMatrix.toString();
};

/**
 *  FirminCSSMatrix#a -> Number
 *  The first 2D vector value.
 **/

/**
 *  FirminCSSMatrix#b -> Number
 *  The second 2D vector value.
 **/

/**
 *  FirminCSSMatrix#c -> Number
 *  The third 2D vector value.
 **/

/**
 *  FirminCSSMatrix#d -> Number
 *  The fourth 2D vector value.
 **/

/**
 *  FirminCSSMatrix#e -> Number
 *  The fifth 2D vector value.
 **/

/**
 *  FirminCSSMatrix#f -> Number
 *  The sixth 2D vector value.
 **/

/**
 *  FirminCSSMatrix#m11 -> Number
 *  The 3D matrix value in the first row and first column.
 **/

/**
 *  FirminCSSMatrix#m12 -> Number
 *  The 3D matrix value in the first row and second column.
 **/

/**
 *  FirminCSSMatrix#m13 -> Number
 *  The 3D matrix value in the first row and third column.
 **/

/**
 *  FirminCSSMatrix#m14 -> Number
 *  The 3D matrix value in the first row and fourth column.
 **/

/**
 *  FirminCSSMatrix#m21 -> Number
 *  The 3D matrix value in the second row and first column.
 **/

/**
 *  FirminCSSMatrix#m22 -> Number
 *  The 3D matrix value in the second row and second column.
 **/

/**
 *  FirminCSSMatrix#m23 -> Number
 *  The 3D matrix value in the second row and third column.
 **/

/**
 *  FirminCSSMatrix#m24 -> Number
 *  The 3D matrix value in the second row and fourth column.
 **/

/**
 *  FirminCSSMatrix#m31 -> Number
 *  The 3D matrix value in the third row and first column.
 **/

/**
 *  FirminCSSMatrix#m32 -> Number
 *  The 3D matrix value in the third row and second column.
 **/

/**
 *  FirminCSSMatrix#m33 -> Number
 *  The 3D matrix value in the third row and third column.
 **/

/**
 *  FirminCSSMatrix#m34 -> Number
 *  The 3D matrix value in the third row and fourth column.
 **/

/**
 *  FirminCSSMatrix#m41 -> Number
 *  The 3D matrix value in the fourth row and first column.
 **/

/**
 *  FirminCSSMatrix#m42 -> Number
 *  The 3D matrix value in the fourth row and second column.
 **/

/**
 *  FirminCSSMatrix#m43 -> Number
 *  The 3D matrix value in the fourth row and third column.
 **/

/**
 *  FirminCSSMatrix#m44 -> Number
 *  The 3D matrix value in the fourth row and fourth column.
 **/

[["m11", "a"],
    ["m12", "b"],
    ["m21", "c"],
    ["m22", "d"],
    ["m41", "e"],
    ["m42", "f"]].forEach(function(pair) {
    var key3d = pair[0], key2d = pair[1];

    Object.defineProperty(FirminCSSMatrix.prototype, key2d, {
        set: function(val) {
            this[key3d] = val;
        },

        get: function() {
            return this[key3d];
        },
        enumerable : true,
        configurable : true
    });
});

/**
 *  FirminCSSMatrix#isAffine() -> Boolean
 *
 *  Determines whether the matrix is affine.
 **/
FirminCSSMatrix.prototype.isAffine = function() {
    return this.m13 === 0 && this.m14 === 0 &&
    this.m23 === 0 && this.m24 === 0 &&
    this.m31 === 0 && this.m32 === 0 &&
    this.m33 === 1 && this.m34 === 0 &&
    this.m43 === 0 && this.m44 === 1;
};

/**
 *  FirminCSSMatrix#multiply(otherMatrix) -> FirminCSSMatrix
 *  - otherMatrix (FirminCSSMatrix): the matrix to multiply this one by.
 *
 *  Multiplies the matrix by a given matrix and returns the result.
 **/
FirminCSSMatrix.prototype.multiply = function(otherMatrix) {
    if (!otherMatrix) return null;

    var a = otherMatrix,
    b = this,
    c = new FirminCSSMatrix();

    c.m11 = a.m11 * b.m11 + a.m12 * b.m21 + a.m13 * b.m31 + a.m14 * b.m41;
    c.m12 = a.m11 * b.m12 + a.m12 * b.m22 + a.m13 * b.m32 + a.m14 * b.m42;
    c.m13 = a.m11 * b.m13 + a.m12 * b.m23 + a.m13 * b.m33 + a.m14 * b.m43;
    c.m14 = a.m11 * b.m14 + a.m12 * b.m24 + a.m13 * b.m34 + a.m14 * b.m44;

    c.m21 = a.m21 * b.m11 + a.m22 * b.m21 + a.m23 * b.m31 + a.m24 * b.m41;
    c.m22 = a.m21 * b.m12 + a.m22 * b.m22 + a.m23 * b.m32 + a.m24 * b.m42;
    c.m23 = a.m21 * b.m13 + a.m22 * b.m23 + a.m23 * b.m33 + a.m24 * b.m43;
    c.m24 = a.m21 * b.m14 + a.m22 * b.m24 + a.m23 * b.m34 + a.m24 * b.m44;

    c.m31 = a.m31 * b.m11 + a.m32 * b.m21 + a.m33 * b.m31 + a.m34 * b.m41;
    c.m32 = a.m31 * b.m12 + a.m32 * b.m22 + a.m33 * b.m32 + a.m34 * b.m42;
    c.m33 = a.m31 * b.m13 + a.m32 * b.m23 + a.m33 * b.m33 + a.m34 * b.m43;
    c.m34 = a.m31 * b.m14 + a.m32 * b.m24 + a.m33 * b.m34 + a.m34 * b.m44;

    c.m41 = a.m41 * b.m11 + a.m42 * b.m21 + a.m43 * b.m31 + a.m44 * b.m41;
    c.m42 = a.m41 * b.m12 + a.m42 * b.m22 + a.m43 * b.m32 + a.m44 * b.m42;
    c.m43 = a.m41 * b.m13 + a.m42 * b.m23 + a.m43 * b.m33 + a.m44 * b.m43;
    c.m44 = a.m41 * b.m14 + a.m42 * b.m24 + a.m43 * b.m34 + a.m44 * b.m44;

    return c;
};

/**
 *  FirminCSSMatrix#isIdentityOrTranslation() -> Boolean
 *
 *  Returns whether the matrix is the identity matrix or a translation matrix.
 **/
FirminCSSMatrix.prototype.isIdentityOrTranslation = function() {
    var t = this;
    return t.m11 === 1 && t.m12 === 0 && t.m13 === 0 && t.m14 === 0 &&
    t.m21 === 0 && t.m22 === 1 && t.m23 === 0 && t.m24 === 0 &&
    t.m31 === 0 && t.m31 === 0 && t.m33 === 1 && t.m34 === 0 &&
        /* m41, m42 and m43 are the translation points */   t.m44 === 1;
};

/**
 *  FirminCSSMatrix#adjoint() -> FirminCSSMatrix
 *
 *  Returns the adjoint matrix.
 **/
FirminCSSMatrix.prototype.adjoint = function() {
    var result = new FirminCSSMatrix(), t = this,
    determinant3x3 = FirminCSSMatrix.determinant3x3,

    a1 = t.m11, b1 = t.m12, c1 = t.m13, d1 = t.m14,
    a2 = t.m21, b2 = t.m22, c2 = t.m23, d2 = t.m24,
    a3 = t.m31, b3 = t.m32, c3 = t.m33, d3 = t.m34,
    a4 = t.m41, b4 = t.m42, c4 = t.m43, d4 = t.m44;

    // Row column labeling reversed since we transpose rows & columns
    result.m11 =  determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4);
    result.m21 = -determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4);
    result.m31 =  determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4);
    result.m41 = -determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);

    result.m12 = -determinant3x3(b1, b3, b4, c1, c3, c4, d1, d3, d4);
    result.m22 =  determinant3x3(a1, a3, a4, c1, c3, c4, d1, d3, d4);
    result.m32 = -determinant3x3(a1, a3, a4, b1, b3, b4, d1, d3, d4);
    result.m42 =  determinant3x3(a1, a3, a4, b1, b3, b4, c1, c3, c4);

    result.m13 =  determinant3x3(b1, b2, b4, c1, c2, c4, d1, d2, d4);
    result.m23 = -determinant3x3(a1, a2, a4, c1, c2, c4, d1, d2, d4);
    result.m33 =  determinant3x3(a1, a2, a4, b1, b2, b4, d1, d2, d4);
    result.m43 = -determinant3x3(a1, a2, a4, b1, b2, b4, c1, c2, c4);

    result.m14 = -determinant3x3(b1, b2, b3, c1, c2, c3, d1, d2, d3);
    result.m24 =  determinant3x3(a1, a2, a3, c1, c2, c3, d1, d2, d3);
    result.m34 = -determinant3x3(a1, a2, a3, b1, b2, b3, d1, d2, d3);
    result.m44 =  determinant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3);

    return result;
};

/**
 *  FirminCSSMatrix#inverse() -> FirminCSSMatrix | null
 *
 *  If the matrix is invertible, returns its inverse, otherwise returns null.
 **/
FirminCSSMatrix.prototype.inverse = function() {
    var inv, det, result, i, j;

    if (this.isIdentityOrTranslation()) {
        inv = new FirminCSSMatrix();

        if (!(this.m41 === 0 && this.m42 === 0 && this.m43 === 0)) {
            inv.m41 = -this.m41;
            inv.m42 = -this.m42;
            inv.m43 = -this.m43;
        }

        return inv;
    }

    // Calculate the adjoint matrix
    result = this.adjoint();

    // Calculate the 4x4 determinant
    det = FirminCSSMatrix.determinant4x4(this);

    // If the determinant is zero, then the inverse matrix is not unique
    if (Math.abs(det) < 1e-8) return null;

    // Scale the adjoint matrix to get the inverse
    for (i = 1; i < 5; i++) {
        for (j = 1; j < 5; j++) {
            result[("m" + i) + j] /= det;
        }
    }

    return result;
};

/**
 *  FirminCSSMatrix#rotate(rotX, rotY, rotZ) -> FirminCSSMatrix
 *  - rotX (Number): the rotation around the x axis.
 *  - rotY (Number): the rotation around the y axis. If undefined, the x
 *    component is used.
 *  - rotZ (Number): the rotation around the z axis. If undefined, the x
 *    component is used.
 *
 *  Returns the result of rotating the matrix by a given vector.
 *
 *  If only the first argument is provided, the matrix is only rotated about
 *  the z axis.
 **/
FirminCSSMatrix.prototype.rotate = function(rx, ry, rz) {
    var degreesToRadians = FirminCSSMatrix.degreesToRadians;

    if (typeof rx != "number" || isNaN(rx)) rx = 0;

    if ((typeof ry != "number" || isNaN(ry)) &&
    (typeof rz != "number" || isNaN(rz))) {
        rz = rx;
        rx = 0;
        ry = 0;
    }

    if (typeof ry != "number" || isNaN(ry)) ry = 0;
    if (typeof rz != "number" || isNaN(rz)) rz = 0;

    rx = degreesToRadians(rx);
    ry = degreesToRadians(ry);
    rz = degreesToRadians(rz);

    var tx = new FirminCSSMatrix(),
    ty = new FirminCSSMatrix(),
    tz = new FirminCSSMatrix(),
    sinA, cosA, sinA2;

    rz /= 2;
    sinA = Math.sin(rz);
    cosA = Math.cos(rz);
    sinA2 = sinA * sinA;

    // Matrices are identity outside the assigned values
    tz.m11 = tz.m22 = 1 - 2 * sinA2;
    tz.m12 = tz.m21 = 2 * sinA * cosA;
    tz.m21 *= -1;

    ry /= 2;
    sinA  = Math.sin(ry);
    cosA  = Math.cos(ry);
    sinA2 = sinA * sinA;

    ty.m11 = ty.m33 = 1 - 2 * sinA2;
    ty.m13 = ty.m31 = 2 * sinA * cosA;
    ty.m13 *= -1;

    rx /= 2;
    sinA = Math.sin(rx);
    cosA = Math.cos(rx);
    sinA2 = sinA * sinA;

    tx.m22 = tx.m33 = 1 - 2 * sinA2;
    tx.m23 = tx.m32 = 2 * sinA * cosA;
    tx.m32 *= -1;

    var isIdentity = (this.toString() === (new FirminCSSMatrix).toString());

    return (isIdentity)
    ? tz.multiply(ty).multiply(tx)
    : this.multiply(tx).multiply(ty).multiply(tz);
};

/**
 *  FirminCSSMatrix#rotateAxisAngle(rotX, rotY, rotZ, angle) -> FirminCSSMatrix
 *  - rotX (Number): the rotation around the x axis.
 *  - rotY (Number): the rotation around the y axis. If undefined, the x
 *    component is used.
 *  - rotZ (Number): the rotation around the z axis. If undefined, the x
 *    component is used.
 *  - angle (Number): the angle of rotation about the axis vector, in degrees.
 *
 *  Returns the result of rotating the matrix around a given vector by a given
 *  angle.
 *
 *  If the given vector is the origin vector then the matrix is rotated by the
 *  given angle around the z axis.
 **/
FirminCSSMatrix.prototype.rotateAxisAngle = function(x, y, z, a) {
    if (typeof x != "number" || isNaN(x)) x = 0;
    if (typeof y != "number" || isNaN(y)) y = 0;
    if (typeof z != "number" || isNaN(z)) z = 0;
    if (typeof a != "number" || isNaN(a)) a = 0;
    if (x === 0 && y === 0 && z === 0) z = 1;

    var t   = new FirminCSSMatrix(),
    len = Math.sqrt(x * x + y * y + z * z),
    cosA, sinA, sinA2, csA, x2, y2, z2;

    a     = (FirminCSSMatrix.degreesToRadians(a) || 0) / 2;
    cosA  = Math.cos(a);
    sinA  = Math.sin(a);
    sinA2 = sinA * sinA;

    // Bad vector, use something sensible
    if (len === 0) {
        x = 0;
        y = 0;
        z = 1;
    } else if (len !== 1) {
        x /= len;
        y /= len;
        z /= len;
    }

    // Optimise cases where axis is along major axis
    if (x === 1 && y === 0 && z === 0) {
        t.m22 = t.m33 = 1 - 2 * sinA2;
        t.m23 = t.m32 = 2 * cosA * sinA;
        t.m32 *= -1;
    } else if (x === 0 && y === 1 && z === 0) {
        t.m11 = t.m33 = 1 - 2 * sinA2;
        t.m13 = t.m31 = 2 * cosA * sinA;
        t.m13 *= -1;
    } else if (x === 0 && y === 0 && z === 1) {
        t.m11 = t.m22 = 1 - 2 * sinA2;
        t.m12 = t.m21 = 2 * cosA * sinA;
        t.m21 *= -1;
    } else {
        csA = sinA * cosA;
        x2  = x * x;
        y2  = y * y;
        z2  = z * z;

        t.m11 = 1 - 2 * (y2 + z2) * sinA2;
        t.m12 = 2 * (x * y * sinA2 + z * csA);
        t.m13 = 2 * (x * z * sinA2 - y * csA);
        t.m21 = 2 * (y * x * sinA2 - z * csA);
        t.m22 = 1 - 2 * (z2 + x2) * sinA2;
        t.m23 = 2 * (y * z * sinA2 + x * csA);
        t.m31 = 2 * (z * x * sinA2 + y * csA);
        t.m32 = 2 * (z * y * sinA2 - x * csA);
        t.m33 = 1 - 2 * (x2 + y2) * sinA2;
    }

    return this.multiply(t);
};

/**
 *  FirminCSSMatrix#scale(scaleX, scaleY, scaleZ) -> FirminCSSMatrix
 *  - scaleX (Number): the scaling factor in the x axis.
 *  - scaleY (Number): the scaling factor in the y axis. If undefined, the x
 *    component is used.
 *  - scaleZ (Number): the scaling factor in the z axis. If undefined, 1 is
 *    used.
 *
 *  Returns the result of scaling the matrix by a given vector.
 **/
FirminCSSMatrix.prototype.scale = function(scaleX, scaleY, scaleZ) {
    var transform = new FirminCSSMatrix();

    if (typeof scaleX != "number" || isNaN(scaleX)) scaleX = 1;
    if (typeof scaleY != "number" || isNaN(scaleY)) scaleY = scaleX;
    if (typeof scaleZ != "number" || isNaN(scaleZ)) scaleZ = 1;

    transform.m11 = scaleX;
    transform.m22 = scaleY;
    transform.m33 = scaleZ;

    return this.multiply(transform);
};

/**
 *  FirminCSSMatrix#skewX(skewX) -> FirminCSSMatrix
 *  - skewX (Number): the scaling factor in the x axis.
 *
 *  Returns the result of skewing the matrix by a given vector.
 **/
FirminCSSMatrix.prototype.skewX = function(degrees) {
    var radians = FirminCSSMatrix.degreesToRadians(degrees);
    var transform = new FirminCSSMatrix();

    transform.c = Math.tan(radians);

    return this.multiply(transform);
};

/**
 *  FirminCSSMatrix#skewY(skewY) -> FirminCSSMatrix
 *  - skewY (Number): the scaling factor in the x axis.
 *
 *  Returns the result of skewing the matrix by a given vector.
 **/
FirminCSSMatrix.prototype.skewY = function(degrees) {
    var radians = FirminCSSMatrix.degreesToRadians(degrees);
    var transform = new FirminCSSMatrix();

    transform.b = Math.tan(radians);

    return this.multiply(transform);
};

/**
 *  FirminCSSMatrix#translate(x, y, z) -> FirminCSSMatrix
 *  - x (Number): the x component of the vector.
 *  - y (Number): the y component of the vector.
 *  - z (Number): the z component of the vector. If undefined, 0 is used.
 *
 *  Returns the result of translating the matrix by a given vector.
 **/
FirminCSSMatrix.prototype.translate = function(x, y, z) {
    var t = new FirminCSSMatrix();

    if (typeof x != "number" || isNaN(x)) x = 0;
    if (typeof y != "number" || isNaN(y)) y = 0;
    if (typeof z != "number" || isNaN(z)) z = 0;

    t.m41 = x;
    t.m42 = y;
    t.m43 = z;

    return this.multiply(t);
};

/**
 *  FirminCSSMatrix#setMatrixValue(domstr) -> undefined
 *  - domstr (String): a string representation of a 2D or 3D transform matrix
 *    in the form given by the CSS transform property, i.e. just like the
 *    output from [[FirminCSSMatrix#toString]].
 *
 *  Sets the matrix values using a string representation, such as that produced
 *  by the [[FirminCSSMatrix#toString]] method.
 **/
FirminCSSMatrix.prototype.setMatrixValue = function(domstr) {
    domstr = FirminCSSMatrix.toMatrixString(domstr.trim());
    var mstr   = domstr.match(/^matrix(3d)?\(\s*(.+)\s*\)$/),
    is3d, chunks, len, points, i, chunk;

    if (!mstr) return;

    is3d   = !!mstr[1];
    chunks = mstr[2].split(/\s*,\s*/);
    len    = chunks.length;
    points = new Array(len);

    if ((is3d && len !== 16) || !(is3d || len === 6)) {
        XML3D.debug.logError("Invalid CSS Matrix: ", domstr);
        return;
    }
    try {
        for (i = 0; i < len; i++) {
            chunk = chunks[i];
            points[i] = parseFloat(chunk);
        }
    } catch(e) {
        XML3D.debug.logError("Invalid CSS Matrix: ", domstr);
        return;
    }
    for (i = 0; i < len; i++) {
        var point = is3d ?
        ("m" + (Math.floor(i / 4) + 1)) + (i % 4 + 1) :
        String.fromCharCode(i + 97); // ASCII char 97 == 'a'
        this[point] = points[i];
    }
};

/**
 *  FirminCSSMatrix#toString() -> String
 *
 *  Returns a string representation of the matrix.
 **/
FirminCSSMatrix.prototype.toString = function() {
    var self = this, points, prefix;

    if (this.isAffine()) {
        prefix = "matrix(";
        points = ["a", "b", "c", "d", "e", "f"];
    } else {
        prefix = "matrix3d(";
        points = ["m11", "m12", "m13", "m14",
            "m21", "m22", "m23", "m24",
            "m31", "m32", "m33", "m34",
            "m41", "m42", "m43", "m44"];
    }

    return prefix + points.map(function(p) {
        return self[p].toFixed(6);
    }).join(", ") + ")";
};

module.exports = FirminCSSMatrix;


},{}],181:[function(require,module,exports){
var printStackTrace = require("../contrib/stacktrace-0.4.js");
var Options = require("./options.js");
var assert = require("assert");

(function (ns) {

    var OPTION_LOGLEVEL = "loglevel";
    Options.register(OPTION_LOGLEVEL, "warning");

    ns.exports = {
        ALL: 0,
        DEBUG: 1,
        INFO: 2,
        WARNING: 3,
        ISSUE: 4,
        ERROR: 5,
        EXCEPTION: 6,
        params: {},
        isSetup: false,
        loglevel: 5,
        loglevels: {
            all: 0,
            debug: 1,
            info: 2,
            warning: 3,
            issue: 4,
            error: 5,
            exception: 6
        },

        setup: function () {
            var debug = XML3D.debug;
            if (!debug.isSetup) {
                debug.isSetup = true;
                debug.loglevel = debug.loglevels[Options.getValue(OPTION_LOGLEVEL)] || 3;
                Options.addObserver(function(key, value) {
                    if(key == OPTION_LOGLEVEL) {
                        debug.loglevel = debug.loglevels[value] || 3;
                    }
                })
            }
            return true;
        },
        _setLogLevel: function() {
        },
        doLog: function (logType, args) {
            var params = XML3D.debug.params;
            if (params.xml3d_nolog || logType < XML3D.debug.loglevel) {
                return;
            }
            args = Array.prototype.slice.call(args);
            if (window.console) {
                switch (logType) {
                    case XML3D.debug.INFO:
                        window.console.info.apply(window.console, args);
                        break;
                    case XML3D.debug.WARNING:
                        window.console.warn.apply(window.console, args);
                        break;
                    case XML3D.debug.ERROR:
                        window.console.error.apply(window.console, args);
                        break;
                    case XML3D.debug.EXCEPTION:
                        window.console.error(printStackTrace({e: args[0], guess: true}).join('\n'));
                        break;
                    case XML3D.debug.DEBUG:
                        window.console.debug.apply(window.console, args);
                        break;
                    case XML3D.debug.ISSUE:
                        assert(args[1] !== undefined, "Github issue number must be specified.");
                        var issue = args[0] + "\nMore information can be found at https://github.com/xml3d/xml3d.js/issues/" + args[1];
                        window.console.error(issue);
                        break;
                    default:
                        break;
                }
            }
        },
        logDebug: function () {
            XML3D.debug.doLog(XML3D.debug.DEBUG, arguments);
        },
        logInfo: function () {
            XML3D.debug.doLog(XML3D.debug.INFO, arguments);
        },
        logWarning: function () {
            XML3D.debug.doLog(XML3D.debug.WARNING, arguments);
        },
        logError: function () {
            XML3D.debug.doLog(XML3D.debug.ERROR, arguments);
        },
        logIssue: function() {
            XML3D.debug.doLog(XML3D.debug.ISSUE, arguments);
        },
        logException: function () {
            XML3D.debug.doLog(XML3D.debug.EXCEPTION, arguments);
        },
        assert: assert,
        trace: function (msg, logType) {
            logType = logType !== undefined ? logType : XML3D.debug.ERROR;
            if (window.console.trace) {
                if (msg) {
                    XML3D.debug.doLog(logType, [msg]);
                }
                window.console.trace();
            } else {
                var stack = printStackTrace();
                msg && stack.splice(0, 0, msg);
                XML3D.debug.doLog(logType, stack);
            }
        },
        getNumberWithPadding: function (number, width) {
            var res = "" + number;
            while (res.length < width) res = " " + res;
            return res;
        },
        formatSourceCode: function (source) {
            var result = "";
            var sourceLines = source.split("\n");
            for (var i = 0; i < sourceLines.length; ++i) {
                result += this.getNumberWithPadding(i + 1, 3) + "  " + sourceLines[i] + "\n";
            }
            return result;
        }
    };

}(module));

},{"../contrib/stacktrace-0.4.js":51,"./options.js":183,"assert":11}],182:[function(require,module,exports){
// utils/misc.js

(function(exports) {


    /**
     * This function sends single or multiple adapter functions by calling functions
     * specified in funcs parameter for each adapter associated with the node.
     *
     * funcs parameter is used as a dictionary where each key is used as name of a
     * adapter function to call, and corresponding value is a list of arguments
     * (i.e. must be an array). For example sendAdapterEvent(node, {method : [1,2,3]})
     * will call function 'method' with arguments 1,2,3 for each adapter of the node.
     *
     * @param {Object} node
     * @param {Object} funcs
     * @return {Array} array of all returned values
     */
    exports.callAdapterFunc = function(node, funcs) {
        var result = [];
        if (!node || node._configured === undefined)
            return result;
        var adapters = node._configured.adapters;
        for (var adapter in adapters) {
            for (var func in funcs) {
                var adapterObject = adapters[adapter];
                var eventHandler = adapterObject[func];
                if (eventHandler) {
                    result.push(eventHandler.apply(adapterObject, funcs[func]));
                }
            }
        }
        return result;
    };

    /**
     * This function sends single or multiple adapter events by calling functions
     * specified in events parameter for each adapter associated with the node.
     *
     * events parameter is used as a dictionary where each key is used as name of a
     * adapter function to call, and corresponding value is a list of arguments
     * (i.e. must be an array). For example sendAdapterEvent(node, {method : [1,2,3]})
     * will call function 'method' with arguments 1,2,3 for each adapter of the node.
     *
     * @param {Object} node
     * @param {Object} events
     * @return {Boolean} false if node is not configured.
     */
    exports.sendAdapterEvent = function(node, events) {
        if (!node || node._configured === undefined)
            return false;
        var adapters = node._configured.adapters;
        for (var adapter in adapters) {
            for (var event in events) {
                var eventHandler = adapters[adapter][event];
                if (eventHandler) {
                    eventHandler.apply(adapters[adapter], events[event]);
                }
            }
        }
        return true;
    };

    /**
     *
     * Dispatch custom HTML event
     *
     * @param {Object} target element or document.
     * @param {string} eventType custom event type.
     * @param {boolean} canBubble Whether the event propagates upward. Sets the value for the bubbles property.
     * @param {boolean} cancelable Whether the event is cancelable and so preventDefault can be called. Sets the value
     *                  for the cancelable property.
     * @param {Object} detail A user-defined object that can contain additional information about the event.
     *                        This parameter can be of any type, or null. This value is returned in the detail property of the event.
     */
    exports.dispatchCustomEvent = function(target, eventType, canBubble, cancelable, detail) {
        var event = document.createEvent('CustomEvent');
        event.initCustomEvent(eventType, canBubble, cancelable, detail);
        return target.dispatchEvent(event);
    };

    /** Dispatch HTML event
     *
     * @param {Object} target    element or document
     * @param {string} eventType standard event type e.g. load, click
     */
    exports.dispatchEvent = function(target, eventType) {
        var evt = null;
        if (document.createEvent) {
                evt = document.createEvent("Events");
                evt.initEvent(eventType, true, true);
                return target.dispatchEvent(evt);
            } else if (document.createEventObject) {
                evt = document.createEventObject();
                return target.fireEvent('on' + eventType, evt);
            }
        };

    var tmpCanvas, tmpContext;

    exports.toImageData = function(imageData) {
        if(imageData instanceof ImageData)
            return imageData;
        if(!imageData.data)
            throw new Error("no data property");
        if(!imageData.width)
            throw new Error("no width property");
        if(!imageData.height)
            throw new Error("no height property");
        if(!tmpContext) {
            tmpCanvas = document.createElement('canvas');
            tmpContext = tmpCanvas.getContext('2d');
        }
        var newImageData = tmpContext.createImageData(imageData.width, imageData.height);
        for(var i = 0; i < imageData.data.length; ++i) {
            var v = imageData.data[i];
            if(v > 255)
                v = 255;
            if(v < 0)
                v = 0;
            newImageData.data[i] = v;
        }
        return newImageData;
    };

    exports.elementIs = function(elem, name) {
        return elem && elem.tagName.toLowerCase() === name;
    };

    exports.encodeZIndex = function(zIndex, isLeafNode) {
        if (zIndex === "auto" || zIndex === "" || zIndex === "0") {
            if (isLeafNode) {
                zIndex = "0"; // Always give leaf nodes an implicit stacking context with z-index of 0 to ensure they compare properly with negative z-index leaf nodes
            } else {
                return ""; // Otherwise this group node does not create a new stacking context, so we can return an empty string
            }
        }
        // Pad with enough zeros to cover the maximum/minimum values (2147483647) for correct string compare results in the sorting step
        zIndex = "0000000000" + zIndex;
        zIndex = zIndex.slice(zIndex.length - 10); // 10 is the number of digits in the max value
        return zIndex;
    }

}(module.exports));

},{}],183:[function(require,module,exports){
(function (ns) {

    /**
     * Class to handle options. Currently only used for global options, could
     * be extended to work hierarchically to configure other elements.
     * @constructor
     */
    var Options = function () {
        this._options = {};
        this._listeners = { "*": [] };
    };

    Options.prototype = {
        register: function (key, defaultValue) {
            if (this._options.hasOwnProperty(key))
                throw new Error("Option already registered '" + key + "'");
            this._options[key] = {
                currentValue: defaultValue,
                defaultValue: defaultValue
            };
        },
        resetValue: function (key) {
            if (!this._options.hasOwnProperty(key))
                throw new Error("Invalid configuration key '" + key + "'");
            this._options[key].currentValue = this._options[key].defaultValue;
            this.notifyObservers(key, this._options[key].currentValue);
        },
        setValue: function (key, value) {
            if (!this._options.hasOwnProperty(key))
                throw new Error("Invalid configuration key '" + key + "'");
            this._options[key].currentValue = value;
            this.notifyObservers(key, value);
        },
        getValue: function (key) {
            if (!this._options.hasOwnProperty(key)) {
                throw new Error("Invalid configuration key '" + key + "'");
            }
            return this._options[key].currentValue;
        },
        getKeys: function () {
            return Object.keys(this._options);
        },
        notifyObservers: function (key, value) {
            // Notify specific observers
            if(this._listeners.hasOwnProperty(key)) {
                this._listeners[key].forEach(function(l) {
                   l(key, value);
                });
            }
            // Notify generic observers
            this._listeners["*"].forEach(function(l) {
               l(key, value);
            });
        },
        addObserver: function (key, observer) {
            if(typeof key == 'function') {
                observer = key;
                key = "*"
            }
            if(!this._options.hasOwnProperty(key) && key !== "*") {
                throw new Error("Can't register to unknown option '" + key + "'");
            }
            if(!this._listeners.hasOwnProperty(key)) {
                this._listeners[key] = [];
            }
            this._listeners[key].push(observer);
        },
        removeObserver: function (observer) {
            for(var filter in this._listeners) {
                var listeners = this._listeners[filter];
                var idx = listeners.indexOf(observer);
                if (idx != -1)
                    listeners.splice(idx, 1);
            }

        }
    };

    var GlobalOptions = new Options();

    GlobalOptions.setOptionsFromQuery = function () {
        var p = window.location.search.substr(1).split('&');

        p.forEach(function (e) {
            var keyVal = e.split('=');
            try {
                var key = keyVal[0].toLowerCase();
                if (key.indexOf("xml3d-") === 0) {
                    var value = decodeURIComponent(keyVal[1]);
                    try {
                        value = JSON.parse(value);
                    } catch (e) {
                        // Do nothing
                    }
                    XML3D.options.setValue(key.substr(6), value);
                }
            } catch (e) {
                XML3D.debug && XML3D.debug.logError(e);
            }
        });
    };

    ns.exports = GlobalOptions;

}(module));

},{}],184:[function(require,module,exports){
(function(exports) {
    /**
     * Class URI
     * @constructor
     * @param {string} str The URI as string
     */
    var URI = function (str) {
        str = str || "";
        if (str.indexOf("blob:") == 0) {
            // Based on http://www.w3.org/TR/FileAPI/#url
            var parser = /^(?:([^:\/?\#]+):)?([^\#]*)(?:\#(.*))?/;
            var result = str.match(parser);
            /**  @type {boolean} */
            this.valid = result != null;
            /**  @type {?string} */
            this.scheme = result[1] || null;
            /**  @type {?string} */
            this.authority = null;
            /**  @type {?string} */
            this.path = null;
            /**  @type {?string} */
            this.query = null;
            /**  @type {?string} */
            this.opaqueString = result[2] || null;
            /**  @type {?string} */
            this.fragment = result[3] || null;
        } else {
            // Based on the regex in RFC2396 Appendix B.
            var parser = /^(?:([^:\/?\#]+):)?(?:\/\/([^\/?\#]*))?([^?\#]*)(?:\?([^\#]*))?(?:\#(.*))?/;
            var result = str.match(parser);
            /**  @type {boolean} */
            this.valid = result != null;
            /**  @type {?string} */
            this.scheme = result[1] || null;
            /**  @type {?string} */
            this.authority = result[2] || null;
            /**  @type {?string} */
            this.path = result[3] || null;
            /**  @type {?string} */
            this.query = result[4] || null;
            /**  @type {?string} */
            this.opaqueString = null;
            /**  @type {?string} */
            this.fragment = result[5] || null;
        }
    };

    /**
     * @return {boolean} true if URI is relative to current document
     */
    URI.prototype.isLocal = function () {
        return this.scheme != "blob" && !this.authority && !this.path;
    }

    /**
     * @return {boolean} true if URI is absolute
     */
    URI.prototype.isAbsolute = function () {
        return this.scheme != null;
    }

    /**
     * Get absolute URI relative to the provided document uri
     * @param {string} docUri uri of document from which this uri originates
     * @returns {URI}
     */
    URI.prototype.getAbsoluteURI = function (docUri) {
        if (!this.valid || this.isAbsolute()) {
            return this;
        }

        var docUriObj = new URI(docUri);

        if (this.path) {
            if (this.path.indexOf("/") == 0) {
                docUriObj.path = this.path;
            } else {
                docUriObj.path = docUriObj.path.substr(0, docUriObj.path.lastIndexOf("/") + 1) + this.path;
            }
            docUriObj.query = this.query;
        } else if (this.query) {
            docUriObj.query = this.query;
        }
        docUriObj.fragment = this.fragment;

        return docUriObj;
    }

    /**
     * Returns if this URI has the same origin as the provided reference
     * @param {URI|string} other
     * @returns {boolean}
     */
    URI.prototype.hasSameOrigin = function (other) {
        if (typeof other == 'string')
            other = new URI(other);

        if (this.scheme == "blob" || this.scheme == "data") {
            return true;
        }

        return this.scheme == other.scheme && this.authority == other.authority;
    };


// Restore the URI to it's stringy glory.
    URI.prototype.toString = function () {
        var str = "";
        if (this.scheme == "blob") {
            str = "blob:" + this.opaqueString;
            if (this.fragment) {
                str += "#" + this.fragment;
            }
            return str;
        }
        if (this.scheme) {
            str += this.scheme + ":";
        }
        if (this.authority) {
            str += "//" + this.authority;
        }
        if (this.path) {
            str += this.path;
        }
        if (this.query) {
            str += "?" + this.query;
        }
        if (this.fragment) {
            str += "#" + this.fragment;
        }
        return str;
    };

// Restore the URI to it's stringy glory minus the fragment
    URI.prototype.toStringWithoutFragment = function () {
        var str = "";
        if (this.scheme == "blob") {
            str = "blob:" + this.opaqueString;
            return str;
        }
        if (this.scheme) {
            str += this.scheme + ":";
        }
        if (this.authority) {
            str += "//" + this.authority;
        }
        if (this.path) {
            str += this.path;
        }
        if (this.query) {
            str += "?" + this.query;
        }
        return str;
    };

    /**
     * Class URIResolver
     * @constructor
     */
    var URIResolver = function () {
    };

    /**
     * Resolve a local URI to an element
     * @param {(string|URI)} uri Element to resolve
     * @param {Document=} document Base document to use
     * @return {Element} The resolved element or null if it could not be resolved
     */
    URIResolver.resolveLocal = function (uri, document) {
        if (typeof uri == 'string')
            uri = new URI(uri);
        document = document || window.document;

        if (uri.scheme == 'urn' || uri.scheme == "blob") {
            return null;
        }

        if (!uri.path && uri.fragment) { // local uri
            return document.getElementById(uri.fragment);
        }
        return null;
    };


    /**
     * @deprecated
     */
    URIResolver.resolve = function (uri, document) {
        XML3D.debug.logWarning("You are using deprecated XML3D.URIResolver.resolve. Use XML3D.URIResolver.resolveLocal instead.");
        return URIResolver.resolveLocal(uri, document);
    };

    exports.URI = URI;
    exports.URIResolver = URIResolver;

}(module.exports));

},{}],185:[function(require,module,exports){
//TODO: Helpful API methods concerning WebCL will be added when needed. Please provide feedback!

/**
 * @file WebCL API. Provides useful methods for initialising and utilising the WebCL platform.
 * @version 0.2
 * @author Toni Dahl
 */

(function (namespace, undefined) {

    var platforms = [],
        devices = [],
        ctx = null,

        WebCLNamespaceAvailable = false,
        OpenCLDriversAvailable = false;

    /**
     *     @constant {string} DEFAULT_DEVICE
     *     @default "CPU"
     */
    var DEFAULT_DEVICE = "CPU",

        /**
         *     @readonly
         *     @name CL_ERROR_CODES
         *     @enum {number}
         */
            CL_ERROR_CODES = {
            "SUCCESS": 0,
            "DEVICE_NOT_FOUND": -1,
            "DEVICE_NOT_AVAILABLE": -2,
            "COMPILER_NOT_AVAILABLE": -3,
            "MEM_OBJECT_ALLOCATION_FAILURE": -4,
            "OUT_OF_RESOURCES": -5,
            "OUT_OF_HOST_MEMORY": -6,
            "PROFILING_INFO_NOT_AVAILABLE": -7,
            "MEM_COPY_OVERLAP": -8,
            "IMAGE_FORMAT_MISMATCH": -9,
            "IMAGE_FORMAT_NOT_SUPPORTED": -10,
            "BUILD_PROGRAM_FAILURE": -11,
            "MAP_FAILURE": -12,
            "INVALID_VALUE": -30,
            "INVALID_DEVICE_TYPE": -31,
            "INVALID_PLATFORM": -32,
            "INVALID_DEVICE": -33,
            "INVALID_CONTEXT": -34,
            "INVALID_QUEUE_PROPERTIES": -35,
            "INVALID_COMMAND_QUEUE": -36,
            "INVALID_HOST_PTR": -37,
            "INVALID_MEM_OBJECT": -38,
            "INVALID_IMAGE_FORMAT_DESCRIPTOR": -39,
            "INVALID_IMAGE_SIZE": -40,
            "INVALID_SAMPLER": -41,
            "INVALID_BINARY": -42,
            "INVALID_BUILD_OPTIONS": -43,
            "INVALID_PROGRAM": -44,
            "INVALID_PROGRAM_EXECUTABLE": -45,
            "INVALID_KERNEL_NAME": -46,
            "INVALID_KERNEL_DEFINITION": -47,
            "INVALID_KERNEL": -48,
            "INVALID_ARG_INDEX": -49,
            "INVALID_ARG_VALUE": -50,
            "INVALID_ARG_SIZE": -51,
            "INVALID_KERNEL_ARGS": -52,
            "INVALID_WORK_DIMENSION": -53,
            "INVALID_WORK_GROUP_SIZE": -54,
            "INVALID_WORK_ITEM_SIZE": -55,
            "INVALID_GLOBAL_OFFSET": -56,
            "INVALID_EVENT_WAIT_LIST": -57,
            "INVALID_EVENT": -58,
            "INVALID_OPERATION": -59,
            "INVALID_GL_OBJECT": -60,
            "INVALID_BUFFER_SIZE": -61,
            "INVALID_MIP_LEVEL": -62,
            "INVALID_GLOBAL_WORK_SIZE": -63
        };
    Object.freeze(CL_ERROR_CODES);


    function isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    /**
     * Returns a CL error name corresponding to a CL error code
     *
     * @function XML3D.webcl~getCLErrorName
     * @param {number} errorCode
     * @returns {string}
     */

    function getCLErrorName(errorCode) {
        var prop;

        if (isNumber(errorCode)) {
            for (prop in CL_ERROR_CODES) {
                if (CL_ERROR_CODES[prop] === errorCode) {
                    return prop;
                }
            }
            XML3D.debug.logDebug("Got unknown OpenCL Error Code:", errorCode);
        }

        return "UNKNOWN_ERROR";
    }

    /**
     * Gets an error code from a CL error message (thrown by Nokia WebCL Plugin)
     *
     * @param e
     * @returns {Integer|Boolean}
     */

    function getErrorCodeFromCLError(e) {
        var code = null;

        if (e.name && typeof e.name === "string") {
            if (CL_ERROR_CODES[e.name]) {
                return CL_ERROR_CODES[e.name];
            }
        }
        if (e.message && typeof e.message === "string") {
            code = e.message.match(/-?\d+/g);

            if (code instanceof Array) {
                return parseInt(code[code.length - 1], 10);
            }
        }

        return false;
    }

    /**
     * Creates instance of WebCLError
     *
     * @constructor XML3D.webcl~WebCLError
     * @param {string} [name="WebCLError"] Error name
     * @param {string} [msg="Generic WebCL error."] The desired error message
     */

    function WebCLError(name, msg) {
        if (name && typeof name !== "string") {
            XML3D.debug.logDebug("WebCL API: WebCLError: Error name not type of String");
            name = "";
        }

        if (msg && typeof msg !== "string") {
            XML3D.debug.logDebug("WebCL API: WebCLError: Error message not type of String");
            msg = "";
        }

        this.name = name || "WebCLError";
        this.message = msg || "Generic WebCL error.";
        this.stack = (new Error()).stack;
    }

    WebCLError.prototype = Object.create(Error.prototype);
    WebCLError.prototype.constructor = WebCLError;


    /**
     * Checks if WebCL namespace is available. The namespace can be provided by a WebCL plugin or native implementation.
     *
     * @function XML3D.webcl~hasWebCLNamespace
     * @returns {Boolean}
     */

    function hasWebCLNamespace() {
        WebCLNamespaceAvailable = window.webcl && webcl.getPlatforms;

        return WebCLNamespaceAvailable;

    }

    /**
     * Tests a basic WebCL method to see if the OpenCL drivers are working on users device.
     *
     * @function XML3D.webcl~hasOpenCLDrivers
     * @returns {Boolean}
     */

    function hasOpenCLDrivers() {
        var platArr;
        OpenCLDriversAvailable = true;

        try {
            platArr = webcl.getPlatforms();
        } catch (e) {
            OpenCLDriversAvailable = false;
        }

        if (!platArr || platArr.length === 0) {
            OpenCLDriversAvailable = false;
        }

        return OpenCLDriversAvailable;

    }

    /**
     * Combines WebCL namespace and driver test.
     *
     * @function XML3D.webcl~isAvailable
     * @returns {Boolean}
     */

    function isAvailable() {
        return hasWebCLNamespace() && hasOpenCLDrivers();
    }


    /**
     * Initialises the WebCL API with default values using a predefined device type or a default device type.
     *
     * @function XML3D.webcl~init
     * @param {string} [type="CPU"] Device type
     * @return {Boolean}
     */

    function init(type) {
        // Checking if WebCL is available in the users system
        if (!hasWebCLNamespace()) {
            XML3D.debug.logWarning("WebCL API: Unfortunately your system does not support WebCL. " +
                "WebCL namespace is not available.");
            return false;
        }

        if (!hasOpenCLDrivers()) {
            XML3D.debug.logWarning("WebCL API: Unfortunately your system does not support WebCL. " +
                "OpenCL drivers are not working properly.");
            return false;
        }

        getPlatforms();

        devices = getDevicesByType(type || DEFAULT_DEVICE);

        // Creating default context
        ctx = createContext(devices);

        return true;
    }

    /**
     * Returns all available WebCL device platforms.
     *
     * @function XML3D.webcl~getPlatforms
     * @returns {Array}
     */

    function getPlatforms() {
        if(platforms.length === 0) {
            platforms = webcl.getPlatforms();
        }

        return platforms;
    }

    /**
     * Returns all devices of a chosen type from a selected platform.
     *
     * @param {string} [type="CPU"] Device type
     * @param {IWebCLPlatform} platform
     * @returns {Array|Boolean}
     */

    function getPlatformDevicesByType(type, platform) {
        var deviceArr = [], errCode;

        if (!platform) {
            XML3D.debug.logError("WebCL API: getPlatformDevicesByType(): platform was not defined.");
            return false;
        }

        type = type || DEFAULT_DEVICE;

        try {
            if (type === "CPU") {
                deviceArr = platform.getDevices(webcl.DEVICE_TYPE_CPU);
            } else if (type === "GPU") {
                deviceArr = platform.getDevices(webcl.DEVICE_TYPE_GPU);
            } else if (type === "ALL") {
                deviceArr = platform.getDevices(webcl.DEVICE_TYPE_ALL);
            }

        } catch (e) {
            errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            } else if (errCode !== CL_ERROR_CODES.DEVICE_NOT_FOUND) {
                throw new WebCLError(getCLErrorName(errCode), "Could not get devices.");
            }

            return false;
        }

        return deviceArr;
    }

    /**
     * Gets all devices of a selected type from all available platforms.
     *
     * @function XML3D.webcl~getDevicesByType
     * @param {string} type Device type
     * @returns {Array|Boolean}
     */

    function getDevicesByType(type) {
        var resultArr = [], deviceArr, i;

        getPlatforms();

        for (i = platforms.length; i--;) {
            deviceArr = getPlatformDevicesByType(type, platforms[i]);

            if (deviceArr) {
                deviceArr.forEach(function (v) {
                    resultArr.push(v);
                });
            }
        }
        return resultArr.length === 0 ? false : resultArr;
    }


    /**
     * Gets the platform on where the device is.
     *
     * @function XML3D.webcl~getDevicePlatform
     * @param {IWebCLDevice} device
     * @returns {IWebCLPlatform|Boolean}
     */

    function getDevicePlatform(device) {
        var platform;

        if (!device) {
            XML3D.debug.logError("WebCL API: getDevicePlatform(): device was not defined.");
            return false;
        }

        try {
            platform = device.getInfo(webcl.DEVICE_PLATFORM);
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }

            throw new WebCLError(getCLErrorName(errCode), "Could not get the platform of the device.");
        }

        return platform;
    }

    /**
     *
     * @param clCtx
     * @returns {boolean}
     */

    function getContextDevices(clCtx) {
        var deviceArr = [], errCode;

        if(!clCtx) {
            XML3D.debug.logError("WebCL API: getContextDevices(): clCtx was not defined.");
            return false;
        }

        try {
            deviceArr = clCtx.getInfo(webcl.CONTEXT_DEVICES);
        }catch(e) {
            errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            } else {
                throw new WebCLError(getCLErrorName(errCode), "Could not get devices.");
            }

        }

        return deviceArr.length === 0 ? false : deviceArr;
    }

    /**
     * Creates a WebCL context
     *
     * @function XML3D.webcl~createContext
     * @param {object} [properties]
     * @returns {IWebCLContext}
     */

    function createContext(properties) {
      /*
        var props = {
            devices: getDevicesByType(DEFAULT_DEVICE)
            }, context;

        XML3D.extend(props, properties);*/

        try {
            var context = webcl.createContext(properties);
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }
            throw new WebCLError(getCLErrorName(errCode), "Failed to create a WebCL context.");
        }

        return context;
    }

    /**
     * Gets the default WebCL context.
     *
     * @function XML3D.webcl~getDefaultContext
     * @returns {IWebCLContext}
     */

    function getDefaultContext() {
        return ctx;
    }


    /**
     * Creates a WebCL program from a string of WebCL code.
     *
     * @function XML3D.webcl~createProgram
     * @param {string} codeStr
     * @param {IWebCLContext} clCtx
     * @returns {IWebCLProgram | Boolean}
     */

    function createProgram(codeStr, clCtx) {
        var program;

        clCtx = clCtx || ctx;

        if (!codeStr) {
            XML3D.debug.logError("WebCL API: createProgram(): codeStr was not defined.");
            return false;
        }

        if (!clCtx) {
            XML3D.debug.logError("WebCL API: createProgram(): clCtx was not defined.");
            return false;
        }

        try {
            program = clCtx.createProgram(codeStr);
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }

            throw new WebCLError(getCLErrorName(errCode), "Failed to create a WebCL program.");
        }

        return program;
    }

    /**
     * Builds a WebCL program.
     *
     * @function XML3D.webcl~buildProgram
     * @param {IWebCLProgram} program
     * @param {Array} deviceArr
     * @returns {IWebCLProgram|Boolean}
     */

    function buildProgram(program, deviceArr) {
        deviceArr = deviceArr || devices;

        if (!program) {
            XML3D.debug.logError("WebCL API: buildProgram(): program was not defined.");
            return false;
        }

        try {
            program.build(deviceArr, "");
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }
            throw new WebCLError(getCLErrorName(errCode),
                program.getBuildInfo(deviceArr[0], WebCL.PROGRAM_BUILD_LOG));
        }

        return program;
    }

    /**
     * Creates a WebCL Kernel using a defined program.
     *
     * @function XML3D.webcl~createKernel
     * @param {IWebCLProgram} program
     * @param {string} name
     * @returns {IWebCLKernel|Boolean}
     */

    function createKernel(program, name) {
        var kernel;

        if (!program) {
            XML3D.debug.logError("WebCL API: createKernel(): program was not defined.");
            return false;
        }

        if (!name) {
            XML3D.debug.logError("WebCL API: createKernel(): name was not defined.");
            return false;
        }

        try {
            kernel = program.createKernel(name);
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }
            throw new WebCLError(getCLErrorName(errCode), "Failed to create a WebCL kernel.");
        }

        return kernel;
    }

    /**
     * Creates a WebCL Command Queue for queueing kernels for execution.
     *
     * @function XML3D.webcl~createCommandQueue
     * @param {IWebCLDevice} device
     * @param {IWebCLContext} clCtx
     * @returns {IWebCLCommandQueue|Boolean}
     */

    function createCommandQueue(device, clCtx) {
        var cmdQueue;

        clCtx = clCtx || ctx;

        if(!clCtx) {
            XML3D.debug.logError("WebCL API: createCommandQueue: clCtx was not defined");
            return false;
        }

        try {
            cmdQueue = clCtx.createCommandQueue(device || devices[0], 0);
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }
            throw new WebCLError(getCLErrorName(getErrorCodeFromCLError(e)), "Could not create CommandQueue.");
        }

        return cmdQueue;
    }

    /**
     * Creates an input/output buffer to be used with a WebCL kernel
     *
     * @function XML3D.webcl~createBuffer
     * @param {int} size
     * @param {string} type
     * @param {IWebCLContext} clCtx
     * @returns {IWebCLMemoryObject|Boolean}
     */

    function createBuffer(size, type, clCtx) {
        clCtx = clCtx || ctx;

        if (!size) {
            XML3D.debug.logError("WebCL API: createBuffer(): Buffer size was not defined.");
            return false;
        }else if (!isNumber(size) || size < 0) {
            XML3D.debug.logError("WebCL API: createBuffer(): Buffer size must be a positive number.");
            return false;
        }

        if (!type) {
            XML3D.debug.logError("WebCL API: createBuffer(): Buffer type was not defined.");
            return false;
        }

        if(!clCtx) {
            XML3D.debug.logError("WebCL API: createBuffer(): clCtx was not defined.");
            return false;
        }

        try {
            if (type === "r") {
                return clCtx.createBuffer(webcl.MEM_READ_ONLY, size);
            } else if (type === "w") {
                return clCtx.createBuffer(webcl.MEM_WRITE_ONLY, size);
            } else if (type === "rw") {
                return clCtx.createBuffer(webcl.MEM_READ_WRITE, size);
            } else {
                XML3D.debug.logError("WebCL API: createBuffer(): Unknown buffer type:", type);
                return false;
            }
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }
            throw new WebCLError(getCLErrorName(errCode), "Could not create a WebCL buffer.");
        }
    }

    /**
     * Creates an instance of KernelManager.
     *
     * @name KernelManager
     * @constructor XML3D.webcl~KernelManager
     */

    var KernelManager = function (clCtx, deviceArr) {
        var kernels = {};

        return {

            /**
             * Creates and builds a WebCL program from a code string and creates a WebCL kernel from the program.
             *
             * @function KernelManager~register
             * @param {string} name
             * @param {string} codeStr
             */

            register: function (name, codeStr) {
                if (kernels.hasOwnProperty(name)) {
                    XML3D.debug.logWarning("WebCL API: kernels.register(): Kernel with a same name is already defined.");
                    return false;
                }

                if (typeof name !== "string") {
                    XML3D.debug.logError("WebCL API: kernels.register(): Kernel name was not defined or was not type of String.");
                    return false;
                }

                if (typeof codeStr !== "string") {
                    XML3D.debug.logError("WebCL API: kernels.register(): Kernel code was not defined or was not type of String.");
                    return false;
                }

                var program, kernel;

                program = createProgram(codeStr, clCtx);

                buildProgram(program, deviceArr);

                if (program) {
                    kernel = createKernel(program, name);
                }

                if (kernel) {
                    kernels[name] = kernel;

                    return true;
                }

                return false;

            },

            /**
             * Deallocates and unregisters a kernel.
             *
             * @function KernelManager~unRegister
             * @param {string} name
             */

            unRegister: function (name) {
                if (kernels.hasOwnProperty(name)) {
                    try {
                        kernels[name].release();
                    } catch (e) {
                        var errCode = getErrorCodeFromCLError(e);

                        if (!errCode) {
                            throw e;
                        }

                        throw new WebCLError(getCLErrorName(errCode), "Could not release kernel resources.");
                    }
                    delete kernels[name];

                    return true;
                }

                return false;
            },

            /**
             * Gets a kernel of a specified name.
             *
             * @function KernelManager~getKernel
             * @param {string} name
             * @returns {IWebCLKernel | Boolean}
             */

            getKernel: function (name) {
                if (typeof name !== "string") {
                    return false;
                }

                if (kernels.hasOwnProperty(name)) {
                    return kernels[name];
                }

                return false;
            },

            /**
             * Sets arguments of a specified kernel.
             * The first argument of this function is a registered kernel name, other arguments are the kernel arguments respectively.
             *
             * @function KernelManager~setArgs
             * @param {IWebCLKernel} kernel WebCL kernel
             * @param {...*} args Kernel arguments in the same order as defined in the kernel code
             * @returns {boolean}
             */

            setArgs: function () {
                var args = Array.prototype.slice.call(arguments),
                    kernel, inputArgs, nKernelArgs, i;

                if (args.length < 2) {
                    XML3D.debug.logWarning("WebCL API: setArgs(): No kernel arguments were defined.");
                    return false;
                }

                kernel = args[0];
                inputArgs = args.slice(1);

                if (!kernel) {
                    XML3D.debug.logWarning("WebCL API: setArgs(): WebCL kernel was not defined.");
                    return false;
                }

                nKernelArgs = kernel.getInfo(webcl.KERNEL_NUM_ARGS);

                if (inputArgs.length > nKernelArgs) {
                    XML3D.debug.logWarning("WebCL: setArgs: Input args amount > kernel program args amount! Ignoring extra arguments.");
                } else if (inputArgs.length < nKernelArgs) {
                    XML3D.debug.logError("WebCL: setArgs: Not enough arguments were given to WebCL kernel.");
                    return false;
                }

                XML3D.debug.logDebug("Args for kernel:", kernel.getInfo(webcl.KERNEL_FUNCTION_NAME));

                i = nKernelArgs;

                try {
                    while (i--) {
                        XML3D.debug.logDebug("Arg:", i, inputArgs[i]);
                        kernel.setArg(i, inputArgs[i]);
                    }
                } catch (e) {
                    var errCode = getErrorCodeFromCLError(e);

                    if (!errCode) {
                        throw e;
                    }
                    throw new WebCLError(getCLErrorName(errCode), "Could not set kernel arguments.");
                }

                return true;

            }
        };
    };

    /**
     * Checks if WebCL is available and attaches a context to the given object
     * @param webclObject the object that the context will be attached to
     * @returns {boolean}
     */
    function initWebCLPlatform(webclObject) {
        if (!isAvailable()) {
            return false;
        }

        var clPlatforms = getPlatforms();
        if (!clPlatforms || clPlatforms.length <= 0) {
            return false;
        }

        try {
            // Trying initially to use GPU (for the best performance). Using CPU as a fallback.
            var clDevices = getDevicesByType("GPU") || getDevicesByType("CPU");
            if (!clDevices) {
                return false;
            }
            var clCtx = createContext(clDevices);
            var cmdQueue = createCommandQueue(clDevices[0], clCtx);

            /**
             *  TODO: Maybe we should just store the cl-platform objects in C.cl so they are more easily available and
             *  to avoid long prototype chains. Or we could pass the graph context to each node of the graph.
             *  However, it would be good to allow each Graph object to have at least own context, cmdQueue and kernelManager.
             */
            webclObject.cl = {
                API: webcl,
                kernelManager: new KernelManager(clCtx, clDevices),
                platforms: clPlatforms,
                devices: clDevices,
                ctx: clCtx,
                cmdQueue: cmdQueue
            };
            XML3D.debug.logDebug("Successfully initialized WebCL platform.");
            return true;
        } catch (e) {
            return false;
        }
    }

    /**
     * API
     *
     * @namespace webcl
     * @memberOf XML3D
     */

    namespace['webcl'] = {
        "init": init,
        "createContext": createContext,
        "createProgram": createProgram,
        "buildProgram": buildProgram,
        "createKernel": createKernel,
        "createCommandQueue": createCommandQueue,
        "createBuffer": createBuffer,
        "getDefaultContext": getDefaultContext,
        "getPlatforms": getPlatforms,
        "getDevicesByType": getDevicesByType,
        "getContextDevices": getContextDevices,
        "getDevicePlatform": getDevicePlatform,

        /** @name XML3D.webcl~kernels */
        "kernels": new KernelManager(),
        "KernelManager": KernelManager,

        "hasWebCLNamespace": hasWebCLNamespace,
        "hasOpenCLDrivers": hasOpenCLDrivers,
        "isAvailable": isAvailable,
        "WebCLError": WebCLError,
        "getCLErrorName": getCLErrorName
    };

    initWebCLPlatform(namespace.webcl);
    window.XML3D.webcl = namespace.webcl;

}(module.exports));

},{}],186:[function(require,module,exports){
var assert = require("assert");

// Error Callbacks:
var c_errorCallbacks = [];

var c_listedCallbacks = [];
var c_listedCallbacksData = [];

module.exports = {

    registerErrorCallback: function (callback) {
        c_errorCallbacks.push(callback);
    },

    notifyError: function (message, node) {
        if (c_errorCallbacks.length > 0) {
            var i;
            for (i = 0; i < c_errorCallbacks.length; ++i) {
                c_errorCallbacks[i](message, node);
            }
        } else {
            // TODO: Do Default error printing
        }
    },

    /**
     *
     * @param {Object} ctor Constructor
     * @param {Object} parent Parent class
     * @param {Object=} methods Methods to add to the class
     * @returns {Object}
     */
    createClass: function (ctor, parent, methods) {
        methods = methods || {};
        if (parent) {
            /** @constructor */
            var F = function () {
            };
            F.prototype = parent.prototype;
            ctor.prototype = new F();
            ctor.prototype.constructor = ctor;
            ctor.superclass = parent.prototype;
        }
        for (var m in methods) {
            ctor.prototype[m] = methods[m];
        }
        return ctor;
    },

    extend: function (a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }
    },

    /**
     * Cluster internal notifications to avoid multiple notifications
     * of same type. Mainly for Requests and Results
     *
     * @param requestOrResult Request or Result
     * @param {RESULT_STATE} resultState
     * @private
     */
    _queueResultCallback: function (requestOrResult, resultState) {
        assert(resultState !== undefined);
        var index;
        if (( index = c_listedCallbacks.indexOf(requestOrResult)) == -1) {
            index = c_listedCallbacks.length;
            c_listedCallbacks.push(requestOrResult);
        }
        var prevData = c_listedCallbacksData[index];

        if (!prevData || prevData < resultState) {
            c_listedCallbacksData[index] = resultState;
        }
    },

    _flushResultCallbacks: function () {
        if (c_listedCallbacks.length) {
            var i;
            for (i = 0; i < c_listedCallbacks.length; ++i) {
                c_listedCallbacks[i]._onPostponedResultChanged(c_listedCallbacksData[i]);
            }
            c_listedCallbacks = [];
            c_listedCallbacksData = [];
        }
    }
};







},{"assert":11}],187:[function(require,module,exports){
var C = {};

C.EPSILON = 0.000001;

/**
 * Type of DataEntry
 * @enum
 */
C.DATA_TYPE = {
    UNKNOWN: 0,
    FLOAT: 1,
    FLOAT2: 2,
    FLOAT3: 3,
    FLOAT4: 4,
    FLOAT3X3: 5,
    FLOAT4X4: 10,
    INT: 20,
    INT4: 21,
    BOOL: 30,
    TEXTURE: 40,
    STRING: 45,
    BYTE: 50,
    UBYTE: 60,
    fromString: function(str) {
        if (!str || !str.toUpperCase) {
            return;
        }
        return this[str.toUpperCase()];
    }
};

C.DATA_TYPE_MAP = {
    'float': C.DATA_TYPE.FLOAT,
    'float2': C.DATA_TYPE.FLOAT2,
    'float3': C.DATA_TYPE.FLOAT3,
    'float4': C.DATA_TYPE.FLOAT4,
    'float3x3': C.DATA_TYPE.FLOAT3X3,
    'float4x4': C.DATA_TYPE.FLOAT4X4,
    'int': C.DATA_TYPE.INT,
    'int4': C.DATA_TYPE.INT4,
    'bool': C.DATA_TYPE.BOOL,
    'texture': C.DATA_TYPE.TEXTURE,
    'string' : C.DATA_TYPE.STRING,
    'byte': C.DATA_TYPE.BYTE,
    'ubyte': C.DATA_TYPE.UBYTE
};

// Values are chosen to be in line with DATA_TYPE
C.TEXTURE_TYPE = {
    UNKNOWN: 0, FLOAT: 1, UBYTE: 60, USHORT_5_6_5: 70, USHORT_4_4_4_4: 71, USHORT_5_5_5_1: 72
};

C.TEXTURE_FORMAT = {
    UNKNOWN: 0, ALPHA: 100, RGB: 101, RGBA: 102, LUMINANCE: 103, LUMINANCE_ALPHA: 104
};

C.DATA_TYPE_TUPLE_SIZE = {};
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT] = 1;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT2] = 2;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT3] = 3;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT4] = 4;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT3X3] = 9;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT4X4] = 16;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.INT] = 1;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.INT4] = 4;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.BOOL] = 1;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.TEXTURE] = 1;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.STRING] = 1;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.BYTE] = 1;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.UBYTE] = 1;

C.TYPED_ARRAY_MAP = {};
C.TYPED_ARRAY_MAP[C.DATA_TYPE.FLOAT] = Float32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.FLOAT2] = Float32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.FLOAT3] = Float32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.FLOAT4] = Float32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.FLOAT4X4] = Float32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.INT] = Int32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.INT4] = Int32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.BOOL] = Int8Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.BYTE] = Int8Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.UBYTE] = Uint8Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.STRING] = Array;

// texture formats
// float and ubyte are mapped to DATA_TYPE values above
C.TYPED_ARRAY_MAP[C.TEXTURE_TYPE.USHORT_4_4_4_4] = Uint16Array;
C.TYPED_ARRAY_MAP[C.TEXTURE_TYPE.USHORT_5_6_5] = Uint16Array;
C.TYPED_ARRAY_MAP[C.TEXTURE_TYPE.USHORT_5_5_5_1] = Uint16Array;

C.TEXTURE_FORMAT_TUPLE_SIZE = {};
C.TEXTURE_FORMAT_TUPLE_SIZE[C.TEXTURE_FORMAT.ALPHA] = 1;
C.TEXTURE_FORMAT_TUPLE_SIZE[C.TEXTURE_FORMAT.RGB] = 3;
C.TEXTURE_FORMAT_TUPLE_SIZE[C.TEXTURE_FORMAT.RGBA] = 4;
C.TEXTURE_FORMAT_TUPLE_SIZE[C.TEXTURE_FORMAT.LUMINANCE] = 1;
C.TEXTURE_FORMAT_TUPLE_SIZE[C.TEXTURE_FORMAT.LUMINANCE_ALPHA] = 2;

C.getTypeName = function (type) {
    var i;
    for (i in C.DATA_TYPE_MAP) {
        if (C.DATA_TYPE_MAP[i] === type) {
            return i;
        }
    }
};

/**
 * @enum {number}
 */
C.TEX_FILTER_TYPE = {
    NEAREST: 0x2600, LINEAR: 0x2601, MIPMAP_NEAREST: 0x2700, MIPMAP_LINEAR: 0x2701

};
/**
 * @enum {number}
 */
C.TEX_WRAP_TYPE = {
    CLAMP: 0x812F, REPEAT: 0x2901
};
/**
 * @enum {number}
 */
C.TEX_TYPE = {
    TEXTURE_2D: 0x0DE1
};

C.SHADER_CONSTANT_KEY = {
    WORLD_TRANSFORM: 1,
    VIEW_TRANSFORM: 2,
    SCREEN_TRANSFORM: 3,
    WORLD_TRANSFORM_NORMAL: 4,
    VIEW_TRANSFORM_NORMAL: 5,
    SCREEN_TRANSFORM_NORMAL: 6,
    OBJECT_ID: 7
};

C.VS_ATTRIB_TRANSFORM = {
    NONE: 0, VIEW_POINT: 1, WORLD_POINT: 2, VIEW_NORMAL: 3, WORLD_NORMAL: 4
};


/**
 * Filter Type of DataNode
 * KEEP - Keep only the provided names
 * REMOVE - Remove provided names (ignores name mapping)
 * RENAME - Only apply name mapping
 * @enum
 */
C.DATA_FILTER_TYPE = {
    NONE: 0, RENAME: 1, KEEP: 2, REMOVE: 3
};


/**
 * TODO: Maybe merge this structure with RESULT_STATE to avoid back and forth conversion within notification chain
 * @enum {number}
 */
C.DATA_ENTRY_STATE = {
    CHANGED_VALUE: 1,
    CHANGED_NEW: 2,
    LOAD_START: 3,
    LOAD_END: 4,
    CHANGED_SIZE: 5,
    CHANGED_REMOVED: 6, // Not just the size changed, but also qualifier
    // if we have 0, 1 or many tuples in value
    CHANGED_SIZE_TYPE: 7
};

/** TODO: Merge with C.PLATFORM? **/
C.RESULT_TYPE = {
    COMPUTE: 0, VS: 1
};


/**
 * Type of Modification, used internally only
 * Ordered by importance.
 * @enum
 */
C.RESULT_STATE = {
    NONE: 0, CHANGED_DATA_VALUE: 1, CHANGED_DATA_SIZE: 2, CHANGED_STRUCTURE: 3, // TODO: Felix: Still required?
    IMAGE_LOAD_START: 4, IMAGE_LOAD_END: 5
};


/**
 * Type of Sequence access - used by operators
 * @enum
 */
C.SEQUENCE = {
    NO_ACCESS: 0, PREV_BUFFER: 1, NEXT_BUFFER: 2, LINEAR_WEIGHT: 3
};


C.ITERATION_TYPE = {
    NULL: 0, ONE: 1, MANY: 2
};

/**
 * Type of Information Extraction - used by operators
 * @private
 * @enum
 */
//TODO: This seems to be unused, is it still needed?
C.EXTRACT = {
    NO_EXTRAC: 0, TEX_WIDTH: 1, TEX_HEIGHT: 2
};

C.ORIGIN = {
    CHILD: 1, COMPUTE: 2, PROTO: 3
};

/**
 * Types of platforms to perform computation on
 * @type {enum}
 */
C.PLATFORM = {
    JAVASCRIPT: 0, GLSL: 1, CL: 2, ASYNC: 3
};

/**
 * Possible states of a ProcessNode
 * @type {enum}
 */
C.PROCESS_STATE = {
    MODIFIED: 0, // We don't know (TODO Felix: Find out!)
    LOADING: 1, // Something still loading (blocked)
    INVALID: 3, // Input is invalid (might happen even after operator selection - e.g. because of empty array output etc.)
    UNPROCESSED: 4, // Process node is dirty
    PROCESSED: 5 // All data is up-to-date
};

//window.Xflow.PLATFORM = C.PLATFORM;

module.exports = C;

},{}],188:[function(require,module,exports){
var Base = require("../base.js");
var C = require("./constants.js");
var assign = require('lodash.assign');
require("../../utils/array.js");

/**
 * Content of this file:
 * All Code for handling data entries connected to Xflow including:
 *  - BufferEntries: Typed value buffers (e.g float3 buffer, without name)
 *  - TextureEntries: e.g. images
 *
 *  This file also includes the DataChangeNotifier used to react to changes on Xflow data structures
 */

//----------------------------------------------------------------------------------------------------------------------
// SamplerConfig
//----------------------------------------------------------------------------------------------------------------------

var SAMPLER_DEFAULTS = {
    minFilter : C.TEX_FILTER_TYPE.LINEAR,
    magFilter : C.TEX_FILTER_TYPE.LINEAR,
    wrapS : C.TEX_WRAP_TYPE.CLAMP,
    wrapT : C.TEX_WRAP_TYPE.CLAMP,
    textureType : C.TEX_TYPE.TEXTURE_2D,
    flipY: true,
    anisotropy : 1, // number of max samples for anisotropic filtering
    generateMipMap : 0
};

/**
 * SamplerConfig is used to define sampler properties of a TextureEntry or ImageDataTextureEntry
 * @constructor
 */
var SamplerConfig = function(){
    this.setDefaults();
};

SamplerConfig.prototype.setDefaults = function() {
    assign(this, SAMPLER_DEFAULTS);
};

SamplerConfig.prototype.set = function(other) {
    assign(this, other);
};


//----------------------------------------------------------------------------------------------------------------------
// DataEntry
//----------------------------------------------------------------------------------------------------------------------


/**
 * The abstract base class for all DataEntries connected to an xflow graph.
 * @abstract
 * @param {C.DATA_TYPE} type Type of DataEntry
 */
var DataEntry = function(type){
    this._type = type;
    /** @type {Array.<Function(DataEntry, C.DATA_ENTRY_STATE)>} **/
    this._listeners = [];
    /** Add related custom data (e.g. WebGL buffers) **/
    this.userData = {};
};

Object.defineProperty(DataEntry.prototype, "type", {
    set: function(){
        throw new Error("type is read-only");
    },
    /** @return {C.DATA_TYPE} */
    get: function(){ return this._type; }
});

/**
 * @param {function(DataEntry, C.DATA_ENTRY_STATE)} callback
 */
DataEntry.prototype.addListener = function(callback){
    this._listeners.push(callback);
};

/**
 * @param {function(DataEntry, C.DATA_ENTRY_STATE)} callback
 */
DataEntry.prototype.removeListener = function(callback){
    Array.erase(this._listeners, callback);
};

/**
 */
DataEntry.prototype._notifyChanged = function(){
    notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_VALUE);
};

//----------------------------------------------------------------------------------------------------------------------
// BufferEntry
//----------------------------------------------------------------------------------------------------------------------

/**
 * A typed value buffer basically linking to a typed array.
 * @constructor
 * @extends {DataEntry}
 * @param {C.DATA_TYPE} type
 * @param {Object} value A typed array
 */
var BufferEntry = function(type, value){
    DataEntry.call(this, type);
    this._value = value;
    notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_NEW);
};
Base.createClass(BufferEntry, DataEntry);


/**
 *  Set value of entry. Triggers notification chain
 *  @param {Object} v Value to set (has to be a TypedArray)
 */
BufferEntry.prototype.setValue = function(v){
    this._setValue(v);
    Base._flushResultCallbacks();
};

/**
 * Are there no, one or many values?
 * @param size
 * @param tupleSize
 * @returns {number}
 */
function getSizeType(size, tupleSize){
    if(size >= tupleSize*2)
        return 2;
    else if(size >= tupleSize)
        return 1;
    else
        return 0;
}

BufferEntry.prototype._setValue = function(v){
    var oldSize = (this._value ? this._value.length : 0), newSize = (v ? v.length : 0), tupleSize = this.getTupleSize();
    var notification;
    if(getSizeType(oldSize, tupleSize) != getSizeType(newSize, tupleSize))
        notification = C.DATA_ENTRY_STATE.CHANGED_SIZE_TYPE;
    else if(oldSize != newSize){
        notification = C.DATA_ENTRY_STATE.CHANGED_SIZE;
    }
    else{
        notification = C.DATA_ENTRY_STATE.CHANGED_VALUE;
    }
    this._value = v;
    notifyListeners(this, notification);
};

/** @return {Object} */
BufferEntry.prototype.getValue = function(){
    return this._value;
};

/**
 * Returns the buffer length
 * @return {Object}
 */
BufferEntry.prototype.getLength = function(){
    return this._value ? this._value.length : 0;
};

/**
 * Returns tuple size (e.g 1, 2, 3, 4, 16)
 * @returns {number}
 */
BufferEntry.prototype.getTupleSize = function() {
    return C.DATA_TYPE_TUPLE_SIZE[this._type];
};

/**
 * Return tuple count
 * @return {number}
 */
BufferEntry.prototype.getIterateCount = function(){
    return this.getLength() / this.getTupleSize();
};

/**
 * Is value not set or the length of the buffer 0
 * @returns {boolean}
 */
BufferEntry.prototype.isEmpty = function(){
    return !this._value || !this.getLength();
};


//----------------------------------------------------------------------------------------------------------------------
// TextureEntry
//----------------------------------------------------------------------------------------------------------------------

function TexelSource(sourceOrWidth, height, format, type) {
    if (typeof sourceOrWidth === "object") {
        if (sourceOrWidth.nodeName) {
            var nodeName = sourceOrWidth.nodeName.toLowerCase();
            if (nodeName === "video" && (typeof sourceOrWidth.complete === "undefined")) {
                Object.defineProperties(sourceOrWidth, {
                    width: {
                        get: function () {
                            return this.videoWidth;
                        }
                    },
                    height: {
                        get: function () {
                            return this.videoHeight;
                        }
                    },
                    complete: {
                        get: function () {
                            return !(this.readyState == 0 || this.videoWidth <= 0 || this.videoHeight <= 0);
                        }
                    }
                });
            }
            sourceOrWidth.texelFormat = C.TEXTURE_FORMAT.RGBA;
            sourceOrWidth.texelType = C.TEXTURE_TYPE.UBYTE;
        }
        //assume source is a image data like object
        this._source = sourceOrWidth;
    } else {
        format = format || C.TEXTURE_FORMAT.RGBA;
        type =  type || C.TEXTURE_TYPE.UBYTE;
        //create a new texel source backed by type array
        this._source = {
            width: sourceOrWidth,
            height: height,
            texelFormat: format,
            texelType: type,
            data: new C.TYPED_ARRAY_MAP[type](sourceOrWidth * height * C.TEXTURE_FORMAT_TUPLE_SIZE[format])
        }
    }
}

Object.defineProperties(TexelSource.prototype, {
    imageData: {
        get: function () {
            if (this._source instanceof HTMLElement) {
                var canvas = document.createElement("canvas");
                canvas.width = this._source.width;
                canvas.height = this._source.height;
                var ctx = canvas.getContext("2d");
                ctx.drawImage(this._source, 0, 0);
                var source = ctx.getImageData(0, 0, this._source.width, this._source.height);
                source.texelFormat = this._source.texelFormat;
                source.texelType = this._source.texelType;
                this._source = source;
            }
            return this._source;
        }
    },
    // TODO this is very confusing. asGLTextureData is texelsource.source
    glTextureData: {
        get: function () {
            return this._source;
        }
    },
    complete: {
        get: function () {
            return typeof this._source.complete === "undefined" ? true : this._source.complete;
        }
    },
    width: {
        get: function () {
            return this._source ? this._source.width : -1;
        }
    },
    height: {
        get: function () {
            return this._source ? this._source.height : -1;
        }
    },
    texelFormat: {
        get: function () {
            return this._source ? this._source.texelFormat: C.TEXTURE_FORMAT.UNKNOWN;
        }
    },
    texelType: {
        get: function () {
            return this._source ? this._source.texelType: C.TEXTURE_TYPE.UNKNOWN;
        }
    }
});

/**
 * A data entry for a texture.
 * Note: each TextureEntry includes a samplerConfig.
 * @constructor
 * @extends {DataEntry}
 * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} source //TODO: Which kinds are supported?
 */
var TextureEntry = function(source){
    DataEntry.call(this, C.DATA_TYPE.TEXTURE);
    this._samplerConfig = new SamplerConfig();
    this._loading = false;
    this.setImage(source);

    notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_NEW);
};

Base.createClass(TextureEntry, DataEntry);

Object.defineProperties(TextureEntry.prototype, {
    width: {
        get: function () {
            return this._source ? this._source.width : -1;
        }
    },
    height: {
        get: function () {
            return this._source ? this._source.height : -1;
        }
    },
    texelFormat: {
        get: function () {
            return this._source ? this._source.texelFormat: C.TEXTURE_FORMAT.UNKNOWN;
        }
    },
    texelType: {
        get: function () {
            return this._source ? this._source.texelType: C.TEXTURE_TYPE.UNKNOWN;
        }
    }
});

TextureEntry.prototype.isLoading = function() {
    if (!this._source)
        return false;

    return !this._source.complete;
};

/**
 * @private
 */
TextureEntry.prototype._createImage = function(width, height, format, type, samplerConfig) {
    if (!this._source || this.width != width || this.height != height || this.format != format || this.type != type) {
        var source = new TexelSource(width, height, format, type);

        if (!samplerConfig) {
            samplerConfig = new SamplerConfig();
            samplerConfig.setDefaults();
        }

        this._samplerConfig.set(samplerConfig);
        this._setImage(source);
    } else {
        this._notifyChanged();
    }

    return this._source;
};

/**
 * Set image source of a Texture Entry
 * TODO: This is called even if image is just loaded (on XML3D side). Add a notifyImageLoaded method could
 * be helpful
 *
 * @param {HTMLImageElement|HTMLVideoElement|TexelSource|null} element
 * @param {boolean?} forceLoadCallback trigger load callback if data changes
 */
TextureEntry.prototype.setImage = function (element, forceLoadCallback) {
    this._setImage(element, forceLoadCallback);
    Base._flushResultCallbacks();
};

TextureEntry.prototype._setImage = function (element, forceLoadCallback) {
    if (!element)
        this._setSource(null, forceLoadCallback);
    else if (element instanceof TexelSource)
        this._setSource(element, forceLoadCallback);
    else
        this._setSource(new TexelSource(element), forceLoadCallback);
};

TextureEntry.prototype._setSource = function(s, forceLoadCallback) {
    var prevLoading = this.isLoading();
    this._source = s;
    var loading = this.isLoading();
    if(forceLoadCallback && !loading && !prevLoading){
        notifyListeners(this, C.DATA_ENTRY_STATE.LOAD_START);
        notifyListeners(this, C.DATA_ENTRY_STATE.LOAD_END);
    }
    else if(loading){
        this._loading = true;
        notifyListeners(this, C.DATA_ENTRY_STATE.LOAD_START);
    }
    else if(this._loading){
        this._loading = false;
        notifyListeners(this, C.DATA_ENTRY_STATE.LOAD_END);
    }
    else
        notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_VALUE);
};

TextureEntry.prototype.asGLTextureValue = function () {
    return this._source && this._source.glTextureData;
};

/** @return {ImageData} */
TextureEntry.prototype.getValue = function() {
    if (!this._source)
        return null;
    if (!this.isLoading())
        return this._source.imageData;
    else
        return null;
};

/** @return {SamplerConfig} */
TextureEntry.prototype.getSamplerConfig = function(){
    return this._samplerConfig;
};

/** @return {number} */
TextureEntry.prototype.getLength = function(){
    return 1;
};
TextureEntry.prototype.isEmpty = function(){
    return false;
};

/** @return {number} */
TextureEntry.prototype.getIterateCount = function() {
    return 1;
};

//----------------------------------------------------------------------------------------------------------------------
// ImageDataTextureEntry
//----------------------------------------------------------------------------------------------------------------------

/**
 * Same as TextureEntry, only based on imageData.
 * This class is used for xflow running inside Web Workers (which don't support HTML images)
 * @param imageData
 * @extends{DataEntry}
 * @constructor
 */
var ImageDataTextureEntry = function(imageData){
    DataEntry.call(this, C.DATA_TYPE.TEXTURE);
    this._samplerConfig = new SamplerConfig();
    this._imageData = null;
    this._texelFormat = C.TEXTURE_FORMAT.RGBA;
    this._texelType = C.TEXTURE_TYPE.UBYTE;

    this._updateImageData(imageData);

    notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_NEW);
};

Base.createClass(ImageDataTextureEntry, DataEntry);

Object.defineProperties(ImageDataTextureEntry.prototype, {
    width: {
        get: function () {
            return this._imageData ? this._imageData.width : -1;
        }
    },
    height: {
        get: function () {
            return this._imageData ? this._imageData.height : -1;
        }
    },
    texelFormat: {
        get: function () {
            return this._texelFormat;
        }
    },
    texelType: {
        get: function () {
            return this._texelType;
        }
    }
});



ImageDataTextureEntry.prototype.isLoading = function() {
    return !this._imageData;
};

ImageDataTextureEntry.prototype._updateImageData = function(imageData) {
    this._texelFormat = C.TEXTURE_FORMAT.RGBA;
    this._texelType = C.TEXTURE_TYPE.UBYTE;
    this._imageData = imageData;
};

/** Create new image
 * TODO: Jan: Write source documentation
 * @param width
 * @param height
 * @param format
 * @param type
 * @param samplerConfig
 * @return {HTMLImageElement|HTMLCanvasElement}
 */
ImageDataTextureEntry.prototype._createImage = function(width, height, format, type, samplerConfig) {
    if (!this._imageData || this.getWidth() != width || this.getHeight() != height || this._format != format || this._type != type) {
        if (!width || !height)
            throw new Error("Width or height is not specified");
        this._texelFormat = format;
        this._texelType = type;
        if (!samplerConfig) {
            samplerConfig = new SamplerConfig();
            samplerConfig.setDefaults();
        }
        this._samplerConfig.set(samplerConfig);

        /**
         * @type {{width: *, height: *, data: null|ArrayBufferView}}
         */
        var imageData = {
            width: width,
            height: height,
            data: null
        };
        if(type == C.TEXTURE_TYPE.FLOAT){
            imageData.data = new Float32Array(width*height*4);
        }
        else {
            // FIXME: We should allocate Uint8ClampedArray here instead
            // But Uint8ClampedArray can't be allocated in Chrome inside a Web Worker
            // See bug: http://code.google.com/p/chromium/issues/detail?id=176479
            // As a work around, we allocate Int16Array which results in correct clamping outside of web worker
            if(Uint8Array == Uint8ClampedArray)
                imageData.data = new Int16Array(width*height*4);
            else
                imageData.data = new Uint8ClampedArray(width*height*4);
        }
        this._imageData = imageData;
    }
    this._notifyChanged();
};

/** @param {Object} v */
ImageDataTextureEntry.prototype.setImageData = function(v) {
    this._updateImageData(v);
    notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_VALUE);
    Base._flushResultCallbacks();
};

ImageDataTextureEntry.prototype.getWidth = function() {
    return this._imageData && this._imageData.width || 0;
};

ImageDataTextureEntry.prototype.getHeight = function() {
    return this._imageData && this._imageData.height || 0;
};

/** @return {ImageData} */
ImageDataTextureEntry.prototype.getValue = function() {
    return this._imageData;
};

/** @return {SamplerConfig} */
ImageDataTextureEntry.prototype.getSamplerConfig = function(){
    return this._samplerConfig;
};

/** @return {number} */
ImageDataTextureEntry.prototype.getLength = function(){
    return 1;
};
ImageDataTextureEntry.prototype.isEmpty = function(){
    return false;
};


/** @return {number} */
ImageDataTextureEntry.prototype.getIterateCount = function() {
    return 1;
};

//----------------------------------------------------------------------------------------------------------------------
// DataChangeNotifier
//----------------------------------------------------------------------------------------------------------------------


/**
 * Used to listen to modifications of any DataEntry connected to an Xflow graph.
 * @constructor
 */
var DataChangeNotifier = {
    _listeners: []
};

/**
 * @param {function(DataEntry, C.DATA_ENTRY_STATE)} callback
 */
DataChangeNotifier.addListener = function(callback){
    this._listeners.push(callback);
};

/**
 * @param {function(DataEntry, C.DATA_ENTRY_STATE)} callback
 */
DataChangeNotifier.removeListener = function(callback){
    Array.erase(this._listeners, callback);
};

/**
 * @param {DataEntry} dataEntry
 * @param {C.DATA_ENTRY_STATE} notification
 */
function notifyListeners(dataEntry, notification){
    var i;
    // Global notifications
    for(i = 0; i < DataChangeNotifier._listeners.length; ++i){
        DataChangeNotifier._listeners[i](dataEntry, notification);
    }
    // Internal and external listeners
    for(i = 0; i < dataEntry._listeners.length; ++i){
        dataEntry._listeners[i](dataEntry, notification);
    }
}

module.exports = {
    DataEntry: DataEntry,
    BufferEntry: BufferEntry,
    TextureEntry: TextureEntry,
    ImageDataTextureEntry: ImageDataTextureEntry,
    SamplerConfig: SamplerConfig,
    DataChangeNotifier: DataChangeNotifier
};

},{"../../utils/array.js":178,"../base.js":186,"./constants.js":187,"lodash.assign":17}],189:[function(require,module,exports){
var C = require("./constants.js");
var Mapping = require("./../processing/mapping.js");
require("../../utils/array.js");

var Base = require("../base.js");
var ChannelNode = require("../processing/channel-node.js").ChannelNode;
var Utils = require("../utils/utils.js");

//----------------------------------------------------------------------------------------------------------------------
// GraphNode
//----------------------------------------------------------------------------------------------------------------------

/**
 * Base class for other graph nodes
 * @constructor
 * @abstract
 * @param {Graph} graph Reference to parent graph
 */
var GraphNode = function(){
    /**
     * All nodes that add a dependency to this node
     * @type array<GraphNode>
     **/
    this._parents = [];
};


//----------------------------------------------------------------------------------------------------------------------
// InputNode
//----------------------------------------------------------------------------------------------------------------------

/**
 * An InputNode include an DataEntry, a name and other information
 * This class mirrors XML3D elements such as <float3>, <int> or <texture>
 *
 * @constructor
 * @param {Graph} graph
 * @extends {GraphNode}
 */
var InputNode = function(){
    GraphNode.call(this);
    /**
     * Name of the input node
     * @type {string}
     * @private
     */
    this._name = "";
    /**
     * Sequence key
     * @type {number}
     * @private
     */
    this._key = 0;
    /**
     * DataEntry node that holds the value
     * @type {DataEntry}
     */
    this._data = null;
    /**
     * If this nodes is a parameter within a <dataflow>
     * this is set to the name of the parameter, otherwise null
     * @type {null|String}
     * @private
     */
    this._paramName = null;

    /**
     * Experimental! Apply different override logic in order
     * to propagate global parameters to the source of the graph
     * Could be used for instance for LOD concepts, where the
     * renderer propagates the distance along the graph
     * @type {boolean}
     * @private
     */
    this._paramGlobal = false;

    /**
     *  Cache listener for DataEntry
     *  @see {InputNode.onDataChange}
     */
    this._dataListener = this.onDataChange.bind(this);
};
Base.createClass(InputNode, GraphNode);

/**
 * Propagate events from DataEntry to parent nodes
 * @param {Object} newValue
 * @param {C.DATA_ENTRY_STATE} notification
 */
InputNode.prototype.onDataChange = function(newValue, notification) {
    var downNote;
    switch(notification){
        case C.DATA_ENTRY_STATE.CHANGED_VALUE: downNote = C.RESULT_STATE.CHANGED_DATA_VALUE; break;
        case C.DATA_ENTRY_STATE.LOAD_START: downNote = C.RESULT_STATE.IMAGE_LOAD_START; break;
        case C.DATA_ENTRY_STATE.LOAD_END: downNote = C.RESULT_STATE.IMAGE_LOAD_END; break;
        case C.DATA_ENTRY_STATE.CHANGED_SIZE_TYPE: downNote = C.RESULT_STATE.CHANGED_STRUCTURE; break;
        case C.DATA_ENTRY_STATE.CHANGED_SIZE: downNote = C.RESULT_STATE.CHANGED_DATA_SIZE; break;
        default: downNote = C.RESULT_STATE.CHANGED_DATA_SIZE; break;
    }
    notifyParentsOnChanged(this,downNote);
};

Object.defineProperty(InputNode.prototype, "name", {
    /** @param {string} v */
    set: function(v){
        this._name = v;
        notifyParentsOnChanged(this, C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {string} */
    get: function(){ return this._name; }
});

Object.defineProperty(InputNode.prototype, "key", {
    /** @param {number} v */
    set: function(v){
        this._key = v;
        notifyParentsOnChanged(this, C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {number} */
    get: function(){ return this._key; }
});

Object.defineProperty(InputNode.prototype, "paramName", {
    /** @param {string} v */
    set: function(v){
        this._paramName = v;
        notifyParentsOnChanged(this, C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {string} */
    get: function(){ return this._paramName; }
});

Object.defineProperty(InputNode.prototype, "paramGlobal", {
    /** @param {boolean} v */
    set: function(v){
        this._paramGlobal = v;
        notifyParentsOnChanged(this, C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {boolean} */
    get: function(){ return this._paramGlobal; }
});

Object.defineProperty(InputNode.prototype, "data", {
    /** @param {DataEntry} dataEntry */
    set: function(dataEntry){
        var prevDataLoading = false;
        if(this._data) {
            prevDataLoading = this._data._loading;
            this._data.removeListener(this._dataListener);
        }
        this._data = dataEntry;
        if(this._data) {
            this._data.addListener(this._dataListener);
        }
        if(prevDataLoading != this._data._loading){
            notifyParentsOnChanged(this, this._data._loading ? C.RESULT_STATE.IMAGE_LOAD_START :
                C.RESULT_STATE.IMAGE_LOAD_END);
        }
        Base._flushResultCallbacks();
    },
    /** @return {DataEntry} */
    get: function(){ return this._data; }
});

/**
 * Getter for local parameter name, returns null if this is a global
 * parameter
 *
 * @returns {null|String}
 * @private
 */
InputNode.prototype._getParamNames = function(){
    return this._paramGlobal ? null : this._paramName;
};

/**
 * Getter for global parameter name, returns null if this is not a global
 * parameter
 *
 * @returns {null|String}
 * @private
 */
InputNode.prototype._getGlobalParamNames = function(){
    return this._paramGlobal ? this._paramName : null;
};

//----------------------------------------------------------------------------------------------------------------------
// DataNode
//----------------------------------------------------------------------------------------------------------------------
var c_xflowNodeId = 0;
function getXflowNodeId(){
    return ++c_xflowNodeId;
}

/**
 * The DataNode is the central structure of an Xflow Graph.
 * It is used to build a data composition graph as well as a data flow.
 * It mirror the <data> element of XML3D
 *
 * @constructor
 * @param {Graph} graph Context graph
 * @param {boolean} isDataFlow is this node a dataflow
 * @extends {GraphNode}
 */
var DataNode = function(isDataFlow){
    GraphNode.call(this);

    /**
     * Marker, if this data node is expecting data. Xflow
     * is not monitoring any load events. This must be set
     * from external
     * @type {boolean}
     */
    this._loading = false;

    /**
     * Experimental! Priority. How important is this data?
     * 0: Very important
     * @type {number}
     */
    this._loadLevel = 0;

    /**
     * Used for loading events: If progress level
     * reaches infinity, loading events are triggered
     * @type {Number}
     */
    this._progressLevel = Infinity;

    /**
     * Globally unique id
     */
    this.id = getXflowNodeId();

    /**
     * Is this node a proto node
     * @type {boolean}
     */
    this._isProtoNode = isDataFlow;

    /**
     * Children. InputNodes and DataNodes (as found in DOM)
     * @type {Array}
     */
    this._children = [];

    /**
     * The DataNode that has been reference via src
     * @type {DataNode}
     */
    this._sourceNode = null;

    /**
     * Field to attach custom data
     * @type {null|Object}
     */
    this._userData = null;

    /**
     * The filter type of this node (keep, rename, remove ...)
     * @type {DATA_FILTER_TYPE}
     */
    this._filterType = C.DATA_FILTER_TYPE.NONE;

    /**
     * Define the mapping
     * @type {Mapping.Mapping}
     */
    this._filterMapping = null;

    /**
     * String identifier for operator
     * TODO: Operator class
     * @type {string|Object}
     */
    this._computeOperator = "";

    /**
     * True, if compute is a dataflow reference
     * @type {boolean}
     */
    this._computeUsesDataflow = false;

    /**
     * Mapping for input of operator,
     * e.g. (position, texcoord) or ({position: pos, texcoord: uv})
     * @type {Mapping}
     */
    this._computeInputMapping = null;

    /**
     * Mapping for output of operator,
     * e.g. (position, texcoord) = ... or {position: pos, texcoord: uv} = ...
     * @type {Mapping}
     */
    this._computeOutputMapping = null;

    /**
     * If dataflow node has been resolved, this
     * entry is set
     * @type {DataNode}
     */
    this._dataflowNode = null;

    /**
     * Internal (optimized) version of this data node
     * @type {ChannelNode}
     */
    this._channelNode = new ChannelNode(this);

    /**
     * Map of cached channel nodes for dataflow instances with varying
     * input arguments (specialized nodes)
     * TODO: Use WeakMap?
     * @type {Object.<string, ChannelNode>}
     */
    this._substitutionNodes = {};

    /**
     * Cached version of local param names collected from
     * children
     * @type {Array.<string>}
     */
    this._paramNames = null;

    /**
     * Cached version of global param names collected from
     * children
     * @type {Array.<string>}
     */
    this._globalParamNames = null;

    /**
     * Platform, this data node should be executed on
     * TODO: This should be implicit, not explicit
     * @type {null}
     */
    this._platform = null;

    /**
     * Observers of the node's C.RESULT_STATE
     * @type {Array}
     */
    this._listeners = [];

    /**
     * Observers of the node's progress level
     * @type {Array}
     */
    this._loadListeners = [];

};
Base.createClass(DataNode, GraphNode);


Object.defineProperty(DataNode.prototype, "sourceNode", {
    /** @param {?DataNode} newSourceNode */
    set: function(newSourceNode){
        replaceNodeInHierarchy(this, "_sourceNode", newSourceNode);
        updateProgressLevel(this);
        this.notify(C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {?DataNode} */
    get: function(){ return this._sourceNode; }
});

Object.defineProperty(DataNode.prototype, "dataflowNode", {
    /** @param {?DataNode} newDataflowNode */
    set: function(newDataflowNode){
        if(newDataflowNode && !this._computeUsesDataflow) {
            throw new Error("Cannot set dataflowNode when compute doesn't use dataflow.");
        }
        replaceNodeInHierarchy(this, "_dataflowNode", newDataflowNode);
        updateProgressLevel(this);
        this.notify(C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {?DataNode} */
    get: function(){ return this._dataflowNode; }
});


Object.defineProperty(DataNode.prototype, "userData", {
    /** @param {?DataNode} v */
    set: function(v){
        this._userData = v;
    },
    /** @return {?DataNode} */
    get: function(){ return this._userData; }
});

/**
 * Set (from external) if more data is expected.
 * @param {boolean} loading
 */
DataNode.prototype.setLoading = function(loading){
    if(this._loading != loading){
        this._loading = loading;
        this._channelNode.setStructureOutOfSync();
        this._channelNode.loading = loading;
        for (var sub in this._substitutionNodes) {
            var subNode = this._substitutionNodes[sub];
            subNode.setStructureOutOfSync();
            subNode.loading = loading;
        }
        updateProgressLevel(this);
        Base._flushResultCallbacks();
    }
};

/**
 * Returns if this or any child node is loading
 * @returns {boolean}
 */
DataNode.prototype.isSubtreeLoading = function(){
    return this._progressLevel == 0;
};

/**
 * @returns {Number}
 */
DataNode.prototype.getProgressLevel = function(){
    return this._progressLevel;
};


Object.defineProperty(DataNode.prototype, "filterType", {
    /** @param {C.DATA_FILTER_TYPE} v */
    set: function(v){
        this._filterType = v;
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {C.DATA_FILTER_TYPE} */
    get: function(){ return this._filterType; }
});

Object.defineProperty(DataNode.prototype, "filterMapping", {
    /** @param {Mapping} v */
    set: function(v){
        swapMapping(this, "_filterMapping", v);
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {Mapping} */
    get: function(){ return this._filterMapping; }
});

Object.defineProperty(DataNode.prototype, "computeOperator", {
    /** @param {string} v */
    set: function(v){
        this._computeOperator = v;
        this._computeUsesDataflow = false;
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {string} */
    get: function(){ return this._computeUsesDataflow ? null : this._computeOperator; }
});

Object.defineProperty(DataNode.prototype, "computeDataflowUrl", {
    /** @param {string} v */
    set: function(v){
        this._computeOperator = v;
        this._computeUsesDataflow = true;
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {string} */
    get: function(){ return this._computeUsesDataflow ? this._computeOperator : null; }
});

Object.defineProperty(DataNode.prototype, "computeInputMapping", {
    /** @param {Mapping} v */
    set: function(v){
        swapMapping(this, "_computeInputMapping", v);
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {Mapping} */
    get: function(){ return this._computeInputMapping; }
});
Object.defineProperty(DataNode.prototype, "computeOutputMapping", {
    /** @param {Mapping} v */
    set: function(v){
        swapMapping(this, "_computeOutputMapping", v);
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {Mapping} */
    get: function(){ return this._computeOutputMapping; }
});

//noinspection JSUnusedGlobalSymbols
DataNode.prototype.isProtoNode = function(){
    return this._isProtoNode;
};

/**
 * @param {GraphNode} child
 */
DataNode.prototype.appendChild = function(child){
    this._children.push(child);
    addParent(this, child);
    updateProgressLevel(this);
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};
/**
 * @param {GraphNode} child
 */
DataNode.prototype.removeChild = function(child){
    Array.erase(this._children, child);
    removeParent(this, child);
    updateProgressLevel(this);
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

/**
 * @param {GraphNode} child
 * @param {GraphNode} beforeNode
 */
DataNode.prototype.insertBefore = function(child, beforeNode){
    var idx = this._children.indexOf(beforeNode);
    if(idx == -1)
        this._children.push(child);
    else
        this._children.splice(idx, 0, child);
    addParent(this, child);
    // TODO: Next three calls on all structural changes. Add Method
    updateProgressLevel(this);
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

/**
 * clear all references and remove children
 */
DataNode.prototype.clear = function(){
    for(var i =0; i < this._children.length; ++i){
        removeParent(this, this._children[i]);
    }
    this._children = [];
    this._dataflowNode && this._dataflowNode.removeParent(this);
    this._dataflowNode = null;
    this._channelNode.decreaseRef();
    clearSubstitutionNodes(this);
    updateProgressLevel(this);
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    this._listeners = [];
    delete this._userData;
    delete this._channelNode;
    delete this._dataflowNode;
    Base._flushResultCallbacks();
};

DataNode.prototype.removeParent = function(parent) {
    Array.erase(this._parents, parent);
    updateProgressLevel(this);
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

//noinspection JSUnusedGlobalSymbols
/**
 * Detach this DataNode from all connections, including source- and proto-node references
 */
DataNode.prototype.detachFromParents = function(){
    for(var i =0; i < this._parents.length; ++i){
        var parent = this._parents[i];
        if(parent._sourceNode == this)
            parent.sourceNode = null;
        else if(parent._dataflowNode == this){
            parent.dataflowNode = null;
        }
        else{
            parent.removeChild(this);
        }
    }
    this._children = [];
};

/**
 * Sets platform of a DataNode. If _platform is defined, it will override the default platform setting of
 * an Xflow graph.
 *
 * @param {String|C.PLATFORM|null} platformSrc
 */
DataNode.prototype.setPlatform = function(platformSrc) {
    if (typeof platformSrc === 'string') {
        if (platformSrc === "cl") {
            this._platform = C.PLATFORM.CL;
        }
        else if (platformSrc === "gl") {
            this._platform = C.PLATFORM.GLSL;
        }
        else if (platformSrc === "js") {
            this._platform = C.PLATFORM.JAVASCRIPT;
        }
    } else if (!isNaN(parseFloat(platformSrc)) && isFinite(platformSrc)) {
        this._platform = platformSrc;
    } else {
        this._platform = null;
    }

    this.notify(C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

/**
 * @const
 */
var filterParser = /^([A-Za-z\s]*)\(([^()]+)\)$/;

/**
 * Set filter by string
 * @param {string} filterString
 */
DataNode.prototype.setFilter = function(filterString){
    filterString = filterString || "";
    var newType = C.DATA_FILTER_TYPE.RENAME;
    var newMapping = null;
    if(filterString){
        var result = filterString.trim().match(filterParser);
        if(result){
            var type = result[1].trim();
            switch(type){
                case "keep": newType = C.DATA_FILTER_TYPE.KEEP; break;
                case "remove": newType = C.DATA_FILTER_TYPE.REMOVE; break;
                case "rename": newType = C.DATA_FILTER_TYPE.RENAME; break;
                default:
                    Base.notifyError("Unknown filter type:" + type, this);
            }
            newMapping = Mapping.Mapping.parse(result[2], this);
        }
        else{
            Base.notifyError("Could not parse filter '" + filterString + "'", this);
        }
    }
    if(!newMapping){
        // TODO Remove this? (Mapping can be null from now on)
        newMapping = new Mapping.OrderMapping();
    }
    swapMapping(this, "_filterMapping", newMapping);
    this._filterType = newType;
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

var computeParser = /^(([^=]+)\=)?([^'(]+('[^']+')?[^'(]+)(\(([^()]*)?\))?$/;
var bracketsParser = /^\(([^()]*)\)$/;
var dataflowParser = /^dataflow\['([^']+)'\]$/;

//noinspection JSUnusedGlobalSymbols
/**
 * If the compute string contains a reference to an external dataflow,
 * the parser returns its URL. Null, otherwise
 * @param computeString
 * @returns {string|null}
 */
var getComputeDataflowUrl = function(computeString){
    computeString = computeString || "";
    var result = computeString.trim().match(computeParser);
    if(result){
        if(result = result[3].trim().match(dataflowParser)){
            return result[1];
        }
    }
    return null;
};

/**
 * Set compute by string
 * @param {string} computeString
 */
DataNode.prototype.setCompute = function(computeString){
    computeString = computeString || "";
    var newOperator = "";
    var inputMapping = null, outputMapping = null;
    var result = computeString.trim().match(computeParser);
    if(result){
        var output = result[2] ? result[2].trim() : "";
        newOperator = result[3].trim();
        var input = result[6] ? result[6].trim() : "";
        if(result = output.match(bracketsParser)){
            output = result[1];
        }
        if(input)
            inputMapping = Mapping.Mapping.parse(input, this);
        if(output)
            outputMapping = Mapping.Mapping.parse(output, this);

        if(result = newOperator.match(dataflowParser)){
            this._computeUsesDataflow = true;
            newOperator = result[1];
        }
        else{
            this._computeUsesDataflow = false;
        }
        this._dataflowNode = null;
    }
    else if(computeString){
        Base.notifyError("Error parsing Compute value '" + computeString + "'", this);
    }
    swapMapping(this, "_computeInputMapping", inputMapping);
    swapMapping(this, "_computeOutputMapping", outputMapping);
    this._computeOperator = newOperator;
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

/**
 * Notifies DataNode about a change. Notification will be forwarded to parents, if necessary
 * @param {C.RESULT_STATE} changeType
 * @param {GraphNode?} senderNode
 */
DataNode.prototype.notify = function(changeType, senderNode){
    //noinspection FallthroughInSwitchStatementJS
    switch(changeType) {
        case C.RESULT_STATE.CHANGED_STRUCTURE:
            this._paramNames = null;
            this._globalParamNames = null;
            this._channelNode.setStructureOutOfSync();
            clearSubstitutionNodes(this);
            notifyParentsOnChanged(this, changeType);
            break;

        case C.RESULT_STATE.IMAGE_LOAD_START:
        case C.RESULT_STATE.IMAGE_LOAD_END:
            updateProgressLevel(this);
            if(senderNode){
                this._channelNode.notifyDataChange(senderNode, changeType);
            }
            break;

        case C.RESULT_STATE.CHANGED_DATA_VALUE:
        case C.RESULT_STATE.CHANGED_DATA_SIZE:
            if(senderNode){
                this._channelNode.notifyDataChange(senderNode, changeType);
            }
            break;
    }
    // Inform listeners (e.g. Requests)
    for(var i = 0; i < this._listeners.length; ++i) {
        this._listeners[i](changeType);
    }
};

DataNode.prototype.addListener = function(listener){
    this._listeners.push(listener)
};

DataNode.prototype.removeListener = function(listener) {
    Array.erase(this._listeners, listener);
};

DataNode.prototype.addLoadListener = function(listener){
    this._loadListeners.push(listener);
};

//noinspection JSUnusedGlobalSymbols
DataNode.prototype.removeLoadListener = function(listener){
    Array.erase(this._loadListeners, listener);
};

DataNode.prototype._callLoadListeners = function(newLevel, oldLevel){
    var len = this._loadListeners.length;
    for(var i = 0; i < len; ++i){
        this._loadListeners[i](this, newLevel, oldLevel);
    }
};

DataNode.prototype.getOutputNames = function(){
    return getForwardNode(this)._channelNode.getOutputNames();
};

DataNode.prototype.getOutputChannelInfo = function(name){
    return getForwardNode(this)._channelNode.getOutputChannelInfo(name);
};

//noinspection JSUnusedGlobalSymbols
DataNode.prototype.getParamNames = function(){
    return this._getParamNames();
};

/**
 * Delegate computation of the result to the channel node
 * of the first contributing DataNode.
 * @param type
 * @param filter
 * @returns {Result}
 */
DataNode.prototype._getResult = function(type, filter){
    return getForwardNode(this, filter)._channelNode.getResult(type, filter);
};

DataNode.prototype._getForwardNode = function(filter){
    return getForwardNode(this, filter);
};

DataNode.prototype._getParamNames = function(){
    if(!this._paramNames){
        this._paramNames = [];
        if(this._sourceNode)
            Utils.nameset.add(this._paramNames, this._sourceNode._getParamNames());
        else{
            for(var i = 0; i < this._children.length; ++i){
                Utils.nameset.add(this._paramNames, this._children[i]._getParamNames());
            }
        }
    }
    return this._paramNames;
};

DataNode.prototype._getGlobalParamNames = function(){
    if(!this._globalParamNames){
        this._globalParamNames = [];
        if(this._dataflowNode)
            Utils.nameset.add(this._globalParamNames, this._dataflowNode._getGlobalParamNames());

        if(this._sourceNode)
            Utils.nameset.add(this._globalParamNames, this._sourceNode._getGlobalParamNames());
        else{
            for(var i = 0; i < this._children.length; ++i){
                Utils.nameset.add(this._globalParamNames, this._children[i]._getGlobalParamNames());
            }
        }
    }
    return this._globalParamNames;
};

/**
 * @param {Substitution} substitution
 * @returns {ChannelNode}
 */
DataNode.prototype._getOrCreateChannelNode = function(substitution){
    if(!substitution)
        return this._channelNode;
    else{
        var key = substitution.getKey(this);
        if(!this._substitutionNodes[key]) {
            this._substitutionNodes[key] = new ChannelNode(this, substitution);
        } else {
            this._substitutionNodes[key].increaseRef();
        }
        return this._substitutionNodes[key];
    }
};

/**
 * Remove ChannelNode passed as argument from internal substitution nodes
 * Decreases reference counter of substitution node and deletes it if not
 * used by any other node.
 * @param {ChannelNode} substitutionNode
 */
DataNode.prototype._removeSubstitutionNode = function(substitutionNode){
    var key = substitutionNode.substitution.getKey(this);
    if(this._substitutionNodes[key] && this._substitutionNodes[key].decreaseRef())
        delete this._substitutionNodes[key];
};

/**
 * Calls clear of all substitutionNodes and clears the map
 * @param {DataNode} dataNode
 */
function clearSubstitutionNodes(dataNode){
    if (!dataNode._substitutionNodes) {
        return;
    }
    for(var name in dataNode._substitutionNodes) {
        dataNode._substitutionNodes[name].clear();
    }
    dataNode._substitutionNodes = {};
    for (var i in dataNode._children) {
        clearSubstitutionNodes(dataNode._children[i]);
    }
}
//----------------------------------------------------------------------------------------------------------------------
// Helpers
//----------------------------------------------------------------------------------------------------------------------



/**
 * Skips nodes, if it does not contribute to the result (optimization)
 * @param {DataNode} dataNode
 * @param {array.<string>?} filter
 * @returns {DataNode}
 */
function getForwardNode(dataNode, filter){
    var hasFilter = (dataNode._filterMapping && !dataNode._filterMapping.isEmpty());
    if(hasFilter)
        return dataNode;

    if(!dataNode._computeOperator ){
        if(dataNode._sourceNode && dataNode._children.length == 0)
            return getForwardNode(dataNode._sourceNode);
        if(dataNode._children.length == 1 && dataNode._children[0] instanceof DataNode)
            return getForwardNode(dataNode._children[0]);
    }

    var idx = dataNode._channelNode.getChildDataIndex(filter);
    if(idx != -1 && idx != undefined){
        if(dataNode._sourceNode)
            return getForwardNode(dataNode._sourceNode);
        else
            return getForwardNode(dataNode._children[idx]);
    }
    return dataNode;
}


/**
 * Computes the progress level
 * @private
 * @param {DataNode} node
 */
function updateProgressLevel(node){
    var progressLevel = node._loading ? node._loadLevel : Infinity;
    var i;

    for(i = 0; progressLevel && i < node._children.length; ++i){
        var child = node._children[i];
        if(child instanceof DataNode){
            progressLevel = Math.min(progressLevel, Math.max(child._loadLevel, child._progressLevel) );
        }
        else if(child._data && child._data.isLoading && child._data.isLoading()){
            progressLevel = Math.min(progressLevel, 1);
        }
    }
    if(progressLevel && node._sourceNode){
        progressLevel = Math.min(progressLevel, Math.max(node._sourceNode._loadLevel, node._sourceNode._progressLevel));
    }
    if(progressLevel && node._dataflowNode){
        progressLevel = Math.min(progressLevel, Math.max(node._dataflowNode._loadLevel, node._dataflowNode._progressLevel));
    }
    var oldLevel = node._progressLevel;
    node._progressLevel = progressLevel;

    if(oldLevel != node._progressLevel){
        node._callLoadListeners(node._progressLevel, oldLevel);
        for(i = 0; i < node._parents.length; ++i)
            updateProgressLevel(node._parents[i]);
    }
}

/**
 * @private
 * @param {DataNode} parent
 * @param {GraphNode} child
 */
function addParent(parent, child){
    child._parents.push(parent);
}

/**
 * @private
 * @param {DataNode} parent
 * @param {GraphNode} child
 */
function removeParent(parent, child){
    Array.erase(child._parents, parent);
}

/**
 * Notify all parent nodes about a change
 * @param {GraphNode} node
 * @param {exports.C.RESULT_STATE} changeType
 * @private
 */
function notifyParentsOnChanged(node, changeType){
    for(var i = 0; i < node._parents.length; ++i){
        node._parents[i].notify(changeType, node);
    }
}

/**
 * Update the owners of the mappings
 * @param {DataNode} dataNode
 * @param {string} key
 * @param {Mapping} mapping
 */
function swapMapping(dataNode, key, mapping){
    dataNode[key] && dataNode[key]._removeOwner(dataNode);
    dataNode[key] = mapping;
    dataNode[key] && dataNode[key]._addOwner(dataNode);
}

function replaceNodeInHierarchy(node, field, newChild) {
    var oldChild = node[field];
    if(oldChild) {
        removeParent(node, oldChild);
    }
    node[field] = newChild;
    if(newChild) {
        addParent(node, newChild);
    }
}

module.exports = {
    InputNode: InputNode,
    DataNode: DataNode,
    getComputeDataflowUrl: getComputeDataflowUrl
};

},{"../../utils/array.js":178,"../base.js":186,"../processing/channel-node.js":230,"../utils/utils.js":238,"./../processing/mapping.js":234,"./constants.js":187}],190:[function(require,module,exports){
var Base = require("../base.js");
var C = require("./constants.js");
var DataNode = require("./graph.js").DataNode;

/**
 * Content of this file:
 * Classes to request results from an Xflow graph.
 */

/**
 * Abstract Request class.
 * Any Request is created from a DataNode to receive the result of that DataNode.
 * To allow effective optimization, it is recommended to create only one Request per DataNode and receive all
 * results through that Request.
 * @abstract
 * @param {DataNode} dataNode The DataNode from which to request results
 * @param {?Array.<string>} filter A list of names filtering the values to be received (only return values with names inside the filter)
 * @param {?function} callback A callback function that gets called whenever the result of the Request changes
 */
var Request = function(dataNode, filter, callback){
    this._dataNode = dataNode;
    this._filter = filter ? filter.slice().sort() : null;
    this._listener = callback;

    /**
     * Cached result of this request
     * @type {Result}
     */
    this._result = null;

    /**
     * Cached callback function attached to data node
     * @private
     */
    this._dataNodeListener = this._onDataNodeChange.bind(this);

    this._dataNode.addListener(this._dataNodeListener);
};

Object.defineProperty(Request.prototype, "dataNode", {
    set: function(){
       throw new Error("dataNode is readonly");
    },
    get: function(){ return this._dataNode; }
});

Object.defineProperty(Request.prototype, "filter", {
    set: function(){
        throw new Error("filter is read-only");
    },
    get: function(){ return this._filter; }
});

/**
 * Call this function, whenever the request is not required anymore.
 * Cleans up cached data and listeners
 */
Request.prototype.clear = function(){
    this._listener = null;
    if(this._result) this._result._removeRequest(this);
    this._dataNode.removeListener(this._dataNodeListener);
};

/**
 * @param {C.RESULT_STATE} data
 * @private
 */
Request.prototype._onPostponedResultChanged = function(data){
    this._listener && this._listener(this, data);
};

/**
 * Change the result of the request and update request list of old and new
 * result.
 * @private
 * @param {Request} request
 * @param {Result?} newResult
 * @returns {Result}
 */
function swapResultRequest(request, newResult){
    if(request._result) request._result._removeRequest(request);
    request._result = newResult;
    if(newResult) newResult._addRequest(request);
    return newResult;
}

/**
 * @param {Request} request
 * @param {C.RESULT_STATE} notification
 * @private
 */
function notifyListeners(request, notification){
    Base._queueResultCallback(request, notification);
}

/**
 * @param {C.RESULT_STATE} notification
 */
Request.prototype._onDataNodeChange = function(notification){
    notifyListeners(this, notification);
};

/**
 * A ComputeRequest is a Request for a ComputeResult, which contains a named map of typed values.
 * @constructor
 * @extends {Request}
 * @param {DataNode} dataNode The DataNode from which to request results
 * @param {?Array.<string>} filter A list of names filtering the values to be received (only return values with names inside the filter)
 * @param {?function} callback A callback function that gets called whenever the result of the Request changes
 */
var ComputeRequest = function(dataNode, filter, callback){
    Request.call(this, dataNode, filter, callback);
};
Base.createClass(ComputeRequest, Request);

/**
 * @returns {Result}
 */
ComputeRequest.prototype.getResult = function(){
    // swapResultRequest is called here because the result object of the request may change, e.g.
    // different forward node.
    return swapResultRequest(this, this._dataNode._getResult(C.RESULT_TYPE.COMPUTE, this._filter));
};

ComputeRequest.prototype._onResultChanged = function(notification){
    this._onDataNodeChange(notification);
};


var c_vsConnectNodeCount = {},
    c_vsConnectNodeKey = {},
    c_vsConnectNodeCache = {};

/**
 * A VertexShaderRequest is a Request for a VSDataResult, used to generate a VertexShader that includes
 * dataflow processing.
 * @constructor
 * @extends {Request}
 * @param {DataNode} dataNode
 * @param {VSConfig} vsConfig Configuration for the output of the generated vertex shader
 * @param {?function} callback A callback function that gets called whenever the result of the Request changes
 */
var VertexShaderRequest = function(dataNode, vsConfig, callback){
    var filter = vsConfig.getFilter();
    if(filter.length == 0)
        throw new Error("vsConfig requires at least one attribute entry.");
    Request.call(this, dataNode, filter, callback);
    this._vsConfig = vsConfig;
    this._vsConnectNode = getVsConnectNode(dataNode, vsConfig);
};
Base.createClass(VertexShaderRequest, Request);

VertexShaderRequest.prototype.getConfig = function(){
    return this._vsConfig;
};

/**
 * @see ComputeRequest.getResult
 * @returns {Result}
 */
VertexShaderRequest.prototype.getResult = function(){
    return swapResultRequest(this, this._vsConnectNode._getResult(C.RESULT_TYPE.VS, this._filter));
};

VertexShaderRequest.prototype._onDataNodeChange = function(notification){
    if(notification == C.RESULT_STATE.CHANGED_STRUCTURE){
        var newVSConnectedNode = getVsConnectNode(this._dataNode, this._vsConfig, this._filter);
        if(newVSConnectedNode != this._vsConnectNode){
            clearVsConnectNode(this._vsConnectNode);
            this._vsConnectNode = newVSConnectedNode;
        }
    }
    Request.prototype._onDataNodeChange.call(this, notification);
};

VertexShaderRequest.prototype.getVertexShader = function(){
    this.getResult(); // Update the result first
    if(!this._vertexShader){
        this._vertexShader = this._result.getVertexShader(this._vsConfig);
    }
    return this._vertexShader;
};

VertexShaderRequest.prototype._onResultChanged = function(notification){
    this._onDataNodeChange(notification);
};

function getVsConnectNode(dataNode, vsConfig, filter){
    var forwardNode = dataNode._getForwardNode(filter);

    var key = getDataNodeShaderKey(forwardNode, vsConfig);
    var connectNode;
    if(!(connectNode = c_vsConnectNodeCache[key])){
        connectNode = new DataNode(false);
        connectNode.appendChild(forwardNode);

        connectNode.computeOperator = vsConfig.getOperator();
        connectNode.computeInputMapping = null;
        connectNode.computeOutputMapping = null;

        c_vsConnectNodeCache[key] = connectNode;
        c_vsConnectNodeCount[connectNode.id] = 1;
        c_vsConnectNodeKey[connectNode.id] = key;
    }
    else{
        c_vsConnectNodeCount[connectNode.id]++;
    }

    return connectNode;
}

function clearVsConnectNode(connectNode){
    c_vsConnectNodeCount[connectNode.id]--;
    if(!c_vsConnectNodeCount[connectNode.id]){
        var key = c_vsConnectNodeKey[connectNode.id];
        c_vsConnectNodeCache[key] = null;
        connectNode.clear();
    }
}


function getDataNodeShaderKey(dataNode, vsConfig){
    return dataNode.id + "|" + vsConfig.getKey();
}

module.exports = {
    ComputeRequest:  ComputeRequest,
    VertexShaderRequest: VertexShaderRequest
};

},{"../base.js":186,"./constants.js":187,"./graph.js":189}],191:[function(require,module,exports){
var C =require("../interface/constants.js");

/**
 * CLProgram implements automatic Xflow input/output adaptive WebCL kernel and application code generation.
 *
 * @param operatorList
 * @constructor
 */

var CLProgram = function (operatorList) {
    this.cl = XML3D.webcl.cl; // CL wrapper

    if (!this.cl) {
        return;
    }

    this.list = operatorList;
    this.entry = operatorList.entries[0];
    this.operator = this.entry.operator;

    this.kernelParamMap = {inputs: [], outputs: []}; // Stores initialised KernelParam objects
    this.kernelFunctionParams = []; // Stores generated function parameters for kernel function header.
    this.kernelCode = null; // Generated kernel code
    this.kernelProgram = null; // Compiled kernel program
    this.mainProgram = null; // Main WebCL application code

};

/**
 * Map of helper kernel parameters required for certain input data types.
 *
 * @type Object
 */
var helperParamMap = {
    'texture': {type: "uint", params: ["width", "height"]}, 'buffer': {type: "uint", params: ["length"]}
};

/**
 * Utility prototype object for mapping Xflow inputs to kernel parameters and for generating kernel code.
 *
 * @param {Object} program
 * @param {String} name
 * @param {C.DATA_TYPE} xflowType
 * @param {String} clType
 * @param entryValue
 * @param {Boolean?} isInput
 * @name KernelParam
 * @constructor KernelParam
 */

function KernelParam(program, name, xflowType, clType, entryValue, isInput) {
    this.program = program;
    this.cl = program.cl;
    this.name = name;
    this.type = clType || null;
    this.isInput = !!isInput;
    this.needsMemObject = false;
    this.hasMemObject = false;
    this.byteSize = null;
    this.memObjectSize = null;
    this.arg = null;
    this.clFunctionParam = null;
    this.xflowType = xflowType;
    this.helperMap = null;
    this.helpers = [];
    this.entryValue = entryValue || null;
    this.val = null;

    this.prepareParam();
    this.initHelperParams();
    this.initKernelArg();
    this.updateValue(this.entryValue);

}

KernelParam.prototype = {
    /**
     * Prepares the kernel parameter data.
     * Maps the input xflow data type to webcl data type and creates a kernel function header parameter with proper
     * declarations.
     */
    prepareParam: function () {
        var helperMap;
        var xflowDataTypes = C.DATA_TYPE;
        var kernelFuncParam = [];
        var addressSpace = '';
        var declarations = '';

        if (!this.type) {
            switch (this.xflowType) {
                case xflowDataTypes.TEXTURE:
                {
                    helperMap = helperParamMap.texture;
                    this.type = "uchar4*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                case xflowDataTypes.INT:
                {
                    this.type = "int";
                }
                    break;
                case xflowDataTypes.INT4:
                {
                    helperMap = helperParamMap.buffer;
                    this.type = "int4*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                case xflowDataTypes.FLOAT:
                {
                    this.type = "float";
                }
                    break;
                case xflowDataTypes.FLOAT2:
                {
                    helperMap = helperParamMap.buffer;
                    this.type = "float2*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                case xflowDataTypes.FLOAT3:
                {
                    helperMap = helperParamMap.buffer;
                    this.type = "float*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                case xflowDataTypes.FLOAT4:
                {
                    helperMap = helperParamMap.buffer;
                    this.type = "float4*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                case xflowDataTypes.FLOAT4X4:
                {
                    helperMap = helperParamMap.buffer;
                    this.type = "float16*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                default:
                    return;
            }

            this.helperMap = helperMap;
        }

        // Arranging parameter parts
        if (addressSpace) {
            kernelFuncParam.push(addressSpace);
        }

        if (this.isInput) {
            declarations = 'const';
        }

        if (declarations) {
            kernelFuncParam.push(declarations);
        }

        kernelFuncParam.push(this.type);
        kernelFuncParam.push(this.name);
        this.clFunctionParam = kernelFuncParam.join(' ');
    },

    /**
     * Initialises helper parameters for an input parameter if needed.
     *
     */

    initHelperParams: function () {
        var helperVal;
        var self = this;
        var helperMap = this.helperMap;

        if (helperMap && this.isInput) {
            helperMap.params.forEach(function (p) {
                var pName = self.name + '_' + p;
                if (p === "width") {
                    helperVal = self.entryValue.width;
                } else if (p === "height") {
                    helperVal = self.entryValue.height;
                } else if (p === "length") {
                    helperVal = self.entryValue.length;
                    var type = self.xflowType;
                    switch (type) {
                        case C.DATA_TYPE.FLOAT2:
                        {
                            helperVal = helperVal / 2;
                        }
                            break;
                        case C.DATA_TYPE.FLOAT3:
                        {
                            helperVal = helperVal / 3;
                        }
                            break;
                        case C.DATA_TYPE.FLOAT4:
                        case C.DATA_TYPE.INT4:
                        {
                            helperVal = helperVal / 4;
                        }
                            break;
                        case C.DATA_TYPE.FLOAT4X4:
                        {
                            helperVal = helperVal / 16;
                        }
                            break;
                        default:
                            break;
                    }
                }
                self.helpers.push(new KernelParam(self.program, pName, null, helperMap.type, new Uint32Array([helperVal])));
            });
        }
    },

    /**
     * Initialises kernel argument that will be passed directly into the compiled kernel.
     * Creates a WebCL memory object if needed (e.g. for texture).
     */

    initKernelArg: function () {
        if (this.needsMemObject) {
            this.allocateMemObject();
        } else {
            this.arg = this.entryValue;
        }
    },

    allocateMemObject: function () {
        var clAPI = this.cl.API;
        var clCtx = this.cl.ctx;
        var paramType = this.type;
        var byteSize = parseInt(paramType.substring(paramType.length - 2, paramType.length - 1), 10);
        var memObjectMode = this.isInput ? 'r' : 'w';
        var entryValue = this.entryValue;
        var memObjectSize, memObject;

        if (this.hasMemObject) {
            this.arg.release();
        }

        this.byteSize = isNaN(byteSize) ? 1 : byteSize;

        if (this.xflowType === C.DATA_TYPE.TEXTURE) { // Texture is a special case
            memObjectSize = entryValue.width * entryValue.height * byteSize;
            this.byteSize = 4;
        } else {
            switch (this.xflowType) {
                case C.DATA_TYPE.INT4:
                {
                    memObjectSize = entryValue.length * Int32Array.BYTES_PER_ELEMENT;
                }
                    break;
                case C.DATA_TYPE.FLOAT2:
                case C.DATA_TYPE.FLOAT3:
                case C.DATA_TYPE.FLOAT4:
                case C.DATA_TYPE.FLOAT4x4:
                {
                    memObjectSize = entryValue.length * Float32Array.BYTES_PER_ELEMENT;
                }
                    break;
                default:
                    memObjectSize = entryValue.length * 4;
                    break;
            }
        }

        memObject = clAPI.createBuffer(memObjectSize, memObjectMode, clCtx);

        this.memObjectSize = memObjectSize;
        this.arg = memObject;

        this.hasMemObject = true;
        this.needsMemObject = false;

    },

    updateValue: function (entry) {
        if (this.hasMemObject) {
            this.val = entry.data === undefined ? entry : entry.data;
            this.entryValue = entry;
            this.checkEntrySize();
        } else {
            this.arg = this.entryValue = entry;
        }
    }, updateHelpers: function () {
        var helpers = this.helpers;
        var self = this;

        helpers.forEach(function (p) {
            var name = p.name;
            if (name.indexOf("width") !== -1) {
                p.updateValue(new Uint32Array([self.entryValue.width]));
            } else if (name.indexOf("height") !== -1) {
                p.updateValue(new Uint32Array([self.entryValue.height]));
            } else if (name.indexOf("length") !== -1) {
                var len = self.entryValue.length;
                if (self.xflowType === C.DATA_TYPE.FLOAT4 || self.xflowType === C.DATA_TYPE.INT4) {
                    len = len / 4;
                } else if (self.xflowType === C.DATA_TYPE.FLOAT4X4) {
                    len = len / 16;
                }
                p.updateValue(new Uint32Array([len]));
            }
        });
    }, checkEntrySize: function () {
        var newSize;
        var entryVal = this.entryValue;

        if (this.xflowType === C.DATA_TYPE.TEXTURE) {
            newSize = entryVal.width * entryVal.height * this.byteSize;
        } else if (this.xflowType === C.DATA_TYPE.FLOAT2 || this.xflowType === C.DATA_TYPE.FLOAT3 || this.xflowType === C.DATA_TYPE.FLOAT4 || this.xflowType === C.DATA_TYPE.FLOAT4X4) {
            newSize = entryVal.length * Float32Array.BYTES_PER_ELEMENT;
        } else if (this.xflowType === C.DATA_TYPE.INT4) {
            newSize = entryVal.length * Int32Array.BYTES_PER_ELEMENT;
        } else {
            newSize = entryVal.length * this.byteSize;
        }
        if (this.memObjectSize !== newSize) {
            this.allocateMemObject();
            this.updateHelpers();
            this.program.mainProgram = null; // Forcing CL application program update
        }
    }
};


/**
 * Runs CLProgram. WebCL related code initialised in the first run.
 *
 * @param programData
 */

CLProgram.prototype.run = function (programData) {
    var operatorData = prepareOperatorData(this.list, 0, programData);

    applyDefaultOperation(this.entry, programData, operatorData, this);

};

function prepareOperatorData(list, idx, programData) {
    var doIterate, i;
    var data = programData.operatorData[0];
    var entry = list.entries[idx];
    var mapping = entry.operator.mapping;

    data.iterFlag = {};

    for (i = 0; i < mapping.length; ++i) {
        doIterate = (entry.isTransferInput(i) || list.isInputIterate(entry.getDirectInputIndex(i)));
        data.iterFlag[i] = doIterate;
    }

    data.iterateCount = list.getIterateCount(programData);

    return data;
}

function applyDefaultOperation(entry, programData, operatorData, program) {
    if (program.operator.evaluate && program.operator.evaluate instanceof Array) {
        assembleFunctionArgs(entry, programData, program);

        if (program.kernelCode === null) {
            prepareWebCLKernel(programData, program);
        }
        //console.time('CLProgram (' + program.operator.name + ')');
        if (program.mainProgram === null) {
            program.mainProgram = createMainWebCLProgram(program);
        }
        program.mainProgram();
        //console.timeEnd('CLProgram (' + program.operator.name + ')');
    }
}

/**
 * Maps Xflow inputs and outputs into WebCL kernel inputs and outputs.
 *
 * @function assembleFunctionArgs
 * @param entry
 * @param programData
 * @param program
 */

function assembleFunctionArgs(entry, programData, program) {
    var d, dataEntry, i;
    var kernelFunctionParams = program.kernelFunctionParams;
    var outputs = program.operator.outputs;

    kernelFunctionParams.length = 0;

    for (i = 0; i < outputs.length; ++i) {
        d = outputs[i];
        dataEntry = programData.outputs[entry.getOutputIndex(i)].dataEntry;

        prepareKernelParameter(d, !!(d.source), program, kernelFunctionParams, dataEntry, i);
    }

    addInputToArgs(entry, programData, program, kernelFunctionParams);
}


function addInputToArgs(entry, programData, program, kernelFunctionParams) {
    var mapEntry, dataEntry, i;
    var mapping = entry.operator.mapping;

    for (i = 0; i < mapping.length; ++i) {
        mapEntry = mapping[i];
        dataEntry = programData.getDataEntry(entry.getDirectInputIndex(i));

        prepareKernelParameter(mapEntry, !!(mapEntry.source), program, kernelFunctionParams, dataEntry, i);
    }
}

/**
 * Creates a new KernelParam utility object or updates the existing object if input value has been changed.
 * Additionally, this is used for generating the WebCL kernel function header.
 *
 * @function prepareKernelParameter
 * @param param
 * @param input
 * @param program
 * @param functionParams
 * @param arg
 * @param i
 */

function prepareKernelParameter(param, input, program, functionParams, arg, i) {
    var kernelParams;
    var entryVal = arg ? arg.getValue() : null;

    if (input) {
        kernelParams = program.kernelParamMap.inputs;
    } else {
        kernelParams = program.kernelParamMap.outputs;
    }

    if (kernelParams[i]) {
        kernelParams[i].updateValue(entryVal);
        return;
    }

    kernelParams[i] = new KernelParam(program, param.name, param.type, null, entryVal, input);

    // Pushing generated kernel function params into array.
    // This array is later used in generating the WebCL kernel function header.
    functionParams.push(kernelParams[i].clFunctionParam);

    kernelParams[i].helpers.forEach(function (p) {
        functionParams.push(p.clFunctionParam);
    });
}


/** KERNEL CODE PREPARATION **/


/**
 * Compiles and registers the prepared WebCL kernel code.
 *
 * @function prepareWebCLKernel
 * @param programData
 * @param program
 * @returns {boolean}
 */

function prepareWebCLKernel(programData, program) {
    var kernelCode;
    var kernelManager = program.cl.kernelManager;
    var inputKernel = program.operator.evaluate;
    var kernelName = program.kernelName = program.operator.name.split('xflow.')[1];

    if (!inputKernel) {
        return false;
    }

    kernelCode = program.kernelCode = prepareKernelCode(kernelName, inputKernel, program);

    try {
        kernelManager.register(kernelName, kernelCode);
    } catch (e) {
        return false;
    }

    program.kernelProgram = kernelManager.getKernel(program.kernelName);

    return true;
}

/**
 *
 * Generates kernel function header and helper kernel code and combines it with user's input kernel code.
 *
 * @function prepareKernelCode
 * @param {String} kernelName
 * @param {Array} inputKernel
 * @param program
 * @returns {String}
 */

function prepareKernelCode(kernelName, inputKernel, program) {
    var result, innerKernelCode;

    result = createKernelHeader(kernelName, program);

    if (!result) {
        return false;
    }

    result += '{\n';

    innerKernelCode = createInnerKernelCode(program);

    if (!innerKernelCode) {
        return false;
    }

    result += innerKernelCode;
    result += inputKernel.join('\n');
    result += '\n}';

    return result;
}

/**
 * Generates a kernel function header from assembled kernel parameters.
 *
 * @function createKernelHeader
 * @param kernelName
 * @param program
 * @returns {string}
 */

function createKernelHeader(kernelName, program) {
    var functionHeader = [];

    functionHeader.push("__kernel void");
    functionHeader.push(kernelName + '(');
    functionHeader.push(program.kernelFunctionParams.join(', '));
    functionHeader.push(')');

    return functionHeader.join(' ');
}

/**
 * Generates helper kernel code.
 *
 * @function createInnerKernelCode
 * @param program
 * @returns {string}
 */

function createInnerKernelCode(program) {
    var codeLines = [];

    var firstInput = program.kernelParamMap.inputs[0];

    if (firstInput.type === "uchar4*") {
        // Add "iterators"
        codeLines.push("int x = get_global_id(0);");
        codeLines.push("int y = get_global_id(1);");

        // Add bounds checkers
        codeLines.push("if (x >= " + firstInput.name + "_width || y >= " + firstInput.name + "_height) return;");

        // Add input iterator
        codeLines.push("int " + firstInput.name + "_i = y * " + firstInput.name + "_width + x;");

    } else { // Else, assuming that the first input is an 1-dimensional buffer

        codeLines.push("int " + firstInput.name + "_i = get_global_id(0);");

        codeLines.push("if (" + firstInput.name + "_i >= " + firstInput.name + "_length) return;");
    }

    return codeLines.join('\n');

}


/** MAIN WEBCL PROGRAM INITIALISATION **/

/**
 * Initialises the main WebCL application code that executes the WebCL kernel
 *
 * @function createMainWebCLProgram
 * @param program
 * @returns {Function}
 */

function createMainWebCLProgram(program) {
    var cl = program.cl;
    var kernelManager = cl.kernelManager;
    var cmdQueue = cl.cmdQueue;
    var memObjects = {inputs: [], outputs: []};
    var assembledArgs = assembleKernelArguments(program.kernelParamMap, memObjects);
    var WSSizes = computeWorkGroupSize(program.kernelParamMap.inputs[0]);
    var kernel = program.kernelProgram;

    return function () {
        var i, len, memObj, args;
        var inputMemObjs = memObjects.inputs;
        var outputMemObjs = memObjects.outputs;

        if (!kernel) {
            return false;
        }

        args = assembledArgs.map(function (a) {
            return a.arg;
        });

        kernelManager.setArgs.apply(null, [kernel].concat(args));

        try {
            // Write the buffer to OpenCL device memory
            len = inputMemObjs.length;
            for (i = 0; i < len; i++) {
                memObj = inputMemObjs[i];
                cmdQueue.enqueueWriteBuffer(memObj.arg, false, 0, /*memObj.arg.getInfo(WebCL.MEM_SIZE)*/memObj.memObjectSize, memObj.val, []);
            }

            // Execute (enqueue) kernel
            cmdQueue.enqueueNDRangeKernel(kernel, WSSizes[1].length, [], WSSizes[1], WSSizes[0]);

            // Read the result buffer from OpenCL device
            len = outputMemObjs.length;
            for (i = 0; i < len; i++) {
                memObj = outputMemObjs[i];
                cmdQueue.enqueueReadBuffer(memObj.arg, false, 0, /*memObj.arg.getInfo(WebCL.MEM_SIZE)*/memObj.memObjectSize, memObj.val, []);
            }

            cmdQueue.finish(); //Finish all the operations

        } catch (e) {
            return false;
        }

        return true;
    };
}


/**
 * Arranges initialised kernel arguments into helper arrays so they are more easily available in
 * the main WebCL application.
 *
 * @function assembleKernelArguments
 * @param paramMap
 * @param memObjects
 * @returns {Array}
 */

function assembleKernelArguments(paramMap, memObjects) {
    var outputs = paramMap.outputs;
    var inputs = paramMap.inputs;
    var kernelArgs = [];

    outputs.forEach(function (p) {
        mapKernelArgument(p, kernelArgs, memObjects.outputs);
    });

    inputs.forEach(function (p) {
        mapKernelArgument(p, kernelArgs, memObjects.inputs);
    });

    return kernelArgs;
}

function mapKernelArgument(param, kernelArgs, memObjects) {
    kernelArgs.push(param);

    if (param.hasMemObject) {
        memObjects.push(param);
        param.helpers.forEach(function (p) {
            kernelArgs.push(p);
        });
    }
}

/**
 * Computes a proper WebCL kernel workgroup size for target input buffer
 *
 * @function computeWorkGroupSize
 * @param targetInput
 * @returns {Array}
 */

function computeWorkGroupSize(targetInput) {
    var localWS, globalWS;
    var entryVal = targetInput.entryValue;

    if (targetInput.xflowType === C.DATA_TYPE.TEXTURE) {
        localWS = [16, 4];
        globalWS = [Math.ceil(entryVal.width / localWS[0]) * localWS[0], Math.ceil(entryVal.height / localWS[1]) * localWS[1]];
    } else {
        var k = 1;
        switch (targetInput.xflowType) {
            case C.DATA_TYPE.INT4:
            case C.DATA_TYPE.FLOAT4:
            {
                k = 4;
            }
                break;
            case C.DATA_TYPE.FLOAT3:
            {
                k = 3;
            }
                break;
            case C.DATA_TYPE.FLOAT4X4:
            {
                k = 16;
            }
                break;
        }
        localWS = [16];
        globalWS = [Math.ceil(entryVal.length / (localWS[0] * k)) * localWS[0]];
    }

    return [localWS, globalWS];
}

module.exports = CLProgram;

},{"../interface/constants.js":187}],192:[function(require,module,exports){
Xflow.registerOperator("xflow.add", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'value1'},
                {type: 'float3', source: 'value2'}],
    evaluate: function(result, value1, value2, info) {
        throw new Error("Not used!");
    },
    evaluate_core: function(result, value1, value2){
        result[0] = value1[0] + value2[0];
        result[1] = value1[1] + value2[1];
        result[2] = value1[2] + value2[2];
    }
});

},{}],193:[function(require,module,exports){
Xflow.registerOperator("xflow.bufferSelect", {
    outputs: [  {type: 'float3', name: 'result', noAlloc: true}],
    params:  [  {type: 'float3', source: 'trueOption', array: true},
                {type: 'float3', source: 'falseOption', array: true},
                {type: 'bool', source: 'value', array: true}],
    evaluate: function(result, falseOption, trueOption, value) {
        result.assign = value[0] ? trueOption : falseOption;

        return true;
    }
});

},{}],194:[function(require,module,exports){
Xflow.registerOperator("xflow.clampImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image', formatType: 'ImageData'} ],
    params:  [ {type: 'texture', source : 'image'},
               {type: 'float', source : 'min'},
               {type: 'float', source : 'max'}
             ],
    evaluate: function(result, image, min, max) {
        var inpix = image.data;
        var outpix = result.data;
        var minv = min[0];
        var maxv = max[0];
        var len = image.data.length;
        for (var i = 0 ; i < len; i++) {
            var val = inpix[i];
            if (val < minv) val = minv;
            if (val > maxv) val = maxv;
            outpix[i] = val;
        }
        return true;
    }
});

},{}],195:[function(require,module,exports){
// Code portions from http://www.html5rocks.com/en/tutorials/canvas/imagefilters/

(function() {

    function convolute(inpixels, outpixels, weights, opaque) {
        var side = Math.round(Math.sqrt(weights.length));
        var halfSide = Math.floor(side/2);
        var src = inpixels.data;
        var sw = inpixels.width;
        var sh = inpixels.height;
        // pad output by the convolution matrix
        var w = sw;
        var h = sh;
        var dst = outpixels.data;
        // go through the destination image pixels
        var alphaFac = opaque ? 1 : 0;
        for (var y=0; y<h; y++) {
            for (var x=0; x<w; x++) {
                var sy = y;
                var sx = x;
                var dstOff = (y*w+x)*4;
                // calculate the weighed sum of the source image pixels that
                // fall under the convolution matrix
                var r=0, g=0, b=0, a=0;
                for (var cy=0; cy<side; cy++) {
                    for (var cx=0; cx<side; cx++) {
                        var scy = sy + cy - halfSide;
                        var scx = sx + cx - halfSide;
                        if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                            var srcOff = (scy*sw+scx)*4;
                            var wt = weights[cy*side+cx];
                            r += src[srcOff] * wt;
                            g += src[srcOff+1] * wt;
                            b += src[srcOff+2] * wt;
                            a += src[srcOff+3] * wt;
                        }
                    }
                }
                dst[dstOff] = r;
                dst[dstOff+1] = g;
                dst[dstOff+2] = b;
                dst[dstOff+3] = a + alphaFac*(255-a);
            }
        }
        return outpixels;
    };

    Xflow.registerOperator("xflow.convoluteImage", {
        outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
        params:  [
            {type: 'texture', source : 'image'},
            {type: 'float', source : 'kernel'}
        ],
        evaluate: function(result, image, kernel) {
            convolute(image, result, kernel, true);
            return true;
        }
    });

    Xflow.registerOperator("xflow.convoluteImageToFloat", {
        outputs: [ {type: 'texture', name : 'result', sizeof: 'image', formatType : 'float32'} ],
        params:  [
            {type: 'texture', source : 'image'},
            {type: 'float', source : 'kernel'}
        ],
        evaluate: function(result, image, kernel) {
            convolute(image, result, kernel, true);
            return true;
        }
    });

})();

},{}],196:[function(require,module,exports){
Xflow.registerOperator("xflow.createIGIndex", {
    outputs:[
        //{type:'int', name:'index', customAlloc:true },
        {type:'float2', name:'texcoord', customAlloc:true }
    ],
    params:[
        {type:'int', source:'vertexCount', optional:false},
        {type:'texture', source:'positionTex', optional: false}
    ],
    alloc:function (sizes, vertexCount, image) {
        sizes['texcoord'] = image.width * image.height;
        //sizes['index'] = vertexCount[0];
    },
    evaluate:function (texcoord, vertexCount, image, info) {
        // tex coords
        var halfPixel = {
            x: 0.5 / image.width,
            y: 0.5 / image.height
        };
        var i = 0;
        for (var y = 0, ylength = image.height; y < ylength; y++)
        {
            for (var x = 0, xlength = image.width; x < xlength; x++)
            {
                texcoord[i++] = (x / xlength) + halfPixel.x;
                texcoord[i++] = 1 - ((y / ylength) + halfPixel.y);
            }
        }

        // index creation
        /*for(var i = 0; i < vertexCount[0]; i++) {
            index[i] = i;
        }*/
        return true;
    }
});

},{}],197:[function(require,module,exports){
(function() {
    var TMP_MATRIX = XML3D.math.mat4.create();
    var TMP_VEC = XML3D.math.vec3.create();
    var TMP_QUAT = XML3D.math.quat.create();
    var mat4 = XML3D.math.mat4;

    Xflow.registerOperator("xflow.createTransform", {
        outputs: [{type: 'float4x4', name: 'result'}],
        params: [{type: 'float3', source: 'translation', optional: true},
            {type: 'float4', source: 'rotation', optional: true},
            {type: 'float3', source: 'scale', optional: true},
            {type: 'float3', source: 'center', optional: true},
            {type: 'float4', source: 'scaleOrientation', optional: true}],
        evaluate: function (result, translation, rotation, scale, center, scaleOrientation, info) {
            for (var i = 0; i < info.iterateCount; i++) {
                var dest = result.subarray(i * 16);
                mat4.identity(dest);
                translation && mat4.translate(dest, dest, info.iterFlag[0] ? translation.subarray(i*3) : translation);
                center && mat4.translate(dest, dest, info.iterFlag[0] ? center.subarray(i*3) : center);
                if (rotation) {
                    mat4.fromRotationTranslation(TMP_MATRIX, info.iterFlag[1] ? rotation.subarray(i*4) : rotation, [0, 0, 0]);
                    mat4.multiply(dest, dest, TMP_MATRIX);
                }
                if (scaleOrientation) {
                    mat4.fromRotationTranslation(TMP_MATRIX, info.iterFlag[4] ? scaleOrientation.subarray(i*4) : scaleOrientation, [0, 0, 0]);
                    mat4.multiply(dest, dest, TMP_MATRIX);
                }
                scale && mat4.scale(dest, dest, info.iterFlag[2] ? scale.subarray(i*3) : scale);
                if (scaleOrientation) {
                    XML3D.math.quat.copy(TMP_QUAT, info.iterFlag[4] ? scaleOrientation.subarray(i*4) : scaleOrientation)
                    mat4.fromRotationTranslation(TMP_MATRIX, XML3D.math.quat.negate(TMP_QUAT, TMP_QUAT), [0, 0, 0]);
                    mat4.multiply(dest, dest, TMP_MATRIX);
                }

                center && mat4.translate(dest, dest, XML3D.math.vec3.negate(TMP_VEC, info.iterFlag[3] ? center.subarray(i*3) : center));

            }
            return true;
        }
    });

})();
},{}],198:[function(require,module,exports){
(function() {
    var TMP_MATRIX = XML3D.math.mat4.create();
    var TMP_VEC = XML3D.math.vec3.create();
    var TMP_QUAT = XML3D.math.quat.create();
    var mat4 = XML3D.math.mat4;

    Xflow.registerOperator("xflow.createTransformInv", {
        outputs: [{type: 'float4x4', name: 'result'}],
        params: [{type: 'float3', source: 'translation', optional: true},
            {type: 'float4', source: 'rotation', optional: true},
            {type: 'float3', source: 'scale', optional: true},
            {type: 'float3', source: 'center', optional: true},
            {type: 'float4', source: 'scaleOrientation', optional: true}],
        evaluate: function (result, translation, rotation, scale, center, scaleOrientation, info) {
            for (var i = 0; i < info.iterateCount; i++) {
                var dest = result.subarray(i * 16);
                mat4.identity(dest);
                center && mat4.translate(dest, dest, info.iterFlag[3] ? center.subarray(i*3) : center);

                if (scaleOrientation) {
                    mat4.fromRotationTranslation(TMP_MATRIX, info.iterFlag[4] ? scaleOrientation.subarray(i*4) : scaleOrientation, [0, 0, 0]);
                    mat4.multiply(dest, dest, TMP_MATRIX);
                }
                scale && mat4.scale(dest, dest, XML3D.math.vec3.reciprocal(TMP_VEC, info.iterFlag[2] ? scale.subarray(i*3) : scale));
                if (scaleOrientation) {
                    XML3D.math.quat.copy(TMP_QUAT, info.iterFlag[4] ? scaleOrientation.subarray(i*4) : scaleOrientation);
                    mat4.fromRotationTranslation(TMP_MATRIX, XML3D.math.quat.invert(TMP_QUAT, TMP_QUAT), [0, 0, 0]);
                    mat4.multiply(dest, dest, TMP_MATRIX);
                }
                if (rotation) {
                    XML3D.math.quat.copy(TMP_QUAT, info.iterFlag[1] ? rotation.subarray(i*4) : rotation);
                    mat4.fromRotationTranslation(TMP_MATRIX, XML3D.math.quat.invert(TMP_QUAT, TMP_QUAT), [0, 0, 0]);
                    mat4.multiply(dest, dest, TMP_MATRIX);
                }
                center && mat4.translate(dest, dest, XML3D.math.vec3.negate(TMP_VEC, info.iterFlag[3] ? center.subarray(i*3) : center));
                translation && mat4.translate(dest, dest, XML3D.math.vec3.negate(TMP_VEC, info.iterFlag[0] ? translation.subarray(i*3) : translation));

            }
        }
    });
})();

},{}],199:[function(require,module,exports){
(function(){

var c_CubePositions =  [
    [-1,-1,-1], [1,-1,-1], [-1,1,-1], [1,1,-1], // front
    [-1,-1,-1], [-1,-1,1], [-1,1,-1], [-1,1,1], // left
    [-1,-1,-1], [1,-1,-1], [-1,-1,1], [1,-1,1], // top
    [1,-1,-1], [1,1,-1], [1,-1,1], [1,1,1],     // right
    [-1,1,-1], [1,1,-1], [-1,1,1], [1,1,1],     // bottom
    [-1,-1,1], [1,-1,1], [-1,1,1], [1,1,1]      // back
];
var c_CubeNormals =  [
    [0,0,-1], [0,0,-1], [0,0,-1], [0,0,-1], // front
    [-1,0,0], [-1,0,0], [-1,0,0], [-1,0,0], // left
    [0,-1,0], [0,-1,0], [0,-1,0], [0,-1,0], // top
    [1,0,0], [1,0,0], [1,0,0], [1,0,0],     // right
    [0,1,0], [0,1,0], [0,1,0], [0,1,0],     // bottom
    [0,0,1], [0,0,1], [0,0,1], [0,0,1]      // back
];
var c_CubeIndex = [
    [0,1,2,1,2,3],
    [4,5,6,5,6,7],
    [8,9,10,9,10,11],
    [12,13,14,13,14,15],
    [16,17,18,17,18,19],
    [20,21,22,21,22,23]
]

/**
 * Grid Generation
 */
Xflow.registerOperator("xflow.debug.createSkinCubes", {
    outputs: [	{type: 'int', name: 'index', customAlloc: true},
                {type: 'float3', name: 'position', customAlloc: true},
                {type: 'float3', name: 'normal', customAlloc: true},
                {type: 'int4', name: 'boneIndices', customAlloc: true},
                {type: 'float4', name: 'boneWeights', customAlloc: true}],
    params:  [{type: 'float4x4', source: 'bindTransforms', array: true},
              {type: 'float', source: 'size', array: true, optional: true}],
    alloc: function(sizes, bindTransforms)
    {
        var s = bindTransforms.length / 16;
        sizes['position'] = s * 4 * 6;
        sizes['normal'] = s * 4 * 6;
        sizes['boneIndices'] = s * 4 * 6;
        sizes['boneWeights'] = s * 4 * 6;
        sizes['index'] = s * 6 * 6;
    },
    evaluate: function(index, position, normal, boneIdx, boneWeight, bindTransforms, size) {
        var cubeCount = bindTransforms.length / 16;
        var size = (size && size[0] || 1) / 2;

        var tmpPosition = XML3D.math.vec3.create(),
            tmpNormal = XML3D.math.vec3.create();

        for(var i = 0; i < cubeCount; ++i){
            for(var j = 0; j < 6; ++j){
                for(var k = 0; k < 4; k++){
                    var localIdx = j*4+ k, globalIdx = i*6*4 + localIdx;

                    XML3D.math.vec3.copy(tmpPosition, c_CubePositions[localIdx]);
                    XML3D.math.vec3.scale(tmpPosition, tmpPosition, size);
                    XML3D.math.mat4.multiplyOffsetVec3(bindTransforms, i*16, tmpPosition, 0);
                    XML3D.math.vec3.copy(tmpNormal, c_CubeNormals[localIdx]);
                    XML3D.math.mat4.multiplyOffsetDirection(bindTransforms, i*16, tmpNormal, 0);

                    position[globalIdx*3+0] = tmpPosition[0];
                    position[globalIdx*3+1] = tmpPosition[1];
                    position[globalIdx*3+2] = tmpPosition[2];
                    normal[globalIdx*3+0] = tmpNormal[0];
                    normal[globalIdx*3+1] = tmpNormal[1];
                    normal[globalIdx*3+2] = tmpNormal[2];
                    boneIdx[globalIdx*4+0] = i;
                    boneIdx[globalIdx*4+1] = boneIdx[globalIdx*4+2] = boneIdx[globalIdx*4+3]= 0;
                    boneWeight[globalIdx*4+0] = 1;
                    boneWeight[globalIdx*4+1] = boneWeight[globalIdx*4+2] = boneWeight[globalIdx*4+3]= 0;
                }
                var globalIndexIdx = i*6*6 + j*6;
                for(var k = 0; k < 6; ++k){
                    index[globalIndexIdx+k] = i*6*4 + c_CubeIndex[j][k];
                }
            }
        }
        // We are done!
        position = position;
    }
});

}());

},{}],200:[function(require,module,exports){
Xflow.registerOperator("xflow.div", {
    outputs: [  {type: 'float', name: 'result'}],
    params:  [  {type: 'float', source: 'value1'},
                {type: 'float', source: 'value2'}],
    evaluate: function(result, value1, value2, info) {
        result[0] = value1[0] / value2[0];
    }

});

},{}],201:[function(require,module,exports){
Xflow.registerOperator("xflow.flipNormal", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'value'}],
    evaluate: function(result, value, info) {
        for(var i = 0; i<info.iterateCount*3; i++)
            result[i] = -value[i];
    }
});

},{}],202:[function(require,module,exports){
Xflow.registerOperator("xflow.flipVerticalImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'} ],
    evaluate: function(result, image) {
        var width = image.width;
        var height = image.height;

        var destpix = result.data;
        var srcpix = image.data;

        for (var y = 0; y < height; ++y) {
            for (var x = 0; x < width; ++x) {
                var rowOffset = y * width;
                var srcOffset = (rowOffset + x) * 4;
                var dstOffset = (rowOffset + ((width-1) - x)) * 4;
                destpix[dstOffset] =  srcpix[srcOffset];
                destpix[dstOffset+1] = srcpix[srcOffset+1];
                destpix[dstOffset+2] = srcpix[srcOffset+2];
                destpix[dstOffset+3] = srcpix[srcOffset+3];
            }
        }
        return true;
    }
});

},{}],203:[function(require,module,exports){
Xflow.registerOperator("xflow.forwardKinematics", {
    outputs: [  {type: 'float4x4',  name: 'result', customAlloc: true}],
    params:  [  {type: 'int',       source: 'parent', array: true },
                {type: 'float4x4',  source: 'xform', array: true }],
    alloc: function(sizes, parent, xform)
    {
        var length = Math.min(parent.length, xform.length / 16);
        sizes['result'] = length;
    },
    evaluate: function(result, parent,xform, info) {

        var boneCount = result.length / 16;

        var computed = [];
        //For each bone do:
        for(var i = 0; i < boneCount;){
            if(!computed[i]) {
                var p = parent[i];
                if(p >= 0){
                    //This bone has a parent bone
                    if(!computed[p]){
                        //The parent bone's transformation matrix hasn't been computed yet
                        while(parent[p] >= 0 && !computed[parent[p]]) p = parent[p];

                        if(parent[p] >= 0)
                            XML3D.math.mat4.multiplyOffset(result, p*16, xform, p*16, result, parent[p]*16);
                        else
                            for(var j = 0; j < 16; j++) {
                                result[p*16+j] = xform[p*16+j];
                            }
                        computed[p] = true;
                        continue;
                    }
                    else {
                        XML3D.math.mat4.multiplyOffset(result, i*16, xform, i*16, result,  p*16);
                    }
                }
                else{
                    for(var j = 0; j < 16; j++) {
                        result[i*16+j] = xform[i*16+j];
                    }
                }
                computed[i] = true;
            }
            i++;
        }
    }
});

},{}],204:[function(require,module,exports){
Xflow.registerOperator("xflow.forwardKinematicsInv", {
    outputs: [  {type: 'float4x4',  name: 'result', customAlloc: true}],
    params:  [  {type: 'int',       source: 'parent', array: true },
                {type: 'float4x4',  source: 'xform', array: true }],
    alloc: function(sizes, parent, xform)
    {
        var length = Math.min(parent.length, xform.length / 16);
        sizes['result'] = length;
    },
    evaluate: function(result, parent,xform, info) {
        var boneCount = xform.length / 16;

        var computed = [];
        //For each bone do:
        for(var i = 0; i < boneCount;){
            if(!computed[i]) {
                var p = parent[i];
                if(p >= 0){
                    //This bone has a parent bone
                    if(!computed[p]){
                        //The parent bone's transformation matrix hasn't been computed yet
                        while(parent[p] >= 0 && !computed[parent[p]]) p = parent[p];
                        //The current bone has a parent and its transform hasn't been computed yet

                        if(parent[p] >= 0)
                            XML3D.math.mat4.multiplyOffset(result, p*16, result, parent[p]*16, xform, p*16);
                        else
                            for(var j = 0; j < 16; j++) {
                                result[p*16+j] = xform[p*16+j];
                            }
                        computed[p] = true;
                        continue;

                    }
                    else {
                        XML3D.math.mat4.multiplyOffset(result, i*16,  result,  p*16, xform, i*16);
                    }
                }
                else{
                    for(var j = 0; j < 16; j++) {
                        result[i*16+j] = xform[i*16+j];
                    }
                }
                computed[i] = true;
            }
            i++;
        }
    }
});

},{}],205:[function(require,module,exports){
// Based on: http://web.archive.org/web/20100310063925/http://dem.ocracy.org/libero/photobooth/

Xflow.registerOperator("xflow.funMirrorImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'},
               {type: 'float', source : 'time'} ],
    evaluate: function(result, image, time) {
        var width = result.width;
        var height = result.height;
        var time = time[0];

        var s = image.data;
        var d = result.data;

        for (var y = 0; y < height; ++y) {
            for (var x = 0; x < width; ++x) {

                /*original coordinates*/
                // [0.0 ,1.0] x [0.0, 1.0]
                var coordX = x / width;
                var coordY = y / height;

                // [-1.0 ,1.0] x [-1.0, 1.0]
                var normCoordX = 2.0 * coordX - 1.0;
                var normCoordY = 2.0 * coordY - 1.0;

                /*go to polar coordinates*/
                var r = Math.sqrt(normCoordX*normCoordX + normCoordY*normCoordY); // length(normCoord)
                var phi = Math.atan2(normCoordY, normCoordX);

                /*squeeze and vary it over time*/
                r = Math.pow(r, 1.0/1.8) * time;

                /*back to cartesian coordinates*/
                normCoordX = r * Math.cos(phi);
                normCoordY = r * Math.sin(phi);
                // [0.0 ,1.0] x [0.0, 1.0]
                coordX = normCoordX / 2.0 + 0.5;
                coordY = normCoordY / 2.0 + 0.5;

                var sX = Math.round(coordX * width);
                var sY = Math.round(coordY * height);

                var i = (sY * width + sX)*4;
                var r = s[i];
                var g = s[i + 1];
                var b = s[i + 2];
                var a = s[i + 3];

                /*color the fragment with calculated texture*/
                var i = (y * width + x)*4;
                d[i] = r;
                d[i + 1] = g;
                d[i + 2] = b;
                d[i + 3] = a;
            }
        }
        return true;
    }
});

},{}],206:[function(require,module,exports){

function fetch(result, value, index, components){
    for(var i = 0; i < index.length; ++i) {
        var offset = index[i] * components;
        var j = components;
        while(j--) {
            result[i*components + j] = value[offset + j];
        }
    }
}

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'float', name: 'result'}],
    params:  [  {type: 'float', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 1);
    }
});

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'float2', name: 'result'}],
    params:  [  {type: 'float2', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 2);
    }
});

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 4);
    }
});


Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'float4', name: 'result'}],
    params:  [  {type: 'float4', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 4);
    }
});

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'float4x4', name: 'result'}],
    params:  [  {type: 'float4x4', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 16);
    }
});


Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'int', name: 'result'}],
    params:  [  {type: 'int', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 1);
    }
});

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'bool', name: 'result'}],
    params:  [  {type: 'bool', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 1);
    }
});

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'byte', name: 'result'}],
    params:  [  {type: 'byte', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 1);
    }
});



Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'ubyte', name: 'result'}],
    params:  [  {type: 'ubyte', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 1);
    }
});

},{}],207:[function(require,module,exports){
Xflow.registerOperator("xflow.grayscaleImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'} ],
    evaluate: function(result, image) {
        var width = image.width;
        var height = image.height;

        var s = image.data;
        var d = result.data;
        for (var i = 0; i < s.length; i += 4) {
            var r = s[i];
            var g = s[i + 1];
            var b = s[i + 2];
            var a = s[i + 3];
            // CIE luminance for the RGB
            // The human eye is bad at seeing red and blue, so we de-emphasize them.
            var v = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            d[i] = d[i + 1] = d[i + 2] = v
            d[i + 3] = a;
        }
        return true;
    }
});

},{}],208:[function(require,module,exports){
require("./add.js");
require("./bufferSelect.js");
require("./clampImage.js");
require("./convoluteImage.js");
require("./createIGIndex.js");
require("./createTransform.js");
require("./createTransformInv.js");
require("./debug.js");
require("./flipNormal.js");
require("./flipVerticalImage.js");
require("./forwardKinematics.js");
require("./forwardKinematicsInv.js");
require("./funMirrorImage.js");
require("./get.js");
require("./grayscaleImage.js");
require("./lerp3seq.js");
require("./magnitudeImage.js");
require("./morph3.js");
require("./mul4x4.js");
require("./noiseImage.js");
require("./normalize3.js");
require("./popartImage.js");
require("./rgbePNGtoFloat.js");
require("./selectBool.js");
require("./selectTransform.js");
require("./sepiaImage.js");
require("./skinDirection.js");
require("./skinPosition.js");
require("./slerpseq.js");
require("./sobelImage.js");
require("./sub3.js");
require("./div.js");

},{"./add.js":192,"./bufferSelect.js":193,"./clampImage.js":194,"./convoluteImage.js":195,"./createIGIndex.js":196,"./createTransform.js":197,"./createTransformInv.js":198,"./debug.js":199,"./div.js":200,"./flipNormal.js":201,"./flipVerticalImage.js":202,"./forwardKinematics.js":203,"./forwardKinematicsInv.js":204,"./funMirrorImage.js":205,"./get.js":206,"./grayscaleImage.js":207,"./lerp3seq.js":209,"./magnitudeImage.js":210,"./morph3.js":211,"./mul4x4.js":212,"./noiseImage.js":213,"./normalize3.js":214,"./popartImage.js":215,"./rgbePNGtoFloat.js":216,"./selectBool.js":217,"./selectTransform.js":218,"./sepiaImage.js":219,"./skinDirection.js":220,"./skinPosition.js":221,"./slerpseq.js":222,"./sobelImage.js":223,"./sub3.js":224}],209:[function(require,module,exports){
var binarySearch = require("../../utils/utils").binarySearch;
var XC = require("../../interface/constants.js");

Xflow.registerOperator("xflow.lerpSeq", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'sequence'},
        {type: 'float', source: 'key'}],
    mapping: [  { name: 'value1', source: 'sequence', sequence: XC.SEQUENCE.PREV_BUFFER, keySource: 'key'},
        { name: 'value2', source: 'sequence', sequence: XC.SEQUENCE.NEXT_BUFFER, keySource: 'key'},
        { name: 'weight', source: 'sequence', sequence: XC.SEQUENCE.LINEAR_WEIGHT, keySource: 'key'}],
    evaluate_core: function(result, value1, value2, weight){
        var invWeight = 1 - weight[0];
        result[0] = invWeight*value1[0] + weight[0]*value2[0];
        result[1] = invWeight*value1[1] + weight[0]*value2[1];
        result[2] = invWeight*value1[2] + weight[0]*value2[2];
    }
});


Xflow.registerOperator("xflow.lerpSeqAsync", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'sequence'},
        {type: 'float', source: 'key'}],
    mapping: [  { name: 'value1', source: 'sequence', sequence: XC.SEQUENCE.PREV_BUFFER, keySource: 'key'},
        { name: 'value2', source: 'sequence', sequence: XC.SEQUENCE.NEXT_BUFFER, keySource: 'key'},
        { name: 'weight', source: 'sequence', sequence: XC.SEQUENCE.LINEAR_WEIGHT, keySource: 'key'}],
    evaluate_async: function(result, value1, value2, weight, info, callback){
        var i = info.iterateCount, off0, off1, off2;
        while(i--){
            off0 = (info.iterFlag[0] ? i : 0)*3;
            off1 = (info.iterFlag[1] ? i : 0)*3;
            off2 = info.iterFlag[2] ? i : 0;
            var invWeight = 1 - weight[off2];
            result[i*3] = invWeight*value1[off0] + weight[off2]*value2[off1];
            result[i*3+1] = invWeight*value1[off0+1] + weight[off2]*value2[off1+1];
            result[i*3+2] = invWeight*value1[off0+2] + weight[off2]*value2[off1+2];
        }
        window.setTimeout(callback, 200);
    }
});


Xflow.registerOperator("xflow.lerpKeys", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float', source: 'keys', array: true},
        {type: 'float3', source: 'values', array: true},
        {type: 'float', source: 'key'}],
    alloc: function(sizes, keys, values, key)
    {
        sizes['result'] = 3;
    },
    evaluate: function(result, keys, values, key) {
        var maxIdx = Math.min(keys.length, Math.floor(values.length / 3));
        var idx = binarySearch(keys, key[0], maxIdx);

        if(idx < 0 || idx == maxIdx - 1){
            idx = Math.max(0,idx);
            result[0] = values[3*idx];
            result[1] = values[3*idx+1];
            result[2] = values[3*idx+2];
        }
        else{
            var weight = (key[0] - keys[idx]) / (keys[idx+1] - keys[idx]);
            var invWeight = 1 - weight;
            result[0] = invWeight*values[3*idx] + weight*values[3*idx + 3];
            result[1] = invWeight*values[3*idx+1] + weight*values[3*idx + 4];
            result[2] = invWeight*values[3*idx+2] + weight*values[3*idx + 5];
        }
    }
});






},{"../../interface/constants.js":187,"../../utils/utils":238}],210:[function(require,module,exports){
Xflow.registerOperator("xflow.magnitudeImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image1'} ],
    params:  [
        {type: 'texture', source : 'image1'},
        {type: 'texture', source : 'image2'}
    ],
    evaluate: function(result, image1, image2) {
        var inpix1 = image1.data;
        var inpix2 = image2.data;
        var outpix = result.data;

        var len = inpix1.length;
        for (var i = 0 ; i < len; i+=1) {
            var val1 = inpix1[i];
            var val2 = inpix2[i];
            outpix[i] = Math.sqrt(val1*val1 + val2*val2);
        }
        return true;
    }
});

},{}],211:[function(require,module,exports){

Xflow.registerOperator("xflow.morph", {
    outputs: [{type: 'float3', name: 'result'}],
    params:  [
        { type: 'float3', source: 'value' },
        { type: 'float3', source: 'valueAdd'},
        { type: 'float', source: 'weight'}
    ],
    evaluate: function(result, value, valueAdd, weight, info) {
        for(var i = 0; i < info.iterateCount; i++){
            var w = weight[info.iterFlag[2] ? i : 0];
            result[3*i] = value[ info.iterFlag[0] ? 3*i : 0] + w * valueAdd[info.iterFlag[1] ? 3*i : 0];
            result[3*i+1] = value[ info.iterFlag[0] ? 3*i+1 : 1] + w * valueAdd[info.iterFlag[1] ? 3*i+1 : 1];
            result[3*i+2] = value[ info.iterFlag[0] ? 3*i+2 : 2] + w * valueAdd[info.iterFlag[1] ? 3*i+2 : 2];
        }
        return true;
    },
    evaluate_core: function(result, value, valueAdd, weight){
        result[0] = value[0] + weight[0] * valueAdd[0];
        result[1] = value[1] + weight[0] * valueAdd[1];
        result[2] = value[2] + weight[0] * valueAdd[2];
    }
});

},{}],212:[function(require,module,exports){
Xflow.registerOperator("xflow.mul", {
    outputs: [  {type: 'float4x4', name: 'result'}],
    params:  [  {type: 'float4x4', source: 'value1'},
                {type: 'float4x4', source: 'value2'}],
    evaluate: function(result, value1, value2, info) {
        for(var i = 0; i < info.iterateCount; i++)
        {
            XML3D.math.mat4.multiplyOffset(result, i*16,
                value1,  info.iterFlag[0] ? i*16 : 0,
                value2, info.iterFlag[1] ? i*16 : 0);
        }
    }
});

},{}],213:[function(require,module,exports){

Xflow.registerOperator("xflow.noiseImage", {
    outputs: [ {type: 'texture', name : 'image', customAlloc: true} ],
    params:  [ {type: 'int', source: 'width'},
               {type: 'int', source:'height'},
               {type: 'float2', source: 'scale'},
               {type: 'float', source: 'minFreq'},
               {type: 'float', source: 'maxFreq'} ],
    alloc: function(sizes, width, height, scale, minFreq, maxFreq) {
        var samplerConfig = new Xflow.SamplerConfig;
        samplerConfig.setDefaults();
        sizes['image'] = {
            imageFormat : {width: width[0], height :height[0]},
            samplerConfig : samplerConfig
        };
    },
    evaluate: function(image, width, height, scale, minFreq, maxFreq) {
        width = width[0];
        height = height[0];
        minFreq = minFreq[0];
        maxFreq = maxFreq[0];

        var id = image;
        var pix = id.data;
        this.noise = this.noise || new SimplexNoise();
        var noise = this.noise;

        var useTurbulence = minFreq != 0.0 && maxFreq != 0.0 && minFreq < maxFreq;

        var snoise = function(x,y) {
            return noise.noise(x, y); // noise.noise returns values in range [-1,1]
            //return 2.0 * noise.noise(x, y) - 1.0; // this code is for noise value in range [0,1]
        };

        var turbulence = function(minFreq, maxFreq, s, t) {
            var value = 0;
            for (var f = minFreq; f < maxFreq; f *= 2)
            {
                value += Math.abs(snoise(s * f, t * f))/f;
            }
            return value;
        };

        for (var y = 0; y < height; ++y)
        {
            var t = y / height * scale[1];
            var invWidth = 1.0 / width;

            for (var x = 0; x < width; ++x)
            {
                var s = x * invWidth * scale[0];
                var v = useTurbulence ? turbulence(minFreq, maxFreq, s, t) : snoise(s, t);
                var offset = (x * width + y) * 4;
                pix[offset] =  Math.floor(v * 255);
                pix[offset+1] = Math.floor(v * 255);
                pix[offset+2] = Math.floor(v * 255);
                pix[offset+3] = 255;
            }
        }

        /* Fill with green color
        for (var y = 0; y < height; ++y)
        {
            for (var x = 0; x < width; ++x)
            {
                var offset = (x * width + y) * 4;
                pix[offset] =  0
                pix[offset+1] = 255;
                pix[offset+2] = 0;
                pix[offset+3] = 255;
            }
        }
        */

        return true;
    }
});

},{}],214:[function(require,module,exports){

Xflow.registerOperator("xflow.normalize", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'value'}],
    evaluate: function(result, value, info) {
        for(var i = 0; i < info.iterateCount; i++) {
            var offset = 3*i;
            var x = value[offset];
            var y = value[offset+1];
            var z = value[offset+2];
            var l = 1.0/Math.sqrt(x*x+y*y+z*z);
            result[offset] = x*l;
            result[offset+1] = y*l;
            result[offset+2] = z*l;
        }
    }
});

},{}],215:[function(require,module,exports){

// Based on http://kodemongki.blogspot.de/2011/06/kameraku-custom-shader-effects-example.html
Xflow.registerOperator("xflow.popartImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'},
        {type: 'float', source : 'time'} ],
    evaluate: function(result, image, time) {
        var width = image.width;
        var height = image.height;

        var s = image.data;
        var d = result.data;
        for (var i = 0; i < s.length; i += 4) {
            var r = s[i] / 255;
            var g = s[i + 1] / 255;
            var b = s[i + 2] / 255;
            var a = s[i + 3] / 255;

            var y = 0.3 * r + 0.59 * g + 0.11 * b;
            y = y < 0.3 ? 0.0 : (y < 0.6 ? 0.5 : 1.0);
            if (y == 0.5) {
                d[i]   = 0.8 * 255;
                d[i+1] = 0;
                d[i+2] = 0;
            } else if (y == 1.0) {
                d[i]   = 0.9 * 255;
                d[i+1] = 0.9 * 255;
                d[i+2] = 0;
            } else {
                d[i] = 0;
                d[i+1] = 0;
                d[i+2] = 0;
            }
            d[i+3] = s[i+3];
        }
        return true;
    }
});

},{}],216:[function(require,module,exports){
var SamplerConfig = require("../../interface/data.js").SamplerConfig;
var XC = require("../../interface/constants.js");

Xflow.registerOperator("xflow.rgbePNGtoFloat", {
    outputs: [ {type: 'texture', name : 'result', customAlloc: true } ],
    params:  [
        {type: 'texture', source : 'image'}
    ],
    alloc: function (sizes, image) {
        var samplerConfig = new SamplerConfig;
        samplerConfig.setDefaults();
        samplerConfig.minFilter = XC.TEX_FILTER_TYPE.NEAREST;
        samplerConfig.magFilter = XC.TEX_FILTER_TYPE.NEAREST;
        sizes["result"] = {
            imageFormat : {
                width: image.width,
                height: image.height,
                texelType: XC.TEXTURE_TYPE.FLOAT,
                texelFormat: XC.TEXTURE_FORMAT.RGB
            },
            samplerConfig: samplerConfig
        }
    },

    evaluate: function(result, image) {
        for (var idx = 0; idx < image.data.length; idx += 4) {
            var rgbe = image.data.subarray(idx, idx + 4);
            var f = 0.0;
            var e = rgbe[3];

            if (e > 0.0)
                f = Math.pow(2.0, e - (128.0 + 8.0));

            var rgb = new Float32Array(3);
            rgb[0] = rgbe[0] * f;
            rgb[1] = rgbe[1] * f;
            rgb[2] = rgbe[2] * f;
            result.data.set(rgb, idx / 4 * 3);
        }
        return true;
    }
});

},{"../../interface/constants.js":187,"../../interface/data.js":188}],217:[function(require,module,exports){

Xflow.registerOperator("xflow.selectBool", {
    outputs: [ {type: 'bool', name : 'result', customAlloc: true} ],
    params:  [ {type: 'int', source : 'index'},
               {type: 'bool', source: 'value'} ],
    alloc: function(sizes, index, value) {
        sizes['result'] = 1;
    },
    evaluate: function(result, index, value) {
        var i = index[0];
        if (i < value.length) {
            result[0] = value[i];
        } else {
            result[0] = false;
        }
    }
});

},{}],218:[function(require,module,exports){

Xflow.registerOperator("xflow.selectTransform", {
    outputs: [ {type: 'float4x4', name : 'result', customAlloc: true} ],
    params:  [ {type: 'int', source : 'index'},
               {type: 'float4x4', source: 'transform'} ],
    alloc: function(sizes, index, transform) {
        sizes['result'] = 1;
    },
    evaluate: function(result, index, transform) {
        var i = 16 * index[0];
        if (i < transform.length && i+15 < transform.length) {
            result[0] = transform[i+0];
            result[1] = transform[i+1];
            result[2] = transform[i+2];
            result[3] = transform[i+3];
            result[4] = transform[i+4];
            result[5] = transform[i+5];
            result[6] = transform[i+6];
            result[7] = transform[i+7];
            result[8] = transform[i+8];
            result[9] = transform[i+9];
            result[10] = transform[i+10];
            result[11] = transform[i+11];
            result[12] = transform[i+12];
            result[13] = transform[i+13];
            result[14] = transform[i+14];
            result[15] = transform[i+15];
        } else {
            result[0] = 1;
            result[1] = 0;
            result[2] = 0;
            result[3] = 0;
            result[4] = 0;
            result[5] = 1;
            result[6] = 0;
            result[7] = 0;
            result[8] = 0;
            result[9] = 0;
            result[10] = 1;
            result[11] = 0;
            result[12] = 0;
            result[13] = 0;
            result[14] = 0;
            result[15] = 1;
        }
    }
});

},{}],219:[function(require,module,exports){

Xflow.registerOperator("xflow.sepiaImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'} ],
    evaluate: function(result, image) {
        var s = image.data;
        var d = result.data;
        var r = 0, g = 0, b = 0;
        for(var i = 0 ; i < s.length; i += 4) {
            r = (s[i] * 0.393 + s[i+1] * 0.769 + s[i+2] * 0.189);
            g = (s[i] * 0.349 + s[i+1] * 0.686 + s[i+2] * 0.168);
            b = (s[i] * 0.272 + s[i+1] * 0.534 + s[i+2] * 0.131);
            if (r>255) r = 255;
            if (g>255) g = 255;
            if (b>255) b = 255;
            if (r<0) r = 0;
            if (g<0) g = 0;
            if (b<0) b = 0;
            d[i] = r;
            d[i+1] = g;
            d[i+2] = b;
            d[i+3] = 255;
        }
        return true;
    }
});

},{}],220:[function(require,module,exports){

Xflow.registerOperator("xflow.skinDirection", {
    outputs: [  {type: 'float3', name: 'result' }],
    params:  [  {type: 'float3', source: 'dir' },
                {type: 'int4', source: 'boneIdx' },
                {type: 'float4', source: 'boneWeight' },
                {type: 'float4x4', source: 'boneXform', array: true } ],
    evaluate: function(result, dir,boneIdx,boneWeight,boneXform, info) {
        var vec3 = XML3D.math.vec3,
            mat4 = XML3D.math.mat4;
        var r = vec3.create();
        var tmp =  vec3.create();

        for(var i = 0; i< info.iterateCount;++i) {
            var offset = i*3;
            r[0] = r[1] = r[2] = +0;
            for(var j = 0; j < 4; j++) {
                var weight = boneWeight[info.iterFlag[2] ? i*4+j : j];
                if (weight) {
                    var mo = boneIdx[info.iterFlag[1] ? i*4+j : j]*16;

                    mat4.multiplyOffsetDirection(boneXform, mo, dir, offset, tmp);
                    vec3.scale(tmp, tmp, weight);
                    vec3.add(r, r, tmp);
                }
            }
            vec3.normalize(r, r);
            result[offset] = r[0];
            result[offset+1] = r[1];
            result[offset+2] = r[2];
        }
    }
});

},{}],221:[function(require,module,exports){

Xflow.registerOperator("xflow.skinPosition", {
    outputs: [  {type: 'float3', name: 'result' }],
    params:  [  {type: 'float3', source: 'pos' },
                {type: 'int4', source: 'boneIdx' },
                {type: 'float4', source: 'boneWeight' },
                {type: 'float4x4', source: 'boneXform', array: true } ],
    evaluate: function(result, pos,boneIdx,boneWeight,boneXform, info) {
        var vec3 = XML3D.math.vec3,
            mat4 = XML3D.math.mat4;
        var r = vec3.create();
        var tmp =  vec3.create();

        for(var i = 0; i< info.iterateCount;++i) {
            var offset = i*3;
            r[0] = r[1] = r[2] = +0;
            for(var j = 0; j < 4; j++) {
                var weight = boneWeight[info.iterFlag[2] ? i*4+j : j];
                if (weight) {
                    var mo = boneIdx[info.iterFlag[1] ? i*4+j : j]*16;

                    mat4.multiplyOffsetVec3(boneXform, mo, pos, offset, tmp);
                    vec3.scale(tmp, tmp, weight);
                    vec3.add(r, r, tmp);
                }
            }
            result[offset] = r[0];
            result[offset+1] = r[1];
            result[offset+2] = r[2];
        }
    }
});

},{}],222:[function(require,module,exports){
var binarySearch = require("../../utils/utils").binarySearch;
var XC = require("../../interface/constants.js");

Xflow.registerOperator("xflow.slerpSeq", {
    outputs: [  {type: 'float4', name: 'result'}],
    params:  [  {type: 'float4', source: 'sequence'},
                {type: 'float', source: 'key'}],
    mapping: [  {name: 'value1', source: 'sequence', sequence: XC.SEQUENCE.PREV_BUFFER, keySource: 'key'},
                {name: 'value2',  source: 'sequence', sequence: XC.SEQUENCE.NEXT_BUFFER, keySource: 'key'},
                {name: 'weight',  source: 'sequence', sequence: XC.SEQUENCE.LINEAR_WEIGHT, keySource: 'key'}],
    evaluate: function(result, value1, value2, weight, info) {
        for(var i = 0; i < info.iterateCount; ++i){
            XML3D.math.quat.slerpOffset(  value1,info.iterFlag[0] ? i*4 : 0,
                                          value2,info.iterFlag[1] ? i*4 : 0,
                                          weight[0],
                                          result, i*4, true);
        }
    }
});


Xflow.registerOperator("xflow.slerpKeys", {
    outputs: [  {type: 'float4', name: 'result'}],
    params:  [  {type: 'float', source: 'keys', array: true},
        {type: 'float4', source: 'values', array: true},
        {type: 'float', source: 'key'}],
    alloc: function(sizes, keys, values, key)
    {
        sizes['result'] = 4;
    },
    evaluate: function(result, keys, values, key) {
        var maxIdx = Math.min(keys.length, Math.floor(values.length / 4));
        var idx = binarySearch(keys, key[0], maxIdx);

        if(idx < 0 || idx == maxIdx - 1){
            idx = Math.max(0,idx);
            result[0] = values[4*idx];
            result[1] = values[4*idx+1];
            result[2] = values[4*idx+2];
            result[3] = values[4*idx+3];
        }
        else{
            var weight = (key[0] - keys[idx]) / (keys[idx+1] - keys[idx]);
            XML3D.math.quat.slerpOffset(  values, idx*4,
                values,(idx+1)*4, weight,
                result, 0, true);
        }
    }
});

},{"../../interface/constants.js":187,"../../utils/utils":238}],223:[function(require,module,exports){

// Code portions from http://www.html5rocks.com/en/tutorials/canvas/imagefilters/
(function() {
    Xflow.Filters = {};

    var tmpCanvas = null;
    var tmpCtx = null;

    Xflow.Filters.createImageData = function(w,h) {
        if (!tmpCanvas)
            tmpCanvas = document.createElement('canvas');
        if (!tmpCtx)
            tmpCtx = tmpCanvas.getContext('2d');
        return tmpCtx.createImageData(w, h);
    };

    Xflow.Filters.createImageDataFloat32 = function(w, h) {
        return {width: w, height: h, data: new Float32Array(w * h * 4)};
    };

    Xflow.Filters.grayscale = function(inpixels, outpixels, args) {
            var s = inpixels.data;
            var d = outpixels.data;
            for (var i=0; i<s.length; i+=4) {
                var r = s[i];
                var g = s[i+1];
                var b = s[i+2];
                var a = s[i+3];
                // CIE luminance for the RGB
                // The human eye is bad at seeing red and blue, so we de-emphasize them.
                var v = 0.2126*r + 0.7152*g + 0.0722*b;
                d[i] = d[i+1] = d[i+2] = v
                d[i+3] = a;
            }
            return inpixels;
    };

    Xflow.Filters.convolute = function(inpixels, outpixels, weights, opaque) {
            var side = Math.round(Math.sqrt(weights.length));
            var halfSide = Math.floor(side/2);
            var src = inpixels.data;
            var sw = inpixels.width;
            var sh = inpixels.height;
            // pad output by the convolution matrix
            var w = sw;
            var h = sh;
            var dst = outpixels.data;
            // go through the destination image pixels
            var alphaFac = opaque ? 1 : 0;
            for (var y=0; y<h; y++) {
                for (var x=0; x<w; x++) {
                    var sy = y;
                    var sx = x;
                    var dstOff = (y*w+x)*4;
                    // calculate the weighed sum of the source image pixels that
                    // fall under the convolution matrix
                    var r=0, g=0, b=0, a=0;
                    for (var cy=0; cy<side; cy++) {
                        for (var cx=0; cx<side; cx++) {
                            var scy = sy + cy - halfSide;
                            var scx = sx + cx - halfSide;
                            if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                                var srcOff = (scy*sw+scx)*4;
                                var wt = weights[cy*side+cx];
                                r += src[srcOff] * wt;
                                g += src[srcOff+1] * wt;
                                b += src[srcOff+2] * wt;
                                a += src[srcOff+3] * wt;
                            }
                        }
                    }
                    dst[dstOff] = r;
                    dst[dstOff+1] = g;
                    dst[dstOff+2] = b;
                    dst[dstOff+3] = a + alphaFac*(255-a);
                }
            }
            return outpixels;
        };
/*
    Xflow.Filters.convoluteFloat32 = function(pixels, weights, opaque) {
        var side = Math.round(Math.sqrt(weights.length));
        var halfSide = Math.floor(side / 2);

        var src = pixels.data;
        var sw = pixels.width;
        var sh = pixels.height;

        var w = sw;
        var h = sh;
        var output = {
            width: w, height: h, data: new Float32Array(w * h * 4)
        };
        var dst = output.data;

        var alphaFac = opaque ? 1 : 0;

        for (var y = 0; y < h; y++) {
            for (var x = 0; x < w; x++) {
                var sy = y;
                var sx = x;
                var dstOff = (y * w + x) * 4;
                var r = 0, g = 0, b = 0, a = 0;
                for (var cy = 0; cy < side; cy++) {
                    for (var cx = 0; cx < side; cx++) {
                        var scy = Math.min(sh - 1, Math.max(0, sy + cy - halfSide));
                        var scx = Math.min(sw - 1, Math.max(0, sx + cx - halfSide));
                        var srcOff = (scy * sw + scx) * 4;
                        var wt = weights[cy * side + cx];
                        r += src[srcOff] * wt;
                        g += src[srcOff + 1] * wt;
                        b += src[srcOff + 2] * wt;
                        a += src[srcOff + 3] * wt;
                    }
                }
                dst[dstOff] = r;
                dst[dstOff + 1] = g;
                dst[dstOff + 2] = b;
                dst[dstOff + 3] = a + alphaFac * (255 - a);
            }
        }
        return output;
    }
*/
}());

function float4(x,y,z,w) {
    var v = new Float32Array(4);
    switch (arguments.length) {
        case 0:
            v[0] = 0;
            v[1] = 0;
            v[2] = 0;
            v[3] = 0;
            break;
        case 1:
            v[0] = x;
            v[1] = x;
            v[2] = x;
            v[3] = x;
            break;
        case 2:
            v[0] = x;
            v[1] = y;
            v[2] = 0;
            v[3] = 0;
            break;
        case 3:
            v[0] = x;
            v[1] = y;
            v[2] = z;
            v[3] = 0;
            break;
        default:
            v[0] = x;
            v[1] = y;
            v[2] = z;
            v[3] = w;
    }
    return v;
}

function hypot(a, b)
{
    return Math.sqrt(a*a + b*b);
}

function hypot4(a, b)
{
    return float4(hypot(a[0], b[0]),
                  hypot(a[1], b[1]),
                  hypot(a[2], b[2]),
                  hypot(a[3], b[3]));
}

function hypot4To(r, a, b)
{
    r[0] = hypot(a[0], b[0]);
    r[1] = hypot(a[1], b[1]);
    r[2] = hypot(a[2], b[2]);
    r[3] = hypot(a[3], b[3]);
}

function getTexel2D(imagedata, x, y) {
    var offset = (y * imagedata.width + x) * 4;
    var data = imagedata.data;
    var color = new Float32Array(4);
    color[0] = data[offset] / 255.0;
    color[1] = data[offset+1] / 255.0;
    color[2] = data[offset+2] / 255.0;
    color[3] = data[offset+3] / 255.0;
    return color;
}

function getTexel2DTo(color, imagedata, x, y) {
    var offset = (y * imagedata.width + x) * 4;
    var data = imagedata.data;
    color[0] = data[offset] / 255.0;
    color[1] = data[offset+1] / 255.0;
    color[2] = data[offset+2] / 255.0;
    color[3] = data[offset+3] / 255.0;
    return color;
}

function setTexel2D(imagedata, x, y, color) {
    var offset = (y * imagedata.width + x) * 4;
    var data = imagedata.data;
    data[offset] = color[0] * 255.0 ;
    data[offset+1] = color[1] * 255.0;
    data[offset+2] = color[2] * 255.0;
    data[offset+3] = color[3] * 255.0;
}

Xflow.registerOperator("xflow.sobelImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'} ],
    evaluate: function(result, image) {
        var width = image.width;
        var height = image.height;

        // Sobel filter, AnySL method
        var gx = float4(0.0);
        var gy = float4(0.0);
        var i00 = float4();
        var i00 = float4();
        var i10 = float4();
        var i20 = float4();
        var i01 = float4();
        var i11 = float4();
        var i21 = float4();
        var i02 = float4();
        var i12 = float4();
        var i22 = float4();
        var color = float4();

        for (var y = 0; y < height; ++y)
        {
            for (var x = 0; x < width; ++x)
            {
                /* Read each texel component and calculate the filtered value using neighbouring texel components */
                if ( x >= 1 && x < (width-1) && y >= 1 && y < height - 1)
                {
                    getTexel2DTo(i00, image, x-1, y-1);
                    getTexel2DTo(i10, image, x, y-1);
                    getTexel2DTo(i20, image, x+1, y-1);
                    getTexel2DTo(i01, image, x-1, y);
                    getTexel2DTo(i11, image, x, y);
                    getTexel2DTo(i21, image, x+1, y);
                    getTexel2DTo(i02, image, x-1, y+1);
                    getTexel2DTo(i12, image, x, y+1);
                    getTexel2DTo(i22, image, x+1, y+1);

                    gx[0] = i00[0] + 2 * i10[0] + i20[0] - i02[0]  - 2 * i12[0] - i22[0];
                    gx[1] = i00[1] + 2 * i10[1] + i20[1] - i02[1]  - 2 * i12[1] - i22[1];
                    gx[2] = i00[2] + 2 * i10[2] + i20[2] - i02[2]  - 2 * i12[2] - i22[2];

                    gy[0] = i00[0] - i20[0]  + 2*i01[0] - 2*i21[0] + i02[0]  -  i22[0];
                    gy[1] = i00[1] - i20[1]  + 2*i01[1] - 2*i21[1] + i02[1]  -  i22[1];
                    gy[2] = i00[2] - i20[2]  + 2*i01[2] - 2*i21[2] + i02[2]  -  i22[2];

                    /* taking root of sums of squares of Gx and Gy */
                    hypot4To(color, gx, gy);
                    color[0]/=2;
                    color[1]/=2;
                    color[2]/=2;
                    color[3]=1.0;
                    setTexel2D(result, x, y, color);
                }
            }
        }



// Sobel filter with separate steps
//
//        var vertical = Xflow.Filters.createImageDataFloat32(width, height);
//        Xflow.Filters.convolute(result, vertical,
//            [ -1, 0, 1,
//              -2, 0, 2,
//              -1, 0, 1 ]);
//        var horizontal = Xflow.Filters.createImageDataFloat32(width, height);
//        Xflow.Filters.convolute(result, horizontal,
//            [ -1, -2, -1,
//               0,  0,  0,
//               1,  2,  1 ]);
//
//        for (var i=0; i<result.data.length; i+=4) {
//            // make the vertical gradient red
//            var v = Math.abs(vertical.data[i]);
//            result.data[i] = v;
//            // make the horizontal gradient green
//            var h = Math.abs(horizontal.data[i]);
//            result.data[i+1] = h;
//            // and mix in some blue for aesthetics
//            result.data[i+2] = (v+h)/4;
//            result.data[i+3] = 255; // opaque alpha
//        }

        /* Copy image
        var destpix = result.data;
        var srcpix = image.data;

        for (var y = 0; y < height; ++y)
        {
            for (var x = 0; x < width; ++x)
            {
                var offset = (y * width + x) * 4;
                destpix[offset] =  srcpix[offset];
                destpix[offset+1] = srcpix[offset+1];
                destpix[offset+2] = srcpix[offset+2];
                destpix[offset+3] = srcpix[offset+3];
            }
        }
        */
        return true;
    }
});

},{}],224:[function(require,module,exports){

Xflow.registerOperator("xflow.sub", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'value1'},
                {type: 'float3', source: 'value2'}],
    evaluate: function(result, value1, value2, info) {
        throw "Not used!";

        for(var i = 0; i< info.iterateCount*3; i++)
            result[i] = value1[i] - value2[i];

        return true;
    },

    evaluate_core: function(result, value1, value2){
        result[0] = value1[0] - value2[0];
        result[1] = value1[1] - value2[1];
        result[2] = value1[2] - value2[2];
    }
});

},{}],225:[function(require,module,exports){
/**
 * One operator execution within the @see{OperatorList}.
 * @param operator
 * @constructor
 */
var OperatorEntry = function (operator) {
    /**
     * Position in OperatorList
     * @type {number}
     */
    this.index = 0;

    /**
     * Operator object
     * @type {{}}
     */
    this.operator = operator;

    /**
     * operatorIndex: Position of the input's operator in the OperatorList if the input comes from
     * previously executed operator otherwise undefined
     * outputIndex: References the outputs of the operator object defined by the operatorIndex
     * mappedName: Original name as defined in operator invocation in DataNode (currently not used)
     * inputIndex: Only set if this is direct input and references into the inputs defined in @see{ProgramData}
     * @type {Array.<{operatorIndex: number?, outputIndex: number?, mappedName: string?, inputIndex: number?}>}
     */
    this.inputInfo = [];
    /**
     * finalOut: {number} Is set, if this output a final output (e.g. a varying in a vertex shader). References the outputs of the ProgramData.
     * transfer: {boolean} Is true if this is a transfer output i.e. this output is used as input by another operator,
     * lost: Data that is lost, i.e. not used in next executor. Reference to ProgramData's outputs
     * @type {Array.<{finalOut: number?, transfer: boolean?, lost: number?}>}
     */
    this.outputInfo = [];
};

/**
 * Is the input the result of a previously executed operator
 * @param mappingIndex Input index of the operator (can be mapped using a mapping declaration)
 * @returns {boolean}
 */
OperatorEntry.prototype.isTransferInput = function (mappingIndex) {
    return this.inputInfo[mappingIndex].operatorIndex !== undefined;
};

OperatorEntry.prototype.getTransferInputOperatorIndex = function (mappingIndex) {
    return this.inputInfo[mappingIndex].operatorIndex;
};
OperatorEntry.prototype.getTransferInputOutputIndex = function (mappingIndex) {
    return this.inputInfo[mappingIndex].outputIndex;
};

/**
 * Generate unique name for a specified transfer input
 * @param mappingIdx
 * @returns {string}
 */
OperatorEntry.prototype.getTransferInputId = function (mappingIdx) {
    var info = this.inputInfo[mappingIdx];
    return info.operatorIndex + "_" + info.outputIndex;
};

/**
 * Generate unique name for transfer output
 * @param outputIndex
 * @returns {string}
 */
OperatorEntry.prototype.getTransferOutputId = function (outputIndex) {
    return this.index + "_" + outputIndex;
};

/**
 * TODO: remove or integrate for debugging purposes
 * @unused
 * @param mappingIdx
 * @returns {string|*}
 */
OperatorEntry.prototype.getInputMappingName = function (mappingIdx) {
    return this.inputInfo[mappingIdx].mappedName;
};
OperatorEntry.prototype.getDirectInputIndex = function (mappingIdx) {
    return this.inputInfo[mappingIdx].inputIndex;
};

OperatorEntry.prototype.getOutputIndex = function (operatorOutputIdx) {
    return this.outputInfo[operatorOutputIdx].finalOut || this.outputInfo[operatorOutputIdx].lost || 0;
};


OperatorEntry.prototype.isFinalOutput = function (outputIndex) {
    return this.outputInfo[outputIndex] && this.outputInfo[outputIndex].finalOut !== undefined;
};
OperatorEntry.prototype.isTransferOutput = function (outputIndex) {
    return this.outputInfo[outputIndex] && this.outputInfo[outputIndex].transfer;
};
OperatorEntry.prototype.isLostOutput = function (outputIndex) {
    return this.outputInfo[outputIndex] && this.outputInfo[outputIndex].lost !== undefined;
};


OperatorEntry.prototype.setTransferInput = function (mappingIndex, operatorIndex, outputIndex) {
    this.inputInfo[mappingIndex] = {operatorIndex: operatorIndex, outputIndex: outputIndex};
};

OperatorEntry.prototype.setDirectInput = function (mappingIndex, inputIndex, mappedName) {
    this.inputInfo[mappingIndex] = {inputIndex: inputIndex, mappedName: mappedName};
};

OperatorEntry.prototype.setFinalOutput = function (operatorOutputIndex, globalOutputIndex) {
    this.outputInfo[operatorOutputIndex] = {finalOut: globalOutputIndex};
};
OperatorEntry.prototype.setTransferOutput = function (operatorOutputIndex) {
    this.outputInfo[operatorOutputIndex] = {transfer: true};
};
OperatorEntry.prototype.setLostOutput = function (operatorOutputIndex, globalOutputIndex) {
    this.outputInfo[operatorOutputIndex] = {lost: globalOutputIndex};
};

/**
 * Generate hash-able key for the entry
 * @returns {string}
 */
OperatorEntry.prototype.getKey = function () {
    var key = this.operator.name + "*O";
    for (var i = 0; i < this.outputInfo.length; ++i) {
        var info = this.outputInfo[i];
        key += "*" + ( info.transfer ? "_" : info.finalOut || (info.lost + "?"));
    }
    key += +"*I";
    for (i = 0; i < this.inputInfo.length; ++i) {
        info = this.inputInfo[i];
        key += "*" + (info.inputIndex ? info.inputInfo : info.operatorIndex + ">" + info.outputIndex);
    }
    return key;
};

module.exports = OperatorEntry;

},{}],226:[function(require,module,exports){
var C = require("../interface/constants.js");
var Base = require("../base.js");


/**
 * List of platform-specific operators, ordered by execution (last entry is last operator
 * executed).
 *
 * @param {C.PLATFORM} platform
 * @constructor
 */
var OperatorList = function (platform) {
    this.platform = platform;
    /**
     * @type {Array.<OperatorEntry>}
     */
    this.entries = [];

    /**
     * Map from position of input parameter to size and iterator type of parameters.
     * Size is only specified for uniform array input, required for programs that
     * have the array size specified.
     * @type {Object.<number,{size: number, iterate: C.ITERATION_TYPE}>}
     */
    this.inputInfo = {};
};

OperatorList.prototype.addEntry = function (entry) {
    entry.index = this.entries.length;
    this.entries.push(entry);
};

/**
 * Hashable key for whole list
 * @returns {string}
 */
OperatorList.prototype.getKey = function () {
    var keys = [];
    for (var i = 0; i < this.entries.length; ++i) {
        keys.push(this.entries[i].getKey());
    }
    var result = this.platform + ">" + keys.join("!") + "|";
    for (var i in this.inputInfo) {
        result += i + ">" + (this.inputInfo[i].iterate || 0) + "x" + (this.inputInfo[i].size || 0);
    }
    return result;
};

OperatorList.prototype.setInputIterateType = function (inputIndex, type) {
    if (!this.inputInfo[inputIndex]) this.inputInfo[inputIndex] = {};
    this.inputInfo[inputIndex].iterate = type;
};
OperatorList.prototype.setInputSize = function (inputIndex, size) {
    if (!this.inputInfo[inputIndex]) this.inputInfo[inputIndex] = {};
    this.inputInfo[inputIndex].size = size;
};


OperatorList.prototype.isInputIterate = function (inputIndex) {
    return this.inputInfo[inputIndex] && this.inputInfo[inputIndex].iterate == C.ITERATION_TYPE.MANY;
};
OperatorList.prototype.isInputUniform = function (inputIndex) {
    return this.inputInfo[inputIndex] && this.inputInfo[inputIndex].iterate == C.ITERATION_TYPE.ONE;
};
OperatorList.prototype.isInputNull = function (inputIndex) {
    return this.inputInfo[inputIndex] && this.inputInfo[inputIndex].iterate == C.ITERATION_TYPE.NULL;
};
OperatorList.prototype.getInputIterateType = function (inputIndex) {
    return this.inputInfo[inputIndex] && this.inputInfo[inputIndex].iterate;
};

OperatorList.prototype.getInputSize = function (inputIndex) {
    return this.inputInfo[inputIndex] && this.inputInfo[inputIndex].size || 0;
};

OperatorList.prototype.getIterateCount = function (programData) {
    var count = -1;
    for (var i = 0; i < programData.inputs.length; ++i) {
        if (this.isInputIterate(i)) {
            var dataEntry = programData.getDataEntry(i);
            if (dataEntry && dataEntry.getIterateCount) {
                var size = dataEntry.getIterateCount();
                count = count < 0 ? size : Math.min(size, count);
            }
        }
    }
    return count < 0 ? 1 : count;
};

var c_sizes = {};

OperatorList.prototype.allocateOutput = function (programData, async) {
    for (var i = 0; i < this.entries.length; ++i) {
        var entry = this.entries[i];
        var operator = entry.operator;
        var operatorData = programData.operatorData[i];
        var iterateCount = this.getIterateCount(programData);
        if (operator.alloc) {
            var args = [c_sizes];
            addInputToArgs(args, entry, programData);
            args.push(iterateCount);
            operator.alloc.apply(operatorData, args);
        }
        for (var j = 0; j < operator.outputs.length; ++j) {
            var d = operator.outputs[j];
            var dataSlot = programData.outputs[entry.getOutputIndex(j)], dataEntry;
            dataEntry = async ? dataSlot.asyncDataEntry : dataSlot.dataEntry;

            if (d.noAlloc)
                continue;

            if (dataEntry.type == C.DATA_TYPE.TEXTURE) {
                // texture entry
                if (d.customAlloc) {
                    var texParams = c_sizes[d.name];
                    var newWidth = texParams.imageFormat.width;
                    var newHeight = texParams.imageFormat.height;
                    var newType = texParams.imageFormat.texelType;
                    var newFormat = texParams.imageFormat.texelFormat;
                    var newSamplerConfig = texParams.samplerConfig;
                    dataEntry._createImage(newWidth, newHeight, newFormat, newType, newSamplerConfig);
                } else if (d.sizeof) {
                    var srcEntry = null;
                    for (var k = 0; k < operator.mapping.length; ++k) {
                        if (operator.mapping[k].source == d.sizeof) {
                            srcEntry = programData.getDataEntry(entry.getDirectInputIndex(k));
                            break;
                        }
                    }
                    if (srcEntry) {
                        var newWidth = Math.max(srcEntry.width, 1);
                        var newHeight = Math.max(srcEntry.height, 1);
                        var newFormat = d.texelFormat || srcEntry.texelFormat;
                        var newType = d.texelType || srcEntry.texelType;
                        var newSamplerConfig = d.samplerConfig || srcEntry.getSamplerConfig();
                        dataEntry._createImage(newWidth, newHeight, newFormat, newType, newSamplerConfig);
                    } else
                        throw new Error("Unknown texture input parameter '" + d.sizeof + "' in operator '" + operator.name + "'");
                } else
                    throw new Error("Cannot create texture. Use customAlloc or sizeof parameter attribute");
            } else {

                var size = (d.customAlloc ? c_sizes[d.name] : iterateCount) * dataEntry.getTupleSize();

                if (!dataEntry._value || dataEntry._value.length != size) {
                    switch (dataEntry.type) {
                        case C.DATA_TYPE.FLOAT:
                        case C.DATA_TYPE.FLOAT2:
                        case C.DATA_TYPE.FLOAT3:
                        case C.DATA_TYPE.FLOAT4:
                        case C.DATA_TYPE.FLOAT4X4:
                            dataEntry._setValue(new Float32Array(size));
                            break;
                        case C.DATA_TYPE.INT:
                        case C.DATA_TYPE.INT4:
                        case C.DATA_TYPE.BOOL:
                            dataEntry._setValue(new Int32Array(size));
                            break;
                        case C.DATA_TYPE.STRING:
                            dataEntry._setValue(new Array(size));
                            break;
                        default:
                            XML3D.debug.logWarning("Could not allocate output buffer of TYPE: " + dataEntry.type);
                    }
                } else {
                    dataEntry._notifyChanged();
                }
            }
        }
    }
};

    // TODO: This function appears in multiple units
    function addInputToArgs(args, entry, programData){
        var mapping = entry.operator.mapping;
        for(var i = 0; i < mapping.length; ++i){
            var dataEntry = programData.getDataEntry(entry.getDirectInputIndex(i));
            args.push(dataEntry ? dataEntry.getValue() : null);
        }
    };

module.exports = OperatorList;

},{"../base.js":186,"../interface/constants.js":187}],227:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");

//----------------------------------------------------------------------------------------------------------------------
// registerOperator && getOperator
//----------------------------------------------------------------------------------------------------------------------

var operators = {};

    /**
     * Registers Xflow operator.
     * The operators are stored in collections using their platform as a key. If no platform is defined, the operator
     * will be registered as a JavaScript-based operator.
     *
     * @param name
     * @param data
     */

var registerOperator = function(name, data){
    var opCollection, platform;

    initOperator(data, name);
    if(!operators[name]) {
        operators[name] = {};
    }

    platform = data['platform'] || C.PLATFORM.JAVASCRIPT;

    opCollection = operators[name];

    if (!name) {
        XML3D.logWarning("Xflow.registerOperator: Operator name undefined.");
        return;
    }

    if (!data) {
        XML3D.logWarning("Xflow.registerOperator: Operator data undefined.");
        return;
    }

    data.name = name;
    if(!opCollection[platform])
        opCollection[platform] = [];

    opCollection[platform].push(data);
};

var initAnonymousOperator = function(name, data){
    initOperator(data);
    data.name = name;
    return data;
};

var isOperatorAsync = function(operator){
    return !!operator.evaluate_async;
};

var getOperators = function(name, platform){
    platform = platform || C.PLATFORM.JAVASCRIPT;

    if (name && !operators[name]) {
        return null;
    }

    if(!operators[name][platform] || operators[name][platform].length == 0) {
        return null;
    }

    return operators[name][platform];
};

function initOperator(operator, name){
    var indexMap = {};
    // Init types of outputs and params
    for(var i= 0; i < operator.outputs.length; ++i){
        if (operator.outputs[i].type === undefined) {
            XML3D.debug.logError("Xflow operator '"+name+"' is missing required attribute 'type' for output parameter "+i);
        }
        operator.outputs[i].type = C.DATA_TYPE_MAP[operator.outputs[i].type];
    }
    for(var i= 0; i < operator.params.length; ++i){
        if (operator.params[i].source === undefined) {
            XML3D.debug.logError("Xflow operator '"+name+"' is missing required attribute 'source' for input parameter "+i);
        }
        if (operator.params[i].type === undefined) {
            XML3D.debug.logError("Xflow operator '"+name+"' is missing required attribute 'type' for input parameter "+i);
        }
        operator.params[i].type = C.DATA_TYPE_MAP[operator.params[i].type];
        indexMap[operator.params[i].source] = i;
    }
    if(!operator.mapping)
        operator.mapping = operator.params;

    // Init interTypes of mapping
    for(var i = 0; i < operator.mapping.length; ++i){
        var mapping = operator.mapping[i];
        var paramIdx = indexMap[mapping.source];
        mapping.paramIdx = paramIdx;
        var type = operator.params[paramIdx].type;
        if(mapping.sequence)
            mapping.keyParamIdx = indexMap[mapping.keySource];
        if(mapping.sequence == C.SEQUENCE.LINEAR_WEIGHT)
            type = C.DATA_TYPE.FLOAT;
        mapping.internalType = type;
        mapping.name = mapping.name || mapping.source;
    }

    //Check/init platform
    operator.platform = operator.platform || C.PLATFORM.JAVASCRIPT;
}

//window.Xflow.registerOperator = registerOperator;

module.exports = {
    registerOperator: registerOperator,
    initAnonymousOperator: initAnonymousOperator,
    isOperatorAsync: isOperatorAsync,
    getOperators: getOperators
};

},{"../base.js":186,"../interface/constants.js":187}],228:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var VSProgram = require("./vs-program.js");
var CLProgram = require("./cl-program.js");

/**
 * Data for a OperatorList, generated by an Executor
 * @constructor
 */
var ProgramData = function(){
    /**
     * @type {Array.<ProgramInputConnection>}
     */
    this.inputs = [];

    /**
     *
     * @type {Array.<DataSlot>}
     */
    this.outputs = [];

    /**
     * iterateCount: How often we iterate with the default execution model
     * iterFlag: Per input: true if the input can be iterated, otherwise false
     * customData: Per instance data that users can persist between operator invocations
     * @type {Array.<{iterateCount: number, iterFlag: Array, customData: {}}>}
     */
    this.operatorData = [];
};

ProgramData.prototype.getChannel = function(index){
    return this.inputs[index].channel;
};

ProgramData.prototype.getDataEntry = function(index){
    var entry = this.inputs[index];
    var channel = entry.channel;
    if(!channel) return null;
    var key = 0;
    if(entry.sequenceKeySourceChannel){
        var keyDataEntry = entry.sequenceKeySourceChannel.getDataEntry();
        key = keyDataEntry && keyDataEntry._value ? keyDataEntry._value[0] : 0;
    }

    return channel.getDataEntry(entry.sequenceAccessType, key);
};

/**
 * @constructor
 */
var ProgramInputConnection = function(){
    /**
     * @type {Channel}
     */
    this.channel = null;

    /**
     * Is this input a uniform array
     * @type {boolean}
     */
    this.arrayAccess = false;

    /**
     * @type {C.SEQUENCE}
     */
    this.sequenceAccessType = C.SEQUENCE.NO_ACCESS;

    /**
     *
     * @type {Channel|null}
     */
    this.sequenceKeySourceChannel = null;
};

/**
 * Hash-able key to identify equal inputs within executor
 * @returns {string}
 */
ProgramInputConnection.prototype.getKey = function(){
    return (this.channel ? this.channel.id : "NULL") + ";" + this.arrayAccess + ";" + this.sequenceAccessType + ";" +
    ( this.sequenceKeySourceChannel ? this.sequenceKeySourceChannel.id : "");
};


var c_program_cache = {};

var createProgram = function(operatorList){
    var firstOperator;

    if(operatorList.entries.length === 0) {
        return null;
    }

    firstOperator = operatorList.entries[0].operator;

    var key = operatorList.getKey();
    if(!c_program_cache[key]){
        // GLSL operators are implemented in a different way, so platform information is fetched from the operatorList
        // as a fallback mode to not break the old implementations
        if(operatorList.platform === C.PLATFORM.GLSL){
            c_program_cache[key] = new VSProgram(operatorList);

        } else if (firstOperator.platform === C.PLATFORM.CL) {
            c_program_cache[key] = new CLProgram(operatorList);

        }else if(firstOperator.platform === C.PLATFORM.JAVASCRIPT && operatorList.entries.length === 1 ) {
            c_program_cache[key] = new SingleProgram(operatorList);

        }else {
            Base.notifyError("Could not create program from operatorList");
        }
    }
    return c_program_cache[key];
};



var SingleProgram = function(operatorList){
    this.list = operatorList;
    this.entry = operatorList.entries[0];
    this.operator = this.entry.operator;
    this._inlineLoop = null;
};

SingleProgram.prototype.run = function(programData, asyncCallback){
    var operatorData = prepareOperatorData(this.list, 0, programData);

    if(asyncCallback)
        applyAsyncOperator(this.entry, programData, operatorData, asyncCallback);
    else if(this.operator.evaluate_core){
        applyCoreOperation(this, programData, operatorData);
    }
    else{
        applyDefaultOperation(this.entry, programData, operatorData);
    }
};

function applyDefaultOperation(entry, programData, operatorData){
    var args = assembleFunctionArgs(entry, programData);
    args.push(operatorData);
    entry.operator.evaluate.apply(operatorData, args);
    handlePostProcessOutput(entry, programData, args, false);
}

function applyAsyncOperator(entry, programData, operatorData, asyncCallback){
    var args = assembleFunctionArgs(entry, programData, true);
    args.push(operatorData);
    args.push(function(){
        handlePostProcessOutput(entry, programData, args, true);
        asyncCallback();
    });
    entry.operator.evaluate_async.apply(operatorData, args);
}

function applyCoreOperation(program, programData, operatorData){
    var args = assembleFunctionArgs(program.entry, programData);
    args.push(operatorData.iterateCount);

    if(!program._inlineLoop){
        program._inlineLoop = createOperatorInlineLoop(program.operator, operatorData);
    }
    program._inlineLoop.apply(operatorData, args);
}

var c_VarPattern = /var\s+(.)+[;\n]/;
var c_InnerVarPattern = /[^=,\s]+\s*(=[^,]+)?(,)?/;
function createOperatorInlineLoop(operator, operatorData){

    var code = "function (";
    var funcData = parseFunction(operator.evaluate_core);
    code += funcData.args.join(",") + ",__xflowMax) {\n";
    code += "    var __xflowI = __xflowMax\n" +
        "    while(__xflowI--){\n";

    var body = funcData.body;
    body = replaceArrayAccess(body, funcData.args, operator, operatorData);
    code += body + "\n  }\n}";

    var inlineFunc = eval("(" + code + ")");
    return inlineFunc;
}

    var c_FunctionPattern = /function\s*([^(]*)\(([^)]*)\)\s*\{([\s\S]*)\}/;

function parseFunction(func){
    var result = {};
    var matches = func.toString().match(c_FunctionPattern);
    if(!matches){
        Base.notifyError("Xflow Internal: Could not parse function: " + func);
        return null;
    }
    result.args = matches[2].split(",");
    for(var i in result.args) result.args[i] = result.args[i].trim();
    result.body = matches[3];
    return result;
}

var c_bracketPattern = /([a-zA-Z_$][\w$]*)(\[)/;

function replaceArrayAccess(code, args, operator, operatorData){
    var result = "";
    var index = 0, bracketIndex = code.indexOf("[", index);
    while(bracketIndex != -1){
        var key = code.substr(index).match(c_bracketPattern)[1];

        var argIdx = args.indexOf(key);
        var addIndex = false, tupleCnt = 0;
        if(argIdx != -1){
            if(argIdx < operator.outputs.length){
                addIndex = true;
                tupleCnt = C.DATA_TYPE_TUPLE_SIZE[[operator.outputs[argIdx].type]];
            }
            else{
                var i = argIdx - operator.outputs.length;
                addIndex = operatorData.iterFlag[i];
                tupleCnt = C.DATA_TYPE_TUPLE_SIZE[operator.mapping[i].internalType];
            }
        }

        result += code.substring(index, bracketIndex) + "[";
        if(addIndex){
            result += tupleCnt + "*__xflowI + ";
        }
        index = bracketIndex + 1;
        bracketIndex = code.indexOf("[", index);
    }
    result +=  code.substring(index);
    return result;
}


function prepareOperatorData(list, idx, programData){
    var data = programData.operatorData[0];
    var entry = list.entries[idx];
    var mapping = entry.operator.mapping;
    data.iterFlag = {};
    for(var i = 0; i < mapping.length; ++i){
        var doIterate = (entry.isTransferInput(i) || list.isInputIterate(entry.getDirectInputIndex(i)));
        data.iterFlag[i] = doIterate;
    }
    data.iterateCount = list.getIterateCount(programData);
    if(!data.customData)
        data.customData = {};
    return data;
}

function assembleFunctionArgs(entry, programData, async){
    var args = [];
    var outputs = entry.operator.outputs;
    for(var i = 0; i < outputs.length; ++i){
        if(outputs[i].noAlloc){
            args.push({assign: null});
        }
        else{
            var dataSlot = programData.outputs[entry.getOutputIndex(i)];
            var dataEntry = async ? dataSlot.asyncDataEntry : dataSlot.dataEntry;
            args.push(dataEntry ? dataEntry.getValue() : null);
        }
    }
    addInputToArgs(args, entry, programData);
    return args;
}
function handlePostProcessOutput(entry, programData, parameters, async){
    var outputs = entry.operator.outputs;
    for(var i = 0; i < outputs.length; ++i){
        var dataSlot = programData.outputs[entry.getOutputIndex(i)];
        if(outputs[i].noAlloc){
            var dataEntry = async ? dataSlot.asyncDataEntry : dataSlot.dataEntry;
            if(dataEntry.type == C.DATA_TYPE.TEXTURE ){
                dataEntry._setImage(parameters[i].assign);
            }
            else{
                dataEntry._setValue(parameters[i].assign);
            }
        }
        if(async){
            dataSlot.swapAsync();
        }
    }
}


function addInputToArgs(args, entry, programData){
    var mapping = entry.operator.mapping;
    for(var i = 0; i < mapping.length; ++i){
        var mapEntry = mapping[i];
        var dataEntry = programData.getDataEntry(entry.getDirectInputIndex(i));
        args.push(dataEntry ? dataEntry.getValue() : null);
    }
}

module.exports = {
    createProgram: createProgram,
    ProgramData: ProgramData,
    ProgramInputConnection: ProgramInputConnection
};

},{"../base.js":186,"../interface/constants.js":187,"./cl-program.js":191,"./vs-program.js":229}],229:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var Utils = require("../utils/utils.js");
var VertexShader = require("../processing/vs-connect.js").VertexShader;

//----------------------------------------------------------------------------------------------------------------------
// OperatorList
//----------------------------------------------------------------------------------------------------------------------

var c_SHADER_CONSTANT_TYPES = {};
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.OBJECT_ID] = 'int';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM] = 'mat4';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM_NORMAL] = 'mat3';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.VIEW_TRANSFORM] = 'mat4';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.VIEW_TRANSFORM_NORMAL] = 'mat3';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.WORLD_TRANSFORM] = 'mat4';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.WORLD_TRANSFORM_NORMAL] = 'mat3';

var VSProgram = function(operatorList){
    this.list = operatorList;
    this._outputInfo = {};
    setOutputIterate(this);
};

VSProgram.prototype.getOutputNames = function(){
    return Object.keys(this._outputInfo);
};

VSProgram.prototype.getOutputType = function(name){
    return this._outputInfo[name].type;
};

VSProgram.prototype.isOutputUniform = function(name){
    return this._outputInfo[name].iteration == C.ITERATION_TYPE.ONE;
};

VSProgram.prototype.isOutputNull = function(name){
    return this._outputInfo[name].iteration == C.ITERATION_TYPE.NULL;
};

VSProgram.prototype.createVertexShader = function(programData, vsConfig){
    var result = new VertexShader(programData);
    constructVS(result, this, vsConfig);
    return result;
};

function setOutputIterate(program){
    var operatorList = program.list, entries = operatorList.entries;

    var baseEntry = entries[entries.length - 1], baseOperator = baseEntry.operator;

    for( var i = 0; i < baseOperator.params.length; ++i){
        var entry = baseOperator.params[i],
            name = entry.source,
            inputIndex = i,
            directInputIndex = baseEntry.getDirectInputIndex(inputIndex);
        program._outputInfo[name] = {type: entry.type};
        if( baseEntry.isTransferInput(inputIndex) ||
            operatorList.isInputIterate(directInputIndex))
        {
            program._outputInfo[name].iteration = C.ITERATION_TYPE.MANY;
        }
        else if(operatorList.isInputUniform(directInputIndex)){
            program._outputInfo[name].iteration = C.ITERATION_TYPE.ONE;
        }
        else{
            program._outputInfo[name].iteration = C.ITERATION_TYPE.NULL;
        }
    }
}

function constructVS(vs, program, vsConfig){
    var operatorList = program.list, entries = operatorList.entries;

    var usedNames = [],
        directInputNames = {},
        transferNames = {};

    var baseEntry = entries[entries.length - 1], acceptedBaseShaderInput = [], baseOperator = baseEntry.operator;

    if(!vsConfig)
        throw new Error("Could not find vsConfig! Attempt to create vertex shader programm without VS operator?");

    Utils.nameset.add(usedNames, vsConfig.getBlockedNames());

    var code = "";
    code += "// OUTPUT\n";
    // First: collect output names
    for(var name in vsConfig._addOutput){
        var entry = vsConfig._addOutput[name];
        code += "varying " + getGLSLType(entry.type) + " " + name + ";\n";
        Utils.nameset.add(usedNames, name);
    }
    var inputIndex = 0;
    for( var name in vsConfig._attributes){
        var configAttr = vsConfig._attributes[name],
            directInputIndex = baseEntry.getDirectInputIndex(inputIndex);
        for(var i = 0; i < configAttr.channeling.length; ++i){
            var channeling = configAttr.channeling[i];
            var outputInfo = {type: configAttr.type, iteration: 0, index: 0, sourceName: name},
                outputName = channeling.outputName;
            if( channeling.code ||
                baseEntry.isTransferInput(inputIndex) ||
                operatorList.isInputIterate(directInputIndex))
            {
                acceptedBaseShaderInput[inputIndex] = true;
                outputInfo.iteration = C.ITERATION_TYPE.MANY;
                var type = baseOperator.outputs[inputIndex].type;
                code += "varying " + getGLSLType(type) + " " + outputName + ";\n";
                Utils.nameset.add(usedNames, outputName);
                transferNames[baseEntry.getTransferOutputId(i)] = outputName;
            }
            else if(operatorList.isInputUniform(directInputIndex)){
                outputInfo.iteration = C.ITERATION_TYPE.ONE;
                outputInfo.index = directInputIndex;
            }
            else{
                outputInfo.iteration = C.ITERATION_TYPE.NULL;
            }
            Utils.nameset.add(vs._outputNames, outputName);
            vs._outputInfo[outputName] = outputInfo;
        }
        inputIndex++;
    }
    code += "\n";
    code += "// INPUT\n";
    // Add additional input
    for(var name in vsConfig._addInput){
        var entry = vsConfig._addInput[name];
        code += (entry.uniform ? "uniform " : "attribute " ) + getGLSLType(entry.type) + " " + name + ";\n";
        Utils.nameset.add(usedNames, name);
    }
    // Second: collect input names
    for(var i = 0; i < entries.length; ++i){
        var entry = entries[i], operator = entry.operator;
        for(var j = 0; j < operator.mapping.length; ++j){
            if( (i < entries.length - 1 || acceptedBaseShaderInput[j]) &&
                    !entry.isTransferInput(j) && !directInputNames[entry.getDirectInputIndex(j)])
            {
                var mapEntry = operator.mapping[j];
                var name = getFreeName(mapEntry.name, usedNames), inputIndex = entry.getDirectInputIndex(j),
                    uniform = !operatorList.isInputIterate(inputIndex);
                vs._inputInfo[name] = { index: inputIndex, uniform: uniform };
                Utils.nameset.add(vs._inputNames, name);
                directInputNames[inputIndex] = name;
                code += (uniform ? "uniform " : "attribute ") + getGLSLType(mapEntry.internalType) + " " + name;
                if(mapEntry.array)
                    code += "[" + operatorList.getInputSize(inputIndex) + "]";
                code += ";\n";
            }
        }
    }

    // Start main
    code += "\n// CODE\n";
    code += "void main(void){\n";

    // Create Code
    for(var i = 0; i < entries.length; ++i){
        var entry = entries[i], operator = entry.operator;
        // Declare transfer output names
        for(var j = 0; j < operator.outputs.length; ++j){
            if(!entry.isFinalOutput(j)){
                var name = getFreeName(operator.outputs[j].name, usedNames);
                transferNames[entry.getTransferOutputId(j)] = name;
                code += "\t" + getGLSLType(operator.outputs[j].type) + " " + name + ";\n";
            }
        }
        // Take Code Fragment
        var codeFragment = convertCodeFragment(operator.evaluate_glsl, entry,
                                transferNames, directInputNames, usedNames);
        code += codeFragment + "\n";
    }

    // Add attribute channeling code
    var mappingIndex = 0, conversionCode = "";
    for( var name in vsConfig._attributes){
        var entry = vsConfig._attributes[name];
        for(var i = 0; i < entry.channeling.length; ++i){
            var channeling = entry.channeling[i], outputName = channeling.outputName;
            if(vs._outputInfo[outputName].iteration == C.ITERATION_TYPE.MANY){
                if(channeling.code)
                    conversionCode += "\t" + channeling.code + "\n";
                else
                    conversionCode += "\t" + outputName + " = #I{" + name + "};\n";
            }
        }
        mappingIndex++;
    }
    for( var i = 0; i < vsConfig._codeFragments.length; ++i){
        conversionCode += "\t" + vsConfig._codeFragments[i] + "\n";
    }
    code += convertCodeFragment(conversionCode, baseEntry, transferNames, directInputNames, usedNames) + "\n";

    code += "}\n";
    vs._glslCode = code;
}

function convertCodeFragment(codeFragment, entry, transferNames, directInputNames, usedNames){
    var index, operator = entry.operator;
    while((index = codeFragment.indexOf("#I{")) != -1){
        var end = codeFragment.indexOf("}",index);
        var mappingIndex = getMappingIndex(operator, codeFragment.substring(index+3,end));
        var replaceName = entry.isTransferInput(mappingIndex) ?
            transferNames[entry.getTransferInputId(mappingIndex)] :
            directInputNames[entry.getDirectInputIndex(mappingIndex)];
        codeFragment = codeFragment.substring(0, index) + replaceName + codeFragment.substring(end+1);
    }
    while((index = codeFragment.indexOf("#O{")) != -1){
        var end = codeFragment.indexOf("}",index);
        var outputIndex = getOutputIndex(operator, codeFragment.substring(index+3,end));
        var replaceName = transferNames[entry.getTransferOutputId(outputIndex)];
        codeFragment = codeFragment.substring(0, index) + replaceName + codeFragment.substring(end+1);
    }
    var localNames = [];
    while((index = codeFragment.indexOf("#L{")) != -1){
        var end = codeFragment.indexOf("}",index);
        var key = codeFragment.substring(index+3,end);
        if(!localNames[key]){
            localNames[key] = getFreeName(key, usedNames);
        }
        var replaceName = localNames[key];
        codeFragment = codeFragment.substring(0, index) + replaceName + codeFragment.substring(end+1);
    }
    while((index = codeFragment.indexOf("#G{")) != -1){
        var end = codeFragment.indexOf("}",index);
        var replaceName = codeFragment.substring(index+3,end);
        codeFragment = codeFragment.substring(0, index) + replaceName + codeFragment.substring(end+1);
    }
    return codeFragment;
}

function getFreeName(name, usedNames){
    var result = name, i = 1;
    while(usedNames.indexOf(result) != -1){
        result = name + "_" + (++i);
    }
    Utils.nameset.add(usedNames, result);
    return result;
}

function getMappingIndex(operator, name){
    for(var i = 0; i < operator.mapping.length; ++i){
        if(operator.mapping[i].name == name)
            return i;
    }
    throw new Error("Invalid input name '" + name  + "' inside of code fragment" );
}

function getOutputIndex(operator, name){
    for(var i = 0; i < operator.outputs.length; ++i){
        if(operator.outputs[i].name == name)
            return i;
    }
}

function getGLSLType(xflowType){
    switch(xflowType){
        case C.DATA_TYPE.BOOL : return 'bool';
        case C.DATA_TYPE.BYTE : return 'uint';
        case C.DATA_TYPE.FLOAT : return 'float';
        case C.DATA_TYPE.FLOAT2 : return 'vec2';
        case C.DATA_TYPE.FLOAT3 : return 'vec3';
        case C.DATA_TYPE.FLOAT4 : return 'vec4';
        case C.DATA_TYPE.FLOAT3X3 : return 'mat3';
        case C.DATA_TYPE.FLOAT4X4 : return 'mat4';
        case C.DATA_TYPE.INT : return 'int';
        case C.DATA_TYPE.INT4 : return 'ivec4';
    }
    throw new Error("Type not supported for GLSL " + C.getTypeName(xflowType) );
}

module.exports = VSProgram;

},{"../base.js":186,"../interface/constants.js":187,"../processing/vs-connect.js":237,"../utils/utils.js":238}],230:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var Channels = require("./channel.js");
var RequestNode = require("./process-node.js").RequestNode;
var ProcessNode = require("./process-node.js").ProcessNode;
var DataSlot = require("./data-slot.js");
var Operator = require("../operator/operator.js");

var ChannelMap = Channels.ChannelMap;

//----------------------------------------------------------------------------------------------------------------------
// ChannelNode
//----------------------------------------------------------------------------------------------------------------------

/**
 * Is created for each substitution (via dataflow) of a DataNode.
 * Stores an optimized representation of the data with ChannelMaps and Channels
 * On construction a ChannelNode is marked outOfSync and synchronized only once data is requested.
 * When the structure of a DataNode is changed in any way (e.g. rename InputNode, add/remove children) a channelNode
 * is marked outOfSync.
 * @param {DataNode} dataNode
 * @param {Substitution} substitution
 * @constructor
 */
var ChannelNode = function(dataNode, substitution){
    this.owner = dataNode;
    this.platform = C.PLATFORM.JAVASCRIPT;
    this.substitution = substitution;   // Substitution is defined by the dataflow instance
    this.loading = false;   // is true if any value in the sub tree is loading and the result can't be calculated
    this.inputSlots = {};   // DataEntries from direct InputNode children of the DataNode
    this.inputChannels = new ChannelMap();    // channel map for input data prio to operator execution
    this.computedChannels = new ChannelMap(); // channel map extend by operator output
    this.outputChannels = new ChannelMap();   // channel map with applied filter => final output

    /**
     * Operator attached to DataNode (guaranteed to be resolved)
     * @type {Object}
     */
    this.operator = null;
    /**
     * Channel node of the dataflowNode (analogue to dataflowNode of DataNode)
     * @type {ChannelNode}
     */
    this.dataflowChannelNode = null;
    /**
     * Process node - only constructed if an operator/dataflow is defined
     * @type {ProcessNode}
     */
    this.processNode = null;
    /**
     * Request Nodes created for each result request on this dataNode.
     * @type {Object.<String,RequestNode>}
     */
    this.requestNodes = {};
    /**
     * Number of uses of channel node. This is only relevant for channel nodes created with substitution.
     * These nodes are cached and the useCount is used to clean this cache.
     * TODO: Use weakmap here to avoid explicit reference count
     * @type {number}
     */
    this.useCount = 1;
    /**
     * True if the channel node is out of sync and internal channel maps need to be reconstructed
     * @type {boolean}
     */
    this.outOfSync = true;
};

/**
 * If node is out of sync, reconstruct all channels
 */
ChannelNode.prototype.synchronize = function(){

    if(this.outOfSync){
        updatePlatform(this);
        synchronizeChildren(this);
        updateInputChannels(this);
        updateComputedChannels(this);
        updateOutputChannels(this);
        this.outOfSync = false;
    }
};

ChannelNode.prototype.clear = function(){
    this.useCount = 0;
    this.inputChannels.clear();
    this.outputChannels.clear();
    delete this.owner;
    var reqs = Object.keys(this.requestNodes);
    for (var i = 0; i < reqs.length; i++) {
        this.requestNodes[reqs[i]].clear();
    }
    this.requestNodes = {};
};

ChannelNode.prototype.increaseRef = function(){
    this.useCount++;
};

ChannelNode.prototype.decreaseRef = function(){
    this.useCount--;
    if(this.useCount == 0){
        this.clear();
        return true;
    }
    return false;
};

ChannelNode.prototype.getOutputNames = function(){
    this.synchronize();
    return this.outputChannels.getNames();
};

ChannelNode.prototype.getChildDataIndex = function(filter){
    this.synchronize();
    return this.outputChannels.getChildDataIndexForFilter(filter);
};

ChannelNode.prototype.setStructureOutOfSync = function()
{
    if(!this.outOfSync){
        this.outOfSync = true;
        this.inputChannels.clear();
        this.computedChannels.clear();
        this.outputChannels.clear();
        this.processNode && this.processNode.clear();
        for(var key in this.requestNodes){
            this.requestNodes[key].setStructureOutOfSync();
        }
        if(this.dataflowChannelNode) {
            this.dataflowChannelNode.setStructureOutOfSync();
        }
    }
};

ChannelNode.prototype.notifyDataChange = function(inputNode, changeType){
    var key = inputNode._name + ";" + inputNode._key;
    if(this.inputSlots[key])
        this.inputSlots[key].setDataEntry(inputNode._data, changeType);
};

ChannelNode.prototype.getResult = function(type, filter) {
    this.synchronize();

    var key = filter ? filter.join(";") : "[null]";
    if(!this.requestNodes[key]){
        this.requestNodes[key] = new RequestNode(this, filter);
    }
    return this.requestNodes[key].getResult(type);
};


ChannelNode.prototype.getOutputChannelInfo = function(name){
    this.synchronize();

    var channel = this.outputChannels.getChannel(name);
    if(!channel)
        return null;
    var result = {
        type: channel.getType(),
        seqLength: channel.getSequenceLength(),
        seqMinKey: channel.getSequenceMinKey(),
        seqMaxKey: channel.getSequenceMaxKey(),
        origin: 0,
        originalName: ""
    };
    var preFilterName = this.owner._filterMapping ? this.owner._filterMapping.getRenameSrcName(name) : name;
    var dataEntry = channel.getDataEntry();
    if(this.dataflowChannelNode){
        var protoInputChannel = this.inputChannels.getChannel(preFilterName);
        if(!protoInputChannel || dataEntry != protoInputChannel.getDataEntry()){
            result.origin = C.ORIGIN.PROTO;
            result.originalName = preFilterName;
            return result;
        }
    }
    if(this.operator){
        var inputChannel = this.inputChannels.getChannel(preFilterName);
        if(!inputChannel || dataEntry != inputChannel.getDataEntry()){
            result.origin = C.ORIGIN.COMPUTE;
            result.originalName = this.owner._computeOutputMapping.getScriptOutputNameInv(preFilterName, this.operator.outputs);
            return result;
        }
    }
    result.origin = C.ORIGIN.CHILD;
    result.originalName = preFilterName;
    return result;
};

/**
 * Select the platform to compute the attached platform
 * @param {ChannelNode} channelNode
 */
function updatePlatform(channelNode) {
    var platform;
    var owner = channelNode.owner;

    // Platforms other than JavaScript are available only for computing operators
    if(!channelNode.owner._computeOperator) {
        return;
    }

    //TODO: Improve platform selection logic.
    // Currently we use forced platform if graph platform is something other than JavaScript
    // and forced platform (owner._platform) is defined
    platform = owner._platform !== null ? owner._platform : C.PLATFORM.JAVASCRIPT;

    channelNode.platform = platform;
}

/**
 *
 * @param {ChannelNode} channelNode
 */
function synchronizeChildren(channelNode){
    var dataNode = channelNode.owner;
    channelNode.loading = dataNode.isSubtreeLoading();

    /**
     * If the channel node represents a substitution, we also need to
     * synchronize the main ChannelNode of the DataNode
     */
    if(channelNode.substitution) {
        dataNode._channelNode.synchronize();
    }

    // Now synchronize all children (either referenced data node, or real children)
    // TODO: Change here if we change behaviour of src attribute
    if(dataNode._sourceNode){
        dataNode._sourceNode._getOrCreateChannelNode(channelNode.substitution).synchronize();
    }
    else{
        for(var i = 0; i < dataNode._children.length; ++i){
            if(dataNode._children[i]._getOrCreateChannelNode){
                dataNode._children[i]._getOrCreateChannelNode(channelNode.substitution).synchronize();
            }
        }
    }
}

/**
 *
 * @param {ChannelNode} channelNode
 */
function updateInputChannels(channelNode){
    var owner = channelNode.owner;
    // TODO: Change here if we change behaviour of src attribute
    if(owner._sourceNode){
        channelNode.inputChannels.merge(owner._sourceNode._getOrCreateChannelNode(channelNode.substitution).outputChannels, 0);
    }
    else{
        var children = owner._children;
        // First the DataNodes than the input nodes in order to override the DataNode channels
        mergeInputChannelDataNodes(channelNode, children);
        mergeInputChannelInputNodes(channelNode, children);
    }
}

/**
 * @param {ChannelNode} channelNode
 * @param {Array.<GraphNode>} children
 */
function mergeInputChannelInputNodes(channelNode, children) {
    for (var i = 0; i < children.length; ++i) {
        if (!children[i]._getOrCreateChannelNode) {  // Child is an InputNode
            var child = children[i];
            var key = child._name + ";" + child._key;
            if (!channelNode.substitution) {  // No dataflow
                var slot = new DataSlot(child._data, child._key);
                channelNode.inputSlots[key] = slot;
                channelNode.inputChannels.addDataEntry(child._name, slot);
            } else {
                if (child._paramName && channelNode.substitution.hasChannel(child._paramName)) {
                    channelNode.inputChannels.addChannel(child._name, channelNode.substitution.getChannel(child._paramName));
                } else {
                    channelNode.inputChannels.addDataEntry(child._name, channelNode.owner._channelNode.inputSlots[key]);
                }
            }
        }
    }
}

/**
 * @param {ChannelNode} channelNode
 * @param {Array.<GraphNode>} children
 */
function mergeInputChannelDataNodes(channelNode, children) {
    for (var i = 0; i < children.length; ++i) {
        if (children[i]._getOrCreateChannelNode) {  // Child is a DataNode
            channelNode.inputChannels.merge(children[i]._getOrCreateChannelNode(channelNode.substitution).outputChannels, i);
        }
    }
}

function updateComputedChannels(channelNode){
    var owner = channelNode.owner;
    channelNode.computedChannels.merge(channelNode.inputChannels);

    var oldDataflowChannelNode = channelNode.dataflowChannelNode;

    if( owner._computeUsesDataflow && owner._dataflowNode){
        channelNode.operator = null;
        updateDataflowChannelNode(channelNode);
        updateComputedChannelsFromDataflow(channelNode);
    }
    else if(!owner._computeUsesDataflow && owner._computeOperator){
        channelNode.dataflowChannelNode = null;
        updateOperator(channelNode);
        updateComputedChannelsFromOperator(channelNode);
    }

    if(oldDataflowChannelNode && oldDataflowChannelNode != channelNode.dataflowChannelNode){
        oldDataflowChannelNode.owner._removeSubstitutionNode(oldDataflowChannelNode);
    }
}

/**
 * Find and set the operator for the given ChannelNode
 * @param channelNode
 */
function updateOperator(channelNode){
    var operatorName, operator;
    var owner = channelNode.owner;

    if(channelNode.loading){
        channelNode.operator = null;
        return;
    }
    if(typeof owner._computeOperator == "string"){
        operatorName = owner._computeOperator;
        operator = null;

        // Getting a correct operator for the selected platform. If operator is not available, we'll try to get
        // the default JavaScript platform operator
        if(operatorName){
            operator = findOperatorByName(channelNode, owner);
            if(operator) { // TODO: Is this good? We calculated the platform before, now it just gets overriden
                channelNode.platform = operator.platform;
            }
        }
        channelNode.operator = operator;
    }else{
        channelNode.operator = owner._computeOperator;
    }
}

var c_typeComparisons = [];

/**
 * Find operator based on name in dataNode, platform and input mapping (signature)
 * @param {ChannelNode} channelNode
 * @param {DataNode} dataNode
 * @returns {Object|null}
 */
function findOperatorByName(channelNode, dataNode){
    var operatorName = dataNode._computeOperator,
        inputMapping = dataNode._computeInputMapping,
        inputChannels = channelNode.inputChannels;

    var operators = Operator.getOperators(operatorName, channelNode.platform) ||
                Operator.getOperators(operatorName, C.PLATFORM.JAVASCRIPT);
    if(!operators){
        Base.notifyError("No operator with name '" + operatorName+"' found", channelNode.owner);
    }

    var i = operators.length;
    while(i--){
        if(checkOperator(operators[i], inputMapping, inputChannels)){
            return operators[i];
        }
    }
    c_typeComparisons.length = 0;
    i = operators.length;
    while(i--){
        checkOperator(operators[i], inputMapping, inputChannels, c_typeComparisons);
    }
    var errorMessage = "No operator '" + operatorName+"' with matching type signature found:\n\n"
                        + c_typeComparisons.join("\n");
    Base.notifyError(errorMessage, channelNode.owner);
    return null;
}

/**
 *
 * @param operator
 * @param inputMapping
 * @param inputChannels
 * @param {Array?} typeComparisonsOutput If array is give, save error information
 * @returns {boolean}
 */
function checkOperator(operator, inputMapping, inputChannels, typeComparisonsOutput){
    var inputs, errors;
    if(typeComparisonsOutput){
        inputs = []; errors = [];
    }
    for(var i = 0; i < operator.params.length; ++i){
        var inputEntry = operator.params[i], sourceName = inputEntry.source;
        var dataName = inputMapping ? inputMapping.getScriptInputName(i, sourceName) : sourceName;
        var errorHeader;
        if(typeComparisonsOutput){
            errorHeader = "For " + (i+1) + ". argument '" + sourceName + "': ";
            inputs.push( C.getTypeName(inputEntry.type) + " " + sourceName + (inputEntry.optional ? " [optional]" : ""));
        }
        if(dataName){
            var channel = inputChannels.getChannel(dataName);
            if(!channel && !inputEntry.optional){
                if(!typeComparisonsOutput)
                    return false;
                else{
                    errors.push(errorHeader + "DataEntry '" + dataName + "' does not exist");
                }
            }
            if(channel && channel.getType() != inputEntry.type){
                if(!typeComparisonsOutput)
                    return false;
                else{
                    errors.push(errorHeader + "DataEntry '" + dataName + "' has wrong type '" + C.getTypeName(channel.getType()) + "'");
                }
            }
        }
    }
    if(typeComparisonsOutput){
        typeComparisonsOutput.push(operator.name + "(" + inputs.join(", ") + ")\n\t * " + errors.join("\n\t * "));
    }
    return true;
}

/**
 *
 * @param channelNode
 */
function updateComputedChannelsFromOperator(channelNode){
    var owner = channelNode.owner;
    if(channelNode.operator){
        var procNode = channelNode.processNode = new ProcessNode(channelNode);
        var index = 0;
        for(var name in procNode.outputDataSlots){
            var destName = name;
            if(owner._computeOutputMapping) destName = owner._computeOutputMapping.getScriptOutputName(index, name);
            if(destName){
                channelNode.computedChannels.addOutputDataSlot(destName, procNode.outputDataSlots[name], procNode);
            }
            index++;
        }
    }
}

/**
 *
 * @param {ChannelNode} channelNode
 */
function updateDataflowChannelNode(channelNode){
    var owner = channelNode.owner;
    var subSubstitution = new Substitution(owner._dataflowNode, channelNode);
    channelNode.dataflowChannelNode = owner._dataflowNode._getOrCreateChannelNode(subSubstitution);
}

/**
 * @param {ChannelNode} channelNode
 */
function updateComputedChannelsFromDataflow(channelNode){
    var owner = channelNode.owner;
    if(channelNode.dataflowChannelNode){
        var dataflowCNode = channelNode.dataflowChannelNode;
        dataflowCNode.synchronize();
        // TODO: We have to make sure to get outputNames in the right order to apply output mapping correctly
        var outputNames = dataflowCNode.outputChannels.getNames();
        for(var i = 0; i < outputNames.length; ++i){
            var srcName = outputNames[i], destName = srcName;
            if(owner._computeOutputMapping)
                destName = owner._computeOutputMapping.getScriptOutputName(i, srcName);
            if(destName)
                channelNode.computedChannels.addChannel(destName, dataflowCNode.outputChannels.getChannel(srcName));
        }
    }
}

function updateOutputChannels(channelNode){
    var dataNode = channelNode.owner;
    if(dataNode._filterMapping) {
        // TODO: This is the only location where applyFilterOnChannelMap is used. Can be simplified (e.g. without callback)
        dataNode._filterMapping.applyFilterOnChannelMap(channelNode.outputChannels, channelNode.computedChannels, dataNode._filterType, setChannelFilterCallback);
    }
    else
        channelNode.outputChannels.merge(channelNode.computedChannels);
}

function setChannelFilterCallback(destMap, destName, srcMap, srcName){
    var channel = srcMap.getChannel(srcName);
    destMap.addChannel(destName, channel, srcMap.getChildDataIndex(srcName));
}

//----------------------------------------------------------------------------------------------------------------------
// Substitution
//----------------------------------------------------------------------------------------------------------------------

/**
 * TODO: Think of replacing this with a channel map
 * @param dataflowNode
 * @param userChannelNode
 * @constructor
 */
var Substitution = function(dataflowNode, userChannelNode){
    this.map = {};

    createSubstitution(this, dataflowNode, userChannelNode);
};

Substitution.prototype.hasChannel = function(name){
    return !!this.map[name];
};
Substitution.prototype.getChannel = function(name){
    return this.map[name];
};

/**
 * Create a hashable key for the substiution
 * @param subDataflowNode
 * @returns {string}
 */
Substitution.prototype.getKey = function(subDataflowNode){
    var key = "";
    var globalParamNames = subDataflowNode._getGlobalParamNames();
    for(var i = 0; i < globalParamNames.length; ++i){
        var channel = this.map[globalParamNames[i]];
        key+= (channel && channel.id || "-") + "!";
    }
    var paramNames = subDataflowNode._getParamNames();
    for(i = 0; i < paramNames.length; ++i){
        channel = this.map[paramNames[i]];
        key+= (channel && channel.id || "-") + ".";
    }
    return key;
};

/**
 *
 * @param {Substitution} substitution
 * @param {DataNode} dataflowNode
 * @param {ChannelNode} userChannelNode
 */
function createSubstitution(substitution, dataflowNode, userChannelNode){
    var userOwner = userChannelNode.owner;

    // Find channels for global parameters
    var globalParamNames = dataflowNode._getGlobalParamNames();
    for(var i = 0; i < globalParamNames.length; ++i){
        substitution.map[globalParamNames[i]] = userChannelNode.inputChannels.getChannel(globalParamNames[i]);
    }

    // Find channels for local parameters. These will override existing global parameters
    var paramNames = dataflowNode._getParamNames();
    for(i = 0; i < paramNames.length; ++i){
        var destName = paramNames[i], srcName = destName;
        if(userOwner._computeInputMapping){
            srcName = userOwner._computeInputMapping.getScriptInputName(i, destName);
        }
        substitution.map[destName] = userChannelNode.inputChannels.getChannel(srcName);
    }
}

module.exports = {
    ChannelNode:  ChannelNode,
    Substitution: Substitution
};

},{"../base.js":186,"../interface/constants.js":187,"../operator/operator.js":227,"./channel.js":231,"./data-slot.js":232,"./process-node.js":235}],231:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var BufferEntry = require("../interface/data.js").BufferEntry;


//----------------------------------------------------------------------------------------------------------------------
// DataSlot
//----------------------------------------------------------------------------------------------------------------------


//----------------------------------------------------------------------------------------------------------------------
// ChannelMap
//----------------------------------------------------------------------------------------------------------------------

/**
 * A map with channels.
 * @constructor
 */
var ChannelMap = function(){
    /**
     * A map of channels.
     * @type {Object.<string, {channel: Channel, childDataIndex: Number}>}
     */
    this.map = {};
};


/**
 * Return a list of all keys.
 * @returns {Array.<string>}
 */
ChannelMap.prototype.getNames = function()
{
    return Object.keys(this.map);
};

/**
 *
 * @param name
 * @returns {Channel}
 */
ChannelMap.prototype.getChannel = function(name)
{
    if(!this.map[name])
        return null;
    return this.map[name].channel;
};

ChannelMap.prototype.getChildDataIndex = function(name)
{
    if(!this.map[name])
        return undefined;
    return this.map[name].childDataIndex;
};
ChannelMap.prototype.getChildDataIndexForFilter = function(filter){
    var result;
    filter = filter || this.getNames();
    for(var i = 0; i < filter.length; ++i){
        var idx = this.getChildDataIndex(filter[i]);
        if(idx == undefined) continue;
        if(result != undefined && result != idx)
            result = -1;
        else
            result = idx;
    }
    return result;
};

/**
 * TODO: Add a mergeWithChildIndex method?
 * @param {ChannelMap} otherChannelMap
 * @param {number?} childDataIndex Index relative to DataNode. Used to mark if channel comes
 * from a specific child DataNode, undefined if ChannelMap should take over child index from otherChannelMap
 */
ChannelMap.prototype.merge = function(otherChannelMap, childDataIndex){
    for(var name in otherChannelMap.map){
        // Either use provided child index, otherwise use child index from ChannelMap to merge
        // For input channel map we define the childDataIndex directly, for applied filters we use the
        // childDataIndex of the provided ChannelMap (it's just a renaming)
        var index = childDataIndex == undefined ? otherChannelMap.getChildDataIndex(name) : childDataIndex;
        this.addChannel(name, otherChannelMap.getChannel(name), index);
    }
};
/**
 * Add a channel with a childDataIndex
 * The childDataIndex defines the origin of the channel.
 * If childDataIndex is undefined the value of the channel can't be determined from one single DataNode
 * @param {String} name
 * @param {Channel} channel
 * @param {Number?} childDataIndex
 */
ChannelMap.prototype.addChannel = function(name, channel, childDataIndex){
    // TODO: Check if this is ever called with a proper childDataIndex value
    if(!channel) return;
    if(childDataIndex == undefined) childDataIndex = -1;
    mergeChannelIntoChannel(this, name, channel, childDataIndex);
};

/**
 * Add DataSlot to the Channel
 * @param name
 * @param dataSlot
 */
ChannelMap.prototype.addDataEntry = function(name, dataSlot)
{
    mergeDataSlotIntoChannel(this, name, dataSlot, -1);
};
/**
 * Add an output DataSlot that originates from an operator
 * @param {String} name
 * @param {DataSlot} dataSlot
 * @param {ProcessNode} creatorNode
 */
ChannelMap.prototype.addOutputDataSlot = function(name, dataSlot, creatorNode){
    var finalChannel = mergeDataSlotIntoChannel(this, name, dataSlot, -1);
    finalChannel.creatorProcessNode = creatorNode;
};

/**
 * Empty the channel map.
 */
ChannelMap.prototype.clear = function(){
    for(var name in this.map){
        var channel = this.map[name];
        if(channel && channel.map == this)
            channel.clear();
    }
    this.map = {};
};

function initChannelSlot(channelMap, name){
    if(!channelMap.map[name]){
        channelMap.map[name] = {
            channel: null,
            childDataIndex: undefined
        }
    }
}

function mergeChannelIntoChannel(channelMap, name, newChannel, childDataIndex){
    initChannelSlot(channelMap, name);
    var currentChannel = channelMap.map[name].channel;
    if(!currentChannel || !currentChannel.willMergeWithChannel(newChannel)) {
        channelMap.map[name].channel = newChannel;
        channelMap.map[name].childDataIndex = childDataIndex;
        return newChannel;
    }
    currentChannel = getMapOwnedChannel(channelMap, currentChannel);
    currentChannel.addChannelEntries(newChannel);
    channelMap.map[name].channel = currentChannel;
    channelMap.map[name].childDataIndex = -1;
    return currentChannel;
}

function mergeDataSlotIntoChannel(channelMap, name, dataSlot, childDataIndex){
    initChannelSlot(channelMap, name);
    var currentChannel = channelMap.map[name].channel;
    if(!currentChannel || !currentChannel.willMergeWithDataSlot(dataSlot)){
        var channel = new Channel(channelMap, dataSlot);
        channelMap.map[name].channel = channel;
        channelMap.map[name].childDataIndex = childDataIndex;
        return channel;
    }
    currentChannel = getMapOwnedChannel(channelMap, currentChannel);
    currentChannel.addDataSlot(dataSlot);
    channelMap.map[name].channel = currentChannel;
    channelMap.map[name].childDataIndex = -1;
    return currentChannel;
}


function getMapOwnedChannel(map, channel){
    if(channel.map != map){
        var newChannel = new Channel(map);
        newChannel.addChannelEntries(channel);
        newChannel.creatorProcessNode = channel.creatorProcessNode;
        return newChannel
    }
    return channel;
}


//----------------------------------------------------------------------------------------------------------------------
// Channel
//----------------------------------------------------------------------------------------------------------------------


/**
 * A channel may inclue several DataSlots/DataEntries
 * A declared Sequence will result in on channel with multiple DataEntries.
 * @constructor
 * @param {ChannelMap} map Owner of the channel
 * @param {DataSlot=} dataSlot Optional DataSlot added to the channel
 */
var Channel = function(map, dataSlot){
    /**
     * DataSlot entries sorted by key value
     * @type {Array.<DataSlot>}
     */
    this.entries = [];
    /**
     * Owner ChannelMap that created with channel.
     * Note: a channel can still exist in several ChannelMaps
     * @type {ChannelMap}
     */
    this.map = map;
    /**
     * Unique ID for this channel. Is used for several optimizations.
     */
    this.id = generateChannelId();
    /**
     * Listeners of this channels (usually ProcessNodes and RequestNodes)
     * @type {Array}
     */
    this.listeners = [];
    /**
     * The ProcessNode that created/extended the content of this channel
     * There can be only one creatorProcessNode per channel because
     * then ouput DataSlots of an operator will always have key "0"
     * If two operators influence the same sequence, the second operator'
     * output will replace the first operator's output, effectively removing the dependency.
     * @type {null}
     */
    this.creatorProcessNode = null;

    if(dataSlot){
        this.addDataSlot(dataSlot);
    }
};

/**
 * Add a dataSlot to the channel, adding dependencies.
 * No notifications send etc.
 * Makes sure that resulting channel has dataSlots ordered by key
 * @param dataSlot
 */
Channel.prototype.addDataSlot = function(dataSlot){
    dataSlot.addChannel(this);
    for(var i = 0; i < this.entries.length; ++i){
        var entry = this.entries[i];
        // We use epsilon here to detect data entries with "equal" key
        if(entry.key >= dataSlot.key - C.EPSILON ){
            if(Math.abs(entry.key - dataSlot.key) <= C.EPSILON){
                entry.removeChannel(this);
                this.entries.splice(i, 1, dataSlot);
            }
            else{
                this.entries.splice(i, 0, dataSlot);
            }
            break;
        }
    }
    this.entries.push(dataSlot);
};

Channel.prototype.getSequenceLength = function(){
    return this.entries.length;
};
Channel.prototype.getSequenceMinKey = function(){
    return this.entries[0].key;
};
Channel.prototype.getSequenceMaxKey = function(){
    return this.entries[this.entries.length - 1].key;
};
/**
 * The DataType of the channel.
 * Since all DataEntries within a channel have the same type, we can simply return the type of the first entry.
 * @returns {DATA_TYPE}
 */
Channel.prototype.getType = function(){
    if(this.entries.length == 0)
        return C.DATA_TYPE.UNKNOWN;
    else
        return this.entries[0].dataEntry._type;
};
/**
 * Merge another channel into this channel.
 */
Channel.prototype.addChannelEntries = function(otherChannel){
    for(var i = 0; i < otherChannel.entries.length; ++i){
        var slot = otherChannel.entries[i];
        this.addDataSlot(slot);
    }
    // FIXME: otherChannel might be without creatorProcessNode but still define a DataSlot with key 0
    // In this case we have to set creatorProcessNode to null
    if(otherChannel.creatorProcessNode)
        this.creatorProcessNode = otherChannel.creatorProcessNode;
    //else
    //    this.creatorProcessNode = null;
};
/**
 * Return a DataEntry from this channel depending on sequenceKey.
 * @param {C.SEQUENCE?} sequenceAccessType
 * @param {number?} sequenceKey
 * @returns {DataEntry}
 */
Channel.prototype.getDataEntry = function(sequenceAccessType, sequenceKey){
    if(this.entries.length == 0)
        return null;
    if(!sequenceAccessType){
        return this.entries[0].dataEntry;
    }


    var i = 0, max = this.entries.length;
    // TODO: Do binary search here?
    while(i < max && this.entries[i].key < sequenceKey) ++i;
    if(sequenceAccessType == C.SEQUENCE.PREV_BUFFER){
        return this.entries[i ? i -1 : 0].dataEntry;
    }
    else if(sequenceAccessType == C.SEQUENCE.NEXT_BUFFER){
        return this.entries[i < max ? i : max - 1].dataEntry;
    }
    else if(sequenceAccessType == C.SEQUENCE.LINEAR_WEIGHT){
        var weight1 = this.entries[i ? i - 1 : 0].key;
        var weight2 = this.entries[i < max ? i : max - 1].key;
        var value = new Float32Array(1);
        value[0] = weight2 == weight1 ? 0 : (sequenceKey - weight1) / (weight2 - weight1);
        // TODO: Check if repeated BufferEntry and Float32Array allocation is a serious bottleneck
        return new BufferEntry(C.DATA_TYPE.FLOAT, value);
    }
    return null;
};

/**
 * Return true of the two channels need to be merged (instead of replacing this channel with otherChannel)
 * @param otherChannel
 * @returns {boolean}
 */
Channel.prototype.willMergeWithChannel = function(otherChannel){
    if(this.entries.length != otherChannel.entries.length) return true;
    if(this.getType() != otherChannel.getType())
        return false;
    for(var i = 0; i < this.entries.length; i++){
        if(Math.abs(this.entries[i].key - otherChannel.entries[i].key) > C.EPSILON)
            return true;
    }
    return false;
};
/**
 * Return true if we need to merge the channel with this dataSlot
 * (instead of creating a new channel fromthis dataSlot)
 * @param dataSlot
 * @returns {boolean}
 */
Channel.prototype.willMergeWithDataSlot = function(dataSlot){
    if(this.entries.length > 1) return true;
    if(this.getType() != dataSlot.dataEntry._type) return false;
    return (Math.abs(this.entries[0].key - dataSlot.key) > C.EPSILON);
};

Channel.prototype.notifyOnChange = function(state){
    for(var i = 0; i < this.listeners.length; i++){
        this.listeners[i].onXflowChannelChange(this, state);
    }
};

Channel.prototype.addListener = function(processNode){
    this.listeners.push(processNode);
};
Channel.prototype.removeListener = function(processNode){
    var idx = this.listeners.indexOf(processNode);
    if(idx != -1) this.listeners.splice(idx, 1);
};

Channel.prototype.clear = function(){
    for(var i = 0; i < this.entries.length; ++i){
        this.entries[i].removeChannel(this);
    }
};

var c_channelKeyIdx = 0;
function generateChannelId(){
    return ++c_channelKeyIdx;
}

module.exports = {
    Channel: Channel,
    ChannelMap: ChannelMap
};

},{"../base.js":186,"../interface/constants.js":187,"../interface/data.js":188}],232:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");

/**
 * A DataSlot wraps a dataEntry and adds a key value for sequences.
 * This structure is used internally within channels and process nodes
 * @constructor
 * @param {DataEntry} dataEntry
 * @param {number=} key
 */
var DataSlot = function(dataEntry, key){
    this.key = key || 0;            // sequence key
    this.dataEntry = dataEntry;     // dataEntry of the slot
    /**
     * alternative dataEntry for asynchronous processing
     * only used for output DataSlots of asynchronous operators
     * @type {DataEntry}
     */
    this.asyncDataEntry = null;
    /**
     * list of all channels that contain this DataSlot
     * @type {Array.<Channel>}
     */
    this.parentChannels = [];

};
DataSlot.prototype.addChannel = function(channel){
    this.parentChannels.push(channel);
};
DataSlot.prototype.removeChannel = function(channel){
    var idx = this.parentChannels.indexOf(channel);
    if(idx != -1) this.parentChannels.splice(idx, 1);
};
DataSlot.prototype.swapAsync = function(){
    var tmp = this.dataEntry;
    this.dataEntry = this.asyncDataEntry;
    this.asyncDataEntry = tmp;
};

DataSlot.prototype.setDataEntry = function(dataEntry, changeType){
    this.dataEntry = dataEntry;
    var state = changeType == C.RESULT_STATE.CHANGED_DATA_VALUE ? C.DATA_ENTRY_STATE.CHANGED_VALUE :
        C.DATA_ENTRY_STATE.CHANGED_SIZE;
    this.notifyOnChange(state);
};

DataSlot.prototype.notifyOnChange = function(state){
    for(var i = 0; i < this.parentChannels.length; ++i){
        this.parentChannels[i].notifyOnChange(state);
    }
};

module.exports = DataSlot;

},{"../base.js":186,"../interface/constants.js":187}],233:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var OperatorList = require("../operator/operator-list.js");
var Utils = require("../utils/utils.js");
var Operator = require("../operator/operator.js");
var OperatorEntry = require("../operator/operator-entry.js");
var Program = require("../operator/program.js");

//----------------------------------------------------------------------------------------------------------------------
// Executor
//----------------------------------------------------------------------------------------------------------------------

/**
 * Tries to combine multiple ProcessNodes into a Program. Currently only used for vertex shaders.
 *
 * @param {RequestNode|ProcessNode} ownerNode
 * @param {C.PLATFORM} platform
 * @constructor
 */
var Executor = function(ownerNode, platform){
    this.platform = platform;

    /**
     * Nodes that are merged by this executor
     * @type {Array.<ProcessNode|RequestNode>}
     */
    this.mergedNodes = [];

    /**
     * Subset of this.mergedNodes that directly provide results of the executor
     * @type {Array.<ProcessNode>}
     */
    this.mergedOutputNodes = [];

    /**
     * ProcessNodes to be executed before this executor can be
     * executed
     * @type {Array.<ProcessNode>}
     */
    this.subNodes = [];

    /**
     * TODO: Unused. Remove?
     * @type {Array}
     */
    this.unprocessedDataNames = [];

    /**
     *  TODO: Maybe we should just store the cl-platform objects in global object so they are more easily available and
     *  to avoid long prototype chains. Or we could pass the graph context to each node of the graph.
     *  However, it would be good to allow each Graph object to have at least own context, cmdQueue and kernelManager.
     *  e.g. passing graph information here requires a long prototype chain
     */
    this.operatorList =  new OperatorList(platform);
    this.programData =  new Program.ProgramData();

    /**
     *
     * @type {Program}
     */
    this.program = null;

    constructExecutor(this, ownerNode);
};

    Executor.prototype.isProcessed = function(){
        var i = this.mergedOutputNodes.length;
        while(i--){
            if(this.mergedOutputNodes[i].status != C.PROCESS_STATE.PROCESSED)
                return false;
        }
        return true;
    };


    Executor.prototype.run = function(asyncCallback){
        runSubNodes(this);
        updateIterateState(this); // TODO check if iterate State has changes in any way and only refetch program in that case

        this.program = Program.createProgram(this.operatorList);

        if(this.program){
            this.operatorList.allocateOutput(this.programData, !!asyncCallback);
            this.program.run(this.programData, asyncCallback);
        }
        if(this.platform != C.PLATFORM.ASYNC){
            var i = this.mergedOutputNodes.length;
            while(i--){
                this.mergedOutputNodes[i].status = C.PROCESS_STATE.PROCESSED;
            }
        }


    };

    Executor.prototype.getVertexShader = function(){
        runSubNodes(this);
        updateIterateState(this);

        this.program = Program.createProgram(this.operatorList);

        return this.program;
    };

/**
 * Construct Executor
 * @param executer
 * @param ownerNode
 */
function constructExecutor(executer, ownerNode){
    var cData = {
        blockedNodes: [],   // Bad Nodes that cannot be merge. Filled during pre scan
        doneNodes: [],      // Nodes that have been signed up for merging. TODO: Redundant with constructionOrder and subNodes? - maybe yes!
        constructionOrder: [], // Store nodes in order of construction of OperatorEntries.
        inputSlots: {},     // Collected input channels of all merged nodes. Used to avoid assigning same input buffer twice
        finalOutput: null,  // finalOutput channes in case we have a RequestNode
        firstOperator: null // Set to first operator that has been merged (will be executed last)
    };
    var requestNode = initRequestNode(cData, executer, ownerNode);

    var noOperators = false; // TODO: Remove this?
    constructPreScan(cData, ownerNode, executer.platform, noOperators);

    setConstructionOrderAndSubNodes(cData, executer, ownerNode);

    constructFromData(executer, cData);
}
/**
 * Only relevant if ownerNodes is a RequestNode
 * Sets finalOutput of construction data and unprocessedDataNames
 * @param cData
 * @param executer
 * @param ownerNode
 * @returns {boolean}
 */
function initRequestNode(cData, executer, ownerNode){
    if(true) { // FIXME: ownerNode instanceof RequestNode){
        cData.finalOutput = {};
        var filter = ownerNode.filter || ownerNode.owner.outputChannels.getNames();
        for(var i = 0; i < filter.length; ++i){
            var name = filter[i];
            var channel = ownerNode.owner.outputChannels.getChannel(name);
            if(channel && channel.creatorProcessNode)
                cData.finalOutput[name] = channel.getDataEntry();
        }
        Utils.nameset.add(executer.unprocessedDataNames, filter);
        return true;
    }
    return false;
}
/**
 * Goes to processing subtree at filled blockedNodes array in construction data.
 * All nodes that cannot be merged or have parents that can't be merged will be blocked
 * @param cData
 * @param node
 * @param platform
 * @param noOperators
 */
function constructPreScan(cData, node, platform, noOperators){
    if(cData.blockedNodes.indexOf(node) != -1)
        return;

    if(node.operator){
        if(noOperators || !canOperatorMerge(cData, node.operator, platform)){
            blockSubtree(cData, node);
            return;
        }
        else{
            if(!cData.firstOperator) cData.firstOperator = node.operator;
            var mapping = node.operator.mapping;
            for(var i = 0; i < mapping.length; ++i){
                if(mapping[i].sequence){
                    blockInput(cData, node, mapping[i].source);
                    blockInput(cData, node, mapping[i].keySource);
                }
                else if(mapping[i].array){
                    // TODO: Rename .array to .randomAccess
                    blockInput(cData, node, mapping[i].source);
                }
            }
        }
    }
    for(var i = 0; i < node.children.length; ++i){
        constructPreScan(cData, node.children[i], platform, noOperators);
    }
}

function canOperatorMerge(cData, operator, platform){
    // TODO: Detect merge support
    return (platform == C.PLATFORM.ASYNC || !Operator.isOperatorAsync(operator)) &&
        (!cData.firstOperator ||
        (platform == C.PLATFORM.GLSL && cData.firstOperator.evaluate_glsl && operator.evaluate_glsl));
}

function blockSubtree(cData, node){
    if(cData.blockedNodes.indexOf(node) != -1)
        return;

    cData.blockedNodes.push(node);
    for(var i = 0; i < node.children.length; ++i){
        blockSubtree(cData, node.children[i]);
    }
}
/**
 * Block all processNodes assigned to an input channel
 * @param cData
 * @param node
 * @param inputName
 */
    function blockInput(cData, node, inputName){
        var channel = node.inputChannels[inputName];
        if(channel && channel.creatorProcessNode){
            blockSubtree(cData, channel.creatorProcessNode);
        }
    }
/**
 * Fill doneNodes and constructionOrder arrays of construction data.
 * It also fills the subNodes array of the executer
 * @param cData construction data
 * @param executer
 * @param node
 */
    function setConstructionOrderAndSubNodes(cData, executer, node){
        if(cData.doneNodes.indexOf(node) != -1)
            return;

        cData.doneNodes.push(node);

        if(cData.blockedNodes.indexOf(node) != -1){
            executer.subNodes.push(node);
        }
        else{
            for(var i = 0; i < node.children.length; ++i){
                setConstructionOrderAndSubNodes(cData, executer, node.children[i]);
            }

            if(node.operator){ // RequestNodes don't have an operator. Consider this case.
                cData.constructionOrder.push(node);
            }
        }
    }
/**
 * Last step of construction: create OperatorList from constructionOrder array
 * Also fill mergedNodes and programData
 * @param executer
 * @param cData
 */
    function constructFromData(executer, cData){

        for(var i = 0; i < cData.constructionOrder.length; ++i){
            var node = cData.constructionOrder[i];

            var entry = new OperatorEntry(node.operator);

            constructInputConnection(executer, entry, cData, node);

            var isOutputNode = constructOutputConnection(executer, entry, cData, node);

            executer.programData.operatorData.push({});
            executer.operatorList.addEntry(entry);
            executer.mergedNodes.push(node);
            if(isOutputNode || (i == cData.constructionOrder.length-1))
                executer.mergedOutputNodes.push(node)

        }

        constructLostOutput(executer, cData);
    }
/**
 * Construct input info for OperatorEntry.
 * Will implicitly create ProgramInputConnections for ProgramData
 * @param {Executor} executer
 * @param {OperatorEntry} entry
 * @param {{}} cData
 * @param {ProcessNode} node
 */
    function constructInputConnection(executer, entry, cData, node){
        var mapping = node.operator.mapping;
        for(var j = 0; j < mapping.length; ++j){
            var channel = node.inputChannels[mapping[j].source];
            var operatorIndex;
            if(channel && channel.creatorProcessNode && (operatorIndex =
                executer.mergedNodes.indexOf(channel.creatorProcessNode) ) != -1 )
            {
                // it's transfer input
                var outputIndex = getOperatorOutputIndex(channel.creatorProcessNode, channel);
                entry.setTransferInput(j, operatorIndex, outputIndex);
                var prevOperator = executer.operatorList.entries[operatorIndex];
                if(!prevOperator.isFinalOutput(outputIndex)){
                    prevOperator.setTransferOutput(outputIndex);
                }
                continue;
            }
            // Handle direct input

            var mappedInputName = mapping[j].source;
            if(node.owner.owner._computeInputMapping)
                mappedInputName = node.owner.owner._computeInputMapping.getScriptInputName(mapping[j].paramIdx, mapping[j].source);

            var connection = new Program.ProgramInputConnection();
            connection.channel = channel;
            connection.arrayAccess = mapping[j].array || false; // TODO: rename to randomAccess
            connection.sequenceAccessType = mapping[j].sequence || 0;
            if(connection.sequenceAccessType)
                connection.sequenceKeySourceChannel = node.inputChannels[mapping[j].keySource];

            var connectionKey = connection.getKey();
            var inputSlotIdx = cData.inputSlots[connectionKey];
            if(channel && inputSlotIdx != undefined){
                // Direct input already exists
                entry.setDirectInput(j, inputSlotIdx, mappedInputName);
            }
            else{
                // new direct input
                inputSlotIdx = executer.programData.inputs.length;
                cData.inputSlots[connectionKey] = inputSlotIdx;
                executer.programData.inputs.push(connection);
                entry.setDirectInput(j, inputSlotIdx, mappedInputName);
            }
        }
    }

/**
 * Construct output info of OperatorEntry
 * @param {Executor} executer
 * @param {OperatorEntry} entry
 * @param {{}} cData
 * @param {ProcessNode} node
 */
    function constructOutputConnection(executer, entry, cData, node){
        var outputs = node.operator.outputs;
        var isOutputNode = true;
        for(var i = 0; i < outputs.length; ++i){
            var slot = node.outputDataSlots[outputs[i].name];
            var finalOutputName = getFinalOutputName(slot, cData);
            if(finalOutputName){
                var index =  executer.programData.outputs.length;
                executer.programData.outputs.push(slot);
                entry.setFinalOutput(i, index);
                if(finalOutputName !== true){
                    Utils.nameset.remove(executer.unprocessedDataNames, finalOutputName);
                }
            }
            else{
                isOutputNode = false;
            }
        }
        return isOutputNode; // TODO: Check if computation of isOutputNode is really correct?
    }


    function getOperatorOutputIndex(processNode, channel){
        var outputs = processNode.operator.outputs;
        for(var i = 0; i < outputs.length; ++i){
            if(channel.getDataEntry() == processNode.outputDataSlots[outputs[i].name].dataEntry){
                return i;
            }
        }
        return null;
    }

    function getFinalOutputName(dataSlot, cData){
        if(!cData.finalOutput) // If root of Executor is a ProcessNode we don't have finalOutput defined and all outputs are final.
            return true;
        for(var name in cData.finalOutput){
            if(cData.finalOutput[name] == dataSlot.dataEntry){
                return name;
            }
        }
        return false;
    }

    function constructLostOutput(executer, cData){
        for(var i = 0; i < cData.constructionOrder.length; ++i){
            var node = cData.constructionOrder[i];
            var entry = executer.operatorList.entries[i];

            var outputs = node.operator.outputs;
            for(var j = 0; j < outputs.length; ++j){
                if(!entry.isFinalOutput(j) && ! entry.isTransferOutput(j)){
                    var index = executer.programData.outputs.length;
                    executer.programData.outputs.push(node.outputDataSlots[outputs[j].name]);
                    entry.setLostOutput(j, index);
                }
            }
        }
    }


    function updateIterateState(executer){
        var inputs = executer.programData.inputs;
        for(var i = 0; i < executer.programData.inputs.length; ++i){
            var entry = executer.programData.getDataEntry(i);
            var iterateCount = entry ? entry.getIterateCount ? entry.getIterateCount() : 1 : 0;
            if(!iterateCount)
                executer.operatorList.setInputIterateType(i, C.ITERATION_TYPE.NULL);
            else if(!inputs[i].arrayAccess && iterateCount > 1)
                executer.operatorList.setInputIterateType(i, C.ITERATION_TYPE.MANY);
            else
                executer.operatorList.setInputIterateType(i, C.ITERATION_TYPE.ONE);

            if(inputs[i].arrayAccess && platformRequiresArraySize(executer. platform)){
                executer.operatorList.setInputSize(i, iterateCount);
            }
        }
    }
/**
 * Determine if the platform needs to declare uniform array sizes in the source code.
 * @param platform
 * @returns {boolean}
 */
    function platformRequiresArraySize(platform){
        return platform == C.PLATFORM.GLSL;
    }


    function runSubNodes(executer){
        for(var i = 0; i < executer.subNodes.length; ++i){
            executer.subNodes[i].process();
        }
    }

module.exports = Executor;

},{"../base.js":186,"../interface/constants.js":187,"../operator/operator-entry.js":225,"../operator/operator-list.js":226,"../operator/operator.js":227,"../operator/program.js":228,"../utils/utils.js":238}],234:[function(require,module,exports){
var Base = require("../base.js");
var C = require("./../interface/constants.js");


var orderMappingParser = /^([^:,{}]+)(,[^:{},]+)*$/;
var nameMappingParser = /^\{(([^:,{}]+:[^:{},]+)(,[^:{},]+:[^:},]+)*)}$/;

/**
 * A mapping used for a filter or a compute properties of a DataNode
 * @abstract
 */
var Mapping = function(){
    /**
     * @type {Array<DataNode>}
     */
    this._owners = [];
};

/**
 * Parse a Mapping (both C.OrderMapping or C.ComputeMapping) from a syntax string.
 * @param {string} string The syntax string.
 * @param {C.DataNode} dataNode DataNode of the Mapping
 * @returns {?C.Mapping}
 */
Mapping.parse = function(string, dataNode){
    string = string.trim();
    var results = string.trim().match(orderMappingParser);
    if(results)
        return OrderMapping.parse(string, dataNode);
    results = string.trim().match(nameMappingParser);
    if(results)
        return NameMapping.parse(results[1], dataNode);
    Base.notifyError("Cannot parse name mapping '" + string + "'", dataNode);
    return null;
};

/**
 *
 * @param {DataNode} owner
 * @private
 */
Mapping.prototype._addOwner = function(owner){
    var idx = this._owners.indexOf(owner);
    if(idx == -1)
        this._owners.push(owner);
};

/**
 *
 * @param {DataNode} owner
 * @private
 */
Mapping.prototype._removeOwner = function(owner){
    var idx = this._owners.indexOf(owner);
    if(idx != -1)
        this._owners.splice(idx, -1);
};


//----------------------------------------------------------------------------------------------------------------------
// OrderMapping
//----------------------------------------------------------------------------------------------------------------------

/**
 * An OrderMapping used for a filter or compute properties of a DataNode
 * It describes a mapping of names referring to the order of arguments / output values.
 * OrderMapping syntax examples in compute:
 * position = C.morph(position, posAdd, weight)
 * @constructor
 * @extends {Mapping}
 */
var OrderMapping = function(){
    Mapping.call(this);
    this._names = [];
};
Base.createClass(OrderMapping, Mapping);

OrderMapping.parse = function(string, dataNode){
    var mapping = new OrderMapping(dataNode);
    var token = string.split(",");
    for(var i = 0; i < token.length; i++){
        mapping._names.push(token[i].trim());
    }
    return mapping;
};


Object.defineProperty(OrderMapping.prototype, "length", {
    set: function(){ throw new Error("length is read-only");
    },
    get: function(){ return this._names.length; }
});

OrderMapping.prototype.getName = function(idx){
    return this._names[idx];
};

OrderMapping.prototype.clear = function(){
    this._names = [];
    mappingNotifyOwner(this);
};

OrderMapping.prototype.setName = function(index, name){
    this._names[index] = name;
    mappingNotifyOwner(this);
};


//noinspection JSUnusedGlobalSymbols
OrderMapping.prototype.removeName = function(index){
    this._names.splice(index);
    mappingNotifyOwner(this);
};

OrderMapping.prototype.isEmpty = function(){
    return this._names.length == 0;
};

/**
 *
 * @param {ChannelMap} destMap
 * @param {ChannelMap} sourceMap
 * @param {exports.C.DATA_FILTER_TYPE} filterType
 * @param {function(ChannelMap, string, ChannelMap, string)} callback
 */
OrderMapping.prototype.applyFilterOnChannelMap = function(destMap, sourceMap, filterType, callback){
    var i;
    if(filterType == C.DATA_FILTER_TYPE.KEEP){
        for(i = 0; i < this._names.length; ++i){
            var name = this._names[i];
            if(sourceMap.map[name]) {
                callback(destMap, name, sourceMap, name);
            }
        }
    }
    else{
        for(i in sourceMap.map){
            var idx = this._names.indexOf(i);
            if(filterType == C.DATA_FILTER_TYPE.RENAME ||
                (filterType == C.DATA_FILTER_TYPE.REMOVE && idx == -1))
                callback(destMap, i, sourceMap, i);
        }
    }
};

/**
 * Return the name of the input value assigned to operator argument.
 * Returns null, if no mapping is defined.
 * @param {number} index Position of the operator argument
 * @returns {string|null}
 */
OrderMapping.prototype.getScriptInputName = function(index /*, destName */){
    if(this._names[index])
        return this._names[index];
    else
        return null;
};

/**
 * Returns the name of the output parameter as it should be used for the
 * following dataflow. Returns null, if no mapping is defined.
 * @param index
 * @returns {string|null}
 */
OrderMapping.prototype.getScriptOutputName = function(index /*, srcName */){
    if(this._names[index])
        return this._names[index];
    else
        return null;
};

/**
 * Returns the inverse name of the output parameter as it should be used for the
 * following dataflow. Returns null, if no mapping is defined.
 * @param {string} destName
 * @param {array<object>} operatorOutputs
 * @returns {string|null}
 */
OrderMapping.prototype.getScriptOutputNameInv = function(destName, operatorOutputs){
    var index = this._names.indexOf(destName);
    if(index == -1)
        return null;
    return operatorOutputs[index].name;
};

/**
 * Identity function. Used to implement interface. Usually you don't rename with order
 * mapping.
 * @param name
 * @returns {string}
 */
OrderMapping.prototype.getRenameSrcName = function(name){
    return name;
};

//----------------------------------------------------------------------------------------------------------------------
// NameMapping
//----------------------------------------------------------------------------------------------------------------------

/**
 * An NameMapping used for a filter or compute properties of a DataNode
 * It describes a mapping of names referring to the original names of the arguments / output values.
 * NameMapping syntax examples in compute:
 * {position: result} = C.morph({value: position, valueAdd: posAdd, weight: weight})
 * @constructor
 * @extends {Mapping}
 */
var NameMapping = function(){
    Mapping.call(this);
    this._destNames = [];
    this._srcNames = [];

};
Base.createClass(NameMapping, Mapping);

NameMapping.parse = function(string, dataNode)  {
    var mapping = new NameMapping(dataNode);
    var token = string.split(",");
    for(var i = 0; i < token.length; i++){
        var pair = token[i].split(":");
        var dest = pair[0].trim(); var src = pair[1].trim();
        mapping.setNamePair(dest, src);
    }
    return mapping;
};

Object.defineProperty(NameMapping.prototype, "length", {
    set: function(){ throw new Error("length is read-only");
    },
    get: function(){ return this._srcNames.length; }
});

NameMapping.prototype.getDestName = function(idx){
    return this._destNames[idx];
};
NameMapping.prototype.getSrcName = function(idx){
    return this._srcNames[idx];
};

NameMapping.prototype.getSrcNameFromDestName = function(destName){
    var idx = this._destNames.indexOf(destName);
    return idx == -1 ? null : this._srcNames[idx];
};
NameMapping.prototype.getDestNameFromSrcName = function(srcName){
    var idx = this._srcNames.indexOf(srcName);
    return idx == -1 ? null : this._destNames[idx];
};

NameMapping.prototype.clear = function(){
    this._srcNames = [];
    this._destNames = [];
    mappingNotifyOwner(this);
};

NameMapping.prototype.setNamePair = function(destName, srcName){
    var idx = this._destNames.indexOf(destName);
    if(idx != -1){
        this._destNames.splice(idx,1);
        this._srcNames.splice(idx,1);
    }
    this._destNames.push(destName);
    this._srcNames.push(srcName);
    mappingNotifyOwner(this);
};

//noinspection JSUnusedGlobalSymbols
NameMapping.prototype.removeNamePair = function(destName){
    var idx = this._destNames.indexOf(destName);
    if(idx != -1){
        this._destNames.splice(idx,1);
        this._srcNames.splice(idx,1);
    }
    mappingNotifyOwner(this);
};

NameMapping.prototype.isEmpty = function(){
    return this._destNames.length == 0;
};

/**
 * @see OrderMapping.applyFilterOnChannelMap
 * @param {ChannelMap} destMap
 * @param {ChannelMap} sourceMap
 * @param {C.DATA_FILTER_TYPE} filterType
 * @param {function} callback
 */
NameMapping.prototype.applyFilterOnChannelMap = function(destMap, sourceMap, filterType, callback) {
    var i;
    if(filterType == C.DATA_FILTER_TYPE.REMOVE){
        for(i in sourceMap.map)
            if(this._srcNames.indexOf(i) == -1)
                callback(destMap, i, sourceMap, i);
    }
    else{
        if(filterType == C.DATA_FILTER_TYPE.RENAME){
            for(i in sourceMap.map)
                if(this._srcNames.indexOf(i) == -1)
                    callback(destMap, i, sourceMap, i);
        }
        for(i in this._destNames){
            callback(destMap, this._destNames[i], sourceMap, this._srcNames[i]);
        }
    }
};

/**
 * Renames: Look-up the destination name and return the source name
 * @param {string} name
 * @returns {string}
 */
NameMapping.prototype.getRenameSrcName = function(name){
    return this.getSrcNameFromDestName(name) || name;
};

/**
 * Return the name of the input value assigned to operator argument
 * @param {number} index Position of the operator argument
 * @param {string} destinationName Name of the operator argument
 * @returns {string|null}
 */
NameMapping.prototype.getScriptInputName= function(index, destinationName){
    return this.getSrcNameFromDestName(destinationName);
};

/**
 * @see OrderMapping.getScriptOutputName
 */
NameMapping.prototype.getScriptOutputName = function(index, srcName){
    return this.getDestNameFromSrcName(srcName);
};

/**
 * @see OrderMapping.getScriptOutputNameInv
 */
NameMapping.prototype.getScriptOutputNameInv = function(destName /*, operatorOutputs */){
    var index = this._destNames.indexOf(destName);
    if(index == -1)
        return null;
    return this._srcNames[index];
};

/**
 * Notify all DataNodes that use the mapping passed to the function
 * @param {Mapping} mapping
 */
function mappingNotifyOwner(mapping){
    for(var i = 0; i < mapping._owners.length; ++i) {
        mapping._owners[i].notify(C.RESULT_STATE.CHANGED_STRUCTURE);
    }
    Base._flushResultCallbacks();
}
module.exports = {
    NameMapping: NameMapping,
    OrderMapping: OrderMapping,
    Mapping: Mapping
};

},{"../base.js":186,"./../interface/constants.js":187}],235:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var utils = require("../utils/utils.js");
var Executor = require("./executor.js");
var Result = require("./result.js");
var Operator = require("../operator/operator.js");
var Data = require("../interface/data.js");
var DataSlot = require("../processing/data-slot.js");

var BufferEntry = Data.BufferEntry;
var TextureEntry = Data.TextureEntry;
var ImageDataTextureEntry = Data.ImageDataTextureEntry;

//----------------------------------------------------------------------------------------------------------------------
// C.ProcessNode
//----------------------------------------------------------------------------------------------------------------------

var ASYNC_PROCESS_STATE = {
    IDLE : 0,
    RUNNING : 1,
    RESCHEDULED : 2,
    INIT: 3
};


/**
 * Optimized representation for the processing graph. Only created for ChannelNodes with operators.
 * Is connected directly to other ProcessNodes, ignoring channels that are not relevant for processing
 * @param {ChannelNode} channelNode
 * @constructor
 * @extends {GraphNode}
 */
var ProcessNode = function(channelNode){
    this.owner = channelNode;
    this.operator = channelNode.operator;

    /**
     * Input channels for the operator
     * @type {Object.<string, Channel>}
     */
    this.inputChannels = {};

    /**
     * Outputs of operator
     * @type {Object.<string, DataSlot>}
     */
    this.outputDataSlots = {};

    /**
     * @type {exports.C.PROCESS_STATE}
     */
    this.status = C.PROCESS_STATE.MODIFIED;

    /**
     * @type {ASYNC_PROCESS_STATE}
     */
    this.asyncProcessState = ASYNC_PROCESS_STATE.INIT;

    /**
     * Direct Children without transitive children of children
     * TODO: Use Set()?
     * @type {Array.<ProcessNode>}
     */
    this.children = [];

    /**
     * Children with transitive dependencies
     * TODO: Use Set()?
     * @type {Array.<ProcessNode>}
     */
    this.descendants = [];

    /**
     * Callback, the executor needs to call when the computation is ready
     * @type {Function}
     * @private
     */
    this._bindedAsyncCallback = null;

    /**
     * Index of array matches platform id (C.PLATFORM)
     * @type {Array.<Executor>}
     */
    this.executers = [];

    constructProcessNode(this, channelNode);

    if(Operator.isOperatorAsync(this.operator)){
        this._bindedAsyncCallback = this.receiveAsyncProcessing.bind(this);
    }
};

ProcessNode.prototype.onXflowChannelChange = function(channel, state){
    if (Operator.isOperatorAsync(this.operator)) {
        if (this.status == C.PROCESS_STATE.LOADING || this.asyncProcessState != ASYNC_PROCESS_STATE.INIT) {
            this.status = C.PROCESS_STATE.MODIFIED;
            this.updateState();
        }
    }
    else {

        if (state == C.DATA_ENTRY_STATE.CHANGED_VALUE && this.status > C.PROCESS_STATE.UNPROCESSED) {
            this.status = C.PROCESS_STATE.UNPROCESSED;
        } else {
            this.status = C.PROCESS_STATE.MODIFIED;
        }
        this.notifyOutputChanged(state);
    }
};

ProcessNode.prototype.startAsyncProcessing = function(){
    if(this.asyncProcessState == ASYNC_PROCESS_STATE.IDLE || this.asyncProcessState == ASYNC_PROCESS_STATE.INIT){
        this.asyncProcessState = ASYNC_PROCESS_STATE.RUNNING;
        var executer = getOrCreateExecuter(this, C.PLATFORM.ASYNC);
        executer.run(this._bindedAsyncCallback);
    }
    else{
        this.asyncProcessState = ASYNC_PROCESS_STATE.RESCHEDULED;
    }
};
ProcessNode.prototype.receiveAsyncProcessing = function(){
    this.status = C.PROCESS_STATE.PROCESSED;
    this.notifyOutputChanged(C.DATA_ENTRY_STATE.CHANGED_SIZE_TYPE);
    if(this.asyncProcessState == ASYNC_PROCESS_STATE.RESCHEDULED){
        this.asyncProcessState = ASYNC_PROCESS_STATE.IDLE;
        this.status = C.PROCESS_STATE.MODIFIED;
        this.updateState();
    }
    else{
        this.asyncProcessState = ASYNC_PROCESS_STATE.IDLE;
    }
    Base._flushResultCallbacks();
};



ProcessNode.prototype.notifyOutputChanged = function(state){
    for(var name in this.outputDataSlots){
        this.outputDataSlots[name].notifyOnChange(state);
    }
};


ProcessNode.prototype.clear = function(){
    for(var name in this.inputChannels){
        this.inputChannels[name] && this.inputChannels[name].removeListener(this);
    }
    for (var i = 0; i < this.children.length; i++) {
        this.children[i].clear();
    }
};

ProcessNode.prototype.updateState = function(){
    if(this.status == C.PROCESS_STATE.MODIFIED){
        this.status = C.PROCESS_STATE.UNPROCESSED;

        XML3D.debug.assert(!this.owner.loading, "This should never happen");

        if(this.owner.loading)
            this.status = C.PROCESS_STATE.LOADING;
        else{
            for(var i = 0; i < this.children.length; ++i){
                this.status = Math.min(this.status, this.children[i].updateState());
            }
            if(this.status > C.PROCESS_STATE.LOADING && isInputLoading(this.operator, this.inputChannels))
                this.status = C.PROCESS_STATE.LOADING;

            if(this.status > C.PROCESS_STATE.INVALID &&
                !checkInput(this, this.operator, this.owner.owner._computeInputMapping, this.inputChannels))
                this.status = C.PROCESS_STATE.INVALID;

            if(this.status == C.PROCESS_STATE.UNPROCESSED && Operator.isOperatorAsync(this.operator)){
                this.status = this.asyncProcessState == ASYNC_PROCESS_STATE.INIT ? C.PROCESS_STATE.LOADING
                    : C.PROCESS_STATE.PROCESSED;
                this.startAsyncProcessing();
            }

        }
    }
    return this.status;
};

ProcessNode.prototype.process = function(){

    if(this.status == C.PROCESS_STATE.UNPROCESSED){
        var executer = getOrCreateExecuter(this, this.owner.platform);
        executer.run();
        this.status = C.PROCESS_STATE.PROCESSED;
    }
};

/**
 *
 * @param {ProcessNode} processNode
 * @param {ChannelNode} channelNode
 */
function constructProcessNode(processNode, channelNode){
    var dataNode = channelNode.owner;
    synchronizeInputChannels(processNode, channelNode, dataNode);
    synchronizeChildrenAndDescendants(processNode.children, processNode.descendants, processNode.inputChannels);
    synchronizeOutput(processNode.operator, processNode.outputDataSlots);
}

/**
 *
 * @param processNode
 * @param channelNode
 * @param dataNode
 */
function synchronizeInputChannels(processNode, channelNode, dataNode){
    var operator = processNode.operator, inputMapping = dataNode._computeInputMapping;
    for(var i = 0; i < operator.params.length; ++i){
        var sourceName = operator.params[i].source;
        var dataName = inputMapping ? inputMapping.getScriptInputName(i, sourceName) : sourceName;
        if(dataName){
            var channel = channelNode.inputChannels.getChannel(dataName);
            if(channel) channel.addListener(processNode);
            processNode.inputChannels[sourceName] = channel;
        }
    }
}

function isInputLoading(operator, inputChannels){
    for(var i in operator.params){
        var entry = operator.params[i];
        var channel = inputChannels[entry.source];
        if(!channel) continue;
        var dataEntry = channel.getDataEntry();
        if(!dataEntry) continue;
        if(dataEntry.isLoading && dataEntry.isLoading()) return true;
    }
    return false;
}

function checkInput(processNode, operator, inputMapping, inputChannels){
    var dataNode = processNode.owner.owner;
    for(var i in operator.params){
        var entry = operator.params[i];
        var dataName = inputMapping ? inputMapping.getScriptInputName(i, entry.source) : entry.source;
        if(!entry.optional && !dataName){
            Base.notifyError("Xflow: operator " + operator.name + ": Missing input argument for "
                + entry.source, dataNode);
            return false;
        }
        if(dataName){
            var channel = inputChannels[entry.source];
            if(!channel){
                if(!inputMapping) continue;
                Base.notifyError("Xflow: operator " + operator.name + ": Input of name '" + dataName +
                    "' not found. Used for parameter " + entry.source, dataNode);
                return false;
            }
            var dataEntry = channel.getDataEntry();

            if(!channel.creatorProcessNode){
                if(!entry.optional && (!dataEntry || dataEntry.isEmpty())){
                    Base.notifyError("Xflow: operator " + operator.name + ": Input for " + entry.source +
                        ' contains no data.', dataNode);
                    return false;
                }
            }
            if(dataEntry && dataEntry.type != entry.type){
                Base.notifyError("Xflow: operator " + operator.name + ": Input for " + entry.source +
                    " has wrong type. Expected: " + C.getTypeName(entry.type)
                    + ", but got: " +  C.getTypeName(dataEntry.type), dataNode);
                return false;
            }
        }
    }
    return true;
}

function synchronizeChildrenAndDescendants(children, descendants, inputChannels){
    var channel;
    for(var name in inputChannels){
        channel = inputChannels[name];
        if(channel && channel.creatorProcessNode){
            utils.set.add(children, channel.creatorProcessNode);
            utils.set.add(descendants, channel.creatorProcessNode.descendants);
        }
    }
    utils.set.remove(children, descendants);
    utils.set.add(descendants, children);
}

function synchronizeOutput(operator, outputs){
    var async = Operator.isOperatorAsync(operator);
    for(var i in operator.outputs){
        var dataEntry = operator.outputs[i];

        var entry, asyncEntry;
        var type = dataEntry.type;
        if(type != C.DATA_TYPE.TEXTURE){
            entry = new BufferEntry(type, null);
            if(async) asyncEntry = new BufferEntry(type, null);
        }
        else{
            entry = window.document ? new TextureEntry(null) : new ImageDataTextureEntry(null);
            if(async) asyncEntry = window.document ? new TextureEntry(null) : new ImageDataTextureEntry(null);
        }
        outputs[dataEntry.name] = new DataSlot(entry, 0);
        if(async) outputs[dataEntry.name].asyncDataEntry = asyncEntry;
    }
}

function getOrCreateExecuter(node, platform){
    if(!node.executers[platform]){
        node.executers[platform] = new Executor(node, platform);
    }
    return node.executers[platform];
}


//----------------------------------------------------------------------------------------------------------------------
// RequestNode
//----------------------------------------------------------------------------------------------------------------------
/**
 *
 * FIXME: RequestNodes are never deleted.
 * @param {ChannelNode} channelNode
 * @param {Array.<string>} filter
 * @constructor
 */
var RequestNode = function(channelNode, filter){
    this.owner = channelNode;
    this.filter = filter;

    /**
     *
     * @type {Object<C.PLATFORM, exports.Result>}
     */
    this.results = {};

    /**
     * @type {exports.C.PROCESS_STATE}
     */
    this.status = C.PROCESS_STATE.MODIFIED;

    /**
     * @type {Object.<string, Channel>}
     */
    this.channels = {};

    /**
     * @see ProcessNode.children
     * @type {Array}
     */
    this.children = [];

    /**
     * @see ProcessNode.executers
     * @type {Array}
     */
    this.executers = [];

    /**
     * @see ProcessNode.outOfSync
     * @type {boolean}
     */
    this.outOfSync = true;
};

RequestNode.prototype.synchronize = function(){
    if(this.outOfSync){
        this.outOfSync = false;
        synchronizeRequestChannels(this, this.owner);
        synchronizeChildrenAndDescendants(this.children, [], this.channels);
    }
};

RequestNode.prototype.updateState = function(){
    this.synchronize();
    if(this.status == C.PROCESS_STATE.MODIFIED){
        this.status = C.PROCESS_STATE.UNPROCESSED;

        if(this.owner.loading) {
            this.status = C.PROCESS_STATE.LOADING;
        } else {
            for(var i = 0; i < this.children.length; ++i){
                this.status = Math.min(this.status, this.children[i].updateState());
            }
        }
    }
    return this.status;
};

RequestNode.prototype.getResult = function(resultType){
    this.updateState();

    // TODO: This could be in getRequestComputeResult
    if(this.status == C.PROCESS_STATE.UNPROCESSED){
        if(resultType == C.RESULT_TYPE.COMPUTE){
            var executer = getOrCreateExecuter(this, this.owner.platform);
            if(!executer.isProcessed())
                executer.run();
        }
        this.status = C.PROCESS_STATE.PROCESSED;
    }
    var result = null;
    if (resultType == C.RESULT_TYPE.COMPUTE) {
        result = getRequestComputeResult(this);
    } else if (resultType == C.RESULT_TYPE.VS) {
        result = getRequestVSResult(this);
    }
    result.loading = (this.status == C.PROCESS_STATE.LOADING);
    return result;
};

RequestNode.prototype.setStructureOutOfSync = function(){
    this.outOfSync = true;
    this.status = C.PROCESS_STATE.MODIFIED;
    for(var type in this.results){
        this.results[type]._notifyChanged(C.RESULT_STATE.CHANGED_STRUCTURE);
    }
    for(var name in this.channels){
        this.channels[name].removeListener(this);
    }
    this.channels = [];
    this.children = [];
    this.executers = [];
};

RequestNode.prototype.onXflowChannelChange = function(channel, state){
    if(channel.creatorProcessNode)
        this.status = C.PROCESS_STATE.MODIFIED;
    var notifyState = (state == C.DATA_ENTRY_STATE.CHANGED_VALUE ? C.RESULT_STATE.CHANGED_DATA_VALUE
            : C.RESULT_STATE.CHANGED_DATA_SIZE);

    for(var type in this.results){
        this.results[type]._notifyChanged(notifyState);
    }
};

RequestNode.prototype.clear = function() {
    this.setStructureOutOfSync();
    delete this.owner;
};

/**
 *
 * @param requestNode
 * @param channelNode
 */
function synchronizeRequestChannels(requestNode, channelNode){
    var names = requestNode.filter;
    if(!names){
        names = channelNode.outputChannels.getNames();
    }

    for(var i = 0; i < names.length; ++i){
        var name = names[i];
        var channel = channelNode.outputChannels.getChannel(name);
        if(channel){
            requestNode.channels[name] = channel;
            channel.addListener(requestNode);
        }
    }
}

/**
 *
 * @param {RequestNode} requestNode
 * @returns {Result}
 */
function getRequestComputeResult(requestNode)
{
    if(!requestNode.results[C.RESULT_TYPE.COMPUTE])
        requestNode.results[C.RESULT_TYPE.COMPUTE] = new Result.ComputeResult();

    var result = requestNode.results[C.RESULT_TYPE.COMPUTE];
    result._dataEntries = {}; result._outputNames = [];

    for(var name in requestNode.channels){
        var entry = requestNode.channels[name].getDataEntry();
        result._dataEntries[name] = entry && !entry.isEmpty() ? entry : null;
        result._outputNames.push(name);
    }
    return result;
}

/**
 *
 * @param requestNode
 * @returns {exports.VSDataResult}
 */
function getRequestVSResult(requestNode)
{
    var executer = getOrCreateExecuter(requestNode, C.PLATFORM.GLSL);
    if(!requestNode.results[C.RESULT_TYPE.VS])
        requestNode.results[C.RESULT_TYPE.VS] = new Result.VSDataResult();
    var result = requestNode.results[C.RESULT_TYPE.VS];

    var program = executer.getVertexShader();
    result._program = program;
    result._programData = executer.programData;
    return result;
}


module.exports = {
    RequestNode: RequestNode,
    ProcessNode: ProcessNode
};


},{"../base.js":186,"../interface/constants.js":187,"../interface/data.js":188,"../operator/operator.js":227,"../processing/data-slot.js":232,"../utils/utils.js":238,"./executor.js":233,"./result.js":236}],236:[function(require,module,exports){
var Base = require("../base.js");
require("../../utils/array.js");

var queueResultCallback = Base._queueResultCallback;

/**
 * Content of this file:
 * Result classes of an Xflow graph which are received through Requests.
 */

/**
 * Abstract Result structure containing a (processed) result of the Xflow graph.
 * @abstract
 */
var Result = function(){
    this.loading = false;
    /** Valid is false if an error occurred during the processing of the result */
    this.valid = false;
    this._listeners = [];
    this._requests = [];
};

/**
 * @param {function(Result, C.RESULT_STATE)} callback
 */
Result.prototype.addListener = function(callback){
    this._listeners.push(callback);
};

/**
 * @param {function(Result, C.RESULT_STATE)} callback
 */
Result.prototype.removeListener = function(callback){
    Array.erase(this._listeners, callback);
};

/**
 * @param {function(Result, C.RESULT_STATE)} callback
 */
Result.prototype._addRequest = function(request){
    this._requests.push(request);
};

/**
 * @param {function(Result, C.RESULT_STATE)} callback
 */
Result.prototype._removeRequest = function(request){
    Array.erase(this._requests, request);
};


Result.prototype._notifyChanged = function(state){
    this.valid = false;
    for(var i = 0; i < this._requests.length; ++i){
        this._requests[i]._onResultChanged(state);
    }
    queueResultCallback(this, state);
}

Result.prototype._onPostponedResultChanged = function(state){
    for(var i = 0; i < this._listeners.length; ++i){
        this._listeners[i](this, state);
    }
}



/**
 * ComputeResult contains a named map of typed values.
 * @constructor
 * @extends {Result}
 */
var ComputeResult = function(){
    Result.call(this);
    this._outputNames = [];
    /** @type {Object.<string,DataEntry>} */
    this._dataEntries = {};
};
Base.createClass(ComputeResult, Result);

Object.defineProperty(ComputeResult.prototype, "outputNames", {
    set: function(v){
        throw new Error("outputNames is readonly");
    },
    get: function(){ return this._outputNames; }
});

ComputeResult.prototype.getOutputData = function(name){
    return this._dataEntries[name];
};

/**
 * @returns {Object.<string,DataEntry>}
 */
ComputeResult.prototype.getOutputMap = function() {
    return this._dataEntries;
};



/**
 * VSDataResult is used to analyse the output of a VertexShader
 * Note that the VSDataResult is not used to generate the VertexShader directly.
 * For that, the VertexShader structure must be created from VertexShaderRequest
 * @constructor
 * @extends {Result}
 */
var VSDataResult = function(){
    Result.call(this);
    this._program = null;
    this._programData = null;
};
Base.createClass(VSDataResult, Result);

Object.defineProperty(VSDataResult.prototype, "outputNames", {
    set: function(v){
        throw new Error("shaderOutputNames is readonly");
    },
    get: function(){ return this._program.getOutputNames(); }
});

VSDataResult.prototype.isOutputUniform = function(name){
    return this._program.isOutputUniform(name);
}
VSDataResult.prototype.isOutputNull = function(name){
    return this._program.isOutputNull(name);
}
VSDataResult.prototype.getOutputType = function(name){
    return this._program.getOutputType(name);
}
VSDataResult.prototype.getVertexShader = function(vsConfig){
    return this._program.createVertexShader(this._programData, vsConfig);
}

module.exports = {
    ComputeResult:  ComputeResult,
    VSDataResult: VSDataResult
};

},{"../../utils/array.js":178,"../base.js":186}],237:[function(require,module,exports){
var Base = require("../base.js");
var C = require("./../interface/constants.js");

var initAnonymousOperator = require("../operator/operator.js").initAnonymousOperator;

var shaderConstant = {};
shaderConstant[C.SHADER_CONSTANT_KEY.OBJECT_ID] = "objectID";
shaderConstant[C.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM] = "screenTransform";
shaderConstant[C.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM_NORMAL] = "screenTransformNormal";
shaderConstant[C.SHADER_CONSTANT_KEY.VIEW_TRANSFORM] = "viewTransform";
shaderConstant[C.SHADER_CONSTANT_KEY.VIEW_TRANSFORM_NORMAL] = "viewTransformNormal";
shaderConstant[C.SHADER_CONSTANT_KEY.WORLD_TRANSFORM] = "worldTransform";
shaderConstant[C.SHADER_CONSTANT_KEY.WORLD_TRANSFORM_NORMAL] = "worldTransformNormal";

var setShaderConstant = function(type, name){
    shaderConstant[type] = name;
};


/**
 * The output configuration of a VertexShader generated by Xflow
 * @constructor
 */
var VSConfig = function(){
    this._attributes = {};
    this._blockedNames = [];
    this._addInput = {};
    this._addOutput = {};
    this._codeFragments = [];
    this._outputChanneling = {};
};

VSConfig.prototype.addAttribute = function(type, name, optional){
    if(this._attributes[name]){
        if(this._attributes[name].type != type)
            throw new Error("Tries to add two attributes with different types of name '" + name + '"');
        this._attributes[name].optional = this._attributes[name].optional && optional;
        return;
    }
    this._attributes[name] = {type: type, optional: optional, channeling: []};
};

VSConfig.prototype.channelAttribute = function(inputName, outputName, code){
    this._attributes[inputName].channeling.push( { outputName : outputName, code : code });
};

VSConfig.prototype.addInputParameter = function(type, name, uniform){
    if(this._addInput[name])
        return;
    this._addInput[name] = { type: type, uniform: uniform };
    this._blockedNames.push(name);
};
VSConfig.prototype.addOutputParameter = function(type, name){
    if(this._addOutput[name])
        return;
    this._addOutput[name] = { type: type };
    this._blockedNames.push(name);
};
VSConfig.prototype.addCodeFragment = function(codeFragment){
    this._codeFragments.push(codeFragment);
};

VSConfig.prototype.addBlockedName = function(name){
    this._blockedNames.push(name);
};

VSConfig.prototype.getBlockedNames = function(){
    return this._blockedNames;
};

VSConfig.prototype.getFilter = function(){
    return Object.keys(this._attributes);
};
VSConfig.prototype.getKey = function(){
    var key = "";
    for(var name in this._attributes){
        var attr = this._attributes[name];
        key += ";" + attr.type + "," + name + "," + attr.optional;
    }
    return key;
};

var c_vs_operator_cache = {};

VSConfig.prototype.getOperator = function(){
    var key = this.getKey();
    if(c_vs_operator_cache[key])
        return c_vs_operator_cache[key];

    var outputs = [], params = [], glslCode = "\t// VS Connector\n";
    var name = "VSConnect";
    for(var attributeName in this._attributes){
        var attr = this._attributes[attributeName];
        var type = C.getTypeName(attr.type);
        outputs.push( { type: type, name: attributeName} );
        params.push( { type: type, source: attributeName, optional: attr.optional} );
        name += "T" + type + "N" + attributeName + "O" + attr.optional + ".";
    }
    var operator = initAnonymousOperator(name,
    {
        outputs: outputs,
        params:  params,
        evaluate_glsl: glslCode
    });
    c_vs_operator_cache[key] = operator;
    return operator;
};

var VertexShader = function(programData){
    this._programData = programData;
    this._glslCode = null;
    this._inputNames = [];
    this._outputNames = [];
    this._inputInfo = {};
    this._outputInfo = {};
};

Object.defineProperty(VertexShader.prototype, "inputNames", {
    set: function(v){
        throw new Error("inputNames is readonly");
    },
    get: function(){ return this._inputNames; }
});

Object.defineProperty(VertexShader.prototype, "outputNames", {
    set: function(v){
        throw new Error("outputNames is readonly");
    },
    get: function(){ return this._outputNames; }
});

VertexShader.prototype.isInputUniform = function(name){
    return this._inputInfo[name].uniform;
};
VertexShader.prototype.getInputData = function(name){
    return this._programData.getDataEntry(this._inputInfo[name].index);
};

VertexShader.prototype.isOutputNull = function(name){
    return this._outputInfo[name].iteration == C.ITERATION_TYPE.NULL;
};
VertexShader.prototype.isOutputFragmentUniform = function(name){
    return this._outputInfo[name].iteration == C.ITERATION_TYPE.ONE;
};
VertexShader.prototype.getUniformOutputData = function(name){
    return this._programData.getDataEntry(this._outputInfo[name].index);
};
VertexShader.prototype.getOutputType = function(name){
    return this._outputInfo[name].type;
};
VertexShader.prototype.getOutputSourceName = function(name){
    return this._outputInfo[name].sourceName;
};
VertexShader.prototype.getGLSLCode = function(){
    return this._glslCode;
};

module.exports = {
    shaderConstant: shaderConstant,
    setShaderConstant: setShaderConstant,
    VSConfig: VSConfig,
    VertexShader: VertexShader
};

},{"../base.js":186,"../operator/operator.js":227,"./../interface/constants.js":187}],238:[function(require,module,exports){
var set = {};


set.add = function(setArray, setToAdd){
    if(Array.isArray(setToAdd)){
        for(var i = 0; i < setToAdd.length; ++i){
            if(setArray.indexOf(setToAdd[i]) == -1)
                setArray.push(setToAdd[i]);
        }
    }
    else{
        if(setArray.indexOf(setToAdd) == -1)
            setArray.push(setToAdd);
    }
}
set.remove = function(setArray, setToRemove){
    var idx;
    if(Array.isArray(setToRemove)){
        for(var i = 0; i < setToRemove.length; ++i){
            if( (idx = setArray.indexOf(setToRemove[i])) != -1)
                setArray.splice(idx,1);
        }
    }
    else{
        if( (idx = setArray.indexOf(setToRemove)) != -1)
            setArray.splice(idx,1);
    }
}

set.intersection = function(dest, setA, setB){
    var size = setA.length;
    for(var i = 0; i < size; ++i){
        if(setB.indexOf(setA[i]) != -1)
            dest.push(setA[i]);
    }
}

set.isIntersecting = function(setA, setB){
    var i = setA.length;
    while(i--){
        if(setB.indexOf(setA[i]) != -1)
            return true;
    }
    return false;
}

set.isSubset = function(smallerSet, largerSet){
    var i = smallerSet.length;
    while(i--){
        if(largerSet.indexOf(smallerSet[i]) == -1)
            return false;
    }
    return true;
}

/**
 * Nameset Utilities for Xflow
 */
var nameset = {};

nameset.add = function(nameSet, toAdd){
    if(!toAdd) return;
    if(typeof toAdd == "string"){
        if(nameSet.indexOf(toAdd) == -1)
            nameSet.push(toAdd);
    }
    else{
        for(var i = 0; i < toAdd.length; ++i){
            if(nameSet.indexOf(toAdd[i]) == -1)
                nameSet.push(toAdd[i]);
        }
    }
}

nameset.remove = function(nameSet, toRemove){
    if(!toRemove) return;
    if(typeof toRemove == "string"){
        var removeIdx = nameSet.indexOf(toRemove);
        if(removeIdx != -1)
            nameSet.splice(removeIdx, 1);
    }
    else{
        for(var i = 0; i < toRemove.length; ++i){
            var removeIdx = nameSet.indexOf(toRemove[i]);
            if(removeIdx != -1)
                nameSet.splice(removeIdx, 1);
        }
    }
}

nameset.intersection = function(nameSetA, nameSetB){
    var i = nameSetA.length;
    while(i--){
        if(nameSetB.indexOf(nameSetA[i]) == -1){
            nameSetA.splice(i,1);
        }
    }
}


var binarySearch = function(keys, key, maxIndex){
    var min = 0, max = maxIndex - 1;
    while(min <= max){
        var i = Math.floor((min + max) / 2);
        if(keys[i] == key){
            return i;
        }
        else if(keys[i] < key)
            min = i + 1;
        else
            max = i - 1;
    }
    return max;
}

module.exports = {
    set: set,
    nameset: nameset,
    binarySearch: binarySearch
}

},{}],239:[function(require,module,exports){

module.exports = require("./init.js");
},{"./init.js":68}]},{},[239])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXguanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDIuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0MmQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0My5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQ0LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3F1YXQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvdmVjMi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWMzLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzQuanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5hc3NpZ24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmFzc2lnbi9ub2RlX21vZHVsZXMvbG9kYXNoLl9iYXNlYXNzaWduL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5hc3NpZ24vbm9kZV9tb2R1bGVzL2xvZGFzaC5fYmFzZWFzc2lnbi9ub2RlX21vZHVsZXMvbG9kYXNoLl9iYXNlY29weS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guYXNzaWduL25vZGVfbW9kdWxlcy9sb2Rhc2guX2Jhc2Vhc3NpZ24vbm9kZV9tb2R1bGVzL2xvZGFzaC5rZXlzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5hc3NpZ24vbm9kZV9tb2R1bGVzL2xvZGFzaC5fYmFzZWFzc2lnbi9ub2RlX21vZHVsZXMvbG9kYXNoLmtleXMvbm9kZV9tb2R1bGVzL2xvZGFzaC5fZ2V0bmF0aXZlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5hc3NpZ24vbm9kZV9tb2R1bGVzL2xvZGFzaC5fYmFzZWFzc2lnbi9ub2RlX21vZHVsZXMvbG9kYXNoLmtleXMvbm9kZV9tb2R1bGVzL2xvZGFzaC5pc2FyZ3VtZW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guYXNzaWduL25vZGVfbW9kdWxlcy9sb2Rhc2guX2Jhc2Vhc3NpZ24vbm9kZV9tb2R1bGVzL2xvZGFzaC5rZXlzL25vZGVfbW9kdWxlcy9sb2Rhc2guaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guYXNzaWduL25vZGVfbW9kdWxlcy9sb2Rhc2guX2NyZWF0ZWFzc2lnbmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5hc3NpZ24vbm9kZV9tb2R1bGVzL2xvZGFzaC5fY3JlYXRlYXNzaWduZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC5fYmluZGNhbGxiYWNrL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5hc3NpZ24vbm9kZV9tb2R1bGVzL2xvZGFzaC5fY3JlYXRlYXNzaWduZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC5faXNpdGVyYXRlZWNhbGwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmFzc2lnbi9ub2RlX21vZHVsZXMvbG9kYXNoLl9jcmVhdGVhc3NpZ25lci9ub2RlX21vZHVsZXMvbG9kYXNoLnJlc3RwYXJhbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guY3JlYXRlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5jcmVhdGUvbm9kZV9tb2R1bGVzL2xvZGFzaC5fYmFzZWNyZWF0ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guZGVmYXVsdHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGV4dHVyZS1tYW5hZ2VyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RleHR1cmUtbWFuYWdlci9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGV4dHVyZS1tYW5hZ2VyL25vZGVfbW9kdWxlcy9wZXJmb3JtYW5jZS1ub3cvbGliL3BlcmZvcm1hbmNlLW5vdy5qcyIsIm5vZGVfbW9kdWxlcy93aGF0d2ctZmV0Y2gvZmV0Y2guanMiLCJzcmMvYXNzZXQvYXNzZXQuanMiLCJzcmMvYmFzZS9hZGFwdGVyLmpzIiwic3JjL2Jhc2UvYWRhcHRlcmhhbmRsZS5qcyIsInNyYy9jb250cmliL2dsdS5qcyIsInNyYy9jb250cmliL3N0YWNrdHJhY2UtMC40LmpzIiwic3JjL2NvbnRyaWIvc3RhdGUtbWFjaGluZS5qcyIsInNyYy9kYXRhL2FkYXB0ZXIvYXNzZXQuanMiLCJzcmMvZGF0YS9hZGFwdGVyL2Jhc2UuanMiLCJzcmMvZGF0YS9hZGFwdGVyL2NvbXB1dGUuanMiLCJzcmMvZGF0YS9hZGFwdGVyL2RhdGEuanMiLCJzcmMvZGF0YS9hZGFwdGVyL2RhdGFmbG93LmpzIiwic3JjL2RhdGEvYWRhcHRlci9mYWN0b3J5LmpzIiwic3JjL2RhdGEvYWRhcHRlci9qYXZhc2NyaXB0L2ZhY3RvcnkuanMiLCJzcmMvZGF0YS9hZGFwdGVyL2pzb24vZmFjdG9yeS5qcyIsInNyYy9kYXRhL2FkYXB0ZXIvbWlzYy5qcyIsInNyYy9kYXRhL2FkYXB0ZXIvc2NyaXB0LmpzIiwic3JjL2RhdGEvYWRhcHRlci90ZXh0dXJlLmpzIiwic3JjL2RhdGEvYWRhcHRlci90cmFuc2Zvcm0uanMiLCJzcmMvZGF0YS9hZGFwdGVyL3ZhbHVlcy5qcyIsInNyYy9kYXRhL3RyYW5zZm9ybS1mZXRjaGVyLmpzIiwic3JjL2dsb2JhbC5qcyIsInNyYy9pbml0LmpzIiwic3JjL2ludGVyZmFjZS9hdHRyaWJ1dGVzLmpzIiwic3JjL2ludGVyZmFjZS9jb25maWd1cmF0aW9uLmpzIiwic3JjL2ludGVyZmFjZS9kb20uanMiLCJzcmMvaW50ZXJmYWNlL2VsZW1lbnRzLmpzIiwic3JjL2ludGVyZmFjZS9tZXRob2RzLmpzIiwic3JjL2ludGVyZmFjZS9ub3RpZmljYXRpb24uanMiLCJzcmMvaW50ZXJmYWNlL3Byb3BlcnRpZXMuanMiLCJzcmMvbWF0aC9tYXRoLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL2FkYXB0ZXIvYmFzZS5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9hZGFwdGVyL2RlZnMuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvYWRhcHRlci9mYWN0b3J5LmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL2FkYXB0ZXIvZ3JvdXAuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvYWRhcHRlci9saWdodC5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9hZGFwdGVyL2xpZ2h0c2hhZGVyLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL2FkYXB0ZXIvbWF0ZXJpYWwuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvYWRhcHRlci9tZXNoLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL2FkYXB0ZXIvbW9kZWwuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvYWRhcHRlci9zY2VuZS1lbGVtZW50LmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL2FkYXB0ZXIvdmlldy5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9hZGFwdGVyL3htbDNkLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL2NhbWVyYXMvY2FtZXJhLW1vZGVscy5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9jYW52YXMtaGFuZGxlci5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9jb25maWd1cmUuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvZXZlbnRzL21vdXNlLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL2V2ZW50cy90b3VjaC5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9saWdodHMvbGlnaHQtbWFuYWdlci5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9saWdodHMvbGlnaHQtbW9kZWxzLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL3JlbmRlcmVyLWZhY3RvcnkuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvc2NlbmUvY29uZmlndXJhdGlvbi5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9zY2VuZS9jb25zdGFudHMuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvc2NlbmUvZHJhd2FibGVjbG9zdXJlLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL3NjZW5lL3BhZ2VyLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL3NjZW5lL3JlbmRlcmdyb3VwLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL3NjZW5lL3JlbmRlcmxpZ2h0LmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL3NjZW5lL3JlbmRlcm5vZGUuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvc2NlbmUvcmVuZGVyb2JqZWN0LmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL3NjZW5lL3JlbmRlcnZpZXcuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvc2NlbmUvc2NlbmUtZGF0YS5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9zY2VuZS9zY2VuZS5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci90b29scy9kYXRhY2hhbmdlbGlzdGVuZXIuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvdG9vbHMvZnJ1c3R1bS5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci90b29scy9vYmplY3Rzb3J0ZXIuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvdXRpbHMuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvYmFzZS9jb250ZXh0LmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL2Jhc2UvZnVsbHNjcmVlbnF1YWQuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvYmFzZS9tZXNoLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL2Jhc2UvcHJvZ3JhbS5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9iYXNlL3JlbmRlcnRhcmdldC5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9iYXNlL3RleHR1cmUuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvYmFzZS91dGlscy5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9jYW52YXMtaGFuZGxlci5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9jb25zdGFudHMuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvbWF0ZXJpYWxzL2Fic3RyYWN0c2hhZGVyY2xvc3VyZS5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9tYXRlcmlhbHMvYWJzdHJhY3RzaGFkZXJjb21wb3Nlci5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9tYXRlcmlhbHMvZXZlbnRzLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL21hdGVyaWFscy9qcy9qc3NoYWRlcmNsb3N1cmUuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvbWF0ZXJpYWxzL2pzL2pzc2hhZGVyY29tcG9zZXIuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvbWF0ZXJpYWxzL2pzL2pzc3lzdGVtY29uZmlndXJhdGlvbi5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9tYXRlcmlhbHMvc2hhZGVyY29tcG9zZXJmYWN0b3J5LmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL21hdGVyaWFscy9zaGFkb3dtYXAtc2VydmljZS5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9tYXRlcmlhbHMvdXJuL2RpZmZ1c2UuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvbWF0ZXJpYWxzL3Vybi9tYXR0ZS5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9tYXRlcmlhbHMvdXJuL3Bob25nLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL21hdGVyaWFscy91cm4vcG9pbnQuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvbWF0ZXJpYWxzL3Vybi9yZWdpc3RlcnkuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvbWF0ZXJpYWxzL3Vybi9zaGFkZXItZGVzY3JpcHRvci5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9tYXRlcmlhbHMvdXJuL3VybnNoYWRlcmNsb3N1cmUuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvbWF0ZXJpYWxzL3Vybi91cm5zaGFkZXJjb21wb3Nlci5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9tYXRlcmlhbHMvdXJuL3V0aWxpdHkuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvcmVuZGVyLWludGVyZmFjZS5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9yZW5kZXItcGFzc2VzL2Jhc2UuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvcmVuZGVyLXBhc3Nlcy9ib3hibHVyLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL3JlbmRlci1wYXNzZXMvZm9yd2FyZC5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9yZW5kZXItcGFzc2VzL2xpZ2h0LXBhc3MuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvcmVuZGVyLXBhc3Nlcy9waWNrLW5vcm1hbC5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9yZW5kZXItcGFzc2VzL3BpY2stb2JqZWN0LmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL3JlbmRlci1wYXNzZXMvcGljay1wb3NpdGlvbi5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9yZW5kZXItcGFzc2VzL3BvaW50bGlnaHQtcGFzcy5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9yZW5kZXItcGFzc2VzL3NjZW5lLXBhc3MuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvcmVuZGVyLXBhc3Nlcy9zc2FvLXBhc3MuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvcmVuZGVyLXBhc3Nlcy92ZXJ0ZXhhdHRyaWJ1dGUtcGFzcy5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9yZW5kZXItdHJlZXMvYmFzZS5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9yZW5kZXItdHJlZXMvZm9yd2FyZC5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9yZW5kZXJlci5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9zY2VuZS9kcmF3YWJsZS1mYWN0b3J5LmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL3NjZW5lL2dsbGlnaHRzLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL3NjZW5lL2dsc2NlbmUuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVyL3Byb2dyYW1mYWN0b3J5LmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL3NoYWRlci9zaGFkZXItdXRpbHMuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvc3lzdGVtL3N5c3RlbS1ub3RpZmllci5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC94Zmxvdy91dGlscy5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC94Zmxvdy94Zmxvdy1tZXNoLmpzIiwic3JjL3Jlc291cmNlL2Nvb3JkaW5hdG9yLmpzIiwic3JjL3Jlc291cmNlL2NvdW50ZXIuanMiLCJzcmMvcmVzb3VyY2UvZmV0Y2hlci5qcyIsInNyYy9yZXNvdXJjZS9mb3JtYXRoYW5kbGVyLmpzIiwic3JjL3Jlc291cmNlL2luZGV4LmpzIiwic3JjL3Jlc291cmNlL3htbDNkZm9ybWF0aGFuZGxlci5qcyIsInNyYy90eXBlcy9heGlzYW5nbGUuanMiLCJzcmMvdHlwZXMvYm94LmpzIiwic3JjL3R5cGVzL2RhdGEtb2JzZXJ2ZXIuanMiLCJzcmMvdHlwZXMvbWF0Mi5qcyIsInNyYy90eXBlcy9tYXQzLmpzIiwic3JjL3R5cGVzL21hdDQuanMiLCJzcmMvdHlwZXMvcXVhdC5qcyIsInNyYy90eXBlcy9yYXkuanMiLCJzcmMvdHlwZXMvdmVjMi5qcyIsInNyYy90eXBlcy92ZWMzLmpzIiwic3JjL3R5cGVzL3ZlYzQuanMiLCJzcmMvdXRpbHMvYXJyYXkuanMiLCJzcmMvdXRpbHMvY3NzLmpzIiwic3JjL3V0aWxzL2Nzc01hdHJpeC5qcyIsInNyYy91dGlscy9kZWJ1Zy5qcyIsInNyYy91dGlscy9taXNjLmpzIiwic3JjL3V0aWxzL29wdGlvbnMuanMiLCJzcmMvdXRpbHMvdXJpLmpzIiwic3JjL3V0aWxzL3dlYmNsLmpzIiwic3JjL3hmbG93L2Jhc2UuanMiLCJzcmMveGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qcyIsInNyYy94Zmxvdy9pbnRlcmZhY2UvZGF0YS5qcyIsInNyYy94Zmxvdy9pbnRlcmZhY2UvZ3JhcGguanMiLCJzcmMveGZsb3cvaW50ZXJmYWNlL3JlcXVlc3QuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvY2wtcHJvZ3JhbS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2FkZC5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2J1ZmZlclNlbGVjdC5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2NsYW1wSW1hZ2UuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9jb252b2x1dGVJbWFnZS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2NyZWF0ZUlHSW5kZXguanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9jcmVhdGVUcmFuc2Zvcm0uanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9jcmVhdGVUcmFuc2Zvcm1JbnYuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9kZWJ1Zy5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2Rpdi5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2ZsaXBOb3JtYWwuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9mbGlwVmVydGljYWxJbWFnZS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2ZvcndhcmRLaW5lbWF0aWNzLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvZm9yd2FyZEtpbmVtYXRpY3NJbnYuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9mdW5NaXJyb3JJbWFnZS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2dldC5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2dyYXlzY2FsZUltYWdlLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvaW5kZXguanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9sZXJwM3NlcS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L21hZ25pdHVkZUltYWdlLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvbW9ycGgzLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvbXVsNHg0LmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvbm9pc2VJbWFnZS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L25vcm1hbGl6ZTMuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9wb3BhcnRJbWFnZS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L3JnYmVQTkd0b0Zsb2F0LmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvc2VsZWN0Qm9vbC5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L3NlbGVjdFRyYW5zZm9ybS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L3NlcGlhSW1hZ2UuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9za2luRGlyZWN0aW9uLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvc2tpblBvc2l0aW9uLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvc2xlcnBzZXEuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9zb2JlbEltYWdlLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvc3ViMy5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9vcGVyYXRvci1lbnRyeS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9vcGVyYXRvci1saXN0LmpzIiwic3JjL3hmbG93L29wZXJhdG9yL29wZXJhdG9yLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL3Byb2dyYW0uanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvdnMtcHJvZ3JhbS5qcyIsInNyYy94Zmxvdy9wcm9jZXNzaW5nL2NoYW5uZWwtbm9kZS5qcyIsInNyYy94Zmxvdy9wcm9jZXNzaW5nL2NoYW5uZWwuanMiLCJzcmMveGZsb3cvcHJvY2Vzc2luZy9kYXRhLXNsb3QuanMiLCJzcmMveGZsb3cvcHJvY2Vzc2luZy9leGVjdXRvci5qcyIsInNyYy94Zmxvdy9wcm9jZXNzaW5nL21hcHBpbmcuanMiLCJzcmMveGZsb3cvcHJvY2Vzc2luZy9wcm9jZXNzLW5vZGUuanMiLCJzcmMveGZsb3cvcHJvY2Vzc2luZy9yZXN1bHQuanMiLCJzcmMveGZsb3cvcHJvY2Vzc2luZy92cy1jb25uZWN0LmpzIiwic3JjL3hmbG93L3V0aWxzL3V0aWxzLmpzIiwic3JjL3htbDNkLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ253Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbnlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25NQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzViQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Z6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2wyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2huQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2wvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGdsLW1hdHJpeCAtIEhpZ2ggcGVyZm9ybWFuY2UgbWF0cml4IGFuZCB2ZWN0b3Igb3BlcmF0aW9uc1xuICogQGF1dGhvciBCcmFuZG9uIEpvbmVzXG4gKiBAYXV0aG9yIENvbGluIE1hY0tlbnppZSBJVlxuICogQHZlcnNpb24gMi4zLjFcbiAqL1xuXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuLy8gRU5EIEhFQURFUlxuXG5leHBvcnRzLmdsTWF0cml4ID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L2NvbW1vbi5qc1wiKTtcbmV4cG9ydHMubWF0MiA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC9tYXQyLmpzXCIpO1xuZXhwb3J0cy5tYXQyZCA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC9tYXQyZC5qc1wiKTtcbmV4cG9ydHMubWF0MyA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC9tYXQzLmpzXCIpO1xuZXhwb3J0cy5tYXQ0ID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L21hdDQuanNcIik7XG5leHBvcnRzLnF1YXQgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvcXVhdC5qc1wiKTtcbmV4cG9ydHMudmVjMiA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC92ZWMyLmpzXCIpO1xuZXhwb3J0cy52ZWMzID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L3ZlYzMuanNcIik7XG5leHBvcnRzLnZlYzQgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvdmVjNC5qc1wiKTsiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyBDb21tb24gdXRpbGl0aWVzXG4gKiBAbmFtZSBnbE1hdHJpeFxuICovXG52YXIgZ2xNYXRyaXggPSB7fTtcblxuLy8gQ29uc3RhbnRzXG5nbE1hdHJpeC5FUFNJTE9OID0gMC4wMDAwMDE7XG5nbE1hdHJpeC5BUlJBWV9UWVBFID0gKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKSA/IEZsb2F0MzJBcnJheSA6IEFycmF5O1xuZ2xNYXRyaXguUkFORE9NID0gTWF0aC5yYW5kb207XG5cbi8qKlxuICogU2V0cyB0aGUgdHlwZSBvZiBhcnJheSB1c2VkIHdoZW4gY3JlYXRpbmcgbmV3IHZlY3RvcnMgYW5kIG1hdHJpY2VzXG4gKlxuICogQHBhcmFtIHtUeXBlfSB0eXBlIEFycmF5IHR5cGUsIHN1Y2ggYXMgRmxvYXQzMkFycmF5IG9yIEFycmF5XG4gKi9cbmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBHTE1BVF9BUlJBWV9UWVBFID0gdHlwZTtcbn1cblxudmFyIGRlZ3JlZSA9IE1hdGguUEkgLyAxODA7XG5cbi8qKlxuKiBDb252ZXJ0IERlZ3JlZSBUbyBSYWRpYW5cbipcbiogQHBhcmFtIHtOdW1iZXJ9IEFuZ2xlIGluIERlZ3JlZXNcbiovXG5nbE1hdHJpeC50b1JhZGlhbiA9IGZ1bmN0aW9uKGEpe1xuICAgICByZXR1cm4gYSAqIGRlZ3JlZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnbE1hdHJpeDtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgMngyIE1hdHJpeFxuICogQG5hbWUgbWF0MlxuICovXG52YXIgbWF0MiA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MlxuICpcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cbm1hdDIuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xubWF0Mi5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDIgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi50cmFuc3Bvc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICB2YXIgYTEgPSBhWzFdO1xuICAgICAgICBvdXRbMV0gPSBhWzJdO1xuICAgICAgICBvdXRbMl0gPSBhMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzJdO1xuICAgICAgICBvdXRbMl0gPSBhWzFdO1xuICAgICAgICBvdXRbM10gPSBhWzNdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYTAgKiBhMyAtIGEyICogYTE7XG5cbiAgICBpZiAoIWRldCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuICAgIFxuICAgIG91dFswXSA9ICBhMyAqIGRldDtcbiAgICBvdXRbMV0gPSAtYTEgKiBkZXQ7XG4gICAgb3V0WzJdID0gLWEyICogZGV0O1xuICAgIG91dFszXSA9ICBhMCAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5hZGpvaW50ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gQ2FjaGluZyB0aGlzIHZhbHVlIGlzIG5lc3NlY2FyeSBpZiBvdXQgPT0gYVxuICAgIHZhciBhMCA9IGFbMF07XG4gICAgb3V0WzBdID0gIGFbM107XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgb3V0WzNdID0gIGEwO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDIuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBhWzBdICogYVszXSAtIGFbMl0gKiBhWzFdO1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICAgIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICAgIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICAgIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICAgIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0Mi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQyLm11bCA9IG1hdDIubXVsdGlwbHk7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDIgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuICAgICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgb3V0WzBdID0gYTAgKiAgYyArIGEyICogcztcbiAgICBvdXRbMV0gPSBhMSAqICBjICsgYTMgKiBzO1xuICAgIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gICAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDIgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICoqL1xubWF0Mi5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG4gICAgICAgIHYwID0gdlswXSwgdjEgPSB2WzFdO1xuICAgIG91dFswXSA9IGEwICogdjA7XG4gICAgb3V0WzFdID0gYTEgKiB2MDtcbiAgICBvdXRbMl0gPSBhMiAqIHYxO1xuICAgIG91dFszXSA9IGEzICogdjE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDIucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgbWF0MiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5mcm9tUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgb3V0WzBdID0gYztcbiAgICBvdXRbMV0gPSBzO1xuICAgIG91dFsyXSA9IC1zO1xuICAgIG91dFszXSA9IGM7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDIuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0Mi5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IG1hdDIgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmZyb21TY2FsaW5nID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gdlswXTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gdlsxXTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0Mi5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0MignICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDIuZnJvYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSkpXG59O1xuXG4vKipcbiAqIFJldHVybnMgTCwgRCBhbmQgVSBtYXRyaWNlcyAoTG93ZXIgdHJpYW5ndWxhciwgRGlhZ29uYWwgYW5kIFVwcGVyIHRyaWFuZ3VsYXIpIGJ5IGZhY3Rvcml6aW5nIHRoZSBpbnB1dCBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gTCB0aGUgbG93ZXIgdHJpYW5ndWxhciBtYXRyaXggXG4gKiBAcGFyYW0ge21hdDJ9IEQgdGhlIGRpYWdvbmFsIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gVSB0aGUgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXggXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGlucHV0IG1hdHJpeCB0byBmYWN0b3JpemVcbiAqL1xuXG5tYXQyLkxEVSA9IGZ1bmN0aW9uIChMLCBELCBVLCBhKSB7IFxuICAgIExbMl0gPSBhWzJdL2FbMF07IFxuICAgIFVbMF0gPSBhWzBdOyBcbiAgICBVWzFdID0gYVsxXTsgXG4gICAgVVszXSA9IGFbM10gLSBMWzJdICogVVsxXTsgXG4gICAgcmV0dXJuIFtMLCBELCBVXTsgICAgICAgXG59OyBcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdDI7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDJ4MyBNYXRyaXhcbiAqIEBuYW1lIG1hdDJkXG4gKiBcbiAqIEBkZXNjcmlwdGlvbiBcbiAqIEEgbWF0MmQgY29udGFpbnMgc2l4IGVsZW1lbnRzIGRlZmluZWQgYXM6XG4gKiA8cHJlPlxuICogW2EsIGMsIHR4LFxuICogIGIsIGQsIHR5XVxuICogPC9wcmU+XG4gKiBUaGlzIGlzIGEgc2hvcnQgZm9ybSBmb3IgdGhlIDN4MyBtYXRyaXg6XG4gKiA8cHJlPlxuICogW2EsIGMsIHR4LFxuICogIGIsIGQsIHR5LFxuICogIDAsIDAsIDFdXG4gKiA8L3ByZT5cbiAqIFRoZSBsYXN0IHJvdyBpcyBpZ25vcmVkIHNvIHRoZSBhcnJheSBpcyBzaG9ydGVyIGFuZCBvcGVyYXRpb25zIGFyZSBmYXN0ZXIuXG4gKi9cbnZhciBtYXQyZCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MmRcbiAqXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xubWF0MmQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MmQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDJkfSBhIG5ldyAyeDMgbWF0cml4XG4gKi9cbm1hdDJkLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MmQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDJkIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYWEgPSBhWzBdLCBhYiA9IGFbMV0sIGFjID0gYVsyXSwgYWQgPSBhWzNdLFxuICAgICAgICBhdHggPSBhWzRdLCBhdHkgPSBhWzVdO1xuXG4gICAgdmFyIGRldCA9IGFhICogYWQgLSBhYiAqIGFjO1xuICAgIGlmKCFkZXQpe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gYWQgKiBkZXQ7XG4gICAgb3V0WzFdID0gLWFiICogZGV0O1xuICAgIG91dFsyXSA9IC1hYyAqIGRldDtcbiAgICBvdXRbM10gPSBhYSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYWMgKiBhdHkgLSBhZCAqIGF0eCkgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGFiICogYXR4IC0gYWEgKiBhdHkpICogZGV0O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDJkLmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzFdICogYVsyXTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MmQnc1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM10sIGI0ID0gYls0XSwgYjUgPSBiWzVdO1xuICAgIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICAgIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICAgIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICAgIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICAgIG91dFs0XSA9IGEwICogYjQgKyBhMiAqIGI1ICsgYTQ7XG4gICAgb3V0WzVdID0gYTEgKiBiNCArIGEzICogYjUgKyBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDJkLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDJkLm11bCA9IG1hdDJkLm11bHRpcGx5O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQyZCBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIG91dFswXSA9IGEwICogIGMgKyBhMiAqIHM7XG4gICAgb3V0WzFdID0gYTEgKiAgYyArIGEzICogcztcbiAgICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjO1xuICAgIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gICAgb3V0WzRdID0gYTQ7XG4gICAgb3V0WzVdID0gYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKiovXG5tYXQyZC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgICBvdXRbMF0gPSBhMCAqIHYwO1xuICAgIG91dFsxXSA9IGExICogdjA7XG4gICAgb3V0WzJdID0gYTIgKiB2MTtcbiAgICBvdXRbM10gPSBhMyAqIHYxO1xuICAgIG91dFs0XSA9IGE0O1xuICAgIG91dFs1XSA9IGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gdHJhbnNsYXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKiovXG5tYXQyZC50cmFuc2xhdGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gICAgb3V0WzBdID0gYTA7XG4gICAgb3V0WzFdID0gYTE7XG4gICAgb3V0WzJdID0gYTI7XG4gICAgb3V0WzNdID0gYTM7XG4gICAgb3V0WzRdID0gYTAgKiB2MCArIGEyICogdjEgKyBhNDtcbiAgICBvdXRbNV0gPSBhMSAqIHYwICsgYTMgKiB2MSArIGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0MmQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuZnJvbVJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIG91dFswXSA9IGM7XG4gICAgb3V0WzFdID0gcztcbiAgICBvdXRbMl0gPSAtcztcbiAgICBvdXRbM10gPSBjO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0MmQuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuZnJvbVNjYWxpbmcgPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSB2WzBdO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSB2WzFdO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDJkLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDJkLnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuZnJvbVRyYW5zbGF0aW9uID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSB2WzBdO1xuICAgIG91dFs1XSA9IHZbMV07XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbm1hdDJkLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQyZCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5tYXQyZC5mcm9iID0gZnVuY3Rpb24gKGEpIHsgXG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyAxKSlcbn07IFxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdDJkO1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyAzeDMgTWF0cml4XG4gKiBAbmFtZSBtYXQzXG4gKi9cbnZhciBtYXQzID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQzXG4gKlxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcbiAqL1xubWF0My5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAxO1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29waWVzIHRoZSB1cHBlci1sZWZ0IDN4MyB2YWx1ZXMgaW50byB0aGUgZ2l2ZW4gbWF0My5cbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIDN4MyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSAgIHRoZSBzb3VyY2UgNHg0IG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmZyb21NYXQ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVs0XTtcbiAgICBvdXRbNF0gPSBhWzVdO1xuICAgIG91dFs1XSA9IGFbNl07XG4gICAgb3V0WzZdID0gYVs4XTtcbiAgICBvdXRbN10gPSBhWzldO1xuICAgIG91dFs4XSA9IGFbMTBdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0M30gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQzfSBhIG5ldyAzeDMgbWF0cml4XG4gKi9cbm1hdDMuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDMgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDE7XG4gICAgb3V0WzVdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMudHJhbnNwb3NlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICAgIGlmIChvdXQgPT09IGEpIHtcbiAgICAgICAgdmFyIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGExMiA9IGFbNV07XG4gICAgICAgIG91dFsxXSA9IGFbM107XG4gICAgICAgIG91dFsyXSA9IGFbNl07XG4gICAgICAgIG91dFszXSA9IGEwMTtcbiAgICAgICAgb3V0WzVdID0gYVs3XTtcbiAgICAgICAgb3V0WzZdID0gYTAyO1xuICAgICAgICBvdXRbN10gPSBhMTI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgb3V0WzFdID0gYVszXTtcbiAgICAgICAgb3V0WzJdID0gYVs2XTtcbiAgICAgICAgb3V0WzNdID0gYVsxXTtcbiAgICAgICAgb3V0WzRdID0gYVs0XTtcbiAgICAgICAgb3V0WzVdID0gYVs3XTtcbiAgICAgICAgb3V0WzZdID0gYVsyXTtcbiAgICAgICAgb3V0WzddID0gYVs1XTtcbiAgICAgICAgb3V0WzhdID0gYVs4XTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG5cbiAgICAgICAgYjAxID0gYTIyICogYTExIC0gYTEyICogYTIxLFxuICAgICAgICBiMTEgPSAtYTIyICogYTEwICsgYTEyICogYTIwLFxuICAgICAgICBiMjEgPSBhMjEgKiBhMTAgLSBhMTEgKiBhMjAsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjE7XG5cbiAgICBpZiAoIWRldCkgeyBcbiAgICAgICAgcmV0dXJuIG51bGw7IFxuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSBiMDEgKiBkZXQ7XG4gICAgb3V0WzFdID0gKC1hMjIgKiBhMDEgKyBhMDIgKiBhMjEpICogZGV0O1xuICAgIG91dFsyXSA9IChhMTIgKiBhMDEgLSBhMDIgKiBhMTEpICogZGV0O1xuICAgIG91dFszXSA9IGIxMSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTIyICogYTAwIC0gYTAyICogYTIwKSAqIGRldDtcbiAgICBvdXRbNV0gPSAoLWExMiAqIGEwMCArIGEwMiAqIGExMCkgKiBkZXQ7XG4gICAgb3V0WzZdID0gYjIxICogZGV0O1xuICAgIG91dFs3XSA9ICgtYTIxICogYTAwICsgYTAxICogYTIwKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTExICogYTAwIC0gYTAxICogYTEwKSAqIGRldDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuYWRqb2ludCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGEyMiAtIGExMiAqIGEyMSk7XG4gICAgb3V0WzFdID0gKGEwMiAqIGEyMSAtIGEwMSAqIGEyMik7XG4gICAgb3V0WzJdID0gKGEwMSAqIGExMiAtIGEwMiAqIGExMSk7XG4gICAgb3V0WzNdID0gKGExMiAqIGEyMCAtIGExMCAqIGEyMik7XG4gICAgb3V0WzRdID0gKGEwMCAqIGEyMiAtIGEwMiAqIGEyMCk7XG4gICAgb3V0WzVdID0gKGEwMiAqIGExMCAtIGEwMCAqIGExMik7XG4gICAgb3V0WzZdID0gKGExMCAqIGEyMSAtIGExMSAqIGEyMCk7XG4gICAgb3V0WzddID0gKGEwMSAqIGEyMCAtIGEwMCAqIGEyMSk7XG4gICAgb3V0WzhdID0gKGEwMCAqIGExMSAtIGEwMSAqIGExMCk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDMuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gICAgcmV0dXJuIGEwMCAqIChhMjIgKiBhMTEgLSBhMTIgKiBhMjEpICsgYTAxICogKC1hMjIgKiBhMTAgKyBhMTIgKiBhMjApICsgYTAyICogKGEyMSAqIGExMCAtIGExMSAqIGEyMCk7XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDMnc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgICAgICBiMDAgPSBiWzBdLCBiMDEgPSBiWzFdLCBiMDIgPSBiWzJdLFxuICAgICAgICBiMTAgPSBiWzNdLCBiMTEgPSBiWzRdLCBiMTIgPSBiWzVdLFxuICAgICAgICBiMjAgPSBiWzZdLCBiMjEgPSBiWzddLCBiMjIgPSBiWzhdO1xuXG4gICAgb3V0WzBdID0gYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwO1xuICAgIG91dFsxXSA9IGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMTtcbiAgICBvdXRbMl0gPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjI7XG5cbiAgICBvdXRbM10gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjA7XG4gICAgb3V0WzRdID0gYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxO1xuICAgIG91dFs1XSA9IGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMjtcblxuICAgIG91dFs2XSA9IGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMDtcbiAgICBvdXRbN10gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjE7XG4gICAgb3V0WzhdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQzLm11bCA9IG1hdDMubXVsdGlwbHk7XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0MyBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My50cmFuc2xhdGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcbiAgICAgICAgeCA9IHZbMF0sIHkgPSB2WzFdO1xuXG4gICAgb3V0WzBdID0gYTAwO1xuICAgIG91dFsxXSA9IGEwMTtcbiAgICBvdXRbMl0gPSBhMDI7XG5cbiAgICBvdXRbM10gPSBhMTA7XG4gICAgb3V0WzRdID0gYTExO1xuICAgIG91dFs1XSA9IGExMjtcblxuICAgIG91dFs2XSA9IHggKiBhMDAgKyB5ICogYTEwICsgYTIwO1xuICAgIG91dFs3XSA9IHggKiBhMDEgKyB5ICogYTExICsgYTIxO1xuICAgIG91dFs4XSA9IHggKiBhMDIgKyB5ICogYTEyICsgYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQzIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG5cbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYyAqIGEwMCArIHMgKiBhMTA7XG4gICAgb3V0WzFdID0gYyAqIGEwMSArIHMgKiBhMTE7XG4gICAgb3V0WzJdID0gYyAqIGEwMiArIHMgKiBhMTI7XG5cbiAgICBvdXRbM10gPSBjICogYTEwIC0gcyAqIGEwMDtcbiAgICBvdXRbNF0gPSBjICogYTExIC0gcyAqIGEwMTtcbiAgICBvdXRbNV0gPSBjICogYTEyIC0gcyAqIGEwMjtcblxuICAgIG91dFs2XSA9IGEyMDtcbiAgICBvdXRbN10gPSBhMjE7XG4gICAgb3V0WzhdID0gYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MyBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKiovXG5tYXQzLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXTtcblxuICAgIG91dFswXSA9IHggKiBhWzBdO1xuICAgIG91dFsxXSA9IHggKiBhWzFdO1xuICAgIG91dFsyXSA9IHggKiBhWzJdO1xuXG4gICAgb3V0WzNdID0geSAqIGFbM107XG4gICAgb3V0WzRdID0geSAqIGFbNF07XG4gICAgb3V0WzVdID0geSAqIGFbNV07XG5cbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDMudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmZyb21UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMTtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IHZbMF07XG4gICAgb3V0WzddID0gdlsxXTtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDMucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5mcm9tUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSwgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBjO1xuICAgIG91dFsxXSA9IHM7XG4gICAgb3V0WzJdID0gMDtcblxuICAgIG91dFszXSA9IC1zO1xuICAgIG91dFs0XSA9IGM7XG4gICAgb3V0WzVdID0gMDtcblxuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDMuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5mcm9tU2NhbGluZyA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IHZbMF07XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuXG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB2WzFdO1xuICAgIG91dFs1XSA9IDA7XG5cbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIGZyb20gYSBtYXQyZCBpbnRvIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY29weVxuICogQHJldHVybnMge21hdDN9IG91dFxuICoqL1xubWF0My5mcm9tTWF0MmQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gMDtcblxuICAgIG91dFszXSA9IGFbMl07XG4gICAgb3V0WzRdID0gYVszXTtcbiAgICBvdXRbNV0gPSAwO1xuXG4gICAgb3V0WzZdID0gYVs0XTtcbiAgICBvdXRbN10gPSBhWzVdO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuKiBDYWxjdWxhdGVzIGEgM3gzIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXG4qXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiogQHBhcmFtIHtxdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4qXG4qIEByZXR1cm5zIHttYXQzfSBvdXRcbiovXG5tYXQzLmZyb21RdWF0ID0gZnVuY3Rpb24gKG91dCwgcSkge1xuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeXggPSB5ICogeDIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB6eCA9IHogKiB4MixcbiAgICAgICAgenkgPSB6ICogeTIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gICAgb3V0WzNdID0geXggLSB3ejtcbiAgICBvdXRbNl0gPSB6eCArIHd5O1xuXG4gICAgb3V0WzFdID0geXggKyB3ejtcbiAgICBvdXRbNF0gPSAxIC0geHggLSB6ejtcbiAgICBvdXRbN10gPSB6eSAtIHd4O1xuXG4gICAgb3V0WzJdID0genggLSB3eTtcbiAgICBvdXRbNV0gPSB6eSArIHd4O1xuICAgIG91dFs4XSA9IDEgLSB4eCAtIHl5O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuKiBDYWxjdWxhdGVzIGEgM3gzIG5vcm1hbCBtYXRyaXggKHRyYW5zcG9zZSBpbnZlcnNlKSBmcm9tIHRoZSA0eDQgbWF0cml4XG4qXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiogQHBhcmFtIHttYXQ0fSBhIE1hdDQgdG8gZGVyaXZlIHRoZSBub3JtYWwgbWF0cml4IGZyb21cbipcbiogQHJldHVybnMge21hdDN9IG91dFxuKi9cbm1hdDMubm9ybWFsRnJvbU1hdDQgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICAgIGlmICghZGV0KSB7IFxuICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIG91dFsxXSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgIG91dFsyXSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuXG4gICAgb3V0WzNdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG5cbiAgICBvdXRbNl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICBvdXRbN10gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0My5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0MygnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICsgYVs4XSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDMuZnJvYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyBNYXRoLnBvdyhhWzZdLCAyKSArIE1hdGgucG93KGFbN10sIDIpICsgTWF0aC5wb3coYVs4XSwgMikpKVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdDM7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDR4NCBNYXRyaXhcbiAqIEBuYW1lIG1hdDRcbiAqL1xudmFyIG1hdDQgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDRcbiAqXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxuICovXG5tYXQ0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxuICovXG5tYXQ0LmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0NCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC50cmFuc3Bvc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICB2YXIgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgICAgIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgICAgICBvdXRbMV0gPSBhWzRdO1xuICAgICAgICBvdXRbMl0gPSBhWzhdO1xuICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgb3V0WzRdID0gYTAxO1xuICAgICAgICBvdXRbNl0gPSBhWzldO1xuICAgICAgICBvdXRbN10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzhdID0gYTAyO1xuICAgICAgICBvdXRbOV0gPSBhMTI7XG4gICAgICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzEyXSA9IGEwMztcbiAgICAgICAgb3V0WzEzXSA9IGExMztcbiAgICAgICAgb3V0WzE0XSA9IGEyMztcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzRdO1xuICAgICAgICBvdXRbMl0gPSBhWzhdO1xuICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgb3V0WzRdID0gYVsxXTtcbiAgICAgICAgb3V0WzVdID0gYVs1XTtcbiAgICAgICAgb3V0WzZdID0gYVs5XTtcbiAgICAgICAgb3V0WzddID0gYVsxM107XG4gICAgICAgIG91dFs4XSA9IGFbMl07XG4gICAgICAgIG91dFs5XSA9IGFbNl07XG4gICAgICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICAgICAgb3V0WzExXSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTJdID0gYVszXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbN107XG4gICAgICAgIG91dFsxNF0gPSBhWzExXTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gICAgaWYgKCFkZXQpIHsgXG4gICAgICAgIHJldHVybiBudWxsOyBcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzNdID0gKGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzZdID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzldID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTJdID0gKGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTVdID0gKGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgKiBkZXQ7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuYWRqb2ludCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gICAgb3V0WzBdICA9ICAoYTExICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgICBvdXRbMV0gID0gLShhMDEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICAgIG91dFsyXSAgPSAgKGEwMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTExICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzNdICA9IC0oYTAxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbNF0gID0gLShhMTAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICAgIG91dFs1XSAgPSAgKGEwMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gICAgb3V0WzZdICA9IC0oYTAwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbN10gID0gIChhMDAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs4XSAgPSAgKGExMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSk7XG4gICAgb3V0WzldICA9IC0oYTAwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpKTtcbiAgICBvdXRbMTBdID0gIChhMDAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICAgIG91dFsxMV0gPSAtKGEwMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gICAgb3V0WzEyXSA9IC0oYTEwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpKTtcbiAgICBvdXRbMTNdID0gIChhMDAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkpO1xuICAgIG91dFsxNF0gPSAtKGEwMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gICAgb3V0WzE1XSA9ICAoYTAwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0NC5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICByZXR1cm4gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0J3NcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgICAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXhcbiAgICB2YXIgYjAgID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTsgIFxuICAgIG91dFswXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzJdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFszXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls0XTsgYjEgPSBiWzVdOyBiMiA9IGJbNl07IGIzID0gYls3XTtcbiAgICBvdXRbNF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzVdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFs2XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbN10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbOF07IGIxID0gYls5XTsgYjIgPSBiWzEwXTsgYjMgPSBiWzExXTtcbiAgICBvdXRbOF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzldID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxMF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzExXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYlsxMl07IGIxID0gYlsxM107IGIyID0gYlsxNF07IGIzID0gYlsxNV07XG4gICAgb3V0WzEyXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMTNdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxNF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzE1XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0NC5tdWwgPSBtYXQ0Lm11bHRpcGx5O1xuXG4vKipcbiAqIFRyYW5zbGF0ZSBhIG1hdDQgYnkgdGhlIGdpdmVuIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjM30gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQudHJhbnNsYXRlID0gZnVuY3Rpb24gKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdLFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzO1xuXG4gICAgaWYgKGEgPT09IG91dCkge1xuICAgICAgICBvdXRbMTJdID0gYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbM10gKiB4ICsgYVs3XSAqIHkgKyBhWzExXSAqIHogKyBhWzE1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgICAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgICAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICAgICAgb3V0WzBdID0gYTAwOyBvdXRbMV0gPSBhMDE7IG91dFsyXSA9IGEwMjsgb3V0WzNdID0gYTAzO1xuICAgICAgICBvdXRbNF0gPSBhMTA7IG91dFs1XSA9IGExMTsgb3V0WzZdID0gYTEyOyBvdXRbN10gPSBhMTM7XG4gICAgICAgIG91dFs4XSA9IGEyMDsgb3V0WzldID0gYTIxOyBvdXRbMTBdID0gYTIyOyBvdXRbMTFdID0gYTIzO1xuXG4gICAgICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGEwMSAqIHggKyBhMTEgKiB5ICsgYTIxICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYTAyICogeCArIGExMiAqIHkgKyBhMjIgKiB6ICsgYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7dmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKiovXG5tYXQ0LnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl07XG5cbiAgICBvdXRbMF0gPSBhWzBdICogeDtcbiAgICBvdXRbMV0gPSBhWzFdICogeDtcbiAgICBvdXRbMl0gPSBhWzJdICogeDtcbiAgICBvdXRbM10gPSBhWzNdICogeDtcbiAgICBvdXRbNF0gPSBhWzRdICogeTtcbiAgICBvdXRbNV0gPSBhWzVdICogeTtcbiAgICBvdXRbNl0gPSBhWzZdICogeTtcbiAgICBvdXRbN10gPSBhWzddICogeTtcbiAgICBvdXRbOF0gPSBhWzhdICogejtcbiAgICBvdXRbOV0gPSBhWzldICogejtcbiAgICBvdXRbMTBdID0gYVsxMF0gKiB6O1xuICAgIG91dFsxMV0gPSBhWzExXSAqIHo7XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIGdpdmVuIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQsIGF4aXMpIHtcbiAgICB2YXIgeCA9IGF4aXNbMF0sIHkgPSBheGlzWzFdLCB6ID0gYXhpc1syXSxcbiAgICAgICAgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeiksXG4gICAgICAgIHMsIGMsIHQsXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcbiAgICAgICAgYTEwLCBhMTEsIGExMiwgYTEzLFxuICAgICAgICBhMjAsIGEyMSwgYTIyLCBhMjMsXG4gICAgICAgIGIwMCwgYjAxLCBiMDIsXG4gICAgICAgIGIxMCwgYjExLCBiMTIsXG4gICAgICAgIGIyMCwgYjIxLCBiMjI7XG5cbiAgICBpZiAoTWF0aC5hYnMobGVuKSA8IGdsTWF0cml4LkVQU0lMT04pIHsgcmV0dXJuIG51bGw7IH1cbiAgICBcbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHggKj0gbGVuO1xuICAgIHkgKj0gbGVuO1xuICAgIHogKj0gbGVuO1xuXG4gICAgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgdCA9IDEgLSBjO1xuXG4gICAgYTAwID0gYVswXTsgYTAxID0gYVsxXTsgYTAyID0gYVsyXTsgYTAzID0gYVszXTtcbiAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAgIC8vIENvbnN0cnVjdCB0aGUgZWxlbWVudHMgb2YgdGhlIHJvdGF0aW9uIG1hdHJpeFxuICAgIGIwMCA9IHggKiB4ICogdCArIGM7IGIwMSA9IHkgKiB4ICogdCArIHogKiBzOyBiMDIgPSB6ICogeCAqIHQgLSB5ICogcztcbiAgICBiMTAgPSB4ICogeSAqIHQgLSB6ICogczsgYjExID0geSAqIHkgKiB0ICsgYzsgYjEyID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gICAgYjIwID0geCAqIHogKiB0ICsgeSAqIHM7IGIyMSA9IHkgKiB6ICogdCAtIHggKiBzOyBiMjIgPSB6ICogeiAqIHQgKyBjO1xuXG4gICAgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDI7XG4gICAgb3V0WzFdID0gYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyO1xuICAgIG91dFsyXSA9IGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMjtcbiAgICBvdXRbM10gPSBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDI7XG4gICAgb3V0WzRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyO1xuICAgIG91dFs1XSA9IGEwMSAqIGIxMCArIGExMSAqIGIxMSArIGEyMSAqIGIxMjtcbiAgICBvdXRbNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTI7XG4gICAgb3V0WzddID0gYTAzICogYjEwICsgYTEzICogYjExICsgYTIzICogYjEyO1xuICAgIG91dFs4XSA9IGEwMCAqIGIyMCArIGExMCAqIGIyMSArIGEyMCAqIGIyMjtcbiAgICBvdXRbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XG4gICAgb3V0WzEwXSA9IGEwMiAqIGIyMCArIGExMiAqIGIyMSArIGEyMiAqIGIyMjtcbiAgICBvdXRbMTFdID0gYTAzICogYjIwICsgYTEzICogYjIxICsgYTIzICogYjIyO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGVYID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSxcbiAgICAgICAgYTIxID0gYVs5XSxcbiAgICAgICAgYTIyID0gYVsxMF0sXG4gICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgICAgIG91dFswXSAgPSBhWzBdO1xuICAgICAgICBvdXRbMV0gID0gYVsxXTtcbiAgICAgICAgb3V0WzJdICA9IGFbMl07XG4gICAgICAgIG91dFszXSAgPSBhWzNdO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFs0XSA9IGExMCAqIGMgKyBhMjAgKiBzO1xuICAgIG91dFs1XSA9IGExMSAqIGMgKyBhMjEgKiBzO1xuICAgIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xuICAgIG91dFs3XSA9IGExMyAqIGMgKyBhMjMgKiBzO1xuICAgIG91dFs4XSA9IGEyMCAqIGMgLSBhMTAgKiBzO1xuICAgIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xuICAgIG91dFsxMF0gPSBhMjIgKiBjIC0gYTEyICogcztcbiAgICBvdXRbMTFdID0gYTIzICogYyAtIGExMyAqIHM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZVkgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMDAgPSBhWzBdLFxuICAgICAgICBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdLFxuICAgICAgICBhMjAgPSBhWzhdLFxuICAgICAgICBhMjEgPSBhWzldLFxuICAgICAgICBhMjIgPSBhWzEwXSxcbiAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgICAgb3V0WzRdICA9IGFbNF07XG4gICAgICAgIG91dFs1XSAgPSBhWzVdO1xuICAgICAgICBvdXRbNl0gID0gYVs2XTtcbiAgICAgICAgb3V0WzddICA9IGFbN107XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYyAtIGEyMCAqIHM7XG4gICAgb3V0WzFdID0gYTAxICogYyAtIGEyMSAqIHM7XG4gICAgb3V0WzJdID0gYTAyICogYyAtIGEyMiAqIHM7XG4gICAgb3V0WzNdID0gYTAzICogYyAtIGEyMyAqIHM7XG4gICAgb3V0WzhdID0gYTAwICogcyArIGEyMCAqIGM7XG4gICAgb3V0WzldID0gYTAxICogcyArIGEyMSAqIGM7XG4gICAgb3V0WzEwXSA9IGEwMiAqIHMgKyBhMjIgKiBjO1xuICAgIG91dFsxMV0gPSBhMDMgKiBzICsgYTIzICogYztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucm90YXRlWiA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sXG4gICAgICAgIGExMSA9IGFbNV0sXG4gICAgICAgIGExMiA9IGFbNl0sXG4gICAgICAgIGExMyA9IGFbN107XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgICAgIG91dFs4XSAgPSBhWzhdO1xuICAgICAgICBvdXRbOV0gID0gYVs5XTtcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgICAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYyArIGExMCAqIHM7XG4gICAgb3V0WzFdID0gYTAxICogYyArIGExMSAqIHM7XG4gICAgb3V0WzJdID0gYTAyICogYyArIGExMiAqIHM7XG4gICAgb3V0WzNdID0gYTAzICogYyArIGExMyAqIHM7XG4gICAgb3V0WzRdID0gYTEwICogYyAtIGEwMCAqIHM7XG4gICAgb3V0WzVdID0gYTExICogYyAtIGEwMSAqIHM7XG4gICAgb3V0WzZdID0gYTEyICogYyAtIGEwMiAqIHM7XG4gICAgb3V0WzddID0gYTEzICogYyAtIGEwMyAqIHM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tVHJhbnNsYXRpb24gPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSB2WzBdO1xuICAgIG91dFsxM10gPSB2WzFdO1xuICAgIG91dFsxNF0gPSB2WzJdO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzN9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tU2NhbGluZyA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IHZbMF07XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSB2WzFdO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IHZbMl07XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZSBhcm91bmQgYSBnaXZlbiBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZShkZXN0LCBkZXN0LCByYWQsIGF4aXMpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21Sb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkLCBheGlzKSB7XG4gICAgdmFyIHggPSBheGlzWzBdLCB5ID0gYXhpc1sxXSwgeiA9IGF4aXNbMl0sXG4gICAgICAgIGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopLFxuICAgICAgICBzLCBjLCB0O1xuICAgIFxuICAgIGlmIChNYXRoLmFicyhsZW4pIDwgZ2xNYXRyaXguRVBTSUxPTikgeyByZXR1cm4gbnVsbDsgfVxuICAgIFxuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeCAqPSBsZW47XG4gICAgeSAqPSBsZW47XG4gICAgeiAqPSBsZW47XG4gICAgXG4gICAgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgdCA9IDEgLSBjO1xuICAgIFxuICAgIC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0geCAqIHggKiB0ICsgYztcbiAgICBvdXRbMV0gPSB5ICogeCAqIHQgKyB6ICogcztcbiAgICBvdXRbMl0gPSB6ICogeCAqIHQgLSB5ICogcztcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHggKiB5ICogdCAtIHogKiBzO1xuICAgIG91dFs1XSA9IHkgKiB5ICogdCArIGM7XG4gICAgb3V0WzZdID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4ICogeiAqIHQgKyB5ICogcztcbiAgICBvdXRbOV0gPSB5ICogeiAqIHQgLSB4ICogcztcbiAgICBvdXRbMTBdID0geiAqIHogKiB0ICsgYztcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlWChkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVhSb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBcbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdICA9IDE7XG4gICAgb3V0WzFdICA9IDA7XG4gICAgb3V0WzJdICA9IDA7XG4gICAgb3V0WzNdICA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSBjO1xuICAgIG91dFs2XSA9IHM7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IC1zO1xuICAgIG91dFsxMF0gPSBjO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGVZKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tWVJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIFxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gID0gYztcbiAgICBvdXRbMV0gID0gMDtcbiAgICBvdXRbMl0gID0gLXM7XG4gICAgb3V0WzNdICA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSBzO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IGM7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVooZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21aUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSAgPSBjO1xuICAgIG91dFsxXSAgPSBzO1xuICAgIG91dFsyXSAgPSAwO1xuICAgIG91dFszXSAgPSAwO1xuICAgIG91dFs0XSA9IC1zO1xuICAgIG91dFs1XSA9IGM7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24gYW5kIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAqICAgICB2YXIgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24gPSBmdW5jdGlvbiAob3V0LCBxLCB2KSB7XG4gICAgLy8gUXVhdGVybmlvbiBtYXRoXG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB4eSA9IHggKiB5MixcbiAgICAgICAgeHogPSB4ICogejIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB5eiA9IHkgKiB6MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0gKHl5ICsgenopO1xuICAgIG91dFsxXSA9IHh5ICsgd3o7XG4gICAgb3V0WzJdID0geHogLSB3eTtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHh5IC0gd3o7XG4gICAgb3V0WzVdID0gMSAtICh4eCArIHp6KTtcbiAgICBvdXRbNl0gPSB5eiArIHd4O1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0geHogKyB3eTtcbiAgICBvdXRbOV0gPSB5eiAtIHd4O1xuICAgIG91dFsxMF0gPSAxIC0gKHh4ICsgeXkpO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSB2WzBdO1xuICAgIG91dFsxM10gPSB2WzFdO1xuICAgIG91dFsxNF0gPSB2WzJdO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24sIHZlY3RvciB0cmFuc2xhdGlvbiBhbmQgdmVjdG9yIHNjYWxlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIHZhciBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBzIFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZSA9IGZ1bmN0aW9uIChvdXQsIHEsIHYsIHMpIHtcbiAgICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHh5ID0geCAqIHkyLFxuICAgICAgICB4eiA9IHggKiB6MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHl6ID0geSAqIHoyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MixcbiAgICAgICAgc3ggPSBzWzBdLFxuICAgICAgICBzeSA9IHNbMV0sXG4gICAgICAgIHN6ID0gc1syXTtcblxuICAgIG91dFswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICAgIG91dFsxXSA9ICh4eSArIHd6KSAqIHN4O1xuICAgIG91dFsyXSA9ICh4eiAtIHd5KSAqIHN4O1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gKHh5IC0gd3opICogc3k7XG4gICAgb3V0WzVdID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gICAgb3V0WzZdID0gKHl6ICsgd3gpICogc3k7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAoeHogKyB3eSkgKiBzejtcbiAgICBvdXRbOV0gPSAoeXogLSB3eCkgKiBzejtcbiAgICBvdXRbMTBdID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IHZbMF07XG4gICAgb3V0WzEzXSA9IHZbMV07XG4gICAgb3V0WzE0XSA9IHZbMl07XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGUsIHJvdGF0aW5nIGFuZCBzY2FsaW5nIGFyb3VuZCB0aGUgZ2l2ZW4gb3JpZ2luXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIG9yaWdpbik7XG4gKiAgICAgdmFyIHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgbmVnYXRpdmVPcmlnaW4pO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBzIFNjYWxpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IG8gVGhlIG9yaWdpbiB2ZWN0b3IgYXJvdW5kIHdoaWNoIHRvIHNjYWxlIGFuZCByb3RhdGVcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlT3JpZ2luID0gZnVuY3Rpb24gKG91dCwgcSwgdiwgcywgbykge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgeDIgPSB4ICsgeCxcbiAgICAgIHkyID0geSArIHksXG4gICAgICB6MiA9IHogKyB6LFxuXG4gICAgICB4eCA9IHggKiB4MixcbiAgICAgIHh5ID0geCAqIHkyLFxuICAgICAgeHogPSB4ICogejIsXG4gICAgICB5eSA9IHkgKiB5MixcbiAgICAgIHl6ID0geSAqIHoyLFxuICAgICAgenogPSB6ICogejIsXG4gICAgICB3eCA9IHcgKiB4MixcbiAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgd3ogPSB3ICogejIsXG4gICAgICBcbiAgICAgIHN4ID0gc1swXSxcbiAgICAgIHN5ID0gc1sxXSxcbiAgICAgIHN6ID0gc1syXSxcblxuICAgICAgb3ggPSBvWzBdLFxuICAgICAgb3kgPSBvWzFdLFxuICAgICAgb3ogPSBvWzJdO1xuICAgICAgXG4gIG91dFswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICBvdXRbMV0gPSAoeHkgKyB3eikgKiBzeDtcbiAgb3V0WzJdID0gKHh6IC0gd3kpICogc3g7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9ICh4eSAtIHd6KSAqIHN5O1xuICBvdXRbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgb3V0WzZdID0gKHl6ICsgd3gpICogc3k7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9ICh4eiArIHd5KSAqIHN6O1xuICBvdXRbOV0gPSAoeXogLSB3eCkgKiBzejtcbiAgb3V0WzEwXSA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF0gKyBveCAtIChvdXRbMF0gKiBveCArIG91dFs0XSAqIG95ICsgb3V0WzhdICogb3opO1xuICBvdXRbMTNdID0gdlsxXSArIG95IC0gKG91dFsxXSAqIG94ICsgb3V0WzVdICogb3kgKyBvdXRbOV0gKiBveik7XG4gIG91dFsxNF0gPSB2WzJdICsgb3ogLSAob3V0WzJdICogb3ggKyBvdXRbNl0gKiBveSArIG91dFsxMF0gKiBveik7XG4gIG91dFsxNV0gPSAxO1xuICAgICAgICBcbiAgcmV0dXJuIG91dDtcbn07XG5cbm1hdDQuZnJvbVF1YXQgPSBmdW5jdGlvbiAob3V0LCBxKSB7XG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB5eCA9IHkgKiB4MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHp4ID0geiAqIHgyLFxuICAgICAgICB6eSA9IHogKiB5MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgICBvdXRbMV0gPSB5eCArIHd6O1xuICAgIG91dFsyXSA9IHp4IC0gd3k7XG4gICAgb3V0WzNdID0gMDtcblxuICAgIG91dFs0XSA9IHl4IC0gd3o7XG4gICAgb3V0WzVdID0gMSAtIHh4IC0geno7XG4gICAgb3V0WzZdID0genkgKyB3eDtcbiAgICBvdXRbN10gPSAwO1xuXG4gICAgb3V0WzhdID0genggKyB3eTtcbiAgICBvdXRbOV0gPSB6eSAtIHd4O1xuICAgIG91dFsxMF0gPSAxIC0geHggLSB5eTtcbiAgICBvdXRbMTFdID0gMDtcblxuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgZnJ1c3R1bSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJ1c3R1bSA9IGZ1bmN0aW9uIChvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIHJsID0gMSAvIChyaWdodCAtIGxlZnQpLFxuICAgICAgICB0YiA9IDEgLyAodG9wIC0gYm90dG9tKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IChuZWFyICogMikgKiBybDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IChuZWFyICogMikgKiB0YjtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gKHJpZ2h0ICsgbGVmdCkgKiBybDtcbiAgICBvdXRbOV0gPSAodG9wICsgYm90dG9tKSAqIHRiO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTFdID0gLTE7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IChmYXIgKiBuZWFyICogMikgKiBuZjtcbiAgICBvdXRbMTVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhc3BlY3QgQXNwZWN0IHJhdGlvLiB0eXBpY2FsbHkgdmlld3BvcnQgd2lkdGgvaGVpZ2h0XG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnBlcnNwZWN0aXZlID0gZnVuY3Rpb24gKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgZiA9IDEuMCAvIE1hdGgudGFuKGZvdnkgLyAyKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IGYgLyBhc3BlY3Q7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSBmO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxMV0gPSAtMTtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gKDIgKiBmYXIgKiBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGZpZWxkIG9mIHZpZXcuXG4gKiBUaGlzIGlzIHByaW1hcmlseSB1c2VmdWwgZm9yIGdlbmVyYXRpbmcgcHJvamVjdGlvbiBtYXRyaWNlcyB0byBiZSB1c2VkXG4gKiB3aXRoIHRoZSBzdGlsbCBleHBlcmllbWVudGFsIFdlYlZSIEFQSS5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gZm92IE9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiB1cERlZ3JlZXMsIGRvd25EZWdyZWVzLCBsZWZ0RGVncmVlcywgcmlnaHREZWdyZWVzXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3ID0gZnVuY3Rpb24gKG91dCwgZm92LCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgdXBUYW4gPSBNYXRoLnRhbihmb3YudXBEZWdyZWVzICogTWF0aC5QSS8xODAuMCksXG4gICAgICAgIGRvd25UYW4gPSBNYXRoLnRhbihmb3YuZG93bkRlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgbGVmdFRhbiA9IE1hdGgudGFuKGZvdi5sZWZ0RGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICByaWdodFRhbiA9IE1hdGgudGFuKGZvdi5yaWdodERlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgeFNjYWxlID0gMi4wIC8gKGxlZnRUYW4gKyByaWdodFRhbiksXG4gICAgICAgIHlTY2FsZSA9IDIuMCAvICh1cFRhbiArIGRvd25UYW4pO1xuXG4gICAgb3V0WzBdID0geFNjYWxlO1xuICAgIG91dFsxXSA9IDAuMDtcbiAgICBvdXRbMl0gPSAwLjA7XG4gICAgb3V0WzNdID0gMC4wO1xuICAgIG91dFs0XSA9IDAuMDtcbiAgICBvdXRbNV0gPSB5U2NhbGU7XG4gICAgb3V0WzZdID0gMC4wO1xuICAgIG91dFs3XSA9IDAuMDtcbiAgICBvdXRbOF0gPSAtKChsZWZ0VGFuIC0gcmlnaHRUYW4pICogeFNjYWxlICogMC41KTtcbiAgICBvdXRbOV0gPSAoKHVwVGFuIC0gZG93blRhbikgKiB5U2NhbGUgKiAwLjUpO1xuICAgIG91dFsxMF0gPSBmYXIgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzExXSA9IC0xLjA7XG4gICAgb3V0WzEyXSA9IDAuMDtcbiAgICBvdXRbMTNdID0gMC4wO1xuICAgIG91dFsxNF0gPSAoZmFyICogbmVhcikgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzE1XSA9IDAuMDtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQub3J0aG8gPSBmdW5jdGlvbiAob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICAgIHZhciBsciA9IDEgLyAobGVmdCAtIHJpZ2h0KSxcbiAgICAgICAgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSAtMiAqIGxyO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gLTIgKiBidDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAyICogbmY7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IChsZWZ0ICsgcmlnaHQpICogbHI7XG4gICAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gICAgb3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGxvb2stYXQgbWF0cml4IHdpdGggdGhlIGdpdmVuIGV5ZSBwb3NpdGlvbiwgZm9jYWwgcG9pbnQsIGFuZCB1cCBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHt2ZWMzfSBleWUgUG9zaXRpb24gb2YgdGhlIHZpZXdlclxuICogQHBhcmFtIHt2ZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XG4gKiBAcGFyYW0ge3ZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5sb29rQXQgPSBmdW5jdGlvbiAob3V0LCBleWUsIGNlbnRlciwgdXApIHtcbiAgICB2YXIgeDAsIHgxLCB4MiwgeTAsIHkxLCB5MiwgejAsIHoxLCB6MiwgbGVuLFxuICAgICAgICBleWV4ID0gZXllWzBdLFxuICAgICAgICBleWV5ID0gZXllWzFdLFxuICAgICAgICBleWV6ID0gZXllWzJdLFxuICAgICAgICB1cHggPSB1cFswXSxcbiAgICAgICAgdXB5ID0gdXBbMV0sXG4gICAgICAgIHVweiA9IHVwWzJdLFxuICAgICAgICBjZW50ZXJ4ID0gY2VudGVyWzBdLFxuICAgICAgICBjZW50ZXJ5ID0gY2VudGVyWzFdLFxuICAgICAgICBjZW50ZXJ6ID0gY2VudGVyWzJdO1xuXG4gICAgaWYgKE1hdGguYWJzKGV5ZXggLSBjZW50ZXJ4KSA8IGdsTWF0cml4LkVQU0lMT04gJiZcbiAgICAgICAgTWF0aC5hYnMoZXlleSAtIGNlbnRlcnkpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJlxuICAgICAgICBNYXRoLmFicyhleWV6IC0gY2VudGVyeikgPCBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgICAgIHJldHVybiBtYXQ0LmlkZW50aXR5KG91dCk7XG4gICAgfVxuXG4gICAgejAgPSBleWV4IC0gY2VudGVyeDtcbiAgICB6MSA9IGV5ZXkgLSBjZW50ZXJ5O1xuICAgIHoyID0gZXlleiAtIGNlbnRlcno7XG5cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KHowICogejAgKyB6MSAqIHoxICsgejIgKiB6Mik7XG4gICAgejAgKj0gbGVuO1xuICAgIHoxICo9IGxlbjtcbiAgICB6MiAqPSBsZW47XG5cbiAgICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejE7XG4gICAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyO1xuICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgICBsZW4gPSBNYXRoLnNxcnQoeDAgKiB4MCArIHgxICogeDEgKyB4MiAqIHgyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB4MCA9IDA7XG4gICAgICAgIHgxID0gMDtcbiAgICAgICAgeDIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHgwICo9IGxlbjtcbiAgICAgICAgeDEgKj0gbGVuO1xuICAgICAgICB4MiAqPSBsZW47XG4gICAgfVxuXG4gICAgeTAgPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgICB5MSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICAgIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG5cbiAgICBsZW4gPSBNYXRoLnNxcnQoeTAgKiB5MCArIHkxICogeTEgKyB5MiAqIHkyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB5MCA9IDA7XG4gICAgICAgIHkxID0gMDtcbiAgICAgICAgeTIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHkwICo9IGxlbjtcbiAgICAgICAgeTEgKj0gbGVuO1xuICAgICAgICB5MiAqPSBsZW47XG4gICAgfVxuXG4gICAgb3V0WzBdID0geDA7XG4gICAgb3V0WzFdID0geTA7XG4gICAgb3V0WzJdID0gejA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4MTtcbiAgICBvdXRbNV0gPSB5MTtcbiAgICBvdXRbNl0gPSB6MTtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHgyO1xuICAgIG91dFs5XSA9IHkyO1xuICAgIG91dFsxMF0gPSB6MjtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gLSh4MCAqIGV5ZXggKyB4MSAqIGV5ZXkgKyB4MiAqIGV5ZXopO1xuICAgIG91dFsxM10gPSAtKHkwICogZXlleCArIHkxICogZXlleSArIHkyICogZXlleik7XG4gICAgb3V0WzE0XSA9IC0oejAgKiBleWV4ICsgejEgKiBleWV5ICsgejIgKiBleWV6KTtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0NC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0NCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcsICcgK1xuICAgICAgICAgICAgICAgICAgICBhWzRdICsgJywgJyArIGFbNV0gKyAnLCAnICsgYVs2XSArICcsICcgKyBhWzddICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIGFbOF0gKyAnLCAnICsgYVs5XSArICcsICcgKyBhWzEwXSArICcsICcgKyBhWzExXSArICcsICcgKyBcbiAgICAgICAgICAgICAgICAgICAgYVsxMl0gKyAnLCAnICsgYVsxM10gKyAnLCAnICsgYVsxNF0gKyAnLCAnICsgYVsxNV0gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5tYXQ0LmZyb2IgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgTWF0aC5wb3coYVs2XSwgMikgKyBNYXRoLnBvdyhhWzddLCAyKSArIE1hdGgucG93KGFbOF0sIDIpICsgTWF0aC5wb3coYVs5XSwgMikgKyBNYXRoLnBvdyhhWzEwXSwgMikgKyBNYXRoLnBvdyhhWzExXSwgMikgKyBNYXRoLnBvdyhhWzEyXSwgMikgKyBNYXRoLnBvdyhhWzEzXSwgMikgKyBNYXRoLnBvdyhhWzE0XSwgMikgKyBNYXRoLnBvdyhhWzE1XSwgMikgKSlcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBtYXQ0O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xudmFyIG1hdDMgPSByZXF1aXJlKFwiLi9tYXQzLmpzXCIpO1xudmFyIHZlYzMgPSByZXF1aXJlKFwiLi92ZWMzLmpzXCIpO1xudmFyIHZlYzQgPSByZXF1aXJlKFwiLi92ZWM0LmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyBRdWF0ZXJuaW9uXG4gKiBAbmFtZSBxdWF0XG4gKi9cbnZhciBxdWF0ID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBxdWF0XG4gKlxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqL1xucXVhdC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXRzIGEgcXVhdGVybmlvbiB0byByZXByZXNlbnQgdGhlIHNob3J0ZXN0IHJvdGF0aW9uIGZyb20gb25lXG4gKiB2ZWN0b3IgdG8gYW5vdGhlci5cbiAqXG4gKiBCb3RoIHZlY3RvcnMgYXJlIGFzc3VtZWQgdG8gYmUgdW5pdCBsZW5ndGguXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uLlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBpbml0aWFsIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBkZXN0aW5hdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGlvblRvID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB0bXB2ZWMzID0gdmVjMy5jcmVhdGUoKTtcbiAgICB2YXIgeFVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDEsMCwwKTtcbiAgICB2YXIgeVVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDAsMSwwKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICAgICAgdmFyIGRvdCA9IHZlYzMuZG90KGEsIGIpO1xuICAgICAgICBpZiAoZG90IDwgLTAuOTk5OTk5KSB7XG4gICAgICAgICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIHhVbml0VmVjMywgYSk7XG4gICAgICAgICAgICBpZiAodmVjMy5sZW5ndGgodG1wdmVjMykgPCAwLjAwMDAwMSlcbiAgICAgICAgICAgICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIHlVbml0VmVjMywgYSk7XG4gICAgICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh0bXB2ZWMzLCB0bXB2ZWMzKTtcbiAgICAgICAgICAgIHF1YXQuc2V0QXhpc0FuZ2xlKG91dCwgdG1wdmVjMywgTWF0aC5QSSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9IGVsc2UgaWYgKGRvdCA+IDAuOTk5OTk5KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSAwO1xuICAgICAgICAgICAgb3V0WzFdID0gMDtcbiAgICAgICAgICAgIG91dFsyXSA9IDA7XG4gICAgICAgICAgICBvdXRbM10gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgYSwgYik7XG4gICAgICAgICAgICBvdXRbMF0gPSB0bXB2ZWMzWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdG1wdmVjM1sxXTtcbiAgICAgICAgICAgIG91dFsyXSA9IHRtcHZlYzNbMl07XG4gICAgICAgICAgICBvdXRbM10gPSAxICsgZG90O1xuICAgICAgICAgICAgcmV0dXJuIHF1YXQubm9ybWFsaXplKG91dCwgb3V0KTtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFNldHMgdGhlIHNwZWNpZmllZCBxdWF0ZXJuaW9uIHdpdGggdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuXG4gKiBheGVzLiBFYWNoIGF4aXMgaXMgYSB2ZWMzIGFuZCBpcyBleHBlY3RlZCB0byBiZSB1bml0IGxlbmd0aCBhbmRcbiAqIHBlcnBlbmRpY3VsYXIgdG8gYWxsIG90aGVyIHNwZWNpZmllZCBheGVzLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gdmlldyAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIHZpZXdpbmcgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHJpZ2h0IHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCBcInJpZ2h0XCIgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHVwICAgIHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCBcInVwXCIgZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuc2V0QXhlcyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgbWF0ciA9IG1hdDMuY3JlYXRlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob3V0LCB2aWV3LCByaWdodCwgdXApIHtcbiAgICAgICAgbWF0clswXSA9IHJpZ2h0WzBdO1xuICAgICAgICBtYXRyWzNdID0gcmlnaHRbMV07XG4gICAgICAgIG1hdHJbNl0gPSByaWdodFsyXTtcblxuICAgICAgICBtYXRyWzFdID0gdXBbMF07XG4gICAgICAgIG1hdHJbNF0gPSB1cFsxXTtcbiAgICAgICAgbWF0cls3XSA9IHVwWzJdO1xuXG4gICAgICAgIG1hdHJbMl0gPSAtdmlld1swXTtcbiAgICAgICAgbWF0cls1XSA9IC12aWV3WzFdO1xuICAgICAgICBtYXRyWzhdID0gLXZpZXdbMl07XG5cbiAgICAgICAgcmV0dXJuIHF1YXQubm9ybWFsaXplKG91dCwgcXVhdC5mcm9tTWF0MyhvdXQsIG1hdHIpKTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXRlcm5pb24gdG8gY2xvbmVcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5jbG9uZSA9IHZlYzQuY2xvbmU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuZnJvbVZhbHVlcyA9IHZlYzQuZnJvbVZhbHVlcztcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgcXVhdCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIHNvdXJjZSBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5jb3B5ID0gdmVjNC5jb3B5O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHF1YXQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNldCA9IHZlYzQuc2V0O1xuXG4vKipcbiAqIFNldCBhIHF1YXQgdG8gdGhlIGlkZW50aXR5IHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0cyBhIHF1YXQgZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYW5kIHJvdGF0aW9uIGF4aXMsXG4gKiB0aGVuIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgYXJvdW5kIHdoaWNoIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgaW4gcmFkaWFuc1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICoqL1xucXVhdC5zZXRBeGlzQW5nbGUgPSBmdW5jdGlvbihvdXQsIGF4aXMsIHJhZCkge1xuICAgIHJhZCA9IHJhZCAqIDAuNTtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgb3V0WzBdID0gcyAqIGF4aXNbMF07XG4gICAgb3V0WzFdID0gcyAqIGF4aXNbMV07XG4gICAgb3V0WzJdID0gcyAqIGF4aXNbMl07XG4gICAgb3V0WzNdID0gTWF0aC5jb3MocmFkKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuYWRkID0gdmVjNC5hZGQ7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl0sIGJ3ID0gYlszXTtcblxuICAgIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubXVsID0gcXVhdC5tdWx0aXBseTtcblxuLyoqXG4gKiBTY2FsZXMgYSBxdWF0IGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNjYWxlID0gdmVjNC5zY2FsZTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFggYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRlWCA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHJhZCAqPSAwLjU7IFxuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnggPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieDtcbiAgICBvdXRbMV0gPSBheSAqIGJ3ICsgYXogKiBieDtcbiAgICBvdXRbMl0gPSBheiAqIGJ3IC0gYXkgKiBieDtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFkgYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRlWSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHJhZCAqPSAwLjU7IFxuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnkgPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3IC0gYXogKiBieTtcbiAgICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieTtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXggKiBieTtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXkgKiBieTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFogYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRlWiA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHJhZCAqPSAwLjU7IFxuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnogPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXkgKiBiejtcbiAgICBvdXRbMV0gPSBheSAqIGJ3IC0gYXggKiBiejtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBiejtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXogKiBiejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBXIGNvbXBvbmVudCBvZiBhIHF1YXQgZnJvbSB0aGUgWCwgWSwgYW5kIFogY29tcG9uZW50cy5cbiAqIEFzc3VtZXMgdGhhdCBxdWF0ZXJuaW9uIGlzIDEgdW5pdCBpbiBsZW5ndGguXG4gKiBBbnkgZXhpc3RpbmcgVyBjb21wb25lbnQgd2lsbCBiZSBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIFcgY29tcG9uZW50IG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuY2FsY3VsYXRlVyA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcblxuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIG91dFszXSA9IE1hdGguc3FydChNYXRoLmFicygxLjAgLSB4ICogeCAtIHkgKiB5IC0geiAqIHopKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5kb3QgPSB2ZWM0LmRvdDtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5sZXJwID0gdmVjNC5sZXJwO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnNsZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIC8vIGJlbmNobWFya3M6XG4gICAgLy8gICAgaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi1zbGVycC1pbXBsZW1lbnRhdGlvbnNcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl0sIGJ3ID0gYlszXTtcblxuICAgIHZhciAgICAgICAgb21lZ2EsIGNvc29tLCBzaW5vbSwgc2NhbGUwLCBzY2FsZTE7XG5cbiAgICAvLyBjYWxjIGNvc2luZVxuICAgIGNvc29tID0gYXggKiBieCArIGF5ICogYnkgKyBheiAqIGJ6ICsgYXcgKiBidztcbiAgICAvLyBhZGp1c3Qgc2lnbnMgKGlmIG5lY2Vzc2FyeSlcbiAgICBpZiAoIGNvc29tIDwgMC4wICkge1xuICAgICAgICBjb3NvbSA9IC1jb3NvbTtcbiAgICAgICAgYnggPSAtIGJ4O1xuICAgICAgICBieSA9IC0gYnk7XG4gICAgICAgIGJ6ID0gLSBiejtcbiAgICAgICAgYncgPSAtIGJ3O1xuICAgIH1cbiAgICAvLyBjYWxjdWxhdGUgY29lZmZpY2llbnRzXG4gICAgaWYgKCAoMS4wIC0gY29zb20pID4gMC4wMDAwMDEgKSB7XG4gICAgICAgIC8vIHN0YW5kYXJkIGNhc2UgKHNsZXJwKVxuICAgICAgICBvbWVnYSAgPSBNYXRoLmFjb3MoY29zb20pO1xuICAgICAgICBzaW5vbSAgPSBNYXRoLnNpbihvbWVnYSk7XG4gICAgICAgIHNjYWxlMCA9IE1hdGguc2luKCgxLjAgLSB0KSAqIG9tZWdhKSAvIHNpbm9tO1xuICAgICAgICBzY2FsZTEgPSBNYXRoLnNpbih0ICogb21lZ2EpIC8gc2lub207XG4gICAgfSBlbHNlIHsgICAgICAgIFxuICAgICAgICAvLyBcImZyb21cIiBhbmQgXCJ0b1wiIHF1YXRlcm5pb25zIGFyZSB2ZXJ5IGNsb3NlIFxuICAgICAgICAvLyAgLi4uIHNvIHdlIGNhbiBkbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgICAgIHNjYWxlMCA9IDEuMCAtIHQ7XG4gICAgICAgIHNjYWxlMSA9IHQ7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZXNcbiAgICBvdXRbMF0gPSBzY2FsZTAgKiBheCArIHNjYWxlMSAqIGJ4O1xuICAgIG91dFsxXSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7XG4gICAgb3V0WzJdID0gc2NhbGUwICogYXogKyBzY2FsZTEgKiBiejtcbiAgICBvdXRbM10gPSBzY2FsZTAgKiBhdyArIHNjYWxlMSAqIGJ3O1xuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYyB0aGUgdGhpcmQgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5zcWxlcnAgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgdGVtcDEgPSBxdWF0LmNyZWF0ZSgpO1xuICB2YXIgdGVtcDIgPSBxdWF0LmNyZWF0ZSgpO1xuICBcbiAgcmV0dXJuIGZ1bmN0aW9uIChvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgICBxdWF0LnNsZXJwKHRlbXAxLCBhLCBkLCB0KTtcbiAgICBxdWF0LnNsZXJwKHRlbXAyLCBiLCBjLCB0KTtcbiAgICBxdWF0LnNsZXJwKG91dCwgdGVtcDEsIHRlbXAyLCAyICogdCAqICgxIC0gdCkpO1xuICAgIFxuICAgIHJldHVybiBvdXQ7XG4gIH07XG59KCkpO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGludmVyc2Ugb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgaW52ZXJzZSBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG4gICAgICAgIGRvdCA9IGEwKmEwICsgYTEqYTEgKyBhMiphMiArIGEzKmEzLFxuICAgICAgICBpbnZEb3QgPSBkb3QgPyAxLjAvZG90IDogMDtcbiAgICBcbiAgICAvLyBUT0RPOiBXb3VsZCBiZSBmYXN0ZXIgdG8gcmV0dXJuIFswLDAsMCwwXSBpbW1lZGlhdGVseSBpZiBkb3QgPT0gMFxuXG4gICAgb3V0WzBdID0gLWEwKmludkRvdDtcbiAgICBvdXRbMV0gPSAtYTEqaW52RG90O1xuICAgIG91dFsyXSA9IC1hMippbnZEb3Q7XG4gICAgb3V0WzNdID0gYTMqaW52RG90O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGNvbmp1Z2F0ZSBvZiBhIHF1YXRcbiAqIElmIHRoZSBxdWF0ZXJuaW9uIGlzIG5vcm1hbGl6ZWQsIHRoaXMgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW4gcXVhdC5pbnZlcnNlIGFuZCBwcm9kdWNlcyB0aGUgc2FtZSByZXN1bHQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgY29uanVnYXRlIG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuY29uanVnYXRlID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0Lmxlbmd0aCA9IHZlYzQubGVuZ3RoO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5sZW4gPSBxdWF0Lmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuc3F1YXJlZExlbmd0aCA9IHZlYzQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNxckxlbiA9IHF1YXQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdGVybmlvbiB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0Lm5vcm1hbGl6ZSA9IHZlYzQubm9ybWFsaXplO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBxdWF0ZXJuaW9uIGZyb20gdGhlIGdpdmVuIDN4MyByb3RhdGlvbiBtYXRyaXguXG4gKlxuICogTk9URTogVGhlIHJlc3VsdGFudCBxdWF0ZXJuaW9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyB5b3Ugc2hvdWxkIGJlIHN1cmVcbiAqIHRvIHJlbm9ybWFsaXplIHRoZSBxdWF0ZXJuaW9uIHlvdXJzZWxmIHdoZXJlIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7bWF0M30gbSByb3RhdGlvbiBtYXRyaXhcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmZyb21NYXQzID0gZnVuY3Rpb24ob3V0LCBtKSB7XG4gICAgLy8gQWxnb3JpdGhtIGluIEtlbiBTaG9lbWFrZSdzIGFydGljbGUgaW4gMTk4NyBTSUdHUkFQSCBjb3Vyc2Ugbm90ZXNcbiAgICAvLyBhcnRpY2xlIFwiUXVhdGVybmlvbiBDYWxjdWx1cyBhbmQgRmFzdCBBbmltYXRpb25cIi5cbiAgICB2YXIgZlRyYWNlID0gbVswXSArIG1bNF0gKyBtWzhdO1xuICAgIHZhciBmUm9vdDtcblxuICAgIGlmICggZlRyYWNlID4gMC4wICkge1xuICAgICAgICAvLyB8d3wgPiAxLzIsIG1heSBhcyB3ZWxsIGNob29zZSB3ID4gMS8yXG4gICAgICAgIGZSb290ID0gTWF0aC5zcXJ0KGZUcmFjZSArIDEuMCk7ICAvLyAyd1xuICAgICAgICBvdXRbM10gPSAwLjUgKiBmUm9vdDtcbiAgICAgICAgZlJvb3QgPSAwLjUvZlJvb3Q7ICAvLyAxLyg0dylcbiAgICAgICAgb3V0WzBdID0gKG1bNV0tbVs3XSkqZlJvb3Q7XG4gICAgICAgIG91dFsxXSA9IChtWzZdLW1bMl0pKmZSb290O1xuICAgICAgICBvdXRbMl0gPSAobVsxXS1tWzNdKSpmUm9vdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB8d3wgPD0gMS8yXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgaWYgKCBtWzRdID4gbVswXSApXG4gICAgICAgICAgaSA9IDE7XG4gICAgICAgIGlmICggbVs4XSA+IG1baSozK2ldIClcbiAgICAgICAgICBpID0gMjtcbiAgICAgICAgdmFyIGogPSAoaSsxKSUzO1xuICAgICAgICB2YXIgayA9IChpKzIpJTM7XG4gICAgICAgIFxuICAgICAgICBmUm9vdCA9IE1hdGguc3FydChtW2kqMytpXS1tW2oqMytqXS1tW2sqMytrXSArIDEuMCk7XG4gICAgICAgIG91dFtpXSA9IDAuNSAqIGZSb290O1xuICAgICAgICBmUm9vdCA9IDAuNSAvIGZSb290O1xuICAgICAgICBvdXRbM10gPSAobVtqKjMra10gLSBtW2sqMytqXSkgKiBmUm9vdDtcbiAgICAgICAgb3V0W2pdID0gKG1baiozK2ldICsgbVtpKjMral0pICogZlJvb3Q7XG4gICAgICAgIG91dFtrXSA9IChtW2sqMytpXSArIG1baSozK2tdKSAqIGZSb290O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgcXVhdGVuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xucXVhdC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAncXVhdCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcXVhdDtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgMiBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBuYW1lIHZlYzJcbiAqL1xudmFyIHZlYzIgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXG4gKlxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSkge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5zdWIgPSB2ZWMyLnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLm11bCA9IHZlYzIubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5kaXYgPSB2ZWMyLmRpdmlkZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubWluID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm1heCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc2NhbGVBbmRBZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMi5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5kaXN0ID0gdmVjMi5kaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzIuc3F1YXJlZERpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgICByZXR1cm4geCp4ICsgeSp5O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuc3FyRGlzdCA9IHZlYzIuc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbnZlYzIubGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLmxlbiA9IHZlYzIubGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbnZlYzIuc3F1YXJlZExlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICByZXR1cm4geCp4ICsgeSp5O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLnNxckxlbiA9IHZlYzIuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuaW52ZXJzZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICB2YXIgbGVuID0geCp4ICsgeSp5O1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgICAgICAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG52ZWMyLmRvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqIE5vdGUgdGhhdCB0aGUgY3Jvc3MgcHJvZHVjdCBtdXN0IGJ5IGRlZmluaXRpb24gcHJvZHVjZSBhIDNEIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMi5jcm9zcyA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIHZhciB6ID0gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXTtcbiAgICBvdXRbMF0gPSBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IHo7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV07XG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5yYW5kb20gPSBmdW5jdGlvbiAob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuICAgIHZhciByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICAgIG91dFswXSA9IE1hdGguY29zKHIpICogc2NhbGU7XG4gICAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiBzY2FsZTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDIgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHk7XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0MmR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0MmQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDNcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQzfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDMgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVszXSAqIHkgKyBtWzZdO1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs0XSAqIHkgKyBtWzddO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDRcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzAnXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQ0ID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCBcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bMTJdO1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzEzXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjMnMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMi4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzJzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLmZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZlYyA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgICAgIHZhciBpLCBsO1xuICAgICAgICBpZighc3RyaWRlKSB7XG4gICAgICAgICAgICBzdHJpZGUgPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoY291bnQpIHtcbiAgICAgICAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsID0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldOyB2ZWNbMV0gPSBhW2krMV07XG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgICAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzIuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzIoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcpJztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdmVjMjtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgMyBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBuYW1lIHZlYzNcbiAqL1xudmFyIHZlYzMgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMzXG4gKlxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG52ZWMzLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbnZlYzMuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbnZlYzMuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zZXQgPSBmdW5jdGlvbihvdXQsIHgsIHksIHopIHtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5zdWIgPSB2ZWMzLnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLm11bCA9IHZlYzMubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5kaXYgPSB2ZWMzLmRpdmlkZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubWluID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm1heCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMydzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc2NhbGVBbmRBZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgICBvdXRbMl0gPSBhWzJdICsgKGJbMl0gKiBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzMuZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5kaXN0ID0gdmVjMy5kaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzMuc3F1YXJlZERpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6Kno7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5zcXJEaXN0ID0gdmVjMy5zcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjMy5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmxlbiA9IHZlYzMubGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbnZlYzMuc3F1YXJlZExlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqejtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5zcXJMZW4gPSB2ZWMzLnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmludmVyc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgb3V0WzJdID0gMS4wIC8gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6Kno7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICAgICAgICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzMuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmNyb3NzID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl07XG5cbiAgICBvdXRbMF0gPSBheSAqIGJ6IC0gYXogKiBieTtcbiAgICBvdXRbMV0gPSBheiAqIGJ4IC0gYXggKiBiejtcbiAgICBvdXRbMl0gPSBheCAqIGJ5IC0gYXkgKiBieDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5sZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXSxcbiAgICAgICAgYXogPSBhWzJdO1xuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgaGVybWl0ZSBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuaGVybWl0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgdmFyIGZhY3RvclRpbWVzMiA9IHQgKiB0LFxuICAgICAgZmFjdG9yMSA9IGZhY3RvclRpbWVzMiAqICgyICogdCAtIDMpICsgMSxcbiAgICAgIGZhY3RvcjIgPSBmYWN0b3JUaW1lczIgKiAodCAtIDIpICsgdCxcbiAgICAgIGZhY3RvcjMgPSBmYWN0b3JUaW1lczIgKiAodCAtIDEpLFxuICAgICAgZmFjdG9yNCA9IGZhY3RvclRpbWVzMiAqICgzIC0gMiAqIHQpO1xuICBcbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcbiAgXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgYmV6aWVyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5iZXppZXIgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBpbnZlcnNlRmFjdG9yID0gMSAtIHQsXG4gICAgICBpbnZlcnNlRmFjdG9yVGltZXNUd28gPSBpbnZlcnNlRmFjdG9yICogaW52ZXJzZUZhY3RvcixcbiAgICAgIGZhY3RvclRpbWVzMiA9IHQgKiB0LFxuICAgICAgZmFjdG9yMSA9IGludmVyc2VGYWN0b3JUaW1lc1R3byAqIGludmVyc2VGYWN0b3IsXG4gICAgICBmYWN0b3IyID0gMyAqIHQgKiBpbnZlcnNlRmFjdG9yVGltZXNUd28sXG4gICAgICBmYWN0b3IzID0gMyAqIGZhY3RvclRpbWVzMiAqIGludmVyc2VGYWN0b3IsXG4gICAgICBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogdDtcbiAgXG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG4gIFxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnJhbmRvbSA9IGZ1bmN0aW9uIChvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG5cbiAgICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgICB2YXIgeiA9IChnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCkgLSAxLjA7XG4gICAgdmFyIHpTY2FsZSA9IE1hdGguc3FydCgxLjAteip6KSAqIHNjYWxlO1xuXG4gICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGU7XG4gICAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiB6U2NhbGU7XG4gICAgb3V0WzJdID0geiAqIHNjYWxlO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDQuXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy50cmFuc2Zvcm1NYXQ0ID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV07XG4gICAgdyA9IHcgfHwgMS4wO1xuICAgIG91dFswXSA9IChtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSkgLyB3O1xuICAgIG91dFsxXSA9IChtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSkgLyB3O1xuICAgIG91dFsyXSA9IChtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0pIC8gdztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQzLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSB0aGUgM3gzIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnRyYW5zZm9ybU1hdDMgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcbiAgICBvdXRbMF0gPSB4ICogbVswXSArIHkgKiBtWzNdICsgeiAqIG1bNl07XG4gICAgb3V0WzFdID0geCAqIG1bMV0gKyB5ICogbVs0XSArIHogKiBtWzddO1xuICAgIG91dFsyXSA9IHggKiBtWzJdICsgeSAqIG1bNV0gKyB6ICogbVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBxdWF0XG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtxdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy50cmFuc2Zvcm1RdWF0ID0gZnVuY3Rpb24ob3V0LCBhLCBxKSB7XG4gICAgLy8gYmVuY2htYXJrczogaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi10cmFuc2Zvcm0tdmVjMy1pbXBsZW1lbnRhdGlvbnNcblxuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM10sXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgICAgICAgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgICAgIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICAgIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gICAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnJvdGF0ZVggPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICAgdmFyIHAgPSBbXSwgcj1bXTtcblx0ICAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG5cdCAgcFswXSA9IGFbMF0gLSBiWzBdO1xuXHQgIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgXHRwWzJdID0gYVsyXSAtIGJbMl07XG5cblx0ICAvL3BlcmZvcm0gcm90YXRpb25cblx0ICByWzBdID0gcFswXTtcblx0ICByWzFdID0gcFsxXSpNYXRoLmNvcyhjKSAtIHBbMl0qTWF0aC5zaW4oYyk7XG5cdCAgclsyXSA9IHBbMV0qTWF0aC5zaW4oYykgKyBwWzJdKk1hdGguY29zKGMpO1xuXG5cdCAgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXHQgIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuXHQgIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuXHQgIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuXG4gIFx0cmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeS1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMucm90YXRlWSA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgYyl7XG4gIFx0dmFyIHAgPSBbXSwgcj1bXTtcbiAgXHQvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gIFx0cFswXSA9IGFbMF0gLSBiWzBdO1xuICBcdHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgXHRwWzJdID0gYVsyXSAtIGJbMl07XG4gIFxuICBcdC8vcGVyZm9ybSByb3RhdGlvblxuICBcdHJbMF0gPSBwWzJdKk1hdGguc2luKGMpICsgcFswXSpNYXRoLmNvcyhjKTtcbiAgXHRyWzFdID0gcFsxXTtcbiAgXHRyWzJdID0gcFsyXSpNYXRoLmNvcyhjKSAtIHBbMF0qTWF0aC5zaW4oYyk7XG4gIFxuICBcdC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgXHRvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgXHRvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgXHRvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgXG4gIFx0cmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMucm90YXRlWiA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgYyl7XG4gIFx0dmFyIHAgPSBbXSwgcj1bXTtcbiAgXHQvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gIFx0cFswXSA9IGFbMF0gLSBiWzBdO1xuICBcdHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgXHRwWzJdID0gYVsyXSAtIGJbMl07XG4gIFxuICBcdC8vcGVyZm9ybSByb3RhdGlvblxuICBcdHJbMF0gPSBwWzBdKk1hdGguY29zKGMpIC0gcFsxXSpNYXRoLnNpbihjKTtcbiAgXHRyWzFdID0gcFswXSpNYXRoLnNpbihjKSArIHBbMV0qTWF0aC5jb3MoYyk7XG4gIFx0clsyXSA9IHBbMl07XG4gIFxuICBcdC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgXHRvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgXHRvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgXHRvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgXG4gIFx0cmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzNzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzMuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMzcyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5mb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZWMgPSB2ZWMzLmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdOyB2ZWNbMl0gPSBhW2krMl07XG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgICAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTsgYVtpKzJdID0gdmVjWzJdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBHZXQgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIDNEIHZlY3RvcnNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqL1xudmVjMy5hbmdsZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgIFxuICAgIHZhciB0ZW1wQSA9IHZlYzMuZnJvbVZhbHVlcyhhWzBdLCBhWzFdLCBhWzJdKTtcbiAgICB2YXIgdGVtcEIgPSB2ZWMzLmZyb21WYWx1ZXMoYlswXSwgYlsxXSwgYlsyXSk7XG4gXG4gICAgdmVjMy5ub3JtYWxpemUodGVtcEEsIHRlbXBBKTtcbiAgICB2ZWMzLm5vcm1hbGl6ZSh0ZW1wQiwgdGVtcEIpO1xuIFxuICAgIHZhciBjb3NpbmUgPSB2ZWMzLmRvdCh0ZW1wQSwgdGVtcEIpO1xuXG4gICAgaWYoY29zaW5lID4gMS4wKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpO1xuICAgIH0gICAgIFxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjMy5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAndmVjMygnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnKSc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZlYzM7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDQgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbmFtZSB2ZWM0XG4gKi9cbnZhciB2ZWM0ID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjNFxuICpcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xudmVjNC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbnZlYzQuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbnZlYzQuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHgsIHksIHosIHcpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgb3V0WzNdID0gdztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjNCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSwgeiwgdykge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIG91dFszXSA9IHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuc3ViID0gdmVjNC5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICogYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5tdWwgPSB2ZWM0Lm11bHRpcGx5O1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5kaXZpZGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdIC8gYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuZGl2ID0gdmVjNC5kaXZpZGU7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm1pbiA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICAgIG91dFszXSA9IE1hdGgubWluKGFbM10sIGJbM10pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5tYXggPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgICBvdXRbM10gPSBNYXRoLm1heChhWzNdLCBiWzNdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWM0IGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIG91dFszXSA9IGFbM10gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzQncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjNC5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXSxcbiAgICAgICAgdyA9IGJbM10gLSBhWzNdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6ICsgdyp3KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuZGlzdCA9IHZlYzQuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWM0LnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXSxcbiAgICAgICAgdyA9IGJbM10gLSBhWzNdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5zcXJEaXN0ID0gdmVjNC5zcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjNC5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeiArIHcqdyk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5sZW4gPSB2ZWM0Lmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWM0LnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LnNxckxlbiA9IHZlYzQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIG91dFszXSA9IC1hWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuaW52ZXJzZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICBvdXRbM10gPSAxLjAgLyBhWzNdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBhWzNdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSB4ICogbGVuO1xuICAgICAgICBvdXRbMV0gPSB5ICogbGVuO1xuICAgICAgICBvdXRbMl0gPSB6ICogbGVuO1xuICAgICAgICBvdXRbM10gPSB3ICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzQuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdICsgYVszXSAqIGJbM107XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl0sXG4gICAgICAgIGF3ID0gYVszXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgICBvdXRbM10gPSBhdyArIHQgKiAoYlszXSAtIGF3KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnJhbmRvbSA9IGZ1bmN0aW9uIChvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG5cbiAgICAvL1RPRE86IFRoaXMgaXMgYSBwcmV0dHkgYXdmdWwgd2F5IG9mIGRvaW5nIHRoaXMuIEZpbmQgc29tZXRoaW5nIGJldHRlci5cbiAgICBvdXRbMF0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICBvdXRbMV0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICBvdXRbMl0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICBvdXRbM10gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICB2ZWM0Lm5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgdmVjNC5zY2FsZShvdXQsIG91dCwgc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIG1hdDQuXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSwgdyA9IGFbM107XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0gKiB3O1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdICogdztcbiAgICBvdXRbMl0gPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0gKiB3O1xuICAgIG91dFszXSA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XSAqIHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQudHJhbnNmb3JtUXVhdCA9IGZ1bmN0aW9uKG91dCwgYSwgcSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM10sXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgICAgICAgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgICAgIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICAgIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gICAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzQuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWM0cyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5mb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZWMgPSB2ZWM0LmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gNDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdOyB2ZWNbMl0gPSBhW2krMl07IHZlY1szXSA9IGFbaSszXTtcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdOyBhW2krMl0gPSB2ZWNbMl07IGFbaSszXSA9IHZlY1szXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZlYzQ7XG4iLCIvLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gd2hlbiB1c2VkIGluIG5vZGUsIHRoaXMgd2lsbCBhY3R1YWxseSBsb2FkIHRoZSB1dGlsIG1vZHVsZSB3ZSBkZXBlbmQgb25cbi8vIHZlcnN1cyBsb2FkaW5nIHRoZSBidWlsdGluIHV0aWwgbW9kdWxlIGFzIGhhcHBlbnMgb3RoZXJ3aXNlXG4vLyB0aGlzIGlzIGEgYnVnIGluIG5vZGUgbW9kdWxlIGxvYWRpbmcgYXMgZmFyIGFzIEkgYW0gY29uY2VybmVkXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG5cbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gc3RhY2tTdGFydEZ1bmN0aW9uLm5hbWU7XG4gICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xcbicgKyBmbl9uYW1lKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgbG9jYXRlZCB0aGUgZnVuY3Rpb24gZnJhbWVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzdHJpcCBvdXQgZXZlcnl0aGluZyBiZWZvcmUgaXQgKGFuZCBpdHMgbGluZSlcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcbiAgICAgICAgb3V0ID0gb3V0LnN1YnN0cmluZyhuZXh0X2xpbmUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFjayA9IG91dDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gIGlmICh1dGlsLmlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgIHJldHVybiAnJyArIHZhbHVlO1xuICB9XG4gIGlmICh1dGlsLmlzTnVtYmVyKHZhbHVlKSAmJiAhaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbih2YWx1ZSkgfHwgdXRpbC5pc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocykpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeShzZWxmLmFjdHVhbCwgcmVwbGFjZXIpLCAxMjgpICsgJyAnICtcbiAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuICAgICAgICAgdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoc2VsZi5leHBlY3RlZCwgcmVwbGFjZXIpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGFjdHVhbCkgJiYgdXRpbC5pc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICBpZiAoYWN0dWFsLmxlbmd0aCAhPSBleHBlY3RlZC5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0dWFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWN0dWFsW2ldICE9PSBleHBlY3RlZFtpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghdXRpbC5pc09iamVjdChhY3R1YWwpICYmICF1dGlsLmlzT2JqZWN0KGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYikge1xuICBpZiAodXRpbC5pc051bGxPclVuZGVmaW5lZChhKSB8fCB1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZVxuICBpZiAodXRpbC5pc1ByaW1pdGl2ZShhKSB8fCB1dGlsLmlzUHJpbWl0aXZlKGIpKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cbiAgdmFyIGFJc0FyZ3MgPSBpc0FyZ3VtZW50cyhhKSxcbiAgICAgIGJJc0FyZ3MgPSBpc0FyZ3VtZW50cyhiKTtcbiAgaWYgKChhSXNBcmdzICYmICFiSXNBcmdzKSB8fCAoIWFJc0FyZ3MgJiYgYklzQXJncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYUlzQXJncykge1xuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYik7XG4gIH1cbiAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgIGtiID0gb2JqZWN0S2V5cyhiKSxcbiAgICAgIGtleSwgaTtcbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHV0aWwuaXNTdHJpbmcoZXhwZWN0ZWQpKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGFjdHVhbCA9IGU7XG4gIH1cblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICghc2hvdWxkVGhyb3cgJiYgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW3RydWVdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFtmYWxzZV0uY29uY2F0KHBTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHt0aHJvdyBlcnI7fX07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIHZhciBtO1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gMDtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbihlbWl0dGVyLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IDE7XG4gIGVsc2VcbiAgICByZXQgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCIvKipcbiAqIGxvZGFzaCAzLjIuMCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xudmFyIGJhc2VBc3NpZ24gPSByZXF1aXJlKCdsb2Rhc2guX2Jhc2Vhc3NpZ24nKSxcbiAgICBjcmVhdGVBc3NpZ25lciA9IHJlcXVpcmUoJ2xvZGFzaC5fY3JlYXRlYXNzaWduZXInKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnbG9kYXNoLmtleXMnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uYXNzaWduYCBmb3IgY3VzdG9taXppbmcgYXNzaWduZWQgdmFsdWVzIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGFyZ3VtZW50IGp1Z2dsaW5nLCBtdWx0aXBsZSBzb3VyY2VzLCBhbmQgYHRoaXNgIGJpbmRpbmcgYGN1c3RvbWl6ZXJgXG4gKiBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYXNzaWduV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHByb3BzID0ga2V5cyhzb3VyY2UpLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplcih2YWx1ZSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpO1xuXG4gICAgaWYgKChyZXN1bHQgPT09IHJlc3VsdCA/IChyZXN1bHQgIT09IHZhbHVlKSA6ICh2YWx1ZSA9PT0gdmFsdWUpKSB8fFxuICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgb2JqZWN0W2tleV0gPSByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbi8qKlxuICogQXNzaWducyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGRlc3RpbmF0aW9uXG4gKiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy5cbiAqIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6XG4gKiAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YCBhbmQgaXMgYmFzZWQgb25cbiAqIFtgT2JqZWN0LmFzc2lnbmBdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1vYmplY3QuYXNzaWduKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGFsaWFzIGV4dGVuZFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5hc3NpZ24oeyAndXNlcic6ICdiYXJuZXknIH0sIHsgJ2FnZSc6IDQwIH0sIHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfVxuICpcbiAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ24sIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICogICByZXR1cm4gXy5pc1VuZGVmaW5lZCh2YWx1ZSkgPyBvdGhlciA6IHZhbHVlO1xuICogfSk7XG4gKlxuICogZGVmYXVsdHMoeyAndXNlcic6ICdiYXJuZXknIH0sIHsgJ2FnZSc6IDM2IH0sIHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gKi9cbnZhciBhc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcikge1xuICByZXR1cm4gY3VzdG9taXplclxuICAgID8gYXNzaWduV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcilcbiAgICA6IGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduO1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy4yLjAgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciBiYXNlQ29weSA9IHJlcXVpcmUoJ2xvZGFzaC5fYmFzZWNvcHknKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnbG9kYXNoLmtleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmcsXG4gKiBtdWx0aXBsZSBzb3VyY2VzLCBhbmQgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIHNvdXJjZSA9PSBudWxsXG4gICAgPyBvYmplY3RcbiAgICA6IGJhc2VDb3B5KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ247XG4iLCIvKipcbiAqIGxvZGFzaCAzLjAuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDb3B5KHNvdXJjZSwgcHJvcHMsIG9iamVjdCkge1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDb3B5O1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy4xLjIgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciBnZXROYXRpdmUgPSByZXF1aXJlKCdsb2Rhc2guX2dldG5hdGl2ZScpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnbG9kYXNoLmlzYXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJ2xvZGFzaC5pc2FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eXFxkKyQvO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2tleXMnKTtcblxuLyoqXG4gKiBVc2VkIGFzIHRoZSBbbWF4aW11bSBsZW5ndGhdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5tYXhfc2FmZV9pbnRlZ2VyKVxuICogb2YgYW4gYXJyYXktbGlrZSB2YWx1ZS5cbiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgdmFsdWUgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhdm9pZCBhIFtKSVQgYnVnXShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNzkyKVxuICogdGhhdCBhZmZlY3RzIFNhZmFyaSBvbiBhdCBsZWFzdCBpT1MgOC4xLTguMyBBUk02NC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIFwibGVuZ3RoXCIgdmFsdWUuXG4gKi9cbnZhciBnZXRMZW5ndGggPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aChnZXRMZW5ndGgodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFsdWUgPSAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSA/ICt2YWx1ZSA6IC0xO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBPYmplY3Qua2V5c2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZiB0aGVcbiAqIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBzaGltS2V5cyhvYmplY3QpIHtcbiAgdmFyIHByb3BzID0ga2V5c0luKG9iamVjdCksXG4gICAgICBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IHByb3BzTGVuZ3RoICYmIG9iamVjdC5sZW5ndGg7XG5cbiAgdmFyIGFsbG93SW5kZXhlcyA9ICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgaWYgKChhbGxvd0luZGV4ZXMgJiYgaXNJbmRleChrZXksIGxlbmd0aCkpIHx8IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG52YXIga2V5cyA9ICFuYXRpdmVLZXlzID8gc2hpbUtleXMgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIEN0b3IgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgaWYgKCh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlID09PSBvYmplY3QpIHx8XG4gICAgICAodHlwZW9mIG9iamVjdCAhPSAnZnVuY3Rpb24nICYmIGlzQXJyYXlMaWtlKG9iamVjdCkpKSB7XG4gICAgcmV0dXJuIHNoaW1LZXlzKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KG9iamVjdCkgPyBuYXRpdmVLZXlzKG9iamVjdCkgOiBbXTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7XG4gIGxlbmd0aCA9IChsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSkgJiYgbGVuZ3RoKSB8fCAwO1xuXG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgaW5kZXggPSAtMSxcbiAgICAgIGlzUHJvdG8gPSB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlID09PSBvYmplY3QsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBsZW5ndGggPiAwO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IChpbmRleCArICcnKTtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoc2tpcEluZGV4ZXMgJiYgaXNJbmRleChrZXksIGxlbmd0aCkpICYmXG4gICAgICAgICEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcbiIsIi8qKlxuICogbG9kYXNoIDMuOS4xIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkgPiA1KS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZm5Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZuVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICByZXR1cm4gaXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpIHdoaWNoIHJldHVybiAnZnVuY3Rpb24nIGZvciByZWdleGVzXG4gIC8vIGFuZCBTYWZhcmkgOCBlcXVpdmFsZW50cyB3aGljaCByZXR1cm4gJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9ycy5cbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBmdW5jVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTmF0aXZlKF8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChmblRvU3RyaW5nLmNhbGwodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiByZUlzSG9zdEN0b3IudGVzdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy4wLjQgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIFVzZWQgYXMgdGhlIFttYXhpbXVtIGxlbmd0aF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSB2YWx1ZSBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGF2b2lkIGEgW0pJVCBidWddKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI3OTIpXG4gKiB0aGF0IGFmZmVjdHMgU2FmYXJpIG9uIGF0IGxlYXN0IGlPUyA4LjEtOC4zIEFSTTY0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgXCJsZW5ndGhcIiB2YWx1ZS5cbiAqL1xudmFyIGdldExlbmd0aCA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKGdldExlbmd0aCh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiYgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogbG9kYXNoIDMuMC40IChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpID4gNSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmblRvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQXJyYXkgPSBnZXROYXRpdmUoQXJyYXksICdpc0FycmF5Jyk7XG5cbi8qKlxuICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcbiAqIG9mIGFuIGFycmF5LWxpa2UgdmFsdWUuXG4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIHJldHVybiBpc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJyYXlUYWc7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaSB3aGljaCByZXR1cm4gJ2Z1bmN0aW9uJyBmb3IgcmVnZXhlc1xuICAvLyBhbmQgU2FmYXJpIDggZXF1aXZhbGVudHMgd2hpY2ggcmV0dXJuICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcnMuXG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZnVuY1RhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc05hdGl2ZShfKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHJldHVybiByZUlzTmF0aXZlLnRlc3QoZm5Ub1N0cmluZy5jYWxsKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgcmVJc0hvc3RDdG9yLnRlc3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCIvKipcbiAqIGxvZGFzaCAzLjEuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xudmFyIGJpbmRDYWxsYmFjayA9IHJlcXVpcmUoJ2xvZGFzaC5fYmluZGNhbGxiYWNrJyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCdsb2Rhc2guX2lzaXRlcmF0ZWVjYWxsJyksXG4gICAgcmVzdFBhcmFtID0gcmVxdWlyZSgnbG9kYXNoLnJlc3RwYXJhbScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFzc2lnbnMgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIGEgZ2l2ZW5cbiAqIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGNyZWF0ZSBgXy5hc3NpZ25gLCBgXy5kZWZhdWx0c2AsIGFuZCBgXy5tZXJnZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbbGVuZ3RoIC0gMl0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQsXG4gICAgICAgIHRoaXNBcmcgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcblxuICAgIGlmICh0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjdXN0b21pemVyID0gYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDUpO1xuICAgICAgbGVuZ3RoIC09IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgdGhpc0FyZyA9PSAnZnVuY3Rpb24nID8gdGhpc0FyZyA6IHVuZGVmaW5lZDtcbiAgICAgIGxlbmd0aCAtPSAoY3VzdG9taXplciA/IDEgOiAwKTtcbiAgICB9XG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcbiIsIi8qKlxuICogbG9kYXNoIDMuMC4xIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQ2FsbGJhY2tgIHdoaWNoIG9ubHkgc3VwcG9ydHMgYHRoaXNgIGJpbmRpbmdcbiAqIGFuZCBzcGVjaWZ5aW5nIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGJpbmRDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodGhpc0FyZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cbiAgc3dpdGNoIChhcmdDb3VudCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH07XG4gICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICB9O1xuICAgIGNhc2UgNTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlciwga2V5LCBvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgb3RoZXIsIGtleSwgb2JqZWN0LCBzb3VyY2UpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgcHJvdmlkZWQgdG8gaXQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gKlxuICogXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3Q7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kQ2FsbGJhY2s7XG4iLCIvKipcbiAqIGxvZGFzaCAzLjAuOSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXlxcZCskLztcblxuLyoqXG4gKiBVc2VkIGFzIHRoZSBbbWF4aW11bSBsZW5ndGhdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcbiAqIG9mIGFuIGFycmF5LWxpa2UgdmFsdWUuXG4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IHZhbHVlIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXZvaWQgYSBbSklUIGJ1Z10oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0Mjc5MilcbiAqIHRoYXQgYWZmZWN0cyBTYWZhcmkgb24gYXQgbGVhc3QgaU9TIDguMS04LjMgQVJNNjQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBcImxlbmd0aFwiIHZhbHVlLlxuICovXG52YXIgZ2V0TGVuZ3RoID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgoZ2V0TGVuZ3RoKHZhbHVlKSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhbHVlID0gKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgPyArdmFsdWUgOiAtMTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdCkpIHtcbiAgICB2YXIgb3RoZXIgPSBvYmplY3RbaW5kZXhdO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyAodmFsdWUgPT09IG90aGVyKSA6IChvdGhlciAhPT0gb3RoZXIpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSXRlcmF0ZWVDYWxsO1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy42LjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gKiBjcmVhdGVkIGZ1bmN0aW9uIGFuZCBhcmd1bWVudHMgZnJvbSBgc3RhcnRgIGFuZCBiZXlvbmQgcHJvdmlkZWQgYXMgYW4gYXJyYXkuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZSBbcmVzdCBwYXJhbWV0ZXJdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Z1bmN0aW9ucy9yZXN0X3BhcmFtZXRlcnMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHNheSA9IF8ucmVzdFBhcmFtKGZ1bmN0aW9uKHdoYXQsIG5hbWVzKSB7XG4gKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcbiAqICAgICAoXy5zaXplKG5hbWVzKSA+IDEgPyAnLCAmICcgOiAnJykgKyBfLmxhc3QobmFtZXMpO1xuICogfSk7XG4gKlxuICogc2F5KCdoZWxsbycsICdmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJyk7XG4gKiAvLyA9PiAnaGVsbG8gZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gKi9cbmZ1bmN0aW9uIHJlc3RQYXJhbShmdW5jLCBzdGFydCkge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiAoK3N0YXJ0IHx8IDApLCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIHJlc3QgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3RbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgc3dpdGNoIChzdGFydCkge1xuICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIHJlc3QpO1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3NbMF0sIHJlc3QpO1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIHJlc3QpO1xuICAgIH1cbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICBpbmRleCA9IC0xO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHJlc3Q7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXN0UGFyYW07XG4iLCIvKipcbiAqIGxvZGFzaCAzLjEuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xudmFyIGJhc2VBc3NpZ24gPSByZXF1aXJlKCdsb2Rhc2guX2Jhc2Vhc3NpZ24nKSxcbiAgICBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnbG9kYXNoLl9iYXNlY3JlYXRlJyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCdsb2Rhc2guX2lzaXRlcmF0ZWVjYWxsJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBnaXZlbiBgcHJvdG90eXBlYCBvYmplY3QuIElmIGFcbiAqIGBwcm9wZXJ0aWVzYCBvYmplY3QgaXMgcHJvdmlkZWQgaXRzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGFzc2lnbmVkXG4gKiB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIFRoZSBwcm9wZXJ0aWVzIHRvIGFzc2lnbiB0byB0aGUgb2JqZWN0LlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAqICAgdGhpcy54ID0gMDtcbiAqICAgdGhpcy55ID0gMDtcbiAqIH1cbiAqXG4gKiBmdW5jdGlvbiBDaXJjbGUoKSB7XG4gKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gKiB9XG4gKlxuICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwge1xuICogICAnY29uc3RydWN0b3InOiBDaXJjbGVcbiAqIH0pO1xuICpcbiAqIHZhciBjaXJjbGUgPSBuZXcgQ2lyY2xlO1xuICogY2lyY2xlIGluc3RhbmNlb2YgQ2lyY2xlO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIGNpcmNsZSBpbnN0YW5jZW9mIFNoYXBlO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzLCBndWFyZCkge1xuICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwocHJvdG90eXBlLCBwcm9wZXJ0aWVzLCBndWFyZCkpIHtcbiAgICBwcm9wZXJ0aWVzID0gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0aWVzID8gYmFzZUFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZTtcbiIsIi8qKlxuICogbG9kYXNoIDMuMC4zIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG52YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgIGlmIChpc09iamVjdChwcm90b3R5cGUpKSB7XG4gICAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0IHx8IHt9O1xuICB9O1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy4xLjIgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciBhc3NpZ24gPSByZXF1aXJlKCdsb2Rhc2guYXNzaWduJyksXG4gICAgcmVzdFBhcmFtID0gcmVxdWlyZSgnbG9kYXNoLnJlc3RwYXJhbScpO1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduYCB1c2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0VmFsdWUgVGhlIGRlc3RpbmF0aW9uIG9iamVjdCBwcm9wZXJ0eSB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gc291cmNlVmFsdWUgVGhlIHNvdXJjZSBvYmplY3QgcHJvcGVydHkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbkRlZmF1bHRzKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSkge1xuICByZXR1cm4gb2JqZWN0VmFsdWUgPT09IHVuZGVmaW5lZCA/IHNvdXJjZVZhbHVlIDogb2JqZWN0VmFsdWU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBfLmRlZmF1bHRzYCBvciBgXy5kZWZhdWx0c0RlZXBgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWZhdWx0cyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdHMoYXNzaWduZXIsIGN1c3RvbWl6ZXIpIHtcbiAgcmV0dXJuIHJlc3RQYXJhbShmdW5jdGlvbihhcmdzKSB7XG4gICAgdmFyIG9iamVjdCA9IGFyZ3NbMF07XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICBhcmdzLnB1c2goY3VzdG9taXplcik7XG4gICAgcmV0dXJuIGFzc2lnbmVyLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICogb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIE9uY2UgYVxuICogcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlcyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmF1bHRzKHsgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICdhZ2UnOiAzNiB9LCB7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICovXG52YXIgZGVmYXVsdHMgPSBjcmVhdGVEZWZhdWx0cyhhc3NpZ24sIGFzc2lnbkRlZmF1bHRzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSggJy4vbGliLycgKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIG5vdyA9IHJlcXVpcmUoXCJwZXJmb3JtYW5jZS1ub3dcIik7XG5cbiAgICBmdW5jdGlvbiBmaW5kKGFyciwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgICBpZiAoYXJyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZmluZCBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJlZGljYXRlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxpc3QgPSBPYmplY3QoYXJyKTtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aCA+Pj4gMDtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwobnVsbCwgdmFsdWUsIGksIGxpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICB2YXIgU2ltcGxlVGV4dHVyZU1hbmFnZXIgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdGhpcy5fdW5pdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAob3B0LnVuaXRzIHx8IDgpOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX3VuaXRzW2ldID0ge3Nsb3Q6IGksIHVzZTogMH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU2ltcGxlVGV4dHVyZU1hbmFnZXIuTk9UX0ZPVU5EID0gLTE7XG4gICAgU2ltcGxlVGV4dHVyZU1hbmFnZXIuRlVMTCA9IC0yO1xuXG4gICAgU2ltcGxlVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIF9zZXQ6IGZ1bmN0aW9uIChzbG90LCBuZXdFbnRyeSkge1xuICAgICAgICAgICAgdmFyIG9sZEVudHJ5ID0gdGhpcy5fdW5pdHNbc2xvdF07XG4gICAgICAgICAgICBpZiAob2xkRW50cnkuZGlzcG9zZSkge1xuICAgICAgICAgICAgICAgIG9sZEVudHJ5LmRpc3Bvc2Uob2xkRW50cnksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld0VudHJ5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5pdHNbc2xvdF0gPSBuZXdFbnRyeTtcbiAgICAgICAgICAgICAgICB0aGlzLl91bml0c1tzbG90XS5zbG90ID0gc2xvdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5pdHNbc2xvdF0gPSB7c2xvdDogc2xvdCwgdXNlOiAwfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBiaW5kOiBmdW5jdGlvbiAoaWQsIG9wdCkge1xuICAgICAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICAgICAgdmFyIGZpeGVkID0gISFvcHQuZml4ZWQ7XG4gICAgICAgICAgICB2YXIgZGlzcG9zZSA9IHR5cGVvZiBvcHQuZGlzcG9zZSA9PSBcImZ1bmN0aW9uXCIgPyBvcHQuZGlzcG9zZSA6IG51bGw7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRleHR1cmUgaXMgYWxyZWFkeSBib3VuZFxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZ2V0KGlkKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IFNpbXBsZVRleHR1cmVNYW5hZ2VyLk5PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGVzID0gdGhpcy5fdW5pdHMuZmlsdGVyKGZ1bmN0aW9uICh1bml0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF1bml0LmZpeGVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ2FuZGlkYXRlcyxcIiwgY2FuZGlkYXRlcywgY2FuZGlkYXRlcy5sZW5ndGgpO1xuXG4gICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNpbXBsZVRleHR1cmVNYW5hZ2VyLkZVTEw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IGNhbmRpZGF0ZXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXYgPyAoY3Vyci51c2UgPCBwcmV2LnVzZSA/IGN1cnIgOiBwcmV2KSA6IGN1cnI7XG4gICAgICAgICAgICB9LCBudWxsKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTZWxlY3RlZCBlbnRyeVwiLCBzZWxlY3RlZCk7XG5cbiAgICAgICAgICAgIHZhciBzbG90ID0gc2VsZWN0ZWQuc2xvdDtcbiAgICAgICAgICAgIHRoaXMuX3NldChzbG90LCB7XG4gICAgICAgICAgICAgICAgZml4ZWQ6IGZpeGVkLCB1c2U6IG5vdygpLCBpZDogaWQsIGRpc3Bvc2U6IGRpc3Bvc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNsb3Q7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuZ2V0RW50cnkoaWQpO1xuICAgICAgICAgICAgdGhpcy5fc2V0KGVudHJ5LnNsb3QsIG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBpZiB0aGUgdGV4dHVyZSBvZiB0aGUgZ2l2ZW4gaWQgaXMgYm91bmQgdG8gYW4gdW5pdFxuICAgICAgICAgKiBAcGFyYW0gaWRcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBoYXM6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5nZXRFbnRyeShpZCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRleHR1cmUgdW5pdCBmb3IgdGhlIGlkIG9yIFNpbXBsZVRleHR1cmVNYW5hZ2VyLk5PVF9GT1VORFxuICAgICAgICAgKiBpZiB0aGUgdGV4dHVyZSBpcyBjdXJyZW50bHkgbm90IGJvdW5kXG4gICAgICAgICAqIEBwYXJhbSBpZFxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5nZXRFbnRyeShpZCk7XG4gICAgICAgICAgICBpZihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudXNlID0gbm93KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zbG90O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFNpbXBsZVRleHR1cmVNYW5hZ2VyLk5PVF9GT1VORDtcbiAgICAgICAgfSxcblxuICAgICAgICB1c2U6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZ2V0RW50cnkoaWQpO1xuICAgICAgICAgICAgaWYocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnVzZSA9IG5vdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldEVudHJ5OiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5kKHRoaXMuX3VuaXRzLCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkuaWQgPT09IGlkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH07XG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIFNpbXBsZVRleHR1cmVNYW5hZ2VyOiBTaW1wbGVUZXh0dXJlTWFuYWdlclxuICAgIH07XG59KCk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBnZXROYW5vU2Vjb25kcywgaHJ0aW1lLCBsb2FkVGltZTtcblxuICBpZiAoKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwZXJmb3JtYW5jZSAhPT0gbnVsbCkgJiYgcGVyZm9ybWFuY2Uubm93KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKCh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzICE9PSBudWxsKSAmJiBwcm9jZXNzLmhydGltZSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKGdldE5hbm9TZWNvbmRzKCkgLSBsb2FkVGltZSkgLyAxZTY7XG4gICAgfTtcbiAgICBocnRpbWUgPSBwcm9jZXNzLmhydGltZTtcbiAgICBnZXROYW5vU2Vjb25kcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhyO1xuICAgICAgaHIgPSBocnRpbWUoKTtcbiAgICAgIHJldHVybiBoclswXSAqIDFlOSArIGhyWzFdO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBnZXROYW5vU2Vjb25kcygpO1xuICB9IGVsc2UgaWYgKERhdGUubm93KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbG9hZFRpbWU7XG4gICAgfTtcbiAgICBsb2FkVGltZSA9IERhdGUubm93KCk7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfVxuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHNlbGYuZmV0Y2gpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSlcbiAgICB9XG4gICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXFxeX2B8fl0vaS50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZScpXG4gICAgfVxuICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICAgIHRoaXMubWFwID0ge31cblxuICAgIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKVxuICAgICAgfSwgdGhpcylcblxuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pXG4gICAgICB9LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSlcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxuICAgIHZhciBsaXN0ID0gdGhpcy5tYXBbbmFtZV1cbiAgICBpZiAoIWxpc3QpIHtcbiAgICAgIGxpc3QgPSBbXVxuICAgICAgdGhpcy5tYXBbbmFtZV0gPSBsaXN0XG4gICAgfVxuICAgIGxpc3QucHVzaCh2YWx1ZSlcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbiAgICByZXR1cm4gdmFsdWVzID8gdmFsdWVzWzBdIDogbnVsbFxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSB8fCBbXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IFtub3JtYWxpemVWYWx1ZSh2YWx1ZSldXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLm1hcCkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICB0aGlzLm1hcFtuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsdWUsIG5hbWUsIHRoaXMpXG4gICAgICB9LCB0aGlzKVxuICAgIH0sIHRoaXMpXG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdClcbiAgICAgIH1cbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbiAgICByZXR1cm4gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IpXG4gICAgcmV0dXJuIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIH1cblxuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBibG9iOiAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJiAnQmxvYicgaW4gc2VsZiAmJiAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pKCksXG4gICAgZm9ybURhdGE6ICdGb3JtRGF0YScgaW4gc2VsZixcbiAgICBhcnJheUJ1ZmZlcjogJ0FycmF5QnVmZmVyJyBpbiBzZWxmXG4gIH1cblxuICBmdW5jdGlvbiBCb2R5KCkge1xuICAgIHRoaXMuYm9keVVzZWQgPSBmYWxzZVxuXG5cbiAgICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keVxuICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuZm9ybURhdGEgJiYgRm9ybURhdGEucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUZvcm1EYXRhID0gYm9keVxuICAgICAgfSBlbHNlIGlmICghYm9keSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9ICcnXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgQXJyYXlCdWZmZXIucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgLy8gT25seSBzdXBwb3J0IEFycmF5QnVmZmVycyBmb3IgUE9TVCBtZXRob2QuXG4gICAgICAgIC8vIFJlY2VpdmluZyBBcnJheUJ1ZmZlcnMgaGFwcGVucyB2aWEgQmxvYnMsIGluc3RlYWQuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIEJvZHlJbml0IHR5cGUnKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9iKCkudGhlbihyZWFkQmxvYkFzQXJyYXlCdWZmZXIpXG4gICAgICB9XG5cbiAgICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgcmV0dXJuIHJlamVjdGVkID8gcmVqZWN0ZWQgOiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICByZXR1cm4gKG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xKSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5XG4gICAgaWYgKFJlcXVlc3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoaW5wdXQpKSB7XG4gICAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gaW5wdXQudXJsXG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHNcbiAgICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpXG4gICAgICB9XG4gICAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZFxuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZVxuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXRcbiAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXJsID0gaW5wdXRcbiAgICB9XG5cbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdvbWl0J1xuICAgIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykge1xuICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIH1cbiAgICB0aGlzLm1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChvcHRpb25zLm1ldGhvZCB8fCB0aGlzLm1ldGhvZCB8fCAnR0VUJylcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGxcbiAgICB0aGlzLnJlZmVycmVyID0gbnVsbFxuXG4gICAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICAgIH1cbiAgICB0aGlzLl9pbml0Qm9keShib2R5KVxuICB9XG5cbiAgUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcylcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKVxuICAgIGJvZHkudHJpbSgpLnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbihieXRlcykge1xuICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IGJ5dGVzLnNwbGl0KCc9JylcbiAgICAgICAgdmFyIG5hbWUgPSBzcGxpdC5zaGlmdCgpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJz0nKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICBmb3JtLmFwcGVuZChkZWNvZGVVUklDb21wb25lbnQobmFtZSksIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gZm9ybVxuICB9XG5cbiAgZnVuY3Rpb24gaGVhZGVycyh4aHIpIHtcbiAgICB2YXIgaGVhZCA9IG5ldyBIZWFkZXJzKClcbiAgICB2YXIgcGFpcnMgPSB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkudHJpbSgpLnNwbGl0KCdcXG4nKVxuICAgIHBhaXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICB2YXIgc3BsaXQgPSBoZWFkZXIudHJpbSgpLnNwbGl0KCc6JylcbiAgICAgIHZhciBrZXkgPSBzcGxpdC5zaGlmdCgpLnRyaW0oKVxuICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignOicpLnRyaW0oKVxuICAgICAgaGVhZC5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICB9KVxuICAgIHJldHVybiBoZWFkXG4gIH1cblxuICBCb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpXG5cbiAgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fVxuICAgIH1cblxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KVxuICAgIHRoaXMudHlwZSA9ICdkZWZhdWx0J1xuICAgIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXNcbiAgICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwXG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gb3B0aW9ucy5zdGF0dXNUZXh0XG4gICAgdGhpcy5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycyA/IG9wdGlvbnMuaGVhZGVycyA6IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnXG4gIH1cblxuICBCb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKVxuXG4gIFJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHtcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgICAgdXJsOiB0aGlzLnVybFxuICAgIH0pXG4gIH1cblxuICBSZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAwLCBzdGF0dXNUZXh0OiAnJ30pXG4gICAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcidcbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfVxuXG4gIHZhciByZWRpcmVjdFN0YXR1c2VzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XVxuXG4gIFJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG4gIH1cblxuICBzZWxmLkhlYWRlcnMgPSBIZWFkZXJzO1xuICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0O1xuICBzZWxmLlJlc3BvbnNlID0gUmVzcG9uc2U7XG5cbiAgc2VsZi5mZXRjaCA9IGZ1bmN0aW9uKGlucHV0LCBpbml0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlcXVlc3RcbiAgICAgIGlmIChSZXF1ZXN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGlucHV0KSAmJiAhaW5pdCkge1xuICAgICAgICByZXF1ZXN0ID0gaW5wdXRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdClcbiAgICAgIH1cblxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG5cbiAgICAgIGZ1bmN0aW9uIHJlc3BvbnNlVVJMKCkge1xuICAgICAgICBpZiAoJ3Jlc3BvbnNlVVJMJyBpbiB4aHIpIHtcbiAgICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlVVJMXG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdm9pZCBzZWN1cml0eSB3YXJuaW5ncyBvbiBnZXRSZXNwb25zZUhlYWRlciB3aGVuIG5vdCBhbGxvd2VkIGJ5IENPUlNcbiAgICAgICAgaWYgKC9eWC1SZXF1ZXN0LVVSTDovbS50ZXN0KHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpIHtcbiAgICAgICAgICByZXR1cm4geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdYLVJlcXVlc3QtVVJMJylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhdHVzID0gKHhoci5zdGF0dXMgPT09IDEyMjMpID8gMjA0IDogeGhyLnN0YXR1c1xuICAgICAgICBpZiAoc3RhdHVzIDwgMTAwIHx8IHN0YXR1cyA+IDU5OSkge1xuICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogaGVhZGVycyh4aHIpLFxuICAgICAgICAgIHVybDogcmVzcG9uc2VVUkwoKVxuICAgICAgICB9XG4gICAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QudXJsLCB0cnVlKVxuXG4gICAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYidcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpXG4gICAgICB9KVxuXG4gICAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KVxuICAgIH0pXG4gIH1cbiAgc2VsZi5mZXRjaC5wb2x5ZmlsbCA9IHRydWVcbn0pKCk7XG4iLCJ2YXIgU2V0ID0gcmVxdWlyZShcIi4uL3hmbG93L3V0aWxzL3V0aWxzLmpzXCIpLnNldDtcclxudmFyIERhdGFOb2RlID0gcmVxdWlyZShcIi4uL3hmbG93L2ludGVyZmFjZS9ncmFwaC5qc1wiKS5EYXRhTm9kZTtcclxudmFyIEJhc2UgPSByZXF1aXJlKFwiLi4veGZsb3cvYmFzZS5qc1wiKTtcclxuXHJcbmZ1bmN0aW9uIEFzc2V0RXJyb3IobWVzc2FnZSwgbm9kZSl7XHJcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgdGhpcy5ub2RlID0gbm9kZTtcclxufVxyXG5cclxudmFyIEFzc2V0ID0gZnVuY3Rpb24ocmVmTm9kZSl7XHJcbiAgICB0aGlzLm5hbWUgPSBudWxsO1xyXG4gICAgdGhpcy5zcmNBc3NldCA9IG51bGw7XHJcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcbiAgICB0aGlzLnN1YkFzc2V0cyA9IFtdO1xyXG4gICAgdGhpcy5waWNrRmlsdGVyID0gbnVsbDtcclxuICAgIHRoaXMucGFyZW50cyA9IFtdO1xyXG4gICAgdGhpcy5saXN0ZW5lciA9IFtdO1xyXG4gICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLnJlZk5vZGUgPSByZWZOb2RlIHx8IG51bGw7XHJcbiAgICB0aGlzLm1hdGVyaWFsID0gbnVsbDtcclxuICAgIHRoaXMudHJhbnNmb3JtID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLmFzc2V0UmVzdWx0ID0gbnVsbDtcclxuICAgIHRoaXMubG9hZExldmVsID0gMDtcclxuICAgIHRoaXMucHJvZ3Jlc3NMZXZlbCA9IEluZmluaXR5O1xyXG59O1xyXG5cclxuQXNzZXQucHJvdG90eXBlLmNoZWNrVmFsaWRpdHkgPSBmdW5jdGlvbigpe1xyXG4gICAgaWYodGhpcy5pc1N1YnRyZWVMb2FkaW5nKCkpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgY2hlY2tSZWN1cnNpdmUodGhpcyk7XHJcbn07XHJcbmZ1bmN0aW9uIGNoZWNrUmVjdXJzaXZlKGFzc2V0KXtcclxuICAgIGlmKGFzc2V0LnNyY0Fzc2V0KXtcclxuICAgICAgICBjaGVja1JlY3Vyc2l2ZShhc3NldC5zcmNBc3NldCk7XHJcbiAgICB9XHJcbiAgICB2YXIgbG9jYWxOYW1lcyA9IFtdO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGFzc2V0LmNoaWxkcmVuLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB2YXIgY2hpbGQgPSBhc3NldC5jaGlsZHJlbltpXSwgbmFtZSA9IGNoaWxkLm5hbWU7XHJcbiAgICAgICAgaWYobmFtZSAmJiBsb2NhbE5hbWVzLmluZGV4T2YobmFtZSkgIT0gLTEpe1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQXNzZXRFcnJvcihcIlR3byBzdWJkYXRhIGVsZW1lbnRzIHdpdGggdGhlIHNhbWUgbmFtZTogJ1wiICsgbmFtZSArIFwiJ1wiLCBjaGlsZC5yZWZOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYobmFtZSkgbG9jYWxOYW1lcy5wdXNoKG5hbWUpO1xyXG4gICAgfVxyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGFzc2V0LnN1YkFzc2V0cy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgY2hlY2tSZWN1cnNpdmUoYXNzZXQuc3ViQXNzZXRzW2ldKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbkFzc2V0LnByb3RvdHlwZS5zZXRMb2FkaW5nID0gZnVuY3Rpb24obG9hZGluZyl7XHJcbiAgICBpZihsb2FkaW5nICE9IHRoaXMubG9hZGluZyl7XHJcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gbG9hZGluZztcclxuICAgICAgICB1cGRhdGVMb2FkaW5nU3RhdGUodGhpcyk7XHJcbiAgICAgICAgaW52YWxpZGF0ZUFzc2V0KHRoaXMpO1xyXG5cclxuICAgIH1cclxufTtcclxuXHJcbkFzc2V0LnByb3RvdHlwZS5pc1N1YnRyZWVMb2FkaW5nID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLnByb2dyZXNzTGV2ZWwgPT0gMDtcclxufTtcclxuQXNzZXQucHJvdG90eXBlLmdldFByb2dyZXNzTGV2ZWwgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3NMZXZlbDtcclxufTtcclxuXHJcbkFzc2V0LnByb3RvdHlwZS5zZXROYW1lID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgaW52YWxpZGF0ZUFzc2V0KHRoaXMpO1xyXG59O1xyXG5cclxuQXNzZXQucHJvdG90eXBlLnNldE1hdGVyaWFsID0gZnVuY3Rpb24obWF0ZXJpYWwpe1xyXG4gICAgdGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xyXG4gICAgaW52YWxpZGF0ZUFzc2V0KHRoaXMpO1xyXG59O1xyXG5cclxuQXNzZXQucHJvdG90eXBlLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uKHRyYW5zZm9ybSl7XHJcbiAgICB0aGlzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcclxuICAgIGlmICh0aGlzLnJlZk5vZGUubG9jYWxOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwibW9kZWxcIikge1xyXG4gICAgICAgIGludmFsaWRhdGVBc3NldCh0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcbkFzc2V0LnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKXtcclxuICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICBjaGlsZC5hc3NldFBhcmVudCA9IHRoaXM7XHJcbiAgICB1cGRhdGVMb2FkaW5nU3RhdGUodGhpcyk7XHJcbiAgICBpbnZhbGlkYXRlQXNzZXQodGhpcyk7XHJcblxyXG59O1xyXG5cclxuQXNzZXQucHJvdG90eXBlLnNldFBpY2tGaWx0ZXIgPSBmdW5jdGlvbihwaWNrRmlsdGVyU3RyaW5nKXtcclxuICAgIGlmKHR5cGVvZiBwaWNrRmlsdGVyU3RyaW5nID09IFwic3RyaW5nXCIpe1xyXG4gICAgICAgIHRoaXMucGlja0ZpbHRlciA9IG5ldyBBc3NldFBpY2tGaWx0ZXIoKTtcclxuICAgICAgICB0aGlzLnBpY2tGaWx0ZXIucGFyc2UocGlja0ZpbHRlclN0cmluZyk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICAgICAgdGhpcy5waWNrRmlsdGVyID0gbnVsbDtcclxuICAgIGludmFsaWRhdGVBc3NldCh0aGlzKTtcclxufTtcclxuXHJcbkFzc2V0LnByb3RvdHlwZS5hcHBlbmRTdWJBc3NldCA9IGZ1bmN0aW9uKHN1YkFzc2V0KXtcclxuICAgIHN1YkFzc2V0Ll9hZGRQYXJlbnQodGhpcyk7XHJcbiAgICB0aGlzLnN1YkFzc2V0cy5wdXNoKHN1YkFzc2V0KTtcclxuICAgIHVwZGF0ZUxvYWRpbmdTdGF0ZSh0aGlzKTtcclxuICAgIGludmFsaWRhdGVBc3NldCh0aGlzKTtcclxuXHJcbn07XHJcblxyXG5Bc3NldC5wcm90b3R5cGUuc2V0U3JjQXNzZXQgPSBmdW5jdGlvbihhc3NldCl7XHJcbiAgICBpZih0aGlzLnNyY0Fzc2V0KVxyXG4gICAgICAgIHRoaXMuc3JjQXNzZXQuX3JlbW92ZVBhcmVudCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnNyY0Fzc2V0ID0gYXNzZXQ7XHJcblxyXG4gICAgaWYodGhpcy5zcmNBc3NldClcclxuICAgICAgICB0aGlzLnNyY0Fzc2V0Ll9hZGRQYXJlbnQodGhpcyk7XHJcbiAgICB1cGRhdGVMb2FkaW5nU3RhdGUodGhpcyk7XHJcbiAgICBpbnZhbGlkYXRlQXNzZXQodGhpcyk7XHJcblxyXG59O1xyXG5cclxuQXNzZXQucHJvdG90eXBlLmNsZWFyQ2hpbGRyZW4gPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcclxuICAgIHdoaWxlKGktLSkgdGhpcy5jaGlsZHJlbltpXS5hc3NldFBhcmVudCA9IG51bGw7XHJcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcbiAgICB1cGRhdGVMb2FkaW5nU3RhdGUodGhpcyk7XHJcbiAgICBpbnZhbGlkYXRlQXNzZXQodGhpcyk7XHJcblxyXG59O1xyXG5Bc3NldC5wcm90b3R5cGUuY2xlYXJTdWJBc3NldHMgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGkgPSB0aGlzLnN1YkFzc2V0cy5sZW5ndGg7XHJcbiAgICB3aGlsZShpLS0pIHtcclxuICAgICAgICB0aGlzLnN1YkFzc2V0c1tpXS5fcmVtb3ZlUGFyZW50KHRoaXMpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zdWJBc3NldHMubGVuZ3RoID0gMDtcclxuICAgIHVwZGF0ZUxvYWRpbmdTdGF0ZSh0aGlzKTtcclxuICAgIGludmFsaWRhdGVBc3NldCh0aGlzKTtcclxuXHJcbn07XHJcblxyXG5Bc3NldC5wcm90b3R5cGUuX2FkZFBhcmVudCA9IGZ1bmN0aW9uKGFzc2V0KXtcclxuICAgIHRoaXMucGFyZW50cy5wdXNoKGFzc2V0KTtcclxufTtcclxuQXNzZXQucHJvdG90eXBlLl9yZW1vdmVQYXJlbnQgPSBmdW5jdGlvbihhc3NldCl7XHJcbiAgICB2YXIgaWR4ID0gdGhpcy5wYXJlbnRzLmluZGV4T2YoYXNzZXQpO1xyXG4gICAgaWYoaWR4ICE9IC0xKVxyXG4gICAgICAgIHRoaXMucGFyZW50cy5zcGxpY2UoaWR4LCAxKTtcclxufTtcclxuXHJcbkFzc2V0LnByb3RvdHlwZS5fY2FsbExvYWRMaXN0ZW5lcnMgPSBmdW5jdGlvbihuZXdMZXZlbCwgb2xkTGV2ZWwpe1xyXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXI7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICBsaXN0ZW5lcnNbaV0ub25Bc3NldExvYWRDaGFuZ2UgJiYgbGlzdGVuZXJzW2ldLm9uQXNzZXRMb2FkQ2hhbmdlKHRoaXMsIG5ld0xldmVsLCBvbGRMZXZlbCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuQXNzZXQucHJvdG90eXBlLmFkZENoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpe1xyXG4gICAgU2V0LmFkZCh0aGlzLmxpc3RlbmVyLCBsaXN0ZW5lcik7XHJcbn07XHJcbkFzc2V0LnByb3RvdHlwZS5yZW1vdmVDaGFuZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKXtcclxuICAgIFNldC5yZW1vdmUodGhpcy5saXN0ZW5lciwgbGlzdGVuZXIpO1xyXG4gICAgaWYgKCF0aGlzLmxpc3RlbmVyLmxlbmd0aCkge1xyXG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQXNzZXQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuYXNzZXRSZXN1bHQuZGlzcG9zZSgpO1xyXG4gICAgdGhpcy5jbGVhclN1YkFzc2V0cygpO1xyXG4gICAgdGhpcy5jbGVhckNoaWxkcmVuKCk7XHJcbn07XHJcblxyXG5Bc3NldC5wcm90b3R5cGUuZ2V0UmVzdWx0ID0gZnVuY3Rpb24oKXtcclxuICAgIGlmKCF0aGlzLmFzc2V0UmVzdWx0KXtcclxuICAgICAgICB0aGlzLmFzc2V0UmVzdWx0ID0gbmV3IEFzc2V0UmVzdWx0KCk7XHJcbiAgICAgICAgdGhpcy5hc3NldFJlc3VsdC5jb25zdHJ1Y3QodGhpcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5hc3NldFJlc3VsdDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGludmFsaWRhdGVBc3NldChhc3NldCl7XHJcbiAgICBpZihhc3NldC5hc3NldFJlc3VsdCl7XHJcbiAgICAgICAgYXNzZXQuYXNzZXRSZXN1bHQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgdmFyIGxpc3RlbmVycyA9IGFzc2V0Lmxpc3RlbmVyO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgbGlzdGVuZXJzW2ldLm9uQXNzZXRDaGFuZ2UgJiYgbGlzdGVuZXJzW2ldLm9uQXNzZXRDaGFuZ2UodGhpcyk7XHJcbiAgICB9XHJcbiAgICB2YXIgaSA9IGFzc2V0LnBhcmVudHMubGVuZ3RoO1xyXG4gICAgd2hpbGUoaS0tKXtcclxuICAgICAgICBpbnZhbGlkYXRlQXNzZXQoYXNzZXQucGFyZW50c1tpXSk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiB1cGRhdGVMb2FkaW5nU3RhdGUoYXNzZXQpe1xyXG4gICAgdmFyIHByb2dyZXNzTGV2ZWwgPSBhc3NldC5sb2FkaW5nID8gYXNzZXQubG9hZExldmVsIDogSW5maW5pdHk7XHJcbiAgICBpZihwcm9ncmVzc0xldmVsICYmIGFzc2V0LnNyY0Fzc2V0KXtcclxuICAgICAgICBwcm9ncmVzc0xldmVsID0gTWF0aC5taW4ocHJvZ3Jlc3NMZXZlbCwgTWF0aC5tYXgoYXNzZXQuc3JjQXNzZXQubG9hZExldmVsLCBhc3NldC5zcmNBc3NldC5wcm9ncmVzc0xldmVsKSk7XHJcbiAgICB9XHJcbiAgICB2YXIgaSA9IGFzc2V0LnN1YkFzc2V0cy5sZW5ndGg7XHJcbiAgICB3aGlsZShwcm9ncmVzc0xldmVsICYmIGktLSl7XHJcbiAgICAgICAgcHJvZ3Jlc3NMZXZlbCA9IE1hdGgubWluKHByb2dyZXNzTGV2ZWwsIE1hdGgubWF4KGFzc2V0LnN1YkFzc2V0c1tpXS5sb2FkTGV2ZWwsIGFzc2V0LnN1YkFzc2V0c1tpXS5wcm9ncmVzc0xldmVsKSk7XHJcbiAgICB9XHJcbiAgICB2YXIgaSA9IGFzc2V0LmNoaWxkcmVuLmxlbmd0aDtcclxuICAgIHdoaWxlKHByb2dyZXNzTGV2ZWwgJiYgaS0tKXtcclxuICAgICAgICBwcm9ncmVzc0xldmVsID0gTWF0aC5taW4ocHJvZ3Jlc3NMZXZlbCwgYXNzZXQuY2hpbGRyZW5baV0ucHJvZ3Jlc3NMZXZlbCk7XHJcbiAgICB9XHJcbiAgICB2YXIgb2xkTGV2ZWwgPSBhc3NldC5wcm9ncmVzc0xldmVsO1xyXG4gICAgYXNzZXQucHJvZ3Jlc3NMZXZlbCA9IHByb2dyZXNzTGV2ZWw7XHJcblxyXG4gICAgaWYob2xkTGV2ZWwgIT0gYXNzZXQucHJvZ3Jlc3NMZXZlbCl7XHJcbiAgICAgICAgYXNzZXQuX2NhbGxMb2FkTGlzdGVuZXJzKGFzc2V0LnByb2dyZXNzTGV2ZWwsIG9sZExldmVsKTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXNzZXQucGFyZW50cy5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgdXBkYXRlTG9hZGluZ1N0YXRlKGFzc2V0LnBhcmVudHNbaV0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIFN1YkRhdGFcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG52YXIgU3ViRGF0YSA9IGZ1bmN0aW9uKHhmbG93Tm9kZU91dCwgeGZsb3dOb2RlSW4sIHJlZk5vZGUpe1xyXG4gICAgdGhpcy54Zmxvd05vZGVPdXQgPSB4Zmxvd05vZGVPdXQ7XHJcbiAgICB0aGlzLnhmbG93Tm9kZUluID0geGZsb3dOb2RlSW47XHJcbiAgICB0aGlzLnJlZk5vZGUgPSByZWZOb2RlIHx8IG51bGw7XHJcbiAgICB0aGlzLm5hbWUgPSBudWxsO1xyXG4gICAgdGhpcy5tYXRjaEZpbHRlciA9IG51bGw7XHJcbiAgICB0aGlzLmNsYXNzTmFtZXMgPSBbXTtcclxuICAgIHRoaXMucG9zdERhdGFmbG93ID0gbnVsbDtcclxuICAgIHRoaXMucG9zdENvbXB1dGUgPSBudWxsO1xyXG4gICAgdGhpcy5wb3N0RmlsdGVyID0gbnVsbDtcclxuICAgIHRoaXMuaW5jbHVkZXMgPSBbXTtcclxuICAgIHRoaXMubWF0ZXJpYWwgPSBudWxsO1xyXG4gICAgdGhpcy50cmFuc2Zvcm0gPSBudWxsO1xyXG4gICAgdGhpcy5tZXNoVHlwZSA9IG51bGw7XHJcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xyXG4gICAgdGhpcy5hc3NldFBhcmVudCA9IG51bGw7XHJcbiAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMubG9hZExldmVsID0gMDtcclxuICAgIHRoaXMucHJvZ3Jlc3NMZXZlbCA9IEluZmluaXR5O1xyXG4gICAgeGZsb3dOb2RlSW4uYWRkTG9hZExpc3RlbmVyKHRoaXMub25YZmxvd0xvYWRFdmVudC5iaW5kKHRoaXMpKTtcclxuICAgIHRoaXMuX3VwZGF0ZUxvYWRpbmdTdGF0ZSgpO1xyXG59O1xyXG5cclxuU3ViRGF0YS5wcm90b3R5cGUuc2V0TG9hZGluZyA9IGZ1bmN0aW9uKGxvYWRpbmcpe1xyXG4gICAgaWYobG9hZGluZyAhPSB0aGlzLmxvYWRpbmcpe1xyXG4gICAgICAgIHRoaXMubG9hZGluZyA9IGxvYWRpbmc7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlTG9hZGluZ1N0YXRlKCk7XHJcbiAgICAgICAgaW52YWxpZGF0ZVBhcmVudCh0aGlzKTtcclxuXHJcbiAgICB9XHJcbn07XHJcblxyXG5TdWJEYXRhLnByb3RvdHlwZS5fdXBkYXRlTG9hZGluZ1N0YXRlID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBwcm9ncmVzc0xldmVsID0gdGhpcy5sb2FkaW5nID8gdGhpcy5sb2FkTGV2ZWwgOiBJbmZpbml0eTtcclxuICAgIHByb2dyZXNzTGV2ZWwgPSBNYXRoLm1pbihwcm9ncmVzc0xldmVsLCB0aGlzLnhmbG93Tm9kZUluLmdldFByb2dyZXNzTGV2ZWwoKSk7XHJcbiAgICB2YXIgb2xkTGV2ZWwgPSB0aGlzLnByb2dyZXNzTGV2ZWw7XHJcbiAgICB0aGlzLnByb2dyZXNzTGV2ZWwgPSBwcm9ncmVzc0xldmVsO1xyXG5cclxuICAgIGlmKG9sZExldmVsICE9IHRoaXMucHJvZ3Jlc3NMZXZlbCl7XHJcbiAgICAgICAgdGhpcy5hc3NldFBhcmVudCAmJiB1cGRhdGVMb2FkaW5nU3RhdGUodGhpcy5hc3NldFBhcmVudCk7XHJcbiAgICAgICAgaW52YWxpZGF0ZVBhcmVudCh0aGlzKTtcclxuICAgIH1cclxufTtcclxuU3ViRGF0YS5wcm90b3R5cGUub25YZmxvd0xvYWRFdmVudCA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLl91cGRhdGVMb2FkaW5nU3RhdGUoKTtcclxufTtcclxuXHJcblN1YkRhdGEucHJvdG90eXBlLmlzU3VidHJlZUxvYWRpbmcgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMubG9hZGluZztcclxufTtcclxuXHJcblN1YkRhdGEucHJvdG90eXBlLmlzTWVzaCA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gISF0aGlzLm1lc2hUeXBlO1xyXG59O1xyXG5cclxuU3ViRGF0YS5wcm90b3R5cGUuc2V0TmFtZSA9IGZ1bmN0aW9uKG5hbWUpe1xyXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgIGludmFsaWRhdGVQYXJlbnQodGhpcyk7XHJcbn07XHJcblxyXG5TdWJEYXRhLnByb3RvdHlwZS5zZXRNYXRjaEZpbHRlciA9IGZ1bmN0aW9uKG1hdGNoU3RyaW5nKXtcclxuICAgIGlmKHR5cGVvZiBtYXRjaFN0cmluZyA9PSBcInN0cmluZ1wiKXtcclxuICAgICAgICB0aGlzLm1hdGNoRmlsdGVyID0gbmV3IEFzc2V0UGlja0ZpbHRlcigpO1xyXG4gICAgICAgIHRoaXMubWF0Y2hGaWx0ZXIucGFyc2UobWF0Y2hTdHJpbmcpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAgICAgIHRoaXMubWF0Y2hGaWx0ZXIgPSBudWxsO1xyXG4gICAgaW52YWxpZGF0ZVBhcmVudCh0aGlzKTtcclxufTtcclxuXHJcblN1YkRhdGEucHJvdG90eXBlLnNldENsYXNzTmFtZXMgPSBmdW5jdGlvbihjbGFzc05hbWVzKXtcclxuICAgIHRoaXMuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XHJcbiAgICBpbnZhbGlkYXRlUGFyZW50KHRoaXMpO1xyXG59O1xyXG5TdWJEYXRhLnByb3RvdHlwZS5zZXRDbGFzc05hbWVzU3RyaW5nID0gZnVuY3Rpb24oY2xhc3NOYW1lc1N0cmluZyl7XHJcbiAgICBpZighY2xhc3NOYW1lc1N0cmluZylcclxuICAgICAgICB0aGlzLnNldENsYXNzTmFtZXMoW10pO1xyXG4gICAgZWxzZXtcclxuICAgICAgICB2YXIgYXJyYXkgPSBjbGFzc05hbWVzU3RyaW5nLnNwbGl0KC9cXHMrLyk7XHJcbiAgICAgICAgdmFyIGkgPSBhcnJheS5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUoaS0tKSBhcnJheVtpXSA9IGFycmF5W2ldLnRyaW0oKTtcclxuICAgICAgICB0aGlzLnNldENsYXNzTmFtZXMoYXJyYXkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblN1YkRhdGEucHJvdG90eXBlLnNldFBvc3REYXRhZmxvdyA9IGZ1bmN0aW9uKHBvc3REYXRhZmxvdyl7XHJcbiAgICB0aGlzLnBvc3REYXRhZmxvdyA9IHBvc3REYXRhZmxvdztcclxuICAgIGludmFsaWRhdGVQYXJlbnQodGhpcyk7XHJcbn07XHJcblxyXG5TdWJEYXRhLnByb3RvdHlwZS5zZXRQb3N0Q29tcHV0ZSA9IGZ1bmN0aW9uKHBvc3RDb21wdXRlKXtcclxuICAgIHRoaXMucG9zdENvbXB1dGUgPSBwb3N0Q29tcHV0ZTtcclxuICAgIGludmFsaWRhdGVQYXJlbnQodGhpcyk7XHJcbn07XHJcblxyXG5TdWJEYXRhLnByb3RvdHlwZS5zZXRQb3N0RmlsdGVyID0gZnVuY3Rpb24ocG9zdEZpbHRlcil7XHJcbiAgICB0aGlzLnBvc3RGaWx0ZXIgPSBwb3N0RmlsdGVyO1xyXG4gICAgaW52YWxpZGF0ZVBhcmVudCh0aGlzKTtcclxufTtcclxuXHJcblN1YkRhdGEucHJvdG90eXBlLnNldEluY2x1ZGVzID0gZnVuY3Rpb24oaW5jbHVkZXMpe1xyXG4gICAgdGhpcy5pbmNsdWRlcyA9IGluY2x1ZGVzO1xyXG4gICAgaW52YWxpZGF0ZVBhcmVudCh0aGlzKTtcclxufTtcclxuXHJcblN1YkRhdGEucHJvdG90eXBlLnNldE1hdGVyaWFsID0gZnVuY3Rpb24obWF0ZXJpYWwpe1xyXG4gICAgdGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xyXG4gICAgaW52YWxpZGF0ZVBhcmVudCh0aGlzKTtcclxufTtcclxuXHJcblN1YkRhdGEucHJvdG90eXBlLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uKHRyYW5zZm9ybSl7XHJcbiAgICB0aGlzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcclxuICAgIGludmFsaWRhdGVQYXJlbnQodGhpcyk7XHJcbn07XHJcblxyXG5TdWJEYXRhLnByb3RvdHlwZS5zZXRNZXNoVHlwZSA9IGZ1bmN0aW9uKG1lc2hUeXBlKXtcclxuICAgIHRoaXMubWVzaFR5cGUgPSBtZXNoVHlwZTtcclxuICAgIGludmFsaWRhdGVQYXJlbnQodGhpcyk7XHJcbn07XHJcblxyXG5TdWJEYXRhLnByb3RvdHlwZS5zZXRWaXNpYmlsaXR5ID0gZnVuY3Rpb24oaXNWaXNpYmxlKSB7XHJcbiAgICB0aGlzLnZpc2libGUgPSBpc1Zpc2libGU7XHJcbiAgICBpbnZhbGlkYXRlUGFyZW50KHRoaXMpO1xyXG59O1xyXG5mdW5jdGlvbiBpbnZhbGlkYXRlUGFyZW50KHN1YkRhdGEpe1xyXG4gICAgaWYoc3ViRGF0YS5hc3NldFBhcmVudCl7XHJcbiAgICAgICAgaW52YWxpZGF0ZUFzc2V0KHN1YkRhdGEuYXNzZXRQYXJlbnQpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gQXNzZXRSZXN1bHRcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG52YXIgQXNzZXRSZXN1bHQgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5wYXJlbnRSZXN1bHQgPSBudWxsO1xyXG4gICAgdGhpcy5uYW1lID0gbnVsbDtcclxuICAgIHRoaXMubmFtZWRFbnRyaWVzID0ge307XHJcbiAgICB0aGlzLmFsbEVudHJpZXMgPSBbXTtcclxuICAgIHRoaXMubWF0Y2hFbnRyaWVzID0gW107XHJcbiAgICB0aGlzLm5hbWVkU3ViUmVzdWx0cyA9IHt9O1xyXG4gICAgdGhpcy5hbGxTdWJSZXN1bHRzID0gW107XHJcblxyXG4gICAgdGhpcy5tYXRlcmlhbCA9IG51bGw7XHJcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG51bGw7XHJcbiAgICB0aGlzLnBpY2tGaWx0ZXIgPSBudWxsO1xyXG59O1xyXG5cclxuQXNzZXRSZXN1bHQucHJvdG90eXBlLmNvbnN0cnVjdCA9IGZ1bmN0aW9uKGFzc2V0KXtcclxuICAgIGNvbnN0cnVjdEFzc2V0VGFibGUodGhpcywgYXNzZXQpO1xyXG59O1xyXG5cclxuQXNzZXRSZXN1bHQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hbGxFbnRyaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5hbGxFbnRyaWVzW2ldLmRpc3Bvc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWxsU3ViUmVzdWx0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRoaXMuYWxsU3ViUmVzdWx0c1tpXS5kaXNwb3NlKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Bc3NldFJlc3VsdC5wcm90b3R5cGUuZ2V0RGF0YVRyZWUgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHJlY19nZXREYXRhVHJlZSh0aGlzKTtcclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBjb25zdHJ1Y3RBc3NldFRhYmxlKHRhYmxlLCBhc3NldCl7XHJcbiAgICB0YWJsZS5uYW1lID0gYXNzZXQubmFtZTtcclxuXHJcbiAgICB2YXIgc3JjQXNzZXQgPSBhc3NldC5zcmNBc3NldCwgc3JjUmVzdWx0ID0gc3JjQXNzZXQgJiYgc3JjQXNzZXQuZ2V0UmVzdWx0KCk7XHJcbiAgICBpZihzcmNSZXN1bHQpe1xyXG4gICAgICAgIGNvcHlTcmNUYWJsZSh0YWJsZSwgc3JjQXNzZXQuZ2V0UmVzdWx0KCksIGFzc2V0LnBpY2tGaWx0ZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAgICAgIHRhYmxlLnBpY2tGaWx0ZXIgPSBhc3NldC5waWNrRmlsdGVyO1xyXG5cclxuICAgIGlmKGFzc2V0Lm1hdGVyaWFsKSB0YWJsZS5tYXRlcmlhbCA9IGFzc2V0Lm1hdGVyaWFsO1xyXG4gICAgaWYoYXNzZXQudHJhbnNmb3JtKSB0YWJsZS50cmFuc2Zvcm0gPSBjb21iaW5lVHJhbnNmb3JtKHRhYmxlLnRyYW5zZm9ybSwgYXNzZXQudHJhbnNmb3JtKTtcclxuXHJcblxyXG4gICAgdmFyIHN1YkFzc2V0cyA9IGFzc2V0LnN1YkFzc2V0cztcclxuICAgIHZhciBpID0gc3ViQXNzZXRzLmxlbmd0aDtcclxuICAgIHdoaWxlKGktLSl7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHN1YkFzc2V0c1tpXS5nZXRSZXN1bHQoKTtcclxuICAgICAgICBtZXJnZVN1YkFzc2V0UmVzdWx0KHRhYmxlLCByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgdmFyIG1hdGNoQ2hpbGRyZW4gPSBbXTtcclxuICAgIHZhciBjaGlsZHJlbiA9IGFzc2V0LmNoaWxkcmVuO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICB2YXIgbmFtZSA9IGNoaWxkLm5hbWU7XHJcbiAgICAgICAgdmFyIGVudHJ5O1xyXG4gICAgICAgIGlmKGNoaWxkLm5hbWUgJiYgY2hpbGQubWF0Y2hGaWx0ZXIpe1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiQXNzZXQgZW50cnkgZGVmaW5lcyBib3RoIG5hbWUgYW5kIG1hdGNoIGF0dHJpYnV0ZS4gTWF0Y2ggYXR0cmlidXRlIHdpbGwgYmUgaWdub3JlZFwiLCBjaGlsZC5yZWZOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYobmFtZSl7XHJcbiAgICAgICAgICAgIGlmKCF0YWJsZS5uYW1lZEVudHJpZXNbbmFtZV0pe1xyXG4gICAgICAgICAgICAgICAgZW50cnkgPSBuZXcgQXNzZXRUYWJsZUVudHJ5KGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIGFwcGx5TWF0Y2hFbnRyaWVzKGVudHJ5LCB0YWJsZS5tYXRjaEVudHJpZXMpO1xyXG4gICAgICAgICAgICAgICAgdGFibGUubmFtZWRFbnRyaWVzW25hbWVdID0gZW50cnk7XHJcbiAgICAgICAgICAgICAgICB0YWJsZS5hbGxFbnRyaWVzLnB1c2goZW50cnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGVudHJ5ID0gdGFibGUubmFtZWRFbnRyaWVzW25hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGNoaWxkLm1hdGNoRmlsdGVyKXtcclxuICAgICAgICAgICAgbWF0Y2hDaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIGVudHJ5ID0gbmV3IEFzc2V0VGFibGVFbnRyeShjaGlsZCk7XHJcbiAgICAgICAgICAgIGFwcGx5TWF0Y2hFbnRyaWVzKGVudHJ5LCB0YWJsZS5tYXRjaEVudHJpZXMpO1xyXG4gICAgICAgICAgICB0YWJsZS5hbGxFbnRyaWVzLnB1c2goZW50cnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbnRyeS5wdXNoUG9zdEVudHJ5KGNoaWxkKTtcclxuICAgIH1cclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtYXRjaENoaWxkcmVuLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB2YXIgY2hpbGQgPSBtYXRjaENoaWxkcmVuW2ldO1xyXG4gICAgICAgIHZhciBtYXRjaEVudHJ5ID0ge2ZpbHRlcjogY2hpbGQubWF0Y2hGaWx0ZXIsIHN1YmRhdGE6IGNoaWxkfTtcclxuICAgICAgICB0YWJsZS5tYXRjaEVudHJpZXMucHVzaChtYXRjaEVudHJ5KTtcclxuICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgdGFibGUuYWxsRW50cmllcy5sZW5ndGg7ICsrail7XHJcbiAgICAgICAgICAgIGFwcGx5TWF0Y2hFbnRyeSh0YWJsZS5hbGxFbnRyaWVzW2pdLCBtYXRjaEVudHJ5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5TWF0Y2hFbnRyaWVzKGRlc3RFbnRyeSwgbWF0Y2hFbnRyaWVzKXtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtYXRjaEVudHJpZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIGFwcGx5TWF0Y2hFbnRyeShkZXN0RW50cnksIG1hdGNoRW50cmllc1tpXSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5TWF0Y2hFbnRyeShkZXN0RW50cnksIG1hdGNoRW50cnkpe1xyXG4gICAgdmFyIGNoaWxkID0gbWF0Y2hFbnRyeS5zdWJkYXRhO1xyXG4gICAgaWYoY2hpbGQuaXNNZXNoKCkgPT0gZGVzdEVudHJ5LmlzTWVzaCgpICYmIG1hdGNoRW50cnkuZmlsdGVyLmNoZWNrKGRlc3RFbnRyeSkpe1xyXG4gICAgICAgIGRlc3RFbnRyeS5wdXNoUG9zdEVudHJ5KGNoaWxkKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGNvcHlTcmNUYWJsZSh0YWJsZSwgc3JjVGFibGUsIHBpY2tGaWx0ZXIpe1xyXG5cclxuICAgIGlmKHNyY1RhYmxlLm1hdGNoRW50cmllcy5sZW5ndGggPiAwKXtcclxuICAgICAgICB2YXIgaSA9IHRhYmxlLmFsbEVudHJpZXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlKGktLSl7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRhYmxlLmFsbEVudHJpZXNbaV07XHJcbiAgICAgICAgICAgIGlmKCFlbnRyeS5uYW1lIHx8ICFzcmNUYWJsZS5uYW1lZEVudHJpZXNbZW50cnkubmFtZV0pe1xyXG4gICAgICAgICAgICAgICAgYXBwbHlNYXRjaEVudHJpZXMoZW50cnksIHNyY1RhYmxlLm1hdGNoRW50cmllcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGkgPSBzcmNUYWJsZS5hbGxFbnRyaWVzLmxlbmd0aDtcclxuICAgIHdoaWxlKGktLSl7XHJcbiAgICAgICAgdmFyIHNyY0VudHJ5ID0gc3JjVGFibGUuYWxsRW50cmllc1tpXTtcclxuICAgICAgICB2YXIgZGVzdEVudHJ5LCBuZXdseUNyZWF0ZWQgPSBmYWxzZTtcclxuICAgICAgICBpZihzcmNFbnRyeS5uYW1lICYmIHRhYmxlLm5hbWVkRW50cmllc1tzcmNFbnRyeS5uYW1lXSl7XHJcbiAgICAgICAgICAgIGRlc3RFbnRyeSA9IHRhYmxlLm5hbWVkRW50cmllc1tzcmNFbnRyeS5uYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgZGVzdEVudHJ5ID0gbmV3IEFzc2V0VGFibGVFbnRyeSgpO1xyXG4gICAgICAgICAgICBuZXdseUNyZWF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0YWJsZS5hbGxFbnRyaWVzLnB1c2goZGVzdEVudHJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVzdEVudHJ5LnB1c2hUYWJsZUVudHJ5KHNyY0VudHJ5KTtcclxuICAgICAgICBpZihuZXdseUNyZWF0ZWQpXHJcbiAgICAgICAgICAgIGFwcGx5TWF0Y2hFbnRyaWVzKGRlc3RFbnRyeSwgdGFibGUubWF0Y2hFbnRyaWVzKTtcclxuXHJcbiAgICAgICAgaWYoZGVzdEVudHJ5Lm5hbWUpIHRhYmxlLm5hbWVkRW50cmllc1tkZXN0RW50cnkubmFtZV0gPSBkZXN0RW50cnk7XHJcbiAgICB9XHJcblxyXG4gICAgdGFibGUubWF0Y2hFbnRyaWVzLnB1c2guYXBwbHkodGFibGUubWF0Y2hFbnRyaWVzLCBzcmNUYWJsZS5tYXRjaEVudHJpZXMpO1xyXG5cclxuXHJcbiAgICB2YXIgaSA9IHNyY1RhYmxlLmFsbFN1YlJlc3VsdHMubGVuZ3RoO1xyXG4gICAgd2hpbGUoaS0tKXtcclxuICAgICAgICBtZXJnZVN1YkFzc2V0UmVzdWx0KHRhYmxlLCBzcmNUYWJsZS5hbGxTdWJSZXN1bHRzW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICBpZihwaWNrRmlsdGVyICYmIHNyY1RhYmxlLnBpY2tGaWx0ZXIpe1xyXG4gICAgICAgIHRhYmxlLnBpY2tGaWx0ZXIgPSBuZXcgQXNzZXRQaWNrRmlsdGVyKCk7XHJcbiAgICAgICAgdGFibGUucGlja0ZpbHRlci5pbnRlcnNlY3Rpb24ocGlja0ZpbHRlciwgc3JjVGFibGUucGlja0ZpbHRlcik7XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICAgIHRhYmxlLnBpY2tGaWx0ZXIgPSBwaWNrRmlsdGVyIHx8IHNyY1RhYmxlLnBpY2tGaWx0ZXI7XHJcbiAgICB9XHJcbiAgICBpZihzcmNUYWJsZS5tYXRlcmlhbCkgdGFibGUubWF0ZXJpYWwgPSBzcmNUYWJsZS5tYXRlcmlhbDtcclxuICAgIGlmKHNyY1RhYmxlLnRyYW5zZm9ybSkgdGFibGUudHJhbnNmb3JtID0gY29tYmluZVRyYW5zZm9ybSh0YWJsZS50cmFuc2Zvcm0sIHNyY1RhYmxlLnRyYW5zZm9ybSk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBtZXJnZVN1YkFzc2V0UmVzdWx0KHRhYmxlLCBzcmNTdWJUYWJsZSl7XHJcbiAgICB2YXIgZGVzdFN1YlRhYmxlO1xyXG4gICAgaWYoc3JjU3ViVGFibGUubmFtZSAmJiB0YWJsZS5uYW1lZFN1YlJlc3VsdHNbc3JjU3ViVGFibGUubmFtZV0pe1xyXG4gICAgICAgIGRlc3RTdWJUYWJsZSA9IHRhYmxlLm5hbWVkU3ViUmVzdWx0c1tzcmNTdWJUYWJsZS5uYW1lXTtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgICAgZGVzdFN1YlRhYmxlID0gbmV3IEFzc2V0UmVzdWx0KCk7XHJcbiAgICAgICAgZGVzdFN1YlRhYmxlLnBhcmVudFJlc3VsdCA9IHRhYmxlO1xyXG4gICAgICAgIGRlc3RTdWJUYWJsZS5uYW1lID0gc3JjU3ViVGFibGUubmFtZTtcclxuICAgICAgICB0YWJsZS5hbGxTdWJSZXN1bHRzLnB1c2goZGVzdFN1YlRhYmxlKTtcclxuICAgICAgICBpZihkZXN0U3ViVGFibGUubmFtZSkgdGFibGUubmFtZWRTdWJSZXN1bHRzW2Rlc3RTdWJUYWJsZS5uYW1lXSA9IGRlc3RTdWJUYWJsZTtcclxuICAgIH1cclxuICAgIGNvcHlTcmNUYWJsZShkZXN0U3ViVGFibGUsIHNyY1N1YlRhYmxlLCBkZXN0U3ViVGFibGUucGlja0ZpbHRlcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlY19nZXREYXRhVHJlZSh0YWJsZSl7XHJcbiAgICB2YXIgbm9kZSA9IHtcclxuICAgICAgICBtZXNoZXM6IFtdLFxyXG4gICAgICAgIGdyb3VwczogW10sXHJcbiAgICAgICAgdHJhbnNmb3JtOiB0YWJsZS50cmFuc2Zvcm0sXHJcbiAgICAgICAgbWF0ZXJpYWw6IHRhYmxlLm1hdGVyaWFsLFxyXG4gICAgICAgIHBvc3RUcmFuc2Zvcm1YZmxvd05vZGU6IG51bGxcclxuICAgIH07XHJcblxyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRhYmxlLmFsbEVudHJpZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRhYmxlLmFsbEVudHJpZXNbaV07XHJcbiAgICAgICAgaWYoZW50cnkubWVzaFR5cGUgJiYgKCF0YWJsZS5waWNrRmlsdGVyIHx8IHRhYmxlLnBpY2tGaWx0ZXIuY2hlY2soZW50cnkpKSApe1xyXG4gICAgICAgICAgICB1cGRhdGVBY2N1bXVsYXRlZE5vZGUodGFibGUsIGVudHJ5KTtcclxuICAgICAgICAgICAgbm9kZS5tZXNoZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB4Zmxvd05vZGU6IGVudHJ5LmFjY3VtdWxhdGVkWGZsb3dOb2RlLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogZW50cnkubWVzaFR5cGUsXHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbDogZW50cnkubWF0ZXJpYWwsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGVudHJ5LnRyYW5zZm9ybSxcclxuICAgICAgICAgICAgICAgIHZpc2libGU6IGVudHJ5LnZpc2libGUsXHJcbiAgICAgICAgICAgICAgICByZWZOb2RlOiBlbnRyeS5yZWZOb2RlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBwb3N0VHJhbnNmb3JtRW50cnkgPSB0YWJsZS5uYW1lZEVudHJpZXNbXCJfcG9zdFRyYW5zZm9ybVwiXTtcclxuICAgIGlmKHBvc3RUcmFuc2Zvcm1FbnRyeSl7XHJcbiAgICAgICAgdXBkYXRlQWNjdW11bGF0ZWROb2RlKHRhYmxlLCBwb3N0VHJhbnNmb3JtRW50cnkpO1xyXG4gICAgICAgIG5vZGUucG9zdFRyYW5zZm9ybVhmbG93Tm9kZSA9IHBvc3RUcmFuc2Zvcm1FbnRyeS5hY2N1bXVsYXRlZFhmbG93Tm9kZTtcclxuICAgIH1cclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0YWJsZS5hbGxTdWJSZXN1bHRzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB2YXIgc3ViTm9kZSA9IHJlY19nZXREYXRhVHJlZSh0YWJsZS5hbGxTdWJSZXN1bHRzW2ldKTtcclxuICAgICAgICBub2RlLmdyb3Vwcy5wdXNoKHN1Yk5vZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vZGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUFjY3VtdWxhdGVkTm9kZSh0YWJsZSwgZW50cnkpe1xyXG4gICAgaWYoIWVudHJ5Lm91dE9mU3luYylcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgaWYoZW50cnkuYWNjdW11bGF0ZWRYZmxvd05vZGUpe1xyXG4gICAgICAgIGVudHJ5LmFjY3VtdWxhdGVkWGZsb3dOb2RlLnNldENvbXB1dGUoXCJcIik7XHJcbiAgICAgICAgZW50cnkuYWNjdW11bGF0ZWRYZmxvd05vZGUuc2V0RmlsdGVyKFwiXCIpO1xyXG4gICAgICAgIGVudHJ5LmFjY3VtdWxhdGVkWGZsb3dOb2RlLmRhdGFmbG93Tm9kZSA9IG51bGw7XHJcbiAgICAgICAgZW50cnkuYWNjdW11bGF0ZWRYZmxvd05vZGUuc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICAgIGVudHJ5LmFjY3VtdWxhdGVkWGZsb3dOb2RlID0gbmV3IEFzc2V0RGF0YU5vZGUoZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkYXRhTm9kZSA9IGVudHJ5LnBvc3RRdWV1ZS5sZW5ndGggPT0gMSA/IGVudHJ5LmFjY3VtdWxhdGVkWGZsb3dOb2RlIDogbmV3IEFzc2V0RGF0YU5vZGUoZmFsc2UpO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGVudHJ5LnBvc3RRdWV1ZS5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdmFyIGluY2x1ZGVzID0gZW50cnkucG9zdFF1ZXVlW2ldLmluY2x1ZGVzO1xyXG4gICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBpbmNsdWRlcy5sZW5ndGg7ICsrail7XHJcbiAgICAgICAgICAgIHZhciBhZGRFbnRyeSA9IGdldEluY2x1ZGVFbnRyeSh0YWJsZSwgaW5jbHVkZXNbal0pO1xyXG4gICAgICAgICAgICBkYXRhTm9kZS5hcHBlbmRDaGlsZChhZGRFbnRyeS5hY2N1bXVsYXRlZFhmbG93Tm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGVudHJ5LnBvc3RRdWV1ZVtpXS54Zmxvd05vZGUpXHJcbiAgICAgICAgICAgIGRhdGFOb2RlLmFwcGVuZENoaWxkKGVudHJ5LnBvc3RRdWV1ZVtpXS54Zmxvd05vZGUpO1xyXG4gICAgfVxyXG4gICAgdmFyIG5vZGUgPSBkYXRhTm9kZSwgcGFyZW50Tm9kZSA9IG51bGw7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZW50cnkucG9zdFF1ZXVlLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB2YXIgcG9zdEVudHJ5ID0gZW50cnkucG9zdFF1ZXVlW2ldO1xyXG4gICAgICAgIGlmKCFub2RlKSBub2RlID0gKGkgPT0gZW50cnkucG9zdFF1ZXVlLmxlbmd0aCAtIDEgPyBlbnRyeS5hY2N1bXVsYXRlZFhmbG93Tm9kZSA6IG5ldyBBc3NldERhdGFOb2RlKGZhbHNlKSk7XHJcbiAgICAgICAgbm9kZS5zZXRDb21wdXRlKHBvc3RFbnRyeS5jb21wdXRlKTtcclxuICAgICAgICBub2RlLnNldEZpbHRlcihwb3N0RW50cnkuZmlsdGVyKTtcclxuICAgICAgICBub2RlLmRhdGFmbG93Tm9kZSA9IHBvc3RFbnRyeS5kYXRhZmxvdztcclxuICAgICAgICBub2RlLnNldExvYWRpbmcocG9zdEVudHJ5LmRhdGFmbG93TG9hZGluZyk7XHJcbiAgICAgICAgaWYocGFyZW50Tm9kZSkgbm9kZS5hcHBlbmRDaGlsZChwYXJlbnROb2RlKTtcclxuICAgICAgICBwYXJlbnROb2RlID0gbm9kZTtcclxuICAgICAgICBub2RlID0gbnVsbDtcclxuICAgIH1cclxuICAgIGVudHJ5Lm91dE9mU3luYyA9IGZhbHNlO1xyXG59XHJcblxyXG5cclxudmFyIGNfYWNjdW1fZW50cmllcyA9IFtdLFxyXG4gICAgY19hY2N1bV9uYW1lcyA9IFtdO1xyXG5cclxuZnVuY3Rpb24gZ2V0SW5jbHVkZUVudHJ5KHRhYmxlLCBpbmNsdWRlU3RyaW5nKXtcclxuICAgIHZhciBzZWdtZW50cyA9IGluY2x1ZGVTdHJpbmcuc3BsaXQoXCIuXCIpO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aCAtMTsgKytpKXtcclxuICAgICAgICB2YXIgc2VnID0gc2VnbWVudHNbaV07XHJcbiAgICAgICAgaWYoc2VnID09IFwicGFyZW50XCIpe1xyXG4gICAgICAgICAgICBpZighdGFibGUucGFyZW50UmVzdWx0KVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jbHVkZXMgZW50cnkgJ1wiICsgaW5jbHVkZVN0cmluZyArIFwiJyAodG9rZW4gXCIrIGkgK1wiKSBhY2Nlc3NlcyBub24gZXhpc3RlbnQgcGFyZW50LlwiKTtcclxuICAgICAgICAgICAgdGFibGUgPSB0YWJsZS5wYXJlbnRSZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIGlmKCF0YWJsZS5uYW1lZFN1YlJlc3VsdHNbc2VnXSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY2x1ZGVzIGVudHJ5ICdcIiArIGluY2x1ZGVTdHJpbmcgKyBcIicgKHRva2VuIFwiKyBpICtcIikgYWNjZXNzZXMgbm9uIGV4aXN0ZW50IHN1YiByZXN1bHQgJ1wiICsgc2VnICsgXCInXCIpO1xyXG4gICAgICAgICAgICB0YWJsZSA9IHRhYmxlLm5hbWVkU3ViUmVzdWx0c1tzZWddO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBlbnRyeUtleSA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgdmFyIGVudHJ5ID0gdGFibGUubmFtZWRFbnRyaWVzW2VudHJ5S2V5XTtcclxuICAgIGlmKCFlbnRyeSl7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jbHVkZXMgZW50cnkgJ1wiICsgaW5jbHVkZVN0cmluZyArIFwiJyBhY2Nlc3NlcyBub24gZXhpc3RlbnQgYXNzZXQgZW50cnkgJ1wiICsgZW50cnlLZXkgKyBcIidcIiApO1xyXG4gICAgfVxyXG5cclxuICAgIGNfYWNjdW1fbmFtZXMucHVzaChpbmNsdWRlU3RyaW5nKTtcclxuICAgIGlmKGNfYWNjdW1fZW50cmllcy5pbmRleE9mKGVudHJ5KSAhPSAtMSl7XHJcbiAgICAgICAgdmFyIHBhdGggPSBjX2FjY3VtX25hbWVzLmpvaW4oXCIgPiBcIik7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVjdXJzaXZlIGluY2x1ZGUgZGVwZW5kZW5jaWVzIGRldGVjdGVkOiBcIiArIHBhdGgpO1xyXG4gICAgfVxyXG4gICAgY19hY2N1bV9lbnRyaWVzLnB1c2goZW50cnkpO1xyXG5cclxuICAgIHVwZGF0ZUFjY3VtdWxhdGVkTm9kZSh0YWJsZSwgZW50cnkpO1xyXG4gICAgY19hY2N1bV9lbnRyaWVzLnBvcCgpO1xyXG4gICAgY19hY2N1bV9uYW1lcy5wb3AoKTtcclxuICAgIHJldHVybiBlbnRyeTtcclxufVxyXG5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gQXNzZXRUYWJsZUVudHJ5IChzdWJEYXRhKXtcclxuICAgIHRoaXMubmFtZSA9IG51bGw7XHJcbiAgICB0aGlzLmNsYXNzTmFtZXMgPSBbXTtcclxuICAgIHRoaXMubWVzaFR5cGUgPSBudWxsO1xyXG5cclxuICAgIHRoaXMucG9zdFF1ZXVlID0gW107XHJcbiAgICB0aGlzLm1hdGVyaWFsID0gbnVsbDtcclxuICAgIHRoaXMudHJhbnNmb3JtID0gbnVsbDtcclxuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5hY2N1bXVsYXRlZFhmbG93Tm9kZSA9IG51bGw7XHJcbiAgICB0aGlzLm91dE9mU3luYyA9IHRydWU7XHJcbiAgICB0aGlzLnJlZk5vZGUgPSBudWxsO1xyXG4gICAgaWYoc3ViRGF0YSl7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gc3ViRGF0YS5uYW1lO1xyXG4gICAgICAgIFNldC5hZGQodGhpcy5jbGFzc05hbWVzLCBzdWJEYXRhLmNsYXNzTmFtZXMpO1xyXG4gICAgfVxyXG59XHJcblxyXG5Bc3NldFRhYmxlRW50cnkucHJvdG90eXBlLmlzTWVzaCA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gISF0aGlzLm1lc2hUeXBlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsZWFycyBjaGlsZDwtPnBhcmVudCByZWxhdGlvbnNoaXBzIGZvciBhbGwgWGZsb3cgbm9kZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZm9yIHRoaXMgQXNzZXQgaW5zdGFuY2Ugc3BlY2lmaWNhbGx5IChlZyB0aHJvdWdoIG92ZXJyaWRlcylcclxuICovXHJcbkFzc2V0VGFibGVFbnRyeS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgY2xlYXJBc3NldFJlbGF0ZWRDaGlsZHJlbih0aGlzLmFjY3VtdWxhdGVkWGZsb3dOb2RlKTtcclxuICAgIHRoaXMuYWNjdW11bGF0ZWRYZmxvd05vZGUuY2xlYXIoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGNsZWFycyBwYXJlbnQtPmNoaWxkIGFuZCBkYXRhRmxvd05vZGUgcmVsYXRpb25zaGlwcyBmb3IgYWxsIHhmbG93IG5vZGVzXHJcbiAqIHRoYXQgd2VyZSBnZW5lcmF0ZWQgZm9yIHRoZSBBc3NldFRhYmxlRW50cnkgdGhhdCBpdCdzIGNhbGxlZCBmcm9tIGluaXRpYWxseS4gSXQgd29uJ3QgY2xlYXJcclxuICogcmVsYXRpb25zaGlwcyBmb3IgYW55IG5vcm1hbCBEYXRhTm9kZXMgdGhhdCBhcmUgcGFydCBvZiBub24tYXNzZXQtcmVsYXRlZCBYZmxvdyBncmFwaHMgKGllLiBkYXRhZmxvdyBncmFwaHMpXHJcbiAqIEBwYXJhbSBkYXRhTm9kZVxyXG4gKi9cclxuZnVuY3Rpb24gY2xlYXJBc3NldFJlbGF0ZWRDaGlsZHJlbihkYXRhTm9kZSkge1xyXG4gICAgaWYgKGRhdGFOb2RlLl9jaGlsZHJlbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuOyAvL0lucHV0IGxlYWYgbm9kZSwgbm90aGluZyB0byBkbyBoZXJlXHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFOb2RlLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNsZWFyQXNzZXRSZWxhdGVkQ2hpbGRyZW4oZGF0YU5vZGUuX2NoaWxkcmVuW2ldKTtcclxuICAgIH1cclxuICAgIGlmIChkYXRhTm9kZS5pc0Fzc2V0RGF0YU5vZGUpIHtcclxuICAgICAgICBkYXRhTm9kZS5jbGVhcigpO1xyXG4gICAgICAgIGRhdGFOb2RlLl9jaGFubmVsTm9kZS5zZXRTdHJ1Y3R1cmVPdXRPZlN5bmMoKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbkFzc2V0VGFibGVFbnRyeS5wcm90b3R5cGUucHVzaFRhYmxlRW50cnkgPSBmdW5jdGlvbihzcmNFbnRyeSl7XHJcbiAgICB0aGlzLm5hbWUgPSBzcmNFbnRyeS5uYW1lO1xyXG4gICAgU2V0LmFkZCh0aGlzLmNsYXNzTmFtZXMsIHNyY0VudHJ5LmNsYXNzTmFtZXMpO1xyXG4gICAgaWYoc3JjRW50cnkubWVzaFR5cGUpIHRoaXMubWVzaFR5cGUgPSBzcmNFbnRyeS5tZXNoVHlwZTtcclxuICAgIGlmKHNyY0VudHJ5LnZpc2libGUgIT09IHVuZGVmaW5lZCkgdGhpcy52aXNpYmxlID0gc3JjRW50cnkudmlzaWJsZTtcclxuXHJcbiAgICBpZihzcmNFbnRyeS50cmFuc2Zvcm0pIHRoaXMudHJhbnNmb3JtID0gY29tYmluZVRyYW5zZm9ybSh0aGlzLnRyYW5zZm9ybSwgc3JjRW50cnkudHJhbnNmb3JtKTtcclxuICAgIGlmKHNyY0VudHJ5Lm1hdGVyaWFsKSB0aGlzLm1hdGVyaWFsID0gc3JjRW50cnkubWF0ZXJpYWw7XHJcblxyXG4gICAgdGhpcy5wb3N0UXVldWUucHVzaC5hcHBseSh0aGlzLnBvc3RRdWV1ZSwgc3JjRW50cnkucG9zdFF1ZXVlKTtcclxufTtcclxuXHJcblxyXG5Bc3NldFRhYmxlRW50cnkucHJvdG90eXBlLnB1c2hQb3N0RW50cnkgPSBmdW5jdGlvbihzdWJEYXRhKXtcclxuICAgIHRoaXMubmFtZSA9IHN1YkRhdGEubmFtZTtcclxuICAgIHRoaXMucG9zdFF1ZXVlLnB1c2goe1xyXG4gICAgICAgIGRhdGFmbG93OiBzdWJEYXRhLnBvc3REYXRhZmxvdyxcclxuICAgICAgICBkYXRhZmxvd0xvYWRpbmc6IHN1YkRhdGEubG9hZGluZyxcclxuICAgICAgICBjb21wdXRlOiBzdWJEYXRhLnBvc3RDb21wdXRlLFxyXG4gICAgICAgIGZpbHRlcjogc3ViRGF0YS5wb3N0RmlsdGVyLFxyXG4gICAgICAgIGluY2x1ZGVzOiBzdWJEYXRhLmluY2x1ZGVzLFxyXG4gICAgICAgIHhmbG93Tm9kZTogc3ViRGF0YS54Zmxvd05vZGVJblxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnJlZk5vZGUgPSBzdWJEYXRhLnJlZk5vZGU7XHJcbiAgICB0aGlzLmFjY3VtdWxhdGVkWGZsb3dOb2RlID0gc3ViRGF0YS54Zmxvd05vZGVPdXQ7XHJcbiAgICBTZXQuYWRkKHRoaXMuY2xhc3NOYW1lcywgc3ViRGF0YS5jbGFzc05hbWVzKTtcclxuICAgIGlmKHN1YkRhdGEubWVzaFR5cGUpIHRoaXMubWVzaFR5cGUgPSBzdWJEYXRhLm1lc2hUeXBlO1xyXG4gICAgaWYoc3ViRGF0YS5tYXRlcmlhbCkgdGhpcy5tYXRlcmlhbCA9IHN1YkRhdGEubWF0ZXJpYWw7XHJcbiAgICBpZihzdWJEYXRhLnZpc2libGUgIT09IHVuZGVmaW5lZCkgdGhpcy52aXNpYmxlID0gc3ViRGF0YS52aXNpYmxlO1xyXG4gICAgaWYoc3ViRGF0YS50cmFuc2Zvcm0pIHRoaXMudHJhbnNmb3JtID0gY29tYmluZVRyYW5zZm9ybSh0aGlzLnRyYW5zZm9ybSwgc3ViRGF0YS50cmFuc2Zvcm0pO1xyXG59O1xyXG5cclxuXHJcbmZ1bmN0aW9uIGNvbWJpbmVUcmFuc2Zvcm0ob2xkVHJhbnNmb3JtLCBuZXdUcmFuc2Zvcm0pe1xyXG4gICAgLy8gVE9ETzogQmV0dGVyIG11bHRpcGx5IHRyYW5zZm9ybWF0aW9ucyBoZXJlXHJcbiAgICByZXR1cm4gbmV3VHJhbnNmb3JtO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gQXNzZXRQaWNrRmlsdGVyKCl7XHJcbiAgICB0aGlzLmFsbCA9IGZhbHNlO1xyXG4gICAgdGhpcy5uYW1lcyA9IFtdO1xyXG4gICAgdGhpcy5jbGFzc05hbWVzID0gW107XHJcbn1cclxuXHJcbkFzc2V0UGlja0ZpbHRlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihzdHJpbmcpe1xyXG4gICAgdmFyIGVudHJpZXMgPSBzdHJpbmcuc3BsaXQoXCIsXCIpO1xyXG4gICAgdmFyIGkgPSBlbnRyaWVzLmxlbmd0aDtcclxuICAgIHdoaWxlKGktLSl7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpXS50cmltKCk7XHJcbiAgICAgICAgaWYoZW50cnkgPT0gXCIqXCIpe1xyXG4gICAgICAgICAgICB0aGlzLmFsbCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZW50cnkuaW5kZXhPZihcIi5cIikgPT0gMCl7XHJcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWVzID0gZW50cnkuc3BsaXQoXCIuXCIpO1xyXG4gICAgICAgICAgICB2YXIgaiA9IGNsYXNzTmFtZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZShqLS0pe1xyXG4gICAgICAgICAgICAgICAgaWYoIWNsYXNzTmFtZXNbal0udHJpbSgpKVxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMuc3BsaWNlKGosMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWVzLnB1c2goY2xhc3NOYW1lcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIFNldC5hZGQodGhpcy5uYW1lcywgZW50cnkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbkFzc2V0UGlja0ZpbHRlci5wcm90b3R5cGUuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oc2V0QSwgc2V0Qil7XHJcbiAgICBTZXQuaW50ZXJzZWN0aW9uKHRoaXMubmFtZXMsIHNldEEubmFtZXMsIHNldEIubmFtZXMpO1xyXG4gICAgU2V0LmludGVyc2VjdGlvbih0aGlzLmNsYXNzTmFtZXMsIHNldEEuY2xhc3NOYW1lcywgc2V0Qi5jbGFzc05hbWVzKTtcclxufTtcclxuXHJcbkFzc2V0UGlja0ZpbHRlci5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbihlbnRyeSl7XHJcbiAgICBpZih0aGlzLmFsbClcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGlmKGVudHJ5LmNsYXNzTmFtZXMubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgdmFyIGkgPSB0aGlzLmNsYXNzTmFtZXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlKGktLSl7XHJcbiAgICAgICAgICAgIGlmKFNldC5pc1N1YnNldCh0aGlzLmNsYXNzTmFtZXNbaV0sIGVudHJ5LmNsYXNzTmFtZXMpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIChlbnRyeS5uYW1lICYmIHRoaXMubmFtZXMuaW5kZXhPZihlbnRyeS5uYW1lKSAhPSAtMSk7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBpcyBqdXN0IGEgc21hbGwgd3JhcHBlciB0byBpZGVudGlmeSBYZmxvdyBub2RlcyB0aGF0IHdlcmUgY3JlYXRlZCBieSBhbiBBc3NldCwgZWcgYXMgcGFydCBvZiBvdmVycmlkZXNcclxuICogdGhhdCBuZWVkIHRvIGJlIGNsZWFuZWQgdXAgbGF0ZXIgaWYgdGhlIGNvcnJlc3BvbmRpbmcgbW9kZWwgdGFnIGlzIGRlc3Ryb3llZFxyXG4gKiBAcGFyYW0gaXNEYXRhRmxvd1xyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBBc3NldERhdGFOb2RlID0gZnVuY3Rpb24oaXNEYXRhRmxvdykge1xyXG4gICAgRGF0YU5vZGUuY2FsbCh0aGlzLCBpc0RhdGFGbG93KTtcclxuICAgIHRoaXMuaXNBc3NldERhdGFOb2RlID0gdHJ1ZTtcclxufTtcclxuXHJcbkJhc2UuY3JlYXRlQ2xhc3MoQXNzZXREYXRhTm9kZSwgRGF0YU5vZGUpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBBc3NldDogQXNzZXQsXHJcbiAgICBTdWJEYXRhOiBTdWJEYXRhLFxyXG4gICAgQXNzZXRSZXN1bHQ6IEFzc2V0UmVzdWx0XHJcbn07XHJcbiIsInZhciBFdmVudHMgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlL25vdGlmaWNhdGlvbi5qc1wiKTtcclxudmFyIGNvbmZpZyA9IHJlcXVpcmUoXCIuLi9pbnRlcmZhY2UvZWxlbWVudHMuanNcIikuY29uZmlnO1xyXG52YXIgUmVzb3VyY2UgPSByZXF1aXJlKFwiLi4vcmVzb3VyY2VcIik7XHJcblxyXG4vKipcclxuICogQSBub3JtYWwgYWRhcHRlciB0aGF0IGRvZXNuJ3QgbmVlZCB0byBiZSBjb25uZWN0ZWQgdG8gYSBET00gbm9kZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtYTUwzRC5iYXNlLkFkYXB0ZXJGYWN0b3J5fSBmYWN0b3J5IC0gdGhlIGZhY3RvcnkgdGhpcyBhZGFwdGVyIHdhcyBjcmVhdGVkIGZyb21cclxuICovXHJcbnZhciBBZGFwdGVyID0gZnVuY3Rpb24oZmFjdG9yeSkge1xyXG4gICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb25uZWN0IGFuIGFkYXB0ZXJIYW5kbGUgdG8gYSBjZXJ0YWluIGtleS5cclxuICogVGhpcyB3aWxsIGVuYWJsZSB0aGUgQ29ubmVjdGVkQWRhcHRlck5vdGlmY2F0aW9ucyBmb3Igbm90aWZ5Q2hhbmdlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIHRoZSBrZXkgdGhhdCB3aWxsIGFsc28gYmUgcHJvdmlkZWQgaW4gY29ubmVjdEFkYXB0ZXJDaGFuZ2VkIGNhbGxiYWNrXHJcbiAqIEBwYXJhbSB7WE1MM0QuYmFzZS5BZGFwdGVySGFuZGxlfSBhZGFwdGVySGFuZGxlIGhhbmRsZSBvZiBhZGFwdGVyIHRvIGJlIGFkZGVkXHJcbiAqL1xyXG5BZGFwdGVyLnByb3RvdHlwZS5jb25uZWN0QWRhcHRlckhhbmRsZSA9IGZ1bmN0aW9uKGtleSwgYWRhcHRlckhhbmRsZSkge1xyXG4gICAgaWYgKCF0aGlzLmNvbm5lY3RlZEFkYXB0ZXJIYW5kbGVzKSB7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2JpbmRlZEFkYXB0ZXJIYW5kbGVDYWxsYmFjayA9IGFkYXB0ZXJIYW5kbGVDYWxsYmFjay5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZGlzY29ubmVjdEFkYXB0ZXJIYW5kbGUoa2V5KTtcclxuXHJcbiAgICBpZiAoYWRhcHRlckhhbmRsZSkge1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkQWRhcHRlckhhbmRsZXNba2V5XSA9IGFkYXB0ZXJIYW5kbGU7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlc1trZXldLmFkZExpc3RlbmVyKHRoaXMuX2JpbmRlZEFkYXB0ZXJIYW5kbGVDYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICAgICAgZGVsZXRlIHRoaXMuY29ubmVjdGVkQWRhcHRlckhhbmRsZXNba2V5XTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogRGlzY29ubmVjdHMgdGhlIGFkYXB0ZXIgaGFuZGxlIGZyb20gdGhlIGdpdmVuIGtleS5cclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIHRoZSBrZXkgdGhhdCB3YXMgcHJvdmlkZWQgd2hlbiB0aGlzIGFkYXB0ZXIgaGFuZGxlIHdhcyBjb25uZWN0ZWRcclxuICovXHJcbkFkYXB0ZXIucHJvdG90eXBlLmRpc2Nvbm5lY3RBZGFwdGVySGFuZGxlID0gZnVuY3Rpb24oa2V5KSB7XHJcbiAgICBpZiAodGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlcyAmJiB0aGlzLmNvbm5lY3RlZEFkYXB0ZXJIYW5kbGVzW2tleV0pIHtcclxuICAgICAgICB0aGlzLmNvbm5lY3RlZEFkYXB0ZXJIYW5kbGVzW2tleV0ucmVtb3ZlTGlzdGVuZXIodGhpcy5fYmluZGVkQWRhcHRlckhhbmRsZUNhbGxiYWNrKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlc1trZXldO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERpc2Nvbm5lY3RzIGFsbCBhZGFwdGVyIGhhbmRsZXMuXHJcbiAqL1xyXG5BZGFwdGVyLnByb3RvdHlwZS5jbGVhckFkYXB0ZXJIYW5kbGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICBmb3IgKHZhciBpIGluIHRoaXMuY29ubmVjdGVkQWRhcHRlckhhbmRsZXMpIHtcclxuICAgICAgICB0aGlzLmNvbm5lY3RlZEFkYXB0ZXJIYW5kbGVzW2ldLnJlbW92ZUxpc3RlbmVyKHRoaXMuX2JpbmRlZEFkYXB0ZXJIYW5kbGVDYWxsYmFjayk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlcyA9IG51bGw7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBjb25uZWN0ZWQgQWRhcHRlckhhbmRsZSBvZiBhIGNlcnRhaW4ga2V5LlxyXG4gKiBUaGlzIHdpbGwgb25seSByZXR1cm4gQWRhcHRlckhhbmRsZXMgcHJldmlvdXNseSBhZGRlZCB2aWEgY29ubmVjdEFkYXB0ZXJIYW5kbGVcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxyXG4gKiBAcmV0dXJuIHs/QWRhcHRlckhhbmRsZX0gdGhlIGFkYXB0ZXIgb2YgdGhhdCBrZXksIG9yIG51bGwgaWYgbm90IGF2YWlsYWJsZVxyXG4gKi9cclxuQWRhcHRlci5wcm90b3R5cGUuZ2V0Q29ubmVjdGVkQWRhcHRlckhhbmRsZSA9IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGVkQWRhcHRlckhhbmRsZXMgJiYgdGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlc1trZXldO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgY29ubmVjdGVkIGFkYXB0ZXIgb2YgYSBjZXJ0YWluIGtleS5cclxuICogVGhpcyB3aWxsIG9ubHkgcmV0dXJuIGFkYXB0ZXJzIG9mIEFkYXB0ZXJIYW5kbGVzIHByZXZpb3VzbHkgYWRkZWQgdmlhIGNvbm5lY3RBZGFwdGVyXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcclxuICogQHJldHVybiB7P1hNTDNELmJhc2UuQWRhcHRlcn0gdGhlIGFkYXB0ZXIgb2YgdGhhdCBrZXksIG9yIG51bGwgaWYgbm90IGF2YWlsYWJsZVxyXG4gKi9cclxuQWRhcHRlci5wcm90b3R5cGUuZ2V0Q29ubmVjdGVkQWRhcHRlciA9IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgdmFyIGhhbmRsZSA9IHRoaXMuZ2V0Q29ubmVjdGVkQWRhcHRlckhhbmRsZShrZXkpO1xyXG4gICAgcmV0dXJuIGhhbmRsZSAmJiBoYW5kbGUuZ2V0QWRhcHRlcigpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLCB3aGVuIHRoZSBhZGFwYXRlciBpcyBkZXRhY2hlZCBmcm9tIHRoZSBub2RlLlxyXG4gKiBBdCB0aGlzIHBvaW50LCB0aGUgYWRhcGF0ZXIgc2hvdWxkIGRpc2Nvbm5lY3QgZnJvbSBhbnkgb3RoZXIgYWRhcHRlciBhbmQgcHJlcGFyZSB0byBiZSBwcm9wZXJseSBnYXJiYWdlIGNvbGxlY3RlZFxyXG4gKi9cclxuQWRhcHRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0aGF0IGNvbnZlcnRzIGFuIEFkYXB0ZXJIYW5kbGVOb3RpZmljYXRpb24gdG8gYSBDb25uZWN0ZWRBZGFwdGVyTm90aWZpY2F0aW9uXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7RXZlbnRzLkFkYXB0ZXJIYW5kbGVOb3RpZmljYXRpb259IGV2dFxyXG4gKi9cclxuZnVuY3Rpb24gYWRhcHRlckhhbmRsZUNhbGxiYWNrKGV2dCkge1xyXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuY29ubmVjdGVkQWRhcHRlckhhbmRsZXMpIHtcclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlc1trZXldID09IGV2dC5hZGFwdGVySGFuZGxlKSB7XHJcbiAgICAgICAgICAgIHZhciBzdWJFdmVudCA9IG5ldyBFdmVudHMuQ29ubmVjdGVkQWRhcHRlck5vdGlmaWNhdGlvbihldnQsIGtleSk7XHJcbiAgICAgICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlZChzdWJFdmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEFuIEFkYXB0ZXIgY29ubmVjdGVkIHRvIGEgRE9NTm9kZSAocG9zc2libHkgb2YgYW4gZXh0ZXJuYWwgZG9jdW1lbnQpXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0FkYXB0ZXJGYWN0b3J5fSBmYWN0b3J5IHRoZSBBZGFwdGVyRmFjdG9yeSB0aGlzIGFkYXB0ZXIgd2FzIGNyZWF0ZWQgZnJvbVxyXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSAtIERPTSBub2RlIG9mIHRoaXMgQWRhcHRlclxyXG4gKi9cclxudmFyIE5vZGVBZGFwdGVyID0gZnVuY3Rpb24oZmFjdG9yeSwgbm9kZSkge1xyXG4gICAgQWRhcHRlci5jYWxsKHRoaXMsIGZhY3RvcnkpO1xyXG4gICAgdGhpcy5ub2RlID0gbm9kZTtcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoTm9kZUFkYXB0ZXIsIEFkYXB0ZXIpO1xyXG5cclxuLyoqXHJcbiAqIGNhbGxlZCBieSB0aGUgZmFjdG9yeSBhZnRlciBhZGRpbmcgdGhlIGFkYXB0ZXIgdG8gdGhlIG5vZGVcclxuICovXHJcbk5vZGVBZGFwdGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XHJcbn07XHJcblxyXG4vKipcclxuICogTm90aWZpY3Rpb24gZHVlIHRvIGEgY2hhbmdlIGluIERPTSwgcmVsYXRlZCBhZGFwdGVycyBhbmQgc28gb24uXHJcbiAqIEBwYXJhbSB7RXZlbnRzLk5vdGlmaWNhdGlvbn0gZVxyXG4gKi9cclxuTm9kZUFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeUNoYW5nZWQgPSBmdW5jdGlvbihlKSB7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfFhNTDNELlVSSX0gdXJpIFVyaSB0byByZWZlcnJlZCBhZGFwdGVySGFuZGxlXHJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gYXNwZWN0VHlwZSBPcHRpb25hbDogdGhlIHR5cGUgb2YgYWRhcHRlciAodXNlIHNhbWUgYWRhcHRlciB0eXBlIGJ5IGRlZmF1bHQpXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gY2FudmFzSWQgT3B0aW9uYWw6IHRoZSBjYW52YXMgaWQgb2YgdGhlIGFkYXB0ZXIgKHVzZSBjYW52YXMgaWQgb2YgdGhpcyBhZGFwdGVyIGJ5IGRlZmF1bHQpXHJcbiAqIEByZXR1cm5zIGFuIEFkYXB0ZXJIYW5kbGUgdG8gdGhlIHJlZmVycmVkIEFkYXB0ZXIgb2YgdGhlIHNhbWUgYXNwZWN0IGFuZCBjYW52YXNJZFxyXG4gKi9cclxuTm9kZUFkYXB0ZXIucHJvdG90eXBlLmdldEFkYXB0ZXJIYW5kbGUgPSBmdW5jdGlvbih1cmksIGFzcGVjdFR5cGUsIGNhbnZhc0lkKSB7XHJcbiAgICBjYW52YXNJZCA9IGNhbnZhc0lkID09PSB1bmRlZmluZWQgPyB0aGlzLmZhY3RvcnkuY2FudmFzSWQgOiBjYW52YXNJZDtcclxuICAgIHJldHVybiBSZXNvdXJjZS5nZXRBZGFwdGVySGFuZGxlKHRoaXMubm9kZS5vd25lckRvY3VtZW50Ll9kb2N1bWVudFVSTCB8fCB0aGlzLm5vZGUub3duZXJEb2N1bWVudC5VUkwsXHJcbiAgICAgICAgdXJpLCBhc3BlY3RUeXBlIHx8IHRoaXMuZmFjdG9yeS5hc3BlY3QsIGNhbnZhc0lkLCB0aGlzLm5vZGUubm9kZU5hbWUpO1xyXG59O1xyXG4vKipcclxuICogbm90aWZpZXMgYWxsIGFkYXB0ZXIgdGhhdCByZWZlciB0byB0aGlzIGFkYXB0ZXIgdGhyb3VnaCBBZGFwdGVySGFuZGxlcy5cclxuICogQHBhcmFtIHtudW1iZXI/fSB0eXBlIFRoZSB0eXBlIG9mIGNoYW5nZVxyXG4gKi9cclxuTm9kZUFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeU9wcG9zaXRlQWRhcHRlcnMgPSBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICB0eXBlID0gdHlwZSB8fCBFdmVudHMuQURBUFRFUl9IQU5ETEVfQ0hBTkdFRDtcclxuICAgIHJldHVybiBSZXNvdXJjZS5ub3RpZnlOb2RlQWRhcHRlckNoYW5nZSh0aGlzLm5vZGUsXHJcbiAgICAgICAgdGhpcy5mYWN0b3J5LmFzcGVjdCwgdGhpcy5mYWN0b3J5LmNhbnZhc0lkLCB0eXBlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZXB0aC1maXJzdCB0cmF2ZXJzYWwgb3ZlciBlbGVtZW50IGhpZXJhcmNoeVxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKE5vZGVBZGFwdGVyKX0gY2FsbGJhY2tcclxuICovXHJcbk5vZGVBZGFwdGVyLnByb3RvdHlwZS50cmF2ZXJzZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICBjYWxsYmFjayh0aGlzKTtcclxuICAgIHZhciBjaGlsZCA9IHRoaXMubm9kZS5maXJzdEVsZW1lbnRDaGlsZDtcclxuICAgIHdoaWxlIChjaGlsZCkge1xyXG4gICAgICAgIHZhciBhZGFwdGVyID0gdGhpcy5mYWN0b3J5LmdldEFkYXB0ZXIoY2hpbGQpO1xyXG4gICAgICAgIGFkYXB0ZXIgJiYgYWRhcHRlci50cmF2ZXJzZShjYWxsYmFjayk7XHJcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0RWxlbWVudFNpYmxpbmc7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEBpbnRlcmZhY2VcclxuICovXHJcbnZhciBJRmFjdG9yeSA9IGZ1bmN0aW9uKCkge1xyXG59O1xyXG5JRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlQWRhcHRlciA9IGZ1bmN0aW9uKCkge307XHJcblxyXG5cclxuLyoqXHJcbiAqIEFuIGFkYXB0ZXIgZmFjdG9yeSBpcyByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgYWRhcHRlciBmcm9tIGEgY2VydGFpbiBkYXRhIHNvdXJjZS5cclxuICogTm90ZSB0aGF0IGFueSBBZGFwdGVyRmFjdG9yeSBpcyByZWdpc3RlcmVkIHdpdGggUmVzb3VyY2VcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBpbXBsZW1lbnRzIHtJRmFjdG9yeX1cclxuICogQHBhcmFtIHtPYmplY3R9IGFzcGVjdCBUaGUgYXNwZWN0IHRoaXMgZmFjdG9yeSBzZXJ2ZXMgKGUuZy4gWE1MM0QuZGF0YSBvciBYTUwzRC53ZWJnbClcclxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IG1pbWV0eXBlcyBUaGUgbWltZXR5cGUgdGhpcyBmYWN0b3J5IGlzIGNvbXBhdGlibGUgdG9cclxuICogQHBhcmFtIHtudW1iZXJ9IGNhbnZhc0lkIFRoZSBpZCBvZiB0aGUgY29ycmVzcG9uZGluZyBjYW52YXMgaGFuZGxlci4gMCwgaWYgbm90IGRlcGVuZGVudCBvbiBhbnkgR0xDYW52YXNIYW5kbGVyXHJcbiAqL1xyXG52YXIgQWRhcHRlckZhY3RvcnkgPSBmdW5jdGlvbihhc3BlY3QsIG1pbWV0eXBlcywgY2FudmFzSWQpIHtcclxuICAgIHRoaXMuYXNwZWN0ID0gYXNwZWN0O1xyXG4gICAgdGhpcy5jYW52YXNJZCA9IGNhbnZhc0lkIHx8IDA7XHJcbiAgICB0aGlzLm1pbWV0eXBlcyA9IHR5cGVvZiBtaW1ldHlwZXMgPT0gXCJzdHJpbmdcIiA/IFsgbWltZXR5cGVzXSA6IG1pbWV0eXBlcztcclxufTtcclxuXHJcbiAvKiogSW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NcclxuICogQ3JlYXRlIGFkYXB0ZXIgZnJvbSBhbiBvYmplY3QgKG5vZGUgaW4gY2FzZSBvZiBhbiB4bWwsIGFuZCBvYmplY3QgaW4gY2FzZSBvZiBqc29uKVxyXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqXHJcbiAqIEByZXR1cm5zIHs/QWRhcHRlcn0gY3JlYXRlZCBhZGFwdGVyIG9yIG51bGwgaWYgbm8gYWRhcHRlciBjYW4gYmUgY3JlYXRlZFxyXG4gKi9cclxuQWRhcHRlckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUFkYXB0ZXIgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0aGUgYWRhcHRlciBmYWN0b3J5IHN1cHBvcnRzIHNwZWNpZmllZCBtaW1ldHlwZS4gQ2FuIGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3MuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1ldHlwZVxyXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBhZGFwdGVyIGZhY3Rvcnkgc3VwcG9ydHMgc3BlY2lmaWVkIG1pbWV0eXBlXHJcbiAqL1xyXG5BZGFwdGVyRmFjdG9yeS5wcm90b3R5cGUuc3VwcG9ydHNNaW1ldHlwZSA9IGZ1bmN0aW9uKG1pbWV0eXBlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5taW1ldHlwZXMuaW5kZXhPZihtaW1ldHlwZSkgIT0gLTE7XHJcbn07XHJcblxyXG4vKipcclxuICogQSBOb2RlQWRhcGVyRmFjdG9yeSBpcyBhIEFkYXB0ZXJGYWN0b3J5LCB0aGF0IHdvcmtzIHNwZWNpZmljYWxseSBmb3IgRE9NIG5vZGVzIC8gZWxlbWVudHMuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge09iamVjdH0gYXNwZWN0IFRoZSBhc3BlY3QgdGhpcyBmYWN0b3J5IHNlcnZlcyAoZS5nLiBYTUwzRC5kYXRhIG9yIFhNTDNELndlYmdsKVxyXG4gKiBAcGFyYW0ge251bWJlcn0gY2FudmFzSWQgVGhlIGlkIG9mIHRoZSBjb3JyZXNwb25kaW5nIGNhbnZhcyBoYW5kbGVyLiAwLCBpZiBub3QgZGVwZW5kZW50IG9uIGFueSBHTENhbnZhc0hhbmRsZXJcclxuICovXHJcbnZhciBOb2RlQWRhcHRlckZhY3RvcnkgPSBmdW5jdGlvbihhc3BlY3QsIGNhbnZhc0lkKSB7XHJcbiAgICBBZGFwdGVyRmFjdG9yeS5jYWxsKHRoaXMsIGFzcGVjdCwgW1widGV4dC94bWxcIiwgXCJhcHBsaWNhdGlvbi94bWxcIl0sIGNhbnZhc0lkKTtcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoTm9kZUFkYXB0ZXJGYWN0b3J5LCBBZGFwdGVyRmFjdG9yeSk7XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBmaXJzdCBjaGVja3MsIGlmIGFuIGFkYXB0ZXIgaGFzIGJlZW4gYWxyZWFkeSBjcmVhdGVkIGZvciB0aGUgY29ycmVzcG9uZGluZyBub2RlXHJcbiAqIElmIHllcywgdGhpcyBhZGFwdGVyIGlzIHJldHVybmVkLCBvdGhlcndpc2UsIGEgbmV3IGFkYXB0ZXIgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXHJcbiAqIEByZXR1cm5zIHtBZGFwdGVyfSBUaGUgYWRhcHRlciBvZiB0aGUgbm9kZVxyXG4gKi9cclxuTm9kZUFkYXB0ZXJGYWN0b3J5LnByb3RvdHlwZS5nZXRBZGFwdGVyID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgaWYobm9kZSAmJiBub2RlLl9jb25maWd1cmVkID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgY29uZmlnLmVsZW1lbnQobm9kZSk7XHJcbiAgICBpZiAoIW5vZGUgfHwgbm9kZS5fY29uZmlndXJlZCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIHZhciBlbGVtSGFuZGxlciA9IG5vZGUuX2NvbmZpZ3VyZWQ7XHJcbiAgICB2YXIga2V5ID0gdGhpcy5hc3BlY3QgKyBcIl9cIiArIHRoaXMuY2FudmFzSWQ7XHJcbiAgICB2YXIgYWRhcHRlciA9IGVsZW1IYW5kbGVyLmFkYXB0ZXJzW2tleV07XHJcbiAgICBpZiAoYWRhcHRlciAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHJldHVybiBhZGFwdGVyO1xyXG5cclxuICAgIC8vIE5vIGFkYXB0ZXIgZm91bmQsIHRyeSB0byBjcmVhdGUgb25lXHJcbiAgICBhZGFwdGVyID0gdGhpcy5jcmVhdGVBZGFwdGVyKG5vZGUpO1xyXG4gICAgaWYgKGFkYXB0ZXIpIHtcclxuICAgICAgICBlbGVtSGFuZGxlci5hZGFwdGVyc1trZXldID0gYWRhcHRlcjtcclxuICAgICAgICBhZGFwdGVyLmluaXQoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhZGFwdGVyO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbk5vZGVBZGFwdGVyIDogTm9kZUFkYXB0ZXIsXHJcbkFkYXB0ZXJGYWN0b3J5IDogQWRhcHRlckZhY3RvcnksXHJcbk5vZGVBZGFwdGVyRmFjdG9yeSA6IE5vZGVBZGFwdGVyRmFjdG9yeVxyXG59O1xyXG4iLCJ2YXIgRXZlbnRzID0gcmVxdWlyZShcIi4uL2ludGVyZmFjZS9ub3RpZmljYXRpb24uanNcIik7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyoqXHJcbiAqIEFuIGFkYXB0ZXIgaGFuZGxlIGlzIGEgY29ubmVjdGlvbiBwaWVjZSBmb3IgYW4gYWRhcHRlciB0aGF0IGlzIHJlZmVycmVkIHRocm91Z2ggYSB1cmkgKGUuZy4gaWQgcmVmZXJlbmNlKVxyXG4gKiBBZGFwdGVySGFuZGxlcyBhcmUgYWx3YXlzIGZldGNoZWQgZnJvbSB0aGUgUmVzb3VyY2Ugb2JqZWN0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIEFkYXB0ZXJIYW5kbGUgPSBmdW5jdGlvbih1cmwpIHtcclxuICAgIHRoaXMudXJsID0gdXJsO1xyXG4gICAgdGhpcy5hZGFwdGVyID0gbnVsbDtcclxuICAgIHRoaXMubGlzdGVuZXJzID0gW107XHJcbiAgICB0aGlzLnN0YXR1cyA9IDA7IC8vIFNUQVRVUy5MT0FESU5HXHJcbn07XHJcblxyXG4vKipcclxuICogRW51bWFlcmF0aW9uIG9mIHN0YXRlcyBmb3IgdGhlIGFkYXB0ZXIgaGFuZGxlXHJcbiAqIEBlbnVtIHtudW1iZXJ9XHJcbiAqL1xyXG5BZGFwdGVySGFuZGxlLlNUQVRVUyA9IHtcclxuICAgIExPQURJTkc6IDAsXHJcbiAgICBOT1RfRk9VTkQ6IDEsXHJcbiAgICBSRUFEWTogMlxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmZiBhbiBhZGFwdGVyIGlzIGF2YWlsYWJsZVxyXG4gKi9cclxuQWRhcHRlckhhbmRsZS5wcm90b3R5cGUuaGFzQWRhcHRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlciAhPSBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHs/WE1MM0QuYmFzZS5BZGFwdGVyfSB0aGUgYWRhcHRlciBjb25uZWN0ZWQgdG8gdGhlIGhhbmRsZS4gQ2FuIGJlIG51bGxcclxuICovXHJcbkFkYXB0ZXJIYW5kbGUucHJvdG90eXBlLmdldEFkYXB0ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmFkYXB0ZXI7XHJcbn07XHJcblxyXG4vKipcclxuICogTm90ZTogdGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgYnkgUmVzb3VyY2VcclxuICogQHBhcmFtIHtYTUwzRC5iYXNlLkFkYXB0ZXJ9IGFkYXB0ZXIgVGhlIGFkYXB0ZXIgY29ubmVjdGVkIHRvIHRoZSBBZGFwdGVySGFuZGxlclxyXG4gKiBAcGFyYW0ge0FkYXB0ZXJIYW5kbGUuU1RBVFVTfSBzdGF0dXNcclxuICovXHJcbkFkYXB0ZXJIYW5kbGUucHJvdG90eXBlLnNldEFkYXB0ZXIgPSBmdW5jdGlvbihhZGFwdGVyLCBzdGF0dXMpIHtcclxuICAgIHRoaXMuYWRhcHRlciA9IGFkYXB0ZXI7XHJcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcclxuICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKEV2ZW50cy5BREFQVEVSX0hBTkRMRV9DSEFOR0VEKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB0byBub3RpZnkgYWxsIGxpc3RlbmVycyBvZiB0aGlzIEFkYXB0ZXJIYW5kbGUgYWJvdXQgc29tZSBjaGFuZ2UuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIEEgdHlwZSBudW1iZXIgd2l0aCB0aGUgdHlwZSBvZiBjaGFuZ2UgKHVzdWFsbHkgRXZlbnRzLkFEQVBURVJfSEFORExFX0NIQU5HRUQpXHJcbiAqL1xyXG5BZGFwdGVySGFuZGxlLnByb3RvdHlwZS5ub3RpZnlMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnRzLkFkYXB0ZXJIYW5kbGVOb3RpZmljYXRpb24odGhpcywgdHlwZSk7XHJcbiAgICB2YXIgaSA9IHRoaXMubGlzdGVuZXJzLmxlbmd0aDtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyc1tpXShldmVudCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkIGEgbGlzdGVuZXIgdG8gdGhlIEFkYXB0ZXJIYW5kbGUgdGhhdCBpcyBub3RpZmllZCBhYm91dCBjaGFuZ2VzLlxyXG4gKiBMaXN0ZW5lcnMgY2Fubm90IGJlIGluc2VydGVkIHR3aWNlLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHNvbWV0aGluZyBjb25jZXJpbmcgdGhlIGFkYXB0ZXIgY2hhbmdlc1xyXG4gKi9cclxuQWRhcHRlckhhbmRsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xyXG4gICAgdmFyIGlkeCA9IHRoaXMubGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xyXG4gICAgaWYgKGlkeCA9PSAtMSlcclxuICAgICAgICB0aGlzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgYSBsaXN0ZW5lciBmcm9tIHRoZSBBZGFwdGVySGFuZGxlXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXHJcbiAqL1xyXG5BZGFwdGVySGFuZGxlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XHJcbiAgICB2YXIgaWR4ID0gdGhpcy5saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XHJcbiAgICBpZiAoaWR4ICE9IC0xKVxyXG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBZGFwdGVySGFuZGxlOyIsIi8qanNsaW50IHdoaXRlOiBmYWxzZSwgb25ldmFyOiBmYWxzZSwgdW5kZWY6IHRydWUsIG5vbWVuOiB0cnVlLCBlcWVxZXE6IHRydWUsIHBsdXNwbHVzOiB0cnVlLCBiaXR3aXNlOiB0cnVlLCByZWdleHA6IHRydWUsIG5ld2NhcDogdHJ1ZSwgaW1tZWQ6IHRydWUsIHN1YjogdHJ1ZSwgbm9tZW46IGZhbHNlICovXHJcblxyXG4vKipcclxuKiBUaGlzIGZpbGUgY29udGFpbnMgY29kZSB0aGF0IG1heSBiZSB1bmRlciB0aGUgZm9sbG93aW5nIGxpY2Vuc2U6XHJcbipcclxuKiBTR0kgRlJFRSBTT0ZUV0FSRSBMSUNFTlNFIEIgKFZlcnNpb24gMi4wLCBTZXB0LiAxOCwgMjAwOClcclxuKiBDb3B5cmlnaHQgKEMpIDE5OTEtMjAwMCBTaWxpY29uIEdyYXBoaWNzLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbipcclxuKiBTZWUgaHR0cDovL29zcy5zZ2kuY29tL3Byb2plY3RzL0ZyZWVCLyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuKlxyXG4qIEFsbCBjb2RlIGluIHRoaXMgZmlsZSB3aGljaCBpcyBOT1QgdW5kZXIgdGhlIFNHSSBGUkVFIFNPRlRXQVJFIExJQ0VOU0UgQlxyXG4qIGlzIGZyZWUgYW5kIHVuZW5jdW1iZXJlZCBzb2Z0d2FyZSByZWxlYXNlZCBpbnRvIHRoZSBwdWJsaWMgZG9tYWluLlxyXG4qXHJcbiogQW55b25lIGlzIGZyZWUgdG8gY29weSwgbW9kaWZ5LCBwdWJsaXNoLCB1c2UsIGNvbXBpbGUsIHNlbGwsIG9yXHJcbiogZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlLCBlaXRoZXIgaW4gc291cmNlIGNvZGUgZm9ybSBvciBhcyBhIGNvbXBpbGVkXHJcbiogYmluYXJ5LCBmb3IgYW55IHB1cnBvc2UsIGNvbW1lcmNpYWwgb3Igbm9uLWNvbW1lcmNpYWwsIGFuZCBieSBhbnlcclxuKiBtZWFucy5cclxuKlxyXG4qIEluIGp1cmlzZGljdGlvbnMgdGhhdCByZWNvZ25pemUgY29weXJpZ2h0IGxhd3MsIHRoZSBhdXRob3Igb3IgYXV0aG9yc1xyXG4qIG9mIHRoaXMgc29mdHdhcmUgZGVkaWNhdGUgYW55IGFuZCBhbGwgY29weXJpZ2h0IGludGVyZXN0IGluIHRoZVxyXG4qIHNvZnR3YXJlIHRvIHRoZSBwdWJsaWMgZG9tYWluLiBXZSBtYWtlIHRoaXMgZGVkaWNhdGlvbiBmb3IgdGhlIGJlbmVmaXRcclxuKiBvZiB0aGUgcHVibGljIGF0IGxhcmdlIGFuZCB0byB0aGUgZGV0cmltZW50IG9mIG91ciBoZWlycyBhbmRcclxuKiBzdWNjZXNzb3JzLiBXZSBpbnRlbmQgdGhpcyBkZWRpY2F0aW9uIHRvIGJlIGFuIG92ZXJ0IGFjdCBvZlxyXG4qIHJlbGlucXVpc2htZW50IGluIHBlcnBldHVpdHkgb2YgYWxsIHByZXNlbnQgYW5kIGZ1dHVyZSByaWdodHMgdG8gdGhpc1xyXG4qIHNvZnR3YXJlIHVuZGVyIGNvcHlyaWdodCBsYXcuXHJcbipcclxuKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4qIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4qIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuKiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUlxyXG4qIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLFxyXG4qIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxyXG4qIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuKi9cclxuXHJcbnZhciBHTFUgPSB7fTtcclxuLyoqXHJcbiogVW5wcm9qZWN0IGEgc2NyZWVuIHBvaW50LlxyXG4qXHJcbiogQHBhcmFtIHtudW1iZXJ9IHdpblggdGhlIHdpbmRvdyBwb2ludCBmb3IgdGhlIHggdmFsdWUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHdpblkgdGhlIHdpbmRvdyBwb2ludCBmb3IgdGhlIHkgdmFsdWUuXHJcbiogQHBhcmFtIHtudW1iZXJ9IHdpblogdGhlIHdpbmRvdyBwb2ludCBmb3IgdGhlIHogdmFsdWUuXHJcbiogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbW9kZWwgdGhlIG1vZGVsLXZpZXcgbWF0cml4LlxyXG4qIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHByb2ogdGhlIHByb2plY3Rpb24gbWF0cml4LlxyXG4qIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZpZXcgdGhlIHZpZXdwb3J0IGNvb3JkaW5hdGUgYXJyYXkuXHJcbiogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb2JqUG9zIHRoZSBtb2RlbCBwb2ludCByZXN1bHQuXHJcbiogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdW5wcm9qZWN0IG9wZXJhdGlvbiB3YXMgc3VjY2Vzc2Z1bCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4qL1xyXG5HTFUudW5Qcm9qZWN0ID0gZnVuY3Rpb24od2luWCwgd2luWSwgd2luWiwgbW9kZWwsIHByb2osIHZpZXcsIG9ialBvcykge1xyXG5cclxuICAgIC8qKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59ICovXHJcbiAgICB2YXIgaW5wID0gW1xyXG4gICAgICAgIHdpblgsXHJcbiAgICAgICAgd2luWSxcclxuICAgICAgICB3aW5aLFxyXG4gICAgICAgIDEuMFxyXG4gICAgXTtcclxuXHJcbiAgICAvKiogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xyXG4gICAgdmFyIGZpbmFsTWF0cml4ID0gW107XHJcblxyXG4gICAgR0xVLm11bHRNYXRyaWNlcyhtb2RlbCwgcHJvaiwgZmluYWxNYXRyaXgpO1xyXG4gICAgaWYgKCFHTFUuaW52ZXJ0TWF0cml4KGZpbmFsTWF0cml4LCBmaW5hbE1hdHJpeCkpIHtcclxuICAgICAgICByZXR1cm4gKGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiBNYXAgeCBhbmQgeSBmcm9tIHdpbmRvdyBjb29yZGluYXRlcyAqL1xyXG4gICAgaW5wWzBdID0gKGlucFswXSAtIHZpZXdbMF0pIC8gdmlld1syXTtcclxuICAgIGlucFsxXSA9IChpbnBbMV0gLSB2aWV3WzFdKSAvIHZpZXdbM107XHJcblxyXG4gICAgLyogTWFwIHRvIHJhbmdlIC0xIHRvIDEgKi9cclxuICAgIGlucFswXSA9IGlucFswXSAqIDIgLSAxO1xyXG4gICAgaW5wWzFdID0gaW5wWzFdICogMiAtIDE7XHJcbiAgICBpbnBbMl0gPSBpbnBbMl0gKiAyIC0gMTtcclxuXHJcbiAgICAvKiogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xyXG4gICAgdmFyIG91dCA9IFtdO1xyXG5cclxuICAgIEdMVS5tdWx0TWF0cml4VmVjKGZpbmFsTWF0cml4LCBpbnAsIG91dCk7XHJcblxyXG4gICAgaWYgKG91dFszXSA9PT0gMC4wKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIG91dFswXSAvPSBvdXRbM107XHJcbiAgICBvdXRbMV0gLz0gb3V0WzNdO1xyXG4gICAgb3V0WzJdIC89IG91dFszXTtcclxuXHJcbiAgICBvYmpQb3NbMF0gPSBvdXRbMF07XHJcbiAgICBvYmpQb3NbMV0gPSBvdXRbMV07XHJcbiAgICBvYmpQb3NbMl0gPSBvdXRbMl07XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG4vKipcclxuKiBNdWx0aXBseSB0aGUgbWF0cml4IGJ5IHRoZSBzcGVjaWZpZWQgdmVjdG9yLlxyXG4qXHJcbiogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF0cml4IHRoZSBtYXRyaXguXHJcbiogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gaW5wIHRoZSB2ZWN0b3IuXHJcbiogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3V0IHRoZSBvdXRwdXQuXHJcbiovXHJcbkdMVS5tdWx0TWF0cml4VmVjID0gZnVuY3Rpb24obWF0cml4LCBpbnAsIG91dCkge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpID0gaSArIDEpIHtcclxuICAgICAgICBvdXRbaV0gPVxyXG4gICAgICAgICAgICBpbnBbMF0gKiBtYXRyaXhbMCAqIDQgKyBpXSArXHJcbiAgICAgICAgICAgIGlucFsxXSAqIG1hdHJpeFsxICogNCArIGldICtcclxuICAgICAgICAgICAgaW5wWzJdICogbWF0cml4WzIgKiA0ICsgaV0gK1xyXG4gICAgICAgICAgICBpbnBbM10gKiBtYXRyaXhbMyAqIDQgKyBpXTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4qIE11bHRpcGx5IHRoZSBzcGVjaWZpZWQgbWF0cmljZXMuXHJcbipcclxuKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhIHRoZSBmaXJzdCBtYXRyaXguXHJcbiogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYiB0aGUgc2Vjb25kIG1hdHJpeC5cclxuKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByIHRoZSByZXN1bHQuXHJcbiovXHJcbkdMVS5tdWx0TWF0cmljZXMgPSBmdW5jdGlvbihhLCBiLCByKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkgPSBpICsgMSkge1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNDsgaiA9IGogKyAxKSB7XHJcbiAgICAgICAgICAgIHJbaSAqIDQgKyBqXSA9XHJcbiAgICAgICAgICAgICAgICBhW2kgKiA0ICsgMF0gKiBiWzAgKiA0ICsgal0gK1xyXG4gICAgICAgICAgICAgICAgYVtpICogNCArIDFdICogYlsxICogNCArIGpdICtcclxuICAgICAgICAgICAgICAgIGFbaSAqIDQgKyAyXSAqIGJbMiAqIDQgKyBqXSArXHJcbiAgICAgICAgICAgICAgICBhW2kgKiA0ICsgM10gKiBiWzMgKiA0ICsgal07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiogSW52ZXJ0IGEgbWF0cml4LlxyXG4qXHJcbiogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbSB0aGUgbWF0cml4LlxyXG4qIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGludk91dCB0aGUgaW52ZXJ0ZWQgb3V0cHV0LlxyXG4qIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgc3VjY2Vzc2Z1bCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4qL1xyXG5HTFUuaW52ZXJ0TWF0cml4ID0gZnVuY3Rpb24obSwgaW52T3V0KSB7XHJcbiAgICAvKiogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xyXG4gICAgdmFyIGludiA9IFtdO1xyXG5cclxuICAgIGludlswXSA9IG1bNV0gKiBtWzEwXSAqIG1bMTVdIC0gbVs1XSAqIG1bMTFdICogbVsxNF0gLSBtWzldICogbVs2XSAqIG1bMTVdICtcclxuICAgICAgICBtWzldICogbVs3XSAqIG1bMTRdICsgbVsxM10gKiBtWzZdICogbVsxMV0gLSBtWzEzXSAqIG1bN10gKiBtWzEwXTtcclxuICAgIGludls0XSA9IC1tWzRdICogbVsxMF0gKiBtWzE1XSArIG1bNF0gKiBtWzExXSAqIG1bMTRdICsgbVs4XSAqIG1bNl0gKiBtWzE1XSAtXHJcbiAgICAgICAgbVs4XSAqIG1bN10gKiBtWzE0XSAtIG1bMTJdICogbVs2XSAqIG1bMTFdICsgbVsxMl0gKiBtWzddICogbVsxMF07XHJcbiAgICBpbnZbOF0gPSBtWzRdICogbVs5XSAqIG1bMTVdIC0gbVs0XSAqIG1bMTFdICogbVsxM10gLSBtWzhdICogbVs1XSAqIG1bMTVdICtcclxuICAgICAgICBtWzhdICogbVs3XSAqIG1bMTNdICsgbVsxMl0gKiBtWzVdICogbVsxMV0gLSBtWzEyXSAqIG1bN10gKiBtWzldO1xyXG4gICAgaW52WzEyXSA9IC1tWzRdICogbVs5XSAqIG1bMTRdICsgbVs0XSAqIG1bMTBdICogbVsxM10gKyBtWzhdICogbVs1XSAqIG1bMTRdIC1cclxuICAgICAgICBtWzhdICogbVs2XSAqIG1bMTNdIC0gbVsxMl0gKiBtWzVdICogbVsxMF0gKyBtWzEyXSAqIG1bNl0gKiBtWzldO1xyXG4gICAgaW52WzFdID0gLW1bMV0gKiBtWzEwXSAqIG1bMTVdICsgbVsxXSAqIG1bMTFdICogbVsxNF0gKyBtWzldICogbVsyXSAqIG1bMTVdIC1cclxuICAgICAgICBtWzldICogbVszXSAqIG1bMTRdIC0gbVsxM10gKiBtWzJdICogbVsxMV0gKyBtWzEzXSAqIG1bM10gKiBtWzEwXTtcclxuICAgIGludls1XSA9IG1bMF0gKiBtWzEwXSAqIG1bMTVdIC0gbVswXSAqIG1bMTFdICogbVsxNF0gLSBtWzhdICogbVsyXSAqIG1bMTVdICtcclxuICAgICAgICBtWzhdICogbVszXSAqIG1bMTRdICsgbVsxMl0gKiBtWzJdICogbVsxMV0gLSBtWzEyXSAqIG1bM10gKiBtWzEwXTtcclxuICAgIGludls5XSA9IC1tWzBdICogbVs5XSAqIG1bMTVdICsgbVswXSAqIG1bMTFdICogbVsxM10gKyBtWzhdICogbVsxXSAqIG1bMTVdIC1cclxuICAgICAgICBtWzhdICogbVszXSAqIG1bMTNdIC0gbVsxMl0gKiBtWzFdICogbVsxMV0gKyBtWzEyXSAqIG1bM10gKiBtWzldO1xyXG4gICAgaW52WzEzXSA9IG1bMF0gKiBtWzldICogbVsxNF0gLSBtWzBdICogbVsxMF0gKiBtWzEzXSAtIG1bOF0gKiBtWzFdICogbVsxNF0gK1xyXG4gICAgICAgIG1bOF0gKiBtWzJdICogbVsxM10gKyBtWzEyXSAqIG1bMV0gKiBtWzEwXSAtIG1bMTJdICogbVsyXSAqIG1bOV07XHJcbiAgICBpbnZbMl0gPSBtWzFdICogbVs2XSAqIG1bMTVdIC0gbVsxXSAqIG1bN10gKiBtWzE0XSAtIG1bNV0gKiBtWzJdICogbVsxNV0gK1xyXG4gICAgICAgIG1bNV0gKiBtWzNdICogbVsxNF0gKyBtWzEzXSAqIG1bMl0gKiBtWzddIC0gbVsxM10gKiBtWzNdICogbVs2XTtcclxuICAgIGludls2XSA9IC1tWzBdICogbVs2XSAqIG1bMTVdICsgbVswXSAqIG1bN10gKiBtWzE0XSArIG1bNF0gKiBtWzJdICogbVsxNV0gLVxyXG4gICAgICAgIG1bNF0gKiBtWzNdICogbVsxNF0gLSBtWzEyXSAqIG1bMl0gKiBtWzddICsgbVsxMl0gKiBtWzNdICogbVs2XTtcclxuICAgIGludlsxMF0gPSBtWzBdICogbVs1XSAqIG1bMTVdIC0gbVswXSAqIG1bN10gKiBtWzEzXSAtIG1bNF0gKiBtWzFdICogbVsxNV0gK1xyXG4gICAgICAgIG1bNF0gKiBtWzNdICogbVsxM10gKyBtWzEyXSAqIG1bMV0gKiBtWzddIC0gbVsxMl0gKiBtWzNdICogbVs1XTtcclxuICAgIGludlsxNF0gPSAtbVswXSAqIG1bNV0gKiBtWzE0XSArIG1bMF0gKiBtWzZdICogbVsxM10gKyBtWzRdICogbVsxXSAqIG1bMTRdIC1cclxuICAgICAgICBtWzRdICogbVsyXSAqIG1bMTNdIC0gbVsxMl0gKiBtWzFdICogbVs2XSArIG1bMTJdICogbVsyXSAqIG1bNV07XHJcbiAgICBpbnZbM10gPSAtbVsxXSAqIG1bNl0gKiBtWzExXSArIG1bMV0gKiBtWzddICogbVsxMF0gKyBtWzVdICogbVsyXSAqIG1bMTFdIC1cclxuICAgICAgICBtWzVdICogbVszXSAqIG1bMTBdIC0gbVs5XSAqIG1bMl0gKiBtWzddICsgbVs5XSAqIG1bM10gKiBtWzZdO1xyXG4gICAgaW52WzddID0gbVswXSAqIG1bNl0gKiBtWzExXSAtIG1bMF0gKiBtWzddICogbVsxMF0gLSBtWzRdICogbVsyXSAqIG1bMTFdICtcclxuICAgICAgICBtWzRdICogbVszXSAqIG1bMTBdICsgbVs4XSAqIG1bMl0gKiBtWzddIC0gbVs4XSAqIG1bM10gKiBtWzZdO1xyXG4gICAgaW52WzExXSA9IC1tWzBdICogbVs1XSAqIG1bMTFdICsgbVswXSAqIG1bN10gKiBtWzldICsgbVs0XSAqIG1bMV0gKiBtWzExXSAtXHJcbiAgICAgICAgbVs0XSAqIG1bM10gKiBtWzldIC0gbVs4XSAqIG1bMV0gKiBtWzddICsgbVs4XSAqIG1bM10gKiBtWzVdO1xyXG4gICAgaW52WzE1XSA9IG1bMF0gKiBtWzVdICogbVsxMF0gLSBtWzBdICogbVs2XSAqIG1bOV0gLSBtWzRdICogbVsxXSAqIG1bMTBdICtcclxuICAgICAgICBtWzRdICogbVsyXSAqIG1bOV0gKyBtWzhdICogbVsxXSAqIG1bNl0gLSBtWzhdICogbVsyXSAqIG1bNV07XHJcblxyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICB2YXIgZGV0ID0gbVswXSAqIGludlswXSArIG1bMV0gKiBpbnZbNF0gKyBtWzJdICogaW52WzhdICsgbVszXSAqIGludlsxMl07XHJcblxyXG4gICAgaWYgKGRldCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBkZXQgPSAxLjAgLyBkZXQ7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSA9IGkgKyAxKSB7XHJcbiAgICAgICAgaW52T3V0W2ldID0gaW52W2ldICogZGV0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHTFU7IiwiLy8gRG9tYWluIFB1YmxpYyBieSBFcmljIFdlbmRlbGluIGh0dHA6Ly9lcml3ZW4uY29tLyAoMjAwOClcclxuLy8gICAgICAgICAgICAgICAgICBMdWtlIFNtaXRoIGh0dHA6Ly9sdWNhc3NtaXRoLm5hbWUvICgyMDA4KVxyXG4vLyAgICAgICAgICAgICAgICAgIExvaWMgRGFjaGFyeSA8bG9pY0BkYWNoYXJ5Lm9yZz4gKDIwMDgpXHJcbi8vICAgICAgICAgICAgICAgICAgSm9oYW4gRXVwaHJvc2luZSA8cHJvcHB5QGFtaW5jaGUuY29tPiAoMjAwOClcclxuLy8gICAgICAgICAgICAgICAgICBPeXZpbmQgU2VhbiBLaW5zZXkgaHR0cDovL2tpbnNleS5uby9ibG9nICgyMDEwKVxyXG4vLyAgICAgICAgICAgICAgICAgIFZpY3RvciBIb215YWtvdiA8dmljdG9yLWhvbXlha292QHVzZXJzLnNvdXJjZWZvcmdlLm5ldD4gKDIwMTApXHJcblxyXG5cclxuLyoqXHJcbiAqIE1haW4gZnVuY3Rpb24gZ2l2aW5nIGEgZnVuY3Rpb24gc3RhY2sgdHJhY2Ugd2l0aCBhIGZvcmNlZCBvciBwYXNzZWQgaW5cclxuICogRXJyb3JcclxuICpcclxuICogQGNmZyB7RXJyb3J9IGUgVGhlIGVycm9yIHRvIGNyZWF0ZSBhIHN0YWNrdHJhY2UgZnJvbSAob3B0aW9uYWwpXHJcbiAqIEBjZmcge0Jvb2xlYW59IGd1ZXNzIElmIHdlIHNob3VsZCB0cnkgdG8gcmVzb2x2ZSB0aGUgbmFtZXMgb2YgYW5vbnltb3VzXHJcbiAqIGZ1bmN0aW9uc1xyXG4gKiBAcmV0dXJuIHtBcnJheX0gb2YgU3RyaW5ncyB3aXRoIGZ1bmN0aW9ucywgbGluZXMsIGZpbGVzLCBhbmQgYXJndW1lbnRzXHJcbiAqIHdoZXJlIHBvc3NpYmxlXHJcbiAqL1xyXG52YXIgcHJpbnRTdGFja1RyYWNlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHtcclxuICAgICAgICBndWVzcyA6IHRydWVcclxuICAgIH07XHJcbiAgICB2YXIgZXggPSBvcHRpb25zLmUgfHwgbnVsbCwgZ3Vlc3MgPSAhIW9wdGlvbnMuZ3Vlc3M7XHJcbiAgICB2YXIgcCA9IG5ldyBwcmludFN0YWNrVHJhY2UuaW1wbGVtZW50YXRpb24oKSwgcmVzdWx0ID0gcC5ydW4oZXgpO1xyXG4gICAgcmV0dXJuIChndWVzcykgPyBwLmd1ZXNzQW5vbnltb3VzRnVuY3Rpb25zKHJlc3VsdCkgOiByZXN1bHQ7XHJcbn07XHJcblxyXG5wcmludFN0YWNrVHJhY2UuaW1wbGVtZW50YXRpb24gPSBmdW5jdGlvbigpIHt9O1xyXG5cclxucHJpbnRTdGFja1RyYWNlLmltcGxlbWVudGF0aW9uLnByb3RvdHlwZSA9IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZXggVGhlIGVycm9yIHRvIGNyZWF0ZSBhIHN0YWNrdHJhY2UgZnJvbSAob3B0aW9uYWwpXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kZSBGb3JjZWQgbW9kZSAob3B0aW9uYWwsIG1vc3RseSBmb3IgdW5pdCB0ZXN0cylcclxuICAgICAqL1xyXG4gICAgcnVuIDogZnVuY3Rpb24oZXgsIG1vZGUpIHtcclxuICAgICAgICBleCA9IGV4IHx8IHRoaXMuY3JlYXRlRXhjZXB0aW9uKCk7XHJcbiAgICAgICAgLy8gZXhhbWluZSBleGNlcHRpb24gcHJvcGVydGllcyB3L28gZGVidWdnZXJcclxuICAgICAgICAvLyBmb3IgKHZhciBwcm9wIGluIGV4KSB7YWxlcnQoXCJFeFsnXCIgKyBwcm9wICsgXCInXT1cIiArIGV4W3Byb3BdKTt9XHJcbiAgICAgICAgbW9kZSA9IG1vZGUgfHwgdGhpcy5tb2RlKGV4KTtcclxuICAgICAgICBpZiAobW9kZSA9PT0gJ290aGVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vdGhlcihhcmd1bWVudHMuY2FsbGVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1ttb2RlXShleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVFeGNlcHRpb24gOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLnVuZGVmKCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW9kZSBjb3VsZCBkaWZmZXIgZm9yIGRpZmZlcmVudCBleGNlcHRpb24sIGUuZy4gZXhjZXB0aW9ucyBpbiBDaHJvbWVcclxuICAgICAqIG1heSBvciBtYXkgbm90IGhhdmUgYXJndW1lbnRzIG9yIHN0YWNrLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gbW9kZSBvZiBvcGVyYXRpb24gZm9yIHRoZSBleGNlcHRpb25cclxuICAgICAqL1xyXG4gICAgbW9kZSA6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICBpZiAoZVsnYXJndW1lbnRzJ10gJiYgZS5zdGFjaykge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2Nocm9tZSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlLnN0YWNrICYmIGUuc291cmNlVVJMKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnc2FmYXJpJztcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5vcGVyYSkge1xyXG4gICAgICAgICAgICAvLyBlLm1lc3NhZ2UuaW5kZXhPZihcIkJhY2t0cmFjZTpcIikgPiAtMSAtPiBvcGVyYVxyXG4gICAgICAgICAgICAvLyAhZS5zdGFja3RyYWNlIC0+IG9wZXJhXHJcbiAgICAgICAgICAgIGlmICghZS5zdGFja3RyYWNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29wZXJhOSc7IC8vIHVzZSBlLm1lc3NhZ2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAnb3BlcmEjc291cmNlbG9jJyBpbiBlIC0+IG9wZXJhOSwgb3BlcmExMGFcclxuICAgICAgICAgICAgaWYgKGUubWVzc2FnZS5pbmRleE9mKCdcXG4nKSA+IC0xICYmIGUubWVzc2FnZS5zcGxpdCgnXFxuJykubGVuZ3RoID4gZS5zdGFja3RyYWNlLnNwbGl0KCdcXG4nKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnb3BlcmE5JzsgLy8gdXNlIGUubWVzc2FnZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGUuc3RhY2t0cmFjZSAmJiAhZS5zdGFjayAtPiBvcGVyYTEwYVxyXG4gICAgICAgICAgICBpZiAoIWUuc3RhY2spIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnb3BlcmExMGEnOyAvLyB1c2UgZS5zdGFja3RyYWNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZS5zdGFja3RyYWNlICYmIGUuc3RhY2sgLT4gb3BlcmExMGJcclxuICAgICAgICAgICAgaWYgKGUuc3RhY2t0cmFjZS5pbmRleE9mKFwiY2FsbGVkIGZyb20gbGluZVwiKSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnb3BlcmExMGInOyAvLyB1c2UgZS5zdGFja3RyYWNlLCBmb3JtYXQgZGlmZmVycyBmcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICdvcGVyYTEwYSdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBlLnN0YWNrdHJhY2UgJiYgZS5zdGFjayAtPiBvcGVyYTExXHJcbiAgICAgICAgICAgIHJldHVybiAnb3BlcmExMSc7IC8vIHVzZSBlLnN0YWNrdHJhY2UsIGZvcm1hdCBkaWZmZXJzIGZyb21cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnb3BlcmExMGEnLCAnb3BlcmExMGInXHJcbiAgICAgICAgfSBlbHNlIGlmIChlLnN0YWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnZmlyZWZveCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnb3RoZXInO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgY29udGV4dCwgZnVuY3Rpb24gbmFtZSwgYW5kIGNhbGxiYWNrIGZ1bmN0aW9uLCBvdmVyd3JpdGUgaXRcclxuICAgICAqIHNvIHRoYXQgaXQgY2FsbHMgcHJpbnRTdGFja1RyYWNlKCkgZmlyc3Qgd2l0aCBhIGNhbGxiYWNrIGFuZCB0aGVuXHJcbiAgICAgKiBydW5zIHRoZSByZXN0IG9mIHRoZSBib2R5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IG9mIGV4ZWN1dGlvbiAoZS5nLiB3aW5kb3cpXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZnVuY3Rpb25OYW1lIHRvIGluc3RydW1lbnRcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uIHRvIGNhbGwgd2l0aCBhIHN0YWNrIHRyYWNlIG9uIGludm9jYXRpb25cclxuICAgICAqL1xyXG4gICAgaW5zdHJ1bWVudEZ1bmN0aW9uIDogZnVuY3Rpb24oY29udGV4dCwgZnVuY3Rpb25OYW1lLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IHdpbmRvdztcclxuICAgICAgICB2YXIgb3JpZ2luYWwgPSBjb250ZXh0W2Z1bmN0aW9uTmFtZV07XHJcbiAgICAgICAgY29udGV4dFtmdW5jdGlvbk5hbWVdID0gZnVuY3Rpb24gaW5zdHJ1bWVudGVkKCkge1xyXG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHByaW50U3RhY2tUcmFjZSgpLnNsaWNlKDQpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRbZnVuY3Rpb25OYW1lXS5faW5zdHJ1bWVudGVkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb250ZXh0W2Z1bmN0aW9uTmFtZV0uX2luc3RydW1lbnRlZCA9IG9yaWdpbmFsO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgY29udGV4dCBhbmQgZnVuY3Rpb24gbmFtZSBvZiBhIGZ1bmN0aW9uIHRoYXQgaGFzIGJlZW5cclxuICAgICAqIGluc3RydW1lbnRlZCwgcmV2ZXJ0IHRoZSBmdW5jdGlvbiB0byBpdCdzIG9yaWdpbmFsIChub24taW5zdHJ1bWVudGVkKVxyXG4gICAgICogc3RhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgb2YgZXhlY3V0aW9uIChlLmcuIHdpbmRvdylcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmdW5jdGlvbk5hbWUgdG8gZGUtaW5zdHJ1bWVudFxyXG4gICAgICovXHJcbiAgICBkZWluc3RydW1lbnRGdW5jdGlvbiA6IGZ1bmN0aW9uKGNvbnRleHQsIGZ1bmN0aW9uTmFtZSkge1xyXG4gICAgICAgIGlmIChjb250ZXh0W2Z1bmN0aW9uTmFtZV0uY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uICYmIGNvbnRleHRbZnVuY3Rpb25OYW1lXS5faW5zdHJ1bWVudGVkXHJcbiAgICAgICAgICAgICAgICAmJiBjb250ZXh0W2Z1bmN0aW9uTmFtZV0uX2luc3RydW1lbnRlZC5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgY29udGV4dFtmdW5jdGlvbk5hbWVdID0gY29udGV4dFtmdW5jdGlvbk5hbWVdLl9pbnN0cnVtZW50ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIEVycm9yIG9iamVjdCwgcmV0dXJuIGEgZm9ybWF0dGVkIEFycmF5IGJhc2VkIG9uIENocm9tZSdzXHJcbiAgICAgKiBzdGFjayBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGUgLSBFcnJvciBvYmplY3QgdG8gaW5zcGVjdFxyXG4gICAgICogQHJldHVybiBBcnJheTxTdHJpbmc+IG9mIGZ1bmN0aW9uIGNhbGxzLCBmaWxlcyBhbmQgbGluZSBudW1iZXJzXHJcbiAgICAgKi9cclxuICAgIGNocm9tZSA6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICB2YXIgc3RhY2sgPSAoZS5zdGFjayArICdcXG4nKS5yZXBsYWNlKC9eXFxTW15cXChdKz9bXFxuJF0vZ20sICcnKS5yZXBsYWNlKC9eXFxzKyhhdCBldmFsICk/YXRcXHMrL2dtLCAnJykucmVwbGFjZSgvXihbXlxcKF0rPykoW1xcbiRdKS9nbSxcclxuICAgICAgICAgICAgICAgICd7YW5vbnltb3VzfSgpQCQxJDInKS5yZXBsYWNlKC9eT2JqZWN0Ljxhbm9ueW1vdXM+XFxzKlxcKChbXlxcKV0rKVxcKS9nbSwgJ3thbm9ueW1vdXN9KClAJDEnKS5zcGxpdCgnXFxuJyk7XHJcbiAgICAgICAgc3RhY2sucG9wKCk7XHJcbiAgICAgICAgcmV0dXJuIHN0YWNrO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIEVycm9yIG9iamVjdCwgcmV0dXJuIGEgZm9ybWF0dGVkIEFycmF5IGJhc2VkIG9uIFNhZmFyaSdzXHJcbiAgICAgKiBzdGFjayBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGUgLSBFcnJvciBvYmplY3QgdG8gaW5zcGVjdFxyXG4gICAgICogQHJldHVybiBBcnJheTxTdHJpbmc+IG9mIGZ1bmN0aW9uIGNhbGxzLCBmaWxlcyBhbmQgbGluZSBudW1iZXJzXHJcbiAgICAgKi9cclxuICAgIHNhZmFyaSA6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICByZXR1cm4gZS5zdGFjay5yZXBsYWNlKC9cXFtuYXRpdmUgY29kZVxcXVxcbi9tLCAnJykucmVwbGFjZSgvXkAvZ20sICd7YW5vbnltb3VzfSgpQCcpLnNwbGl0KCdcXG4nKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhbiBFcnJvciBvYmplY3QsIHJldHVybiBhIGZvcm1hdHRlZCBBcnJheSBiYXNlZCBvbiBGaXJlZm94J3NcclxuICAgICAqIHN0YWNrIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZSAtIEVycm9yIG9iamVjdCB0byBpbnNwZWN0XHJcbiAgICAgKiBAcmV0dXJuIEFycmF5PFN0cmluZz4gb2YgZnVuY3Rpb24gY2FsbHMsIGZpbGVzIGFuZCBsaW5lIG51bWJlcnNcclxuICAgICAqL1xyXG4gICAgZmlyZWZveCA6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICByZXR1cm4gZS5zdGFjay5yZXBsYWNlKC8oPzpcXG5AOjApP1xccyskL20sICcnKS5yZXBsYWNlKC9eW1xcKEBdL2dtLCAne2Fub255bW91c30oKUAnKS5zcGxpdCgnXFxuJyk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9wZXJhMTEgOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgdmFyIEFOT04gPSAne2Fub255bW91c30nLCBsaW5lUkUgPSAvXi4qbGluZSAoXFxkKyksIGNvbHVtbiAoXFxkKykoPzogaW4gKC4rKSk/IGluIChcXFMrKTokLztcclxuICAgICAgICB2YXIgbGluZXMgPSBlLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpLCByZXN1bHQgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lUkUuZXhlYyhsaW5lc1tpXSk7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gbWF0Y2hbNF0gKyAnOicgKyBtYXRjaFsxXSArICc6JyArIG1hdGNoWzJdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZuTmFtZSA9IG1hdGNoWzNdIHx8IFwiZ2xvYmFsIGNvZGVcIjtcclxuICAgICAgICAgICAgICAgIGZuTmFtZSA9IGZuTmFtZS5yZXBsYWNlKC88YW5vbnltb3VzIGZ1bmN0aW9uOiAoXFxTKyk+LywgXCIkMVwiKS5yZXBsYWNlKC88YW5vbnltb3VzIGZ1bmN0aW9uPi8sIEFOT04pO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZm5OYW1lICsgJ0AnICsgbG9jYXRpb24gKyAnIC0tICcgKyBsaW5lc1tpICsgMV0ucmVwbGFjZSgvXlxccysvLCAnJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuXHJcbiAgICBvcGVyYTEwYiA6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAvLyBcIjxhbm9ueW1vdXMgZnVuY3Rpb246IHJ1bj4oW2FyZ3VtZW50cyBub3RcclxuICAgICAgICAvLyBhdmFpbGFibGVdKUBmaWxlOi8vbG9jYWxob3N0L0c6L2pzL3N0YWNrdHJhY2UuanM6MjdcXG5cIiArXHJcbiAgICAgICAgLy8gXCJwcmludFN0YWNrVHJhY2UoW2FyZ3VtZW50cyBub3RcclxuICAgICAgICAvLyBhdmFpbGFibGVdKUBmaWxlOi8vbG9jYWxob3N0L0c6L2pzL3N0YWNrdHJhY2UuanM6MThcXG5cIiArXHJcbiAgICAgICAgLy8gXCJAZmlsZTovL2xvY2FsaG9zdC9HOi9qcy90ZXN0L2Z1bmN0aW9uYWwvdGVzdGNhc2UxLmh0bWw6MTVcIlxyXG4gICAgICAgIHZhciBsaW5lUkUgPSAvXiguKilAKC4rKTooXFxkKykkLztcclxuICAgICAgICB2YXIgbGluZXMgPSBlLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpLCByZXN1bHQgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lUkUuZXhlYyhsaW5lc1tpXSk7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZuTmFtZSA9IG1hdGNoWzFdID8gKG1hdGNoWzFdICsgJygpJykgOiBcImdsb2JhbCBjb2RlXCI7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmbk5hbWUgKyAnQCcgKyBtYXRjaFsyXSArICc6JyArIG1hdGNoWzNdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhbiBFcnJvciBvYmplY3QsIHJldHVybiBhIGZvcm1hdHRlZCBBcnJheSBiYXNlZCBvbiBPcGVyYSAxMCdzXHJcbiAgICAgKiBzdGFja3RyYWNlIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZSAtIEVycm9yIG9iamVjdCB0byBpbnNwZWN0XHJcbiAgICAgKiBAcmV0dXJuIEFycmF5PFN0cmluZz4gb2YgZnVuY3Rpb24gY2FsbHMsIGZpbGVzIGFuZCBsaW5lIG51bWJlcnNcclxuICAgICAqL1xyXG4gICAgb3BlcmExMGEgOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgLy8gXCIgTGluZSAyNyBvZiBsaW5rZWQgc2NyaXB0XHJcbiAgICAgICAgLy8gZmlsZTovL2xvY2FsaG9zdC9HOi9qcy9zdGFja3RyYWNlLmpzXFxuXCJcclxuICAgICAgICAvLyBcIiBMaW5lIDExIG9mIGlubGluZSMxIHNjcmlwdCBpblxyXG4gICAgICAgIC8vIGZpbGU6Ly9sb2NhbGhvc3QvRzovanMvdGVzdC9mdW5jdGlvbmFsL3Rlc3RjYXNlMS5odG1sOiBJblxyXG4gICAgICAgIC8vIGZ1bmN0aW9uIGZvb1xcblwiXHJcbiAgICAgICAgdmFyIEFOT04gPSAne2Fub255bW91c30nLCBsaW5lUkUgPSAvTGluZSAoXFxkKykuKnNjcmlwdCAoPzppbiApPyhcXFMrKSg/OjogSW4gZnVuY3Rpb24gKFxcUyspKT8kL2k7XHJcbiAgICAgICAgdmFyIGxpbmVzID0gZS5zdGFja3RyYWNlLnNwbGl0KCdcXG4nKSwgcmVzdWx0ID0gW107XHJcblxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgdmFyIG1hdGNoID0gbGluZVJFLmV4ZWMobGluZXNbaV0pO1xyXG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmbk5hbWUgPSBtYXRjaFszXSB8fCBBTk9OO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZm5OYW1lICsgJygpQCcgKyBtYXRjaFsyXSArICc6JyArIG1hdGNoWzFdICsgJyAtLSAnICsgbGluZXNbaSArIDFdLnJlcGxhY2UoL15cXHMrLywgJycpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gT3BlcmEgNy54LTkuMnggb25seSFcclxuICAgIG9wZXJhOSA6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAvLyBcIiBMaW5lIDQzIG9mIGxpbmtlZCBzY3JpcHRcclxuICAgICAgICAvLyBmaWxlOi8vbG9jYWxob3N0L0c6L2pzL3N0YWNrdHJhY2UuanNcXG5cIlxyXG4gICAgICAgIC8vIFwiIExpbmUgNyBvZiBpbmxpbmUjMSBzY3JpcHQgaW5cclxuICAgICAgICAvLyBmaWxlOi8vbG9jYWxob3N0L0c6L2pzL3Rlc3QvZnVuY3Rpb25hbC90ZXN0Y2FzZTEuaHRtbFxcblwiXHJcbiAgICAgICAgdmFyIEFOT04gPSAne2Fub255bW91c30nLCBsaW5lUkUgPSAvTGluZSAoXFxkKykuKnNjcmlwdCAoPzppbiApPyhcXFMrKS9pO1xyXG4gICAgICAgIHZhciBsaW5lcyA9IGUubWVzc2FnZS5zcGxpdCgnXFxuJyksIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDIsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGxpbmVSRS5leGVjKGxpbmVzW2ldKTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChBTk9OICsgJygpQCcgKyBtYXRjaFsyXSArICc6JyArIG1hdGNoWzFdICsgJyAtLSAnICsgbGluZXNbaSArIDFdLnJlcGxhY2UoL15cXHMrLywgJycpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gU2FmYXJpIDUtLCBJRSA5LSwgYW5kIG90aGVyc1xyXG4gICAgb3RoZXIgOiBmdW5jdGlvbihjdXJyKSB7XHJcbiAgICAgICAgdmFyIEFOT04gPSAne2Fub255bW91c30nLCBmblJFID0gL2Z1bmN0aW9uXFxzKihbXFx3XFwtJF0rKT9cXHMqXFwoL2ksIHN0YWNrID0gW10sIGZuLCBhcmdzLCBtYXhTdGFja1NpemUgPSAxMDtcclxuICAgICAgICB3aGlsZSAoY3VyciAmJiBjdXJyWydhcmd1bWVudHMnXSAmJiBzdGFjay5sZW5ndGggPCBtYXhTdGFja1NpemUpIHtcclxuICAgICAgICAgICAgZm4gPSBmblJFLnRlc3QoY3Vyci50b1N0cmluZygpKSA/IFJlZ0V4cC4kMSB8fCBBTk9OIDogQU5PTjtcclxuICAgICAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGN1cnJbJ2FyZ3VtZW50cyddIHx8IFtdKTtcclxuICAgICAgICAgICAgc3RhY2tbc3RhY2subGVuZ3RoXSA9IGZuICsgJygnICsgdGhpcy5zdHJpbmdpZnlBcmd1bWVudHMoYXJncykgKyAnKSc7XHJcbiAgICAgICAgICAgIGN1cnIgPSBjdXJyLmNhbGxlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0YWNrO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFyZ3VtZW50cyBhcnJheSBhcyBhIFN0cmluZywgc3Vic2l0dXRpbmcgdHlwZSBuYW1lcyBmb3JcclxuICAgICAqIG5vbi1zdHJpbmcgdHlwZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcmd1bWVudHN9IGFyZ3NcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSBvZiBTdHJpbmdzIHdpdGggc3RyaW5naWZpZWQgYXJndW1lbnRzXHJcbiAgICAgKi9cclxuICAgIHN0cmluZ2lmeUFyZ3VtZW50cyA6IGZ1bmN0aW9uKGFyZ3MpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGFyZyA9IGFyZ3NbaV07XHJcbiAgICAgICAgICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gJ3VuZGVmaW5lZCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSAnbnVsbCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnLmNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoIDwgMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSAnWycgKyB0aGlzLnN0cmluZ2lmeUFyZ3VtZW50cyhhcmcpICsgJ10nO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9ICdbJyArIHRoaXMuc3RyaW5naWZ5QXJndW1lbnRzKHNsaWNlLmNhbGwoYXJnLCAwLCAxKSkgKyAnLi4uJyArIHRoaXMuc3RyaW5naWZ5QXJndW1lbnRzKHNsaWNlLmNhbGwoYXJnLCAtMSkpICsgJ10nO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSAnI29iamVjdCc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSAnI2Z1bmN0aW9uJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSAnXCInICsgYXJnICsgJ1wiJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBhcmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcsJyk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNvdXJjZUNhY2hlIDoge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHRoZSB0ZXh0IGZyb20gYSBnaXZlbiBVUkxcclxuICAgICAqL1xyXG4gICAgYWpheCA6IGZ1bmN0aW9uKHVybCkge1xyXG4gICAgICAgIHZhciByZXEgPSB0aGlzLmNyZWF0ZVhNTEhUVFBPYmplY3QoKTtcclxuICAgICAgICBpZiAocmVxKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXEub3BlbignR0VUJywgdXJsLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAvLyByZXEub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbicpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVxLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvamF2YXNjcmlwdCcpO1xyXG4gICAgICAgICAgICAgICAgcmVxLnNlbmQobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gcmVxLnN0YXR1cyA9PSAyMDAgPyByZXEucmVzcG9uc2VUZXh0IDogJyc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxLnJlc3BvbnNlVGV4dDtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcnkgWEhSIG1ldGhvZHMgaW4gb3JkZXIgYW5kIHN0b3JlIFhIUiBmYWN0b3J5LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gPEZ1bmN0aW9uPiBYSFIgZnVuY3Rpb24gb3IgZXF1aXZhbGVudFxyXG4gICAgICovXHJcbiAgICBjcmVhdGVYTUxIVFRQT2JqZWN0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHhtbGh0dHAsIFhNTEh0dHBGYWN0b3JpZXMgPSBbIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAnKTtcclxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDMuWE1MSFRUUCcpO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7XHJcbiAgICAgICAgfSBdO1xyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IFhNTEh0dHBGYWN0b3JpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHhtbGh0dHAgPSBYTUxIdHRwRmFjdG9yaWVzW2ldKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBVc2UgbWVtb2l6YXRpb24gdG8gY2FjaGUgdGhlIGZhY3RvcnlcclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlWE1MSFRUUE9iamVjdCA9IFhNTEh0dHBGYWN0b3JpZXNbaV07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geG1saHR0cDtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgVVJMLCBjaGVjayBpZiBpdCBpcyBpbiB0aGUgc2FtZSBkb21haW4gKHNvIHdlIGNhbiBnZXQgdGhlXHJcbiAgICAgKiBzb3VyY2UgdmlhIEFqYXgpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1cmwgPFN0cmluZz4gc291cmNlIHVybFxyXG4gICAgICogQHJldHVybiBGYWxzZSBpZiB3ZSBuZWVkIGEgY3Jvc3MtZG9tYWluIHJlcXVlc3RcclxuICAgICAqL1xyXG4gICAgaXNTYW1lRG9tYWluIDogZnVuY3Rpb24odXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBsb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiAmJiB1cmwuaW5kZXhPZihsb2NhdGlvbi5ob3N0bmFtZSkgIT09IC0xOyAvLyBsb2NhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1heVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlLmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJ1bm5pbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9kZWpzLlxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBzb3VyY2UgY29kZSBmcm9tIGdpdmVuIFVSTCBpZiBpbiB0aGUgc2FtZSBkb21haW4uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVybCA8U3RyaW5nPiBKUyBzb3VyY2UgVVJMXHJcbiAgICAgKiBAcmV0dXJuIDxBcnJheT4gQXJyYXkgb2Ygc291cmNlIGNvZGUgbGluZXNcclxuICAgICAqL1xyXG4gICAgZ2V0U291cmNlIDogZnVuY3Rpb24odXJsKSB7XHJcbiAgICAgICAgLy8gVE9ETyByZXVzZSBzb3VyY2UgZnJvbSBzY3JpcHQgdGFncz9cclxuICAgICAgICBpZiAoISh1cmwgaW4gdGhpcy5zb3VyY2VDYWNoZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2VDYWNoZVt1cmxdID0gdGhpcy5hamF4KHVybCkuc3BsaXQoJ1xcbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VDYWNoZVt1cmxdO1xyXG4gICAgfSxcclxuXHJcbiAgICBndWVzc0Fub255bW91c0Z1bmN0aW9ucyA6IGZ1bmN0aW9uKHN0YWNrKSB7XHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHJlU3RhY2sgPSAvXFx7YW5vbnltb3VzXFx9XFwoLipcXClAKC4qKS8sIHJlUmVmID0gL14oLio/KSg/OjooXFxkKykpKD86OihcXGQrKSk/KD86IC0tIC4rKT8kLywgZnJhbWUgPSBzdGFja1tpXSwgcmVmID0gcmVTdGFjay5leGVjKGZyYW1lKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZWYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtID0gcmVSZWYuZXhlYyhyZWZbMV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKG0pIHsgLy8gSWYgZmFsc2V5LCB3ZSBkaWQgbm90IGdldCBhbnkgZmlsZS9saW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmZvcm1hdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxlID0gbVsxXSwgbGluZW5vID0gbVsyXSwgY2hhcm5vID0gbVszXSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlICYmIHRoaXMuaXNTYW1lRG9tYWluKGZpbGUpICYmIGxpbmVubykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gdGhpcy5ndWVzc0Fub255bW91c0Z1bmN0aW9uKGZpbGUsIGxpbmVubywgY2hhcm5vKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tbaV0gPSBmcmFtZS5yZXBsYWNlKCd7YW5vbnltb3VzfScsIGZ1bmN0aW9uTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdGFjaztcclxuICAgIH0sXHJcblxyXG4gICAgZ3Vlc3NBbm9ueW1vdXNGdW5jdGlvbiA6IGZ1bmN0aW9uKHVybCwgbGluZU5vLCBjaGFyTm8pIHtcclxuICAgICAgICB2YXIgcmV0O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldCA9IHRoaXMuZmluZEZ1bmN0aW9uTmFtZSh0aGlzLmdldFNvdXJjZSh1cmwpLCBsaW5lTm8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmV0ID0gJ2dldFNvdXJjZSBmYWlsZWQgd2l0aCB1cmw6ICcgKyB1cmwgKyAnLCBleGNlcHRpb246ICcgKyBlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGZpbmRGdW5jdGlvbk5hbWUgOiBmdW5jdGlvbihzb3VyY2UsIGxpbmVObykge1xyXG4gICAgICAgIC8vIEZJWE1FIGZpbmRGdW5jdGlvbk5hbWUgZmFpbHMgZm9yIGNvbXByZXNzZWQgc291cmNlXHJcbiAgICAgICAgLy8gKG1vcmUgdGhhbiBvbmUgZnVuY3Rpb24gb24gdGhlIHNhbWUgbGluZSlcclxuICAgICAgICAvLyBUT0RPIHVzZSBjYXB0dXJlZCBhcmdzXHJcbiAgICAgICAgLy8gZnVuY3Rpb24ge25hbWV9KHthcmdzfSkgbVsxXT1uYW1lIG1bMl09YXJnc1xyXG4gICAgICAgIHZhciByZUZ1bmN0aW9uRGVjbGFyYXRpb24gPSAvZnVuY3Rpb25cXHMrKFteKF0qPylcXHMqXFwoKFteKV0qKVxcKS87XHJcbiAgICAgICAgLy8ge25hbWV9ID0gZnVuY3Rpb24gKHthcmdzfSkgVE9ETyBhcmdzIGNhcHR1cmVcclxuICAgICAgICAvLyAvWydcIl0/KFswLTlBLVphLXpfXSspWydcIl0/XFxzKls6PV1cXHMqZnVuY3Rpb24oPzpbXihdKikvXHJcbiAgICAgICAgdmFyIHJlRnVuY3Rpb25FeHByZXNzaW9uID0gL1snXCJdPyhbMC05QS1aYS16X10rKVsnXCJdP1xccypbOj1dXFxzKmZ1bmN0aW9uXFxiLztcclxuICAgICAgICAvLyB7bmFtZX0gPSBldmFsKClcclxuICAgICAgICB2YXIgcmVGdW5jdGlvbkV2YWx1YXRpb24gPSAvWydcIl0/KFswLTlBLVphLXpfXSspWydcIl0/XFxzKls6PV1cXHMqKD86ZXZhbHxuZXcgRnVuY3Rpb24pXFxiLztcclxuICAgICAgICAvLyBXYWxrIGJhY2t3YXJkcyBpbiB0aGUgc291cmNlIGxpbmVzIHVudGlsIHdlIGZpbmRcclxuICAgICAgICAvLyB0aGUgbGluZSB3aGljaCBtYXRjaGVzIG9uZSBvZiB0aGUgcGF0dGVybnMgYWJvdmVcclxuICAgICAgICB2YXIgY29kZSA9IFwiXCIsIGxpbmUsIG1heExpbmVzID0gTWF0aC5taW4obGluZU5vLCAyMCksIG0sIGNvbW1lbnRQb3M7XHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbWF4TGluZXM7ICsraSkge1xyXG4gICAgICAgICAgICAvLyBsaW5lTm8gaXMgMS1iYXNlZCwgc291cmNlW10gaXMgMC1iYXNlZFxyXG4gICAgICAgICAgICBsaW5lID0gc291cmNlW2xpbmVObyAtIGkgLSAxXTtcclxuICAgICAgICAgICAgY29tbWVudFBvcyA9IGxpbmUuaW5kZXhPZignLy8nKTtcclxuICAgICAgICAgICAgaWYgKGNvbW1lbnRQb3MgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKDAsIGNvbW1lbnRQb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRPRE8gY2hlY2sgb3RoZXIgdHlwZXMgb2YgY29tbWVudHM/IENvbW1lbnRlZCBjb2RlIG1heSBsZWFkIHRvIGZhbHNlIHBvc2l0aXZlXHJcbiAgICAgICAgICAgIGlmIChsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlID0gbGluZSArIGNvZGU7XHJcbiAgICAgICAgICAgICAgICBtID0gcmVGdW5jdGlvbkV4cHJlc3Npb24uZXhlYyhjb2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChtICYmIG1bMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbVsxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG0gPSByZUZ1bmN0aW9uRGVjbGFyYXRpb24uZXhlYyhjb2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChtICYmIG1bMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBtWzFdICsgXCIoXCIgKyAobVsyXSB8fCBcIlwiKSArIFwiKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtWzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbSA9IHJlRnVuY3Rpb25FdmFsdWF0aW9uLmV4ZWMoY29kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobSAmJiBtWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1bMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcoPyknO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBwcmludFN0YWNrVHJhY2U7IiwiXHJcbnZhciBTdGF0ZU1hY2hpbmUgPSB7XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICBWRVJTSU9OOiBcIjIuMi4wXCIsXHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICBSZXN1bHQ6IHtcclxuICAgICAgU1VDQ0VFREVEOiAgICAxLCAvLyB0aGUgZXZlbnQgdHJhbnNpdGlvbmVkIHN1Y2Nlc3NmdWxseSBmcm9tIG9uZSBzdGF0ZSB0byBhbm90aGVyXHJcbiAgICAgIE5PVFJBTlNJVElPTjogMiwgLy8gdGhlIGV2ZW50IHdhcyBzdWNjZXNzZnVsbCBidXQgbm8gc3RhdGUgdHJhbnNpdGlvbiB3YXMgbmVjZXNzYXJ5XHJcbiAgICAgIENBTkNFTExFRDogICAgMywgLy8gdGhlIGV2ZW50IHdhcyBjYW5jZWxsZWQgYnkgdGhlIGNhbGxlciBpbiBhIGJlZm9yZUV2ZW50IGNhbGxiYWNrXHJcbiAgICAgIEFTWU5DOiAgICAgICAgNCAvLyB0aGUgZXZlbnQgaXMgYXN5bmNocm9ub3VzIGFuZCB0aGUgY2FsbGVyIGlzIGluIGNvbnRyb2wgb2Ygd2hlbiB0aGUgdHJhbnNpdGlvbiBvY2N1cnNcclxuICAgIH0sXHJcblxyXG4gICAgRXJyb3I6IHtcclxuICAgICAgSU5WQUxJRF9UUkFOU0lUSU9OOiAxMDAsIC8vIGNhbGxlciB0cmllZCB0byBmaXJlIGFuIGV2ZW50IHRoYXQgd2FzIGlubmFwcm9wcmlhdGUgaW4gdGhlIGN1cnJlbnQgc3RhdGVcclxuICAgICAgUEVORElOR19UUkFOU0lUSU9OOiAyMDAsIC8vIGNhbGxlciB0cmllZCB0byBmaXJlIGFuIGV2ZW50IHdoaWxlIGFuIGFzeW5jIHRyYW5zaXRpb24gd2FzIHN0aWxsIHBlbmRpbmdcclxuICAgICAgSU5WQUxJRF9DQUxMQkFDSzogICAzMDAgLy8gY2FsbGVyIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIHRocmV3IGFuIGV4Y2VwdGlvblxyXG4gICAgfSxcclxuXHJcbiAgICBXSUxEQ0FSRDogJyonLFxyXG4gICAgQVNZTkM6ICdhc3luYycsXHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKGNmZywgdGFyZ2V0KSB7XHJcblxyXG4gICAgICB2YXIgaW5pdGlhbCAgID0gKHR5cGVvZiBjZmcuaW5pdGlhbCA9PSAnc3RyaW5nJykgPyB7IHN0YXRlOiBjZmcuaW5pdGlhbCB9IDogY2ZnLmluaXRpYWw7IC8vIGFsbG93IGZvciBhIHNpbXBsZSBzdHJpbmcsIG9yIGFuIG9iamVjdCB3aXRoIHsgc3RhdGU6ICdmb28nLCBldmVudDogJ3NldHVwJywgZGVmZXI6IHRydWV8ZmFsc2UgfVxyXG4gICAgICB2YXIgZnNtICAgICAgID0gdGFyZ2V0IHx8IGNmZy50YXJnZXQgIHx8IHt9O1xyXG4gICAgICB2YXIgZXZlbnRzICAgID0gY2ZnLmV2ZW50cyB8fCBbXTtcclxuICAgICAgdmFyIGNhbGxiYWNrcyA9IGNmZy5jYWxsYmFja3MgfHwge307XHJcbiAgICAgIHZhciBtYXAgICAgICAgPSB7fTtcclxuXHJcbiAgICAgIHZhciBhZGQgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgdmFyIGZyb20gPSAoZS5mcm9tIGluc3RhbmNlb2YgQXJyYXkpID8gZS5mcm9tIDogKGUuZnJvbSA/IFtlLmZyb21dIDogW1N0YXRlTWFjaGluZS5XSUxEQ0FSRF0pOyAvLyBhbGxvdyAnd2lsZGNhcmQnIHRyYW5zaXRpb24gaWYgJ2Zyb20nIGlzIG5vdCBzcGVjaWZpZWRcclxuICAgICAgICBtYXBbZS5uYW1lXSA9IG1hcFtlLm5hbWVdIHx8IHt9O1xyXG4gICAgICAgIGZvciAodmFyIG4gPSAwIDsgbiA8IGZyb20ubGVuZ3RoIDsgbisrKVxyXG4gICAgICAgICAgbWFwW2UubmFtZV1bZnJvbVtuXV0gPSBlLnRvIHx8IGZyb21bbl07IC8vIGFsbG93IG5vLW9wIHRyYW5zaXRpb24gaWYgJ3RvJyBpcyBub3Qgc3BlY2lmaWVkXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAoaW5pdGlhbCkge1xyXG4gICAgICAgIGluaXRpYWwuZXZlbnQgPSBpbml0aWFsLmV2ZW50IHx8ICdzdGFydHVwJztcclxuICAgICAgICBhZGQoeyBuYW1lOiBpbml0aWFsLmV2ZW50LCBmcm9tOiAnbm9uZScsIHRvOiBpbml0aWFsLnN0YXRlIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IodmFyIG4gPSAwIDsgbiA8IGV2ZW50cy5sZW5ndGggOyBuKyspXHJcbiAgICAgICAgYWRkKGV2ZW50c1tuXSk7XHJcblxyXG4gICAgICBmb3IodmFyIG5hbWUgaW4gbWFwKSB7XHJcbiAgICAgICAgaWYgKG1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcclxuICAgICAgICAgIGZzbVtuYW1lXSA9IFN0YXRlTWFjaGluZS5idWlsZEV2ZW50KG5hbWUsIG1hcFtuYW1lXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvcih2YXIgbmFtZSBpbiBjYWxsYmFja3MpIHtcclxuICAgICAgICBpZiAoY2FsbGJhY2tzLmhhc093blByb3BlcnR5KG5hbWUpKVxyXG4gICAgICAgICAgZnNtW25hbWVdID0gY2FsbGJhY2tzW25hbWVdXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZzbS5jdXJyZW50ID0gJ25vbmUnO1xyXG4gICAgICBmc20uaXMgICAgICA9IGZ1bmN0aW9uKHN0YXRlKSB7IHJldHVybiB0aGlzLmN1cnJlbnQgPT0gc3RhdGU7IH07XHJcbiAgICAgIGZzbS5jYW4gICAgID0gZnVuY3Rpb24oZXZlbnQpIHsgcmV0dXJuICF0aGlzLnRyYW5zaXRpb24gJiYgKG1hcFtldmVudF0uaGFzT3duUHJvcGVydHkodGhpcy5jdXJyZW50KSB8fCBtYXBbZXZlbnRdLmhhc093blByb3BlcnR5KFN0YXRlTWFjaGluZS5XSUxEQ0FSRCkpOyB9XHJcbiAgICAgIGZzbS5jYW5ub3QgID0gZnVuY3Rpb24oZXZlbnQpIHsgcmV0dXJuICF0aGlzLmNhbihldmVudCk7IH07XHJcbiAgICAgIGZzbS5lcnJvciAgID0gY2ZnLmVycm9yIHx8IGZ1bmN0aW9uKG5hbWUsIGZyb20sIHRvLCBhcmdzLCBlcnJvciwgbXNnLCBlKSB7IHRocm93IGUgfHwgbXNnOyB9OyAvLyBkZWZhdWx0IGJlaGF2aW9yIHdoZW4gc29tZXRoaW5nIHVuZXhwZWN0ZWQgaGFwcGVucyBpcyB0byB0aHJvdyBhbiBleGNlcHRpb24sIGJ1dCBjYWxsZXIgY2FuIG92ZXJyaWRlIHRoaXMgYmVoYXZpb3IgaWYgZGVzaXJlZCAoc2VlIGdpdGh1YiBpc3N1ZSAjMyBhbmQgIzE3KVxyXG5cclxuICAgICAgaWYgKGluaXRpYWwgJiYgIWluaXRpYWwuZGVmZXIpXHJcbiAgICAgICAgZnNtW2luaXRpYWwuZXZlbnRdKCk7XHJcblxyXG4gICAgICByZXR1cm4gZnNtO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBkb0NhbGxiYWNrOiBmdW5jdGlvbihmc20sIGZ1bmMsIG5hbWUsIGZyb20sIHRvLCBhcmdzKSB7XHJcbiAgICAgIGlmIChmdW5jKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGZzbSwgW25hbWUsIGZyb20sIHRvXS5jb25jYXQoYXJncykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICByZXR1cm4gZnNtLmVycm9yKG5hbWUsIGZyb20sIHRvLCBhcmdzLCBTdGF0ZU1hY2hpbmUuRXJyb3IuSU5WQUxJRF9DQUxMQkFDSywgXCJhbiBleGNlcHRpb24gb2NjdXJyZWQgaW4gYSBjYWxsZXItcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb25cIiwgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGJlZm9yZUV2ZW50OiBmdW5jdGlvbihmc20sIG5hbWUsIGZyb20sIHRvLCBhcmdzKSB7IHJldHVybiBTdGF0ZU1hY2hpbmUuZG9DYWxsYmFjayhmc20sIGZzbVsnb25iZWZvcmUnICsgbmFtZV0sICAgICAgICAgICAgICAgICAgICAgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpOyB9LFxyXG4gICAgYWZ0ZXJFdmVudDogIGZ1bmN0aW9uKGZzbSwgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpIHsgcmV0dXJuIFN0YXRlTWFjaGluZS5kb0NhbGxiYWNrKGZzbSwgZnNtWydvbmFmdGVyJyAgKyBuYW1lXSB8fCBmc21bJ29uJyArIG5hbWVdLCBuYW1lLCBmcm9tLCB0bywgYXJncyk7IH0sXHJcbiAgICBsZWF2ZVN0YXRlOiAgZnVuY3Rpb24oZnNtLCBuYW1lLCBmcm9tLCB0bywgYXJncykgeyByZXR1cm4gU3RhdGVNYWNoaW5lLmRvQ2FsbGJhY2soZnNtLCBmc21bJ29ubGVhdmUnICArIGZyb21dLCAgICAgICAgICAgICAgICAgICAgIG5hbWUsIGZyb20sIHRvLCBhcmdzKTsgfSxcclxuICAgIGVudGVyU3RhdGU6ICBmdW5jdGlvbihmc20sIG5hbWUsIGZyb20sIHRvLCBhcmdzKSB7IHJldHVybiBTdGF0ZU1hY2hpbmUuZG9DYWxsYmFjayhmc20sIGZzbVsnb25lbnRlcicgICsgdG9dICAgfHwgZnNtWydvbicgKyB0b10sICAgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpOyB9LFxyXG4gICAgY2hhbmdlU3RhdGU6IGZ1bmN0aW9uKGZzbSwgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpIHsgcmV0dXJuIFN0YXRlTWFjaGluZS5kb0NhbGxiYWNrKGZzbSwgZnNtWydvbmNoYW5nZXN0YXRlJ10sICAgICAgICAgICAgICAgICAgICAgICBuYW1lLCBmcm9tLCB0bywgYXJncyk7IH0sXHJcblxyXG5cclxuICAgIGJ1aWxkRXZlbnQ6IGZ1bmN0aW9uKG5hbWUsIG1hcCkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBmcm9tICA9IHRoaXMuY3VycmVudDtcclxuICAgICAgICB2YXIgdG8gICAgPSBtYXBbZnJvbV0gfHwgbWFwW1N0YXRlTWFjaGluZS5XSUxEQ0FSRF0gfHwgZnJvbTtcclxuICAgICAgICB2YXIgYXJncyAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpOyAvLyB0dXJuIGFyZ3VtZW50cyBpbnRvIHB1cmUgYXJyYXlcclxuXHJcbiAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvbilcclxuICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKG5hbWUsIGZyb20sIHRvLCBhcmdzLCBTdGF0ZU1hY2hpbmUuRXJyb3IuUEVORElOR19UUkFOU0lUSU9OLCBcImV2ZW50IFwiICsgbmFtZSArIFwiIGluYXBwcm9wcmlhdGUgYmVjYXVzZSBwcmV2aW91cyB0cmFuc2l0aW9uIGRpZCBub3QgY29tcGxldGVcIik7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmNhbm5vdChuYW1lKSlcclxuICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKG5hbWUsIGZyb20sIHRvLCBhcmdzLCBTdGF0ZU1hY2hpbmUuRXJyb3IuSU5WQUxJRF9UUkFOU0lUSU9OLCBcImV2ZW50IFwiICsgbmFtZSArIFwiIGluYXBwcm9wcmlhdGUgaW4gY3VycmVudCBzdGF0ZSBcIiArIHRoaXMuY3VycmVudCk7XHJcblxyXG4gICAgICAgIGlmIChmYWxzZSA9PT0gU3RhdGVNYWNoaW5lLmJlZm9yZUV2ZW50KHRoaXMsIG5hbWUsIGZyb20sIHRvLCBhcmdzKSlcclxuICAgICAgICAgIHJldHVybiBTdGF0ZU1hY2hpbmUuUmVzdWx0LkNBTkNFTExFRDtcclxuXHJcbiAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XHJcbiAgICAgICAgICBTdGF0ZU1hY2hpbmUuYWZ0ZXJFdmVudCh0aGlzLCBuYW1lLCBmcm9tLCB0bywgYXJncyk7XHJcbiAgICAgICAgICByZXR1cm4gU3RhdGVNYWNoaW5lLlJlc3VsdC5OT1RSQU5TSVRJT047XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBwcmVwYXJlIGEgdHJhbnNpdGlvbiBtZXRob2QgZm9yIHVzZSBFSVRIRVIgbG93ZXIgZG93biwgb3IgYnkgY2FsbGVyIGlmIHRoZXkgd2FudCBhbiBhc3luYyB0cmFuc2l0aW9uIChpbmRpY2F0ZWQgYnkgYW4gQVNZTkMgcmV0dXJuIHZhbHVlIGZyb20gbGVhdmVTdGF0ZSlcclxuICAgICAgICB2YXIgZnNtID0gdGhpcztcclxuICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGZzbS50cmFuc2l0aW9uID0gbnVsbDsgLy8gdGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgZXZlciBiZSBjYWxsZWQgb25jZVxyXG4gICAgICAgICAgZnNtLmN1cnJlbnQgPSB0bztcclxuICAgICAgICAgIFN0YXRlTWFjaGluZS5lbnRlclN0YXRlKCBmc20sIG5hbWUsIGZyb20sIHRvLCBhcmdzKTtcclxuICAgICAgICAgIFN0YXRlTWFjaGluZS5jaGFuZ2VTdGF0ZShmc20sIG5hbWUsIGZyb20sIHRvLCBhcmdzKTtcclxuICAgICAgICAgIFN0YXRlTWFjaGluZS5hZnRlckV2ZW50KCBmc20sIG5hbWUsIGZyb20sIHRvLCBhcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMudHJhbnNpdGlvbi5jYW5jZWwgPSBmdW5jdGlvbigpIHsgLy8gcHJvdmlkZSBhIHdheSBmb3IgY2FsbGVyIHRvIGNhbmNlbCBhc3luYyB0cmFuc2l0aW9uIGlmIGRlc2lyZWQgKGlzc3VlICMyMilcclxuICAgICAgICAgIGZzbS50cmFuc2l0aW9uID0gbnVsbDtcclxuICAgICAgICAgIFN0YXRlTWFjaGluZS5hZnRlckV2ZW50KGZzbSwgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBsZWF2ZSA9IFN0YXRlTWFjaGluZS5sZWF2ZVN0YXRlKHRoaXMsIG5hbWUsIGZyb20sIHRvLCBhcmdzKTtcclxuICAgICAgICBpZiAoZmFsc2UgPT09IGxlYXZlKSB7XHJcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgcmV0dXJuIFN0YXRlTWFjaGluZS5SZXN1bHQuQ0FOQ0VMTEVEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChcImFzeW5jXCIgPT09IGxlYXZlKSB7XHJcbiAgICAgICAgICByZXR1cm4gU3RhdGVNYWNoaW5lLlJlc3VsdC5BU1lOQztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBpZiAodGhpcy50cmFuc2l0aW9uKVxyXG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24oKTsgLy8gaW4gY2FzZSB1c2VyIG1hbnVhbGx5IGNhbGxlZCB0cmFuc2l0aW9uKCkgYnV0IGZvcmdvdCB0byByZXR1cm4gQVNZTkNcclxuICAgICAgICAgIHJldHVybiBTdGF0ZU1hY2hpbmUuUmVzdWx0LlNVQ0NFRURFRDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxufTsgLy8gU3RhdGVNYWNoaW5lXHJcblxyXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuLyppZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZGVmaW5lKSB7XHJcbmRlZmluZShmdW5jdGlvbihyZXF1aXJlKSB7IHJldHVybiBTdGF0ZU1hY2hpbmU7IH0pO1xyXG59XHJcbmVsc2UgeyovXHJcbndpbmRvdy5TdGF0ZU1hY2hpbmUgPSBTdGF0ZU1hY2hpbmU7XHJcbi8qfSovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlTWFjaGluZTtcclxuXHJcbiIsInZhciBET01UcmFuc2Zvcm1GZXRjaGVyID0gcmVxdWlyZShcIi4uL3RyYW5zZm9ybS1mZXRjaGVyLmpzXCIpO1xyXG52YXIgRGF0YUFkYXB0ZXIgPSByZXF1aXJlKFwiLi9kYXRhLmpzXCIpO1xyXG52YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi8uLi94Zmxvdy9iYXNlLmpzXCIpO1xyXG52YXIgRGF0YU5vZGUgPSByZXF1aXJlKFwiLi4vLi4veGZsb3cvaW50ZXJmYWNlL2dyYXBoLmpzXCIpLkRhdGFOb2RlO1xyXG52YXIgZ2V0Q29tcHV0ZURhdGFmbG93VXJsID0gcmVxdWlyZShcIi4uLy4uL3hmbG93L2ludGVyZmFjZS9ncmFwaC5qc1wiKS5nZXRDb21wdXRlRGF0YWZsb3dVcmw7XHJcbnZhciBBc3NldCA9IHJlcXVpcmUoXCIuLi8uLi9hc3NldC9hc3NldC5qc1wiKS5Bc3NldDtcclxudmFyIFN1YkRhdGEgPSByZXF1aXJlKFwiLi4vLi4vYXNzZXQvYXNzZXQuanNcIikuU3ViRGF0YTtcclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xyXG52YXIgZGlzcGF0Y2hDdXN0b21FdmVudCA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9taXNjLmpzXCIpLmRpc3BhdGNoQ3VzdG9tRXZlbnQ7XHJcbnZhciBSZXNvdXJjZSA9IHJlcXVpcmUoXCIuLi8uLi9yZXNvdXJjZVwiKTtcclxuXHJcbnZhciBOb2RlQWRhcHRlciA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2FkYXB0ZXIuanNcIikuTm9kZUFkYXB0ZXI7XHJcbnZhciBjcmVhdGVDbGFzcyA9IFhNTDNELmNyZWF0ZUNsYXNzO1xyXG52YXIgQWRhcHRlckhhbmRsZSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2FkYXB0ZXJoYW5kbGUuanNcIik7XHJcblxyXG5cclxudmFyIEFzc2V0QWRhcHRlciA9IGZ1bmN0aW9uIChmYWN0b3J5LCBub2RlKSB7XHJcbiAgICBOb2RlQWRhcHRlci5jYWxsKHRoaXMsIGZhY3RvcnksIG5vZGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogIEB0eXBlIEFzc2V0XHJcbiAgICAgKiovXHJcbiAgICB0aGlzLmFzc2V0ID0gbmV3IEFzc2V0KHRoaXMubm9kZSk7XHJcbiAgICBpZiAobm9kZS5sb2NhbE5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJtb2RlbFwiKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1GZXRjaGVyID0gbmV3IERPTVRyYW5zZm9ybUZldGNoZXIodGhpcywgXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2Zvcm1cIik7XHJcbiAgICB9XHJcbn07XHJcblxyXG5jcmVhdGVDbGFzcyhBc3NldEFkYXB0ZXIsIE5vZGVBZGFwdGVyKTtcclxuXHJcbkFzc2V0QWRhcHRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuYXNzZXQuYWRkQ2hhbmdlTGlzdGVuZXIodGhpcyk7XHJcbiAgICB0aGlzLmFzc2V0LnNldE5hbWUodGhpcy5ub2RlLmdldEF0dHJpYnV0ZShcIm5hbWVcIikpO1xyXG4gICAgdXBkYXRlQWRhcHRlckhhbmRsZSh0aGlzLCBcInNyY1wiLCB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKFwic3JjXCIpKTtcclxuICAgIHVwZGF0ZVBpY2tGaWx0ZXIodGhpcyk7XHJcbiAgICB1cGRhdGVDaGlsZHJlbih0aGlzKTtcclxuICAgIHNldE1hdGVyaWFsVXJsKHRoaXMsIHRoaXMuYXNzZXQpO1xyXG4gICAgdGhpcy50cmFuc2Zvcm1GZXRjaGVyICYmIHRoaXMudHJhbnNmb3JtRmV0Y2hlci51cGRhdGUoKTtcclxufTtcclxuXHJcbkFzc2V0QWRhcHRlci5wcm90b3R5cGUub25Bc3NldExvYWRDaGFuZ2UgPSBmdW5jdGlvbiAoYXNzZXQsIG5ld0xldmVsLCBvbGRMZXZlbCkge1xyXG4gICAgaWYgKG5ld0xldmVsID09IEluZmluaXR5KSB7XHJcbiAgICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudCh0aGlzLm5vZGUsICdsb2FkJywgZmFsc2UsIHRydWUsIG51bGwpO1xyXG4gICAgfSBlbHNlIGlmIChuZXdMZXZlbCA+IG9sZExldmVsKSB7XHJcbiAgICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudCh0aGlzLm5vZGUsICdwcm9ncmVzcycsIGZhbHNlLCB0cnVlLCBudWxsKTtcclxuICAgIH1cclxufTtcclxuXHJcbkFzc2V0QWRhcHRlci5wcm90b3R5cGUuZ2V0QXNzZXRDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLmFzc2V0LmdldFByb2dyZXNzTGV2ZWwoKSA9PSBJbmZpbml0eTtcclxufTtcclxuQXNzZXRBZGFwdGVyLnByb3RvdHlwZS5nZXRBc3NldFByb2dyZXNzTGV2ZWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hc3NldC5nZXRQcm9ncmVzc0xldmVsKCk7XHJcbn07XHJcblxyXG5Bc3NldEFkYXB0ZXIucHJvdG90eXBlLmdldEFzc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXNzZXQ7XHJcbn07XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVDaGlsZHJlbihhZGFwdGVyKSB7XHJcbiAgICBhZGFwdGVyLmFzc2V0LmNsZWFyQ2hpbGRyZW4oKTtcclxuICAgIGFkYXB0ZXIuYXNzZXQuY2xlYXJTdWJBc3NldHMoKTtcclxuICAgIGZvciAodmFyIGNoaWxkID0gYWRhcHRlci5ub2RlLmZpcnN0RWxlbWVudENoaWxkOyBjaGlsZCAhPT0gbnVsbDsgY2hpbGQgPSBjaGlsZC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcclxuICAgICAgICB2YXIgc3ViYWRhcHRlciA9IGFkYXB0ZXIuZmFjdG9yeS5nZXRBZGFwdGVyKGNoaWxkKTtcclxuICAgICAgICBpZiAoc3ViYWRhcHRlciAmJiBzdWJhZGFwdGVyLmdldEFzc2V0KSB7XHJcbiAgICAgICAgICAgIGFkYXB0ZXIuYXNzZXQuYXBwZW5kU3ViQXNzZXQoc3ViYWRhcHRlci5nZXRBc3NldCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN1YmFkYXB0ZXIgJiYgc3ViYWRhcHRlci5hc3NldEVudHJ5KSB7XHJcbiAgICAgICAgICAgIGFkYXB0ZXIuYXNzZXQuYXBwZW5kQ2hpbGQoc3ViYWRhcHRlci5hc3NldEVudHJ5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUFkYXB0ZXJIYW5kbGUoYWRhcHRlciwga2V5LCB1cmwpIHtcclxuICAgIHZhciBhZGFwdGVySGFuZGxlID0gYWRhcHRlci5nZXRBZGFwdGVySGFuZGxlKHVybCksIHN0YXR1cyA9IChhZGFwdGVySGFuZGxlICYmIGFkYXB0ZXJIYW5kbGUuc3RhdHVzKTtcclxuXHJcbiAgICBpZiAoc3RhdHVzID09PSBBZGFwdGVySGFuZGxlLlNUQVRVUy5OT1RfRk9VTkQpIHtcclxuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGVsZW1lbnQgb2YgdXJsICdcIiArIGFkYXB0ZXJIYW5kbGUudXJsICsgXCInIGZvciBcIiArIGtleSwgYWRhcHRlci5ub2RlKTtcclxuICAgIH1cclxuICAgIGFkYXB0ZXIuY29ubmVjdEFkYXB0ZXJIYW5kbGUoa2V5LCBhZGFwdGVySGFuZGxlKTtcclxuICAgIGFkYXB0ZXIuY29ubmVjdGVkQWRhcHRlckNoYW5nZWQoa2V5LCBhZGFwdGVySGFuZGxlID8gYWRhcHRlckhhbmRsZS5nZXRBZGFwdGVyKCkgOiBudWxsLCBzdGF0dXMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVBc3NldExvYWRTdGF0ZShkYXRhQWRhcHRlcikge1xyXG4gICAgdmFyIGxvYWRpbmcgPSBmYWxzZSwgaGFuZGxlO1xyXG5cclxuICAgIGhhbmRsZSA9IGRhdGFBZGFwdGVyLmdldENvbm5lY3RlZEFkYXB0ZXJIYW5kbGUoXCJzcmNcIik7XHJcbiAgICBpZiAoaGFuZGxlICYmIGhhbmRsZS5zdGF0dXMgPT09IEFkYXB0ZXJIYW5kbGUuU1RBVFVTLkxPQURJTkcpIHtcclxuICAgICAgICBsb2FkaW5nID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGRhdGFBZGFwdGVyLmFzc2V0LnNldExvYWRpbmcobG9hZGluZyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZVBpY2tGaWx0ZXIoYWRhcHRlcikge1xyXG4gICAgaWYgKCFhZGFwdGVyLm5vZGUuaGFzQXR0cmlidXRlKFwicGlja1wiKSlcclxuICAgICAgICBhZGFwdGVyLmFzc2V0LnNldFBpY2tGaWx0ZXIobnVsbCk7IGVsc2Uge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IGFkYXB0ZXIubm9kZS5nZXRBdHRyaWJ1dGUoXCJwaWNrXCIpO1xyXG4gICAgICAgIGFkYXB0ZXIuYXNzZXQuc2V0UGlja0ZpbHRlcih2YWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbkFzc2V0QWRhcHRlci5wcm90b3R5cGUuY29ubmVjdGVkQWRhcHRlckNoYW5nZWQgPSBmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSwgYWRhcHRlcikge1xyXG4gICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT0gXCJzcmNcIilcclxuICAgICAgICB0aGlzLmFzc2V0LnNldFNyY0Fzc2V0KGFkYXB0ZXIgJiYgYWRhcHRlci5nZXRBc3NldCgpIHx8IG51bGwpO1xyXG4gICAgdXBkYXRlQXNzZXRMb2FkU3RhdGUodGhpcyk7XHJcbn07XHJcblxyXG5Bc3NldEFkYXB0ZXIucHJvdG90eXBlLm9uVHJhbnNmb3JtQ2hhbmdlID0gZnVuY3Rpb24gKGF0dHJOYW1lLCBtYXRyaXgpIHtcclxuICAgIHRoaXMuYXNzZXQuc2V0VHJhbnNmb3JtKG1hdHJpeCk7XHJcbn07XHJcblxyXG5Bc3NldEFkYXB0ZXIucHJvdG90eXBlLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayA9IGZ1bmN0aW9uKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xyXG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5hc3NldC5zZXROYW1lKG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibWF0ZXJpYWxcIjpcclxuICAgICAgICAgICAgICAgIHNldE1hdGVyaWFsVXJsKHRoaXMsIHRoaXMuYXNzZXQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzdHlsZVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwidHJhbnNmb3JtXCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybUZldGNoZXIgJiYgdGhpcy50cmFuc2Zvcm1GZXRjaGVyLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzcmNcIjpcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUFkYXB0ZXJIYW5kbGUodGhpcywgXCJzcmNcIiwgbmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwaWNrXCI6XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVQaWNrRmlsdGVyKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG59O1xyXG5cclxuXHJcbkFzc2V0QWRhcHRlci5wcm90b3R5cGUubm90aWZ5Q2hhbmdlZCA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgIGlmIChldnQudHlwZSA9PSBFdmVudHMuQURBUFRFUl9IQU5ETEVfQ0hBTkdFRCkge1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkQWRhcHRlckNoYW5nZWQoZXZ0LmtleSwgZXZ0LmFkYXB0ZXIpO1xyXG4gICAgICAgIGlmIChldnQuaGFuZGxlU3RhdHVzID09IEFkYXB0ZXJIYW5kbGUuU1RBVFVTLk5PVF9GT1VORCkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNvdWxkIG5vdCBmaW5kIDxhc3NldD4gZWxlbWVudCBvZiB1cmwgJ1wiICsgZXZ0LnVybCArIFwiJyBmb3IgXCIgKyBldnQua2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGV2dC50eXBlID09IEV2ZW50cy5OT0RFX0lOU0VSVEVEKSB7XHJcbiAgICAgICAgdXBkYXRlQ2hpbGRyZW4odGhpcyk7XHJcblxyXG4gICAgfSBlbHNlIGlmIChldnQudHlwZSA9PSBFdmVudHMuTk9ERV9SRU1PVkVEKSB7XHJcbiAgICAgICAgdXBkYXRlQ2hpbGRyZW4odGhpcyk7XHJcblxyXG4gICAgfSAgZWxzZSBpZiAoZXZ0LnR5cGUgPT0gRXZlbnRzLlRISVNfUkVNT1ZFRCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXJBZGFwdGVySGFuZGxlcygpO1xyXG4gICAgICAgIHRoaXMuYXNzZXQucmVtb3ZlQ2hhbmdlTGlzdGVuZXIodGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgQXNzZXREYXRhQWRhcHRlciA9IGZ1bmN0aW9uIChmYWN0b3J5LCBub2RlKSB7XHJcbiAgICB0aGlzLmFzc2V0RGF0YSA9IHRydWU7XHJcbiAgICBEYXRhQWRhcHRlci5jYWxsKHRoaXMsIGZhY3RvcnksIG5vZGUpO1xyXG5cclxuICAgIC8vIE5vZGUgaGFuZGxlcyBmb3Igc3JjIGFuZCBwcm90b1xyXG4gICAgdGhpcy5hc3NldEVudHJ5ID0gbnVsbDtcclxuICAgIHRoaXMub3V0cHV0WGZsb3dOb2RlID0gbnVsbDtcclxufTtcclxuY3JlYXRlQ2xhc3MoQXNzZXREYXRhQWRhcHRlciwgRGF0YUFkYXB0ZXIpO1xyXG5cclxuQXNzZXREYXRhQWRhcHRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIERhdGFBZGFwdGVyLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XHJcbiAgICB0aGlzLm91dHB1dFhmbG93Tm9kZSA9IG5ldyBBc3NldERhdGFOb2RlKGZhbHNlKTtcclxuICAgIHRoaXMuYXNzZXRFbnRyeSA9IG5ldyBTdWJEYXRhKHRoaXMub3V0cHV0WGZsb3dOb2RlLCB0aGlzLmdldFhmbG93Tm9kZSgpLCB0aGlzLm5vZGUpO1xyXG4gICAgdGhpcy5hc3NldEVudHJ5LnNldE5hbWUodGhpcy5ub2RlLmdldEF0dHJpYnV0ZShcIm5hbWVcIikpO1xyXG4gICAgdXBkYXRlQ2xhc3NOYW1lcyh0aGlzKTtcclxuICAgIHVwZGF0ZVBvc3RDb21wdXRlKHRoaXMpO1xyXG4gICAgdGhpcy5hc3NldEVudHJ5LnNldFBvc3RGaWx0ZXIodGhpcy5ub2RlLmdldEF0dHJpYnV0ZShcImZpbHRlclwiKSk7XHJcbiAgICB1cGRhdGVJbmNsdWRlcyh0aGlzLmFzc2V0RW50cnksIHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoXCJpbmNsdWRlc1wiKSk7XHJcbn07XHJcblxyXG5Bc3NldERhdGFBZGFwdGVyLnByb3RvdHlwZS5jb25uZWN0ZWRBZGFwdGVyQ2hhbmdlZCA9IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lLCBhZGFwdGVyKSB7XHJcbiAgICBpZiAoYXR0cmlidXRlTmFtZSA9PSBcInBvc3REYXRhZmxvd1wiKSB7XHJcbiAgICAgICAgdGhpcy5hc3NldEVudHJ5LnNldFBvc3REYXRhZmxvdyhhZGFwdGVyICYmIGFkYXB0ZXIuZ2V0WGZsb3dOb2RlKCkgfHwgbnVsbCk7XHJcbiAgICAgICAgdXBkYXRlU3ViRGF0YUxvYWRTdGF0ZSh0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgRGF0YUFkYXB0ZXIucHJvdG90eXBlLmNvbm5lY3RlZEFkYXB0ZXJDaGFuZ2VkLmNhbGwodGhpcywgYXR0cmlidXRlTmFtZSwgYWRhcHRlcik7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Bc3NldERhdGFBZGFwdGVyLnByb3RvdHlwZS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XHJcbiAgICBEYXRhQWRhcHRlci5wcm90b3R5cGUuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrLmNhbGwodGhpcywgbmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcclxuICAgIHN3aXRjaCAobmFtZSkge1xyXG4gICAgICAgIGNhc2UgXCJuYW1lXCI6XHJcbiAgICAgICAgICAgIHRoaXMuYXNzZXRFbnRyeS5zZXROYW1lKG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImNvbXB1dGVcIjpcclxuICAgICAgICAgICAgdXBkYXRlUG9zdENvbXB1dGUodGhpcyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJjbGFzc1wiOlxyXG4gICAgICAgICAgICB1cGRhdGVDbGFzc05hbWVzKHRoaXMpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiZmlsdGVyXCI6XHJcbiAgICAgICAgICAgIHRoaXMuYXNzZXRFbnRyeS5zZXRQb3N0RmlsdGVyKG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImluY2x1ZGVzXCI6XHJcbiAgICAgICAgICAgIHVwZGF0ZUluY2x1ZGVzKG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Bc3NldERhdGFBZGFwdGVyLnByb3RvdHlwZS5ub3RpZnlDaGFuZ2VkID0gZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgRGF0YUFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeUNoYW5nZWQuY2FsbCh0aGlzLCBldnQpO1xyXG5cclxufTtcclxuXHJcbkFzc2V0RGF0YUFkYXB0ZXIucHJvdG90eXBlLm9uVHJhbnNmb3JtQ2hhbmdlID0gZnVuY3Rpb24gKGF0dHJOYW1lLCBtYXRyaXgpIHtcclxuICAgIHRoaXMuYXNzZXRFbnRyeS5zZXRUcmFuc2Zvcm0obWF0cml4KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUluY2x1ZGVzKGFzc2V0RW50cnksIGluY2x1ZGVTdHJpbmcpIHtcclxuICAgIGlmICghaW5jbHVkZVN0cmluZylcclxuICAgICAgICBhc3NldEVudHJ5LnNldEluY2x1ZGVzKFtdKTsgZWxzZVxyXG4gICAgICAgIGFzc2V0RW50cnkuc2V0SW5jbHVkZXMoaW5jbHVkZVN0cmluZy50cmltKCkuc3BsaXQoL1xccyosXFxzKi8pKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlQ2xhc3NOYW1lcyhhZGFwdGVyKSB7XHJcbiAgICB2YXIgY2xhc3NOYW1lcyA9IGFkYXB0ZXIubm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcclxuICAgIGFkYXB0ZXIuYXNzZXRFbnRyeS5zZXRDbGFzc05hbWVzU3RyaW5nKGNsYXNzTmFtZXMpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZVBvc3RDb21wdXRlKGFkYXB0ZXIpIHtcclxuICAgIHZhciBjb21wdXRlU3RyaW5nID0gYWRhcHRlci5ub2RlLmdldEF0dHJpYnV0ZShcImNvbXB1dGVcIik7XHJcbiAgICB2YXIgZGF0YWZsb3dVcmwgPSBnZXRDb21wdXRlRGF0YWZsb3dVcmwoY29tcHV0ZVN0cmluZyk7XHJcbiAgICBpZiAoZGF0YWZsb3dVcmwpIHtcclxuICAgICAgICB1cGRhdGVBZGFwdGVySGFuZGxlKGFkYXB0ZXIsIFwicG9zdERhdGFmbG93XCIsIGRhdGFmbG93VXJsKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWRhcHRlci5kaXNjb25uZWN0QWRhcHRlckhhbmRsZShcInBvc3REYXRhZmxvd1wiKTtcclxuICAgICAgICB1cGRhdGVTdWJEYXRhTG9hZFN0YXRlKGFkYXB0ZXIpO1xyXG4gICAgfVxyXG4gICAgYWRhcHRlci5hc3NldEVudHJ5LnNldFBvc3RDb21wdXRlKGNvbXB1dGVTdHJpbmcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVTdWJEYXRhTG9hZFN0YXRlKGRhdGFBZGFwdGVyKSB7XHJcbiAgICB2YXIgbG9hZGluZyA9IGZhbHNlLCBoYW5kbGU7XHJcblxyXG4gICAgaGFuZGxlID0gZGF0YUFkYXB0ZXIuZ2V0Q29ubmVjdGVkQWRhcHRlckhhbmRsZShcInBvc3REYXRhZmxvd1wiKTtcclxuICAgIGlmIChoYW5kbGUgJiYgaGFuZGxlLnN0YXR1cyA9PT0gQWRhcHRlckhhbmRsZS5TVEFUVVMuTE9BRElORykge1xyXG4gICAgICAgIGxvYWRpbmcgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZGF0YUFkYXB0ZXIuYXNzZXRFbnRyeS5zZXRMb2FkaW5nKGxvYWRpbmcpO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBhZGFwdGVyXHJcbiAqIEBwYXJhbSB7QXNzZXR9IGRlc3RcclxuICovXHJcbmZ1bmN0aW9uIHNldE1hdGVyaWFsVXJsKGFkYXB0ZXIsIGRlc3QpIHtcclxuICAgIHZhciBub2RlID0gYWRhcHRlci5ub2RlO1xyXG4gICAgdmFyIG1hdGVyaWFsVVJMID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJtYXRlcmlhbFwiKTtcclxuICAgIGlmIChtYXRlcmlhbFVSTCkge1xyXG4gICAgICAgIHZhciBtYXRlcmlhbEFic29sdXRlVVJMID0gUmVzb3VyY2UuZ2V0QWJzb2x1dGVVUkkobm9kZS5vd25lckRvY3VtZW50Ll9kb2N1bWVudFVSTCB8fCBub2RlLm93bmVyRG9jdW1lbnQuVVJMLCBtYXRlcmlhbFVSTCk7XHJcbiAgICAgICAgZGVzdC5zZXRNYXRlcmlhbChtYXRlcmlhbEFic29sdXRlVVJMLnRvU3RyaW5nKCkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBkZXN0LnNldE1hdGVyaWFsKG51bGwpO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgQXNzZXRNZXNoQWRhcHRlciA9IGZ1bmN0aW9uIChmYWN0b3J5LCBub2RlKSB7XHJcbiAgICBBc3NldERhdGFBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XHJcbiAgICB0aGlzLnRyYW5zZm9ybUZldGNoZXIgPSBuZXcgRE9NVHJhbnNmb3JtRmV0Y2hlcih0aGlzLCBcInRyYW5zZm9ybVwiLCBcInRyYW5zZm9ybVwiKTtcclxufTtcclxuY3JlYXRlQ2xhc3MoQXNzZXRNZXNoQWRhcHRlciwgQXNzZXREYXRhQWRhcHRlciwge1xyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBBc3NldERhdGFBZGFwdGVyLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgc2V0TWF0ZXJpYWxVcmwodGhpcywgdGhpcy5hc3NldEVudHJ5KTtcclxuICAgICAgICB0aGlzLmFzc2V0RW50cnkuc2V0TWVzaFR5cGUodGhpcy5ub2RlLmdldEF0dHJpYnV0ZShcInR5cGVcIikgfHwgXCJ0cmlhbmdsZXNcIik7XHJcbiAgICAgICAgdGhpcy5hc3NldEVudHJ5LnNldE1hdGNoRmlsdGVyKHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoXCJtYXRjaFwiKSk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1GZXRjaGVyLnVwZGF0ZSgpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IGZ1bmN0aW9uIChuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcclxuICAgICAgICBBc3NldERhdGFBZGFwdGVyLnByb3RvdHlwZS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2suY2FsbCh0aGlzLCBuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xyXG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwibWF0ZXJpYWxcIjpcclxuICAgICAgICAgICAgICAgIHNldE1hdGVyaWFsVXJsKHRoaXMsIHRoaXMuYXNzZXRFbnRyeSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIm1hdGNoXCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFzc2V0RW50cnkuc2V0TWF0Y2hGaWx0ZXIobmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzdHlsZVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwidHJhbnNmb3JtXCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybUZldGNoZXIudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwidHlwZVwiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5hc3NldEVudHJ5LnNldE1lc2hUeXBlKG5ld1ZhbHVlIHx8IFwidHJpYW5nbGVzXCIpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBub3RpZnlDaGFuZ2VkOiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgQXNzZXREYXRhQWRhcHRlci5wcm90b3R5cGUubm90aWZ5Q2hhbmdlZC5jYWxsKHRoaXMsIGV2dCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVZpc2liaWxpdHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMubm9kZS5zdHlsZSkge1xyXG4gICAgICAgICAgICB0aGlzLm5vZGUuc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbm9uZSA9IHRoaXMubm9kZS5zdHlsZS5kaXNwbGF5ID09IFwibm9uZVwiO1xyXG4gICAgICAgIHRoaXMuYXNzZXRFbnRyeSAmJiB0aGlzLmFzc2V0RW50cnkuc2V0VmlzaWJpbGl0eSghbm9uZSk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMganVzdCBhIHNtYWxsIHdyYXBwZXIgdG8gaWRlbnRpZnkgWGZsb3cgbm9kZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgYnkgYW4gQXNzZXQsIGVnIGFzIHBhcnQgb2Ygb3ZlcnJpZGVzXHJcbiAqIHRoYXQgbmVlZCB0byBiZSBjbGVhbmVkIHVwIGxhdGVyIGlmIHRoZSBjb3JyZXNwb25kaW5nIG1vZGVsIHRhZyBpcyBkZXN0cm95ZWRcclxuICogQHBhcmFtIGlzRGF0YUZsb3dcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgQXNzZXREYXRhTm9kZSA9IGZ1bmN0aW9uKGlzRGF0YUZsb3cpIHtcclxuICAgIERhdGFOb2RlLmNhbGwodGhpcywgaXNEYXRhRmxvdyk7XHJcbiAgICB0aGlzLmlzQXNzZXREYXRhTm9kZSA9IHRydWU7XHJcbn07XHJcblxyXG5CYXNlLmNyZWF0ZUNsYXNzKEFzc2V0RGF0YU5vZGUsIERhdGFOb2RlKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgQXNzZXRBZGFwdGVyOiBBc3NldEFkYXB0ZXIsIEFzc2V0TWVzaEFkYXB0ZXI6IEFzc2V0TWVzaEFkYXB0ZXIsIEFzc2V0RGF0YUFkYXB0ZXI6IEFzc2V0RGF0YUFkYXB0ZXJcclxufTtcclxuIiwidmFyIENvbXB1dGVSZXF1ZXN0ID0gcmVxdWlyZShcIi4uLy4uL3hmbG93L2ludGVyZmFjZS9yZXF1ZXN0LmpzXCIpLkNvbXB1dGVSZXF1ZXN0O1xyXG52YXIgc2V0U2hhZGVyQ29uc3RhbnQgPSByZXF1aXJlKFwiLi4vLi4veGZsb3cvcHJvY2Vzc2luZy92cy1jb25uZWN0LmpzXCIpLnNldFNoYWRlckNvbnN0YW50O1xyXG52YXIgcmVnaXN0ZXJFcnJvckNhbGxiYWNrID0gcmVxdWlyZShcIi4uLy4uL3hmbG93L2Jhc2UuanNcIikucmVnaXN0ZXJFcnJvckNhbGxiYWNrO1xyXG52YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIFVSSSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy91cmkuanNcIikuVVJJO1xyXG5cclxudmFyIE5vZGVBZGFwdGVyID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvYWRhcHRlci5qc1wiKS5Ob2RlQWRhcHRlcjtcclxudmFyIGNyZWF0ZUNsYXNzID0gWE1MM0QuY3JlYXRlQ2xhc3M7XHJcblxyXG4vKipcclxuICogQGV4dGVuZHMgTm9kZUFkYXB0ZXJcclxuICogQGFic3RyYWN0XHJcbiAqXHJcbiAqIEBwYXJhbSBmYWN0b3J5XHJcbiAqIEBwYXJhbSBub2RlXHJcbiAqL1xyXG52YXIgQmFzZURhdGFBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcclxuICAgIE5vZGVBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XHJcbiAgICB0aGlzLnhmbG93RGF0YU5vZGUgPSBudWxsO1xyXG59O1xyXG5jcmVhdGVDbGFzcyhCYXNlRGF0YUFkYXB0ZXIsIE5vZGVBZGFwdGVyKTtcclxuXHJcblxyXG5CYXNlRGF0YUFkYXB0ZXIucHJvdG90eXBlLmdldFhmbG93Tm9kZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnhmbG93RGF0YU5vZGU7XHJcbn07XHJcblxyXG5CYXNlRGF0YUFkYXB0ZXIucHJvdG90eXBlLmdldENvbXB1dGVSZXF1ZXN0ID0gZnVuY3Rpb24gKGZpbHRlciwgY2FsbGJhY2spIHtcclxuICAgIHJldHVybiBuZXcgQ29tcHV0ZVJlcXVlc3QodGhpcy54Zmxvd0RhdGFOb2RlLCBmaWx0ZXIsIGNhbGxiYWNrKTtcclxufTtcclxuXHJcbkJhc2VEYXRhQWRhcHRlci5wcm90b3R5cGUuZ2V0Q29tcHV0ZVJlc3VsdCA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgIHJldHVybiB0aGlzLnhmbG93RGF0YU5vZGUuX2dldFJlc3VsdChYQy5SRVNVTFRfVFlQRS5DT01QVVRFLCBmaWx0ZXIpO1xyXG59O1xyXG5cclxuQmFzZURhdGFBZGFwdGVyLnByb3RvdHlwZS5nZXRPdXRwdXROYW1lcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnhmbG93RGF0YU5vZGUuZ2V0T3V0cHV0TmFtZXMoKTtcclxufTtcclxuXHJcbkJhc2VEYXRhQWRhcHRlci5wcm90b3R5cGUuZ2V0T3V0cHV0Q2hhbm5lbEluZm8gPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgcmV0dXJuIHRoaXMueGZsb3dEYXRhTm9kZS5nZXRPdXRwdXRDaGFubmVsSW5mbyhuYW1lKTtcclxufTtcclxuXHJcbnNldFNoYWRlckNvbnN0YW50KFhDLlNIQURFUl9DT05TVEFOVF9LRVkuT0JKRUNUX0lELCBcIm9iamVjdElEXCIpO1xyXG5zZXRTaGFkZXJDb25zdGFudChYQy5TSEFERVJfQ09OU1RBTlRfS0VZLlNDUkVFTl9UUkFOU0ZPUk0sIFwibW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeFwiKTtcclxuc2V0U2hhZGVyQ29uc3RhbnQoWEMuU0hBREVSX0NPTlNUQU5UX0tFWS5TQ1JFRU5fVFJBTlNGT1JNX05PUk1BTCwgXCJtb2RlbFZpZXdQcm9qZWN0aW9uTm9ybWFsTWF0cml4XCIpO1xyXG5zZXRTaGFkZXJDb25zdGFudChYQy5TSEFERVJfQ09OU1RBTlRfS0VZLlZJRVdfVFJBTlNGT1JNLCBcIm1vZGVsVmlld01hdHJpeFwiKTtcclxuc2V0U2hhZGVyQ29uc3RhbnQoWEMuU0hBREVSX0NPTlNUQU5UX0tFWS5WSUVXX1RSQU5TRk9STV9OT1JNQUwsIFwibW9kZWxWaWV3TWF0cml4TlwiKTtcclxuc2V0U2hhZGVyQ29uc3RhbnQoWEMuU0hBREVSX0NPTlNUQU5UX0tFWS5XT1JMRF9UUkFOU0ZPUk0sIFwibW9kZWxNYXRyaXhcIik7XHJcbnJlZ2lzdGVyRXJyb3JDYWxsYmFjayhmdW5jdGlvbihtZXNzYWdlLCB4Zmxvd05vZGUpe1xyXG4gICAgbWVzc2FnZSA9IFwiWGZsb3c6IFwiICsgbWVzc2FnZTtcclxuICAgIHZhciB1c2VyRGF0YSA9IHhmbG93Tm9kZSA/IHhmbG93Tm9kZS51c2VyRGF0YSA6IG51bGw7XHJcbiAgICBpZiAodXNlckRhdGEgJiYgdXNlckRhdGEub3duZXJEb2N1bWVudCkge1xyXG4gICAgICAgIGlmICh1c2VyRGF0YS5vd25lckRvY3VtZW50ID09PSBkb2N1bWVudCkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihtZXNzYWdlLCB1c2VyRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHVzZXJEYXRhLmlkKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmkgPSBuZXcgVVJJKFwiI1wiICsgdXNlckRhdGEuaWQpO1xyXG4gICAgICAgICAgICB1cmkgPSB1cmkuZ2V0QWJzb2x1dGVVUkkodXNlckRhdGEub3duZXJEb2N1bWVudC5fZG9jdW1lbnRVUkwgfHwgdXNlckRhdGEub3duZXJEb2N1bWVudC5VUkwpO1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihtZXNzYWdlLCBcIkV4dGVybmFsIE5vZGU6IFwiICsgdXJpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKG1lc3NhZ2UsIFwiRXh0ZXJuYWwgRG9jdW1lbnQ6IFwiICsgdXNlckRhdGEub3duZXJEb2N1bWVudC5VUkwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiB1c2VyRGF0YSA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IobWVzc2FnZSwgdXNlckRhdGEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IobWVzc2FnZSk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYXNlRGF0YUFkYXB0ZXI7XHJcbiIsInZhciBFdmVudHMgPSByZXF1aXJlKFwiLi4vLi4vaW50ZXJmYWNlL25vdGlmaWNhdGlvbi5qc1wiKTtcclxudmFyIE5vZGVBZGFwdGVyID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvYWRhcHRlci5qc1wiKS5Ob2RlQWRhcHRlcjtcclxuXHJcbi8qKlxyXG4gKiBEYXRhQWRhcHRlciBoYW5kbGluZyBhIDxjb21wdXRlPiBlbGVtZW50XHJcbiAqIEBwYXJhbSB7QWRhcHRlckZhY3Rvcnl9IGZhY3RvcnlcclxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIENvbXB1dGVEYXRhQWRhcHRlciA9IGZ1bmN0aW9uIChmYWN0b3J5LCBub2RlKSB7XHJcbiAgICBOb2RlQWRhcHRlci5jYWxsKHRoaXMsIGZhY3RvcnksIG5vZGUpO1xyXG59O1xyXG5YTUwzRC5jcmVhdGVDbGFzcyhDb21wdXRlRGF0YUFkYXB0ZXIsIE5vZGVBZGFwdGVyKTtcclxuXHJcbkNvbXB1dGVEYXRhQWRhcHRlci5wcm90b3R5cGUuZ2V0Q29tcHV0ZUNvZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5ub2RlLnZhbHVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSBldnQgbm90aWZpY2F0aW9uIG9mIHR5cGUgWE1MM0QuTm90aWZpY2F0aW9uXHJcbiAqL1xyXG5Db21wdXRlRGF0YUFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeUNoYW5nZWQgPSBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICBzd2l0Y2ggKGV2dC50eXBlKSB7XHJcbiAgICAgICAgY2FzZSBFdmVudHMuVkFMVUVfTU9ESUZJRUQ6XHJcbiAgICAgICAgY2FzZSBFdmVudHMuTk9ERV9JTlNFUlRFRDpcclxuICAgICAgICBjYXNlIEV2ZW50cy5OT0RFX1JFTU9WRUQ6XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLm5vZGUucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEFkYXB0ZXIgPSB0aGlzLmZhY3RvcnkuZ2V0QWRhcHRlcihwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50QWRhcHRlciAmJiBwYXJlbnRBZGFwdGVyLnVwZGF0ZVhmbG93Tm9kZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbXB1dGVEYXRhQWRhcHRlcjtcclxuIiwidmFyIEJhc2VEYXRhQWRhcHRlciA9IHJlcXVpcmUoXCIuL2Jhc2UuanNcIik7XHJcbnZhciBEYXRhTm9kZSA9IHJlcXVpcmUoXCIuLi8uLi94Zmxvdy9pbnRlcmZhY2UvZ3JhcGguanNcIikuRGF0YU5vZGU7XHJcbnZhciBYQyA9IHJlcXVpcmUoXCIuLi8uLi94Zmxvdy9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xyXG52YXIgRXZlbnRzID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZS9ub3RpZmljYXRpb24uanNcIik7XHJcbnZhciBkaXNwYXRjaEN1c3RvbUV2ZW50ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL21pc2MuanNcIikuZGlzcGF0Y2hDdXN0b21FdmVudDtcclxudmFyIEFkYXB0ZXJIYW5kbGUgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9hZGFwdGVyaGFuZGxlLmpzXCIpO1xyXG52YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi8uLi94Zmxvdy9iYXNlLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBEYXRhQWRhcHRlciBpbXBsZW1lbnRzIHRoZVxyXG4gKiBEYXRhQ29sbGVjdG9yIGNvbmNlcHQgYW5kIHNlcnZlcyBhcyBiYXNpcyBvZiBhbGwgRGF0YUFkYXB0ZXIgY2xhc3Nlcy4gSW5cclxuICogZ2VuZXJhbCwgYSBEYXRhQWRhcHRlciBpcyBhc3NvY2lhdGVkIHdpdGggYW4gZWxlbWVudCBub2RlIHdoaWNoIHVzZXNcclxuICogZ2VuZXJpYyBkYXRhIGFuZCBzaG91bGQgYmUgaW5zdGFudGlhdGVkIHZpYVxyXG4gKiBYTUwzRERhdGFBZGFwdGVyRmFjdG9yeSB0byBlbnN1cmUgcHJvcGVyIGZ1bmN0aW9uYWxpdHkuXHJcbiAqXHJcbiAqIEBleHRlbmRzIEFkYXB0ZXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSBmYWN0b3J5XHJcbiAqIEBwYXJhbSBub2RlXHJcbiAqL1xyXG52YXIgRGF0YUFkYXB0ZXIgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbm9kZSkge1xyXG4gICAgQmFzZURhdGFBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XHJcbiAgICAvLyBOb2RlIGhhbmRsZXMgZm9yIHNyYyBhbmQgcHJvdG9cclxuICAgIHRoaXMueGZsb3dEYXRhTm9kZSA9IG51bGw7XHJcbiAgICB0aGlzLmV4dGVybmFsU2NyaXB0cyA9IHt9O1xyXG59O1xyXG5YTUwzRC5jcmVhdGVDbGFzcyhEYXRhQWRhcHRlciwgQmFzZURhdGFBZGFwdGVyKTtcclxuXHJcbkRhdGFBZGFwdGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy54Zmxvd0RhdGFOb2RlID0gbmV3IERhdGFOb2RlKGZhbHNlKTtcclxuICAgIHRoaXMueGZsb3dEYXRhTm9kZS5hZGRMb2FkTGlzdGVuZXIodGhpcy5vblhmbG93TG9hZEV2ZW50LmJpbmQodGhpcykpO1xyXG4gICAgdGhpcy54Zmxvd0RhdGFOb2RlLnVzZXJEYXRhID0gdGhpcy5ub2RlO1xyXG5cclxuICAgIHRoaXMuc3JjRGF0YU5vZGUgPSBuZXcgRGF0YU5vZGUoZmFsc2UpO1xyXG4gICAgdGhpcy54Zmxvd0RhdGFOb2RlLmFwcGVuZENoaWxkKHRoaXMuc3JjRGF0YU5vZGUpO1xyXG5cclxuICAgIC8vIFNldHRpbmcgcGxhdGZvcm0gYW5kIG5vZGUgdHlwZSBpbmZvcm1hdGlvbiBmb3IgYSBkYXRhIHNlcXVlbmNlXHJcbiAgICB0aGlzLnhmbG93RGF0YU5vZGUuc2V0UGxhdGZvcm0odGhpcy5ub2RlLmdldEF0dHJpYnV0ZShcInBsYXRmb3JtXCIpKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZUFkYXB0ZXJIYW5kbGUoXCJzcmNcIiwgdGhpcy5ub2RlLmdldEF0dHJpYnV0ZShcInNyY1wiKSk7XHJcbiAgICBpZighdGhpcy5hc3NldERhdGEpe1xyXG4gICAgICAgIHRoaXMueGZsb3dEYXRhTm9kZS5zZXRGaWx0ZXIodGhpcy5ub2RlLmdldEF0dHJpYnV0ZShcImZpbHRlclwiKSk7XHJcbiAgICAgICAgdXBkYXRlQ29tcHV0ZSh0aGlzKTtcclxuICAgIH1cclxuICAgIHJlY3Vyc2l2ZURhdGFBZGFwdGVyQ29uc3RydWN0aW9uKHRoaXMpO1xyXG59O1xyXG5cclxuRGF0YUFkYXB0ZXIucHJvdG90eXBlLnVwZGF0ZUFkYXB0ZXJIYW5kbGUgPSBmdW5jdGlvbihrZXksIHVybCkge1xyXG4gICAgdmFyIG9sZEFkYXB0ZXJIYW5kbGUgPSB0aGlzLmdldENvbm5lY3RlZEFkYXB0ZXJIYW5kbGUoa2V5KTtcclxuXHJcbiAgICB2YXIgYWRhcHRlckhhbmRsZSA9IHRoaXMuZ2V0QWRhcHRlckhhbmRsZSh1cmwpLFxyXG4gICAgICAgIHN0YXR1cyA9IChhZGFwdGVySGFuZGxlICYmIGFkYXB0ZXJIYW5kbGUuc3RhdHVzKTtcclxuXHJcbiAgICBpZihvbGRBZGFwdGVySGFuZGxlID09IGFkYXB0ZXJIYW5kbGUpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgaWYgKHN0YXR1cyA9PT0gQWRhcHRlckhhbmRsZS5TVEFUVVMuTk9UX0ZPVU5EKSB7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJDb3VsZCBub3QgZmluZCBlbGVtZW50IG9mIHVybCAnXCIgKyBhZGFwdGVySGFuZGxlLnVybCArIFwiJyBmb3IgXCIgKyBrZXksIHRoaXMubm9kZSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmNvbm5lY3RBZGFwdGVySGFuZGxlKGtleSwgYWRhcHRlckhhbmRsZSk7XHJcbiAgICB0aGlzLmNvbm5lY3RlZEFkYXB0ZXJDaGFuZ2VkKGtleSwgYWRhcHRlckhhbmRsZSA/IGFkYXB0ZXJIYW5kbGUuZ2V0QWRhcHRlcigpIDogbnVsbCwgc3RhdHVzKTtcclxufTtcclxuXHJcbkRhdGFBZGFwdGVyLnByb3RvdHlwZS5vblhmbG93TG9hZEV2ZW50ID0gZnVuY3Rpb24obm9kZSwgbmV3TGV2ZWwsIG9sZExldmVsKXtcclxuICAgIGlmKG5ld0xldmVsID09IEluZmluaXR5KXtcclxuICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50KHRoaXMubm9kZSwgJ2xvYWQnLCBmYWxzZSwgdHJ1ZSwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmKG5ld0xldmVsID4gb2xkTGV2ZWwpe1xyXG4gICAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQodGhpcy5ub2RlLCAncHJvZ3Jlc3MnLCBmYWxzZSwgdHJ1ZSwgbnVsbCk7XHJcbiAgICB9XHJcbn07XHJcbkRhdGFBZGFwdGVyLnByb3RvdHlwZS5nZXREYXRhQ29tcGxldGUgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMueGZsb3dEYXRhTm9kZS5nZXRQcm9ncmVzc0xldmVsKCkgPT0gSW5maW5pdHk7XHJcbn07XHJcbkRhdGFBZGFwdGVyLnByb3RvdHlwZS5nZXREYXRhUHJvZ3Jlc3NMZXZlbCA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpcy54Zmxvd0RhdGFOb2RlLmdldFByb2dyZXNzTGV2ZWwoKTtcclxufTtcclxuXHJcbiAgICAvKiogUmVjdXJzaXZlbHkgcGFzc2luZyBwbGF0Zm9ybSBpbmZvcm1hdGlvbiB0byBjaGlsZHJlbiBvZiBhIGRhdGEgbm9kZVxyXG4gICAgICogIFJlcXVpcmVzIHRoYXQgdGhlIGNoaWxkcmVuIGFuZCB0aGUgcGFyZW50cyBvZiBkYXRhIG5vZGVzIGFyZSBkZWZpbmVkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtEYXRhTm9kZX0gcGFyZW50Tm9kZVxyXG4gICAgICovXHJcbmZ1bmN0aW9uIHJlY3Vyc2l2ZURhdGFOb2RlQXR0ckluaXQocGFyZW50Tm9kZSkge1xyXG4gICAgdmFyIGNoaWxkcmVuID0gcGFyZW50Tm9kZS5fY2hpbGRyZW4sIE5DaGlsZHJlbiwgaTtcclxuXHJcbiAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIE5DaGlsZHJlbiA9IGNoaWxkcmVuLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yIChpID0gTkNoaWxkcmVuOyBpLS07KSB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltpXSBpbnN0YW5jZW9mIERhdGFOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpXS5zZXRQbGF0Zm9ybShwYXJlbnROb2RlLl9wbGF0Zm9ybSk7XHJcbiAgICAgICAgICAgICAgICByZWN1cnNpdmVEYXRhTm9kZUF0dHJJbml0KGNoaWxkcmVuW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVjdXJzaXZlRGF0YUFkYXB0ZXJDb25zdHJ1Y3Rpb24oYWRhcHRlcikge1xyXG4gICAgZm9yICh2YXIgY2hpbGQgPSBhZGFwdGVyLm5vZGUuZmlyc3RFbGVtZW50Q2hpbGQ7IGNoaWxkICE9PSBudWxsOyBjaGlsZCA9IGNoaWxkLm5leHRFbGVtZW50U2libGluZykge1xyXG4gICAgICAgIHZhciBzdWJhZGFwdGVyID0gYWRhcHRlci5mYWN0b3J5LmdldEFkYXB0ZXIoY2hpbGQpO1xyXG4gICAgICAgIGlmIChzdWJhZGFwdGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChzdWJhZGFwdGVyLmdldFhmbG93Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgYWRhcHRlci54Zmxvd0RhdGFOb2RlLmFwcGVuZENoaWxkKHN1YmFkYXB0ZXIuZ2V0WGZsb3dOb2RlKCkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN1YmFkYXB0ZXIuZ2V0U2NyaXB0VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjcmlwdElkID0gc3ViYWRhcHRlci5ub2RlLm5hbWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNjcmlwdElkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJQYXJzaW5nIGVycm9yOiBFeHRlcm5hbGx5IHJlZmVyZW5jZWQgb3BlcmF0b3JzIG11c3QgaGF2ZSBhICduYW1lJyBhdHRyaWJ1dGUgbWF0Y2hpbmcgdGhlIG5hbWUgdGhleSB3ZXJlIHJlZ2lzdGVyZWQgd2l0aC4gXCIsIHN1YmFkYXB0ZXIubm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0SWQgPSBcInVua25vd25fb3BlcmF0b3JcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFkYXB0ZXIuZXh0ZXJuYWxTY3JpcHRzW3NjcmlwdElkXSA9IHN1YmFkYXB0ZXI7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3ViYWRhcHRlci5jb25uZWN0ZWRBZGFwdGVySGFuZGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRhcHRlci5jb25uZWN0QWRhcHRlckhhbmRsZShzY3JpcHRJZCwgc3ViYWRhcHRlci5jb25uZWN0ZWRBZGFwdGVySGFuZGxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFkYXB0ZXIueGZsb3dEYXRhTm9kZS5zZXRMb2FkaW5nKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFBhc3NlcyBfcGxhdGZvcm0gdmFsdWVzIHRvIGNoaWxkcmVuIG5vZGVzIHN0YXJ0aW5nIGZyb20gdGhlIG5vZGVcclxuICAgICAgICAgICAgLy8gd2hlcmUgdGhlc2UgYXR0cmlidXRlcyBhcmUgZmlyc3QgZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoYWRhcHRlci54Zmxvd0RhdGFOb2RlLl9wbGF0Zm9ybSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlRGF0YU5vZGVBdHRySW5pdChhZGFwdGVyLnhmbG93RGF0YU5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhlIG5vdGlmeUNoYW5nZWQoKSBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBYTUwzRCBkYXRhIHN0cnVjdHVyZSB0b1xyXG4gKiBub3RpZnkgdGhlIERhdGFBZGFwdGVyIGFib3V0IGRhdGEgY2hhbmdlcyAoRE9NIG11c3RhdGlvbiBldmVudHMpIGluIGl0c1xyXG4gKiBhc3NvY2lhdGluZyBub2RlLiBXaGVuIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgYWxsIG9ic2VydmVycyBvZiB0aGVcclxuICogRGF0YUFkYXB0ZXIgYXJlIG5vdGlmaWVkIGFib3V0IGRhdGEgY2hhbmdlcyB2aWEgdGhlaXIgbm90aWZ5RGF0YUNoYW5nZWQoKVxyXG4gKiBtZXRob2QuXHJcbiAqXHJcbiAqIEBwYXJhbSBldnQgbm90aWZpY2F0aW9uIG9mIHR5cGUgWE1MM0QuTm90aWZpY2F0aW9uXHJcbiAqL1xyXG5EYXRhQWRhcHRlci5wcm90b3R5cGUubm90aWZ5Q2hhbmdlZCA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgIGlmIChldnQudHlwZSA9PT0gRXZlbnRzLkFEQVBURVJfSEFORExFX0NIQU5HRUQpIHtcclxuICAgICAgICB0aGlzLmNvbm5lY3RlZEFkYXB0ZXJDaGFuZ2VkKGV2dC5rZXksIGV2dC5hZGFwdGVyLCBldnQuaGFuZGxlU3RhdHVzKTtcclxuICAgICAgICBpZiAoZXZ0LmhhbmRsZVN0YXR1cyA9PT0gQWRhcHRlckhhbmRsZS5TVEFUVVMuTk9UX0ZPVU5EKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiQ291bGQgbm90IGZpbmQgPGRhdGE+IGVsZW1lbnQgb2YgdXJsICdcIiArIGV2dC51cmwgKyBcIicgZm9yIFwiICsgZXZ0LmtleSwgdGhpcy5ub2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSBlbHNlIGlmIChldnQudHlwZSA9PT0gRXZlbnRzLk5PREVfSU5TRVJURUQpIHtcclxuICAgICAgICB2YXIgaW5zZXJ0ZWROb2RlID0gZXZ0LmFmZmVjdGVkTm9kZTtcclxuICAgICAgICB2YXIgYWRhcHRlciA9IHRoaXMuZmFjdG9yeS5nZXRBZGFwdGVyKGluc2VydGVkTm9kZSk7XHJcbiAgICAgICAgaWYgKCFhZGFwdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpbnNlcnRlZFhmbG93Tm9kZSA9IGFkYXB0ZXIuZ2V0WGZsb3dOb2RlKCk7XHJcbiAgICAgICAgdmFyIHNpYmxpbmcgPSBpbnNlcnRlZE5vZGUsIGZvbGxvd1VwQWRhcHRlciA9IG51bGw7XHJcblxyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgc2libGluZyA9IHNpYmxpbmcubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgfSB3aGlsZSAoc2libGluZyAmJiAhKGZvbGxvd1VwQWRhcHRlciA9IHRoaXMuZmFjdG9yeS5nZXRBZGFwdGVyKHNpYmxpbmcpKSk7XHJcblxyXG4gICAgICAgIGlmIChmb2xsb3dVcEFkYXB0ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy54Zmxvd0RhdGFOb2RlLmluc2VydEJlZm9yZShpbnNlcnRlZFhmbG93Tm9kZSwgZm9sbG93VXBBZGFwdGVyLmdldFhmbG93Tm9kZSgpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnhmbG93RGF0YU5vZGUuYXBwZW5kQ2hpbGQoaW5zZXJ0ZWRYZmxvd05vZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGVsc2UgaWYgKGV2dC50eXBlID09PSBFdmVudHMuTk9ERV9SRU1PVkVEKSB7XHJcbiAgICAgICAgdmFyIGFkYXB0ZXIgPSB0aGlzLmZhY3RvcnkuZ2V0QWRhcHRlcihldnQuYWZmZWN0ZWROb2RlKTtcclxuICAgICAgICBpZiAoIWFkYXB0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlbW92ZWRYZmxvd05vZGUgPSBhZGFwdGVyLmdldFhmbG93Tm9kZSgpO1xyXG4gICAgICAgIHRoaXMueGZsb3dEYXRhTm9kZS5yZW1vdmVDaGlsZChyZW1vdmVkWGZsb3dOb2RlKTtcclxuXHJcbiAgICB9IGVsc2UgaWYgKGV2dC50eXBlID09PSBFdmVudHMuVEhJU19SRU1PVkVEKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhckFkYXB0ZXJIYW5kbGVzKCk7XHJcbiAgICAgICAgdGhpcy54Zmxvd0RhdGFOb2RlLmNsZWFyKCk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuc3JjRGF0YU5vZGU7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMubm9kZTtcclxuICAgIH1cclxufTtcclxuXHJcbkRhdGFBZGFwdGVyLnByb3RvdHlwZS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XHJcbiAgICBpZiAobmFtZSA9PT0gXCJmaWx0ZXJcIiAmJiAhdGhpcy5hc3NldERhdGEpIHtcclxuICAgICAgICB0aGlzLnhmbG93RGF0YU5vZGUuc2V0RmlsdGVyKG5ld1ZhbHVlKTtcclxuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJjb21wdXRlXCIgJiYgIXRoaXMuYXNzZXREYXRhKSB7XHJcbiAgICAgICAgdXBkYXRlQ29tcHV0ZSh0aGlzKTtcclxuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJzcmNcIikge1xyXG4gICAgICAgIHRoaXMudXBkYXRlQWRhcHRlckhhbmRsZShuYW1lLCBuZXdWYWx1ZSk7XHJcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwicGxhdGZvcm1cIikge1xyXG4gICAgICAgIHVwZGF0ZVBsYXRmb3JtKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuRGF0YUFkYXB0ZXIucHJvdG90eXBlLmNvbm5lY3RlZEFkYXB0ZXJDaGFuZ2VkID0gZnVuY3Rpb24gKGtleSwgYWRhcHRlciAvKiwgc3RhdHVzICovKSB7XHJcbiAgICBpZiAoa2V5ID09PSBcInNyY1wiKSB7XHJcbiAgICAgICAgdGhpcy5zcmNEYXRhTm9kZS5zb3VyY2VOb2RlID0gYWRhcHRlciA/IGFkYXB0ZXIuZ2V0WGZsb3dOb2RlKCkgOiBudWxsO1xyXG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiZGF0YWZsb3dcIikge1xyXG4gICAgICAgIHRoaXMueGZsb3dEYXRhTm9kZS5kYXRhZmxvd05vZGUgPSBhZGFwdGVyID8gYWRhcHRlci5nZXRYZmxvd05vZGUoKSA6IG51bGw7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuZXh0ZXJuYWxTY3JpcHRzW2tleV0pIHtcclxuICAgICAgICB3aW5kb3cuZXZhbChhZGFwdGVyLnNjcmlwdCk7XHJcbiAgICAgICAgdGhpcy54Zmxvd0RhdGFOb2RlLm5vdGlmeShYQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xyXG4gICAgICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XHJcbiAgICB9XHJcbiAgICAvLyBDeWNsZSB0aGUgbG9hZCBzdGF0ZSB0byBmb3JjZSBhIGxvYWQgZXZlbnQgZXZlbiBpZiB0aGUgbmV3IHNvdXJjZU5vZGUgaXMgY2FjaGVkXHJcbiAgICB0aGlzLnhmbG93RGF0YU5vZGUuc2V0TG9hZGluZyh0cnVlKTtcclxuICAgIHVwZGF0ZUxvYWRTdGF0ZSh0aGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGFBZGFwdGVyXHJcbiAqL1xyXG5EYXRhQWRhcHRlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gXCJEYXRhQWRhcHRlclwiO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gdXBkYXRlQ29tcHV0ZShkYXRhQWRhcHRlcikge1xyXG4gICAgdmFyIHhmbG93Tm9kZSA9IGRhdGFBZGFwdGVyLnhmbG93RGF0YU5vZGU7XHJcbiAgICB4Zmxvd05vZGUuc2V0Q29tcHV0ZShkYXRhQWRhcHRlci5ub2RlLmdldEF0dHJpYnV0ZShcImNvbXB1dGVcIikpO1xyXG4gICAgaWYgKHhmbG93Tm9kZS5jb21wdXRlRGF0YWZsb3dVcmwpIHtcclxuICAgICAgICBkYXRhQWRhcHRlci51cGRhdGVBZGFwdGVySGFuZGxlKFwiZGF0YWZsb3dcIiwgeGZsb3dOb2RlLmNvbXB1dGVEYXRhZmxvd1VybCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBkYXRhQWRhcHRlci5kaXNjb25uZWN0QWRhcHRlckhhbmRsZShcImRhdGFmbG93XCIpO1xyXG4gICAgICAgIHVwZGF0ZUxvYWRTdGF0ZShkYXRhQWRhcHRlcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZVBsYXRmb3JtKGRhdGFBZGFwdGVyKSB7XHJcbiAgICB2YXIgeGZsb3dOb2RlID0gZGF0YUFkYXB0ZXIueGZsb3dEYXRhTm9kZTtcclxuXHJcbiAgICB4Zmxvd05vZGUuc2V0UGxhdGZvcm0oZGF0YUFkYXB0ZXIubm9kZS5nZXRBdHRyaWJ1dGUoXCJwbGF0Zm9ybVwiKSk7XHJcbiAgICByZWN1cnNpdmVEYXRhTm9kZUF0dHJJbml0KHhmbG93Tm9kZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUxvYWRTdGF0ZShkYXRhQWRwYXRlcikge1xyXG4gICAgdmFyIGxvYWRpbmcgPSBmYWxzZSwgaGFuZGxlO1xyXG5cclxuICAgIGhhbmRsZSA9IGRhdGFBZHBhdGVyLmdldENvbm5lY3RlZEFkYXB0ZXJIYW5kbGUoXCJzcmNcIik7XHJcbiAgICBpZiAoaGFuZGxlICYmIGhhbmRsZS5zdGF0dXMgPT09IEFkYXB0ZXJIYW5kbGUuU1RBVFVTLkxPQURJTkcpIHtcclxuICAgICAgICBsb2FkaW5nID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGUgPSBkYXRhQWRwYXRlci5nZXRDb25uZWN0ZWRBZGFwdGVySGFuZGxlKFwiZGF0YWZsb3dcIik7XHJcbiAgICBpZiAoaGFuZGxlICYmIGhhbmRsZS5zdGF0dXMgPT09IEFkYXB0ZXJIYW5kbGUuU1RBVFVTLkxPQURJTkcpIHtcclxuICAgICAgICBsb2FkaW5nID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBuYW1lIGluIGRhdGFBZHBhdGVyLmV4dGVybmFsU2NyaXB0cykge1xyXG4gICAgICAgIGhhbmRsZSA9IGRhdGFBZHBhdGVyLmdldENvbm5lY3RlZEFkYXB0ZXJIYW5kbGUobmFtZSk7XHJcbiAgICAgICAgaWYgKGhhbmRsZSAmJiBoYW5kbGUuc3RhdHVzID09PSBBZGFwdGVySGFuZGxlLlNUQVRVUy5MT0FESU5HKSB7XHJcbiAgICAgICAgICAgIGxvYWRpbmcgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkYXRhQWRwYXRlci54Zmxvd0RhdGFOb2RlLnNldExvYWRpbmcobG9hZGluZyk7XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFBZGFwdGVyO1xyXG5cclxuXHJcbiIsInZhciBCYXNlRGF0YUFkYXB0ZXIgPSByZXF1aXJlKFwiLi9iYXNlLmpzXCIpO1xyXG52YXIgRGF0YU5vZGUgPSByZXF1aXJlKFwiLi4vLi4veGZsb3cvaW50ZXJmYWNlL2dyYXBoLmpzXCIpLkRhdGFOb2RlO1xyXG52YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xyXG52YXIgQWRhcHRlckhhbmRsZSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2FkYXB0ZXJoYW5kbGUuanNcIik7XHJcbnZhciBCYXNlID0gcmVxdWlyZShcIi4uLy4uL3hmbG93L2Jhc2UuanNcIik7XHJcblxyXG4vKipcclxuICogRGF0YUFkYXB0ZXIgaGFuZGxpbmcgYSA8ZGF0YWZsb3c+IGVsZW1lbnRcclxuICogQHBhcmFtIGZhY3RvcnlcclxuICogQHBhcmFtIG5vZGVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgRGF0YWZsb3dEYXRhQWRhcHRlciA9IGZ1bmN0aW9uIChmYWN0b3J5LCBub2RlKSB7XHJcbiAgICBCYXNlRGF0YUFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlKTtcclxuICAgIHRoaXMueGZsb3dEYXRhTm9kZSA9IG51bGw7XHJcbiAgICB0aGlzLmV4dGVybmFsU2NyaXB0cyA9IHt9O1xyXG59O1xyXG5YTUwzRC5jcmVhdGVDbGFzcyhEYXRhZmxvd0RhdGFBZGFwdGVyLCBCYXNlRGF0YUFkYXB0ZXIpO1xyXG5cclxuRGF0YWZsb3dEYXRhQWRhcHRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMueGZsb3dEYXRhTm9kZSA9IG5ldyBEYXRhTm9kZShmYWxzZSk7XHJcbiAgICB0aGlzLmRhdGFmbG93UmVmcyA9IFtdO1xyXG4gICAgdXBkYXRlRGF0YWZsb3dYZmxvd05vZGUodGhpcywgdGhpcy5ub2RlKTtcclxufTtcclxuXHJcbkRhdGFmbG93RGF0YUFkYXB0ZXIucHJvdG90eXBlLnVwZGF0ZUFkYXB0ZXJIYW5kbGUgPSBmdW5jdGlvbihrZXksIHVybCkge1xyXG4gICAgdmFyIG9sZEFkYXB0ZXJIYW5kbGUgPSB0aGlzLmdldENvbm5lY3RlZEFkYXB0ZXJIYW5kbGUoa2V5KTtcclxuXHJcbiAgICB2YXIgYWRhcHRlckhhbmRsZSA9IHRoaXMuZ2V0QWRhcHRlckhhbmRsZSh1cmwpLFxyXG4gICAgICAgIHN0YXR1cyA9IChhZGFwdGVySGFuZGxlICYmIGFkYXB0ZXJIYW5kbGUuc3RhdHVzKTtcclxuXHJcbiAgICBpZihvbGRBZGFwdGVySGFuZGxlID09IGFkYXB0ZXJIYW5kbGUpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgaWYgKHN0YXR1cyA9PT0gQWRhcHRlckhhbmRsZS5TVEFUVVMuTk9UX0ZPVU5EKSB7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJDb3VsZCBub3QgZmluZCBlbGVtZW50IG9mIHVybCAnXCIgKyBhZGFwdGVySGFuZGxlLnVybCArIFwiJyBmb3IgXCIgKyBrZXksIHRoaXMubm9kZSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmNvbm5lY3RBZGFwdGVySGFuZGxlKGtleSwgYWRhcHRlckhhbmRsZSk7XHJcbiAgICB0aGlzLmNvbm5lY3RlZEFkYXB0ZXJDaGFuZ2VkKGtleSwgYWRhcHRlckhhbmRsZSA/IGFkYXB0ZXJIYW5kbGUuZ2V0QWRhcHRlcigpIDogbnVsbCwgc3RhdHVzKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQHBhcmFtIGV2dCBub3RpZmljYXRpb24gb2YgdHlwZSBYTUwzRC5Ob3RpZmljYXRpb25cclxuICovXHJcbkRhdGFmbG93RGF0YUFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeUNoYW5nZWQgPSBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICBpZiAoZXZ0LnR5cGUgPT09IEV2ZW50cy5BREFQVEVSX0hBTkRMRV9DSEFOR0VEKSB7XHJcbiAgICAgICAgLy9UT0RPOiBIYW5kbGUgQURBUFRFUl9IQU5ETEVfQ0hBTkdFRFxyXG4gICAgICAgIGlmICh0aGlzLmV4dGVybmFsU2NyaXB0c1tldnQua2V5XSkge1xyXG4gICAgICAgICAgICB3aW5kb3cuZXZhbChldnQuYWRhcHRlci5zY3JpcHQpO1xyXG4gICAgICAgICAgICBzZXRMb2FkaW5nU3RhdGVGb3JNYXRjaGluZ1hmbG93Tm9kZXModGhpcy54Zmxvd0RhdGFOb2RlLCBldnQua2V5LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMueGZsb3dEYXRhTm9kZS5ub3RpZnkoWEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKTtcclxuICAgICAgICAgICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3dpdGNoIChldnQudHlwZSkge1xyXG4gICAgICAgIGNhc2UgRXZlbnRzLkFEQVBURVJfSEFORExFX0NIQU5HRUQ6XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkQWRhcHRlckNoYW5nZWQoZXZ0LmtleSwgZXZ0LmFkYXB0ZXIsIGV2dC5oYW5kbGVTdGF0dXMpO1xyXG4gICAgICAgICAgICBpZiAoZXZ0LmhhbmRsZVN0YXR1cyA9PT0gQWRhcHRlckhhbmRsZS5TVEFUVVMuTk9UX0ZPVU5EKSB7XHJcbiAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGRhdGFmbG93IG9mIHVybCAnXCIgKyBldnQudXJsLCB0aGlzLm5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIEV2ZW50cy5OT0RFX0lOU0VSVEVEOlxyXG4gICAgICAgIGNhc2UgRXZlbnRzLk5PREVfUkVNT1ZFRDpcclxuICAgICAgICAgICAgdXBkYXRlRGF0YWZsb3dYZmxvd05vZGUodGhpcyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIEV2ZW50cy5WQUxVRV9NT0RJRklFRDpcclxuICAgICAgICAgICAgdmFyIGF0dHIgPSBldnQubXV0YXRpb24uYXR0cmlidXRlTmFtZTtcclxuICAgICAgICAgICAgaWYgKGF0dHIgPT09IFwib3V0XCIpIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZURhdGFmbG93T3V0KHRoaXMpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHIgPT09IFwicGxhdGZvcm1cIikge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlRGF0YWZsb3dYZmxvd05vZGUodGhpcywgdGhpcy5ub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBUcmF2ZXJzZSBhbGwgc3Vibm9kZXMgb2YgYSBkYXRhZmxvdyBhbmQgc2V0IHRoZSBsb2FkaW5nIHN0YXRlIG9mXHJcbiAqIGFsbCBub2RlcyB3aXRoIGEgY29tcHV0ZSBvcGVyYXRvciB0aGF0IHJlbGllcyBvbiB0aGUgbWF0Y2hpbmcgZXh0ZXJuYWwgc2NyaXB0IG5hbWUuXHJcbiAqIEEgY29tcHV0ZSBub2RlIHdpbGwgb25seSBiZSBleGVjdXRlZCBpZiBpdHMgbG9hZGluZyBzdGF0ZSBpcyAnZmFsc2UnIGFuZCBub25lIG9mIGl0cyBjaGlsZHJlbiBhcmUgJ2xvYWRpbmcnLCBzb1xyXG4gKiB0aGlzIGVuc3VyZXMgd2UgZG9uJ3QgZG8gdGhlIGNvbXB1dGUgb3BlcmF0aW9ucyB1bnRpbCB0aGUgZXh0ZXJuYWwgb3BlcmF0b3JzIGhhdmUgYmVlbiBsb2FkZWQuXHJcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IG5vZGUgdGhlIGN1cnJlbnQgbm9kZSB0byBjaGVjayBmb3IgaW5zdGFuY2VzIG9mIHRoZSBnaXZlbiBvcGVyYXRvclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZXh0ZXJuYWwgb3BlcmF0b3IgdG8gY2hlY2sgZm9yXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9hZGluZyB3aGV0aGVyIHRoZSBvcGVyYXRvciBoYXMgZmluaXNoZWQgbG9hZGluZyBvciBub3RcclxuICovXHJcbmZ1bmN0aW9uIHNldExvYWRpbmdTdGF0ZUZvck1hdGNoaW5nWGZsb3dOb2Rlcyhub2RlLCBuYW1lLCBsb2FkaW5nKSB7XHJcbiAgICBpZiAobm9kZS5fY29tcHV0ZU9wZXJhdG9yID09PSBuYW1lKSB7XHJcbiAgICAgICAgbm9kZS5zZXRMb2FkaW5nKGxvYWRpbmcpO1xyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUuX2NoaWxkcmVuKSB7XHJcbiAgICAgICAgdmFyIGkgPSBub2RlLl9jaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICBzZXRMb2FkaW5nU3RhdGVGb3JNYXRjaGluZ1hmbG93Tm9kZXMobm9kZS5fY2hpbGRyZW5baV0sIG5hbWUsIGxvYWRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuRGF0YWZsb3dEYXRhQWRhcHRlci5wcm90b3R5cGUudXBkYXRlWGZsb3dOb2RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdXBkYXRlRGF0YWZsb3dYZmxvd05vZGUodGhpcywgdGhpcy5ub2RlKTtcclxufTtcclxuXHJcbkRhdGFmbG93RGF0YUFkYXB0ZXIucHJvdG90eXBlLmNvbm5lY3RlZEFkYXB0ZXJDaGFuZ2VkID0gZnVuY3Rpb24gKGtleSwgYWRhcHRlciwgc3RhdHVzKSB7XHJcbiAgICB2YXIgeGZsb3dOb2RlID0gdGhpcy5kYXRhZmxvd1JlZnNba2V5XTtcclxuICAgIGlmICh4Zmxvd05vZGUpIHtcclxuICAgICAgICB4Zmxvd05vZGUuZGF0YWZsb3dOb2RlID0gYWRhcHRlciA/IGFkYXB0ZXIuZ2V0WGZsb3dOb2RlKCkgOiBudWxsO1xyXG4gICAgICAgIHhmbG93Tm9kZS5zZXRMb2FkaW5nKHN0YXR1cyA9PT0gQWRhcHRlckhhbmRsZS5TVEFUVVMuTE9BRElORyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVEYXRhZmxvd091dChhZGFwdGVyKSB7XHJcbiAgICB2YXIgb3V0ID0gYWRhcHRlci5ub2RlLmdldEF0dHJpYnV0ZShcIm91dFwiKTtcclxuICAgIGlmIChvdXQpIHtcclxuICAgICAgICBhZGFwdGVyLnhmbG93RGF0YU5vZGUuc2V0RmlsdGVyKFwia2VlcChcIiArIG91dCArIFwiKVwiKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWRhcHRlci54Zmxvd0RhdGFOb2RlLnNldEZpbHRlcihcIlwiKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlRGF0YWZsb3dYZmxvd05vZGUoYWRhcHRlciwgbm9kZSkge1xyXG4gICAgLy8gR2V0dGluZyBwbGF0Zm9ybSBhbmQgbm9kZSB0eXBlIGluZm9ybWF0aW9uIGZvciBhIERhdGFmbG93IG5vZGVcclxuICAgIHZhciBwbGF0Zm9ybSA9IG5vZGUuZ2V0QXR0cmlidXRlKFwicGxhdGZvcm1cIik7XHJcblxyXG4gICAgYWRhcHRlci54Zmxvd0RhdGFOb2RlLnNldENvbXB1dGUoXCJcIik7XHJcbiAgICBhZGFwdGVyLmNsZWFyQWRhcHRlckhhbmRsZXMoKTtcclxuICAgIGFkYXB0ZXIuZGF0YWZsb3dSZWZzID0gW107XHJcbiAgICBhZGFwdGVyLmV4dGVybmFsU2NyaXB0cyA9IHt9O1xyXG4gICAgdXBkYXRlRGF0YWZsb3dPdXQoYWRhcHRlcik7XHJcblxyXG4gICAgdmFyIGNoaWxkID0gbm9kZS5sYXN0RWxlbWVudENoaWxkLCBmaXJzdE5vZGUgPSB0cnVlLCBwcmV2Tm9kZSA9IG51bGwsIGN1cnJlbnROb2RlID0gYWRhcHRlci54Zmxvd0RhdGFOb2RlLCBzdWJBZGFwdGVyLCB4Zmxvd05vZGU7XHJcblxyXG4gICAgZG8ge1xyXG4gICAgICAgIHN1YkFkYXB0ZXIgPSBhZGFwdGVyLmZhY3RvcnkuZ2V0QWRhcHRlcihjaGlsZCk7XHJcbiAgICAgICAgaWYgKCFzdWJBZGFwdGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHN1YkFkYXB0ZXIuZ2V0WGZsb3dOb2RlKSB7XHJcbiAgICAgICAgICAgIHhmbG93Tm9kZSA9IHN1YkFkYXB0ZXIuZ2V0WGZsb3dOb2RlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAocHJldk5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmluc2VydEJlZm9yZSh4Zmxvd05vZGUsIHByZXZOb2RlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmFwcGVuZENoaWxkKHhmbG93Tm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJldk5vZGUgPSB4Zmxvd05vZGU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzdWJBZGFwdGVyLmdldENvbXB1dGVDb2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGF0ZW1lbnRzID0gc3ViQWRhcHRlci5nZXRDb21wdXRlQ29kZSgpLnNwbGl0KFwiO1wiKTtcclxuICAgICAgICAgICAgdmFyIGogPSBzdGF0ZW1lbnRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChqLS0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb21wdXRlID0gc3RhdGVtZW50c1tqXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXB1dGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3ROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb2RlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHhmbG93Tm9kZSA9IG5ldyBEYXRhTm9kZShmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmluc2VydEJlZm9yZSh4Zmxvd05vZGUsIHByZXZOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5hcHBlbmRDaGlsZCh4Zmxvd05vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IHhmbG93Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2Tm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS51c2VyRGF0YSA9IGNoaWxkO1xyXG5cclxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnNldFBsYXRmb3JtKHBsYXRmb3JtKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRDb21wdXRlKHN0YXRlbWVudHNbal0udHJpbSgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUuY29tcHV0ZURhdGFmbG93VXJsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IGFkYXB0ZXIuZGF0YWZsb3dSZWZzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBhZGFwdGVyLmRhdGFmbG93UmVmcy5wdXNoKGN1cnJlbnROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBhZGFwdGVyLnVwZGF0ZUFkYXB0ZXJIYW5kbGUoaWR4LCBjdXJyZW50Tm9kZS5jb21wdXRlRGF0YWZsb3dVcmwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChzdWJBZGFwdGVyLmdldFNjcmlwdFR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIHNjcmlwdElkID0gc3ViQWRhcHRlci5ub2RlLm5hbWU7XHJcbiAgICAgICAgICAgIGlmICghc2NyaXB0SWQpIHtcclxuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiUGFyc2luZyBlcnJvcjogRXh0ZXJuYWxseSByZWZlcmVuY2VkIG9wZXJhdG9ycyBtdXN0IGhhdmUgYSAnbmFtZScgYXR0cmlidXRlIG1hdGNoaW5nIHRoZSBuYW1lIHRoZXkgd2VyZSByZWdpc3RlcmVkIHdpdGguIFwiLCBzdWJBZGFwdGVyLm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgc2NyaXB0SWQgPSBcInVua25vd25fb3BlcmF0b3JcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhZGFwdGVyLmV4dGVybmFsU2NyaXB0c1tzY3JpcHRJZF0gPSBzdWJBZGFwdGVyO1xyXG4gICAgICAgICAgICBpZiAoc3ViQWRhcHRlci5jb25uZWN0ZWRBZGFwdGVySGFuZGxlKSB7XHJcbiAgICAgICAgICAgICAgICBhZGFwdGVyLmNvbm5lY3RBZGFwdGVySGFuZGxlKHNjcmlwdElkLCBzdWJBZGFwdGVyLmNvbm5lY3RlZEFkYXB0ZXJIYW5kbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0gd2hpbGUgKGNoaWxkID0gY2hpbGQucHJldmlvdXNFbGVtZW50U2libGluZyk7XHJcblxyXG4gICAgZm9yICh2YXIgbmFtZSBpbiBhZGFwdGVyLmV4dGVybmFsU2NyaXB0cykge1xyXG4gICAgICAgIC8vIEVuc3VyZSBYRmxvdyBkb2Vzbid0IGV4ZWN1dGUgYW55IGNvbXB1dGUgbm9kZXMgdGhhdCBkZXBlbmQgb24gZXh0ZXJuYWwgc2NyaXB0cyB1bnRpbCB0aGV5J3JlIGxvYWRlZFxyXG4gICAgICAgIHNldExvYWRpbmdTdGF0ZUZvck1hdGNoaW5nWGZsb3dOb2RlcyhhZGFwdGVyLnhmbG93RGF0YU5vZGUsIG5hbWUsIHRydWUpO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEYXRhZmxvd0RhdGFBZGFwdGVyO1xyXG4iLCJ2YXIgTm9kZUFkYXB0ZXJGYWN0b3J5ID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvYWRhcHRlci5qc1wiKS5Ob2RlQWRhcHRlckZhY3Rvcnk7XHJcbnZhciBBc3NldCA9IHJlcXVpcmUoXCIuL2Fzc2V0LmpzXCIpO1xyXG52YXIgTWlzYyA9IHJlcXVpcmUoXCIuL21pc2MuanNcIik7XHJcbnZhciBTY3JpcHREYXRhQWRhcHRlciA9IHJlcXVpcmUoXCIuL3NjcmlwdC5qc1wiKTtcclxudmFyIFRleHR1cmVEYXRhQWRhcHRlciA9IHJlcXVpcmUoXCIuL3RleHR1cmUuanNcIik7XHJcbnZhciBUcmFuc2Zvcm1EYXRhQWRhcHRlciA9IHJlcXVpcmUoXCIuL3RyYW5zZm9ybS5qc1wiKTtcclxudmFyIFZhbHVlRGF0YUFkYXB0ZXIgPSByZXF1aXJlKFwiLi92YWx1ZXMuanNcIik7XHJcbnZhciBEYXRhQWRhcHRlciA9IHJlcXVpcmUoXCIuL2RhdGEuanNcIik7XHJcbnZhciBDb21wdXRlRGF0YUFkYXB0ZXIgPSByZXF1aXJlKFwiLi9jb21wdXRlLmpzXCIpO1xyXG52YXIgRGF0YWZsb3dEYXRhQWRhcHRlciA9IHJlcXVpcmUoXCIuL2RhdGFmbG93LmpzXCIpO1xyXG4vLyBSZWdpc3RlciBKU09OIEhhbmRsZXJcclxucmVxdWlyZShcIi4vanNvbi9mYWN0b3J5LmpzXCIpO1xyXG4vLyBSZWdpc3RlciBKYXZhU2NyaXB0IEhhbmRsZXIgKHJlcXVpcmVkIGZvciBleHRlcm5hbCBzaGFkZS5qcyBKYXZhc2NyaXB0IHJlc291cmNlcylcclxucmVxdWlyZShcIi4vamF2YXNjcmlwdC9mYWN0b3J5LmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdG9yIG9mIFhNTDNERGF0YUFkYXB0ZXJGYWN0b3J5XHJcbiAqIFhNTDNERGF0YUFkYXB0ZXJGYWN0b3J5IGNyZWF0ZXMgRGF0YUFkYXB0ZXIgaW5zdGFuY2VzIGZvciBlbGVtZW50cyB1c2luZyBnZW5lcmljIGRhdGEgKDxtZXNoPiwgPGRhdGE+LCA8ZmxvYXQ+LC4uLikuXHJcbiAqIEFkZGl0aW9uYWxseSwgaXQgbWFuYWdlcyBhbGwgRGF0YUFkYXB0ZXIgaW5zdGFuY2VzIHNvIHRoYXQgZm9yIGVhY2ggbm9kZSB0aGVyZSBpcyBhbHdheXMganVzdCBvbmUgRGF0YUFkYXB0ZXIuIFdoZW5cclxuICogaXQgY3JlYXRlcyBhIERhdGFBZGFwdGVyLCBpdCBjYWxscyBpdHMgaW5pdCBtZXRob2QuXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBBZGFwdGVyRmFjdG9yeVxyXG4gKi9cclxuXHJcbnZhciBYTUwzRERhdGFBZGFwdGVyRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIE5vZGVBZGFwdGVyRmFjdG9yeS5jYWxsKHRoaXMsIFwiZGF0YVwiKTtcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoWE1MM0REYXRhQWRhcHRlckZhY3RvcnksIE5vZGVBZGFwdGVyRmFjdG9yeSk7XHJcblxyXG52YXIgcmVnID0ge1xyXG4gICAgJ21lc2gnOiBNaXNjLlNpbmtEYXRhQWRhcHRlcixcclxuICAgICdtYXRlcmlhbCc6IE1pc2MuU2lua0RhdGFBZGFwdGVyLFxyXG4gICAgJ3NoYWRlcic6IE1pc2MuU2lua0RhdGFBZGFwdGVyLCAvLyBUT0RPKGtzb25zKTogUmVtb3ZlIGluIDUuMVxyXG4gICAgJ2xpZ2h0JzogTWlzYy5TaW5rRGF0YUFkYXB0ZXIsXHJcbiAgICAndmlldyc6IE1pc2MuU2lua0RhdGFBZGFwdGVyLFxyXG4gICAgJ2Zsb2F0JzogVmFsdWVEYXRhQWRhcHRlcixcclxuICAgICdmbG9hdDInOiBWYWx1ZURhdGFBZGFwdGVyLFxyXG4gICAgJ2Zsb2F0Myc6IFZhbHVlRGF0YUFkYXB0ZXIsXHJcbiAgICAnZmxvYXQ0JzogVmFsdWVEYXRhQWRhcHRlcixcclxuICAgICdmbG9hdDR4NCc6IFZhbHVlRGF0YUFkYXB0ZXIsXHJcbiAgICAnaW50JzogVmFsdWVEYXRhQWRhcHRlcixcclxuICAgICdpbnQ0JzogVmFsdWVEYXRhQWRhcHRlcixcclxuICAgICdib29sJzogVmFsdWVEYXRhQWRhcHRlcixcclxuICAgICdieXRlJzogVmFsdWVEYXRhQWRhcHRlcixcclxuICAgICdzdHJpbmcnOiBWYWx1ZURhdGFBZGFwdGVyLFxyXG4gICAgJ3VieXRlJzogVmFsdWVEYXRhQWRhcHRlcixcclxuICAgICdpbWcnOiBNaXNjLkltZ0RhdGFBZGFwdGVyLFxyXG4gICAgJ3RleHR1cmUnOiBUZXh0dXJlRGF0YUFkYXB0ZXIsXHJcbiAgICAnZGF0YSc6IERhdGFBZGFwdGVyLFxyXG4gICAgJ3Byb3RvJzogRGF0YUFkYXB0ZXIsXHJcbiAgICAnZGF0YWZsb3cnOiBEYXRhZmxvd0RhdGFBZGFwdGVyLFxyXG4gICAgJ2NvbXB1dGUnOiBDb21wdXRlRGF0YUFkYXB0ZXIsXHJcbiAgICAndmlkZW8nOiBNaXNjLlZpZGVvRGF0YUFkYXB0ZXIsXHJcbiAgICAnc2NyaXB0JzogU2NyaXB0RGF0YUFkYXB0ZXIsXHJcbiAgICAndHJhbnNmb3JtJzogVHJhbnNmb3JtRGF0YUFkYXB0ZXIsXHJcbiAgICAnYXNzZXQnOiBBc3NldC5Bc3NldEFkYXB0ZXIsXHJcbiAgICAnYXNzZXRkYXRhJzogQXNzZXQuQXNzZXREYXRhQWRhcHRlcixcclxuICAgICdhc3NldG1lc2gnOiBBc3NldC5Bc3NldE1lc2hBZGFwdGVyLFxyXG4gICAgJ21vZGVsJzogQXNzZXQuQXNzZXRBZGFwdGVyXHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIERhdGFBZGFwdGVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gbm9kZS5cclxuICpcclxuICogQHBhcmFtIG5vZGVcclxuICogICAgICAgICAgICBlbGVtZW50IG5vZGUgd2hpY2ggdXNlcyBnZW5lcmljIGRhdGEuIFRoZSBzdXBwb3J0ZWQgZWxlbWVudHNcclxuICogICAgICAgICAgICBhcmUgbGlzdGVkIGluIHRoZSBjbGFzcyBkZXNjcmlwdGlvbiBhYm92ZS5cclxuICogQHJldHVybnMgRGF0YUFkYXB0ZXIgaW5zdGFuY2VcclxuICovXHJcblhNTDNERGF0YUFkYXB0ZXJGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVBZGFwdGVyID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgIC8vWE1MM0QuZGVidWcubG9nRGVidWcoXCJDcmVhdGluZyBhZGFwdGVyOiBcIiArIG5vZGUubG9jYWxOYW1lKTtcclxuICAgIHZhciBhZGFwdGVyQ29udHJ1Y3RvciA9IHJlZ1tub2RlLmxvY2FsTmFtZV07XHJcbiAgICBpZiAoYWRhcHRlckNvbnRydWN0b3IgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgYWRhcHRlckNvbnRydWN0b3IodGhpcywgbm9kZSk7XHJcbiAgICB9XHJcbiAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiTm90IHN1cHBvcnRlZCBhcyBkYXRhIGVsZW1lbnQ6IFwiICsgbm9kZS5sb2NhbE5hbWUpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9ICBYTUwzRERhdGFBZGFwdGVyRmFjdG9yeTtcclxuIiwiXHJcbnZhciBKYXZhU2NyaXB0Rm9ybWF0SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIFhNTDNELnJlc291cmNlLkZvcm1hdEhhbmRsZXIuY2FsbCh0aGlzKTtcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoSmF2YVNjcmlwdEZvcm1hdEhhbmRsZXIsIFhNTDNELnJlc291cmNlLkZvcm1hdEhhbmRsZXIpO1xyXG5cclxuSmF2YVNjcmlwdEZvcm1hdEhhbmRsZXIucHJvdG90eXBlLmlzRm9ybWF0U3VwcG9ydGVkID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICByZXR1cm4gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIikgPT09IFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiO1xyXG59O1xyXG5cclxuXHJcbkphdmFTY3JpcHRGb3JtYXRIYW5kbGVyLnByb3RvdHlwZS5nZXRGb3JtYXREYXRhID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xyXG59O1xyXG5cclxuSmF2YVNjcmlwdEZvcm1hdEhhbmRsZXIucHJvdG90eXBlLmdldEFkYXB0ZXIgPSBmdW5jdGlvbih4Zmxvd05vZGUsIGFzcGVjdCwgY2FudmFzSWQpIHtcclxuICAgIGlmIChhc3BlY3QgPT09IFwiZGF0YVwiKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTY3JpcHREYXRhQWRhcHRlcih4Zmxvd05vZGUpO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgYXNwZWN0ICdcIithc3BlY3QrXCInIGVuY291bnRlcmVkIGluIEphdmFTY3JpcHQgZm9ybWF0IGhhbmRsZXIuXCIpO1xyXG59O1xyXG5cclxuWE1MM0QucmVzb3VyY2UucmVnaXN0ZXJGb3JtYXRIYW5kbGVyKG5ldyBKYXZhU2NyaXB0Rm9ybWF0SGFuZGxlcigpKTtcclxuXHJcblxyXG52YXIgU2NyaXB0RGF0YUFkYXB0ZXIgPSBmdW5jdGlvbiAoc2NyaXB0KSB7XHJcbiAgICB0aGlzLnNjcmlwdCA9IHNjcmlwdDtcclxufTtcclxuXHJcblNjcmlwdERhdGFBZGFwdGVyLnByb3RvdHlwZS5nZXRTY3JpcHRUeXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiO1xyXG59O1xyXG5cclxuU2NyaXB0RGF0YUFkYXB0ZXIucHJvdG90eXBlLmdldFNjcmlwdD0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2NyaXB0O1xyXG59O1xyXG4iLCJ2YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIElucHV0Tm9kZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvZ3JhcGguanNcIikuSW5wdXROb2RlO1xyXG52YXIgRGF0YU5vZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2dyYXBoLmpzXCIpLkRhdGFOb2RlO1xyXG52YXIgQnVmZmVyRW50cnkgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2RhdGEuanNcIikuQnVmZmVyRW50cnk7XHJcbnZhciBBZGFwdGVyRmFjdG9yeSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL2FkYXB0ZXIuanNcIikuQWRhcHRlckZhY3Rvcnk7XHJcblxyXG52YXIgWE1MM0RKU09ORm9ybWF0SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgWE1MM0QucmVzb3VyY2UuRm9ybWF0SGFuZGxlci5jYWxsKHRoaXMpO1xyXG59O1xyXG5YTUwzRC5jcmVhdGVDbGFzcyhYTUwzREpTT05Gb3JtYXRIYW5kbGVyLCBYTUwzRC5yZXNvdXJjZS5Gb3JtYXRIYW5kbGVyKTtcclxuXHJcblhNTDNESlNPTkZvcm1hdEhhbmRsZXIucHJvdG90eXBlLmlzRm9ybWF0U3VwcG9ydGVkID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgIGlmIChyZXNwb25zZS5oZWFkZXJzLmhhcyhcIkNvbnRlbnQtVHlwZVwiKSkge1xyXG4gICAgICAgIHJldHVybiByZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XHJcbiAgICB9XHJcbiAgICBpZiAocmVzcG9uc2UudXJsLm1hdGNoKC9cXC5qc29uLykpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5YTUwzREpTT05Gb3JtYXRIYW5kbGVyLnByb3RvdHlwZS5nZXRGb3JtYXREYXRhID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCkudGhlbihmdW5jdGlvbihqc29uKSB7XHJcbiAgICAgICAgaWYgKGpzb24uZm9ybWF0ICE9IFwieG1sM2QtanNvblwiKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEpTT04gZm9ybWF0OiBcIiArIGpzb24uZm9ybWF0KTtcclxuICAgICAgICBpZiAoanNvbi52ZXJzaW9uICE9IFwiMC40LjBcIilcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gSlNPTiB2ZXJzaW9uOiBcIiArIGpzb24udmVyc2lvbik7XHJcblxyXG4gICAgICAgIHJldHVybiBqc29uO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5YTUwzREpTT05Gb3JtYXRIYW5kbGVyLnByb3RvdHlwZS5nZXRBZGFwdGVyID0gZnVuY3Rpb24oZGF0YSwgYXNwZWN0LCBjYW52YXNJZCkge1xyXG4gICAgaWYgKGFzcGVjdCA9PT0gXCJkYXRhXCIgfHwgYXNwZWN0ID09PSBcInNjZW5lXCIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEpTT05EYXRhQWRhcHRlcihjcmVhdGVYZmxvd05vZGUoZGF0YSwgYXNwZWN0KSk7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBhc3BlY3QgJ1wiK2FzcGVjdCtcIicgZW5jb3VudGVyZWQgaW4gSlNPTiBmb3JtYXQgaGFuZGxlci5cIik7XHJcbn07XHJcblxyXG5YTUwzRC5yZXNvdXJjZS5yZWdpc3RlckZvcm1hdEhhbmRsZXIobmV3IFhNTDNESlNPTkZvcm1hdEhhbmRsZXIoKSk7XHJcblxyXG5cclxudmFyIGVtcHR5ID0gZnVuY3Rpb24oKSB7fTtcclxuXHJcbnZhciBUWVBFRF9BUlJBWV9NQVAgPSB7XHJcbiAgICBcImludFwiIDogSW50MzJBcnJheSxcclxuICAgIFwiaW50NFwiIDogSW50MzJBcnJheSxcclxuICAgIFwiZmxvYXRcIiA6IEZsb2F0MzJBcnJheSxcclxuICAgIFwiZmxvYXQyXCIgOiBGbG9hdDMyQXJyYXksXHJcbiAgICBcImZsb2F0M1wiIDogRmxvYXQzMkFycmF5LFxyXG4gICAgXCJmbG9hdDRcIiA6IEZsb2F0MzJBcnJheSxcclxuICAgIFwiZmxvYXQ0eDRcIiA6IEZsb2F0MzJBcnJheSxcclxuICAgIFwiYm9vbFwiIDogVWludDhBcnJheSxcclxuICAgIFwiYnl0ZVwiIDogSW50OEFycmF5LFxyXG4gICAgXCJ1Ynl0ZVwiIDogVWludDhBcnJheSxcclxuICAgIFwic3RyaW5nXCI6IEFycmF5XHJcbn07XHJcblxyXG52YXIgaXNMaXR0bGVFbmRpYW4gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcclxuICAgIHZhciBkdiA9IG5ldyBEYXRhVmlldyhidWYpO1xyXG4gICAgdmFyIHZpZXcgPSBuZXcgSW50MzJBcnJheShidWYpO1xyXG4gICAgdmlld1swXSA9IDB4MDEwMjAzMDQ7XHJcbiAgICB2YXIgbGl0dGxlRW5kaWFuID0gKGR2LmdldEludDMyKDAsIHRydWUpID09PSAweDAxMDIwMzA0KTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaXR0bGVFbmRpYW47IH1cclxufSkoKTtcclxuXHJcbmZ1bmN0aW9uIHJlYWxUeXBlT2Yob2JqKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikuc2xpY2UoOCwgLTEpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVYZmxvd1ZhbHVlKGRhdGFOb2RlLCBkYXRhVHlwZSwgbmFtZSwga2V5LCB2YWx1ZSkge1xyXG4gICAgdmFyIHYgPSBuZXcgKFRZUEVEX0FSUkFZX01BUFtkYXRhVHlwZV0pKHZhbHVlKTtcclxuICAgIHZhciB0eXBlID0gWEMuREFUQV9UWVBFLmZyb21TdHJpbmcoZGF0YVR5cGUpO1xyXG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXJFbnRyeSh0eXBlLCB2KTtcclxuXHJcbiAgICB2YXIgaW5wdXROb2RlID0gbmV3IElucHV0Tm9kZSgpO1xyXG4gICAgaW5wdXROb2RlLmRhdGEgPSBidWZmZXI7XHJcbiAgICBpbnB1dE5vZGUubmFtZSA9IG5hbWU7XHJcbiAgICBpbnB1dE5vZGUua2V5ID0ga2V5O1xyXG4gICAgZGF0YU5vZGUuYXBwZW5kQ2hpbGQoaW5wdXROb2RlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlWGZsb3dWYWx1ZUZyb21CdWZmZXIoZGF0YU5vZGUsIGRhdGFUeXBlLCBuYW1lLCBrZXksIGFycmF5QnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSB7XHJcbiAgICB2YXIgQXJyYXlUeXBlID0gVFlQRURfQVJSQVlfTUFQW2RhdGFUeXBlXTtcclxuICAgIHZhciB2ID0gbmV3IChBcnJheVR5cGUpKGFycmF5QnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoL0FycmF5VHlwZS5CWVRFU19QRVJfRUxFTUVOVCk7XHJcbiAgICB2YXIgdHlwZSA9IFhDLkRBVEFfVFlQRS5mcm9tU3RyaW5nKGRhdGFUeXBlKTtcclxuICAgIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyRW50cnkodHlwZSwgdik7XHJcblxyXG4gICAgdmFyIGlucHV0Tm9kZSA9IG5ldyBJbnB1dE5vZGUoKTtcclxuICAgIGlucHV0Tm9kZS5kYXRhID0gYnVmZmVyO1xyXG4gICAgaW5wdXROb2RlLm5hbWUgPSBuYW1lO1xyXG4gICAgaW5wdXROb2RlLmtleSA9IGtleTtcclxuICAgIGRhdGFOb2RlLmFwcGVuZENoaWxkKGlucHV0Tm9kZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVhmbG93SW5wdXRzKGRhdGFOb2RlLCBuYW1lLCBqc29uRGF0YSl7XHJcbiAgICB2YXIgdiA9IG51bGw7XHJcblxyXG4gICAgaWYgKCFUWVBFRF9BUlJBWV9NQVBbanNvbkRhdGEudHlwZV0pXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBqc29uRGF0YS5zZXEubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICB2YXIgZW50cnkgPSBqc29uRGF0YS5zZXFbaV07XHJcbiAgICAgICAgdmFyIHZhbHVlID0gZW50cnkudmFsdWU7XHJcbiAgICAgICAgdmFyIGtleSA9IGVudHJ5LmtleTtcclxuXHJcbiAgICAgICAgaWYgKHJlYWxUeXBlT2YodmFsdWUpID09PSAnT2JqZWN0JyAmJiB2YWx1ZS51cmwpIHtcclxuICAgICAgICAgICAgaWYgKCFpc0xpdHRsZUVuZGlhbigpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBhZGQgYmlnLWVuZGlhbiAtPiBsaXR0bGUtZW5kaWFuIGNvbnZlcnNpb25cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJpZy1lbmRpYW4gYmluYXJ5IGRhdGEgYXJlIG5vdCBzdXBwb3J0ZWQgeWV0XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFhNTDNELnJlc291cmNlLmZldGNoKHZhbHVlLnVybClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihhcnJheUJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVhmbG93VmFsdWVGcm9tQnVmZmVyKGRhdGFOb2RlLCBqc29uRGF0YS50eXBlLCBuYW1lLCBrZXksIGFycmF5QnVmZmVyLCB2YWx1ZS5ieXRlT2Zmc2V0LCB2YWx1ZS5ieXRlTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNyZWF0ZVhmbG93VmFsdWUoZGF0YU5vZGUsIGpzb25EYXRhLnR5cGUsIG5hbWUsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlWGZsb3dOb2RlKGpzb25EYXRhLCBhc3BlY3Qpe1xyXG5cclxuICAgIHZhciBub2RlID0gbmV3IERhdGFOb2RlKGZhbHNlKTtcclxuICAgIG5vZGUudXNlckRhdGEgPSBcIkV4dGVybmFsIEpzb25cIjsgLy8gVE9ETzogVHJ5IHRvIGFkZCBkb2N1bWVudCBVUkwgaGVyZSAoaG93IHRvIGdldCBpdD8pXHJcblxyXG4gICAgdmFyIGVudHJpZXM7XHJcbiAgICBpZiAoYXNwZWN0ID09PSBcInNjZW5lXCIpXHJcbiAgICAgICAgZW50cmllcyA9IGpzb25EYXRhLm1hdGVyaWFsO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIGVudHJpZXMgPSBqc29uRGF0YS5kYXRhO1xyXG5cclxuICAgIGZvcih2YXIgbmFtZSBpbiBlbnRyaWVzKSB7XHJcbiAgICAgICAgY3JlYXRlWGZsb3dJbnB1dHMobm9kZSwgbmFtZSwgZW50cmllc1tuYW1lXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9kZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBpbXBsZW1lbnRzIElEYXRhQWRhcHRlclxyXG4gKi9cclxudmFyIEpTT05EYXRhQWRhcHRlciA9IGZ1bmN0aW9uKHhmbG93Tm9kZSkge1xyXG4gICAgdGhpcy54Zmxvd0RhdGFOb2RlID0geGZsb3dOb2RlO1xyXG59O1xyXG5cclxuSlNPTkRhdGFBZGFwdGVyLnByb3RvdHlwZS5nZXRYZmxvd05vZGUgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMueGZsb3dEYXRhTm9kZTtcclxufTtcclxuIiwidmFyIERhdGFBZGFwdGVyID0gcmVxdWlyZShcIi4vZGF0YS5qc1wiKTtcclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xyXG52YXIgVVJJID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL3VyaS5qc1wiKS5VUkk7XHJcbnZhciBVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL21pc2MuanNcIik7XHJcbnZhciBSZXNvdXJjZSA9IHJlcXVpcmUoXCIuLi8uLi9yZXNvdXJjZS9jb29yZGluYXRvci5qc1wiKTtcclxuXHJcbnZhciBOb2RlQWRhcHRlciA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2FkYXB0ZXIuanNcIikuTm9kZUFkYXB0ZXI7XHJcbnZhciBjcmVhdGVDbGFzcyA9IFhNTDNELmNyZWF0ZUNsYXNzO1xyXG5cclxuLyoqXHJcbiAqIFNpbmtEYXRhQWRhcHRlciByZXByZXNlbnRzIHRoZSBzaW5rIGluIHRoZSBkYXRhIGhpZXJhcmNoeSAobm8gcGFyZW50cykuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyB7RGF0YUFkYXB0ZXJ9XHJcbiAqIEBwYXJhbSBmYWN0b3J5XHJcbiAqIEBwYXJhbSBub2RlXHJcbiAqL1xyXG52YXIgU2lua0RhdGFBZGFwdGVyID0gZnVuY3Rpb24oZmFjdG9yeSwgbm9kZSkge1xyXG4gICAgRGF0YUFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlKTtcclxufTtcclxuY3JlYXRlQ2xhc3MoU2lua0RhdGFBZGFwdGVyLCBEYXRhQWRhcHRlciwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBEYXRhQWRhcHRlciBpcyBhIFNpbmtBZGFwdGVyIChoYXMgbm8gcGFyZW50XHJcbiAgICAgKiBEYXRhQWRhcHRlcikuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIERhdGFBZGFwdGVyIGlzIGEgU2lua0FkYXB0ZXIsIG90aGVyd2lzZSBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgaXNTaW5rQWRhcHRlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0YUFkYXB0ZXJcclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gXCJYTUwzRC5kYXRhLlNpbmtEYXRhQWRhcHRlclwiO1xyXG4gICAgfVxyXG59KTtcclxuXHJcblxyXG4gICAgdmFyIEltZ0RhdGFBZGFwdGVyID0gZnVuY3Rpb24oZmFjdG9yeSwgbm9kZSkge1xyXG4gICAgICAgIE5vZGVBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlRW50cnkgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW1hZ2UgPSBudWxsO1xyXG4gICAgICAgIGlmIChub2RlLnNyYylcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVJbWFnZUZyb21VUkwobm9kZS5zcmMpO1xyXG4gICAgfTtcclxuICAgIGNyZWF0ZUNsYXNzKEltZ0RhdGFBZGFwdGVyLCBOb2RlQWRhcHRlciwge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGltYWdlIG9iamVjdFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNyZWF0ZUltYWdlRnJvbVVSTDogZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciB1cmkgPSBuZXcgVVJJKHVybCkuZ2V0QWJzb2x1dGVVUkkodGhpcy5ub2RlLm93bmVyRG9jdW1lbnQuX2RvY3VtZW50VVJMIHx8IHRoaXMubm9kZS5vd25lckRvY3VtZW50LlVSTCk7XHJcbiAgICAgICAgICAgIHZhciBvbmxvYWQgPSBmdW5jdGlvbiAoZSwgaW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGF0LnRleHR1cmVFbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudGV4dHVyZUVudHJ5LnNldEltYWdlKGltYWdlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbiAoZSwgaW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiQ291bGQgbm90IGxvYWQgaW1hZ2UgVVJJPVwiICsgaW1hZ2Uuc3JjKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IFJlc291cmNlLmdldEltYWdlKHVyaSwgb25sb2FkLCBvbmVycm9yKTtcclxuICAgICAgICAgICAgaWYgKHRoYXQudGV4dHVyZUVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnRleHR1cmVFbnRyeS5zZXRJbWFnZSh0aGlzLmltYWdlLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7WGZsb3cuVGV4dHVyZUVudHJ5fSBlbnRyeVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldFRleHR1cmVFbnRyeTogZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZUVudHJ5ID0gZW50cnk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmltYWdlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmVFbnRyeS5zZXRJbWFnZSh0aGlzLmltYWdlLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjazogZnVuY3Rpb24gKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcInNyY1wiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUltYWdlRnJvbVVSTChuZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBub3RpZnlDaGFuZ2VkOiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChjYiwgb2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmltYWdlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldE91dHB1dHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgICAgICByZXN1bHRbJ2ltYWdlJ10gPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlc29sdmVTY3JpcHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIFZpZGVvRGF0YUFkYXB0ZXIgPSBmdW5jdGlvbihmYWN0b3J5LCBub2RlKSB7XHJcbiAgICAgICAgRGF0YUFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlKTtcclxuICAgICAgICB0aGlzLnRleHR1cmVFbnRyeSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52aWRlbyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdGlja2luZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2JvdW5kVGljayA9IHRoaXMuX3RpY2suYmluZCh0aGlzKTtcclxuICAgICAgICBpZiAobm9kZS5zcmMpXHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlVmlkZW9Gcm9tVVJMKG5vZGUuc3JjKTtcclxuICAgIH07XHJcbiAgICBjcmVhdGVDbGFzcyhWaWRlb0RhdGFBZGFwdGVyLCBOb2RlQWRhcHRlcik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHZpZGVvIG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcclxuICAgICAqL1xyXG4gICAgVmlkZW9EYXRhQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlVmlkZW9Gcm9tVVJMID0gZnVuY3Rpb24odXJsKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciB1cmkgPSBuZXcgVVJJKHVybCkuZ2V0QWJzb2x1dGVVUkkodGhpcy5ub2RlLm93bmVyRG9jdW1lbnQuX2RvY3VtZW50VVJMIHx8IHRoaXMubm9kZS5vd25lckRvY3VtZW50LlVSTCk7XHJcbiAgICAgICAgdGhpcy52aWRlbyA9IFJlc291cmNlLmdldFZpZGVvKHVyaSwgdGhpcy5ub2RlLmF1dG9wbGF5LCB0aGlzLm5vZGUubG9vcCwgdGhpcy5ub2RlLm11dGVkLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYW5wbGF5IDogZnVuY3Rpb24oZXZlbnQsIHZpZGVvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgVXRpbC5kaXNwYXRjaEN1c3RvbUV2ZW50KHRoYXQubm9kZSwgJ2NhbnBsYXknLCB0cnVlLCB0cnVlLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9zdGFydFZpZGVvUmVmcmVzaCgpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVuZGVkIDogZnVuY3Rpb24oZXZlbnQsIHZpZGVvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgVXRpbC5kaXNwYXRjaEN1c3RvbUV2ZW50KHRoYXQubm9kZSwgJ2VuZGVkJywgdHJ1ZSwgdHJ1ZSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbG9hZCA6IGZ1bmN0aW9uKGV2ZW50LCB2aWRlbykge1xyXG4gICAgICAgICAgICAgICAgICAgIFV0aWwuZGlzcGF0Y2hFdmVudCh0aGF0Lm5vZGUsICdsb2FkJyk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZXJyb3IgOiBmdW5jdGlvbihldmVudCwgdmlkZW8pIHtcclxuICAgICAgICAgICAgICAgICAgICBVdGlsLmRpc3BhdGNoQ3VzdG9tRXZlbnQodGhhdC5ub2RlLCAnZXJyb3InLCB0cnVlLCB0cnVlLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNvdWxkIG5vdCBsb2FkIHZpZGVvIFVSST1cIit2aWRlby5zcmMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuICAgICAgICBpZiAodGhpcy50ZXh0dXJlRW50cnkpXHJcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZUVudHJ5LnNldEltYWdlKHRoaXMudmlkZW8sIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBWaWRlb0RhdGFBZGFwdGVyLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmlkZW8pXHJcbiAgICAgICAgICAgIHRoaXMudmlkZW8ucGxheSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBWaWRlb0RhdGFBZGFwdGVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnZpZGVvKVxyXG4gICAgICAgICAgICB0aGlzLnZpZGVvLnBhdXNlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIFZpZGVvRGF0YUFkYXB0ZXIucHJvdG90eXBlLl9zdGFydFZpZGVvUmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fdGlja2luZylcclxuICAgICAgICAgICAgdGhpcy5fdGljaygpO1xyXG4gICAgfTtcclxuXHJcbiAgICBWaWRlb0RhdGFBZGFwdGVyLnByb3RvdHlwZS5fdGljayA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX3RpY2tpbmcgPSB0cnVlO1xyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fYm91bmRUaWNrKTtcclxuICAgICAgICAvLyBGSVhNRSBEbyB0aGlzIG9ubHkgd2hlbiBjdXJyZW50VGltZSBpcyBjaGFuZ2VkICh3aGF0IGFib3V0IHdlYmNhbSA/KVxyXG4gICAgICAgIGlmICh0aGlzLnRleHR1cmVFbnRyeSkge1xyXG4gICAgICAgICAgICB0aGlzLnRleHR1cmVFbnRyeS5zZXRJbWFnZSh0aGlzLnZpZGVvKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtYZmxvdy5UZXh0dXJlRW50cnl9IGVudHJ5XHJcbiAgICAgKi9cclxuICAgIFZpZGVvRGF0YUFkYXB0ZXIucHJvdG90eXBlLnNldFRleHR1cmVFbnRyeSA9IGZ1bmN0aW9uKGVudHJ5KSB7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlRW50cnkgPSBlbnRyeTtcclxuICAgICAgICBpZiAodGhpcy52aWRlbykge1xyXG4gICAgICAgICAgICB0aGlzLnRleHR1cmVFbnRyeS5zZXRJbWFnZSh0aGlzLnZpZGVvLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIFZpZGVvRGF0YUFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeUNoYW5nZWQgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIH07XHJcblxyXG4gICAgVmlkZW9EYXRhQWRhcHRlci5wcm90b3R5cGUuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrID0gZnVuY3Rpb24gKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xyXG4gICAgICAgIGlmIChuYW1lID09IFwic3JjXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVWaWRlb0Zyb21VUkwobmV3VmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgVmlkZW9EYXRhQWRhcHRlci5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbihjYiwgb2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlkZW87XHJcbiAgICB9O1xyXG5cclxuICAgIFZpZGVvRGF0YUFkYXB0ZXIucHJvdG90eXBlLmdldE91dHB1dHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICAgICAgcmVzdWx0Wyd2aWRlbyddID0gdGhpcztcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBFeHBvcnRcclxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgICAgIEltZ0RhdGFBZGFwdGVyOiBJbWdEYXRhQWRhcHRlcixcclxuICAgICAgICBWaWRlb0RhdGFBZGFwdGVyOiBWaWRlb0RhdGFBZGFwdGVyLFxyXG4gICAgICAgIFNpbmtEYXRhQWRhcHRlcjogU2lua0RhdGFBZGFwdGVyXHJcbiAgICB9O1xyXG5cclxuIiwidmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xyXG52YXIgY3JlYXRlQ2xhc3MgPSBYTUwzRC5jcmVhdGVDbGFzcztcclxudmFyIE5vZGVBZGFwdGVyID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvYWRhcHRlci5qc1wiKS5Ob2RlQWRhcHRlcjtcclxuXHJcbnZhciBTY3JpcHREYXRhQWRhcHRlciA9IGZ1bmN0aW9uKGZhY3RvcnksIG5vZGUpIHtcclxuICAgIE5vZGVBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XHJcbiAgICB0aGlzLmNvbm5lY3RlZEFkYXB0ZXJIYW5kbGUgPSBudWxsO1xyXG4gICAgaWYgKG5vZGUuc3JjKSB7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlID0gdGhpcy5nZXRBZGFwdGVySGFuZGxlKG5vZGUuc3JjKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3RBZGFwdGVySGFuZGxlKG5vZGUubmFtZSwgdGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlKTtcclxuICAgIH1cclxufTtcclxuXHJcbmNyZWF0ZUNsYXNzKFNjcmlwdERhdGFBZGFwdGVyLCBOb2RlQWRhcHRlciwge1xyXG5cclxuICAgIGdldFNjcmlwdFR5cGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLnR5cGU7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFNjcmlwdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm5vZGUuc3JjKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2NyaXB0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IGZ1bmN0aW9uIChuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcclxuICAgICAgICB0aGlzLm5vdGlmeU9wcG9zaXRlQWRhcHRlcnMoKTtcclxuICAgIH0sXHJcblxyXG4gICAgbm90aWZ5Q2hhbmdlZDogZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIHN3aXRjaCAoZXZ0LnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBFdmVudHMuTk9ERV9JTlNFUlRFRDpcclxuICAgICAgICAgICAgY2FzZSBFdmVudHMuTk9ERV9SRU1PVkVEOlxyXG4gICAgICAgICAgICBjYXNlIEV2ZW50cy5WQUxVRV9NT0RJRklFRDpcclxuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5T3Bwb3NpdGVBZGFwdGVycygpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIEV2ZW50cy5BREFQVEVSX0hBTkRMRV9DSEFOR0VEOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5leHRlcm5hbFNjcmlwdCA9IGV2dC5hZGFwdGVyLnNjcmlwdDtcclxuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5T3Bwb3NpdGVBZGFwdGVycygpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2NyaXB0RGF0YUFkYXB0ZXI7XHJcbiIsInZhciBUZXh0dXJlRW50cnkgPSByZXF1aXJlKFwiLi4vLi4veGZsb3cvaW50ZXJmYWNlL2RhdGEuanNcIikuVGV4dHVyZUVudHJ5O1xyXG52YXIgSW5wdXROb2RlID0gcmVxdWlyZShcIi4uLy4uL3hmbG93L2ludGVyZmFjZS9ncmFwaC5qc1wiKS5JbnB1dE5vZGU7XHJcbnZhciBYQyA9IHJlcXVpcmUoXCIuLi8uLi94Zmxvdy9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xyXG52YXIgRXZlbnRzID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZS9ub3RpZmljYXRpb24uanNcIik7XHJcbnZhciBOb2RlQWRhcHRlciA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2FkYXB0ZXIuanNcIikuTm9kZUFkYXB0ZXI7XHJcbnZhciBHTCA9IHJlcXVpcmUoXCIuLi8uLi9yZW5kZXJlci93ZWJnbC9jb25zdGFudHMuanNcIik7XHJcblxyXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCdsb2Rhc2guZGVmYXVsdHMnKTtcclxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ2xvZGFzaC5hc3NpZ24nKTtcclxuXHJcblxyXG52YXIgVGV4dHVyZURhdGFBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcclxuICAgIE5vZGVBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhUZXh0dXJlRGF0YUFkYXB0ZXIsIE5vZGVBZGFwdGVyLCB7XHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMueGZsb3dJbnB1dE5vZGUgPSB0aGlzLmNyZWF0ZVhmbG93Tm9kZSgpO1xyXG4gICAgICAgIHRoaXMueGZsb3dJbnB1dE5vZGUuZGF0YSA9IHRoaXMuY3JlYXRlVGV4dHVyZUVudHJ5KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVRleHR1cmVFbnRyeTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlO1xyXG4gICAgICAgIHZhciBlbnRyeSA9IG5ldyBUZXh0dXJlRW50cnkobnVsbCk7XHJcbiAgICAgICAgaW5pdFRleHR1cmVTYW1wbGluZ1BhcmFtZXRlcnMoZW50cnkuZ2V0U2FtcGxlckNvbmZpZygpLCBub2RlLmdldEF0dHJpYnV0ZShcIndyYXBcIiksIG5vZGUuZ2V0QXR0cmlidXRlKFwiZmlsdGVyXCIpLCBub2RlLmdldEF0dHJpYnV0ZShcImFuaXNvdHJvcHlcIikpO1xyXG5cclxuICAgICAgICB2YXIgaW1hZ2VBZGFwdGVyID0gdGhpcy5mYWN0b3J5LmdldEFkYXB0ZXIodGhpcy5ub2RlLmZpcnN0RWxlbWVudENoaWxkKTtcclxuICAgICAgICBpZiAoaW1hZ2VBZGFwdGVyKSB7XHJcbiAgICAgICAgICAgIGltYWdlQWRhcHRlci5zZXRUZXh0dXJlRW50cnkoZW50cnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZW50cnk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNob3VsZEdlbmVyYXRlTWlwTWFwczogc2hvdWxkR2VuZXJhdGVNaXBNYXBzLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtJbnB1dE5vZGV9XHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZVhmbG93Tm9kZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB4bm9kZSA9IG5ldyBJbnB1dE5vZGUoKTtcclxuICAgICAgICB4bm9kZS5uYW1lID0gdGhpcy5ub2RlLm5hbWU7XHJcbiAgICAgICAgeG5vZGUucGFyYW1OYW1lID0gdGhpcy5ub2RlLnBhcmFtID8gdGhpcy5ub2RlLm5hbWUgOiBudWxsO1xyXG4gICAgICAgIHhub2RlLmtleSA9IHRoaXMubm9kZS5rZXk7XHJcbiAgICAgICAgcmV0dXJuIHhub2RlO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTY3JpcHRWYWx1ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiVGV4dHVyZSBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCBzZXRTY3JpcHRWYWx1ZSgpXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRPdXRwdXRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIHJlc3VsdFt0aGlzLm5vZGUubmFtZV0gPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgICB9LFxyXG5cclxuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjazogZnVuY3Rpb24gKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xyXG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy54Zmxvd0lucHV0Tm9kZS5uYW1lID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInBhcmFtXCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnhmbG93SW5wdXROb2RlLnBhcmFtTmFtZSA9IG5ld1ZhbHVlID8gdGhpcy5ub2RlLm5hbWUgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJrZXlcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMueGZsb3dJbnB1dE5vZGUua2V5ID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIndyYXBcIjpcclxuICAgICAgICAgICAgY2FzZSBcImZpbHRlclwiOlxyXG4gICAgICAgICAgICBjYXNlIFwic2FtcGxlc1wiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy54Zmxvd0lucHV0Tm9kZS5kYXRhID0gdGhpcy5jcmVhdGVUZXh0dXJlRW50cnkoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgbm90aWZ5Q2hhbmdlZDogZnVuY3Rpb24gKCkgeyAvKiBOb3RoaW5nIHRvIGRvICovXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7RWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgZ2V0WGZsb3dOb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueGZsb3dJbnB1dE5vZGU7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbnZhciB3cmFwVG9HTCA9IHtcclxuICAgIFwiY2xhbXBcIjogIEdMLkNMQU1QX1RPX0VER0UsXHJcbiAgICBcInJlcGVhdFwiOiBHTC5SRVBFQVRcclxufTtcclxuXHJcbnZhciBmaWx0ZXJUb0dMID0ge1xyXG4gICAgXCJuZWFyZXN0XCI6IEdMLk5FQVJFU1QsXHJcbiAgICBcImxpbmVhclwiOiBHTC5MSU5FQVIsXHJcbiAgICBcIm5lYXJlc3QtbWlwbWFwLW5lYXJlc3RcIjogR0wuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCxcclxuICAgIFwibGluZWFyLW1pcG1hcC1uZWFyZXN0XCI6IEdMLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCxcclxuICAgIFwibmVhcmVzdC1taXBtYXAtbGluZWFyXCI6IEdMLk5FQVJFU1RfTUlQTUFQX0xJTkVBUixcclxuICAgIFwibGluZWFyLW1pcG1hcC1saW5lYXJcIjogR0wuTElORUFSX01JUE1BUF9MSU5FQVJcclxufTtcclxuXHJcbmZ1bmN0aW9uIHNob3VsZEdlbmVyYXRlTWlwTWFwcyhtaW5GaWx0ZXIsIG1hZ0ZpbHRlcikge1xyXG4gICAgcmV0dXJuIChtaW5GaWx0ZXIgIT0gR0wuTkVBUkVTVCAmJiBtaW5GaWx0ZXIgIT0gR0wuTElORUFSKSB8fCAobWFnRmlsdGVyICE9IEdMLk5FQVJFU1QgJiYgbWFnRmlsdGVyICE9IEdMLkxJTkVBUik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlVGV4dHVyZVNhbXBsaW5nUGFyYW1ldGVycyh3cmFwLCBmaWx0ZXIsIGFuaXNvdHJvcHkpIHtcclxuICAgIHZhciByZXN1bHQgPSB7fSwgYXJncztcclxuXHJcbiAgICBpZih3cmFwKSB7XHJcbiAgICAgICAgYXJncyA9IHdyYXAuc3BsaXQoLyhcXHMrKS8pO1xyXG4gICAgICAgIHJlc3VsdC53cmFwUyA9IHdyYXBUb0dMW2FyZ3NbMF1dO1xyXG4gICAgICAgIHJlc3VsdC53cmFwVCA9IHdyYXBUb0dMW2FyZ3NbYXJncy5sZW5ndGggLSAxXV07XHJcbiAgICB9XHJcblxyXG4gICAgaWYoZmlsdGVyKSB7XHJcbiAgICAgICAgYXJncyA9IGZpbHRlci5zcGxpdCgvKFxccyspLyk7XHJcbiAgICAgICAgcmVzdWx0Lm1pbkZpbHRlciA9IGZpbHRlclRvR0xbYXJnc1swXV07XHJcbiAgICAgICAgcmVzdWx0Lm1hZ0ZpbHRlciA9IGZpbHRlclRvR0xbYXJnc1thcmdzLmxlbmd0aCAtIDFdXTtcclxuICAgIH1cclxuXHJcbiAgICBpZihhbmlzb3Ryb3B5KSB7XHJcbiAgICAgICAgdmFyIG51bWJlciA9IHBhcnNlRmxvYXQoYW5pc290cm9weSk7XHJcbiAgICAgICAgaWYgKGlzTmFOKG51bWJlcikpIHtcclxuICAgICAgICAgICAgbnVtYmVyID0gYW5pc290cm9weSA9PSBcIm1heFwiID8gSW5maW5pdHkgOiB1bmRlZmluZWRcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBudW1iZXIgPSBNYXRoLm1pbigxLjAsIG51bWJlcilcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LmFuaXNvdHJvcHkgPSBudW1iZXI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZnVuY3Rpb24gaW5pdFRleHR1cmVTYW1wbGluZ1BhcmFtZXRlcnMoY29uZmlnLCB3cmFwLCBmaWx0ZXIsIHNhbXBsZXMpIHtcclxuICAgIHZhciBwYXJhbXMgPSBwYXJzZVRleHR1cmVTYW1wbGluZ1BhcmFtZXRlcnMod3JhcCwgZmlsdGVyLCBzYW1wbGVzKTtcclxuICAgIGRlZmF1bHRzKHBhcmFtcywge1xyXG4gICAgICAgIHdyYXBTOiBHTC5DTEFNUF9UT19FREdFLFxyXG4gICAgICAgIHdyYXBUOiBHTC5DTEFNUF9UT19FREdFLFxyXG4gICAgICAgIG1pbkZpbHRlcjogR0wuTElORUFSX01JUE1BUF9MSU5FQVIsXHJcbiAgICAgICAgbWFnRmlsdGVyOiBHTC5MSU5FQVIsXHJcbiAgICAgICAgdGV4dHVyZVR5cGU6IFhDLlRFWF9UWVBFLlRFWFRVUkVfMkQsXHJcbiAgICAgICAgYW5pc290cm9weTogMVxyXG4gICAgfSk7XHJcbiAgICBhc3NpZ24oY29uZmlnLCBwYXJhbXMpO1xyXG4gICAgY29uZmlnLmdlbmVyYXRlTWlwTWFwID0gc2hvdWxkR2VuZXJhdGVNaXBNYXBzKGNvbmZpZy5taW5GaWx0ZXIsIGNvbmZpZy5tYWdGaWx0ZXIpO1xyXG59XHJcblxyXG4vLyBFeHBvcnRcclxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlRGF0YUFkYXB0ZXI7XHJcbiIsInZhciBFdmVudHMgPSByZXF1aXJlKFwiLi4vLi4vaW50ZXJmYWNlL25vdGlmaWNhdGlvbi5qc1wiKTtcclxudmFyIE5vZGVBZGFwdGVyID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvYWRhcHRlci5qc1wiKS5Ob2RlQWRhcHRlcjtcclxudmFyIG1hdDQgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLm1hdDQ7XHJcbnZhciB2ZWMzID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS52ZWMzO1xyXG5cclxudmFyIFRyYW5zZm9ybURhdGFBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcclxuICAgIE5vZGVBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XHJcbiAgICB0aGlzLmlzVmFsaWQgPSB0cnVlO1xyXG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhUcmFuc2Zvcm1EYXRhQWRhcHRlciwgTm9kZUFkYXB0ZXIpO1xyXG5cclxudmFyIElERU5UX01BVCA9IG1hdDQuY3JlYXRlKCk7XHJcblxyXG5UcmFuc2Zvcm1EYXRhQWRhcHRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIENyZWF0ZSBhbGwgbWF0cmljZXMsIG5vIHZhbGlkIHZhbHVlcyB5ZXRcclxuICAgIHRoaXMubWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcclxuICAgIHRoaXMudHJhbnNmb3JtID0ge1xyXG4gICAgICAgIHRyYW5zbGF0ZTogbWF0NC5jcmVhdGUoKSxcclxuICAgICAgICBzY2FsZTogbWF0NC5jcmVhdGUoKSxcclxuICAgICAgICBzY2FsZU9yaWVudGF0aW9uOiBtYXQ0LmNyZWF0ZSgpLFxyXG4gICAgICAgIHNjYWxlT3JpZW50YXRpb25JbnY6IG1hdDQuY3JlYXRlKCksXHJcbiAgICAgICAgY2VudGVyOiBtYXQ0LmNyZWF0ZSgpLFxyXG4gICAgICAgIGNlbnRlckludmVyc2U6IG1hdDQuY3JlYXRlKCksXHJcbiAgICAgICAgcm90YXRpb246IG1hdDQuY3JlYXRlKClcclxuICAgIH07XHJcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgIHRoaXMuY2hlY2tGb3JJbXByb3Blck5lc3RpbmcoKTtcclxufTtcclxuXHJcblRyYW5zZm9ybURhdGFBZGFwdGVyLnByb3RvdHlwZS51cGRhdGVNYXRyaXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbiA9IHRoaXMubm9kZTtcclxuICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybTtcclxuICAgIHZhciBjZW50ZXJWZWMgPSBuLmNlbnRlci5kYXRhO1xyXG4gICAgdmFyIHNvID0gbi5zY2FsZU9yaWVudGF0aW9uLmRhdGE7XHJcbiAgICB2YXIgcm8gPSBuLnJvdGF0aW9uLmRhdGE7XHJcblxyXG4gICAgbWF0NC5mcm9tUm90YXRpb24odHJhbnNmb3JtLnNjYWxlT3JpZW50YXRpb24sIHNvWzNdLCBzbyk7XHJcbiAgICBtYXQ0LmZyb21Sb3RhdGlvbih0cmFuc2Zvcm0ucm90YXRpb24sIHJvWzNdLCBybyk7XHJcblxyXG4gICAgbWF0NC50cmFuc2xhdGUodHJhbnNmb3JtLnRyYW5zbGF0ZSwgSURFTlRfTUFULCBuLnRyYW5zbGF0aW9uLmRhdGEpO1xyXG4gICAgbWF0NC50cmFuc2xhdGUodHJhbnNmb3JtLmNlbnRlciwgSURFTlRfTUFULCBjZW50ZXJWZWMpO1xyXG4gICAgbWF0NC50cmFuc2xhdGUodHJhbnNmb3JtLmNlbnRlckludmVyc2UsIElERU5UX01BVCwgdmVjMy5uZWdhdGUoY2VudGVyVmVjLCBjZW50ZXJWZWMpKTtcclxuICAgIG1hdDQuc2NhbGUodHJhbnNmb3JtLnNjYWxlLCBJREVOVF9NQVQsIG4uc2NhbGUuZGF0YSk7XHJcbiAgICBtYXQ0LmludmVydCh0cmFuc2Zvcm0uc2NhbGVPcmllbnRhdGlvbkludiwgdHJhbnNmb3JtLnNjYWxlT3JpZW50YXRpb24pO1xyXG5cclxuICAgIG11bHRpcGx5Q29tcG9uZW50cyh0cmFuc2Zvcm0sIHRoaXMubWF0cml4KTtcclxuICAgIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIG11bHRpcGx5Q29tcG9uZW50cyh0cmFuc2Zvcm0sIG1hdHJpeCkge1xyXG4gICAgLy8gTSA9IFQgKiBDXHJcbiAgICBtYXQ0Lm11bHRpcGx5KG1hdHJpeCwgdHJhbnNmb3JtLnRyYW5zbGF0ZSwgdHJhbnNmb3JtLmNlbnRlcik7XHJcbiAgICAvLyBNID0gVCAqIEMgKiBSXHJcbiAgICBtYXQ0Lm11bHRpcGx5KG1hdHJpeCwgbWF0cml4LCB0cmFuc2Zvcm0ucm90YXRpb24pO1xyXG4gICAgLy8gTSA9IFQgKiBDICogUiAqIFNPXHJcbiAgICBtYXQ0Lm11bHRpcGx5KG1hdHJpeCwgbWF0cml4LCB0cmFuc2Zvcm0uc2NhbGVPcmllbnRhdGlvbik7XHJcbiAgICAvLyBNID0gVCAqIEMgKiBSICogU08gKiBTXHJcbiAgICBtYXQ0Lm11bHRpcGx5KG1hdHJpeCwgbWF0cml4LCB0cmFuc2Zvcm0uc2NhbGUpO1xyXG4gICAgLy8gTSA9IFQgKiBDICogUiAqIFNPICogUyAqIC1TT1xyXG4gICAgbWF0NC5tdWx0aXBseShtYXRyaXgsIG1hdHJpeCwgdHJhbnNmb3JtLnNjYWxlT3JpZW50YXRpb25JbnYpO1xyXG4gICAgLy8gTSA9IFQgKiBDICogUiAqIFNPICogUyAqIC1TTyAqIC1DXHJcbiAgICBtYXQ0Lm11bHRpcGx5KG1hdHJpeCwgbWF0cml4LCB0cmFuc2Zvcm0uY2VudGVySW52ZXJzZSk7XHJcbn1cclxuXHJcblRyYW5zZm9ybURhdGFBZGFwdGVyLnByb3RvdHlwZS5nZXRNYXRyaXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLm5lZWRzVXBkYXRlICYmIHRoaXMudXBkYXRlTWF0cml4KCk7XHJcbiAgICByZXR1cm4gdGhpcy5tYXRyaXg7XHJcbn07XHJcblxyXG5UcmFuc2Zvcm1EYXRhQWRhcHRlci5wcm90b3R5cGUuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrID0gZnVuY3Rpb24gKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xyXG4gICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgdGhpcy5ub3RpZnlPcHBvc2l0ZUFkYXB0ZXJzKEV2ZW50cy5BREFQVEVSX1ZBTFVFX0NIQU5HRUQpO1xyXG59O1xyXG5cclxuVHJhbnNmb3JtRGF0YUFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeUNoYW5nZWQgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgaWYgKGUudHlwZSA9PSBFdmVudHMuTk9ERV9SRU1PVkVEKSB7XHJcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy5ub3RpZnlPcHBvc2l0ZUFkYXB0ZXJzKEV2ZW50cy5BREFQVEVSX0hBTkRMRV9DSEFOR0VEKTtcclxuICAgIH1cclxufTtcclxuVHJhbnNmb3JtRGF0YUFkYXB0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmlzVmFsaWQgPSBmYWxzZTtcclxufTtcclxuXHJcblRyYW5zZm9ybURhdGFBZGFwdGVyLnByb3RvdHlwZS5jaGVja0ZvckltcHJvcGVyTmVzdGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAodGhpcy5ub2RlLmNoaWxkTm9kZXNbaV0ubG9jYWxOYW1lID09PSBcInRyYW5zZm9ybVwiKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiUGFyc2luZyBlcnJvcjogVHJhbnNmb3JtIGVsZW1lbnRzIGNhbm5vdCBiZSBuZXN0ZWQhXCIsIHRoaXMubm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gRXhwb3J0IHRvIFhNTDNELmRhdGEgbmFtZXNwYWNlXHJcbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtRGF0YUFkYXB0ZXI7XHJcblxyXG5cclxuXHJcbiIsInZhciBCdWZmZXJFbnRyeSA9IHJlcXVpcmUoXCIuLi8uLi94Zmxvdy9pbnRlcmZhY2UvZGF0YS5qc1wiKS5CdWZmZXJFbnRyeTtcclxudmFyIElucHV0Tm9kZSA9IHJlcXVpcmUoXCIuLi8uLi94Zmxvdy9pbnRlcmZhY2UvZ3JhcGguanNcIikuSW5wdXROb2RlO1xyXG52YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xyXG52YXIgTm9kZUFkYXB0ZXIgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9hZGFwdGVyLmpzXCIpLk5vZGVBZGFwdGVyO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdG9yIG9mIFhNTDNELmRhdGEuVmFsdWVEYXRhQWRhcHRlclxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBYTUwzRC5kYXRhLkRhdGFBZGFwdGVyXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKlxyXG4gKiBAcGFyYW0gZmFjdG9yeVxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcclxuICovXHJcbnZhciBWYWx1ZURhdGFBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcclxuICAgIE5vZGVBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XHJcbiAgICB0aGlzLnhmbG93SW5wdXROb2RlID0gbnVsbDtcclxuICAgIHRoaXMudHlwZSA9IFhDLkRBVEFfVFlQRS5mcm9tU3RyaW5nKG5vZGUubG9jYWxOYW1lKTtcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoVmFsdWVEYXRhQWRhcHRlciwgTm9kZUFkYXB0ZXIpO1xyXG5cclxuVmFsdWVEYXRhQWRhcHRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKClcclxue1xyXG4gICAgdmFyIGNvbmZpZyA9IHRoaXMubm9kZS5fY29uZmlndXJlZCwgdmFsdWU7XHJcbiAgICBpZih0aGlzLm5vZGUudGV4dENvbnRlbnQgPT0gXCJbdmFsdWUgc2V0IGJ5IHNjcmlwdF1cIil7XHJcbiAgICAgICAgdmFsdWUgPSBjb25maWcuc2NyaXB0VmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICAgIGRlbGV0ZSBjb25maWcuc2NyaXB0VmFsdWU7XHJcbiAgICAgICAgdmFsdWUgPSB0aGlzLm5vZGUudmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gWEMuREFUQV9UWVBFLlNUUklORykge1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUgPyB2YWx1ZS5zcGxpdChcIixcIikgOiBbXTtcclxuICAgIH1cclxuICAgIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyRW50cnkodGhpcy50eXBlLCB2YWx1ZSk7XHJcblxyXG4gICAgdGhpcy54Zmxvd0lucHV0Tm9kZSA9IG5ldyBJbnB1dE5vZGUobnVsbCk7XHJcbiAgICB0aGlzLnhmbG93SW5wdXROb2RlLm5hbWUgPSB0aGlzLm5vZGUubmFtZTtcclxuICAgIHRoaXMueGZsb3dJbnB1dE5vZGUuZGF0YSA9IGJ1ZmZlcjtcclxuICAgIHRoaXMueGZsb3dJbnB1dE5vZGUua2V5ID0gdGhpcy5ub2RlLmtleTtcclxuICAgIHRoaXMueGZsb3dJbnB1dE5vZGUucGFyYW1OYW1lID0gdGhpcy5ub2RlLnBhcmFtID8gdGhpcy5ub2RlLm5hbWUgOiBudWxsO1xyXG4gICAgdGhpcy5jaGVja0ZvckltcHJvcGVyTmVzdGluZygpO1xyXG59O1xyXG5cclxuVmFsdWVEYXRhQWRhcHRlci5wcm90b3R5cGUuZ2V0WGZsb3dOb2RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMueGZsb3dJbnB1dE5vZGU7XHJcbn07XHJcblxyXG4vKipcclxuICpcclxuICovXHJcblZhbHVlRGF0YUFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeUNoYW5nZWQgPSBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICBpZiAoZXZ0LnR5cGUgPT0gRXZlbnRzLlZBTFVFX01PRElGSUVEKSB7XHJcbiAgICAgICAgdmFyIGF0dHIgPSBldnQubXV0YXRpb24uYXR0cmlidXRlTmFtZTtcclxuICAgICAgICBpZiAoIWF0dHIpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMubm9kZS5fY29uZmlndXJlZC5zY3JpcHRWYWx1ZTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5ub2RlLnZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBYQy5EQVRBX1RZUEUuU1RSSU5HKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID8gdmFsdWUuc3BsaXQoXCIsXCIpIDogW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy54Zmxvd0lucHV0Tm9kZS5kYXRhLnNldFZhbHVlKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5WYWx1ZURhdGFBZGFwdGVyLnByb3RvdHlwZS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XHJcbiAgICBpZiAobmFtZSA9PSBcIm5hbWVcIikge1xyXG4gICAgICAgIHRoaXMueGZsb3dJbnB1dE5vZGUubmFtZSA9IG5ld1ZhbHVlO1xyXG4gICAgfSBlbHNlIGlmIChuYW1lID09IFwia2V5XCIpIHtcclxuICAgICAgICB0aGlzLnhmbG93SW5wdXROb2RlLmtleSA9IG5ld1ZhbHVlO1xyXG4gICAgfSBlbHNlIGlmIChuYW1lID09IFwicGFyYW1cIikge1xyXG4gICAgICAgIHRoaXMueGZsb3dJbnB1dE5vZGUucGFyYW1OYW1lID0gbmV3VmFsdWUgPyB0aGlzLm5vZGUubmFtZSA6IG51bGw7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuVmFsdWVEYXRhQWRhcHRlci5wcm90b3R5cGUuc2V0U2NyaXB0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIC8vIFRPRE86IEFkZCBUeXBlIGNoZWNrXHJcbiAgICBpZiAodGhpcy50eXBlID09PSBYQy5EQVRBX1RZUEUuU1RSSU5HKSB7XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA/IHZhbHVlLnNwbGl0KFwiLFwiKSA6IFtdO1xyXG4gICAgfVxyXG4gICAgdGhpcy54Zmxvd0lucHV0Tm9kZS5kYXRhLnNldFZhbHVlKHZhbHVlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGFBZGFwdGVyXHJcbiAqL1xyXG5WYWx1ZURhdGFBZGFwdGVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBcIlhNTDNELmRhdGEuVmFsdWVEYXRhQWRhcHRlclwiO1xyXG59O1xyXG5cclxuVmFsdWVEYXRhQWRhcHRlci5wcm90b3R5cGUuY2hlY2tGb3JJbXByb3Blck5lc3RpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIGZvciAodmFyIGk9MDsgaSA8IHRoaXMubm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKFhDLkRBVEFfVFlQRS5mcm9tU3RyaW5nKHRoaXMubm9kZS5jaGlsZE5vZGVzW2ldLmxvY2FsTmFtZSkpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJQYXJzaW5nIGVycm9yOiBWYWx1ZSBlbGVtZW50cyBjYW5ub3QgYmUgbmVzdGVkIVwiLCB0aGlzLm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8vIEV4cG9ydFxyXG5tb2R1bGUuZXhwb3J0cyA9IFZhbHVlRGF0YUFkYXB0ZXI7XHJcbiIsInZhciBDb21wdXRlUmVxdWVzdCA9IHJlcXVpcmUoXCIuLi94Zmxvdy9pbnRlcmZhY2UvcmVxdWVzdC5qc1wiKS5Db21wdXRlUmVxdWVzdDtcclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xyXG52YXIgQ1NTID0gcmVxdWlyZShcIi4uL3V0aWxzL2Nzcy5qc1wiKTtcclxudmFyIG1hdDQgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLm1hdDQ7XHJcblxyXG52YXIgRE9NVHJhbnNmb3JtRmV0Y2hlciA9IGZ1bmN0aW9uIChvd25lciwgYXR0ck5hbWUsIGRhdGFOYW1lLCBvbmx5RGF0YVRyYW5zZm9ybSkge1xyXG4gICAgdGhpcy5vd25lciA9IG93bmVyO1xyXG4gICAgdGhpcy5ub2RlID0gb3duZXIubm9kZTtcclxuICAgIHRoaXMuYXR0ck5hbWUgPSBhdHRyTmFtZTtcclxuICAgIHRoaXMuZGF0YU5hbWUgPSBkYXRhTmFtZTtcclxuICAgIHRoaXMuYWRhcHRlckhhbmRsZSA9IG51bGw7XHJcbiAgICB0aGlzLnhmbG93UmVxdWVzdCA9IG51bGw7XHJcbiAgICB0aGlzLm9ubHlEYXRhVHJhbnNmb3JtID0gb25seURhdGFUcmFuc2Zvcm0gfHwgZmFsc2U7XHJcbiAgICB0aGlzLl9iaW5kZWRDYWxsYmFjayA9IHRoaXMuX29uQ2hhbmdlLmJpbmQodGhpcyk7XHJcbn07XHJcbkRPTVRyYW5zZm9ybUZldGNoZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy54Zmxvd1JlcXVlc3QgJiYgdGhpcy54Zmxvd1JlcXVlc3QuY2xlYXIoKTtcclxuICAgIHRoaXMueGZsb3dSZXF1ZXN0ID0gbnVsbDtcclxuICAgIHRoaXMuYWRhcHRlckhhbmRsZSAmJiB0aGlzLmFkYXB0ZXJIYW5kbGUucmVtb3ZlTGlzdGVuZXIodGhpcy5fYmluZGVkQ2FsbGJhY2spO1xyXG59O1xyXG5cclxuRE9NVHJhbnNmb3JtRmV0Y2hlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5jbGVhcigpO1xyXG4gICAgZGVsZXRlIHRoaXMub3duZXI7XHJcbiAgICBkZWxldGUgdGhpcy5ub2RlO1xyXG59O1xyXG5cclxuRE9NVHJhbnNmb3JtRmV0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIG5ld0hhbmRsZSA9IHRoaXMub3duZXIuZ2V0QWRhcHRlckhhbmRsZSh0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKHRoaXMuYXR0ck5hbWUpLCBcImRhdGFcIiwgMCk7XHJcbiAgICBpZiAobmV3SGFuZGxlICE9IHRoaXMuYWRhcHRlckhhbmRsZSkge1xyXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmFkYXB0ZXJIYW5kbGUgPSBuZXdIYW5kbGU7XHJcbiAgICAgICAgaWYgKG5ld0hhbmRsZSlcclxuICAgICAgICAgICAgbmV3SGFuZGxlLmFkZExpc3RlbmVyKHRoaXMuX2JpbmRlZENhbGxiYWNrKVxyXG4gICAgfVxyXG4gICAgdGhpcy51cGRhdGVNYXRyaXgoKTtcclxufTtcclxuXHJcbkRPTVRyYW5zZm9ybUZldGNoZXIucHJvdG90eXBlLnVwZGF0ZU1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMub3duZXIub25UcmFuc2Zvcm1DaGFuZ2UodGhpcy5hdHRyTmFtZSwgdGhpcy5nZXRNYXRyaXgoKSk7XHJcbn07XHJcblxyXG5ET01UcmFuc2Zvcm1GZXRjaGVyLnByb3RvdHlwZS5nZXRNYXRyaXggPSAoIGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBJREVOVElUWSA9IG1hdDQuY3JlYXRlKCk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMub25seURhdGFUcmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgdmFyIGNzc01hdHJpeCA9IENTUy5nZXRDU1NNYXRyaXgodGhpcy5ub2RlKTtcclxuICAgICAgICAgICAgaWYgKGNzc01hdHJpeCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENTUy5jb252ZXJ0Q3NzVG9NYXQ0KGNzc01hdHJpeCkuZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYWRhcHRlcjtcclxuICAgICAgICBpZiAodGhpcy5hZGFwdGVySGFuZGxlICYmIChhZGFwdGVyID0gdGhpcy5hZGFwdGVySGFuZGxlLmdldEFkYXB0ZXIoKSkpIHtcclxuICAgICAgICAgICAgaWYgKGFkYXB0ZXIuZ2V0WGZsb3dOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMueGZsb3dSZXF1ZXN0KVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueGZsb3dSZXF1ZXN0ID0gbmV3IENvbXB1dGVSZXF1ZXN0KGFkYXB0ZXIuZ2V0WGZsb3dOb2RlKCksIFt0aGlzLmRhdGFOYW1lXSwgdGhpcy5fYmluZGVkQ2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFSZXN1bHQgPSB0aGlzLnhmbG93UmVxdWVzdC5nZXRSZXN1bHQoKTtcclxuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1EYXRhID0gKGRhdGFSZXN1bHQuZ2V0T3V0cHV0RGF0YSh0aGlzLmRhdGFOYW1lKSAmJiBkYXRhUmVzdWx0LmdldE91dHB1dERhdGEodGhpcy5kYXRhTmFtZSkuZ2V0VmFsdWUoKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtRGF0YSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtRGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYWRhcHRlci5nZXRNYXRyaXgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhZGFwdGVyLmdldE1hdHJpeCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLm9ubHlEYXRhVHJhbnNmb3JtID8gbnVsbCA6IElERU5USVRZO1xyXG4gICAgfTtcclxufSgpKTtcclxuXHJcbkRPTVRyYW5zZm9ybUZldGNoZXIucHJvdG90eXBlLl9vbkNoYW5nZSA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgIGlmIChldnQudHlwZSA9PSBFdmVudHMuQURBUFRFUl9WQUxVRV9DSEFOR0VEKSB7XHJcbiAgICAgICAgdGhpcy5vd25lci5vblRyYW5zZm9ybUNoYW5nZSh0aGlzLmF0dHJOYW1lLCBldnQuYWRhcHRlckhhbmRsZS5nZXRBZGFwdGVyKCkuZ2V0TWF0cml4KCkpO1xyXG4gICAgfSBlbHNlIHsgLy8gSWYgdGhlIGFkYXB0ZXIgY2hhbmdlZCwgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSB0aGUgbWF0cml4XHJcbiAgICAgICAgdGhpcy51cGRhdGVNYXRyaXgoKTtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRE9NVHJhbnNmb3JtRmV0Y2hlcjtcclxuIiwidmFyIGFzc2lnbiA9IHJlcXVpcmUoXCJsb2Rhc2guYXNzaWduXCIpO1xyXG52YXIgY3JlYXRlID0gcmVxdWlyZShcImxvZGFzaC5jcmVhdGVcIik7XHJcblxyXG5pZiAod2luZG93LlhNTDNEICE9PSB1bmRlZmluZWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIGRlZmluZSB0aGUgWE1MM0QgbmFtZXNwYWNlIGEgc2Vjb25kIHRpbWUuIFBsZWFzZSBlbnN1cmUgeG1sM2QuanMgaXMgb25seSBsb2FkZWQgb25jZSFcIik7XHJcbn1cclxuLyoqIEBuYW1lc3BhY2UgKiAqL1xyXG52YXIgWE1MM0QgPSBYTUwzRCB8fCB7fTtcclxudmFyIFhmbG93ID0gWGZsb3cgfHwge307XHJcbndpbmRvdy5YTUwzRCA9IFhNTDNEO1xyXG53aW5kb3cuWGZsb3cgPSBYZmxvdztcclxuXHJcblhNTDNELnZlcnNpb24gPSAnREVWRUxPUE1FTlQgU05BUFNIT1QgKDA3LjAxLjIwMTYgMTM6NDM6MDQgR01UKzAxMDApJztcclxuLyoqIEBjb25zdCAqL1xyXG5YTUwzRC54bWwzZE5TID0gJ2h0dHA6Ly93d3cueG1sM2Qub3JnLzIwMDkveG1sM2QnO1xyXG4vKiogQGNvbnN0ICovXHJcblhNTDNELnhodG1sTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XHJcbi8qKiBAY29uc3QgKi9cclxuWE1MM0Qud2ViZ2xOUyA9ICdodHRwOi8vd3d3LnhtbDNkLm9yZy8yMDA5L3htbDNkL3dlYmdsJztcclxuWE1MM0QuX3htbDNkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFhNTDNELnhtbDNkTlMsIFwieG1sM2RcIik7XHJcblhNTDNELl9wYXJhbGxlbCA9IFhNTDNELl9wYXJhbGxlbCAhPSB1bmRlZmluZWQgPyBYTUwzRC5fcGFyYWxsZWwgOiBmYWxzZTtcclxuWE1MM0QueGh0bWwgPSAhIShkb2N1bWVudC5kb2N0eXBlICYmIG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoZG9jdW1lbnQuZG9jdHlwZSkubWF0Y2goL3hodG1sL2kpKTtcclxuXHJcblhNTDNELmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbih0YWdOYW1lKSB7XHJcbiAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiVGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gVXNlIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaW5zdGVhZC5cIik7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxufTtcclxuXHJcblhNTDNELmV4dGVuZCA9IGFzc2lnbjtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIENvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnQgUGFyZW50IGNsYXNzXHJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gbWV0aG9kcyBNZXRob2RzIHRvIGFkZCB0byB0aGUgY2xhc3NcclxuICogQHJldHVybiB7T2JqZWN0IX1cclxuICovXHJcblhNTDNELmNyZWF0ZUNsYXNzID0gZnVuY3Rpb24ob2JqLCBwYXJlbnQsIG1ldGhvZHMpIHtcclxuICAgIGlmKCFwYXJlbnQpIHtcclxuICAgICAgICBhc3NpZ24ob2JqLnByb3RvdHlwZSwgbWV0aG9kcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIG9iai5wcm90b3R5cGUgPSBjcmVhdGUocGFyZW50LnByb3RvdHlwZSwgbWV0aG9kcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqO1xyXG59O1xyXG5cclxuWE1MM0QuZGVidWcgPSByZXF1aXJlKFwiLi91dGlscy9kZWJ1Zy5qc1wiKTtcclxuWE1MM0QudXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxzL21pc2MuanNcIik7XHJcblhNTDNELm9wdGlvbnMgPSByZXF1aXJlKFwiLi91dGlscy9vcHRpb25zLmpzXCIpO1xyXG5YTUwzRC5tYXRlcmlhbHMgPSByZXF1aXJlKFwiLi9yZW5kZXJlci93ZWJnbC9tYXRlcmlhbHMvdXJuL3JlZ2lzdGVyeS5qc1wiKTtcclxuWE1MM0QucmVzb3VyY2UgPSB7fTtcclxuWE1MM0QuZXh0ZW5kKFhNTDNELnJlc291cmNlLCByZXF1aXJlKFwiLi9yZXNvdXJjZVwiKSk7XHJcblhNTDNELmV4dGVuZChYTUwzRC5yZXNvdXJjZSwgcmVxdWlyZShcIi4vdXRpbHMvdXJpLmpzXCIpKTtcclxuWE1MM0QucmVzb3VyY2UuQXNzZXQgPSByZXF1aXJlKFwiLi9hc3NldC9hc3NldC5qc1wiKS5Bc3NldDtcclxuWE1MM0QucmVzb3VyY2UuU3ViRGF0YSA9IHJlcXVpcmUoXCIuL2Fzc2V0L2Fzc2V0LmpzXCIpLlN1YkRhdGE7XHJcblxyXG5YTUwzRC53ZWJjbCA9IHJlcXVpcmUoXCIuL3V0aWxzL3dlYmNsLmpzXCIpLndlYmNsO1xyXG5YTUwzRC5tYXRoID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKTtcclxucmVxdWlyZShcIi4vbWF0aC9tYXRoLmpzXCIpKFhNTDNELm1hdGgpO1xyXG5cclxuWE1MM0QuTWF0MiA9IHJlcXVpcmUoXCIuL3R5cGVzL21hdDIuanNcIik7XHJcblhNTDNELk1hdDMgPSByZXF1aXJlKFwiLi90eXBlcy9tYXQzLmpzXCIpO1xyXG5YTUwzRC5NYXQ0ID0gcmVxdWlyZShcIi4vdHlwZXMvbWF0NC5qc1wiKTtcclxuWE1MM0QuVmVjMiA9IHJlcXVpcmUoXCIuL3R5cGVzL3ZlYzIuanNcIik7XHJcblhNTDNELlZlYzMgPSByZXF1aXJlKFwiLi90eXBlcy92ZWMzLmpzXCIpO1xyXG5YTUwzRC5WZWM0ID0gcmVxdWlyZShcIi4vdHlwZXMvdmVjNC5qc1wiKTtcclxuWE1MM0QuQXhpc0FuZ2xlID0gcmVxdWlyZShcIi4vdHlwZXMvYXhpc2FuZ2xlLmpzXCIpO1xyXG5YTUwzRC5RdWF0ID0gcmVxdWlyZShcIi4vdHlwZXMvcXVhdC5qc1wiKTtcclxuWE1MM0QuUmF5ID0gcmVxdWlyZShcIi4vdHlwZXMvcmF5LmpzXCIpO1xyXG5YTUwzRC5Cb3ggPSByZXF1aXJlKFwiLi90eXBlcy9ib3guanNcIik7XHJcblxyXG5YTUwzRC5leHRlbmQod2luZG93LCByZXF1aXJlKFwiLi90eXBlcy9kYXRhLW9ic2VydmVyLmpzXCIpKTtcclxuXHJcblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IgPSByZXF1aXJlKFwiLi94Zmxvdy9vcGVyYXRvci9vcGVyYXRvci5qc1wiKS5yZWdpc3Rlck9wZXJhdG9yO1xyXG5YZmxvdy5jb25zdGFudHMgPSByZXF1aXJlKFwiLi94Zmxvdy9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xyXG5YTUwzRC5leHRlbmQoWGZsb3csIHJlcXVpcmUoXCIuL3hmbG93L2ludGVyZmFjZS9ncmFwaC5qc1wiKSk7XHJcblhNTDNELmV4dGVuZChYZmxvdywgcmVxdWlyZShcIi4veGZsb3cvaW50ZXJmYWNlL2RhdGEuanNcIikpO1xyXG5YZmxvdy5Db21wdXRlUmVxdWVzdCA9IHJlcXVpcmUoXCIuL3hmbG93L2ludGVyZmFjZS9yZXF1ZXN0LmpzXCIpLkNvbXB1dGVSZXF1ZXN0O1xyXG5cclxuWE1MM0QuYXNzZXQgPSByZXF1aXJlKFwiLi9hc3NldC9hc3NldC5qc1wiKTtcclxuXHJcblhNTDNELndlYmdsID0ge307XHJcblhNTDNELndlYmdsLkJhc2VSZW5kZXJUcmVlID0gcmVxdWlyZShcIi4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyLXRyZWVzL2Jhc2UuanNcIik7XHJcblhNTDNELndlYmdsLkJhc2VSZW5kZXJQYXNzID0gcmVxdWlyZShcIi4vcmVuZGVyZXIvd2ViZ2wvcmVuZGVyLXBhc3Nlcy9iYXNlLmpzXCIpO1xyXG5cclxucmVxdWlyZShcIi4vcmVzb3VyY2UveG1sM2Rmb3JtYXRoYW5kbGVyLmpzXCIpO1xyXG5cclxucmVxdWlyZShcIi4veGZsb3cvb3BlcmF0b3IvZGVmYXVsdFwiKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgWE1MM0QgOiBYTUwzRCxcclxuICAgIFhmbG93IDogWGZsb3dcclxufTtcclxuIiwidmFyIFhNTDNEID0gcmVxdWlyZShcIi4vZ2xvYmFsLmpzXCIpLlhNTDNEO1xyXG52YXIgQ29uZmlnID0gcmVxdWlyZShcIi4vaW50ZXJmYWNlL2VsZW1lbnRzLmpzXCIpLmNvbmZpZztcclxudmFyIHNlbmRBZGFwdGVyRXZlbnQgPSByZXF1aXJlKFwiLi91dGlscy9taXNjLmpzXCIpLnNlbmRBZGFwdGVyRXZlbnQ7XHJcbnZhciBPcHRpb25zID0gcmVxdWlyZShcIi4vdXRpbHMvb3B0aW9ucy5qc1wiKTtcclxudmFyIENTUyA9IHJlcXVpcmUoXCIuL3V0aWxzL2Nzcy5qc1wiKTtcclxudmFyIENvbmZpZ3VyZVJlbmRlcmVyID0gcmVxdWlyZShcIi4vcmVuZGVyZXIvcmVuZGVyZXIvY29uZmlndXJlLmpzXCIpO1xyXG52YXIgV2ViZ2xTdXBwb3J0ZWQgPSByZXF1aXJlKFwiLi9yZW5kZXJlci93ZWJnbC9iYXNlL3V0aWxzLmpzXCIpLnN1cHBvcnRlZDtcclxudmFyIFV0aWwgPSByZXF1aXJlKFwiLi91dGlscy9taXNjLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9pbnRlcmZhY2UvZG9tLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi91dGlscy9kZWJ1Zy5qc1wiKTtcclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvKGlQYWR8aVBob25lfGlQb2QgdG91Y2gpL2kpKSB7XHJcbiAgICAgICAgdmFyIG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibWV0YVwiKTtcclxuICAgICAgICBtLm5hbWUgPSBcImZvcm1hdC1kZXRlY3Rpb25cIjtcclxuICAgICAgICBtLmNvbnRlbnQgPSBcInRlbGVwaG9uZT1ub1wiO1xyXG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobSlcclxuICAgIH1cclxufSgpKTtcclxuXHJcbmZ1bmN0aW9uIGRpc3BsYXlXZWJHTE5vdFN1cHBvcnRlZEluZm8oeG1sM2RFbGVtZW50KXtcclxuXHJcbiAgICBpZih4bWwzZEVsZW1lbnQuaGFzQXR0cmlidXRlKFwib251bnN1cHBvcnRlZFwiKSl7XHJcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiZXZlbnRcIiwgeG1sM2RFbGVtZW50LmdldEF0dHJpYnV0ZShcIm9udW5zdXBwb3J0ZWRcIikpO1xyXG4gICAgICAgIHhtbDNkRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd1bnN1cHBvcnRlZCcsIGNhbGxiYWNrLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICB2YXIgZG9EZWZhdWx0ID0gWE1MM0QudXRpbC5kaXNwYXRjaEN1c3RvbUV2ZW50KHhtbDNkRWxlbWVudCwgJ3Vuc3VwcG9ydGVkJywgZmFsc2UsIHRydWUsIG51bGwpO1xyXG4gICAgaWYoZG9EZWZhdWx0KXtcclxuICAgICAgICAvLyBQbGFjZSB4bWwzZEVsZW1lbnQgaW5zaWRlIGFuIGludmlzaWJsZSBkaXZcclxuICAgICAgICB2YXIgaGlkZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuICAgICAgICB4bWwzZEVsZW1lbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaGlkZURpdiwgeG1sM2RFbGVtZW50KTtcclxuICAgICAgICBoaWRlRGl2LmFwcGVuZENoaWxkKHhtbDNkRWxlbWVudCk7XHJcbiAgICAgICAgLy9oaWRlRGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuXHJcbiAgICAgICAgdmFyIGluZm9EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBpZih4bWwzZEVsZW1lbnQuaGFzQXR0cmlidXRlKFwiY2xhc3NcIikpe1xyXG4gICAgICAgICAgICBpbmZvRGl2LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHhtbDNkRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbmZvRGl2LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIHhtbDNkRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSk7XHJcbiAgICAgICAgaW5mb0Rpdi5zdHlsZS5ib3JkZXIgPSBcIjJweCBzb2xpZCByZWRcIjtcclxuICAgICAgICBpbmZvRGl2LnN0eWxlLmZvbnRGYW1pbHkgPSBcInZlcmRhbmEsc2Fucy1zZXJpZlwiO1xyXG4gICAgICAgIGluZm9EaXYuc3R5bGUuY29sb3IgPSBcInJlZFwiO1xyXG4gICAgICAgIGluZm9EaXYuc3R5bGUucGFkZGluZyA9IFwiMTBweFwiO1xyXG4gICAgICAgIGluZm9EaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJyZ2JhKDI1NSwgMCwgMCwgMC4zKVwiO1xyXG5cclxuICAgICAgICB2YXIgd2lkdGggPSB4bWwzZEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwid2lkdGhcIik7XHJcbiAgICAgICAgaWYgKHdpZHRoICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGluZm9EaXYuc3R5bGUud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBoZWlnaHQgPSB4bWwzZEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIpO1xyXG4gICAgICAgIGlmIChoZWlnaHQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaW5mb0Rpdi5zdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaDNcIik7XHJcbiAgICAgICAgdmFyIGhUeHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlNvcnJ5LCB5b3VyIGJyb3dzZXIgZG9lc24ndCBhcHBlYXIgdG8gc3VwcG9ydCBYTUwzRC5cIik7XHJcbiAgICAgICAgaEVsZW1lbnQuYXBwZW5kQ2hpbGQoaFR4dCk7XHJcblxyXG4gICAgICAgIHZhciBwRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpO1xyXG4gICAgICAgIHBFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiUGxlYXNlIHZpc2l0IFwiKSk7XHJcbiAgICAgICAgdmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcclxuICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgXCJodHRwOi8vd3d3LnhtbDNkLm9yZy9oZWxwXCIpO1xyXG4gICAgICAgIGxpbmsuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJodHRwOi8vd3d3LnhtbDNkLm9yZy9oZWxwXCIpKTtcclxuICAgICAgICBwRWxlbWVudC5hcHBlbmRDaGlsZChsaW5rKTtcclxuICAgICAgICBwRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIikpO1xyXG4gICAgICAgIGluZm9EaXYuYXBwZW5kQ2hpbGQoaEVsZW1lbnQpO1xyXG4gICAgICAgIGluZm9EaXYuYXBwZW5kQ2hpbGQocEVsZW1lbnQpO1xyXG5cclxuICAgICAgICBoaWRlRGl2LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGluZm9EaXYsIGhpZGVEaXYpO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuLyogIGEgbGlzdCBvZiBlbGVtZW50cyB0aGF0IGFyZSBjdXJyZW50bHkgaW5pdGlhbGl6ZWQuIE1vcmUgc3BlY2lmaWNhbGx5LFxyXG4gKiAgdGhleSdyZSBjdXJyZW50bHkgaW4gYSBjYWxsIHRvIHRoZSBtZXRob2QgYmVsb3cuXHJcbiAqXHJcbiAqICBXaHk/XHJcbiAqICBJbiB3ZWJnbCB3ZSBhY3R1YWxseSByZWF0dGFjaCB0aGUgeG1sM2QgZWxlbWVudCBpbiB0aGUgRE9NLiBUaHVzLCB3aGVuXHJcbiAqICB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIHdvcmtpbmcgb24gYSBvbk5vZGVJbnNlcnRlZCBldmVudCwgdGhlcmUgd2lsbCBwcm9iYWJseVxyXG4gKiAgY29tZSByaWdodCBhbm90aGVyIGV2ZW50IHdoaWNoIHdlIGFjdHVhbGx5IGRvbid0IGNhcmUgZm9yLlxyXG4gKiAgU28gd2UgdXNlIHRoaXMgbGlzdCB0byBrZWVwIHRyYWNrIG9mIHdoaWNoIGVsZW1lbnRzIGFyZSBjdXJyZW50bHkgaW5pdGlhbGl6aW5nLlxyXG4gKi9cclxudmFyIGN1clhNTDNESW5pdEVsZW1lbnRzID0gW107XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtFbGVtZW50fSB4bWwzZEVsZW1lbnRcclxuICovXHJcbmZ1bmN0aW9uIGluaXRYTUwzREVsZW1lbnQoeG1sM2RFbGVtZW50KSB7XHJcbiAgICBpZihjdXJYTUwzREluaXRFbGVtZW50cy5pbmRleE9mKHhtbDNkRWxlbWVudCkgPiAtMSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgY3VyWE1MM0RJbml0RWxlbWVudHMucHVzaCh4bWwzZEVsZW1lbnQpO1xyXG5cclxuICAgIHZhciBkZWJ1ZyA9IFhNTDNELmRlYnVnLnNldHVwKCk7XHJcblxyXG4gICAgaWYgKCFXZWJnbFN1cHBvcnRlZCgpKSB7XHJcbiAgICAgICAgZGVidWcgJiYgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIkNvdWxkIG5vdCBpbml0aWFsaXNlIFdlYkdMLCBzb3JyeSA6LShcIik7XHJcbiAgICAgICAgZGlzcGxheVdlYkdMTm90U3VwcG9ydGVkSW5mbyh4bWwzZEVsZW1lbnQpO1xyXG4gICAgICAgIGN1clhNTDNESW5pdEVsZW1lbnRzLnNwbGljZShjdXJYTUwzREluaXRFbGVtZW50cy5pbmRleE9mKHhtbDNkRWxlbWVudCksIDEpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBYTUwzRC5kZWJ1Zy5sb2dJbmZvKFwiQ29uZmlndXJpbmdcIiwgeG1sM2RFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqXCIpLmxlbmd0aCwgXCJlbGVtZW50c1wiKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAgIENvbmZpZy5jb25maWd1cmUoeG1sM2RFbGVtZW50KTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBkZWJ1ZyAmJiBYTUwzRC5kZWJ1Zy5sb2dFeGNlcHRpb24oZSk7XHJcbiAgICAgICAgY3VyWE1MM0RJbml0RWxlbWVudHMuc3BsaWNlKGN1clhNTDNESW5pdEVsZW1lbnRzLmluZGV4T2YoeG1sM2RFbGVtZW50KSwgMSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBDb25maWd1cmVSZW5kZXJlcih4bWwzZEVsZW1lbnQpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGRlYnVnICYmIFhNTDNELmRlYnVnLmxvZ0V4Y2VwdGlvbihlKTtcclxuICAgICAgICBjdXJYTUwzREluaXRFbGVtZW50cy5zcGxpY2UoY3VyWE1MM0RJbml0RWxlbWVudHMuaW5kZXhPZih4bWwzZEVsZW1lbnQpLCAxKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaW5pdGlhbGl6ZSBhbGwgYXR0YWNoZWQgYWRhcHRlcnNcclxuICAgIHNlbmRBZGFwdGVyRXZlbnQoeG1sM2RFbGVtZW50LCB7b25Db25maWd1cmVkIDogW119KTtcclxuXHJcbiAgICBjdXJYTUwzREluaXRFbGVtZW50cy5zcGxpY2UoY3VyWE1MM0RJbml0RWxlbWVudHMuaW5kZXhPZih4bWwzZEVsZW1lbnQpLCAxKTtcclxuICAgIGNsZWFyT2JzZXJ2ZXIoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0geG1sM2RFbGVtZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBkZXN0cm95WE1MM0RFbGVtZW50KHhtbDNkRWxlbWVudClcclxue1xyXG4gICAgaWYoY3VyWE1MM0RJbml0RWxlbWVudHMuaW5kZXhPZih4bWwzZEVsZW1lbnQpID4gLTEpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGlmICgheG1sM2RFbGVtZW50Ll9jb25maWd1cmVkKSB7XHJcbiAgICAgICAgcmV0dXJuOyAvL0FscmVhZHkgZGVzdHJveWVkIG9yIG5ldmVyIGluaXRpYWxpemVkXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNhbnZhcyA9IHhtbDNkRWxlbWVudC5fY29uZmlndXJlZC5jYW52YXM7XHJcblxyXG4gICAgeG1sM2RFbGVtZW50Ll9jb25maWd1cmVkLmRlc3Ryb3koKTtcclxuICAgIHhtbDNkRWxlbWVudC5fY29uZmlndXJlZCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICBpZighY2FudmFzIHx8ICFVdGlsLmVsZW1lbnRJcyhjYW52YXMsIFwiY2FudmFzXCIpKVxyXG4gICAgICAgIHJldHVybjsgLy8gYW4gZWxlbWVudCB3ZSBkaWRuJ3QgY3JlYXRlLCBza2lwIGRlbGV0aW9uXHJcblxyXG4gICAgaWYgKCF4bWwzZEVsZW1lbnQucGFyZW50Tm9kZSkge1xyXG4gICAgICAgIC8vIFRoZSB4bWwzZCBlbGVtZW50IHdhcyByZW1vdmVkIGRpcmVjdGx5IHJhdGhlciB0aGFuIGFzIGEgcmVzdWx0IG9mIGEgcGFyZW50IGNvbnRhaW5lciBiZWluZyByZW1vdmVkLFxyXG4gICAgICAgIC8vIGhlcmUgd2Ugc2hvdWxkIGFsc28gcmVtb3ZlIHRoZSBoaWRpbmcgZGl2XHJcbiAgICAgICAgdmFyIGRpdiA9IGNhbnZhcy5uZXh0RWxlbWVudFNpYmxpbmc7XHJcbiAgICAgICAgaWYgKFV0aWwuZWxlbWVudElzKGRpdiwgXCJkaXZcIikgJiYgZGl2LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpID09IFwiX3htbDNkX2hpZGVEaXZcIikge1xyXG4gICAgICAgICAgICBkaXYucGFyZW50Tm9kZSAmJiBkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkaXYpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjYW52YXMucGFyZW50Tm9kZSAmJiBjYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjYW52YXMpO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtFdmVudH0gZXZ0XHJcbiAqL1xyXG5mdW5jdGlvbiBvbk5vZGVJbnNlcnRlZChldnQpIHtcclxuXHJcbiAgICBpZihVdGlsLmVsZW1lbnRJcyhldnQudGFyZ2V0LCBcInhtbDNkXCIpKSB7XHJcbiAgICAgICAgaW5pdFhNTDNERWxlbWVudChldnQudGFyZ2V0KTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7RXZlbnR9IGV2dFxyXG4gKi9cclxuZnVuY3Rpb24gb25Ob2RlUmVtb3ZlZChldnQpIHtcclxuXHJcbiAgICBpZihVdGlsLmVsZW1lbnRJcyhldnQudGFyZ2V0LCBcInhtbDNkXCIpKSB7XHJcbiAgICAgICAgZGVzdHJveVhNTDNERWxlbWVudChldnQudGFyZ2V0KTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIG9ic2VydmVyID0gbnVsbDtcclxuXHJcbmZ1bmN0aW9uIG9uTG9hZCgpIHtcclxuXHJcbiAgICBPcHRpb25zLnNldE9wdGlvbnNGcm9tUXVlcnkoKTtcclxuXHJcbiAgICBDU1MuaW5pdCgpO1xyXG5cclxuICAgIHZhciBkZWJ1ZyA9IFhNTDNELmRlYnVnLnNldHVwKCk7XHJcbiAgICBkZWJ1ZyAmJiBYTUwzRC5kZWJ1Zy5sb2dJbmZvKFwieG1sM2QuanMgdmVyc2lvbjogXCIgKyBYTUwzRC52ZXJzaW9uKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgYWxsIHRoZSBYTUwzRCB0YWdzIGluIHRoZSBkb2N1bWVudFxyXG4gICAgICogQHR5cGUge05vZGVMaXN0fVxyXG4gICAgICovXHJcbiAgICB2YXIgeG1sM2RzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcInhtbDNkXCIpO1xyXG5cclxuICAgIGRlYnVnICYmIFhNTDNELmRlYnVnLmxvZ0luZm8oXCJGb3VuZCBcIiArIHhtbDNkcy5sZW5ndGggKyBcIiB4bWwzZCBub2RlKHMpXCIpO1xyXG5cclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB4bWwzZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpbml0WE1MM0RFbGVtZW50KHhtbDNkc1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETyhrc29ucyk6IFJlbW92ZSB0aGlzLCBubyBNdXRhdGlvbk9ic2VydmVyIG5vIFhNTDNEXHJcbiAgICBpZighTXV0YXRpb25PYnNlcnZlcil7XHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NTm9kZUluc2VydGVkJywgb25Ob2RlSW5zZXJ0ZWQsIGZhbHNlKTtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Ob2RlUmVtb3ZlZCcsIG9uTm9kZVJlbW92ZWQsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgICAgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihyZXNvbHZlTXV0YXRpb25zKTtcclxuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUsIGF0dHJpYnV0ZXM6IHRydWUsIGF0dHJpYnV0ZUZpbHRlcjogWyBcImNsYXNzXCIsIFwiaWRcIiwgXCJzdHlsZVwiIF0gfSApO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBvblVubG9hZCgpIHtcclxuICAgIGlmIChYTUwzRC5kb2N1bWVudClcclxuICAgICAgICBYTUwzRC5kb2N1bWVudC5vbnVubG9hZCgpO1xyXG59XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVNdXRhdGlvbnMobXV0YXRpb25zKXtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIHZhciBtdXRhdGlvbiA9IG11dGF0aW9uc1tpXTtcclxuICAgICAgICBpZihtdXRhdGlvbi50eXBlID09ICdjaGlsZExpc3QnKXtcclxuICAgICAgICAgICAgbWFwRnVuY3Rpb25PblhNTDNERWxlbWVudHMobXV0YXRpb24uYWRkZWROb2RlcywgaW5pdFhNTDNERWxlbWVudCk7XHJcbiAgICAgICAgICAgIG1hcEZ1bmN0aW9uT25YTUwzREVsZW1lbnRzKG11dGF0aW9uLnJlbW92ZWROb2RlcywgZGVzdHJveVhNTDNERWxlbWVudCk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAobXV0YXRpb24udHlwZSA9PSAnYXR0cmlidXRlcycpIHtcclxuICAgICAgICAgICAgdmFyIG11dGF0aW9uVGFyZ2V0ID0gbXV0YXRpb24udGFyZ2V0O1xyXG4gICAgICAgICAgICBpZiAobXV0YXRpb24uYXR0cmlidXRlTmFtZSA9PT0gXCJpZFwiIHx8IG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUgPT09IFwiY2xhc3NcIikge1xyXG4gICAgICAgICAgICAgICAgbXV0YXRpb25UYXJnZXQgPSBtdXRhdGlvbi50YXJnZXQucGFyZW50Tm9kZTsgLy8gU3RhcnQgQ1NTIHJlLWV2YWwgYXQgcGFyZW50IHRvIGhvbm9yIHNpYmxpbmcgc2VsZWN0b3JzXHJcbiAgICAgICAgICAgICAgICBpZiAoIW11dGF0aW9uVGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIFRhcmdldCB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBET00gYmVmb3JlIHRoaXMgZXZlbnQgd2FzIHByb2Nlc3NlZFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjc3NUYXJnZXQgPSBtdXRhdGlvblRhcmdldC5fY29uZmlndXJlZCA/IG11dGF0aW9uVGFyZ2V0IDogbXV0YXRpb25UYXJnZXQucXVlcnlTZWxlY3RvcihcInhtbDNkXCIpO1xyXG4gICAgICAgICAgICBpZihjc3NUYXJnZXQgJiYgY3NzVGFyZ2V0Ll9jb25maWd1cmVkKSB7IC8vIHhtbDNkIGlzIGEgY2hpbGQgbm9kZVxyXG4gICAgICAgICAgICAgICAgdmFyIGFkYXB0ZXJzTmFtZXMgPSBPYmplY3Qua2V5cyhjc3NUYXJnZXQuX2NvbmZpZ3VyZWQuYWRhcHRlcnMpLmZpbHRlcihmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXhPZihcInNjZW5lXCIpID09IDA7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGFkYXB0ZXJzTmFtZXMubWFwKGZ1bmN0aW9uKG5hbWUpe3JldHVybiBjc3NUYXJnZXQuX2NvbmZpZ3VyZWQuYWRhcHRlcnNbbmFtZV07fSkuZm9yRWFjaChmdW5jdGlvbihyZW5kZXJBZGFwdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyQWRhcHRlci50cmF2ZXJzZShmdW5jdGlvbihhZGFwdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkYXB0ZXIuc3R5bGVDaGFuZ2VkQ2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hcEZ1bmN0aW9uT25YTUwzREVsZW1lbnRzKGVsZW1lbnRMaXN0LCBmdW4pIHtcclxuICAgIEFycmF5LmZvckVhY2goZWxlbWVudExpc3QsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgICBpZiAoIWVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWVOUykge1xyXG4gICAgICAgICAgICAvLyBUaGVzZSBlbGVtZW50cyBhcmUgbGVhZiBub2RlcyAoZWcuIFRFWFQpIHNvIHdlIGNhbiBpZ25vcmUgdGhlbVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChVdGlsLmVsZW1lbnRJcyhlbGVtZW50LCBcInhtbDNkXCIpKSB7XHJcbiAgICAgICAgICAgIGZ1bihlbGVtZW50KTtcclxuICAgICAgICAgICAgLy8gQW4gWE1MM0QgZWxlbWVudCBjYW4ndCBoYXZlIGZ1cnRoZXIgWE1MM0QgZWxlbWVudHMgYXMgY2hpbGRyZW5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBGb3IgY2FzZXMgd2hlcmUgYW4gWE1MM0QgZWxlbWVudCBtaWdodCBiZSBpbnNpZGUgdGhlIHN1YnRyZWUgb2YgdGhlIGFkZGVkIG5vZGVcclxuICAgICAgICB2YXIgeG1sM2RFbGVtcyA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ4bWwzZFwiKTtcclxuICAgICAgICB4bWwzZEVsZW1zID0geG1sM2RFbGVtcy5sZW5ndGggPyB4bWwzZEVsZW1zIDogZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZU5TKFhNTDNELnhtbDNkTlMsIFwieG1sM2RcIik7XHJcblxyXG4gICAgICAgIEFycmF5LmZvckVhY2goeG1sM2RFbGVtcywgZnVuKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5YTUwzRC5mbHVzaENTU0NoYW5nZXMgPSBmdW5jdGlvbigpe1xyXG4gICAgaWYob2JzZXJ2ZXIpe1xyXG4gICAgICAgIHJlc29sdmVNdXRhdGlvbnMob2JzZXJ2ZXIudGFrZVJlY29yZHMoKSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBjbGVhck9ic2VydmVyKCl7XHJcbiAgICBpZihvYnNlcnZlcil7XHJcbiAgICAgICAgb2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcclxuICAgIH1cclxufVxyXG5cclxuaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImludGVyYWN0aXZlXCIpIHtcclxuICAgIG9uTG9hZCgpO1xyXG59IGVsc2Uge1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIG9uTG9hZCwgZmFsc2UpO1xyXG59XHJcblxyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5sb2FkJywgb25VbmxvYWQsIGZhbHNlKTtcclxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3JlbG9hZCcsIG9uVW5sb2FkLCBmYWxzZSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFhNTDNEO1xyXG5cclxuIiwidmFyIFJlc291cmNlID0gcmVxdWlyZShcIi4uL3Jlc291cmNlXCIpO1xyXG5cclxudmFyIHN0cmluZzJib29sID0gZnVuY3Rpb24oc3RyaW5nKSB7XHJcbiAgICBpZiAoIXN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHN3aXRjaCAoc3RyaW5nLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgIGNhc2UgXCJ0cnVlXCI6XHJcbiAgICBjYXNlIFwiMVwiOlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgY2FzZSBcImZhbHNlXCI6XHJcbiAgICBjYXNlIFwiMFwiOlxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oc3RyaW5nKTtcclxuICAgIH1cclxufTtcclxudmFyIGhhbmRsZXJzID0ge307XHJcblxyXG5mdW5jdGlvbiBnZXRTdG9yYWdlKGVsZW0pe1xyXG4gICAgcmV0dXJuIGVsZW0uX2NvbmZpZ3VyZWQuc3RvcmFnZTtcclxufVxyXG5cclxudmFyIEF0dHJpYnV0ZUhhbmRsZXIgPSBmdW5jdGlvbihlbGVtKSB7XHJcbn07XHJcblxyXG5oYW5kbGVycy5JREhhbmRsZXIgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgaWQgPSBpZC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgdGhpcy5zZXRGcm9tQXR0cmlidXRlID0gZnVuY3Rpb24odmFsdWUsIHByZXZWYWx1ZSwgZWxlbSkge1xyXG4gICAgICAgIFJlc291cmNlLm5vdGlmeU5vZGVJZENoYW5nZShlbGVtLCBwcmV2VmFsdWUsIHZhbHVlKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmRlc2MgPSB7XHJcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZShpZCkgfHwgXCJcIjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGlkLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuXHJcbmhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIgPSBmdW5jdGlvbihpZCwgcGFyYW1zKSB7XHJcbiAgICBpZCA9IGlkLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gcGFyYW1zID8gcGFyYW1zLmRlZmF1bHRWYWx1ZTogXCJcIjtcclxuICAgIHRoaXMuZGVzYyA9IHtcclxuICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKGlkKSB8fCBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQgOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShpZCwgdmFsdWUgfHwgZGVmYXVsdFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5cclxuaGFuZGxlcnMuRW51bUF0dHJpYnV0ZUhhbmRsZXIgPSBmdW5jdGlvbihpZCwgZW51bU9iaikge1xyXG4gICAgQXR0cmlidXRlSGFuZGxlci5jYWxsKHRoaXMpO1xyXG4gICAgaWQgPSBpZC50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKGVsZW0sIHN0b3JhZ2Upe1xyXG4gICAgICAgIHN0b3JhZ2VbaWRdID0gZW51bU9iai5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgaWYgKGVsZW0uaGFzQXR0cmlidXRlKGlkKSlcclxuICAgICAgICAgICAgdGhpcy5zZXRGcm9tQXR0cmlidXRlKGVsZW0uZ2V0QXR0cmlidXRlKGlkKSwgbnVsbCwgZWxlbSwgc3RvcmFnZSk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5zZXRGcm9tQXR0cmlidXRlID0gZnVuY3Rpb24odiwgcHJldlZhbHVlLCBlbGVtLCBzdG9yYWdlKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdi50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIHN0b3JhZ2VbaWRdID0gKHZhbHVlICYmIGVudW1PYmoudmFsdWVzW3ZhbHVlXSAhPT0gdW5kZWZpbmVkKSA/IGVudW1PYmoudmFsdWVzW3ZhbHVlXSA6IGVudW1PYmouZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICB0aGlzLmRlc2MgPSB7XHJcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IGdldFN0b3JhZ2UodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBlbnVtT2JqLnZhbHVlc1tzdG9yYWdlW2lkXV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQgOiBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBdHRyaWJ1dGUgaXMgc2V0IHRvIHdoYXRldmVyIGNvbWVzIGluXHJcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGlkLCB2KTtcclxuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSBnZXRTdG9yYWdlKHRoaXMpO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0eXBlb2YgdiA9PSAnc3RyaW5nJyA/IHYudG9Mb3dlckNhc2UoKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICYmIGVudW1PYmoudmFsdWVzW3ZhbHVlXSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSBlbnVtT2JqLnZhbHVlc1t2YWx1ZV07XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHN0b3JhZ2VbaWRdID0gZW51bU9iai5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuaGFuZGxlcnMuRW51bUF0dHJpYnV0ZUhhbmRsZXIucHJvdG90eXBlID0gbmV3IEF0dHJpYnV0ZUhhbmRsZXIoKTtcclxuaGFuZGxlcnMuRW51bUF0dHJpYnV0ZUhhbmRsZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gaGFuZGxlcnMuRW51bUF0dHJpYnV0ZUhhbmRsZXI7XHJcblxyXG5oYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXIgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgQXR0cmlidXRlSGFuZGxlci5jYWxsKHRoaXMpO1xyXG4gICAgaWQgPSBpZC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgdmFyIGV2ZW50VHlwZSA9IGlkLnN1YnN0cmluZygyKTtcclxuXHJcbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbihlbGVtLCBzdG9yYWdlKXtcclxuICAgICAgICBzdG9yYWdlW2lkXSA9IG51bGw7XHJcbiAgICAgICAgaWYgKGVsZW0uaGFzQXR0cmlidXRlKGlkKSlcclxuICAgICAgICAgICAgdGhpcy5zZXRGcm9tQXR0cmlidXRlKGVsZW0uZ2V0QXR0cmlidXRlKGlkKSwgbnVsbCwgZWxlbSwgc3RvcmFnZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2V0RnJvbUF0dHJpYnV0ZSA9IGZ1bmN0aW9uKHZhbHVlLCBwcmV2VmFsdWUsIGVsZW0sIHN0b3JhZ2UpIHtcclxuICAgICAgICBpZihzdG9yYWdlW2lkXSAhPSBudWxsKVxyXG4gICAgICAgICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBzdG9yYWdlW2lkXSk7XHJcbiAgICAgICAgaWYoIXZhbHVlKXtcclxuICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICBzdG9yYWdlW2lkXSA9IGV2YWwoXCJjcnggPSBmdW5jdGlvbiBcIiArIGlkICsgXCIoZXZlbnQpe1xcbiAgXCIgKyB2YWx1ZSArIFwiXFxufVwiKTtcclxuICAgICAgICAgICAgaWYgKFhNTDNELnhodG1sKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBvbmx5IFhIVE1MIGRvY3VtZW50cyByZXF1aXJlIHRoaXMgcG9seWZpbGwgZm9yIG1vdXNlIGV2ZW50IGF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIHN0b3JhZ2VbaWRdLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIHRoaXMuZGVzYyA9IHtcclxuICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gZ2V0U3RvcmFnZSh0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2VbaWRdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0IDogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSBnZXRTdG9yYWdlKHRoaXMpO1xyXG4gICAgICAgICAgICBpZihYTUwzRC54aHRtbCAmJiBzdG9yYWdlW2lkXSkgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgc3RvcmFnZVtpZF0pO1xyXG4gICAgICAgICAgICBzdG9yYWdlW2lkXSA9ICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYoWE1MM0QueGh0bWwgJiYgc3RvcmFnZVtpZF0pIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIHN0b3JhZ2VbaWRdLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5cclxuaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyLnByb3RvdHlwZSA9IG5ldyBBdHRyaWJ1dGVIYW5kbGVyKCk7XHJcbmhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXI7XHJcblxyXG5oYW5kbGVycy5JbnRBdHRyaWJ1dGVIYW5kbGVyID0gZnVuY3Rpb24oaWQsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgaWQgPSBpZC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24oZWxlbSwgc3RvcmFnZSl7XHJcbiAgICAgICAgc3RvcmFnZVtpZF0gPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgaWYgKGVsZW0uaGFzQXR0cmlidXRlKGlkKSlcclxuICAgICAgICAgICAgdGhpcy5zZXRGcm9tQXR0cmlidXRlKGVsZW0uZ2V0QXR0cmlidXRlKGlkKSwgbnVsbCwgZWxlbSwgc3RvcmFnZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2V0RnJvbUF0dHJpYnV0ZSA9IGZ1bmN0aW9uKHZhbHVlLCBwcmV2VmFsdWUsIGVsZW0sIHN0b3JhZ2UpIHtcclxuICAgICAgICB2YXIgdiA9IHZhbHVlLm1hdGNoKC9eXFxkKy8pO1xyXG4gICAgICAgIGlmICghdiB8fCBpc05hTigrdlswXSkpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIkludmFsaWQgYXR0cmlidXRlIFtcIitpZCtcIl0gdmFsdWU6IFwiICsgdmFsdWUsIGVsZW0pO1xyXG4gICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShpZCwgcHJldlZhbHVlKTtcclxuICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSAgK3ZbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGVsZW0uX2NvbmZpZ3VyZWQuY2FudmFzKVxyXG4gICAgICAgICAgICBlbGVtLl9jb25maWd1cmVkLmNhbnZhc1tpZF0gPSBzdG9yYWdlW2lkXTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZGVzYyA9IHtcclxuICAgICAgICBnZXQgOiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBYTUwzRC5mbHVzaERPTUNoYW5nZXMoKTtcclxuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSBnZXRTdG9yYWdlKHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZVtpZF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQgOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IGdldFN0b3JhZ2UodGhpcyk7XHJcbiAgICAgICAgICAgIHZhciB2ID0gK3ZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoaXNOYU4odikpIHtcclxuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJJbnZhbGlkIGF0dHJpYnV0ZSBbXCIraWQrXCJdIHZhbHVlOiBcIiArIHZhbHVlLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIHN0b3JhZ2VbaWRdID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSAgTWF0aC5mbG9vcih2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShpZCwgc3RvcmFnZVtpZF0gKyAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuaGFuZGxlcnMuSW50QXR0cmlidXRlSGFuZGxlci5wcm90b3R5cGUgPSBuZXcgQXR0cmlidXRlSGFuZGxlcigpO1xyXG5oYW5kbGVycy5JbnRBdHRyaWJ1dGVIYW5kbGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGhhbmRsZXJzLkludEF0dHJpYnV0ZUhhbmRsZXI7XHJcblxyXG5oYW5kbGVycy5GbG9hdEF0dHJpYnV0ZUhhbmRsZXIgPSBmdW5jdGlvbihpZCwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICBpZCA9IGlkLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbihlbGVtLCBzdG9yYWdlKXtcclxuICAgICAgICBzdG9yYWdlW2lkXSA9IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICBpZiAoZWxlbS5oYXNBdHRyaWJ1dGUoaWQpKVxyXG4gICAgICAgICAgICB0aGlzLnNldEZyb21BdHRyaWJ1dGUoZWxlbS5nZXRBdHRyaWJ1dGUoaWQpLCBudWxsLCBlbGVtLCBzdG9yYWdlKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zZXRGcm9tQXR0cmlidXRlID0gZnVuY3Rpb24odmFsdWUsIHByZXZWYWx1ZSwgZWxlbSwgc3RvcmFnZSkge1xyXG4gICAgICAgIHZhciB2ID0gK3ZhbHVlO1xyXG4gICAgICAgIGlmIChpc05hTih2KSkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiSW52YWxpZCBhdHRyaWJ1dGUgdmFsdWU6IFwiICsgdmFsdWUsIGVsZW0pO1xyXG4gICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShpZCwgcHJldlZhbHVlKTtcclxuICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSAgdjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmRlc2MgPSB7XHJcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IGdldFN0b3JhZ2UodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlW2lkXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gZ2V0U3RvcmFnZSh0aGlzKTtcclxuICAgICAgICAgICAgdmFyIHYgPSArdmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChpc05hTih2KSkge1xyXG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIkludmFsaWQgYXR0cmlidXRlIFtcIitpZCtcIl0gdmFsdWU6IFwiICsgdmFsdWUsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdG9yYWdlW2lkXSA9ICB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGlkLCBzdG9yYWdlW2lkXSArICcnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5cclxuaGFuZGxlcnMuQm9vbEF0dHJpYnV0ZUhhbmRsZXIgPSBmdW5jdGlvbihpZCwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICBpZCA9IGlkLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbihlbGVtLCBzdG9yYWdlKXtcclxuICAgICAgICBzdG9yYWdlW2lkXSA9IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICBpZiAoZWxlbS5oYXNBdHRyaWJ1dGUoaWQpKVxyXG4gICAgICAgICAgICB0aGlzLnNldEZyb21BdHRyaWJ1dGUoZWxlbS5nZXRBdHRyaWJ1dGUoaWQpLCBudWxsLCBlbGVtLCBzdG9yYWdlKTtcclxuICAgIH07XHJcbiAgICB0aGlzLnNldEZyb21BdHRyaWJ1dGUgPSBmdW5jdGlvbih2YWx1ZSwgcHJldlZhbHVlLCBlbGVtLCBzdG9yYWdlKSB7XHJcbiAgICAgICAgc3RvcmFnZVtpZF0gPSBzdHJpbmcyYm9vbCh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmRlc2MgPSB7XHJcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IGdldFN0b3JhZ2UodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlW2lkXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gZ2V0U3RvcmFnZSh0aGlzKTtcclxuICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSBCb29sZWFuKHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaWQsIHN0b3JhZ2VbaWRdICsgJycpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcblxyXG5oYW5kbGVycy5WZWMzQXR0cmlidXRlSGFuZGxlciA9IGZ1bmN0aW9uKGlkLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIGlkID0gaWQudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbihlbGVtLCBzdG9yYWdlKXtcclxuICAgICAgICBzdG9yYWdlW2lkXSA9IG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2V0RnJvbUF0dHJpYnV0ZSA9IGZ1bmN0aW9uKHZhbHVlLCBwcmV2VmFsdWUsIGVsZW0sIHN0b3JhZ2UsIGluaXQpIHtcclxuICAgICAgICBpZiAoIXN0b3JhZ2VbaWRdKSB7XHJcbiAgICAgICAgICAgIHN0b3JhZ2VbaWRdID0gWE1MM0QubWF0aC52ZWMzLmNyZWF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdiA9IHN0b3JhZ2VbaWRdO1xyXG4gICAgICAgIHZhciBtID0gL15cXHMqKFxcUyspXFxzKyhcXFMrKVxccysoXFxTKylcXHMqJC8uZXhlYyh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKCFtICB8fCBpc05hTigrbVsxXSkgfHwgaXNOYU4oK21bMl0pIHx8IGlzTmFOKCttWzNdKSkge1xyXG4gICAgICAgICAgICB2WzBdID0gZGVmYXVsdFZhbHVlWzBdO1xyXG4gICAgICAgICAgICB2WzFdID0gZGVmYXVsdFZhbHVlWzFdO1xyXG4gICAgICAgICAgICB2WzJdID0gZGVmYXVsdFZhbHVlWzJdO1xyXG4gICAgICAgICAgICAhaW5pdCAmJiBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiSW52YWxpZCBhdHRyaWJ1dGUgW1wiK2lkK1wiXSB2YWx1ZTogXCIgKyB2YWx1ZSwgZWxlbSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdlswXSA9ICttWzFdO1xyXG4gICAgICAgICAgICB2WzFdID0gK21bMl07XHJcbiAgICAgICAgICAgIHZbMl0gPSArbVszXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmRlc2MgPSB7XHJcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IGdldFN0b3JhZ2UodGhpcyk7XHJcbiAgICAgICAgICAgIGlmICghc3RvcmFnZVtpZF0pIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuc2V0RnJvbUF0dHJpYnV0ZSh0aGlzLmdldEF0dHJpYnV0ZShpZCksIG51bGwsIHRoaXMsIHN0b3JhZ2UsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgWE1MM0QuVmVjMyhzdG9yYWdlW2lkXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQgOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IGdldFN0b3JhZ2UodGhpcyk7XHJcbiAgICAgICAgICAgIGlmICghc3RvcmFnZVtpZF0pIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuc2V0RnJvbUF0dHJpYnV0ZSh0aGlzLmdldEF0dHJpYnV0ZShpZCksIG51bGwsIHRoaXMsIHN0b3JhZ2UsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2ID0gc3RvcmFnZVtpZF07XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSB2YWx1ZS5kYXRhID8gdmFsdWUuZGF0YSA6IHZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodmFsLmxlbmd0aCAhPT0gMyB8fCBpc05hTih2YWxbMF0pIHx8IGlzTmFOKHZhbFsxXSkgfHwgaXNOYU4odmFsWzJdKSkge1xyXG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIkludmFsaWQgYXR0cmlidXRlIFtcIitpZCtcIl0gdmFsdWU6IFwiICsgdmFsdWUsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdiA9IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZbMF0gPSB2YWxbMF07IHZbMV0gPSB2YWxbMV07IHZbMl0gPSB2YWxbMl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaWQsIFhNTDNELm1hdGgudmVjMy50b0RPTVN0cmluZyh2KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuXHJcbi8vIE5vdGU6IEFsbCB2ZWM0IGF0dHJpYnV0ZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmUgYXhpcy1hbmdsZSwgTk9UIHF1YXRlcm5pb25zIVxyXG5oYW5kbGVycy5BeGlzQW5nbGVBdHRyaWJ1dGVIYW5kbGVyID0gZnVuY3Rpb24oaWQsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgaWQgPSBpZC50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKGVsZW0sIHN0b3JhZ2Upe1xyXG4gICAgICAgIHN0b3JhZ2VbaWRdID0gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zZXRGcm9tQXR0cmlidXRlID0gZnVuY3Rpb24odmFsdWUsIHByZXZWYWx1ZSwgZWxlbSwgc3RvcmFnZSwgaW5pdCkge1xyXG4gICAgICAgIGlmICghc3RvcmFnZVtpZF0pIHtcclxuICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSBYTUwzRC5tYXRoLnZlYzQuY3JlYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2ID0gc3RvcmFnZVtpZF07XHJcbiAgICAgICAgdmFyIG0gPSAvXlxccyooXFxTKylcXHMrKFxcUyspXFxzKyhcXFMrKVxccysoXFxTKylcXHMqJC8uZXhlYyh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKCFtICB8fCBpc05hTigrbVsxXSkgfHwgaXNOYU4oK21bMl0pIHx8IGlzTmFOKCttWzNdKSB8fCBpc05hTigrbVs0XSkpIHtcclxuICAgICAgICAgICAgWE1MM0QubWF0aC52ZWM0LmNvcHkodiwgZGVmYXVsdFZhbHVlKTtcclxuICAgICAgICAgICAgIWluaXQgJiYgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIkludmFsaWQgYXR0cmlidXRlIFtcIitpZCtcIl0gdmFsdWU6IFwiICsgdmFsdWUsIGVsZW0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIFhNTDNELm1hdGgudmVjNC5zZXQodiwgK21bMV0sICttWzJdLCArbVszXSwgK21bNF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZGVzYyA9IHtcclxuICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gZ2V0U3RvcmFnZSh0aGlzKTtcclxuICAgICAgICAgICAgaWYgKCFzdG9yYWdlW2lkXSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5zZXRGcm9tQXR0cmlidXRlKHRoaXMuZ2V0QXR0cmlidXRlKGlkKSwgbnVsbCwgdGhpcywgc3RvcmFnZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBYTUwzRC5BeGlzQW5nbGUoc3RvcmFnZVtpZF0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0IDogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSBnZXRTdG9yYWdlKHRoaXMpO1xyXG4gICAgICAgICAgICBpZiAoIXN0b3JhZ2VbaWRdKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnNldEZyb21BdHRyaWJ1dGUodGhpcy5nZXRBdHRyaWJ1dGUoaWQpLCBudWxsLCB0aGlzLCBzdG9yYWdlLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdiA9IHN0b3JhZ2VbaWRdO1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gdmFsdWUuZGF0YSA/IHZhbHVlLmRhdGEgOiB2YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHZhbC5sZW5ndGggIT09IDQgfHwgaXNOYU4odmFsWzBdKSB8fCBpc05hTih2YWxbMV0pIHx8IGlzTmFOKHZhbFsyXSkgfHwgaXNOYU4odmFsWzNdKSkge1xyXG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIkludmFsaWQgYXR0cmlidXRlIFtcIitpZCtcIl0gdmFsdWU6IFwiICsgdmFsdWUsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgWE1MM0QubWF0aC52ZWM0LmNvcHkodiwgZGVmYXVsdFZhbHVlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIFhNTDNELm1hdGgucXVhdC5jb3B5KHYsIHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaWQsIFhNTDNELm1hdGgudmVjNC50b0RPTVN0cmluZyh2KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuXHJcbnZhciBtaXhlZENvbnRlbnQgPSBmdW5jdGlvbihoYW5kbGVyKSB7XHJcbiAgICBoYW5kbGVyLmluaXQgPSBmdW5jdGlvbihlbGVtLCBzdG9yYWdlKXtcclxuICAgICAgICBlbGVtLl9jb25maWd1cmVkLnJlZ2lzdGVyTWl4ZWQoKTtcclxuICAgIH07XHJcbiAgICBoYW5kbGVyLmRlc2MgPSB7XHJcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IGdldFN0b3JhZ2UodGhpcyk7XHJcbiAgICAgICAgICAgIGlmICghc3RvcmFnZS52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgc3RvcmFnZS52YWx1ZSA9IGhhbmRsZXIucGFyc2UodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2UudmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQgOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAvLyBUaHJvdyBlcnJvcj9cclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJDYW4ndCBzZXQgXCIgKyB0aGlzLm5vZGVOYW1lICsgXCI6OnZhbHVlOiBpdCdzIHJlYWRvbmx5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBoYW5kbGVyLnJlc2V0VmFsdWUgPSBmdW5jdGlvbihzdG9yYWdlKSB7IHN0b3JhZ2UudmFsdWUgPSBudWxsOyB9O1xyXG59O1xyXG5cclxudmFyIGdldENvbnRlbnQgPSBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICB2YXIgc3RyID0gXCJcIjtcclxuICAgIHZhciBrID0gZWxlbS5maXJzdENoaWxkO1xyXG4gICAgd2hpbGUgKGspIHtcclxuICAgICAgICBzdHIgKz0gay5ub2RlVHlwZSA9PSAzID8gay50ZXh0Q29udGVudCA6IFwiIFwiO1xyXG4gICAgICAgIGsgPSBrLm5leHRTaWJsaW5nO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0cjtcclxufTtcclxuXHJcbmhhbmRsZXJzLkZsb2F0QXJyYXlWYWx1ZUhhbmRsZXIgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgbWl4ZWRDb250ZW50KHRoaXMpO1xyXG59O1xyXG5cclxuaGFuZGxlcnMuRmxvYXRBcnJheVZhbHVlSGFuZGxlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICB2YXIgZXhwID0gLyhbK1xcLTAtOWVFXFwuXSspL2c7XHJcbiAgICB2YXIgc3RyID0gZ2V0Q29udGVudChlbGVtKTtcclxuICAgIHZhciBtID0gc3RyLm1hdGNoKGV4cCk7XHJcbiAgICByZXR1cm4gbSA/IG5ldyBGbG9hdDMyQXJyYXkobSkgOiBuZXcgRmxvYXQzMkFycmF5KCk7XHJcbn07XHJcblxyXG5oYW5kbGVycy5GbG9hdDJBcnJheVZhbHVlSGFuZGxlciA9IGhhbmRsZXJzLkZsb2F0QXJyYXlWYWx1ZUhhbmRsZXI7XHJcbmhhbmRsZXJzLkZsb2F0M0FycmF5VmFsdWVIYW5kbGVyID0gaGFuZGxlcnMuRmxvYXRBcnJheVZhbHVlSGFuZGxlcjtcclxuaGFuZGxlcnMuRmxvYXQ0QXJyYXlWYWx1ZUhhbmRsZXIgPSBoYW5kbGVycy5GbG9hdEFycmF5VmFsdWVIYW5kbGVyO1xyXG5oYW5kbGVycy5GbG9hdDR4NEFycmF5VmFsdWVIYW5kbGVyID0gaGFuZGxlcnMuRmxvYXRBcnJheVZhbHVlSGFuZGxlcjtcclxuXHJcbmhhbmRsZXJzLkludEFycmF5VmFsdWVIYW5kbGVyID0gZnVuY3Rpb24oaWQpIHtcclxuICAgIG1peGVkQ29udGVudCh0aGlzKTtcclxufTtcclxuaGFuZGxlcnMuSW50QXJyYXlWYWx1ZUhhbmRsZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgdmFyIGV4cCA9IC8oWytcXC0wLTldKykvZztcclxuICAgIHZhciBzdHIgPSBnZXRDb250ZW50KGVsZW0pO1xyXG4gICAgdmFyIG0gPSBzdHIubWF0Y2goZXhwKTtcclxuICAgIHJldHVybiBtID8gbmV3IEludDMyQXJyYXkobSkgOiBuZXcgSW50MzJBcnJheSgpO1xyXG59O1xyXG5cclxuaGFuZGxlcnMuQm9vbEFycmF5VmFsdWVIYW5kbGVyID0gZnVuY3Rpb24oaWQpIHtcclxuICAgIG1peGVkQ29udGVudCh0aGlzKTtcclxufTtcclxuaGFuZGxlcnMuQm9vbEFycmF5VmFsdWVIYW5kbGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgIHZhciBleHAgPSAvKHRydWV8ZmFsc2V8MHwxKS9pZztcclxuICAgIHZhciBzdHIgPSBnZXRDb250ZW50KGVsZW0pO1xyXG4gICAgdmFyIG0gPSBzdHIubWF0Y2goZXhwKTtcclxuICAgIGlmICghbSlcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKTtcclxuICAgIG0gPSBtLm1hcChzdHJpbmcyYm9vbCk7XHJcbiAgICByZXR1cm4gbSA/IG5ldyBVaW50OEFycmF5KG0pIDogbmV3IFVpbnQ4QXJyYXkoKTtcclxufTtcclxuXHJcbmhhbmRsZXJzLlN0cmluZ1ZhbHVlSGFuZGxlciA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICBtaXhlZENvbnRlbnQodGhpcyk7XHJcbn07XHJcbmhhbmRsZXJzLlN0cmluZ1ZhbHVlSGFuZGxlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICByZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcclxufTtcclxuXHJcbmhhbmRsZXJzLkNhbnZhc1N0eWxlSGFuZGxlciA9IGZ1bmN0aW9uKGlkLCBkKSB7XHJcbiAgICBpZCA9IGlkLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbihlbGVtLCBzdG9yYWdlKXtcclxuICAgICAgICBpZiAoZWxlbS5oYXNBdHRyaWJ1dGUoaWQpKVxyXG4gICAgICAgICAgICB0aGlzLnNldEZyb21BdHRyaWJ1dGUoZWxlbS5nZXRBdHRyaWJ1dGUoaWQpLCBudWxsLCBlbGVtLCBzdG9yYWdlKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zZXRGcm9tQXR0cmlidXRlID0gZnVuY3Rpb24odmFsdWUsIHByZXZWYWx1ZSwgZWxlbSwgc3RvcmFnZSkge1xyXG4gICAgICAgIGVsZW0uX2NvbmZpZ3VyZWQuY2FudmFzLnNldEF0dHJpYnV0ZShpZCwgdmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmRlc2MgPSB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2NvbmZpZ3VyZWQuY2FudmFzLnN0eWxlOyB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHt9XHJcbiAgICB9O1xyXG5cclxufTtcclxuXHJcbmhhbmRsZXJzLkNhbnZhc0NsYXNzSGFuZGxlciA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICBpZCA9IGlkLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbihlbGVtLCBzdG9yYWdlKXtcclxuICAgICAgICB2YXIgY2FudmFzID0gZWxlbS5fY29uZmlndXJlZC5jYW52YXM7XHJcbiAgICAgICAgY2FudmFzLmNsYXNzTmFtZSA9IFwiX3htbDNkXCI7IC8vIENsYXNzIG5hbWUgYWx3YXlzIGRlZmluZWQgZm9yIHhtbDNkIGNhbnZhc1xyXG4gICAgICAgIGlmIChlbGVtLmhhc0F0dHJpYnV0ZShpZCkpXHJcbiAgICAgICAgICAgIHRoaXMuc2V0RnJvbUF0dHJpYnV0ZShlbGVtLmdldEF0dHJpYnV0ZShpZCksIG51bGwsIGVsZW0sIHN0b3JhZ2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNldEZyb21BdHRyaWJ1dGUgPSBmdW5jdGlvbih2YWx1ZSwgcHJldlZhbHVlLCBlbGVtLCBzdG9yYWdlKSB7XHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IGVsZW0uX2NvbmZpZ3VyZWQuY2FudmFzO1xyXG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoaWQsIHZhbHVlICsgXCIgX3htbDNkXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmRlc2MgPSB7XHJcbiAgICAgICAgLy8gVE9ETzogU2hvdWxkIHdlIG5vdCBzdHJpcCB0aGUgX3htbDNkIGNsYXNzIGhlcmU/XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9jb25maWd1cmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlndXJlZC5jYW52YXMuY2xhc3NOYW1lO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY29uZmlndXJlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29uZmlndXJlZC5jYW52YXMuY2xhc3NOYW1lID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBoYW5kbGVycztcclxuIiwidmFyIG1ldGhvZHMgPSByZXF1aXJlKFwiLi9tZXRob2RzLmpzXCIpO1xyXG52YXIgaGFuZGxlcnMgPSByZXF1aXJlKFwiLi9hdHRyaWJ1dGVzLmpzXCIpO1xyXG52YXIgcHJvcGVydGllcyA9IHJlcXVpcmUoXCIuL3Byb3BlcnRpZXMuanNcIik7XHJcblxyXG4vLyBNZXNoVHlwZXNcclxudmFyIE1lc2hUeXBlcyA9IHt9O1xyXG5NZXNoVHlwZXNbXCJ0cmlhbmdsZXNcIl0gPSAwO1xyXG5NZXNoVHlwZXNbMF0gPSBcInRyaWFuZ2xlc1wiO1xyXG5NZXNoVHlwZXNbXCJ0cmlhbmdsZXN0cmlwc1wiXSA9IDE7XHJcbk1lc2hUeXBlc1sxXSA9IFwidHJpYW5nbGVzdHJpcHNcIjtcclxuTWVzaFR5cGVzW1wibGluZXNcIl0gPSAyO1xyXG5NZXNoVHlwZXNbMl0gPSBcImxpbmVzXCI7XHJcbk1lc2hUeXBlc1tcImxpbmVzdHJpcHNcIl0gPSAzO1xyXG5NZXNoVHlwZXNbM10gPSBcImxpbmVzdHJpcHNcIjtcclxuTWVzaFR5cGVzW1wicG9pbnRzXCJdID0gNDtcclxuTWVzaFR5cGVzWzRdID0gXCJwb2ludHNcIjtcclxuTWVzaFR5cGVzW1wiZGVyaXZlZFwiXSA9IDU7XHJcbk1lc2hUeXBlc1s1XSA9IFwiZGVyaXZlZFwiO1xyXG4vLyBUZXh0dXJlVHlwZXNcclxudmFyIFRleHR1cmVUeXBlcyA9IHt9O1xyXG5UZXh0dXJlVHlwZXNbXCIyZFwiXSA9IDA7XHJcblRleHR1cmVUeXBlc1swXSA9IFwiMmRcIjtcclxuVGV4dHVyZVR5cGVzW1wiMWRcIl0gPSAxO1xyXG5UZXh0dXJlVHlwZXNbMV0gPSBcIjFkXCI7XHJcblRleHR1cmVUeXBlc1tcIjNkXCJdID0gMjtcclxuVGV4dHVyZVR5cGVzWzJdID0gXCIzZFwiO1xyXG5cclxuLy8gUGxhdGZvcm1UeXBlc1xyXG52YXIgUGxhdGZvcm1UeXBlcyA9IHt9O1xyXG5QbGF0Zm9ybVR5cGVzW1wiYXV0b1wiXSA9IDE7XHJcblBsYXRmb3JtVHlwZXNbMV0gPSBcImF1dG9cIjtcclxuUGxhdGZvcm1UeXBlc1tcImpzXCJdID0gMjtcclxuUGxhdGZvcm1UeXBlc1syXSA9IFwianNcIjtcclxuUGxhdGZvcm1UeXBlc1tcImdsXCJdID0gMztcclxuUGxhdGZvcm1UeXBlc1szXSA9IFwiZ2xcIjtcclxuUGxhdGZvcm1UeXBlc1tcImNsXCJdID0gNDtcclxuUGxhdGZvcm1UeXBlc1s0XSA9IFwiY2xcIjtcclxuLy8gRGF0YUZpZWxkVHlwZVxyXG52YXIgRGF0YUZpZWxkVHlwZSA9IHt9O1xyXG5EYXRhRmllbGRUeXBlW1wiZmxvYXQgXCJdID0gMDtcclxuRGF0YUZpZWxkVHlwZVswXSA9IFwiZmxvYXQgXCI7XHJcbkRhdGFGaWVsZFR5cGVbXCJmbG9hdDIgXCJdID0gMTtcclxuRGF0YUZpZWxkVHlwZVsxXSA9IFwiZmxvYXQyIFwiO1xyXG5EYXRhRmllbGRUeXBlW1wiZmxvYXQzXCJdID0gMjtcclxuRGF0YUZpZWxkVHlwZVsyXSA9IFwiZmxvYXQzXCI7XHJcbkRhdGFGaWVsZFR5cGVbXCJmbG9hdDRcIl0gPSAzO1xyXG5EYXRhRmllbGRUeXBlWzNdID0gXCJmbG9hdDRcIjtcclxuRGF0YUZpZWxkVHlwZVtcImZsb2F0NHg0XCJdID0gNDtcclxuRGF0YUZpZWxkVHlwZVs0XSA9IFwiZmxvYXQ0eDRcIjtcclxuRGF0YUZpZWxkVHlwZVtcImludFwiXSA9IDEwO1xyXG5EYXRhRmllbGRUeXBlWzEwXSA9IFwiaW50XCI7XHJcbkRhdGFGaWVsZFR5cGVbXCJpbnQ0XCJdID0gMTE7XHJcbkRhdGFGaWVsZFR5cGVbMTFdID0gXCJpbnQ0XCI7XHJcbkRhdGFGaWVsZFR5cGVbXCJib29sXCJdID0gMjA7XHJcbkRhdGFGaWVsZFR5cGVbMjBdID0gXCJib29sXCI7XHJcbkRhdGFGaWVsZFR5cGVbXCJ0ZXh0dXJlXCJdID0gMzA7XHJcbkRhdGFGaWVsZFR5cGVbMzBdID0gXCJ0ZXh0dXJlXCI7XHJcbi8vIERhdGFDaGFubmVsT3JpZ2luXHJcbnZhciBEYXRhQ2hhbm5lbE9yaWdpbiA9IHt9O1xyXG5EYXRhQ2hhbm5lbE9yaWdpbltcIm9yaWdpbl92YWx1ZSBcIl0gPSAwO1xyXG5EYXRhQ2hhbm5lbE9yaWdpblswXSA9IFwib3JpZ2luX3ZhbHVlIFwiO1xyXG5EYXRhQ2hhbm5lbE9yaWdpbltcIm9yaWdpbl9jaGlsZFwiXSA9IDE7XHJcbkRhdGFDaGFubmVsT3JpZ2luWzFdID0gXCJvcmlnaW5fY2hpbGRcIjtcclxuRGF0YUNoYW5uZWxPcmlnaW5bXCJvcmlnaW5fc291cmNlXCJdID0gMjtcclxuRGF0YUNoYW5uZWxPcmlnaW5bMl0gPSBcIm9yaWdpbl9zb3VyY2VcIjtcclxuRGF0YUNoYW5uZWxPcmlnaW5bXCJvcmlnaW5fY29tcHV0ZVwiXSA9IDM7XHJcbkRhdGFDaGFubmVsT3JpZ2luWzNdID0gXCJvcmlnaW5fY29tcHV0ZVwiO1xyXG5EYXRhQ2hhbm5lbE9yaWdpbltcIm9yaWdpbl9wcm90b1wiXSA9IDQ7XHJcbkRhdGFDaGFubmVsT3JpZ2luWzRdID0gXCJvcmlnaW5fcHJvdG9cIjtcclxuXHJcbnZhciBjbGFzc0luZm8gPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8eG1sM2Q+XHJcbiAqKi9cclxuY2xhc3NJbmZvWyd4bWwzZCddID0ge1xyXG4gICAgaWQgOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZSA6IHthOiBoYW5kbGVycy5DYW52YXNDbGFzc0hhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIHN0eWxlIDoge2E6IGhhbmRsZXJzLkNhbnZhc1N0eWxlSGFuZGxlcn0sXHJcbiAgICBvbmNsaWNrIDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmRibGNsaWNrIDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlZG93biA6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZXVwIDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlb3ZlciA6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW1vdmUgOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2VvdXQgOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ua2V5cHJlc3MgOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ua2V5ZG93biA6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25rZXl1cCA6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25sb2FkOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9uZnJhbWVkcmF3bjoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBjb21wbGV0ZToge3A6IHByb3BlcnRpZXMueG1sM2RDb21wbGV0ZX0sXHJcbiAgICBoZWlnaHQgOiB7YTogaGFuZGxlcnMuSW50QXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiA2MDB9LFxyXG4gICAgd2lkdGggOiB7YTogaGFuZGxlcnMuSW50QXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiA4MDB9LFxyXG4gICAgZ2V0RWxlbWVudEJ5UG9pbnQgOiB7bTogbWV0aG9kcy54bWwzZEdldEVsZW1lbnRCeVBvaW50fSxcclxuICAgIGdlbmVyYXRlUmF5IDoge206IG1ldGhvZHMueG1sM2RHZW5lcmF0ZVJheX0sXHJcbiAgICBnZXRFbGVtZW50QnlSYXkgOiB7bTogbWV0aG9kcy54bWwzZEdldEVsZW1lbnRCeVJheX0sXHJcbiAgICBnZXRXb3JsZEJvdW5kaW5nQm94IDoge206IG1ldGhvZHMuZ2V0V29ybGRCb3VuZGluZ0JveH0sXHJcbiAgICBnZXRMb2NhbEJvdW5kaW5nQm94IDoge206IG1ldGhvZHMuZ2V0TG9jYWxCb3VuZGluZ0JveH0sXHJcbiAgICBnZXRSZW5kZXJJbnRlcmZhY2UgOiB7bTogbWV0aG9kcy54bWwzZEdldFJlbmRlckludGVyZmFjZX0sXHJcbiAgICB2aWV3IDoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczoge2RlZmF1bHRWYWx1ZTogXCJ2aWV3XCJ9fVxyXG4gICAgfTtcclxuXHJcbmNsYXNzSW5mb1snY29tcHV0ZSddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgdmFsdWU6IHthOiBoYW5kbGVycy5TdHJpbmdWYWx1ZUhhbmRsZXJ9XHJcbiAgICB9O1xyXG5cclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxkYXRhPlxyXG4gKiovXHJcbmNsYXNzSW5mb1snZGF0YSddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgY29tcHV0ZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgcGxhdGZvcm06IHthOiBoYW5kbGVycy5FbnVtQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiB7dmFsdWVzOiBQbGF0Zm9ybVR5cGVzLCBkZWZhdWx0VmFsdWVzOiAxfX0sXHJcbiAgICBmaWx0ZXI6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubG9hZDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbnByb2dyZXNzOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGNvbXBsZXRlOiB7cDogcHJvcGVydGllcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlQ29tcGxldGV9LFxyXG4gICAgZ2V0T3V0cHV0TmFtZXM6IHttOiBtZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVHZXRPdXRwdXROYW1lc30sXHJcbiAgICBnZXRPdXRwdXRDaGFubmVsSW5mbzoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldE91dHB1dENoYW5uZWxJbmZvfSxcclxuICAgIGdldFJlc3VsdDoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldFJlc3VsdH0sXHJcbiAgICBzcmM6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfVxyXG4gICAgfTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxkYXRhZmxvdz5cclxuICoqL1xyXG5jbGFzc0luZm9bJ2RhdGFmbG93J10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICBwbGF0Zm9ybToge2E6IGhhbmRsZXJzLkVudW1BdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IHt2YWx1ZXM6IFBsYXRmb3JtVHlwZXMsIGRlZmF1bHRWYWx1ZXM6IDF9fSxcclxuICAgIG91dDoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25sb2FkOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ucHJvZ3Jlc3M6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgY29tcGxldGU6IHtwOiBwcm9wZXJ0aWVzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVDb21wbGV0ZX0sXHJcbiAgICBnZXRPdXRwdXROYW1lczoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldE91dHB1dE5hbWVzfSxcclxuICAgIGdldE91dHB1dENoYW5uZWxJbmZvOiB7bTogbWV0aG9kcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlR2V0T3V0cHV0Q2hhbm5lbEluZm99LFxyXG4gICAgZ2V0UmVzdWx0OiB7bTogbWV0aG9kcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlR2V0UmVzdWx0fVxyXG4gICAgfTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxkYXRhPlxyXG4gKiovXHJcbmNsYXNzSW5mb1snYXNzZXQnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIG9ubG9hZDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbnByb2dyZXNzOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGNvbXBsZXRlOiB7cDogcHJvcGVydGllcy5Bc3NldENvbXBsZXRlfSxcclxuICAgIHByb2dyZXNzTGV2ZWw6IHtwOiBwcm9wZXJ0aWVzLkFzc2V0UHJvZ3Jlc3NMZXZlbH0sXHJcbiAgICBzcmM6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG5hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHBpY2s6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHRyYW5zZm9ybToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgbWF0ZXJpYWw6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfVxyXG4gICAgfTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxkZWZzPlxyXG4gKiovXHJcbmNsYXNzSW5mb1snZGVmcyddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9XHJcbiAgICB9O1xyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPGdyb3VwPlxyXG4gKiovXHJcbmNsYXNzSW5mb1snZ3JvdXAnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIG9uY2xpY2s6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25kYmxjbGljazoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlZG93bjoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNldXA6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW92ZXI6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW1vdmU6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW91dDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmtleXByZXNzOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ua2V5ZG93bjoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmtleXVwOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGdldFdvcmxkTWF0cml4OiB7bTogbWV0aG9kcy5YTUwzREdyYXBoVHlwZUdldFdvcmxkTWF0cml4fSxcclxuICAgIGdldExvY2FsTWF0cml4OiB7bTogbWV0aG9kcy5YTUwzREdyYXBoVHlwZUdldExvY2FsTWF0cml4fSxcclxuICAgIGdldFdvcmxkQm91bmRpbmdCb3ggOiB7bTogbWV0aG9kcy5nZXRXb3JsZEJvdW5kaW5nQm94fSxcclxuICAgIGdldExvY2FsQm91bmRpbmdCb3ggOiB7bTogbWV0aG9kcy5nZXRMb2NhbEJvdW5kaW5nQm94fSxcclxuICAgIHRyYW5zZm9ybToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgbWF0ZXJpYWw6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfVxyXG4gICAgfTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxtZXNoPlxyXG4gKiovXHJcbmNsYXNzSW5mb1snbWVzaCddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgb25jbGljazoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmRibGNsaWNrOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2Vkb3duOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2V1cDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlb3Zlcjoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlbW92ZToge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlb3V0OiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ua2V5cHJlc3M6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25rZXlkb3duOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ua2V5dXA6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25sb2FkOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ucHJvZ3Jlc3M6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgY29tcGxldGU6IHtwOiBwcm9wZXJ0aWVzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVDb21wbGV0ZX0sXHJcbiAgICB0eXBlOiB7YTogaGFuZGxlcnMuRW51bUF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczoge3ZhbHVlczogTWVzaFR5cGVzLCBkZWZhdWx0VmFsdWU6IDB9fSxcclxuICAgIGNvbXB1dGU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHRyYW5zZm9ybToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgbWF0ZXJpYWw6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGdldFdvcmxkTWF0cml4OiB7bTogbWV0aG9kcy5YTUwzREdyYXBoVHlwZUdldFdvcmxkTWF0cml4fSxcclxuICAgIGdldExvY2FsTWF0cml4OiB7bTogbWV0aG9kcy5YTUwzREdyYXBoVHlwZUdldExvY2FsTWF0cml4fSxcclxuICAgIGdldFdvcmxkQm91bmRpbmdCb3ggOiB7bTogbWV0aG9kcy5nZXRXb3JsZEJvdW5kaW5nQm94fSxcclxuICAgIGdldExvY2FsQm91bmRpbmdCb3ggOiB7bTogbWV0aG9kcy5nZXRMb2NhbEJvdW5kaW5nQm94fSxcclxuICAgIGdldE91dHB1dE5hbWVzOiB7bTogbWV0aG9kcy5tZXNoR2V0T3V0cHV0TmFtZXN9LFxyXG4gICAgZ2V0T3V0cHV0Q2hhbm5lbEluZm86IHttOiBtZXRob2RzLm1lc2hHZXRPdXRwdXRDaGFubmVsSW5mb30sXHJcbiAgICBnZXRSZXN1bHQ6IHttOiBtZXRob2RzLm1lc2hHZXRSZXN1bHR9LFxyXG4gICAgc3JjOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn1cclxuICAgIH07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8bW9kZWw+XHJcbiAqKi9cclxuY2xhc3NJbmZvWydtb2RlbCddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgb25jbGljazoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmRibGNsaWNrOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2Vkb3duOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2V1cDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlb3Zlcjoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlbW92ZToge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlb3V0OiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ua2V5cHJlc3M6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25rZXlkb3duOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ua2V5dXA6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25sb2FkOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ucHJvZ3Jlc3M6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgY29tcGxldGU6IHtwOiBwcm9wZXJ0aWVzLkFzc2V0Q29tcGxldGV9LFxyXG4gICAgcHJvZ3Jlc3NMZXZlbDoge3A6IHByb3BlcnRpZXMuQXNzZXRQcm9ncmVzc0xldmVsfSxcclxuICAgIGdldFdvcmxkTWF0cml4OiB7bTogbWV0aG9kcy5YTUwzREdyYXBoVHlwZUdldFdvcmxkTWF0cml4fSxcclxuICAgIGdldExvY2FsTWF0cml4OiB7bTogbWV0aG9kcy5YTUwzREdyYXBoVHlwZUdldExvY2FsTWF0cml4fSxcclxuICAgIGdldFdvcmxkQm91bmRpbmdCb3ggOiB7bTogbWV0aG9kcy5nZXRXb3JsZEJvdW5kaW5nQm94fSxcclxuICAgIGdldExvY2FsQm91bmRpbmdCb3ggOiB7bTogbWV0aG9kcy5nZXRMb2NhbEJvdW5kaW5nQm94fSxcclxuICAgIHNyYzoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgcGljazoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgdHJhbnNmb3JtOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBtYXRlcmlhbDoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9XHJcbiAgICB9O1xyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPHRyYW5zZm9ybT5cclxuICoqL1xyXG5jbGFzc0luZm9bJ3RyYW5zZm9ybSddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgdHJhbnNsYXRpb246IHthOiBoYW5kbGVycy5WZWMzQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiBbMCwgMCwgMF19LFxyXG4gICAgc2NhbGU6IHthOiBoYW5kbGVycy5WZWMzQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiBbMSwgMSwgMV19LFxyXG4gICAgcm90YXRpb246IHthOiBoYW5kbGVycy5BeGlzQW5nbGVBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IFswLCAwLCAxLCAwXX0sXHJcbiAgICBjZW50ZXI6IHthOiBoYW5kbGVycy5WZWMzQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiBbMCwgMCwgMF19LFxyXG4gICAgc2NhbGVPcmllbnRhdGlvbjoge2E6IGhhbmRsZXJzLkF4aXNBbmdsZUF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogWzAsIDAsIDEsIDBdfVxyXG4gICAgfTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxtYXRlcmlhbD5cclxuICoqL1xyXG5jbGFzc0luZm9bJ21hdGVyaWFsJ10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICBvbmxvYWQ6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25wcm9ncmVzczoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBjb21wbGV0ZToge3A6IHByb3BlcnRpZXMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUNvbXBsZXRlfSxcclxuICAgIGNvbXB1dGU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGdldE91dHB1dE5hbWVzOiB7bTogbWV0aG9kcy5YTUwzRFNoYWRlclByb3ZpZGVyVHlwZUdldE91dHB1dE5hbWVzfSxcclxuICAgIGdldE91dHB1dENoYW5uZWxJbmZvOiB7bTogbWV0aG9kcy5YTUwzRFNoYWRlclByb3ZpZGVyVHlwZUdldE91dHB1dENoYW5uZWxJbmZvfSxcclxuICAgIGdldFJlc3VsdDoge206IG1ldGhvZHMuWE1MM0RTaGFkZXJQcm92aWRlclR5cGVHZXRSZXN1bHR9LFxyXG4gICAgbW9kZWw6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHNyYzoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9XHJcbiAgICB9O1xyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPGxpZ2h0PlxyXG4gKiovXHJcbmNsYXNzSW5mb1snbGlnaHQnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIG9uY2xpY2s6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25kYmxjbGljazoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlZG93bjoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNldXA6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW92ZXI6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW1vdmU6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW91dDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmtleXByZXNzOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ua2V5ZG93bjoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmtleXVwOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGdsb2JhbDoge2E6IGhhbmRsZXJzLkJvb2xBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IGZhbHNlfSxcclxuICAgIGdldFdvcmxkTWF0cml4OiB7bTogbWV0aG9kcy5YTUwzREdyYXBoVHlwZUdldFdvcmxkTWF0cml4fSxcclxuICAgIGdldExvY2FsTWF0cml4OiB7bTogbWV0aG9kcy5YTUwzREdyYXBoVHlwZUdldExvY2FsTWF0cml4fSxcclxuICAgIG9ubG9hZDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbnByb2dyZXNzOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGNvbXBsZXRlOiB7cDogcHJvcGVydGllcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlQ29tcGxldGV9LFxyXG4gICAgY29tcHV0ZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgZ2V0T3V0cHV0TmFtZXM6IHttOiBtZXRob2RzLlhNTDNEU2hhZGVyUHJvdmlkZXJUeXBlR2V0T3V0cHV0TmFtZXN9LFxyXG4gICAgZ2V0T3V0cHV0Q2hhbm5lbEluZm86IHttOiBtZXRob2RzLlhNTDNEU2hhZGVyUHJvdmlkZXJUeXBlR2V0T3V0cHV0Q2hhbm5lbEluZm99LFxyXG4gICAgZ2V0UmVzdWx0OiB7bTogbWV0aG9kcy5YTUwzRFNoYWRlclByb3ZpZGVyVHlwZUdldFJlc3VsdH0sXHJcbiAgICBzcmM6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG1vZGVsOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn1cclxuICAgIH07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8bGlnaHRzaGFkZXI+XHJcbiAqIC8vIFRPRE8oa3NvbnMpOiBSZW1vdmUgaW4gWE1MM0QgNS4xXHJcbiAqKi9cclxuY2xhc3NJbmZvWydsaWdodHNoYWRlciddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgb25sb2FkOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ucHJvZ3Jlc3M6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgY29tcGxldGU6IHtwOiBwcm9wZXJ0aWVzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVDb21wbGV0ZX0sXHJcbiAgICBjb21wdXRlOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBnZXRPdXRwdXROYW1lczoge206IG1ldGhvZHMuWE1MM0RTaGFkZXJQcm92aWRlclR5cGVHZXRPdXRwdXROYW1lc30sXHJcbiAgICBnZXRPdXRwdXRDaGFubmVsSW5mbzoge206IG1ldGhvZHMuWE1MM0RTaGFkZXJQcm92aWRlclR5cGVHZXRPdXRwdXRDaGFubmVsSW5mb30sXHJcbiAgICBnZXRSZXN1bHQ6IHttOiBtZXRob2RzLlhNTDNEU2hhZGVyUHJvdmlkZXJUeXBlR2V0UmVzdWx0fSxcclxuICAgIHNjcmlwdDoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgc3JjOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn1cclxuICAgIH07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8c2NyaXB0PlxyXG4gKiovXHJcbmNsYXNzSW5mb1snc2NyaXB0J10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICB2YWx1ZToge2E6IGhhbmRsZXJzLlN0cmluZ1ZhbHVlSGFuZGxlcn0sXHJcbiAgICBzcmM6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG5hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHR5cGU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfVxyXG4gICAgfTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxhc3NldG1lc2g+XHJcbiAqKi9cclxuY2xhc3NJbmZvWydhc3NldG1lc2gnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIG5hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG1hdGNoOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICB0eXBlOiB7YTogaGFuZGxlcnMuRW51bUF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczoge3ZhbHVlczogTWVzaFR5cGVzLCBkZWZhdWx0VmFsdWU6IDB9fSxcclxuICAgIGNvbXB1dGU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGZpbHRlcjoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgaW5jbHVkZXM6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG1hdGVyaWFsOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICB0cmFuc2Zvcm06IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHBsYXRmb3JtOiB7YTogaGFuZGxlcnMuRW51bUF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczoge3ZhbHVlczogUGxhdGZvcm1UeXBlcywgZGVmYXVsdFZhbHVlOiAxfX0sXHJcbiAgICBnZXRPdXRwdXROYW1lczoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldE91dHB1dE5hbWVzfSxcclxuICAgIGdldE91dHB1dENoYW5uZWxJbmZvOiB7bTogbWV0aG9kcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlR2V0T3V0cHV0Q2hhbm5lbEluZm99LFxyXG4gICAgZ2V0UmVzdWx0OiB7bTogbWV0aG9kcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlR2V0UmVzdWx0fSxcclxuICAgIHNyYzoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9XHJcbiAgICB9O1xyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPGFzc2V0ZGF0YT5cclxuICoqL1xyXG5jbGFzc0luZm9bJ2Fzc2V0ZGF0YSddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgbmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgY29tcHV0ZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgZmlsdGVyOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBpbmNsdWRlczoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgcGxhdGZvcm06IHthOiBoYW5kbGVycy5FbnVtQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiB7dmFsdWVzOiBQbGF0Zm9ybVR5cGVzLCBkZWZhdWx0VmFsdWU6IDF9fSxcclxuICAgIGdldE91dHB1dE5hbWVzOiB7bTogbWV0aG9kcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlR2V0T3V0cHV0TmFtZXN9LFxyXG4gICAgZ2V0T3V0cHV0Q2hhbm5lbEluZm86IHttOiBtZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVHZXRPdXRwdXRDaGFubmVsSW5mb30sXHJcbiAgICBnZXRSZXN1bHQ6IHttOiBtZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVHZXRSZXN1bHR9LFxyXG4gICAgc3JjOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn1cclxuICAgIH07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8ZmxvYXQ+XHJcbiAqKi9cclxuY2xhc3NJbmZvWydmbG9hdCddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgbmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgcGFyYW06IHthOiBoYW5kbGVycy5Cb29sQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiBmYWxzZX0sXHJcbiAgICBrZXk6IHthOiBoYW5kbGVycy5GbG9hdEF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogMC4wfSxcclxuICAgIHZhbHVlOiB7YTogaGFuZGxlcnMuRmxvYXRBcnJheVZhbHVlSGFuZGxlcn0sXHJcbiAgICBzZXRTY3JpcHRWYWx1ZToge206IG1ldGhvZHMuWE1MM0REYXRhU291cmNlVHlwZVNldFNjcmlwdFZhbHVlfVxyXG4gICAgfTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxmbG9hdDI+XHJcbiAqKi9cclxuY2xhc3NJbmZvWydmbG9hdDInXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIG5hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHBhcmFtOiB7YTogaGFuZGxlcnMuQm9vbEF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogZmFsc2V9LFxyXG4gICAga2V5OiB7YTogaGFuZGxlcnMuRmxvYXRBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IDAuMH0sXHJcbiAgICB2YWx1ZToge2E6IGhhbmRsZXJzLkZsb2F0MkFycmF5VmFsdWVIYW5kbGVyfSxcclxuICAgIHNldFNjcmlwdFZhbHVlOiB7bTogbWV0aG9kcy5YTUwzRERhdGFTb3VyY2VUeXBlU2V0U2NyaXB0VmFsdWV9XHJcbiAgICB9O1xyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPGZsb2F0Mz5cclxuICoqL1xyXG5jbGFzc0luZm9bJ2Zsb2F0MyddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgbmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgcGFyYW06IHthOiBoYW5kbGVycy5Cb29sQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiBmYWxzZX0sXHJcbiAgICBrZXk6IHthOiBoYW5kbGVycy5GbG9hdEF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogMC4wfSxcclxuICAgIHZhbHVlOiB7YTogaGFuZGxlcnMuRmxvYXQzQXJyYXlWYWx1ZUhhbmRsZXJ9LFxyXG4gICAgc2V0U2NyaXB0VmFsdWU6IHttOiBtZXRob2RzLlhNTDNERGF0YVNvdXJjZVR5cGVTZXRTY3JpcHRWYWx1ZX1cclxuICAgIH07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8ZmxvYXQ0PlxyXG4gKiovXHJcbmNsYXNzSW5mb1snZmxvYXQ0J10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICBuYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBwYXJhbToge2E6IGhhbmRsZXJzLkJvb2xBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IGZhbHNlfSxcclxuICAgIGtleToge2E6IGhhbmRsZXJzLkZsb2F0QXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiAwLjB9LFxyXG4gICAgdmFsdWU6IHthOiBoYW5kbGVycy5GbG9hdDRBcnJheVZhbHVlSGFuZGxlcn0sXHJcbiAgICBzZXRTY3JpcHRWYWx1ZToge206IG1ldGhvZHMuWE1MM0REYXRhU291cmNlVHlwZVNldFNjcmlwdFZhbHVlfVxyXG4gICAgfTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxmbG9hdDR4ND5cclxuICoqL1xyXG5jbGFzc0luZm9bJ2Zsb2F0NHg0J10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICBuYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBwYXJhbToge2E6IGhhbmRsZXJzLkJvb2xBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IGZhbHNlfSxcclxuICAgIGtleToge2E6IGhhbmRsZXJzLkZsb2F0QXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiAwLjB9LFxyXG4gICAgdmFsdWU6IHthOiBoYW5kbGVycy5GbG9hdDR4NEFycmF5VmFsdWVIYW5kbGVyfSxcclxuICAgIHNldFNjcmlwdFZhbHVlOiB7bTogbWV0aG9kcy5YTUwzRERhdGFTb3VyY2VUeXBlU2V0U2NyaXB0VmFsdWV9XHJcbiAgICB9O1xyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPGludD5cclxuICoqL1xyXG5jbGFzc0luZm9bJ2ludCddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgbmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgcGFyYW06IHthOiBoYW5kbGVycy5Cb29sQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiBmYWxzZX0sXHJcbiAgICBrZXk6IHthOiBoYW5kbGVycy5GbG9hdEF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogMC4wfSxcclxuICAgIHZhbHVlOiB7YTogaGFuZGxlcnMuSW50QXJyYXlWYWx1ZUhhbmRsZXJ9LFxyXG4gICAgc2V0U2NyaXB0VmFsdWU6IHttOiBtZXRob2RzLlhNTDNERGF0YVNvdXJjZVR5cGVTZXRTY3JpcHRWYWx1ZX1cclxuICAgIH07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8aW50ND5cclxuICoqL1xyXG5jbGFzc0luZm9bJ2ludDQnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIG5hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHBhcmFtOiB7YTogaGFuZGxlcnMuQm9vbEF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogZmFsc2V9LFxyXG4gICAga2V5OiB7YTogaGFuZGxlcnMuRmxvYXRBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IDAuMH0sXHJcbiAgICB2YWx1ZToge2E6IGhhbmRsZXJzLkludEFycmF5VmFsdWVIYW5kbGVyfSxcclxuICAgIHNldFNjcmlwdFZhbHVlOiB7bTogbWV0aG9kcy5YTUwzRERhdGFTb3VyY2VUeXBlU2V0U2NyaXB0VmFsdWV9XHJcbiAgICB9O1xyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPGJvb2w+XHJcbiAqKi9cclxuY2xhc3NJbmZvWydib29sJ10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICBuYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBwYXJhbToge2E6IGhhbmRsZXJzLkJvb2xBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IGZhbHNlfSxcclxuICAgIGtleToge2E6IGhhbmRsZXJzLkZsb2F0QXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiAwLjB9LFxyXG4gICAgdmFsdWU6IHthOiBoYW5kbGVycy5Cb29sQXJyYXlWYWx1ZUhhbmRsZXJ9LFxyXG4gICAgc2V0U2NyaXB0VmFsdWU6IHttOiBtZXRob2RzLlhNTDNERGF0YVNvdXJjZVR5cGVTZXRTY3JpcHRWYWx1ZX1cclxuICAgIH07XHJcblxyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPHN0cmluZz5cclxuICoqL1xyXG5jbGFzc0luZm9bJ3N0cmluZyddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgbmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgcGFyYW06IHthOiBoYW5kbGVycy5Cb29sQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiBmYWxzZX0sXHJcbiAgICBrZXk6IHthOiBoYW5kbGVycy5GbG9hdEF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogMC4wfSxcclxuICAgIHZhbHVlOiB7YTogaGFuZGxlcnMuU3RyaW5nVmFsdWVIYW5kbGVyfSxcclxuICAgIHNldFNjcmlwdFZhbHVlOiB7bTogbWV0aG9kcy5YTUwzRERhdGFTb3VyY2VUeXBlU2V0U2NyaXB0VmFsdWV9XHJcbn07XHJcblxyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPHRleHR1cmU+XHJcbiAqKi9cclxuY2xhc3NJbmZvWyd0ZXh0dXJlJ10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICBuYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBwYXJhbToge2E6IGhhbmRsZXJzLkJvb2xBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IGZhbHNlfSxcclxuICAgIGtleToge2E6IGhhbmRsZXJzLkZsb2F0QXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiAwLjB9LFxyXG4gICAgdHlwZToge2E6IGhhbmRsZXJzLkVudW1BdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IHt2YWx1ZXM6IFRleHR1cmVUeXBlcywgZGVmYXVsdFZhbHVlOiAwfX0sXHJcbiAgICBmaWx0ZXI6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHdyYXA6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGFuaXNvdHJvcHk6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfVxyXG4gICAgfTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxpbWc+XHJcbiAqKi9cclxuY2xhc3NJbmZvWydpbWcnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIHNyYzoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9XHJcbiAgICB9O1xyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPHZpZGVvPlxyXG4gKiovXHJcbmNsYXNzSW5mb1sndmlkZW8nXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIHNyYzoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgYXV0b3BsYXk6IHthOiBoYW5kbGVycy5Cb29sQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiBmYWxzZX0sXHJcbiAgICBtdXRlZDoge2E6IGhhbmRsZXJzLkJvb2xBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IGZhbHNlfSxcclxuICAgIHBsYXk6IHttOiBtZXRob2RzLnZpZGVvUGxheX0sXHJcbiAgICBwYXVzZToge206IG1ldGhvZHMudmlkZW9QYXVzZX1cclxuICAgIH07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8dmlldz5cclxuICoqL1xyXG5jbGFzc0luZm9bJ3ZpZXcnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIG9uY2xpY2s6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25kYmxjbGljazoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlZG93bjoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNldXA6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW92ZXI6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW1vdmU6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW91dDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmtleXByZXNzOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ua2V5ZG93bjoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmtleXVwOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGdldFdvcmxkTWF0cml4OiB7bTogbWV0aG9kcy5YTUwzREdyYXBoVHlwZUdldFdvcmxkTWF0cml4fSxcclxuICAgIGdldExvY2FsTWF0cml4OiB7bTogbWV0aG9kcy5YTUwzREdyYXBoVHlwZUdldExvY2FsTWF0cml4fSxcclxuICAgIGdldFByb2plY3Rpb25NYXRyaXg6e206IG1ldGhvZHMudmlld0dldFByb2plY3Rpb25NYXRyaXh9LFxyXG4gICAgZ2V0Vmlld01hdHJpeDoge206IG1ldGhvZHMudmlld0dldFZpZXdNYXRyaXh9XHJcbiAgICB9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBjbGFzc0luZm8gOiBjbGFzc0luZm8sXHJcbiAgICBNZXNoVHlwZXMgOiBNZXNoVHlwZXMsXHJcbiAgICBUZXh0dXJlVHlwZXMgOiBUZXh0dXJlVHlwZXMsXHJcbiAgICBQbGF0Zm9ybVR5cGVzIDogUGxhdGZvcm1UeXBlcyxcclxuICAgIERhdGFGaWVsZFR5cGVzIDogRGF0YUZpZWxkVHlwZSxcclxuICAgIERhdGFDaGFubmVsT3JpZ2luIDogRGF0YUNoYW5uZWxPcmlnaW5cclxufTtcclxuIiwidmFyIGNvbmZpZyA9IHJlcXVpcmUoXCIuL2VsZW1lbnRzLmpzXCIpLmNvbmZpZztcclxudmFyIGNsYXNzSW5mbyA9IHJlcXVpcmUoXCIuL2NvbmZpZ3VyYXRpb24uanNcIikuY2xhc3NJbmZvO1xyXG5cclxudmFyIGRvYyA9IHt9O1xyXG52YXIgbmF0aXZlR2V0RWxlbWVudEJ5SWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZDtcclxuZG9jLmdldEVsZW1lbnRCeUlkID0gZnVuY3Rpb24oaWQpIHtcclxuICAgIHZhciBlbGVtID0gbmF0aXZlR2V0RWxlbWVudEJ5SWQuY2FsbCh0aGlzLCBpZCk7XHJcbiAgICBpZiAoZWxlbSkge1xyXG4gICAgICAgIHJldHVybiBlbGVtO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgZWxlbXMgPSB0aGlzLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKTtcclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IGVsZW1zW2ldO1xyXG4gICAgICAgICAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gaWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcbnZhciBuYXRpdmVDcmVhdGVFbGVtZW50TlMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlM7XHJcbmRvYy5jcmVhdGVFbGVtZW50TlMgPSBmdW5jdGlvbihucywgbmFtZSkge1xyXG4gICAgdmFyIHIgPSBuYXRpdmVDcmVhdGVFbGVtZW50TlMuY2FsbCh0aGlzLCBucywgbmFtZSk7XHJcbiAgICBpZiAobnMgPT0gWE1MM0QueG1sM2ROUyB8fCBjbGFzc0luZm9bbmFtZS50b0xvd2VyQ2FzZSgpXSkge1xyXG4gICAgICAgIGNvbmZpZy5lbGVtZW50KHIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHI7XHJcbn07XHJcbnZhciBuYXRpdmVDcmVhdGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudDtcclxuZG9jLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICB2YXIgciA9IG5hdGl2ZUNyZWF0ZUVsZW1lbnQuY2FsbCh0aGlzLCBuYW1lKTtcclxuICAgIGlmIChjbGFzc0luZm9bbmFtZS50b0xvd2VyQ2FzZSgpXSApIHtcclxuICAgICAgICBjb25maWcuZWxlbWVudChyKTtcclxuICAgIH1cclxuICAgIHJldHVybiByO1xyXG59O1xyXG5cclxuWE1MM0QuZXh0ZW5kKHdpbmRvdy5kb2N1bWVudCwgZG9jKTtcclxuIiwidmFyIGV2ZW50cyA9IHJlcXVpcmUoXCIuL25vdGlmaWNhdGlvbi5qc1wiKTtcclxudmFyIENsYXNzSW5mbyA9IHJlcXVpcmUoXCIuL2NvbmZpZ3VyYXRpb24uanNcIikuY2xhc3NJbmZvO1xyXG52YXIgUmVzb3VyY2UgPSByZXF1aXJlKFwiLi4vcmVzb3VyY2VcIik7XHJcblxyXG52YXIgTXV0YXRpb25PYnNlcnZlciA9ICh3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB8fCB3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlciB8fCB3aW5kb3cuTW96TXV0YXRpb25PYnNlcnZlciksXHJcbiAgICBtdXRPYnNlcnZlcjtcclxuXHJcbmlmKE11dGF0aW9uT2JzZXJ2ZXIpe1xyXG4gICAgbXV0T2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihoYW5kbGVNdXRhdGlvbnMpO1xyXG59IGVsc2Uge1xyXG4gICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJYTUwzRCByZXF1aXJlcyBNdXRhdGlvbk9ic2VydmVycywgd2hpY2ggeW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQuIFBsZWFzZSBjb25zaWRlciB1cGdyYWRpbmcgdG8gYSBuZXdlciB2ZXJzaW9uLlwiKTtcclxuICAgIG11dE9ic2VydmVyID0ge1xyXG4gICAgICAgIHRha2VSZWNvcmRzOmZ1bmN0aW9uKCl7cmV0dXJuIFtdfSxcclxuICAgICAgICBvYnNlcnZlOiBmdW5jdGlvbihhLGIpIHt9XHJcbiAgICB9XHJcbn1cclxuXHJcblhNTDNELmZsdXNoRE9NQ2hhbmdlcyA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgcmVjb3JkcyA9IG11dE9ic2VydmVyLnRha2VSZWNvcmRzKCk7XHJcbiAgICByZWNvcmRzLmxlbmd0aCAmJiBoYW5kbGVNdXRhdGlvbnMocmVjb3Jkcyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVNdXRhdGlvbnMobXV0YXRpb25zKSB7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB2YXIgbXV0YXRpb25SZWNvcmQgPSBtdXRhdGlvbnNbaV07XHJcbiAgICAgICAgaWYgKG11dGF0aW9uUmVjb3JkLnR5cGUgPT09ICdhdHRyaWJ1dGVzJykge1xyXG4gICAgICAgICAgICBoYW5kbGVBdHRyaWJ1dGVDaGFuZ2VkKG11dGF0aW9uUmVjb3JkKTtcclxuICAgICAgICB9IGVsc2UgaWYgKG11dGF0aW9uUmVjb3JkLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZUNoaWxkTGlzdENoYW5nZWQobXV0YXRpb25SZWNvcmQpO1xyXG4gICAgICAgIH0gZWxzZSBpZihtdXRhdGlvblJlY29yZC50eXBlID09ICdjaGFyYWN0ZXJEYXRhJyl7XHJcbiAgICAgICAgICAgIGhhbmRsZUNoYXJhY3RlckRhdGFDaGFuZ2VkKG11dGF0aW9uUmVjb3JkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUNoYXJhY3RlckRhdGFDaGFuZ2VkKG11dGF0aW9uKSB7XHJcbiAgICB2YXIgdGFyZ2V0ID0gbXV0YXRpb24udGFyZ2V0O1xyXG4gICAgd2hpbGUoIXRhcmdldC5fY29uZmlndXJlZCAmJiB0YXJnZXQucGFyZW50RWxlbWVudCkge1xyXG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnRFbGVtZW50O1xyXG4gICAgfVxyXG4gICAgdmFyIGVsZW1lbnRIYW5kbGVyID0gdGFyZ2V0Ll9jb25maWd1cmVkO1xyXG4gICAgaWYgKCFlbGVtZW50SGFuZGxlcikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBuID0gbmV3IGV2ZW50cy5Ob3RpZmljYXRpb25XcmFwcGVyKG11dGF0aW9uLCBldmVudHMuVkFMVUVfTU9ESUZJRUQsIHRhcmdldCk7XHJcbiAgICBpZiAoZWxlbWVudEhhbmRsZXIuaGFuZGxlcnMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGVsZW1lbnRIYW5kbGVyLmhhbmRsZXJzLnZhbHVlLnJlc2V0VmFsdWUoZWxlbWVudEhhbmRsZXIuc3RvcmFnZSk7XHJcbiAgICB9XHJcbiAgICBlbGVtZW50SGFuZGxlci5ub3RpZnkobik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUNoaWxkTGlzdENoYW5nZWQobXV0YXRpb24pIHtcclxuICAgIHZhciBhZGRlZE5vZGVzID0gbXV0YXRpb24uYWRkZWROb2RlcztcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWRkZWROb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChhZGRlZE5vZGVzW2ldLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSl7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgbWF5IGhhdmUgYmVlbiB0aGUgdmFsdWUgb2YgZWcuIGEgZmxvYXQzIGVsZW1lbnQsIHdlIHNob3VsZCB0cmVhdCBpdCBhcyBhIGNoYXJhY3RlckRhdGFDaGFuZ2VkIGV2ZW50XHJcbiAgICAgICAgICAgIGhhbmRsZUNoYXJhY3RlckRhdGFDaGFuZ2VkKG11dGF0aW9uKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhhbmRsZU5vZGVJbnNlcnRlZChhZGRlZE5vZGVzW2ldLCBtdXRhdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlbW92ZWROb2RlcyA9IG11dGF0aW9uLnJlbW92ZWROb2RlcztcclxuICAgIGZvciAodmFyIGk9MDsgaSA8IHJlbW92ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChyZW1vdmVkTm9kZXNbaV0ubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKXtcclxuICAgICAgICAgICAgY29udGludWU7IC8vIGNoYXJhY3RlckRhdGFDaGFuZ2VkIGV2ZW50cyB3ZXJlIGFscmVhZHkgaGFuZGxlZCBpbiBhZGRlZE5vZGVzXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhhbmRsZU5vZGVSZW1vdmVkKHJlbW92ZWROb2Rlc1tpXSwgbXV0YXRpb24pO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVOb2RlSW5zZXJ0ZWQobm9kZSwgbXV0YXRpb24pIHtcclxuICAgIGlmICghbm9kZS5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuOyAvL05vZGUgbWF5IGhhdmUgYmVlbiBzdWJzZXF1ZW50bHkgcmVtb3ZlZCBhZ2FpbiBpbiBhIG11dGF0aW9uIGV2ZW50IHRoYXQgd2UgaGF2ZW4ndCBwcm9jZXNzZWQgeWV0XHJcbiAgICB9XHJcbiAgICB2YXIgdGFyZ2V0SGFuZGxlciA9IG11dGF0aW9uLnRhcmdldC5fY29uZmlndXJlZDtcclxuICAgIGlmICghdGFyZ2V0SGFuZGxlcikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbmZpZy5lbGVtZW50KG5vZGUpO1xyXG4gICAgYWRkUmVjdXJzaXZlKG5vZGUpO1xyXG4gICAgdmFyIG4gPSBuZXcgZXZlbnRzLk5vdGlmaWNhdGlvbldyYXBwZXIobXV0YXRpb24sIGV2ZW50cy5OT0RFX0lOU0VSVEVELCBub2RlKTtcclxuICAgIHRhcmdldEhhbmRsZXIubm90aWZ5KG4pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVOb2RlUmVtb3ZlZChub2RlLCBtdXRhdGlvbikge1xyXG4gICAgdmFyIHRhcmdldEhhbmRsZXIgPSBtdXRhdGlvbi50YXJnZXQuX2NvbmZpZ3VyZWQ7XHJcbiAgICBpZiAoIXRhcmdldEhhbmRsZXIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgbiA9IG5ldyBldmVudHMuTm90aWZpY2F0aW9uV3JhcHBlcihtdXRhdGlvbiwgZXZlbnRzLk5PREVfUkVNT1ZFRCwgbm9kZSk7XHJcbiAgICB0YXJnZXRIYW5kbGVyLm5vdGlmeShuKTtcclxuICAgIGlmKG5vZGUuX2NvbmZpZ3VyZWQpIHtcclxuICAgICAgICBuLnR5cGUgPSBldmVudHMuVEhJU19SRU1PVkVEO1xyXG4gICAgICAgIHJlbW92ZVJlY3Vyc2l2ZShub2RlLCBuKTtcclxuICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpe1xyXG4gICAgICAgIC8vIFRoaXMgbWF5IGhhdmUgYmVlbiB0aGUgdmFsdWUgb2YgZWcuIGEgZmxvYXQzIGVsZW1lbnQsIHdlIHNob3VsZCBhbHNvIHRyZWF0IGl0IGFzIGEgY2hhcmFjdGVyRGF0YUNoYW5nZWQgZXZlbnRcclxuICAgICAgICBoYW5kbGVDaGFyYWN0ZXJEYXRhQ2hhbmdlZChtdXRhdGlvbik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZVJlY3Vyc2l2ZShlbGVtZW50LCBldnQpIHtcclxuICAgIGlmKGVsZW1lbnQuX2NvbmZpZ3VyZWQpIHtcclxuICAgICAgICBSZXNvdXJjZS5ub3RpZnlOb2RlSWRDaGFuZ2UoZWxlbWVudCwgZWxlbWVudC5pZCwgbnVsbCk7XHJcbiAgICAgICAgZWxlbWVudC5fY29uZmlndXJlZC5ub3RpZnkoZXZ0KTtcclxuICAgICAgICBkZWxldGUgZWxlbWVudC5fY29uZmlndXJlZDtcclxuICAgIH1cclxuICAgIHZhciBjaGlsZCA9IGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQ7XHJcbiAgICB3aGlsZShjaGlsZCkge1xyXG4gICAgICAgIHJlbW92ZVJlY3Vyc2l2ZShjaGlsZCwgZXZ0KTtcclxuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRFbGVtZW50U2libGluZztcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYWRkUmVjdXJzaXZlKGVsZW1lbnQpe1xyXG4gICAgdmFyIG4gPSBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkO1xyXG4gICAgd2hpbGUobikge1xyXG4gICAgICAgIGFkZFJlY3Vyc2l2ZShuKTtcclxuICAgICAgICBuID0gbi5uZXh0RWxlbWVudFNpYmxpbmc7XHJcbiAgICB9XHJcbiAgICAvLyBXZSBjYWxsIHRoaXMgaGVyZSBpbiBhZGRpdGlvbiB0byBub2RlSW5zZXJ0ZWRJbnRvRG9jdW1lbnQsIHNpbmNlIHRoZSBsYXRlciBpcyBub3Qgc3VwcG9ydGVkIGJ5IEZpcmVmb3hcclxuICAgIFJlc291cmNlLm5vdGlmeU5vZGVJZENoYW5nZShlbGVtZW50LCBudWxsLCBlbGVtZW50LmlkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7TXV0YXRpb25SZWNvcmR9IG11dGF0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBoYW5kbGVBdHRyaWJ1dGVDaGFuZ2VkKG11dGF0aW9uKSB7XHJcbiAgICB2YXIgdGFyZ2V0ID0gbXV0YXRpb24udGFyZ2V0O1xyXG4gICAgdmFyIGVsZW1lbnRIYW5kbGVyID0gdGFyZ2V0Ll9jb25maWd1cmVkO1xyXG4gICAgaWYgKCFlbGVtZW50SGFuZGxlcikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYXR0cmlidXRlSGFuZGxlciA9IGVsZW1lbnRIYW5kbGVyLmhhbmRsZXJzW211dGF0aW9uLmF0dHJpYnV0ZU5hbWVdIHx8IGVsZW1lbnRIYW5kbGVyLmhhbmRsZXJzW211dGF0aW9uLmF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKV07XHJcbiAgICBpZiAoYXR0cmlidXRlSGFuZGxlciAmJiBhdHRyaWJ1dGVIYW5kbGVyLnNldEZyb21BdHRyaWJ1dGUpIHtcclxuICAgICAgICB2YXIgbmV3VmFsdWUgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUpO1xyXG4gICAgICAgIHZhciBub3RpZmllZCA9IGF0dHJpYnV0ZUhhbmRsZXIuc2V0RnJvbUF0dHJpYnV0ZShuZXdWYWx1ZSwgbXV0YXRpb24ub2xkVmFsdWUsIHRhcmdldCwgZWxlbWVudEhhbmRsZXIuc3RvcmFnZSk7XHJcbiAgICAgICAgWE1MM0QuZGVidWcuYXNzZXJ0KCFub3RpZmllZCwgXCJXZSBhc3N1bWUgbm8gYXR0cmlidXRlIGhhbmRsZXIgbm90aWZpZXMgYWRhcHRlcnMgYW55bW9yZS5cIik7XHJcbiAgICB9XHJcbiAgICBlbGVtZW50SGFuZGxlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobXV0YXRpb24pO1xyXG59XHJcblxyXG5cclxudmFyIEVsZW1lbnRIYW5kbGVyID0gZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgaWYgKCFlbGVtKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbTtcclxuICAgIHRoaXMuaGFuZGxlcnMgPSBudWxsO1xyXG4gICAgdGhpcy5zdG9yYWdlID0ge307XHJcbiAgICB0aGlzLmFkYXB0ZXJzID0ge307XHJcbiAgICBtdXRPYnNlcnZlci5vYnNlcnZlKGVsZW0sIHsgY2hpbGRMaXN0OiB0cnVlLCAgYXR0cmlidXRlczogdHJ1ZSwgYXR0cmlidXRlT2xkVmFsdWU6IHRydWV9ICk7XHJcblxyXG59O1xyXG5cclxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLnJlZ2lzdGVyQXR0cmlidXRlcyA9IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgdmFyIGVsZW0gPSB0aGlzLmVsZW1lbnQ7XHJcblxyXG4gICAgdmFyIGlzSFRNTCA9IChlbGVtIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpO1xyXG4gICAgdmFyIGtleVByZWZpeCA9IChpc0hUTUwgPyBcIl9odG1sXCIgOiBcIl94bWxcIik7XHJcbiAgICB2YXIgaGFuZGxlcktleSA9IGtleVByZWZpeCArIFwiaGFuZGxlcnNcIixcclxuICAgICAgICBwcm90b0tleSA9IGtleVByZWZpeCArIFwicHJvdG9cIjtcclxuXHJcbiAgICB2YXIgY2FuUHJvdG8gPSAhIWVsZW0uX19wcm90b19fO1xyXG5cclxuICAgIGlmKCFjb25maWcuX2NhY2hlKSBjb25maWcuX2NhY2hlID0ge307XHJcblxyXG4gICAgaWYoIWNvbmZpZy5fY2FjaGVbaGFuZGxlcktleV0pe1xyXG4gICAgICAgIC8vIENyZWF0ZSBoYW5kbGVycyBhbmQgcHJvdG90eXBlIG9ubHkgb25jZSBwZXIgY29uZmlndXJhdGlvblxyXG4gICAgICAgIHZhciBwcm90bztcclxuICAgICAgICBpZihjYW5Qcm90byl7XHJcbiAgICAgICAgICAgIHZhciBGID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBGLnByb3RvdHlwZSA9IGVsZW0uX19wcm90b19fO1xyXG4gICAgICAgICAgICBwcm90byA9IG5ldyBGKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB7fTtcclxuICAgICAgICBmb3IgKCB2YXIgcHJvcCBpbiBjb25maWcpIHtcclxuICAgICAgICAgICAgaWYocHJvcCA9PVwiX2NhY2hlXCIpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZiAoY29uZmlnW3Byb3BdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmKHByb3RvKSBkZWxldGUgcHJvdG9bcHJvcF07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnW3Byb3BdLmEgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyTmFtZSA9IGNvbmZpZ1twcm9wXS5pZCB8fCBwcm9wO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gbmV3IGNvbmZpZ1twcm9wXS5hKGF0dHJOYW1lLCBjb25maWdbcHJvcF0ucGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyc1thdHRyTmFtZS50b0xvd2VyQ2FzZSgpXSA9IGhhbmRsZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYocHJvdG8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgcHJvcCwgaGFuZGxlci5kZXNjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIkNhbid0IGNvbmZpZ3VyZSBcIiArIGVsZW0ubm9kZU5hbWUgKyBcIjo6XCIgKyBwcm9wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZ1twcm9wXS5tICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihwcm90bykgcHJvdG9bcHJvcF0gPSBjb25maWdbcHJvcF0ubTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnW3Byb3BdLnAgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHByb3RvKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgcHJvcCwgY29uZmlnW3Byb3BdLnApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiQ2FuJ3QgY29uZmlndXJlIFwiICsgZWxlbS5ub2RlTmFtZSArIFwiOjpcIiArIHByb3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfWVsc2VcclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNhbid0IGNvbmZpZ3VyZSBcIiArIGVsZW0ubm9kZU5hbWUgKyBcIjo6XCIgKyBwcm9wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25maWcuX2NhY2hlW2hhbmRsZXJLZXldID0gaGFuZGxlcnM7XHJcbiAgICAgICAgY29uZmlnLl9jYWNoZVtwcm90b0tleV0gPSBwcm90bztcclxuICAgIH1cclxuICAgIC8vIFNldCBhbmQgaW5pdGlhbGl6ZSBoYW5kbGVycyBmb3IgZWxlbWVudFxyXG4gICAgdGhpcy5oYW5kbGVycyA9IGNvbmZpZy5fY2FjaGVbaGFuZGxlcktleV07XHJcbiAgICBpZihjYW5Qcm90byl7XHJcbiAgICAgICAgZWxlbS5fX3Byb3RvX18gPSBjb25maWcuX2NhY2hlW3Byb3RvS2V5XTtcclxuICAgICAgICBmb3IgKCB2YXIgcHJvcCBpbiBjb25maWcpIHtcclxuICAgICAgICAgICAgaWYocHJvcCA9PVwiX2NhY2hlXCIpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZihjb25maWdbcHJvcF0gJiYgY29uZmlnW3Byb3BdLmEgIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSBjb25maWdbcHJvcF0uaWQgfHwgcHJvcDtcclxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5oYW5kbGVyc1thdHRyTmFtZS50b0xvd2VyQ2FzZSgpXTtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIuaW5pdCAmJiBoYW5kbGVyLmluaXQoZWxlbSwgdGhpcy5zdG9yYWdlKTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtW3Byb3BdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgICBmb3IgKCB2YXIgcHJvcCBpbiBjb25maWcpIHtcclxuICAgICAgICAgICAgaWYocHJvcCA9PVwiX2NhY2hlXCIpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZiAoY29uZmlnW3Byb3BdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtW3Byb3BdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZ1twcm9wXS5hICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0gY29uZmlnW3Byb3BdLmlkIHx8IHByb3A7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuaGFuZGxlcnNbYXR0ck5hbWUudG9Mb3dlckNhc2UoKV07XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmluaXQgJiYgaGFuZGxlci5pbml0KGVsZW0sIHRoaXMuc3RvcmFnZSk7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtLCBwcm9wLCBoYW5kbGVyLmRlc2MpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJDYW4ndCBjb25maWd1cmUgXCIgKyBlbGVtLm5vZGVOYW1lICsgXCI6OlwiICsgcHJvcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1lbHNlIGlmIChjb25maWdbcHJvcF0ubSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtW3Byb3BdID0gY29uZmlnW3Byb3BdLm07XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnW3Byb3BdLnAgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbSwgcHJvcCwgY29uZmlnW3Byb3BdLnApO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJDYW4ndCBjb25maWd1cmUgXCIgKyBlbGVtLm5vZGVOYW1lICsgXCI6OlwiICsgcHJvcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVsZW07XHJcbn07XHJcblxyXG5cclxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLnJlZ2lzdGVyTWl4ZWQgPSBmdW5jdGlvbigpIHtcclxuICAgIG11dE9ic2VydmVyLm9ic2VydmUodGhpcy5lbGVtZW50LCB7IGNoaWxkTGlzdDogdHJ1ZSwgIGF0dHJpYnV0ZXM6IHRydWUsIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlLCBjaGFyYWN0ZXJEYXRhOiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSBldnRcclxuICovXHJcbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5ub3RpZnkgPSAgZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICB2YXIgYWRhcHRlcnMgPSB0aGlzLmFkYXB0ZXJzO1xyXG4gICAgZm9yKHZhciBhIGluIGFkYXB0ZXJzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYWRhcHRlcnNbYV0ubm90aWZ5Q2hhbmdlZChldnQpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXhjZXB0aW9uKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge011dGF0aW9uUmVjb3JkfSBtdXRhdGlvblxyXG4gKi9cclxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayA9ICBmdW5jdGlvbihtdXRhdGlvbikge1xyXG4gICAgdmFyIGFkYXB0ZXJzID0gdGhpcy5hZGFwdGVycztcclxuICAgIGZvcih2YXIgYSBpbiBhZGFwdGVycykge1xyXG4gICAgICAgIFhNTDNELmRlYnVnLmFzc2VydChhZGFwdGVyc1thXS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2ssIFwiQWRhcHRlciBpbXBsZW1lbnRzICdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snOiBcIiArIHRoaXMuZWxlbWVudC5ub2RlTmFtZSArIFwiIChcIiArIGEgKyBcIilcIik7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYWRhcHRlcnNbYV0uYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUsIG11dGF0aW9uLm9sZFZhbHVlLCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUpLCBtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lc3BhY2UpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXhjZXB0aW9uKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qXHJcbiAqIEdldCBjYWxsZWQsIGlmIHRoZSByZWxhdGVkIG5vZGUgZ2V0cyByZW1vdmVkIGZyb20gdGhlIERPTVxyXG4gKi9cclxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgZm9yKHZhciBoIGluIHRoaXMuYWRhcHRlcnMpIHtcclxuICAgICAgICB2YXIgYWRhcHRlciA9IHRoaXMuYWRhcHRlcnNbaF07XHJcbiAgICAgICAgaWYoYWRhcHRlci5kaXNwb3NlKVxyXG4gICAgICAgICAgICBhZGFwdGVyLmRpc3Bvc2UoKTtcclxuICAgICAgICBpZihhZGFwdGVyLmNsZWFyQWRhcHRlckhhbmRsZXMpXHJcbiAgICAgICAgICAgIGFkYXB0ZXIuY2xlYXJBZGFwdGVySGFuZGxlcygpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5hZGFwdGVycyA9IHt9O1xyXG4gICAgZm9yKHZhciBoIGluIHRoaXMuaGFuZGxlcnMpIHtcclxuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuaGFuZGxlcnNbaF07XHJcbiAgICAgICAgaWYoaGFuZGxlci5yZW1vdmUpXHJcbiAgICAgICAgICAgIGhhbmRsZXIucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gXCJFbGVtZW50SGFuZGxlciAoXCIrdGhpcy5lbGVtZW50Lm5vZGVOYW1lICsgXCIsIGlkOiBcIit0aGlzLmVsZW1lbnQuaWQrXCIpXCI7XHJcbn07XHJcblxyXG52YXIgZGVsZWdhdGVQcm9wZXJ0aWVzID0gW1wiY2xpZW50SGVpZ2h0XCIsIFwiY2xpZW50TGVmdFwiLCBcImNsaWVudFRvcFwiLCBcImNsaWVudFdpZHRoXCIsXHJcbiAgICBcIm9mZnNldEhlaWdodFwiLCBcIm9mZnNldExlZnRcIiwgXCJvZmZzZXRUb3BcIiwgXCJvZmZzZXRXaWR0aFwiXTtcclxuZnVuY3Rpb24gZGVsZWdhdGVQcm9wKG5hbWUsIGVsZW0sIGNhbnZhcykge1xyXG4gICAgdmFyIGRlc2MgPSB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlIDogdHJ1ZSxcclxuICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbnZhc1tuYW1lXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbSwgbmFtZSwgZGVzYyk7XHJcbiAgICB9IGNhdGNoIChlKXtcclxuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiQ2FuJ3QgY29uZmlndXJlIFwiICsgZWxlbS5ub2RlTmFtZSArIFwiOjpcIiArIG5hbWUpO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgWE1MM0RIYW5kbGVyID0gZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgRWxlbWVudEhhbmRsZXIuY2FsbCh0aGlzLCBlbGVtKTtcclxuICAgIHZhciBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgIGMud2lkdGggPSA4MDA7XHJcbiAgICBjLmhlaWdodCA9IDYwMDtcclxuICAgIHRoaXMuY2FudmFzID0gYztcclxuICAgIHRoaXMuY2FudmFzSGFuZGxlciA9IHsgZGVzdHJveTpmdW5jdGlvbigpIHt9IH07XHJcblxyXG4gICAgZm9yKHZhciBpIGluIGRlbGVnYXRlUHJvcGVydGllcykge1xyXG4gICAgICAgIGRlbGVnYXRlUHJvcChkZWxlZ2F0ZVByb3BlcnRpZXNbaV0sIGVsZW0sIGMpO1xyXG4gICAgfVxyXG5cclxuICAgIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGZvcih2YXIgaSBpbiBkZWxlZ2F0ZVByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgZGVsZXRlIGVsZW1bZGVsZWdhdGVQcm9wZXJ0aWVzW2ldXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYW52YXNIYW5kbGVyLmRlc3Ryb3koKTtcclxuICAgIH1cclxufTtcclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKFhNTDNESGFuZGxlciwgRWxlbWVudEhhbmRsZXIpO1xyXG5cclxuXHJcbnZhciBjb25maWcgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcclxuICogQHJldHVybiB7dW5kZWZpbmVkfVxyXG4gKi9cclxuY29uZmlnLmVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICBpZiAoZWxlbWVudC5fY29uZmlndXJlZCA9PT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgIHZhciBjbGFzc0luZm8gPSBDbGFzc0luZm9bZWxlbWVudC5sb2NhbE5hbWVdO1xyXG4gICAgICAgIGlmIChjbGFzc0luZm8gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dJbmZvKFwiVW5yZWNvZ25pc2VkIGVsZW1lbnQgXCIgKyBlbGVtZW50LmxvY2FsTmFtZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZWxlbWVudC5fY29uZmlndXJlZCA9IGVsZW1lbnQubG9jYWxOYW1lID09IFwieG1sM2RcIiA/XHJcbiAgICAgICAgICAgICAgICBuZXcgWE1MM0RIYW5kbGVyKGVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICA6IG5ldyBFbGVtZW50SGFuZGxlcihlbGVtZW50KTtcclxuICAgICAgICAgICAgZWxlbWVudC5fY29uZmlndXJlZC5yZWdpc3RlckF0dHJpYnV0ZXMoY2xhc3NJbmZvKTtcclxuICAgICAgICAgICAgLy8gRml4IGRpZmZlcmVuY2UgaW4gRmlyZWZveCAodW5kZWZpbmVkKSBhbmQgQ2hyb21lIChudWxsKVxyXG4gICAgICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdHlsZSA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2goZSl7XHJcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IHRocm93cyBleGNlcHRpb24gaGVyZS4uLlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbiA9IGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQ7XHJcblxyXG4gICAgICAgICAgICBSZXNvdXJjZS5ub3RpZnlOb2RlSWRDaGFuZ2UoZWxlbWVudCwgbnVsbCwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJpZFwiKSk7XHJcblxyXG4gICAgICAgICAgICB3aGlsZShuKSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWcuZWxlbWVudChuKTtcclxuICAgICAgICAgICAgICAgIG4gPSBuLm5leHRFbGVtZW50U2libGluZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcclxuICogQHJldHVybiB7dW5kZWZpbmVkfVxyXG4gKi9cclxuY29uZmlnLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQpKSB7XHJcbiAgICAgICAgZWxlbWVudC5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5lbGVtZW50KGVsKTtcclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uZmlnLmVsZW1lbnQoZWxlbWVudCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBFbGVtZW50SGFuZGxlciA6IEVsZW1lbnRIYW5kbGVyLFxyXG4gICAgWE1MM0RIYW5kbGVyIDogWE1MM0RIYW5kbGVyLFxyXG4gICAgY29uZmlnIDogY29uZmlnXHJcbn07XHJcbiIsInZhciBzZW5kQWRhcHRlckV2ZW50ID0gcmVxdWlyZShcIi4uL3V0aWxzL21pc2MuanNcIikuc2VuZEFkYXB0ZXJFdmVudDtcclxudmFyIGNhbGxBZGFwdGVyRnVuYyA9IHJlcXVpcmUoXCIuLi91dGlscy9taXNjLmpzXCIpLmNhbGxBZGFwdGVyRnVuYztcclxudmFyIENTUyA9IHJlcXVpcmUoXCIuLi91dGlscy9jc3MuanNcIik7XHJcbnZhciBSZXNvdXJjZSA9IHJlcXVpcmUoXCIuLi9yZXNvdXJjZVwiKTtcclxuXHJcbnZhciBWZWMzID0gcmVxdWlyZShcIi4uL3R5cGVzL3ZlYzMuanNcIik7XHJcbnZhciBNYXQ0ID0gcmVxdWlyZShcIi4uL3R5cGVzL21hdDQuanNcIik7XHJcbnZhciB2ZWMzID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS52ZWMzO1xyXG5cclxudmFyIG1ldGhvZHMgPSB7fTtcclxuXHJcbm1ldGhvZHMueG1sM2RHZXRFbGVtZW50QnlSYXkgPSBmdW5jdGlvbihyYXksIGhpdFBvaW50LCBoaXROb3JtYWwpIHtcclxuICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgWE1MM0QuZmx1c2hDU1NDaGFuZ2VzKCk7XHJcbiAgICB2YXIgYWRhcHRlcnMgPSB0aGlzLl9jb25maWd1cmVkLmFkYXB0ZXJzIHx8IHt9O1xyXG4gICAgZm9yICh2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xyXG4gICAgICAgIGlmIChhZGFwdGVyc1thZGFwdGVyXS5nZXRFbGVtZW50QnlSYXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFkYXB0ZXJzW2FkYXB0ZXJdLmdldEVsZW1lbnRCeVJheShyYXksIGhpdFBvaW50LCBoaXROb3JtYWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxubWV0aG9kcy52aWV3R2V0Vmlld01hdHJpeCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XHJcbiAgICB2YXIgYWRhcHRlcnMgPSB0aGlzLl9jb25maWd1cmVkLmFkYXB0ZXJzIHx8IHt9O1xyXG4gICAgZm9yICggdmFyIGFkYXB0ZXIgaW4gYWRhcHRlcnMpIHtcclxuICAgICAgICBpZiAoYWRhcHRlcnNbYWRhcHRlcl0uZ2V0Vmlld01hdHJpeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWRhcHRlcnNbYWRhcHRlcl0uZ2V0Vmlld01hdHJpeCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIEZhbGxiYWNrIGltcGxlbWVudGF0aW9uXHJcbiAgICB2YXIgcmVzdWx0ID0gbmV3IFhNTDNELk1hdDQoKTtcclxuICAgIHZhciBjc3NNYXRyaXggPSBDU1MuZ2V0Q1NTTWF0cml4KHRoaXMpO1xyXG4gICAgaWYoY3NzTWF0cml4KSB7XHJcbiAgICAgICAgQ1NTLmNvbnZlcnRDc3NUb01hdDQoY3NzTWF0cml4LCByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdC5pbnZlcnQoKTtcclxufTtcclxuXHJcbm1ldGhvZHMudmlld0dldFByb2plY3Rpb25NYXRyaXggPSBmdW5jdGlvbigpIHtcclxuICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgdmFyIGFkYXB0ZXJzID0gdGhpcy5fY29uZmlndXJlZC5hZGFwdGVycyB8fCB7fTtcclxuICAgIGZvciAoIHZhciBhZGFwdGVyIGluIGFkYXB0ZXJzKSB7XHJcbiAgICAgICAgaWYgKGFkYXB0ZXJzW2FkYXB0ZXJdLmdldFByb2plY3Rpb25NYXRyaXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFkYXB0ZXJzW2FkYXB0ZXJdLmdldFByb2plY3Rpb25NYXRyaXgoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbm1ldGhvZHMueG1sM2RHZXRFbGVtZW50QnlQb2ludCA9IGZ1bmN0aW9uKHgsIHksIGhpdFBvaW50LCBoaXROb3JtYWwpIHtcclxuICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgWE1MM0QuZmx1c2hDU1NDaGFuZ2VzKCk7XHJcbiAgICB2YXIgYWRhcHRlcnMgPSB0aGlzLl9jb25maWd1cmVkLmFkYXB0ZXJzIHx8IHt9O1xyXG4gICAgZm9yICh2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xyXG4gICAgICAgIGlmIChhZGFwdGVyc1thZGFwdGVyXS5nZXRFbGVtZW50QnlQb2ludCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWRhcHRlcnNbYWRhcHRlcl0uZ2V0RWxlbWVudEJ5UG9pbnQoeCwgeSwgaGl0UG9pbnQsIGhpdE5vcm1hbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5tZXRob2RzLnhtbDNkR2VuZXJhdGVSYXkgPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICB2YXIgYWRhcHRlcnMgPSB0aGlzLl9jb25maWd1cmVkLmFkYXB0ZXJzIHx8IHt9O1xyXG4gICAgZm9yICh2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xyXG4gICAgICAgIGlmIChhZGFwdGVyc1thZGFwdGVyXS5nZW5lcmF0ZVJheSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWRhcHRlcnNbYWRhcHRlcl0uZ2VuZXJhdGVSYXkoeCwgeSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBYTUwzRC5SYXkoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiByZXR1cm4gdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgb3duaW5nIHNwYWNlIGluIHdvcmxkIHNwYWNlXHJcbiAqL1xyXG5tZXRob2RzLmdldFdvcmxkQm91bmRpbmdCb3ggPSBmdW5jdGlvbigpIHtcclxuICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgLy8gVmlzaWJpbGl0eSBpbmZsdWVuY2VzIGJvdW5kaW5nIGJveFxyXG4gICAgWE1MM0QuZmx1c2hDU1NDaGFuZ2VzKCk7XHJcbiAgICB2YXIgYWRhcHRlcnMgPSB0aGlzLl9jb25maWd1cmVkLmFkYXB0ZXJzIHx8IHt9O1xyXG4gICAgZm9yICh2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xyXG4gICAgICAgIGlmIChhZGFwdGVyc1thZGFwdGVyXS5nZXRXb3JsZEJvdW5kaW5nQm94KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhZGFwdGVyc1thZGFwdGVyXS5nZXRXb3JsZEJvdW5kaW5nQm94KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBYTUwzRC5Cb3goKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiByZXR1cm4gdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgb3duaW5nIHNwYWNlIGluIGxvY2FsIHNwYWNlIChvYmplY3QgQkIpXHJcbiAqL1xyXG5tZXRob2RzLmdldExvY2FsQm91bmRpbmdCb3ggPSBmdW5jdGlvbigpIHtcclxuICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgLy8gVmlzaWJpbGl0eSBpbmZsdWVuY2VzIGJvdW5kaW5nIGJveFxyXG4gICAgWE1MM0QuZmx1c2hDU1NDaGFuZ2VzKCk7XHJcbiAgICB2YXIgYWRhcHRlcnMgPSB0aGlzLl9jb25maWd1cmVkLmFkYXB0ZXJzIHx8IHt9O1xyXG4gICAgZm9yICh2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xyXG4gICAgICAgIGlmIChhZGFwdGVyc1thZGFwdGVyXS5nZXRMb2NhbEJvdW5kaW5nQm94KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhZGFwdGVyc1thZGFwdGVyXS5nZXRMb2NhbEJvdW5kaW5nQm94KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBYTUwzRC5Cb3goKTtcclxufTtcclxuXHJcbm1ldGhvZHMueG1sM2RHZXRSZW5kZXJJbnRlcmZhY2UgPSBmdW5jdGlvbigpIHtcclxuICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgdmFyIGFkYXB0ZXJzID0gdGhpcy5fY29uZmlndXJlZC5hZGFwdGVycyB8fCB7fTtcclxuICAgIGZvciAoIHZhciBhZGFwdGVyIGluIGFkYXB0ZXJzKSB7XHJcbiAgICAgICAgaWYgKGFkYXB0ZXJzW2FkYXB0ZXJdLmdldFJlbmRlckludGVyZmFjZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWRhcHRlcnNbYWRhcHRlcl0uZ2V0UmVuZGVySW50ZXJmYWNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHt9O1xyXG59O1xyXG5cclxuXHJcbm1ldGhvZHMuWE1MM0RHcmFwaFR5cGVHZXRXb3JsZE1hdHJpeCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XHJcbiAgICB2YXIgYWRhcHRlcnMgPSB0aGlzLl9jb25maWd1cmVkLmFkYXB0ZXJzIHx8IHt9O1xyXG4gICAgZm9yICh2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xyXG4gICAgICAgIGlmIChhZGFwdGVyc1thZGFwdGVyXS5nZXRXb3JsZE1hdHJpeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWRhcHRlcnNbYWRhcHRlcl0uZ2V0V29ybGRNYXRyaXgoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IE1hdDQoKTtcclxufTtcclxuXHJcbm1ldGhvZHMuWE1MM0RHcmFwaFR5cGVHZXRMb2NhbE1hdHJpeCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XHJcbiAgICB2YXIgYWRhcHRlcnMgPSB0aGlzLl9jb25maWd1cmVkLmFkYXB0ZXJzIHx8IHt9O1xyXG4gICAgZm9yICggdmFyIGFkYXB0ZXIgaW4gYWRhcHRlcnMpIHtcclxuICAgICAgICBpZiAoYWRhcHRlcnNbYWRhcHRlcl0uZ2V0TG9jYWxNYXRyaXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFkYXB0ZXJzW2FkYXB0ZXJdLmdldExvY2FsTWF0cml4KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBNYXQ0KCk7XHJcbn07XHJcblxyXG5tZXRob2RzLnZpZGVvUGxheSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgc2VuZEFkYXB0ZXJFdmVudCh0aGlzLCB7cGxheTogW119KTtcclxufTtcclxuXHJcbm1ldGhvZHMudmlkZW9QYXVzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgc2VuZEFkYXB0ZXJFdmVudCh0aGlzLCB7cGF1c2U6IFtdfSk7XHJcbn07XHJcblxyXG5tZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVHZXRPdXRwdXROYW1lcyA9XHJcbm1ldGhvZHMuWE1MM0RTaGFkZXJQcm92aWRlclR5cGVHZXRPdXRwdXROYW1lcyA9XHJcbm1ldGhvZHMubWVzaEdldE91dHB1dE5hbWVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICBYTUwzRC5mbHVzaERPTUNoYW5nZXMoKTtcclxuICAgIHZhciBkYXRhQWRhcHRlciA9IFJlc291cmNlLmdldEFkYXB0ZXIodGhpcywgXCJkYXRhXCIpO1xyXG4gICAgaWYoZGF0YUFkYXB0ZXIpe1xyXG4gICAgICAgIHJldHVybiBkYXRhQWRhcHRlci5nZXRPdXRwdXROYW1lcygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5tZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVHZXRSZXN1bHQgPVxyXG5tZXRob2RzLlhNTDNEU2hhZGVyUHJvdmlkZXJUeXBlR2V0UmVzdWx0ID1cclxubWV0aG9kcy5tZXNoR2V0UmVzdWx0ID0gZnVuY3Rpb24oZmlsdGVyKSB7XHJcbiAgICBYTUwzRC5mbHVzaERPTUNoYW5nZXMoKTtcclxuICAgIHZhciBkYXRhQWRhcHRlciA9IFJlc291cmNlLmdldEFkYXB0ZXIodGhpcywgXCJkYXRhXCIpO1xyXG4gICAgaWYoZGF0YUFkYXB0ZXIpe1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBkYXRhQWRhcHRlci5nZXRDb21wdXRlUmVzdWx0KGZpbHRlcik7XHJcbiAgICAgICAgaWYoIXJlc3VsdCkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MM0REYXRhUmVzdWx0KHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbm1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldE91dHB1dENoYW5uZWxJbmZvID1cclxuICAgIG1ldGhvZHMuWE1MM0RTaGFkZXJQcm92aWRlclR5cGVHZXRPdXRwdXRDaGFubmVsSW5mbyA9XHJcbiAgICAgICAgbWV0aG9kcy5tZXNoR2V0T3V0cHV0Q2hhbm5lbEluZm8gPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICBYTUwzRC5mbHVzaERPTUNoYW5nZXMoKTtcclxuICAgICAgICAgICAgdmFyIGRhdGFBZGFwdGVyID0gUmVzb3VyY2UuZ2V0QWRhcHRlcih0aGlzLCBcImRhdGFcIik7XHJcbiAgICAgICAgICAgIGlmIChkYXRhQWRhcHRlcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGRhdGFBZGFwdGVyLmdldE91dHB1dENoYW5uZWxJbmZvKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MM0REYXRhQ2hhbm5lbEluZm8ocmVzdWx0LnR5cGUsIHJlc3VsdC5vcmlnaW4sIHJlc3VsdC5vcmlnaW5hbE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNlcUxlbmd0aCwgcmVzdWx0LnNlcU1pbktleSwgcmVzdWx0LnNlcU1heEtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVZhbHVlcyhyZXN1bHQsIG5hbWVzKSB7XHJcbiAgICB2YXIgdmFsdWVzID0ge307XHJcbiAgICBmb3IgKHZhciBpIGluIG5hbWVzKSB7XHJcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcclxuICAgICAgICB2YXIgZGF0YSA9IHJlc3VsdC5nZXRPdXRwdXREYXRhKG5hbWUpICYmIHJlc3VsdC5nZXRPdXRwdXREYXRhKG5hbWUpLmdldFZhbHVlKCk7XHJcbiAgICAgICAgaWYgKGRhdGEpXHJcbiAgICAgICAgICAgIHZhbHVlc1tuYW1lXSA9IGRhdGE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWVzO1xyXG59XHJcblxyXG4vKiogUmVnaXN0ZXIgZGF0YSBsaXN0ZW5lciBmb3IgZGF0YSBmaWVsZHMgc3BlY2lmaWVkIGJ5IG5hbWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0gbmFtZXMgICBzaW5nbGUgbmFtZSBvciBhcnJheSBvZiBuYW1lcyB0aGF0IGFyZSBtb25pdG9yZWQuXHJcbiAqIEBwYXJhbSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHNlbGVjdGVkIGRhdGEgYXJlIGNoYW5nZWQuXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqL1xyXG5tZXRob2RzLmRhdGFBZGRPdXRwdXRGaWVsZExpc3RlbmVyID0gZnVuY3Rpb24obmFtZXMsIGNhbGxiYWNrKSB7XHJcbiAgICBYTUwzRC5mbHVzaERPTUNoYW5nZXMoKTtcclxuICAgIGlmICghbmFtZXMpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIC8vIGNoZWNrIGlmIG5hbWVzIGlzIGEgc2luZ2xlIHN0cmluZywgYW5kIGNvbnZlcnQgaXQgdG8gYXJyYXkgdGhlblxyXG4gICAgdmFyIHR5cGVPZk5hbWVzID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5hbWVzKS5zbGljZSg4LCAtMSk7XHJcbiAgICBpZiAodHlwZU9mTmFtZXMgPT09IFwiU3RyaW5nXCIpIHtcclxuICAgICAgICBuYW1lcyA9IFtuYW1lc107XHJcbiAgICB9XHJcbiAgICBpZiAobmFtZXMubGVuZ3RoID09IDApXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIHZhciByZXF1ZXN0ID0gY2FsbEFkYXB0ZXJGdW5jKHRoaXMsIHtcclxuICAgICAgICBnZXRDb21wdXRlUmVxdWVzdCA6IFtuYW1lcywgZnVuY3Rpb24ocmVxdWVzdCwgY2hhbmdlVHlwZSkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhjcmVhdGVWYWx1ZXMocmVxdWVzdC5nZXRSZXN1bHQoKSwgbmFtZXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXX0pO1xyXG4gICAgaWYgKHJlcXVlc3QubGVuZ3RoID09IDApXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgdmFyIHJlc3VsdCA9IHJlcXVlc3RbMF0uZ2V0UmVzdWx0KCk7XHJcbiAgICB2YXIgdmFsdWVzID0gY3JlYXRlVmFsdWVzKHJlc3VsdCwgbmFtZXMpO1xyXG4gICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlcykubGVuZ3RoKVxyXG4gICAgICAgIGNhbGxiYWNrKHZhbHVlcyk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbm1ldGhvZHMuWE1MM0REYXRhU291cmNlVHlwZVNldFNjcmlwdFZhbHVlID0gZnVuY3Rpb24oZGF0YSl7XHJcbiAgICB2YXIgY29uZmlnRGF0YSA9IHRoaXMuX2NvbmZpZ3VyZWQ7XHJcblxyXG4gICAgaWYoIWNvbmZpZ0RhdGEpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGlmKHRoaXMudGV4dENvbnRlbnQgIT0gXCJbdmFsdWUgc2V0IGJ5IHNjcmlwdF1cIilcclxuICAgICAgICB0aGlzLnRleHRDb250ZW50ID0gXCJbdmFsdWUgc2V0IGJ5IHNjcmlwdF1cIjtcclxuICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgY29uZmlnRGF0YS5zY3JpcHRWYWx1ZSA9IGRhdGE7XHJcblxyXG4gICAgdmFyIGRhdGFBZGFwdGVyID0gUmVzb3VyY2UuZ2V0QWRhcHRlcih0aGlzLCBcImRhdGFcIik7XHJcbiAgICBpZihkYXRhQWRhcHRlcilcclxuICAgICAgICBkYXRhQWRhcHRlci5zZXRTY3JpcHRWYWx1ZShkYXRhKTtcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG1ldGhvZHM7XHJcbiIsIlxyXG4vKipcclxuICogVHlwZXMgb2YgY2hhbmdlIGV2ZW50c1xyXG4gKiBAZW51bSB7bnVtYmVyfVxyXG4gKi9cclxudmFyIGV2ZW50cyA9IHtcclxuICAgICAgTk9ERV9JTlNFUlRFRDogMCxcclxuICAgICAgVkFMVUVfTU9ESUZJRUQ6ICAxLFxyXG4gICAgICBOT0RFX1JFTU9WRUQ6IDIsXHJcbiAgICAgIFRISVNfUkVNT1ZFRDogMyxcclxuICAgICAgQURBUFRFUl9IQU5ETEVfQ0hBTkdFRDogNCxcclxuICAgICAgQURBUFRFUl9WQUxVRV9DSEFOR0VEOiA1XHJcbn07XHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vQ2xhc3MgTm90aWZpY2F0aW9uXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuZXZlbnRzLk5vdGlmaWNhdGlvbiA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbn07XHJcbmV2ZW50cy5Ob3RpZmljYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gXCJOb3RpZmljYXRpb24gKHR5cGU6XCIgKyB0aGlzLnR5cGUgKyBcIilcIjtcclxufTtcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5ldmVudHMuTm90aWZpY2F0aW9uV3JhcHBlciA9IGZ1bmN0aW9uKG11dGF0aW9uLCB0eXBlLCBhZmZlY3RlZE5vZGUpIHtcclxuICAgIHRoaXMubXV0YXRpb24gPSBtdXRhdGlvbjtcclxuICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICB0aGlzLmFmZmVjdGVkTm9kZSA9IGFmZmVjdGVkTm9kZTtcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoZXZlbnRzLk5vdGlmaWNhdGlvbldyYXBwZXIsIGV2ZW50cy5Ob3RpZmljYXRpb24pO1xyXG5ldmVudHMuTm90aWZpY2F0aW9uV3JhcHBlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBcIk5vdGlmaWNhdGlvbldyYXBwZXIgKHR5cGU6XCIgKyB0aGlzLnR5cGUgKyBcIiwgd3JhcHBlZDogXCIrIHRoaXMubXV0YXRpb24gK1wiKVwiO1xyXG59O1xyXG5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7QWRhcHRlckhhbmRsZX0gaGFuZGxlXHJcbiAqIEBwYXJhbSB7aW50fSB0eXBlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZXZlbnRzLkFkYXB0ZXJIYW5kbGVOb3RpZmljYXRpb24gPSBmdW5jdGlvbiAoaGFuZGxlLCB0eXBlKSB7XHJcbiAgICB0aGlzLmFkYXB0ZXJIYW5kbGUgPSBoYW5kbGU7XHJcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG59O1xyXG5YTUwzRC5jcmVhdGVDbGFzcyhldmVudHMuQWRhcHRlckhhbmRsZU5vdGlmaWNhdGlvbiwgZXZlbnRzLk5vdGlmaWNhdGlvbik7XHJcbmV2ZW50cy5BZGFwdGVySGFuZGxlTm90aWZpY2F0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBcIkFkYXB0ZXJIYW5kbGVOb3RpZmljYXRpb24gKHR5cGU6XCIgKyB0aGlzLnR5cGUgKyBcIilcIjtcclxufTtcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuZXZlbnRzLkNvbm5lY3RlZEFkYXB0ZXJOb3RpZmljYXRpb24gPSBmdW5jdGlvbihhZGFwdGVySGFuZGxlTm90aWZpY2F0aW9uLCBrZXkpIHtcclxuICAgIHRoaXMuYWRhcHRlciA9IGFkYXB0ZXJIYW5kbGVOb3RpZmljYXRpb24uYWRhcHRlckhhbmRsZS5nZXRBZGFwdGVyKCk7XHJcbiAgICB0aGlzLmtleSA9IGtleTtcclxuICAgIHRoaXMudXJsID0gYWRhcHRlckhhbmRsZU5vdGlmaWNhdGlvbi5hZGFwdGVySGFuZGxlLnVybDtcclxuICAgIHRoaXMudHlwZSA9IGFkYXB0ZXJIYW5kbGVOb3RpZmljYXRpb24udHlwZTtcclxuICAgIHRoaXMuaGFuZGxlU3RhdHVzID0gYWRhcHRlckhhbmRsZU5vdGlmaWNhdGlvbi5hZGFwdGVySGFuZGxlLnN0YXR1cztcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoZXZlbnRzLkNvbm5lY3RlZEFkYXB0ZXJOb3RpZmljYXRpb24sIGV2ZW50cy5Ob3RpZmljYXRpb24pO1xyXG5ldmVudHMuQ29ubmVjdGVkQWRhcHRlck5vdGlmaWNhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBcIkNvbm5lY3RlZEFkYXB0ZXJOb3RpZmljYXRpb24gKHR5cGU6XCIgKyB0aGlzLnR5cGUgKyBcIiwga2V5OiBcIiArIHRoaXMua2V5ICsgXCIpXCI7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGV2ZW50czsiLCJ2YXIgcHJvcGVydGllcyA9IHt9O1xyXG5cclxucHJvcGVydGllcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlQ29tcGxldGUgPSB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XHJcbiAgICAgICAgdmFyIGFkYXB0ZXJzID0gdGhpcy5fY29uZmlndXJlZC5hZGFwdGVycyB8fCB7fTtcclxuICAgICAgICBmb3IgKHZhciBhZGFwdGVyIGluIGFkYXB0ZXJzKSB7XHJcbiAgICAgICAgICAgIGlmIChhZGFwdGVyc1thZGFwdGVyXS5nZXREYXRhQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhZGFwdGVyc1thZGFwdGVyXS5nZXREYXRhQ29tcGxldGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgc2V0OiBmdW5jdGlvbigpe31cclxufTtcclxuXHJcbnByb3BlcnRpZXMuQXNzZXRDb21wbGV0ZSA9IHtcclxuICAgIGdldDogZnVuY3Rpb24oKXtcclxuICAgICAgICBYTUwzRC5mbHVzaERPTUNoYW5nZXMoKTtcclxuICAgICAgICB2YXIgYWRhcHRlcnMgPSB0aGlzLl9jb25maWd1cmVkLmFkYXB0ZXJzIHx8IHt9O1xyXG4gICAgICAgIGZvciAodmFyIGFkYXB0ZXIgaW4gYWRhcHRlcnMpIHtcclxuICAgICAgICAgICAgaWYgKGFkYXB0ZXJzW2FkYXB0ZXJdLmdldEFzc2V0Q29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhZGFwdGVyc1thZGFwdGVyXS5nZXRBc3NldENvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuICAgIHNldDogZnVuY3Rpb24oKXt9XHJcbn07XHJcblxyXG5cclxucHJvcGVydGllcy5Bc3NldFByb2dyZXNzTGV2ZWwgPSB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XHJcbiAgICAgICAgdmFyIGFkYXB0ZXJzID0gdGhpcy5fY29uZmlndXJlZC5hZGFwdGVycyB8fCB7fTtcclxuICAgICAgICBmb3IgKHZhciBhZGFwdGVyIGluIGFkYXB0ZXJzKSB7XHJcbiAgICAgICAgICAgIGlmIChhZGFwdGVyc1thZGFwdGVyXS5nZXRBc3NldFByb2dyZXNzTGV2ZWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhZGFwdGVyc1thZGFwdGVyXS5nZXRBc3NldFByb2dyZXNzTGV2ZWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgc2V0OiBmdW5jdGlvbigpe31cclxufTtcclxuXHJcbnByb3BlcnRpZXMueG1sM2RDb21wbGV0ZSA9IHtcclxuICAgIGdldDogZnVuY3Rpb24oKXtcclxuICAgICAgICBYTUwzRC5mbHVzaERPTUNoYW5nZXMoKTtcclxuICAgICAgICB2YXIgYWRhcHRlcnMgPSB0aGlzLl9jb25maWd1cmVkLmFkYXB0ZXJzIHx8IHt9O1xyXG4gICAgICAgIGZvciAodmFyIGFkYXB0ZXIgaW4gYWRhcHRlcnMpIHtcclxuICAgICAgICAgICAgaWYgKGFkYXB0ZXJzW2FkYXB0ZXJdLmdldENvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRhcHRlcnNbYWRhcHRlcl0uZ2V0Q29tcGxldGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgc2V0OiBmdW5jdGlvbigpe31cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcHJvcGVydGllcztcclxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xyXG5cclxuLy8gQWRkaXRpb25hbCBtZXRob2RzIGluIGdsTWF0cml4IHN0eWxlXHJcbiAgICBtYXRoLnZlYzMucmVjaXByb2NhbCA9IGZ1bmN0aW9uIChkZXN0LCB2ZWMpIHtcclxuICAgICAgICBpZiAoIWRlc3QpIHtcclxuICAgICAgICAgICAgZGVzdCA9IHZlYztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRlc3RbMF0gPSAxIC8gdmVjWzBdO1xyXG4gICAgICAgIGRlc3RbMV0gPSAxIC8gdmVjWzFdO1xyXG4gICAgICAgIGRlc3RbMl0gPSAxIC8gdmVjWzJdO1xyXG4gICAgICAgIHJldHVybiBkZXN0O1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgdG9ET01TdHJpbmcgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5qb2luLmNhbGwoZGF0YSwgJyAnKTtcclxuICAgIH07XHJcblxyXG4gICAgbWF0aC52ZWMyLnRvRE9NU3RyaW5nID0gdG9ET01TdHJpbmc7XHJcblxyXG4gICAgbWF0aC52ZWMyLmZyb21ET01TdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICB2YXIgcyA9IHN0ci5zcGxpdCgnICcpO1xyXG4gICAgICAgIGlmIChzLmxlbmd0aCAhPT0gMiB8fCBpc05hTigrc1swXSkgfHwgaXNOYU4oK3NbMV0pKSB7XHJcbiAgICAgICAgICAgIHRocm93IFwiQ291bGQgbm90IHBhcnNlICdcIitzdHIrXCInIGludG8gYSB2YWxpZCB2ZWMyIG9iamVjdFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF0aC52ZWMyLmZyb21WYWx1ZXMoK3NbMF0sICtzWzFdKTtcclxuICAgIH07XHJcblxyXG4gICAgbWF0aC52ZWMzLnRvRE9NU3RyaW5nID0gdG9ET01TdHJpbmc7XHJcblxyXG4gICAgbWF0aC52ZWMzLmZyb21ET01TdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICB2YXIgcyA9IHN0ci5zcGxpdCgnICcpO1xyXG4gICAgICAgIGlmIChzLmxlbmd0aCAhPT0gMyB8fCBpc05hTigrc1swXSkgfHwgaXNOYU4oK3NbMV0pIHx8IGlzTmFOKCtzWzJdKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBcIkNvdWxkIG5vdCBwYXJzZSAnXCIrc3RyK1wiJyBpbnRvIGEgdmFsaWQgdmVjMyBvYmplY3RcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hdGgudmVjMy5mcm9tVmFsdWVzKCtzWzBdLCArc1sxXSwgK3NbMl0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgbWF0aC52ZWM0LnRvRE9NU3RyaW5nID0gdG9ET01TdHJpbmc7XHJcblxyXG4gICAgbWF0aC52ZWM0LmZyb21ET01TdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICB2YXIgcyA9IHN0ci5zcGxpdCgnICcpO1xyXG4gICAgICAgIGlmIChzLmxlbmd0aCAhPT0gNCB8fCBpc05hTigrc1swXSkgfHwgaXNOYU4oK3NbMV0pIHx8IGlzTmFOKCtzWzJdKSB8fCBpc05hTigrc1szXSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgXCJDb3VsZCBub3QgcGFyc2UgJ1wiK3N0citcIicgaW50byBhIHZhbGlkIHZlYzQgb3IgcXVhdCBvYmplY3RcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hdGgudmVjNC5mcm9tVmFsdWVzKCtzWzBdLCArc1sxXSwgK3NbMl0sICtzWzNdKTtcclxuICAgIH07XHJcblxyXG4gICAgbWF0aC5xdWF0LnRvRE9NU3RyaW5nID0gdG9ET01TdHJpbmc7XHJcblxyXG4gICAgbWF0aC5xdWF0LmZyb21ET01TdHJpbmcgPSBtYXRoLnZlYzQuZnJvbURPTVN0cmluZztcclxuXHJcbiAgICBtYXRoLm1hdDMudG9ET01TdHJpbmcgPSB0b0RPTVN0cmluZztcclxuXHJcbiAgICBtYXRoLm1hdDMuZnJvbURPTVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgIHZhciBzID0gc3RyLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgaWYgKHMubGVuZ3RoICE9PSA5KSB7XHJcbiAgICAgICAgICAgIHRocm93IFwiQ291bGQgbm90IHBhcnNlICdcIitzdHIrXCInIGludG8gYSB2YWxpZCBtYXQzIG9iamVjdFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWF0ID0gbWF0aC5tYXQzLmNyZWF0ZSgpO1xyXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTw5OyBpKyspIHtcclxuICAgICAgICAgICAgbWF0W2ldID0gK3NbaV07XHJcbiAgICAgICAgICAgIGlmIChpc05hTihtYXRbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkNvdWxkIG5vdCBwYXJzZSAnXCIrc3RyK1wiJyBpbnRvIGEgdmFsaWQgbWF0MyBvYmplY3RcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF0O1xyXG4gICAgfTtcclxuXHJcbiAgICBtYXRoLm1hdDQudG9ET01TdHJpbmcgPSB0b0RPTVN0cmluZztcclxuXHJcbiAgICBtYXRoLm1hdDQuZnJvbURPTVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgIHZhciBzID0gc3RyLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgaWYgKHMubGVuZ3RoICE9PSAxNikge1xyXG4gICAgICAgICAgICB0aHJvdyBcIkNvdWxkIG5vdCBwYXJzZSAnXCIrc3RyK1wiJyBpbnRvIGEgdmFsaWQgbWF0NCBvYmplY3RcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1hdCA9IG1hdGgubWF0NC5jcmVhdGUoKTtcclxuICAgICAgICBmb3IgKHZhciBpPTA7IGk8MTY7IGkrKykge1xyXG4gICAgICAgICAgICBtYXRbaV0gPSArc1tpXTtcclxuICAgICAgICAgICAgaWYgKGlzTmFOKG1hdFtpXSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiQ291bGQgbm90IHBhcnNlICdcIitzdHIrXCInIGludG8gYSB2YWxpZCBtYXQ0IG9iamVjdFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXQ7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBtYXRoLm1hdDQubXVsdGlwbHlPZmZzZXRWZWMzID0gZnVuY3Rpb24gKG1hdCwgbWF0T2Zmc2V0LCB2ZWMsIHZlY09mZnNldCwgZGVzdCkge1xyXG4gICAgICAgIGlmICghZGVzdCkge1xyXG4gICAgICAgICAgICBkZXN0ID0gdmVjO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXZlY09mZnNldCkge1xyXG4gICAgICAgICAgICB2ZWNPZmZzZXQgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHggPSB2ZWNbdmVjT2Zmc2V0ICsgMF0sIHkgPSB2ZWNbdmVjT2Zmc2V0ICsgMV0sIHogPSB2ZWNbdmVjT2Zmc2V0ICsgMl07XHJcblxyXG4gICAgICAgIGRlc3RbMF0gPSBtYXRbbWF0T2Zmc2V0ICsgMF0gKiB4ICsgbWF0W21hdE9mZnNldCArIDRdICogeSArIG1hdFttYXRPZmZzZXQgKyA4XSAqIHogKyBtYXRbbWF0T2Zmc2V0ICsgMTJdO1xyXG4gICAgICAgIGRlc3RbMV0gPSBtYXRbbWF0T2Zmc2V0ICsgMV0gKiB4ICsgbWF0W21hdE9mZnNldCArIDVdICogeSArIG1hdFttYXRPZmZzZXQgKyA5XSAqIHogKyBtYXRbbWF0T2Zmc2V0ICsgMTNdO1xyXG4gICAgICAgIGRlc3RbMl0gPSBtYXRbbWF0T2Zmc2V0ICsgMl0gKiB4ICsgbWF0W21hdE9mZnNldCArIDZdICogeSArIG1hdFttYXRPZmZzZXQgKyAxMF0gKiB6ICsgbWF0W21hdE9mZnNldCArIDE0XTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRlc3Q7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBtYXRoLm1hdDQubXVsdGlwbHlPZmZzZXREaXJlY3Rpb24gPSBmdW5jdGlvbiAobWF0LCBtYXRPZmZzZXQsIHZlYywgdmVjT2Zmc2V0LCBkZXN0KSB7XHJcbiAgICAgICAgaWYgKCFkZXN0KSB7XHJcbiAgICAgICAgICAgIGRlc3QgPSB2ZWM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdmVjT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHZlY09mZnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgeCA9IHZlY1t2ZWNPZmZzZXQgKyAwXSwgeSA9IHZlY1t2ZWNPZmZzZXQgKyAxXSwgeiA9IHZlY1t2ZWNPZmZzZXQgKyAyXSwgdztcclxuXHJcbiAgICAgICAgZGVzdFswXSA9IG1hdFttYXRPZmZzZXQgKyAwXSAqIHggKyBtYXRbbWF0T2Zmc2V0ICsgNF0gKiB5ICsgbWF0W21hdE9mZnNldCArIDhdICogejtcclxuICAgICAgICBkZXN0WzFdID0gbWF0W21hdE9mZnNldCArIDFdICogeCArIG1hdFttYXRPZmZzZXQgKyA1XSAqIHkgKyBtYXRbbWF0T2Zmc2V0ICsgOV0gKiB6O1xyXG4gICAgICAgIGRlc3RbMl0gPSBtYXRbbWF0T2Zmc2V0ICsgMl0gKiB4ICsgbWF0W21hdE9mZnNldCArIDZdICogeSArIG1hdFttYXRPZmZzZXQgKyAxMF0gKiB6O1xyXG5cclxuICAgICAgICByZXR1cm4gZGVzdDtcclxuICAgIH07XHJcblxyXG4gICAgbWF0aC5tYXQ0Lm11bHRpcGx5T2Zmc2V0ID0gZnVuY3Rpb24gKGRlc3QsIGRlc3RPZmZzZXQsIG1hdCwgb2Zmc2V0MSwgbWF0Miwgb2Zmc2V0Mikge1xyXG4gICAgICAgIHZhciBhMDAgPSBtYXQyW29mZnNldDIgKyAwXSwgYTAxID0gbWF0MltvZmZzZXQyICsgMV0sIGEwMiA9IG1hdDJbb2Zmc2V0MiArIDJdLCBhMDMgPSBtYXQyW29mZnNldDIgKyAzXTtcclxuICAgICAgICB2YXIgYTEwID0gbWF0MltvZmZzZXQyICsgNF0sIGExMSA9IG1hdDJbb2Zmc2V0MiArIDVdLCBhMTIgPSBtYXQyW29mZnNldDIgKyA2XSwgYTEzID0gbWF0MltvZmZzZXQyICsgN107XHJcbiAgICAgICAgdmFyIGEyMCA9IG1hdDJbb2Zmc2V0MiArIDhdLCBhMjEgPSBtYXQyW29mZnNldDIgKyA5XSwgYTIyID0gbWF0MltvZmZzZXQyICsgMTBdLCBhMjMgPSBtYXQyW29mZnNldDIgKyAxMV07XHJcbiAgICAgICAgdmFyIGEzMCA9IG1hdDJbb2Zmc2V0MiArIDEyXSwgYTMxID0gbWF0MltvZmZzZXQyICsgMTNdLCBhMzIgPSBtYXQyW29mZnNldDIgKyAxNF0sIGEzMyA9IG1hdDJbb2Zmc2V0MiArIDE1XTtcclxuXHJcbiAgICAgICAgdmFyIGIwMCA9IG1hdFtvZmZzZXQxICsgMF0sIGIwMSA9IG1hdFtvZmZzZXQxICsgMV0sIGIwMiA9IG1hdFtvZmZzZXQxICsgMl0sIGIwMyA9IG1hdFtvZmZzZXQxICsgM107XHJcbiAgICAgICAgdmFyIGIxMCA9IG1hdFtvZmZzZXQxICsgNF0sIGIxMSA9IG1hdFtvZmZzZXQxICsgNV0sIGIxMiA9IG1hdFtvZmZzZXQxICsgNl0sIGIxMyA9IG1hdFtvZmZzZXQxICsgN107XHJcbiAgICAgICAgdmFyIGIyMCA9IG1hdFtvZmZzZXQxICsgOF0sIGIyMSA9IG1hdFtvZmZzZXQxICsgOV0sIGIyMiA9IG1hdFtvZmZzZXQxICsgMTBdLCBiMjMgPSBtYXRbb2Zmc2V0MSArIDExXTtcclxuICAgICAgICB2YXIgYjMwID0gbWF0W29mZnNldDEgKyAxMl0sIGIzMSA9IG1hdFtvZmZzZXQxICsgMTNdLCBiMzIgPSBtYXRbb2Zmc2V0MSArIDE0XSwgYjMzID0gbWF0W29mZnNldDEgKyAxNV07XHJcblxyXG4gICAgICAgIGRlc3RbZGVzdE9mZnNldCArIDBdID0gYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwICsgYjAzICogYTMwO1xyXG4gICAgICAgIGRlc3RbZGVzdE9mZnNldCArIDFdID0gYjAwICogYTAxICsgYjAxICogYTExICsgYjAyICogYTIxICsgYjAzICogYTMxO1xyXG4gICAgICAgIGRlc3RbZGVzdE9mZnNldCArIDJdID0gYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyICsgYjAzICogYTMyO1xyXG4gICAgICAgIGRlc3RbZGVzdE9mZnNldCArIDNdID0gYjAwICogYTAzICsgYjAxICogYTEzICsgYjAyICogYTIzICsgYjAzICogYTMzO1xyXG4gICAgICAgIGRlc3RbZGVzdE9mZnNldCArIDRdID0gYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwICsgYjEzICogYTMwO1xyXG4gICAgICAgIGRlc3RbZGVzdE9mZnNldCArIDVdID0gYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxICsgYjEzICogYTMxO1xyXG4gICAgICAgIGRlc3RbZGVzdE9mZnNldCArIDZdID0gYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyICsgYjEzICogYTMyO1xyXG4gICAgICAgIGRlc3RbZGVzdE9mZnNldCArIDddID0gYjEwICogYTAzICsgYjExICogYTEzICsgYjEyICogYTIzICsgYjEzICogYTMzO1xyXG4gICAgICAgIGRlc3RbZGVzdE9mZnNldCArIDhdID0gYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwICsgYjIzICogYTMwO1xyXG4gICAgICAgIGRlc3RbZGVzdE9mZnNldCArIDldID0gYjIwICogYTAxICsgYjIxICogYTExICsgYjIyICogYTIxICsgYjIzICogYTMxO1xyXG4gICAgICAgIGRlc3RbZGVzdE9mZnNldCArIDEwXSA9IGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMiArIGIyMyAqIGEzMjtcclxuICAgICAgICBkZXN0W2Rlc3RPZmZzZXQgKyAxMV0gPSBiMjAgKiBhMDMgKyBiMjEgKiBhMTMgKyBiMjIgKiBhMjMgKyBiMjMgKiBhMzM7XHJcbiAgICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgMTJdID0gYjMwICogYTAwICsgYjMxICogYTEwICsgYjMyICogYTIwICsgYjMzICogYTMwO1xyXG4gICAgICAgIGRlc3RbZGVzdE9mZnNldCArIDEzXSA9IGIzMCAqIGEwMSArIGIzMSAqIGExMSArIGIzMiAqIGEyMSArIGIzMyAqIGEzMTtcclxuICAgICAgICBkZXN0W2Rlc3RPZmZzZXQgKyAxNF0gPSBiMzAgKiBhMDIgKyBiMzEgKiBhMTIgKyBiMzIgKiBhMjIgKyBiMzMgKiBhMzI7XHJcbiAgICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgMTVdID0gYjMwICogYTAzICsgYjMxICogYTEzICsgYjMyICogYTIzICsgYjMzICogYTMzO1xyXG4gICAgfTtcclxuXHJcbiAgICBtYXRoLnF1YXQuc2xlcnBPZmZzZXQgPSBmdW5jdGlvbiAocXVhdCwgb2Zmc2V0MSwgcXVhdDIsIG9mZnNldDIsIHQsIGRlc3QsIGRlc3RPZmZzZXQsIHNob3J0ZXN0KSB7XHJcbiAgICAgICAgaWYgKCFkZXN0KSB7XHJcbiAgICAgICAgICAgIGRlc3QgPSBxdWF0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGl4MSA9IG9mZnNldDEsIGl5MSA9IG9mZnNldDEgKyAxLCBpejEgPSBvZmZzZXQxICsgMiwgaXcxID0gb2Zmc2V0MSArIDM7XHJcbiAgICAgICAgdmFyIGl4MiA9IG9mZnNldDIsIGl5MiA9IG9mZnNldDIgKyAxLCBpejIgPSBvZmZzZXQyICsgMiwgaXcyID0gb2Zmc2V0MiArIDM7XHJcbiAgICAgICAgdmFyIGl4ZCA9IGRlc3RPZmZzZXQsIGl5ZCA9IGRlc3RPZmZzZXQgKyAxLCBpemQgPSBkZXN0T2Zmc2V0ICsgMiwgaXdkID0gZGVzdE9mZnNldCArIDM7XHJcblxyXG4gICAgICAgIHZhciBjb3NBbmdsZSA9IHF1YXRbaXgxXSAqIHF1YXQyW2l4Ml0gKyBxdWF0W2l5MV0gKiBxdWF0MltpeTJdICsgcXVhdFtpejFdICogcXVhdDJbaXoyXSArIHF1YXRbaXcxXSAqIHF1YXQyW2l3Ml07XHJcblxyXG4gICAgICAgIHZhciBjMSwgYzI7XHJcblxyXG4gICAgICAgIC8vIExpbmVhciBpbnRlcnBvbGF0aW9uIGZvciBjbG9zZSBvcmllbnRhdGlvbnNcclxuICAgICAgICBpZiAoKDEuMCAtIE1hdGguYWJzKGNvc0FuZ2xlKSkgPCAwLjAxKSB7XHJcbiAgICAgICAgICAgIGMxID0gMS4wIC0gdDtcclxuICAgICAgICAgICAgYzIgPSB0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFNwaGVyaWNhbCBpbnRlcnBvbGF0aW9uXHJcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IE1hdGguYWNvcyhNYXRoLmFicyhjb3NBbmdsZSkpO1xyXG4gICAgICAgICAgICB2YXIgc2luQW5nbGUgPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgICAgIGMxID0gTWF0aC5zaW4oYW5nbGUgKiAoMS4wIC0gdCkpIC8gc2luQW5nbGU7XHJcbiAgICAgICAgICAgIGMyID0gTWF0aC5zaW4oYW5nbGUgKiB0KSAvIHNpbkFuZ2xlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXNlIHRoZSBzaG9ydGVzdCBwYXRoXHJcbiAgICAgICAgaWYgKHNob3J0ZXN0ICYmIChjb3NBbmdsZSA8IDAuMCkpXHJcbiAgICAgICAgICAgIGMxID0gLWMxO1xyXG5cclxuICAgICAgICBkZXN0W2l4ZF0gPSBjMSAqIHF1YXRbaXgxXSArIGMyICogcXVhdDJbaXgyXTtcclxuICAgICAgICBkZXN0W2l5ZF0gPSBjMSAqIHF1YXRbaXkxXSArIGMyICogcXVhdDJbaXkyXTtcclxuICAgICAgICBkZXN0W2l6ZF0gPSBjMSAqIHF1YXRbaXoxXSArIGMyICogcXVhdDJbaXoyXTtcclxuICAgICAgICBkZXN0W2l3ZF0gPSBjMSAqIHF1YXRbaXcxXSArIGMyICogcXVhdDJbaXcyXTtcclxuICAgIH07XHJcblxyXG4gICAgbWF0aC5xdWF0LmZyb21BeGlzQW5nbGUgPSBmdW5jdGlvbihheGlzLCBhbmdsZSkge1xyXG4gICAgICAgIHZhciBxID0gbWF0aC5xdWF0LmNyZWF0ZSgpO1xyXG4gICAgICAgIGlmIChheGlzLmxlbmd0aCA9PT0gNCAmJiBhbmdsZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG1hdGgucXVhdC5zZXRBeGlzQW5nbGUocSwgYXhpcywgYXhpc1szXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWF0aC5xdWF0LnNldEF4aXNBbmdsZShxLCBheGlzLCBhbmdsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXRoLnF1YXQubm9ybWFsaXplKHEscSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cclxuICAgICAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzAnXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICAgICAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gICAgICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gICAgICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gICAgICovXHJcbiAgICBtYXRoLnZlYzMudHJhbnNmb3JtRGlyZWN0aW9uID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XHJcbiAgICAgICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XHJcbiAgICAgICAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeik7XHJcbiAgICAgICAgb3V0WzFdID0gKG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeik7XHJcbiAgICAgICAgb3V0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHopO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG5cclxuICAgIG1hdGgucXVhdC5zZXRGcm9tTWF0MyA9IGZ1bmN0aW9uKGRlc3QsIG0pIHtcclxuICAgICAgICB2YXIgdHIgPSBtWzBdICsgbVs0XSArIG1bOF07XHJcblxyXG4gICAgICAgIGlmICh0ciA+IDApIHtcclxuICAgICAgICAgICAgdmFyIHMgPSBNYXRoLnNxcnQodHIgKyAxLjApICogMjsgLy8gcz00KmRlc3RbM11cclxuICAgICAgICAgICAgZGVzdFswXSA9IChtWzddIC0gbVs1XSkgLyBzO1xyXG4gICAgICAgICAgICBkZXN0WzFdID0gKG1bMl0gLSBtWzZdKSAvIHM7XHJcbiAgICAgICAgICAgIGRlc3RbMl0gPSAobVszXSAtIG1bMV0pIC8gcztcclxuICAgICAgICAgICAgZGVzdFszXSA9IDAuMjUgKiBzO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoKG1bMF0gPiBtWzRdKSAmJiAobVswXSA+IG1bOF0pKSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gTWF0aC5zcXJ0KDEuMCArIG1bMF0gLSBtWzRdIC0gbVs4XSkgKiAyOyAvLyBzPTQqcXhcclxuICAgICAgICAgICAgZGVzdFszXSA9IChtWzddIC0gbVs1XSkgLyBzO1xyXG4gICAgICAgICAgICBkZXN0WzBdID0gMC4yNSAqIHM7XHJcbiAgICAgICAgICAgIGRlc3RbMV0gPSAobVsxXSArIG1bM10pIC8gcztcclxuICAgICAgICAgICAgZGVzdFsyXSA9IChtWzJdICsgbVs2XSkgLyBzO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobVs0XSA+IG1bOF0pIHtcclxuICAgICAgICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoMS4wICsgbVs0XSAtIG1bMF0gLSBtWzhdKSAqIDI7IC8vIHM9NCpxeVxyXG4gICAgICAgICAgICBkZXN0WzNdID0gKG1bMl0gLSBtWzZdKSAvIHM7XHJcbiAgICAgICAgICAgIGRlc3RbMF0gPSAobVsxXSArIG1bM10pIC8gcztcclxuICAgICAgICAgICAgZGVzdFsxXSA9IDAuMjUgKiBzO1xyXG4gICAgICAgICAgICBkZXN0WzJdID0gKG1bNV0gKyBtWzddKSAvIHM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoMS4wICsgbVs4XSAtIG1bMF0gLSBtWzRdKSAqIDI7IC8vIHM9NCpxelxyXG4gICAgICAgICAgICBkZXN0WzNdID0gKG1bM10gLSBtWzFdKSAvIHM7XHJcbiAgICAgICAgICAgIGRlc3RbMF0gPSAobVsyXSArIG1bNl0pIC8gcztcclxuICAgICAgICAgICAgZGVzdFsxXSA9IChtWzVdICsgbVs3XSkgLyBzO1xyXG4gICAgICAgICAgICBkZXN0WzJdID0gMC4yNSAqIHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZXN0O1xyXG4gICAgfTtcclxuXHJcbiAgICBtYXRoLnF1YXQuc2V0RnJvbUJhc2lzID0gZnVuY3Rpb24oZGVzdCwgWCxZLFopIHtcclxuICAgICAgICB2YXIgbHggPSAxLjAgLyBYTUwzRC5tYXRoLnZlYzMubGVuZ3RoKFgpO1xyXG4gICAgICAgIHZhciBseSA9IDEuMCAvIFhNTDNELm1hdGgudmVjMy5sZW5ndGgoWSk7XHJcbiAgICAgICAgdmFyIGx6ID0gMS4wIC8gWE1MM0QubWF0aC52ZWMzLmxlbmd0aChaKTtcclxuICAgICAgICB2YXIgbSA9IFhNTDNELm1hdGgubWF0My5jcmVhdGUoKTtcclxuICAgICAgICBtWzBdID0gWFswXSAqIGx4O1xyXG4gICAgICAgIG1bMV0gPSBZWzBdICogbHk7XHJcbiAgICAgICAgbVsyXSA9IFpbMF0gKiBsejtcclxuICAgICAgICBtWzNdID0gWFsxXSAqIGx4O1xyXG4gICAgICAgIG1bNF0gPSBZWzFdICogbHk7XHJcbiAgICAgICAgbVs1XSA9IFpbMV0gKiBsejtcclxuICAgICAgICBtWzZdID0gWFsyXSAqIGx4O1xyXG4gICAgICAgIG1bN10gPSBZWzJdICogbHk7XHJcbiAgICAgICAgbVs4XSA9IFpbMl0gKiBsejtcclxuICAgICAgICByZXR1cm4gWE1MM0QubWF0aC5xdWF0LnNldEZyb21NYXQzKGRlc3QsIG0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBtYXRoLnZlYzQuZnJvbVF1YXQgPSBmdW5jdGlvbihxKSB7XHJcbiAgICAgICAgdmFyIGRlc3QgPSBYTUwzRC5tYXRoLnZlYzQuY3JlYXRlKCk7XHJcbiAgICAgICAgaWYgKHFbM10gPiAxKSB7XHJcbiAgICAgICAgICAgIFhNTDNELm1hdGgucXVhdC5ub3JtYWxpemUocSxxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoMS1xWzNdKnFbM10pO1xyXG4gICAgICAgIHZhciBhbmdsZSA9IDIqTWF0aC5hY29zKHFbM10pO1xyXG4gICAgICAgIGlmIChzIDwgMC4wMDAxKSB7XHJcbiAgICAgICAgICAgIC8vIEF4aXMgaXMgcHJhY3RpY2FsbHkgMCBzbyB3ZSByZXR1cm4gdGhlIGlkZW50aXR5IGF4aXMgYW5nbGVcclxuICAgICAgICAgICAgZGVzdFswXSA9IDA7XHJcbiAgICAgICAgICAgIGRlc3RbMV0gPSAwO1xyXG4gICAgICAgICAgICBkZXN0WzJdID0gMTtcclxuICAgICAgICAgICAgZGVzdFszXSA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGVzdFswXSA9IHFbMF0gLyBzO1xyXG4gICAgICAgICAgICBkZXN0WzFdID0gcVsxXSAvIHM7XHJcbiAgICAgICAgICAgIGRlc3RbMl0gPSBxWzJdIC8gcztcclxuICAgICAgICAgICAgZGVzdFszXSA9IGFuZ2xlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVzdDtcclxuICAgIH07XHJcblxyXG5cclxufTtcclxuIiwidmFyIE5vZGVBZGFwdGVyID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvYWRhcHRlci5qc1wiKS5Ob2RlQWRhcHRlcjtcclxuXHJcbnZhciBSZW5kZXJBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcclxuICAgIE5vZGVBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhSZW5kZXJBZGFwdGVyLCBOb2RlQWRhcHRlciwge1xyXG5cclxuICAgIGdldFBhcmVudFJlbmRlckFkYXB0ZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mYWN0b3J5LmdldEFkYXB0ZXIodGhpcy5ub2RlLnBhcmVudE5vZGUsIFJlbmRlckFkYXB0ZXIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBlbGVtZW50XHJcbiAgICAgKi9cclxuICAgIGluaXRFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIHRoaXMuZmFjdG9yeS5nZXRBZGFwdGVyKGVsZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuaW5pdENoaWxkRWxlbWVudHMoZWxlbWVudCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XHJcbiAgICAgKi9cclxuICAgIGluaXRDaGlsZEVsZW1lbnRzOiBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIHZhciBjaGlsZCA9IGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQ7XHJcbiAgICAgICAgd2hpbGUgKGNoaWxkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdEVsZW1lbnQoY2hpbGQpO1xyXG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRFbGVtZW50U2libGluZztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjazogZnVuY3Rpb24gKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xyXG4gICAgfSxcclxuXHJcbiAgICBzdHlsZUNoYW5nZWRDYWxsYmFjazogZnVuY3Rpb24gKCkge1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRTY2VuZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZhY3RvcnkucmVuZGVyZXIuc2NlbmU7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJBZGFwdGVyO1xyXG4iLCJ2YXIgUmVuZGVyQWRhcHRlciA9IHJlcXVpcmUoXCIuL2Jhc2UuanNcIik7XHJcblxyXG4vL0FkYXB0ZXIgZm9yIDxkZWZzPlxyXG52YXIgRGVmc1JlbmRlckFkYXB0ZXIgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbm9kZSkge1xyXG4gICAgUmVuZGVyQWRhcHRlci5jYWxsKHRoaXMsIGZhY3RvcnksIG5vZGUpO1xyXG59O1xyXG5YTUwzRC5jcmVhdGVDbGFzcyhEZWZzUmVuZGVyQWRhcHRlciwgUmVuZGVyQWRhcHRlcik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERlZnNSZW5kZXJBZGFwdGVyO1xyXG4iLCJ2YXIgTm9kZUFkYXB0ZXJGYWN0b3J5ID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvYWRhcHRlci5qc1wiKS5Ob2RlQWRhcHRlckZhY3Rvcnk7XHJcblxyXG4vKipcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBpbXBsZW1lbnRzIHtYTUwzRC5iYXNlLklGYWN0b3J5fVxyXG4gKiBAZXh0ZW5kcyBYTUwzRC5iYXNlLk5vZGVBZGFwdGVyRmFjdG9yeVxyXG4gKiBAcGFyYW0ge251bWJlcn0gY2FudmFzSWRcclxuICovXHJcbnZhciBSZW5kZXJBZGFwdGVyRmFjdG9yeSA9IGZ1bmN0aW9uIChjYW52YXNJZCkge1xyXG4gICAgTm9kZUFkYXB0ZXJGYWN0b3J5LmNhbGwodGhpcywgXCJzY2VuZVwiLCBjYW52YXNJZCk7XHJcbiAgICB0aGlzLnR5cGUgPSBcIlJlbmRlckFkYXB0ZXJGYWN0b3J5XCI7XHJcbn07XHJcblhNTDNELmNyZWF0ZUNsYXNzKFJlbmRlckFkYXB0ZXJGYWN0b3J5LCBOb2RlQWRhcHRlckZhY3RvcnkpO1xyXG5cclxudmFyIHJlZ2lzdHJ5ID0ge1xyXG4gICAgICAgIHhtbDNkOiByZXF1aXJlKFwiLi94bWwzZC5qc1wiKSxcclxuICAgICAgICB2aWV3OiByZXF1aXJlKFwiLi92aWV3LmpzXCIpLFxyXG4gICAgICAgIGRlZnM6IHJlcXVpcmUoXCIuL2RlZnMuanNcIiksXHJcbiAgICAgICAgbWVzaDogcmVxdWlyZShcIi4vbWVzaC5qc1wiKSxcclxuICAgICAgICBtb2RlbDogcmVxdWlyZShcIi4vbW9kZWwuanNcIiksXHJcbiAgICAgICAgbWF0ZXJpYWw6IHJlcXVpcmUoXCIuL21hdGVyaWFsLmpzXCIpLFxyXG4gICAgICAgIHNoYWRlcjogcmVxdWlyZShcIi4vbWF0ZXJpYWwuanNcIiksIC8vIFRPRE8oa3NvbnMpOiBSZW1vdmUgaW4gNS4xXHJcbiAgICAgICAgZ3JvdXA6IHJlcXVpcmUoXCIuL2dyb3VwLmpzXCIpLFxyXG4gICAgICAgIGxpZ2h0OiByZXF1aXJlKFwiLi9saWdodC5qc1wiKSxcclxuICAgICAgICBsaWdodHNoYWRlcjogcmVxdWlyZShcIi4vbGlnaHRzaGFkZXIuanNcIikgLy8gVE9ETyhrc29ucyk6IFJlbW92ZSBpbiA1LjFcclxuICAgIH07XHJcblxyXG4vKipcclxuICogQHBhcmFtIG5vZGVcclxuICogQHJldHVybiB7WE1MM0QuYmFzZS5BZGFwdGVyfG51bGx9XHJcbiAqL1xyXG5SZW5kZXJBZGFwdGVyRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlQWRhcHRlciA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICB2YXIgYWRhcHRlckNvbnN0cnVjdG9yID0gcmVnaXN0cnlbbm9kZS5sb2NhbE5hbWVdO1xyXG4gICAgaWYgKGFkYXB0ZXJDb25zdHJ1Y3RvciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBhZGFwdGVyQ29uc3RydWN0b3IodGhpcywgbm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcblJlbmRlckFkYXB0ZXJGYWN0b3J5LnByb3RvdHlwZS5zZXRTY2VuZSA9IGZ1bmN0aW9uIChzY2VuZSkge1xyXG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG59O1xyXG5cclxuUmVuZGVyQWRhcHRlckZhY3RvcnkucHJvdG90eXBlLmdldFNjZW5lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2NlbmU7XHJcbn07XHJcblxyXG5SZW5kZXJBZGFwdGVyRmFjdG9yeS5wcm90b3R5cGUuc2V0UmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIpIHtcclxuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcclxufTtcclxuXHJcblJlbmRlckFkYXB0ZXJGYWN0b3J5LnByb3RvdHlwZS5nZXRSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyO1xyXG59O1xyXG5cclxuLy8gRXhwb3J0XHJcbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyQWRhcHRlckZhY3Rvcnk7XHJcbiIsInZhciBTY2VuZUVsZW1lbnRBZGFwdGVyID0gcmVxdWlyZShcIi4vc2NlbmUtZWxlbWVudC5qc1wiKTtcclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xyXG52YXIgbWF0NCA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikubWF0NDtcclxuXHJcbnZhciBHcm91cFJlbmRlckFkYXB0ZXIgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbm9kZSkge1xyXG4gICAgU2NlbmVFbGVtZW50QWRhcHRlci5jYWxsKHRoaXMsIGZhY3RvcnksIG5vZGUsIHRydWUsIHRydWUpO1xyXG4gICAgdGhpcy5jcmVhdGVSZW5kZXJOb2RlKCk7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhHcm91cFJlbmRlckFkYXB0ZXIsIFNjZW5lRWxlbWVudEFkYXB0ZXIsIHtcclxuXHJcbiAgICBjcmVhdGVSZW5kZXJOb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50UmVuZGVyQWRhcHRlcigpO1xyXG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gcGFyZW50LmdldFJlbmRlck5vZGUgJiYgcGFyZW50LmdldFJlbmRlck5vZGUoKTtcclxuICAgICAgICB0aGlzLnJlbmRlck5vZGUgPSB0aGlzLmdldFNjZW5lKCkuY3JlYXRlUmVuZGVyR3JvdXAoe1xyXG4gICAgICAgICAgICBwYXJlbnQ6IHBhcmVudE5vZGUsIG5hbWU6IHRoaXMubm9kZS5pZFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTG9jYWxNYXRyaXgoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZU1hdGVyaWFsSGFuZGxlcigpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyTm9kZS5zZXRXb3JsZFNwYWNlQm91bmRpbmdCb3gobmV3IFhNTDNELkJveCgpKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyogSW50ZXJmYWNlIG1ldGhvZHMgKi9cclxuICAgIGdldFdvcmxkQm91bmRpbmdCb3g6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYmJveCA9IG5ldyBYTUwzRC5Cb3goKTtcclxuICAgICAgICB0aGlzLnJlbmRlck5vZGUuZ2V0V29ybGRTcGFjZUJvdW5kaW5nQm94KGJib3gpO1xyXG4gICAgICAgIHJldHVybiBiYm94O1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRMb2NhbEJvdW5kaW5nQm94OiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsb2NhbE1hdCA9IG1hdDQuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIGNoaWxkQkIgPSBuZXcgWE1MM0QuQm94KCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBiYm94ID0gbmV3IFhNTDNELkJveCgpO1xyXG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHRoaXMubm9kZS5jaGlsZE5vZGVzLCBmdW5jdGlvbiAoYykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGMuZ2V0TG9jYWxCb3VuZGluZ0JveCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQkIgPSBjLmdldExvY2FsQm91bmRpbmdCb3goKTtcclxuICAgICAgICAgICAgICAgICAgICBiYm94LmV4dGVuZChjaGlsZEJCKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZS5nZXRMb2NhbE1hdHJpeChsb2NhbE1hdCk7XHJcbiAgICAgICAgICAgIGJib3gudHJhbnNmb3JtQXhpc0FsaWduZWQobG9jYWxNYXQpO1xyXG4gICAgICAgICAgICByZXR1cm4gYmJveDtcclxuICAgICAgICB9XHJcbiAgICB9KSgpLFxyXG5cclxuICAgIGdldExvY2FsTWF0cml4OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG0gPSBuZXcgWE1MM0QuTWF0NCgpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyTm9kZS5nZXRMb2NhbE1hdHJpeChtLmRhdGEpO1xyXG4gICAgICAgIHJldHVybiBtO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRXb3JsZE1hdHJpeDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBtID0gbmV3IFhNTDNELk1hdDQoKTtcclxuICAgICAgICB0aGlzLnJlbmRlck5vZGUuZ2V0V29ybGRNYXRyaXgobS5kYXRhKTtcclxuICAgICAgICByZXR1cm4gbTtcclxuICAgIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwUmVuZGVyQWRhcHRlcjtcclxuIiwidmFyIFNjZW5lRWxlbWVudEFkYXB0ZXIgPSByZXF1aXJlKFwiLi9zY2VuZS1lbGVtZW50LmpzXCIpO1xyXG5cclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xyXG52YXIgTGlnaHRDb25maWd1cmF0aW9uID0gcmVxdWlyZShcIi4uL3NjZW5lL2NvbmZpZ3VyYXRpb24uanNcIik7XHJcbnZhciBSZXNvdXJjZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9yZXNvdXJjZVwiKTtcclxuXHJcbnZhciBERUZBVUxUX0xJR0hUX01PREVMID0gXCJ1cm46eG1sM2Q6bGlnaHQ6ZGlyZWN0aW9uYWxcIjtcclxuLyoqXHJcbiAqIEFkYXB0ZXIgZm9yIDxsaWdodD5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7UmVuZGVyQWRhcHRlckZhY3Rvcnl9IGZhY3RvcnlcclxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXHJcbiAqL1xyXG52YXIgTGlnaHRSZW5kZXJBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcclxuICAgIFNjZW5lRWxlbWVudEFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICB0aGlzLmRhdGFBZGFwdGVyID0gUmVzb3VyY2UuZ2V0QWRhcHRlcihub2RlLCBcImRhdGFcIik7XHJcbiAgICB0aGlzLmNyZWF0ZVJlbmRlck5vZGUoKTtcclxufTtcclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKExpZ2h0UmVuZGVyQWRhcHRlciwgU2NlbmVFbGVtZW50QWRhcHRlciwge1xyXG5cclxuICAgIGNyZWF0ZVJlbmRlck5vZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGFyZW50QWRhcHRlciA9IHRoaXMuZ2V0UGFyZW50UmVuZGVyQWRhcHRlcigpO1xyXG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gcGFyZW50QWRhcHRlci5nZXRSZW5kZXJOb2RlICYmIHBhcmVudEFkYXB0ZXIuZ2V0UmVuZGVyTm9kZSgpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyTm9kZSA9IHRoaXMuZmFjdG9yeS5nZXRTY2VuZSgpLmNyZWF0ZVJlbmRlckxpZ2h0KHtcclxuICAgICAgICAgICAgY29uZmlndXJhdGlvbjogdGhpcy5jcmVhdGVMaWdodENvbmZpZ3VyYXRpb24oKSxcclxuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnROb2RlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjazogZnVuY3Rpb24gKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xyXG4gICAgICAgIFNjZW5lRWxlbWVudEFkYXB0ZXIucHJvdG90eXBlLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjay5jYWxsKHRoaXMsIG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSk7XHJcblxyXG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiaW50ZW5zaXR5XCI6IC8vIFRPRE8oa3NvbnMpOiByZW1vdmUgaW4gNS4xXHJcbiAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiVGhlIDxsaWdodD4gYXR0cmlidXRlIGludGVuc2l0eSBpcyBkZXByZWNhdGVkIGluIFhNTDNEIDUuMC5cIiwgdGhpcy5ub2RlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibW9kZWxcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlUmVuZGVyTm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVWaXNpYmlsaXR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5vbmUgPSB0aGlzLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJkaXNwbGF5XCIpLnRyaW0oKSA9PSBcIm5vbmVcIjtcclxuICAgICAgICB0aGlzLnJlbmRlck5vZGUuc2V0TG9jYWxWaXNpYmxlKCFub25lKTtcclxuICAgIH0sXHJcblxyXG5cclxuICAgIG5vdGlmeUNoYW5nZWQ6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICBzd2l0Y2ggKGV2dC50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgRXZlbnRzLk5PREVfUkVNT1ZFRDpcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgY2FzZSBFdmVudHMuVEhJU19SRU1PVkVEOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVMaWdodENvbmZpZ3VyYXRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm5vZGUuaGFzQXR0cmlidXRlKFwibW9kZWxcIikgPyB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKFwibW9kZWxcIikgOiBERUZBVUxUX0xJR0hUX01PREVMO1xyXG4gICAgICAgIHZhciBvcHQgPSB7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubm9kZS5pZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaWdodENvbmZpZ3VyYXRpb24obW9kZWwsIHRoaXMuZGF0YUFkYXB0ZXIuZ2V0WGZsb3dOb2RlKCksIG9wdCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmdldFJlbmRlck5vZGUoKS5yZW1vdmUoKTtcclxuICAgICAgICB0aGlzLmNsZWFyQWRhcHRlckhhbmRsZXMoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtYTUwzRC5NYXQ0fVxyXG4gICAgICovXHJcbiAgICBnZXRXb3JsZE1hdHJpeDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBtID0gbmV3IFhNTDNELk1hdDQoKTtcclxuICAgICAgICB0aGlzLnJlbmRlck5vZGUuZ2V0V29ybGRNYXRyaXgobS5kYXRhKTtcclxuICAgICAgICByZXR1cm4gbTtcclxuICAgIH1cclxufSk7XHJcblxyXG4vLyBFeHBvcnRcclxubW9kdWxlLmV4cG9ydHMgPSBMaWdodFJlbmRlckFkYXB0ZXI7XHJcblxyXG4iLCJ2YXIgUmVuZGVyQWRhcHRlciA9IHJlcXVpcmUoXCIuL2Jhc2UuanNcIik7XHJcblxyXG4vKipcclxuICogQWRhcHRlciBmb3IgPGxpZ2h0c2hhZGVyPlxyXG4gKiBUT0RPKGtzb25zKTogUmVtb3ZlIGluIDUuMVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtSZW5kZXJBZGFwdGVyRmFjdG9yeX0gZmFjdG9yeVxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcclxuICogQGV4dGVuZHMgUmVuZGVyQWRhcHRlclxyXG4gKi9cclxudmFyIExpZ2h0U2hhZGVyUmVuZGVyQWRhcHRlciA9IGZ1bmN0aW9uIChmYWN0b3J5LCBub2RlKSB7XHJcbiAgICBSZW5kZXJBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XHJcbiAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiVGhlIDxsaWdodHNoYWRlcj4gZWxlbWVudCBpcyBkZXByZWNhdGVkIGluIFhNTDNEIDUuMC5cIiwgbm9kZSk7XHJcbn07XHJcblxyXG4vLyBFeHBvcnRcclxubW9kdWxlLmV4cG9ydHMgPSBMaWdodFNoYWRlclJlbmRlckFkYXB0ZXI7XHJcblxyXG4iLCJ2YXIgUmVuZGVyQWRhcHRlciA9IHJlcXVpcmUoXCIuL2Jhc2UuanNcIik7XHJcbnZhciBFdmVudHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vaW50ZXJmYWNlL25vdGlmaWNhdGlvbi5qc1wiKTtcclxudmFyIFVSSSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy91cmkuanNcIikuVVJJO1xyXG52YXIgQWRhcHRlckhhbmRsZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL2FkYXB0ZXJoYW5kbGUuanNcIik7XHJcbnZhciBSZXNvdXJjZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9yZXNvdXJjZVwiKTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gZmFjdG9yeVxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcclxuICogQGV4dGVuZHMgUmVuZGVyQWRhcHRlclxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBNYXRlcmlhbFJlbmRlckFkYXB0ZXIgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbm9kZSkge1xyXG4gICAgUmVuZGVyQWRhcHRlci5jYWxsKHRoaXMsIGZhY3RvcnksIG5vZGUpO1xyXG4gICAgdGhpcy5fZGF0YUFkYXB0ZXIgPSBSZXNvdXJjZS5nZXRBZGFwdGVyKG5vZGUsIFwiZGF0YVwiKTtcclxuICAgIC8qKiBAdHlwZSBNYXRlcmlhbENvbmZpZ3VyYXRpb24gfCBudWxsICoqL1xyXG4gICAgdGhpcy5fbWF0ZXJpYWxDb25maWd1cmF0aW9uID0gbnVsbDtcclxuICAgIHRoaXMuX21hdGVyaWFsTW9kZWwgPSBudWxsO1xyXG5cclxuICAgIHRoaXMudXBkYXRlTWF0ZXJpYWxDb25maWd1cmF0aW9uKCk7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhNYXRlcmlhbFJlbmRlckFkYXB0ZXIsIFJlbmRlckFkYXB0ZXIsICB7XHJcblxyXG4gICAgZ2V0TWF0ZXJpYWxDb25maWd1cmF0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWF0ZXJpYWxDb25maWd1cmF0aW9uO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVNYXRlcmlhbENvbmZpZ3VyYXRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBGaXJzdCBmaW5kIHRoZSBtb2RlbFxyXG4gICAgICAgIHRoaXMudXBkYXRlTWF0ZXJpYWxNb2RlbCgpO1xyXG4gICAgICAgIGlmICghdGhpcy5fbWF0ZXJpYWxNb2RlbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXRlcmlhbENvbmZpZ3VyYXRpb24gPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hdGVyaWFsQ29uZmlndXJhdGlvbiA9IHRoaXMuZ2V0U2NlbmUoKS5jcmVhdGVNYXRlcmlhbENvbmZpZ3VyYXRpb24odGhpcy5fbWF0ZXJpYWxNb2RlbCwgdGhpcy5fZGF0YUFkYXB0ZXIuZ2V0WGZsb3dOb2RlKCksIHtuYW1lOiB0aGlzLm5vZGUuaWR9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ub3RpZnlPcHBvc2l0ZUFkYXB0ZXJzKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZU1hdGVyaWFsTW9kZWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9tYXRlcmlhbE1vZGVsID0gbnVsbDtcclxuXHJcbiAgICAgICAgdmFyIHVyaSA9IHRoaXMuZ2V0TWF0ZXJpYWxNb2RlbCgpO1xyXG4gICAgICAgIGlmICh1cmkuc2NoZW1lID09IFwidXJuXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0QWRhcHRlckhhbmRsZShcIm1vZGVsXCIpO1xyXG4gICAgICAgICAgICB0aGlzLl9tYXRlcmlhbE1vZGVsID0geyBcInR5cGVcIjogXCJ1cm5cIiwgXCJ1cm5cIjogdXJpIH07XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY29ubmVjdEFkYXB0ZXJIYW5kbGUoXCJtb2RlbFwiLCB0aGlzLmdldEFkYXB0ZXJIYW5kbGUodXJpLCBcImRhdGFcIiwgMCkpO1xyXG4gICAgICAgIHZhciBhZGFwdGVyID0gdGhpcy5nZXRDb25uZWN0ZWRBZGFwdGVyKFwibW9kZWxcIik7XHJcbiAgICAgICAgaWYgKGFkYXB0ZXIgJiYgYWRhcHRlci5nZXRTY3JpcHRUeXBlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hdGVyaWFsTW9kZWwgPSB7IHR5cGU6IGFkYXB0ZXIuZ2V0U2NyaXB0VHlwZSgpLCBzY3JpcHQ6IGFkYXB0ZXIuZ2V0U2NyaXB0KCkgfTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGdldE1hdGVyaWFsTW9kZWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFVSSSh0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKFwibW9kZWxcIikpO1xyXG4gICAgfSxcclxuXHJcbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IGZ1bmN0aW9uIChuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcclxuICAgICAgICBpZiAobmFtZSA9PSBcIm1vZGVsXCIpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVNYXRlcmlhbENvbmZpZ3VyYXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG5vdGlmeUNoYW5nZWQ6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICBzd2l0Y2ggKGV2dC50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgRXZlbnRzLkFEQVBURVJfSEFORExFX0NIQU5HRUQ6XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZ0LmhhbmRsZVN0YXR1cyA9PSBBZGFwdGVySGFuZGxlLlNUQVRVUy5OT1RfRk9VTkQpIHtcclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNvdWxkIG5vdCBmaW5kIG1hdGVyaWFsIGZvciB1cmwgJ1wiICsgZXZ0LnVybCArIFwiJ1wiKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU1hdGVyaWFsQ29uZmlndXJhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbi8vIEV4cG9ydFxyXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGVyaWFsUmVuZGVyQWRhcHRlcjtcclxuXHJcbiIsInZhciBTY2VuZUVsZW1lbnRBZGFwdGVyID0gcmVxdWlyZShcIi4vc2NlbmUtZWxlbWVudC5qc1wiKTtcclxuXHJcbnZhciBFdmVudHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vaW50ZXJmYWNlL25vdGlmaWNhdGlvbi5qc1wiKTtcclxudmFyIGVuY29kZVpJbmRleCA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9taXNjLmpzXCIpLmVuY29kZVpJbmRleDtcclxudmFyIFJlc291cmNlID0gcmVxdWlyZShcIi4uLy4uLy4uL3Jlc291cmNlXCIpO1xyXG5cclxudmFyIERFRkFVTFRfUFJJTUlUSVZFX1RZUEUgPSBcInRyaWFuZ2xlc1wiO1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIE1lc2hSZW5kZXJBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcclxuICAgIFNjZW5lRWxlbWVudEFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlLCB0cnVlLCB0cnVlKTtcclxuICAgIHRoaXMuY3JlYXRlUmVuZGVyTm9kZSgpO1xyXG59O1xyXG5cclxuWE1MM0QuY3JlYXRlQ2xhc3MoTWVzaFJlbmRlckFkYXB0ZXIsIFNjZW5lRWxlbWVudEFkYXB0ZXIsIHtcclxuXHJcbiAgICBjcmVhdGVSZW5kZXJOb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50UmVuZGVyQWRhcHRlcigpO1xyXG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gcGFyZW50LmdldFJlbmRlck5vZGUgJiYgcGFyZW50LmdldFJlbmRlck5vZGUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZW5kZXJOb2RlID0gdGhpcy5nZXRTY2VuZSgpLmNyZWF0ZVJlbmRlck9iamVjdCh7XHJcbiAgICAgICAgICAgIHBhcmVudDogcGFyZW50Tm9kZSxcclxuICAgICAgICAgICAgbm9kZTogdGhpcy5ub2RlLFxyXG4gICAgICAgICAgICBjb25maWd1cmF0aW9uOiB0aGlzLmNyZWF0ZU1lc2hDb25maWd1cmF0aW9uKCksXHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubm9kZS5pZFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMudXBkYXRlWkluZGV4KCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVMb2NhbE1hdHJpeCgpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTWF0ZXJpYWxIYW5kbGVyKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZU1lc2hDb25maWd1cmF0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YTogUmVzb3VyY2UuZ2V0QWRhcHRlcih0aGlzLm5vZGUsIFwiZGF0YVwiKS5nZXRYZmxvd05vZGUoKSxcclxuICAgICAgICAgICAgdHlwZTogdGhpcy5ub2RlLmhhc0F0dHJpYnV0ZShcInR5cGVcIikgPyB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSA6IERFRkFVTFRfUFJJTUlUSVZFX1RZUEVcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjazogZnVuY3Rpb24gKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xyXG4gICAgICAgIFNjZW5lRWxlbWVudEFkYXB0ZXIucHJvdG90eXBlLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjay5jYWxsKHRoaXMsIG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSk7XHJcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJ0eXBlXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVJlbmRlck5vZGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVpJbmRleDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHpJbmRleCA9IHRoaXMuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcInotaW5kZXhcIik7XHJcbiAgICAgICAgekluZGV4ID0gZW5jb2RlWkluZGV4KHpJbmRleCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudFJlbmRlckFkYXB0ZXIoKTtcclxuICAgICAgICB3aGlsZSAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQuc3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRaID0gcGFyZW50LnN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJ6LWluZGV4XCIpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50WiA9IGVuY29kZVpJbmRleChwYXJlbnRaLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50WiAhPSBcIlwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleCA9IHBhcmVudFogKyBcIjpcIiArIHpJbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50UmVuZGVyQWRhcHRlcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5yZW5kZXJOb2RlLnNldFpJbmRleCh6SW5kZXgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7RXZlbnRzLk5vdGlmaWNhdGlvbn0gZXZ0XHJcbiAgICAgKi9cclxuICAgIG5vdGlmeUNoYW5nZWQ6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICBTY2VuZUVsZW1lbnRBZGFwdGVyLnByb3RvdHlwZS5ub3RpZnlDaGFuZ2VkLmNhbGwodGhpcywgZXZ0KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gSW50ZXJmYWNlIG1ldGhvZHNcclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4ge1hNTDNELkJveH1cclxuICAgICAqL1xyXG4gICAgZ2V0TG9jYWxCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBiYm94ID0gbmV3IFhNTDNELkJveCgpO1xyXG4gICAgICAgIGlmICh0aGlzLnJlbmRlck5vZGUgJiYgdGhpcy5yZW5kZXJOb2RlLnZpc2libGUpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlLmdldE9iamVjdFNwYWNlQm91bmRpbmdCb3goYmJveCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiYm94O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4ge1hNTDNELkJveH1cclxuICAgICAqL1xyXG4gICAgZ2V0V29ybGRCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBiYm94ID0gbmV3IFhNTDNELkJveCgpO1xyXG4gICAgICAgIGlmICh0aGlzLnJlbmRlck5vZGUgJiYgdGhpcy5yZW5kZXJOb2RlLnZpc2libGUpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlLmdldFdvcmxkU3BhY2VCb3VuZGluZ0JveChiYm94KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJib3g7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7bWF0NH1cclxuICAgICAqL1xyXG4gICAgZ2V0V29ybGRNYXRyaXg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbSA9IG5ldyBYTUwzRC5NYXQ0KCksIG9iaiA9IHRoaXMucmVuZGVyTm9kZTtcclxuICAgICAgICBpZiAob2JqKSB7XHJcbiAgICAgICAgICAgIG9iai5nZXRXb3JsZE1hdHJpeChtLmRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbTtcclxuICAgIH1cclxufSk7XHJcblxyXG4vLyBFeHBvcnRcclxubW9kdWxlLmV4cG9ydHMgPSBNZXNoUmVuZGVyQWRhcHRlcjtcclxuXHJcbiIsInZhciBTY2VuZUVsZW1lbnRBZGFwdGVyID0gcmVxdWlyZShcIi4vc2NlbmUtZWxlbWVudC5qc1wiKTtcclxudmFyIENvbXB1dGVSZXF1ZXN0ID0gcmVxdWlyZShcIi4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9yZXF1ZXN0LmpzXCIpLkNvbXB1dGVSZXF1ZXN0O1xyXG52YXIgRXZlbnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZS9ub3RpZmljYXRpb24uanNcIik7XHJcbnZhciBBZGFwdGVySGFuZGxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvYWRhcHRlcmhhbmRsZS5qc1wiKTtcclxudmFyIGVuY29kZVpJbmRleCA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9taXNjLmpzXCIpLmVuY29kZVpJbmRleDtcclxudmFyIG1hdDQgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLm1hdDQ7XHJcbnZhciBSZXNvdXJjZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9yZXNvdXJjZVwiKTtcclxuXHJcblxyXG52YXIgTW9kZWxSZW5kZXJBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcclxuICAgIFNjZW5lRWxlbWVudEFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICB0aGlzLmFzc2V0ID0gbnVsbDtcclxuICAgIHRoaXMucG9zdFRyYW5zZm9ybVhmbG93UmVxdWVzdHMgPSBbXTtcclxuICAgIHRoaXMucG9zdFRyYW5zZm9ybVJlbmRlckdyb3VwcyA9IFtdO1xyXG4gICAgdGhpcy5jcmVhdGVSZW5kZXJOb2RlKCk7XHJcbiAgICB0aGlzLl9iaW5kZWRSZXF1ZXN0Q2FsbGJhY2sgPSB0aGlzLm9uWGZsb3dSZXF1ZXN0Q2hhbmdlLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLnRyYW5zZm9ybUZldGNoZXIudXBkYXRlKCk7XHJcbn07XHJcblxyXG52YXIgY19JREVOVElUWSA9IG1hdDQuY3JlYXRlKCk7XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhNb2RlbFJlbmRlckFkYXB0ZXIsIFNjZW5lRWxlbWVudEFkYXB0ZXIsIHtcclxuXHJcbiAgICBjcmVhdGVSZW5kZXJOb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRhdGFBZGFwdGVyID0gUmVzb3VyY2UuZ2V0QWRhcHRlcih0aGlzLm5vZGUsIFwiZGF0YVwiKTtcclxuICAgICAgICB0aGlzLmFzc2V0ID0gZGF0YUFkYXB0ZXIuZ2V0QXNzZXQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5hc3NldC5hZGRDaGFuZ2VMaXN0ZW5lcih0aGlzKTtcclxuXHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50UmVuZGVyQWRhcHRlcigpO1xyXG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gcGFyZW50LmdldFJlbmRlck5vZGUgJiYgcGFyZW50LmdldFJlbmRlck5vZGUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZW5kZXJOb2RlID0gdGhpcy5nZXRTY2VuZSgpLmNyZWF0ZVJlbmRlckdyb3VwKHtcclxuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnROb2RlLCBuYW1lOiB0aGlzLm5vZGUuaWRcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnJlbmRlck5vZGUuc2V0TG9jYWxNYXRyaXgoY19JREVOVElUWSk7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVNb2RlbFJlbmRlck5vZGVzKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNsZWFyTW9kZWxSZW5kZXJOb2RlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXJBZGFwdGVySGFuZGxlcygpO1xyXG4gICAgICAgIHRoaXMuX3N1YlJlbmRlck5vZGVzID0gW107XHJcbiAgICAgICAgdmFyIGkgPSB0aGlzLnBvc3RUcmFuc2Zvcm1YZmxvd1JlcXVlc3RzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zdFRyYW5zZm9ybVhmbG93UmVxdWVzdHNbaV0uY2xlYXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVjX3JlbW92ZVJlbmRlck5vZGVzKHRoaXMucmVuZGVyTm9kZSwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5wb3N0VHJhbnNmb3JtWGZsb3dSZXF1ZXN0cy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMucG9zdFRyYW5zZm9ybVJlbmRlckdyb3Vwcy5sZW5ndGggPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVNb2RlbFJlbmRlck5vZGVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhck1vZGVsUmVuZGVyTm9kZXMoKTtcclxuICAgICAgICBpZiAoIXRoaXMuYXNzZXQuaXNTdWJ0cmVlTG9hZGluZygpKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFzc2V0LmNoZWNrVmFsaWRpdHkoKTtcclxuICAgICAgICAgICAgICAgIHZhciBhc3NldFJlc3VsdCA9IHRoaXMuYXNzZXQuZ2V0UmVzdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVRyZWUgPSBhc3NldFJlc3VsdC5nZXREYXRhVHJlZSgpO1xyXG4gICAgICAgICAgICAgICAgcmVjX2NyZWF0ZVJlbmRlck5vZGVzKHRoaXMsIHRoaXMucmVuZGVyTm9kZSwgZGF0YVRyZWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVaSW5kZXgoKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJBc3NldCBFcnJvcjogXCIgKyBlLm1lc3NhZ2UsIGUubm9kZSB8fCB0aGlzLm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhck1vZGVsUmVuZGVyTm9kZXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0TWF0ZXJpYWxDb25maWd1cmF0aW9uOiBmdW5jdGlvbiAobWF0ZXJpYWxVUkksIGluZGV4KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgaWYgKG1hdGVyaWFsVVJJKSB7XHJcbiAgICAgICAgICAgIHZhciBhZGFwdGVySGFuZGxlID0gdGhpcy5nZXRBZGFwdGVySGFuZGxlKG1hdGVyaWFsVVJJKTtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0QWRhcHRlckhhbmRsZShcIm1hdGVyaWFsX1wiICsgaW5kZXgsIGFkYXB0ZXJIYW5kbGUpO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoIChhZGFwdGVySGFuZGxlLnN0YXR1cykge1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgQWRhcHRlckhhbmRsZS5TVEFUVVMuTk9UX0ZPVU5EOlxyXG4gICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiQ291bGQgbm90IGZpbmQgPG1hdGVyaWFsPiBvZiB1cmwgJ1wiICsgYWRhcHRlckhhbmRsZS51cmwgKyBcIicgXCIsIHRoaXMubm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFkYXB0ZXJIYW5kbGUuU1RBVFVTLlJFQURZOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhZGFwdGVyID0gYWRhcHRlckhhbmRsZS5nZXRBZGFwdGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkYXB0ZXIgJiYgYWRhcHRlci5nZXRNYXRlcmlhbENvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYWRhcHRlci5nZXRNYXRlcmlhbENvbmZpZ3VyYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEFkYXB0ZXJIYW5kbGUuU1RBVFVTLkxPQURJTkc6XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVZpc2liaWxpdHk6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBub25lID0gdGhpcy5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiZGlzcGxheVwiKS50cmltKCkgPT0gXCJub25lXCI7XHJcbiAgICAgICAgdmFyIGhpZGRlbiAgPSB0aGlzLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJ2aXNpYmlsaXR5XCIpLnRyaW0oKSA9PSBcImhpZGRlblwiO1xyXG4gICAgICAgIHZhciB2aXNpYmxlID0gIShub25lIHx8IGhpZGRlbik7XHJcbiAgICAgICAgdmFyIHByb3BhZ2F0ZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUuc2V0TG9jYWxWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgbm9kZS5zZXRMb2NhbFZpc2libGUodmlzaWJsZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKHByb3BhZ2F0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHByb3BhZ2F0ZSh0aGlzLnJlbmRlck5vZGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVaSW5kZXg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB6SW5kZXggPSB0aGlzLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJ6LWluZGV4XCIpO1xyXG4gICAgICAgIHpJbmRleCA9IGVuY29kZVpJbmRleCh6SW5kZXgsIHRydWUpO1xyXG5cclxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnRSZW5kZXJBZGFwdGVyKCk7XHJcbiAgICAgICAgd2hpbGUgKHBhcmVudCkge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50LnN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50WiA9IHBhcmVudC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiei1pbmRleFwiKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudFogPSBlbmNvZGVaSW5kZXgocGFyZW50WiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudFogIT0gXCJcIilcclxuICAgICAgICAgICAgICAgICAgICB6SW5kZXggPSBwYXJlbnRaICsgXCI6XCIgKyB6SW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudFJlbmRlckFkYXB0ZXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBwcm9wYWdhdGUgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLnNldFpJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5zZXRaSW5kZXgoekluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKHByb3BhZ2F0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHByb3BhZ2F0ZSh0aGlzLnJlbmRlck5vZGUpO1xyXG4gICAgfSxcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZXZ0XHJcbiAgICAgKi9cclxuICAgIG5vdGlmeUNoYW5nZWQ6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICBTY2VuZUVsZW1lbnRBZGFwdGVyLnByb3RvdHlwZS5ub3RpZnlDaGFuZ2VkLmNhbGwodGhpcywgZXZ0KTtcclxuICAgICAgICBzd2l0Y2ggKGV2dC50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgRXZlbnRzLkFEQVBURVJfSEFORExFX0NIQU5HRUQ6XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BsaXRzID0gZXZ0LmtleS5zcGxpdChcIl9cIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3BsaXRzWzBdID09IFwibWF0ZXJpYWxcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZW5kZXJOb2RlSWQgPSArc3BsaXRzWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGlkZW50aWZ5IHRoZSBjb3JyZXNwb25kaW5nIHJlbmRlcm5vZGUgYnkgdGhlIGhhbmRsZXIga2V5XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgdGhhdCBzaG91bGQgYmUgcmVtb3ZlZCBpZiB0aGVyZSBhcmVcclxuICAgICAgICAgICAgICAgICAgICAvLyBjdXN0b20gY2FsbGJhY2tzIGZvclxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZW5kZXJOb2RlID0gdGhpcy5fc3ViUmVuZGVyTm9kZXNbcmVuZGVyTm9kZUlkXTtcclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5hc3NlcnQocmVuZGVyTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2dC5oYW5kbGVTdGF0dXMgPT0gQWRhcHRlckhhbmRsZS5TVEFUVVMuTk9UX0ZPVU5EKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlck5vZGUuc2V0TWF0ZXJpYWwobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkYXB0ZXIgPSBldnQuYWRhcHRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkYXB0ZXIgJiYgYWRhcHRlci5nZXRNYXRlcmlhbENvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlck5vZGUuc2V0TWF0ZXJpYWwoYWRhcHRlci5nZXRNYXRlcmlhbENvbmZpZ3VyYXRpb24oKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWN0b3J5LnJlbmRlcmVyLnJlcXVlc3RSZWRyYXcoXCJNYXRlcmlhbCBtb2RlbCBjaGFuZ2VkLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG9uQXNzZXRDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgaWYgKCF0aGlzLnJlbmRlck5vZGUpIHtcclxuICAgICAgICAgICAgLy9UaGlzIG1vZGVsIGhhc24ndCBldmVuIGJlZW4gaW5pdGlhbGl6ZWQgeWV0IHNvIHdlIGRlZmVyIGJ1aWxkaW5nIHRoZSByZW5kZXIgbm9kZXMgdG8gdGhhdCBzdGVwXHJcbiAgICAgICAgICAgIC8vVGhpcyBjYW4gaGFwcGVuIGZvciBleC4gd2hlbiBjaGFuZ2luZyB0aGUgXCJzcmNcIiBhdHRyaWJ1dGUgYmVmb3JlIHRoZSBtb2RlbCBpcyBhcHBlbmRlZCBpbnRvIHRoZSBET01cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jcmVhdGVNb2RlbFJlbmRlck5vZGVzKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uWGZsb3dSZXF1ZXN0Q2hhbmdlOiBmdW5jdGlvbiAocmVxdWVzdCkge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMucG9zdFRyYW5zZm9ybVhmbG93UmVxdWVzdHMuaW5kZXhPZihyZXF1ZXN0KTtcclxuICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVQb3N0VHJhbnNmb3JtKHRoaXMucG9zdFRyYW5zZm9ybVJlbmRlckdyb3Vwc1tpbmRleF0sIHJlcXVlc3QpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlUG9zdFRyYW5zZm9ybTogZnVuY3Rpb24gKHJlbmRlck5vZGUsIHhmbG93UmVxdWVzdCkge1xyXG4gICAgICAgIHZhciBkYXRhUmVzdWx0ID0geGZsb3dSZXF1ZXN0LmdldFJlc3VsdCgpO1xyXG4gICAgICAgIHZhciB0cmFuc2Zvcm1EYXRhID0gKGRhdGFSZXN1bHQuZ2V0T3V0cHV0RGF0YShcInRyYW5zZm9ybVwiKSAmJiBkYXRhUmVzdWx0LmdldE91dHB1dERhdGEoXCJ0cmFuc2Zvcm1cIikuZ2V0VmFsdWUoKSk7XHJcbiAgICAgICAgaWYgKCF0cmFuc2Zvcm1EYXRhKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJQb3N0IFRyYW5zZm9ybSBlbnRyeSBkb2VzIG5vdCBjb250YWluIGFueSAndHJhbnNmb3JtJyB2YWx1ZS5cIiwgdGhpcy5ub2RlKTtcclxuICAgICAgICAgICAgcmVuZGVyTm9kZS5zZXRMb2NhbE1hdHJpeChjX0lERU5USVRZKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXJOb2RlLnNldExvY2FsTWF0cml4KHRyYW5zZm9ybURhdGEpO1xyXG4gICAgfSxcclxuXHJcbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5hc3NldC5yZW1vdmVDaGFuZ2VMaXN0ZW5lcih0aGlzKTtcclxuICAgICAgICB0aGlzLmNsZWFyTW9kZWxSZW5kZXJOb2RlcygpO1xyXG4gICAgICAgIHRoaXMuZ2V0UmVuZGVyTm9kZSgpLnJlbW92ZSgpO1xyXG4gICAgICAgIHRoaXMuY2xlYXJBZGFwdGVySGFuZGxlcygpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIHJlY19yZW1vdmVSZW5kZXJOb2Rlcyhub2RlLCBrZWVwQ3VycmVudE5vZGUpIHtcclxuICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICgha2VlcEN1cnJlbnROb2RlKVxyXG4gICAgICAgIG5vZGUucmVtb3ZlKCk7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XHJcbiAgICB2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICByZWNfcmVtb3ZlUmVuZGVyTm9kZXMoY2hpbGRyZW5baV0sIGZhbHNlKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVjX2NyZWF0ZVJlbmRlck5vZGVzKGFkYXB0ZXIsIHBhcmVudE5vZGUsIGRhdGFUcmVlTm9kZSkge1xyXG5cclxuICAgIGlmIChkYXRhVHJlZU5vZGUucG9zdFRyYW5zZm9ybVhmbG93Tm9kZSkge1xyXG4gICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IENvbXB1dGVSZXF1ZXN0KGRhdGFUcmVlTm9kZS5wb3N0VHJhbnNmb3JtWGZsb3dOb2RlLCBbXCJ0cmFuc2Zvcm1cIl0sIGFkYXB0ZXIuX2JpbmRlZFJlcXVlc3RDYWxsYmFjayk7XHJcbiAgICAgICAgcGFyZW50Tm9kZSA9IGFkYXB0ZXIuZ2V0U2NlbmUoKS5jcmVhdGVSZW5kZXJHcm91cCh7XHJcbiAgICAgICAgICAgIHBhcmVudDogcGFyZW50Tm9kZSwgdmlzaWJsZTogdHJ1ZSwgbmFtZTogdW5kZWZpbmVkXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWRhcHRlci5wb3N0VHJhbnNmb3JtWGZsb3dSZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xyXG4gICAgICAgIGFkYXB0ZXIucG9zdFRyYW5zZm9ybVJlbmRlckdyb3Vwcy5wdXNoKHBhcmVudE5vZGUpO1xyXG4gICAgICAgIGFkYXB0ZXIudXBkYXRlUG9zdFRyYW5zZm9ybShwYXJlbnROb2RlLCByZXF1ZXN0KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZ3JvdXBOb2RlID0gYWRhcHRlci5nZXRTY2VuZSgpLmNyZWF0ZVJlbmRlckdyb3VwKHtcclxuICAgICAgICBwYXJlbnQ6IHBhcmVudE5vZGUsXHJcbiAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICBuYW1lOiBhZGFwdGVyLm5vZGUuaWRcclxuICAgIH0pO1xyXG4gICAgZ3JvdXBOb2RlLnNldExvY2FsTWF0cml4KGRhdGFUcmVlTm9kZS50cmFuc2Zvcm0gfHwgY19JREVOVElUWSk7XHJcbiAgICBncm91cE5vZGUuc2V0TWF0ZXJpYWwoYWRhcHRlci5nZXRNYXRlcmlhbENvbmZpZ3VyYXRpb24oZGF0YVRyZWVOb2RlLm1hdGVyaWFsLCBhZGFwdGVyLl9zdWJSZW5kZXJOb2Rlcy5sZW5ndGgpKTtcclxuICAgIGFkYXB0ZXIuX3N1YlJlbmRlck5vZGVzLnB1c2goZ3JvdXBOb2RlKTtcclxuXHJcbiAgICB2YXIgbWVzaFNldHMgPSBkYXRhVHJlZU5vZGUubWVzaGVzLCBpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG1lc2hTZXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdmFyIHJlbmRlck5vZGUgPSBhZGFwdGVyLmdldFNjZW5lKCkuY3JlYXRlUmVuZGVyT2JqZWN0KHtcclxuICAgICAgICAgICAgcGFyZW50OiBncm91cE5vZGUsXHJcbiAgICAgICAgICAgIG5vZGU6IG1lc2hTZXRzW2ldLnJlZk5vZGUgfHwgYWRhcHRlci5ub2RlLFxyXG4gICAgICAgICAgICBjb25maWd1cmF0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBtZXNoU2V0c1tpXS54Zmxvd05vZGUsIHR5cGU6IG1lc2hTZXRzW2ldLnR5cGVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbmFtZTogYWRhcHRlci5ub2RlLmlkLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiBtZXNoU2V0c1tpXS52aXNpYmxlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmVuZGVyTm9kZS5zZXRMb2NhbE1hdHJpeChtZXNoU2V0c1tpXS50cmFuc2Zvcm0gfHwgY19JREVOVElUWSk7XHJcbiAgICAgICAgcmVuZGVyTm9kZS5zZXRNYXRlcmlhbChhZGFwdGVyLmdldE1hdGVyaWFsQ29uZmlndXJhdGlvbihtZXNoU2V0c1tpXS5tYXRlcmlhbCwgYWRhcHRlci5fc3ViUmVuZGVyTm9kZXMubGVuZ3RoKSk7XHJcbiAgICAgICAgYWRhcHRlci5fc3ViUmVuZGVyTm9kZXMucHVzaChyZW5kZXJOb2RlKTtcclxuICAgIH1cclxuICAgIHZhciBncm91cHMgPSBkYXRhVHJlZU5vZGUuZ3JvdXBzO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHJlY19jcmVhdGVSZW5kZXJOb2RlcyhhZGFwdGVyLCBncm91cE5vZGUsIGdyb3Vwc1tpXSk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vLyBJbnRlcmZhY2UgbWV0aG9kc1xyXG5cclxuWE1MM0QuZXh0ZW5kKE1vZGVsUmVuZGVyQWRhcHRlci5wcm90b3R5cGUsIHtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7WE1MM0QuQm94fVxyXG4gICAgICovXHJcbiAgICBnZXRMb2NhbEJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGJib3ggPSBuZXcgWE1MM0QuQm94KCk7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyTm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUuZ2V0T2JqZWN0U3BhY2VCb3VuZGluZ0JveChiYm94KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJib3g7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7WE1MM0QuQm94fVxyXG4gICAgICovXHJcbiAgICBnZXRXb3JsZEJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGJib3ggPSBuZXcgWE1MM0QuQm94KCk7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyTm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUuZ2V0V29ybGRTcGFjZUJvdW5kaW5nQm94KGJib3gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmJveDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHttYXQ0fVxyXG4gICAgICovXHJcbiAgICBnZXRXb3JsZE1hdHJpeDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBtID0gbmV3IFhNTDNELk1hdDQoKSwgb2JqID0gdGhpcy5yZW5kZXJOb2RlO1xyXG4gICAgICAgIGlmIChvYmopIHtcclxuICAgICAgICAgICAgb2JqLmdldFdvcmxkTWF0cml4KG0uZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbi8vIEV4cG9ydFxyXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsUmVuZGVyQWRhcHRlcjtcclxuXHJcbiIsInZhciBSZW5kZXJBZGFwdGVyID0gcmVxdWlyZShcIi4vYmFzZS5qc1wiKTtcclxudmFyIERPTVRyYW5zZm9ybUZldGNoZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4vZGF0YS90cmFuc2Zvcm0tZmV0Y2hlci5qc1wiKTtcclxudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xyXG52YXIgQWRhcHRlckhhbmRsZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL2FkYXB0ZXJoYW5kbGUuanNcIik7XHJcblxyXG4vKipcclxuICogVGhlIFNjZW5lRWxlbWVudEFkYXB0ZXIgYWRhcHRlciBpcyB0aGUgYmFzZSBhZGFwdGVyIGZvciBhbGwgc2NlbmUgZWxlbWVudHMsXHJcbiAqIGkuZS4gPGdyb3VwPiwgPHZpZXc+LCA8bWVzaD4sIDxsaWdodD4gYW5kIDxtb2RlbD4uIFRoZXNlIGFyZSBhbHNvXHJcbiAqIHRob3NlIGVsZW1lbnQgdGhhdCBjcmVhdGUgYW4gb2JqZWN0IGluc2lkZSB0aGUge0BsaW5rIFNjZW5lfSBkYXRhIHN0cnVjdHVyZVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlbmRlckFkYXB0ZXJGYWN0b3J5fSBmYWN0b3J5XHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcclxuICogQHBhcmFtIGhhbmRsZU1hdGVyaWFsXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBSZW5kZXJBZGFwdGVyXHJcbiAqIEBzZWUgQGxpbmsgaHR0cDovL3htbDNkLm9yZy94bWwzZC9zcGVjaWZpY2F0aW9uLzUuMC8jc2NlbmUtZWxlbWVudHNcclxuICovXHJcbnZhciBTY2VuZUVsZW1lbnRBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUsIGhhbmRsZU1hdGVyaWFsKSB7XHJcbiAgICBSZW5kZXJBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XHJcbiAgICB0aGlzLnJlbmRlck5vZGUgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGl2aW5nIG9iamVjdDogSG9sZHMgdGhlIHN0eWxlIG9mIHRoZSBhc3NvY2lhdGVkIG5vZGVcclxuICAgICAqIEB0eXBlIHtDU1NTdHlsZURlY2xhcmF0aW9ufVxyXG4gICAgICovXHJcbiAgICB0aGlzLnN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XHJcblxyXG4gICAgdGhpcy5tYXRlcmlhbEhhbmRsZXIgPSBudWxsO1xyXG4gICAgdGhpcy5oYW5kbGVNYXRlcmlhbCA9IGhhbmRsZU1hdGVyaWFsIHx8IGZhbHNlO1xyXG4gICAgdGhpcy50cmFuc2Zvcm1GZXRjaGVyID0gbmV3IERPTVRyYW5zZm9ybUZldGNoZXIodGhpcywgXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2Zvcm1cIik7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhTY2VuZUVsZW1lbnRBZGFwdGVyLCBSZW5kZXJBZGFwdGVyLCB7XHJcblxyXG4gICAgdXBkYXRlTWF0ZXJpYWxIYW5kbGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG1hdGVyaWFsVVJJID0gZ2V0TWF0ZXJpYWxVUkkodGhpcy5ub2RlKTtcclxuICAgICAgICBpZiAoIW1hdGVyaWFsVVJJKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEFkYXB0ZXJIYW5kbGUoXCJtYXRlcmlhbFwiKTtcclxuICAgICAgICAgICAgdGhpcy5tYXRlcmlhbEhhbmRsZXIgPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF0ZXJpYWxIYW5kbGVyID0gdGhpcy5nZXRBZGFwdGVySGFuZGxlKG1hdGVyaWFsVVJJKTtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0QWRhcHRlckhhbmRsZShcIm1hdGVyaWFsXCIsIHRoaXMubWF0ZXJpYWxIYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VkTWF0ZXJpYWxDaGFuZ2VkKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlZmVyZW5jZWRNYXRlcmlhbENoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMubWF0ZXJpYWxIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0UmVuZGVyTm9kZSgpLnNldE1hdGVyaWFsKG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdGF0dXMgPSB0aGlzLm1hdGVyaWFsSGFuZGxlci5zdGF0dXM7XHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gQWRhcHRlckhhbmRsZS5TVEFUVVMuTk9UX0ZPVU5EKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiQ291bGQgbm90IGZpbmQgZWxlbWVudCBvZiB1cmwgJ1wiICsgdGhpcy5tYXRlcmlhbEhhbmRsZXIudXJsICsgXCInIGZvciBtYXRlcmlhbFwiLCB0aGlzLm5vZGUpO1xyXG4gICAgICAgICAgICB0aGlzLmdldFJlbmRlck5vZGUoKS5zZXRNYXRlcmlhbChudWxsKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYWRhcHRlciA9IHRoaXMubWF0ZXJpYWxIYW5kbGVyLmdldEFkYXB0ZXIoKTtcclxuICAgICAgICBpZiAoYWRhcHRlciAmJiBhZGFwdGVyLmdldE1hdGVyaWFsQ29uZmlndXJhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmdldFJlbmRlck5vZGUoKS5zZXRNYXRlcmlhbChhZGFwdGVyLmdldE1hdGVyaWFsQ29uZmlndXJhdGlvbigpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmdldFJlbmRlck5vZGUoKS5zZXRNYXRlcmlhbChudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG9uQ29uZmlndXJlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRSZW5kZXJOb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlck5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlID0gdGhpcy5jcmVhdGVSZW5kZXJOb2RlID8gdGhpcy5jcmVhdGVSZW5kZXJOb2RlKCkgOiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJOb2RlO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVWaXNpYmlsaXR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5vbmUgPSB0aGlzLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJkaXNwbGF5XCIpLnRyaW0oKSA9PSBcIm5vbmVcIjtcclxuICAgICAgICB2YXIgaGlkZGVuID0gdGhpcy5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwidmlzaWJpbGl0eVwiKS50cmltKCkgPT0gXCJoaWRkZW5cIjtcclxuICAgICAgICB0aGlzLnJlbmRlck5vZGUuc2V0TG9jYWxWaXNpYmxlKCEobm9uZSB8fCBoaWRkZW4pKTtcclxuICAgIH0sXHJcblxyXG5cclxuICAgIHVwZGF0ZVpJbmRleDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy9UaGlzIGZ1bmN0aW9uIGlzIG92ZXJyaWRkZW4gYnkgdGhlIGxlYWYgbm9kZXMgKG1lc2gsIG1vZGVsKSwgb3RoZXJ3aXNlIGl0IHNob3VsZCBkbyBub3RoaW5nXHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuZ2V0UmVuZGVyTm9kZSgpLnJlbW92ZSgpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtRmV0Y2hlciAmJiB0aGlzLnRyYW5zZm9ybUZldGNoZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuY2xlYXJBZGFwdGVySGFuZGxlcygpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdHlsZUNoYW5nZWRDYWxsYmFjazogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVaSW5kZXgoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlTG9jYWxNYXRyaXg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybUZldGNoZXIgJiYgdGhpcy50cmFuc2Zvcm1GZXRjaGVyLnVwZGF0ZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvblRyYW5zZm9ybUNoYW5nZTogZnVuY3Rpb24gKGF0dHJOYW1lLCBtYXRyaXgpIHtcclxuICAgICAgICBpZiAoYXR0ck5hbWUgPT0gXCJ0cmFuc2Zvcm1cIikge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUuc2V0TG9jYWxNYXRyaXgobWF0cml4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IGZ1bmN0aW9uIChuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcclxuICAgICAgICBSZW5kZXJBZGFwdGVyLnByb3RvdHlwZS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2suY2FsbCh0aGlzLCBuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xyXG5cclxuICAgICAgICBpZiAobmFtZSA9PSBcInRyYW5zZm9ybVwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtRmV0Y2hlciAmJiB0aGlzLnRyYW5zZm9ybUZldGNoZXIudXBkYXRlKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwic3R5bGVcIikge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybUZldGNoZXIgJiYgdGhpcy50cmFuc2Zvcm1GZXRjaGVyLnVwZGF0ZU1hdHJpeCgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcIm1hdGVyaWFsXCIgJiYgdGhpcy5oYW5kbGVNYXRlcmlhbCkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1hdGVyaWFsSGFuZGxlcigpO1xyXG4gICAgICAgICAgICB0aGlzLmZhY3RvcnkucmVuZGVyZXIucmVxdWVzdFJlZHJhdyhcIlRyYW5zZm9ybWFibGUgbWF0ZXJpYWwgY2hhbmdlZC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBub3RpZnlDaGFuZ2VkOiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgc3dpdGNoIChldnQudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIEV2ZW50cy5BREFQVEVSX0hBTkRMRV9DSEFOR0VEOlxyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGV2dC5rZXk7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09IFwibWF0ZXJpYWxcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTWF0ZXJpYWxIYW5kbGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWN0b3J5LnJlbmRlcmVyLnJlcXVlc3RSZWRyYXcoXCJNYXRlcmlhbCByZWZlcmVuY2UgY2hhbmdlZC5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBFdmVudHMuVEhJU19SRU1PVkVEOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBFdmVudHMuTk9ERV9JTlNFUlRFRDpcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdEVsZW1lbnQoZXZ0LmFmZmVjdGVkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKFwiVW5oYW5kbGVkIGV2ZW50IGluIFNjZW5lRWxlbWVudEFkYXB0ZXI6XCIsIGV2dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0TWF0ZXJpYWxVUkkobm9kZSkge1xyXG4gICAgdmFyIG1hdGVyaWFsVVJJID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJtYXRlcmlhbFwiKTtcclxuICAgIGlmICghbWF0ZXJpYWxVUkkpIHtcclxuICAgICAgICB2YXIgc3R5bGVWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xyXG4gICAgICAgIGlmIChzdHlsZVZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gL21hdGVyaWFsXFxzKjpcXHMqdXJsXFxzKlxcKFxccyooXFxTKylcXHMqXFwpL2k7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBwYXR0ZXJuLmV4ZWMoc3R5bGVWYWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQpXHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbFVSSSA9IHJlc3VsdFsxXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF0ZXJpYWxVUkk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2NlbmVFbGVtZW50QWRhcHRlcjtcclxuIiwidmFyIFNjZW5lRWxlbWVudEFkYXB0ZXIgPSByZXF1aXJlKFwiLi9zY2VuZS1lbGVtZW50LmpzXCIpO1xyXG52YXIgQ2FtZXJhQ29uZmlndXJhdGlvbiA9IHJlcXVpcmUoXCIuLi9zY2VuZS9jb25maWd1cmF0aW9uLmpzXCIpO1xyXG52YXIgUmVzb3VyY2UgPSByZXF1aXJlKFwiLi4vLi4vLi4vcmVzb3VyY2VcIik7XHJcblxyXG52YXIgREVGQVVMVF9DQU1FUkFfTU9ERUwgPSBcInVybjp4bWwzZDp2aWV3OnBlcnNwZWN0aXZlXCI7XHJcblxyXG4vKipcclxuICogQWRhcHRlciBmb3IgPHZpZXc+XHJcbiAqIEBwYXJhbSB7UmVuZGVyQWRhcHRlckZhY3Rvcnl9IGZhY3RvcnlcclxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXHJcbiAqIEBleHRlbmRzIFNjZW5lRWxlbWVudEFkYXB0ZXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgVmlld1JlbmRlckFkYXB0ZXIgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbm9kZSkge1xyXG4gICAgU2NlbmVFbGVtZW50QWRhcHRlci5jYWxsKHRoaXMsIGZhY3RvcnksIG5vZGUsIGZhbHNlLCBmYWxzZSk7XHJcbiAgICB0aGlzLmRhdGFBZGFwdGVyID0gUmVzb3VyY2UuZ2V0QWRhcHRlcihub2RlLCBcImRhdGFcIik7XHJcbiAgICB0aGlzLmNyZWF0ZVJlbmRlck5vZGUoKTtcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoVmlld1JlbmRlckFkYXB0ZXIsIFNjZW5lRWxlbWVudEFkYXB0ZXIsIHtcclxuXHJcbiAgICBjcmVhdGVSZW5kZXJOb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50UmVuZGVyQWRhcHRlcigpO1xyXG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gcGFyZW50LmdldFJlbmRlck5vZGUgPyBwYXJlbnQuZ2V0UmVuZGVyTm9kZSgpIDogdGhpcy5mYWN0b3J5LnJlbmRlcmVyLnNjZW5lLmNyZWF0ZVJvb3ROb2RlKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJOb2RlID0gdGhpcy5mYWN0b3J5LnJlbmRlcmVyLnNjZW5lLmNyZWF0ZVJlbmRlclZpZXcoe1xyXG4gICAgICAgICAgICBjYW1lcmE6IHRoaXMuY3JlYXRlQ2FtZXJhQ29uZmlndXJhdGlvbigpLCBwYXJlbnQ6IHBhcmVudE5vZGVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUxvY2FsTWF0cml4KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZUNhbWVyYUNvbmZpZ3VyYXRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm5vZGUuaGFzQXR0cmlidXRlKFwibW9kZWxcIikgPyB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKFwibW9kZWxcIikgOiBERUZBVUxUX0NBTUVSQV9NT0RFTDtcclxuICAgICAgICByZXR1cm4gbmV3IENhbWVyYUNvbmZpZ3VyYXRpb24obW9kZWwsIHRoaXMuZGF0YUFkYXB0ZXIuZ2V0WGZsb3dOb2RlKCksIHtuYW1lOiB0aGlzLm5vZGUuaWR9KTtcclxuICAgIH0sXHJcblxyXG5cclxuICAgIC8qIEludGVyZmFjZSBtZXRob2QgKi9cclxuICAgIGdldFZpZXdNYXRyaXg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbSA9IG5ldyBYTUwzRC5NYXQ0KCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJOb2RlLmdldFdvcmxkVG9WaWV3TWF0cml4KG0uZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIG07XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJucyB2aWV3MndvcmxkIG1hdHJpeFxyXG4gICAgICogQHJldHVybiB7bWF0NH1cclxuICAgICAqL1xyXG4gICAgZ2V0V29ybGRNYXRyaXg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbSA9IG5ldyBYTUwzRC5NYXQ0KCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJOb2RlLmdldFZpZXdUb1dvcmxkTWF0cml4KG0uZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIG07XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFByb2plY3Rpb25NYXRyaXg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbSA9IG5ldyBYTUwzRC5NYXQ0KCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJOb2RlLmdldFByb2plY3Rpb25NYXRyaXgobS5kYXRhKTtcclxuICAgICAgICByZXR1cm4gbTtcclxuICAgIH0sXHJcblxyXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrOiBmdW5jdGlvbiAobmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgU2NlbmVFbGVtZW50QWRhcHRlci5wcm90b3R5cGUuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrLmNhbGwodGhpcywgbmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcclxuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcclxuICAgICAgICAgICAgY2FzZSBcIm1vZGVsXCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVJlbmRlck5vZGUoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG4vLyBFeHBvcnRcclxubW9kdWxlLmV4cG9ydHMgPSBWaWV3UmVuZGVyQWRhcHRlcjtcclxuIiwidmFyIFJlbmRlckFkYXB0ZXIgPSByZXF1aXJlKFwiLi9iYXNlLmpzXCIpO1xyXG52YXIgVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMuanNcIik7XHJcbnZhciBFdmVudHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vaW50ZXJmYWNlL25vdGlmaWNhdGlvbi5qc1wiKTtcclxudmFyIGRpc3BhdGNoQ3VzdG9tRXZlbnQgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvbWlzYy5qc1wiKS5kaXNwYXRjaEN1c3RvbUV2ZW50O1xyXG52YXIgUmVzb3VyY2VDb3VudGVyID0gcmVxdWlyZShcIi4uLy4uLy4uL3Jlc291cmNlL2NvdW50ZXIuanNcIik7XHJcblxyXG52YXIgWE1MM0RSZW5kZXJBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcclxuICAgIFJlbmRlckFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlKTtcclxuICAgIHRoaXMuZmlyZUxvYWRFdmVudEFmdGVyRHJhdyA9IGZhbHNlO1xyXG4gICAgdGhpcy5maXJzdExvYWRGaXJlZCA9IGZhbHNlO1xyXG59O1xyXG5YTUwzRC5jcmVhdGVDbGFzcyhYTUwzRFJlbmRlckFkYXB0ZXIsIFJlbmRlckFkYXB0ZXIsIHtcclxuXHJcbiAgICBhY3RpdmVWaWV3Q2hhbmdlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2aWV3RWxlbWVudCA9IGdldE9yQ3JlYXRlQWN0aXZlVmlldyh0aGlzLm5vZGUpO1xyXG4gICAgICAgIHZhciBhZGFwdGVyID0gdGhpcy5mYWN0b3J5LmdldEFkYXB0ZXIodmlld0VsZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuZmFjdG9yeS5nZXRTY2VuZSgpLnNldEFjdGl2ZVZpZXcoYWRhcHRlci5nZXRSZW5kZXJOb2RlKCkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IGZ1bmN0aW9uIChuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcclxuICAgICAgICBpZiAobmFtZSA9PSBcInZpZXdcIikge1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVZpZXdDaGFuZ2VkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBub3RpZnlDaGFuZ2VkOiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgc3dpdGNoIChldnQudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIEV2ZW50cy5OT0RFX0lOU0VSVEVEOlxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhbHNvIGluaXRpYWxpemVzIHRoZSBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0RWxlbWVudChldnQubXV0YXRpb24udGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBzY2VuZSBET00gaXMgbG9hZGVkIGFuZCBhbGwgYWRhcHRlcnMgYXJlIGF0dGFjaGVkXHJcbiAgICAgKi9cclxuICAgIG9uQ29uZmlndXJlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlVmlld0NoYW5nZWQoKTtcclxuXHJcbiAgICAgICAgLy8gZW1pdCBsb2FkIGV2ZW50IHdoZW4gYWxsIHJlc291cmNlcyBjdXJyZW50bHkgbG9hZGluZyBhcmUgY29tcGxldGVkXHJcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5vbkxvYWRDb21wbGV0ZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIC8vIHJlZ2lzdGVyIGNhbGxiYWNrIGZvciBjYW52YXNJZCA9PSAwIGkuZS4gZ2xvYmFsIHJlc291cmNlc1xyXG4gICAgICAgIFJlc291cmNlQ291bnRlci5hZGRMb2FkQ29tcGxldGVMaXN0ZW5lcigwLCBjYWxsYmFjayk7XHJcbiAgICAgICAgLy8gcmVnaXN0ZXIgY2FsbGJhY2sgZm9yIGNhbnZhc0lkIG9mIHRoaXMgbm9kZVxyXG4gICAgICAgIFJlc291cmNlQ291bnRlci5hZGRMb2FkQ29tcGxldGVMaXN0ZW5lcih0aGlzLmZhY3RvcnkuY2FudmFzSWQsIGNhbGxiYWNrKTtcclxuICAgICAgICB0aGlzLm9uTG9hZENvbXBsZXRlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qIEludGVyZmFjZSBtZXRob2RzICovXHJcblxyXG4gICAgb25Mb2FkQ29tcGxldGU6IGZ1bmN0aW9uIChjYW52YXNJZCkge1xyXG4gICAgICAgIGlmIChSZXNvdXJjZUNvdW50ZXIuaXNMb2FkQ29tcGxldGUoMCkgJiYgUmVzb3VyY2VDb3VudGVyLmlzTG9hZENvbXBsZXRlKHRoaXMuZmFjdG9yeS5jYW52YXNJZCkpIHtcclxuICAgICAgICAgICAgdGhpcy5maXJlTG9hZEV2ZW50QWZ0ZXJEcmF3ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG9uRnJhbWVEcmF3bjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZpcmVMb2FkRXZlbnRBZnRlckRyYXcpIHtcclxuICAgICAgICAgICAgdGhpcy5maXJlTG9hZEV2ZW50QWZ0ZXJEcmF3ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyc3RMb2FkRmlyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50KHRoaXMubm9kZSwgJ2xvYWQnLCBmYWxzZSwgdHJ1ZSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcblxyXG4gICAgZ2V0Q29tcGxldGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5maXJlTG9hZEV2ZW50QWZ0ZXJEcmF3KSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKCF0aGlzLmZpcnN0TG9hZEZpcmVkKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIFJlc291cmNlQ291bnRlci5pc0xvYWRDb21wbGV0ZSgwKSAmJiBSZXNvdXJjZUNvdW50ZXIuaXNMb2FkQ29tcGxldGUodGhpcy5mYWN0b3J5LmNhbnZhc0lkKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0V29ybGRCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBiYm94ID0gbmV3IFhNTDNELkJveCgpO1xyXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwodGhpcy5ub2RlLmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgICAgIGlmIChjLmdldFdvcmxkQm91bmRpbmdCb3gpIHtcclxuICAgICAgICAgICAgICAgIGJib3guZXh0ZW5kKGMuZ2V0V29ybGRCb3VuZGluZ0JveCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBiYm94O1xyXG4gICAgfVxyXG59KVxyXG47XHJcbi8vWE1MM0QgZWxlbWVudCBpcyB0aGUgcm9vdCB3aXRoIG5vIHRyYW5zZm9ybSBvZiBpdHMgb3duIHNvIGJ5IGRlZmluaXRpb24gaXQncyBhbHdheXMgaW4gd29ybGQgc3BhY2VcclxuWE1MM0RSZW5kZXJBZGFwdGVyLnByb3RvdHlwZS5nZXRMb2NhbEJvdW5kaW5nQm94ID0gWE1MM0RSZW5kZXJBZGFwdGVyLnByb3RvdHlwZS5nZXRXb3JsZEJvdW5kaW5nQm94O1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IHggY29vcmRpbmF0ZSBpbiBzY3JlZW4gc3BhY2VcclxuICogQHBhcmFtIHtudW1iZXJ9IHkgeSBjb29yZGluYXRlIGluIHNjcmVlbiBzcGFjZVxyXG4gKiBAcGFyYW0ge1hNTDNELlZlYzM/fSBoaXRQb2ludFxyXG4gKiBAcGFyYW0ge1hNTDNELlZlYzM/fSBoaXROb3JtYWxcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5YTUwzRFJlbmRlckFkYXB0ZXIucHJvdG90eXBlLmdldEVsZW1lbnRCeVBvaW50ID0gZnVuY3Rpb24gKHgsIHksIGhpdFBvaW50LCBoaXROb3JtYWwpIHtcclxuICAgIHZhciByZWxhdGl2ZU1vdXNlUG9zID0gVXRpbHMuY29udmVydFBhZ2VDb29yZHModGhpcy5ub2RlLCB4LCB5KTtcclxuXHJcbiAgICB2YXIgcmVsWCA9IHJlbGF0aXZlTW91c2VQb3MueDtcclxuICAgIHZhciByZWxZID0gcmVsYXRpdmVNb3VzZVBvcy55O1xyXG5cclxuICAgIHZhciByZW5kZXJlciA9IHRoaXMuZmFjdG9yeS5nZXRSZW5kZXJlcigpO1xyXG4gICAgdmFyIG9iamVjdCA9IHJlbmRlcmVyLmdldFJlbmRlck9iamVjdEZyb21QaWNraW5nQnVmZmVyKHJlbFgsIHJlbFkpO1xyXG4gICAgaWYgKG9iamVjdCkge1xyXG4gICAgICAgIGlmIChoaXRQb2ludCkge1xyXG4gICAgICAgICAgICB2YXIgdmVjID0gcmVuZGVyZXIuZ2V0V29ybGRTcGFjZVBvc2l0aW9uQnlQb2ludChyZWxYLCByZWxZLCBvYmplY3QpO1xyXG4gICAgICAgICAgICBYTUwzRC5tYXRoLnZlYzMuY29weShoaXRQb2ludC5kYXRhLCB2ZWMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGl0Tm9ybWFsKSB7XHJcbiAgICAgICAgICAgIHZhciB2ZWMgPSByZW5kZXJlci5nZXRXb3JsZFNwYWNlTm9ybWFsQnlQb2ludChyZWxYLCByZWxZLCBvYmplY3QpO1xyXG4gICAgICAgICAgICBYTUwzRC5tYXRoLnZlYzMuY29weShoaXROb3JtYWwuZGF0YSwgdmVjKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChoaXRQb2ludCkge1xyXG4gICAgICAgICAgICBoaXRQb2ludC54ID0gTmFOO1xyXG4gICAgICAgICAgICBoaXRQb2ludC55ID0gTmFOO1xyXG4gICAgICAgICAgICBoaXRQb2ludC56ID0gTmFOO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGl0Tm9ybWFsKSB7XHJcbiAgICAgICAgICAgIGhpdE5vcm1hbC54ID0gTmFOO1xyXG4gICAgICAgICAgICBoaXROb3JtYWwueSA9IE5hTjtcclxuICAgICAgICAgICAgaGl0Tm9ybWFsLnogPSBOYU47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iamVjdCA/IG9iamVjdC5ub2RlIDogbnVsbDtcclxufTtcclxuXHJcblhNTDNEUmVuZGVyQWRhcHRlci5wcm90b3R5cGUuZ2V0UmVuZGVySW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZmFjdG9yeS5nZXRSZW5kZXJlcigpLmdldFJlbmRlckludGVyZmFjZSgpO1xyXG59O1xyXG5cclxuWE1MM0RSZW5kZXJBZGFwdGVyLnByb3RvdHlwZS5nZW5lcmF0ZVJheSA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICB2YXIgcmVsYXRpdmVNb3VzZVBvcyA9IFV0aWxzLmNvbnZlcnRQYWdlQ29vcmRzKHRoaXMubm9kZSwgeCwgeSk7XHJcbiAgICByZXR1cm4gdGhpcy5mYWN0b3J5LmdldFJlbmRlcmVyKCkuZ2VuZXJhdGVSYXkocmVsYXRpdmVNb3VzZVBvcy54LCByZWxhdGl2ZU1vdXNlUG9zLnkpO1xyXG59O1xyXG5cclxuWE1MM0RSZW5kZXJBZGFwdGVyLnByb3RvdHlwZS5nZXRFbGVtZW50QnlSYXkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGNfdmlld01hdCA9IFhNTDNELm1hdGgubWF0NC5jcmVhdGUoKTtcclxuICAgIHZhciBjX3Byb2pNYXQgPSBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4bWwzZFJheSwgaGl0UG9pbnQsIGhpdE5vcm1hbCkge1xyXG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuZmFjdG9yeS5nZXRSZW5kZXJlcigpO1xyXG4gICAgICAgIHJlbmRlcmVyLmNhbGN1bGF0ZU1hdHJpY2VzRm9yUmF5KHhtbDNkUmF5LCBjX3ZpZXdNYXQsIGNfcHJvak1hdCk7XHJcbiAgICAgICAgdmFyIGhpdE9iamVjdCA9IHJlbmRlcmVyLmdldFJlbmRlck9iamVjdEJ5UmF5KHhtbDNkUmF5LCBjX3ZpZXdNYXQsIGNfcHJvak1hdCk7XHJcbiAgICAgICAgaWYgKGhpdE9iamVjdCAhPT0gbnVsbCAmJiAoaGl0UG9pbnQgfHwgaGl0Tm9ybWFsKSkge1xyXG4gICAgICAgICAgICBpZiAoaGl0UG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2ZWMgPSByZW5kZXJlci5nZXRXb3JsZFNwYWNlUG9zaXRpb25CeVJheSh4bWwzZFJheSwgaGl0T2JqZWN0LCBjX3ZpZXdNYXQsIGNfcHJvak1hdCk7XHJcbiAgICAgICAgICAgICAgICBYTUwzRC5tYXRoLnZlYzMuY29weShoaXRQb2ludC5kYXRhLCB2ZWMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoaXROb3JtYWwpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2ZWMgPSByZW5kZXJlci5nZXRXb3JsZFNwYWNlTm9ybWFsQnlSYXkoeG1sM2RSYXksIGhpdE9iamVjdCwgY192aWV3TWF0LCBjX3Byb2pNYXQpO1xyXG4gICAgICAgICAgICAgICAgWE1MM0QubWF0aC52ZWMzLmNvcHkoaGl0Tm9ybWFsLmRhdGEsIHZlYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoaGl0UG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIGhpdFBvaW50LnggPSBOYU47XHJcbiAgICAgICAgICAgICAgICBoaXRQb2ludC55ID0gTmFOO1xyXG4gICAgICAgICAgICAgICAgaGl0UG9pbnQueiA9IE5hTjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaGl0Tm9ybWFsKSB7XHJcbiAgICAgICAgICAgICAgICBoaXROb3JtYWwueCA9IE5hTjtcclxuICAgICAgICAgICAgICAgIGhpdE5vcm1hbC55ID0gTmFOO1xyXG4gICAgICAgICAgICAgICAgaGl0Tm9ybWFsLnogPSBOYU47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhpdE9iamVjdCAhPT0gbnVsbCA/IGhpdE9iamVjdC5ub2RlIDogbnVsbDtcclxuICAgIH1cclxufSkoKTtcclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYWN0aXZlIHZpZXcgZWxlbWVudCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiB4bWwzZCBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0geyFPYmplY3R9IHhtbDNkXHJcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGFjdGl2ZSB2aWV3IGVsZW1lbnRcclxuICovXHJcbmZ1bmN0aW9uIGdldE9yQ3JlYXRlQWN0aXZlVmlldyh4bWwzZCkge1xyXG4gICAgLy8gdHJ5IHRvIHJlc29sdmUgcmVmZXJlbmNlXHJcbiAgICB2YXIgdmlldyA9IHhtbDNkLnF1ZXJ5U2VsZWN0b3IoeG1sM2QudmlldykgfHwgeG1sM2QucXVlcnlTZWxlY3RvcihcInZpZXdcIik7XHJcbiAgICBpZiAoIXZpZXcpIHtcclxuICAgICAgICAvLyBkaWRuJ3QgZmluZCBhbnk6IGNyZWF0ZSBuZXcgb25lXHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcInhtbDNkIGVsZW1lbnQgaGFzIG5vIHZpZXcgZGVmaW5lZDogY3JlYXRpbmcgb25lLlwiKTtcclxuXHJcbiAgICAgICAgdmlldyA9IHhtbDNkLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZXdcIik7XHJcbiAgICAgICAgeG1sM2QuYXBwZW5kQ2hpbGQodmlldyk7XHJcbiAgICAgICAgeG1sM2QucmVtb3ZlQXR0cmlidXRlKFwidmlld1wiKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2aWV3O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBYTUwzRFJlbmRlckFkYXB0ZXI7XHJcblxyXG5cclxuIiwidmFyIFhDID0gcmVxdWlyZShcIi4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XHJcbnZhciBEYXRhTm9kZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvZ3JhcGguanNcIikuRGF0YU5vZGU7XHJcbnZhciBJbnB1dE5vZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2dyYXBoLmpzXCIpLklucHV0Tm9kZTtcclxudmFyIEJ1ZmZlckVudHJ5ID0gcmVxdWlyZShcIi4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9kYXRhLmpzXCIpLkJ1ZmZlckVudHJ5O1xyXG52YXIgQ29tcHV0ZVJlcXVlc3QgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL3JlcXVlc3QuanNcIikuQ29tcHV0ZVJlcXVlc3Q7XHJcbnZhciBGcnVzdHVtID0gcmVxdWlyZShcIi4uL3Rvb2xzL2ZydXN0dW0uanNcIikuRnJ1c3R1bTtcclxudmFyIG1hdDQgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLm1hdDQ7XHJcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcclxuXHJcblxyXG5cclxudmFyIFByb2plY3RpdmVDYW1lcmFEYXRhID0ge1xyXG4gICAgXCJwcm9qZWN0aW9uTWF0cml4XCI6IHtcclxuICAgICAgICB0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQ0WDQsIGRlZmF1bHQ6IG1hdDQucGVyc3BlY3RpdmUobWF0NC5jcmVhdGUoKSwgKDQ1ICogTWF0aC5QSSAvIDE4MCksIDEsIDAuMDAxLCAxMDAwMClcclxuICAgIH1cclxufTtcclxuXHJcbnZhciBQZXJzcGVjdGl2ZUNhbWVyYURhdGEgPSB7XHJcbiAgICBcImZvdlZlcnRpY2FsXCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQzLCAnZGVmYXVsdCc6IFsoNDUgKiBNYXRoLlBJIC8gMTgwKV19LFxyXG4gICAgXCJmb3ZIb3Jpem9udGFsXCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQzLCAnZGVmYXVsdCc6IHVuZGVmaW5lZH0sXHJcbiAgICBcIm5lYXJcIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5GTE9BVDMsICdkZWZhdWx0JzogdW5kZWZpbmVkfSxcclxuICAgIFwiZmFyXCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQzLCAnZGVmYXVsdCc6IHVuZGVmaW5lZH0sXHJcbiAgICBcImFzcGVjdFwiOiB7dHlwZTogWEMuREFUQV9UWVBFLkZMT0FULCAnZGVmYXVsdCc6IHVuZGVmaW5lZH0sXHJcbiAgICBcIndvcmxkQm91bmRpbmdCb3hcIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5GTE9BVCwgJ2RlZmF1bHQnOiB1bmRlZmluZWR9XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtEYXRhTm9kZXxudWxsfSBkYXRhTm9kZVxyXG4gKiBAcGFyYW0gc2NlbmVcclxuICogQHBhcmFtIG93bmVyXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlbFxyXG4gKiBAcGFyYW0gZGVmYXVsdHNcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgQWJzdHJhY3RDYW1lcmFNb2RlbCA9IGZ1bmN0aW9uIChkYXRhTm9kZSwgc2NlbmUsIG93bmVyLCBtb2RlbCwgZGVmYXVsdHMpIHtcclxuICAgIGFzc2VydC5lcXVhbCh0eXBlb2Ygb3duZXIudmlld0ZydXN0dW1DaGFuZ2VkLCAnZnVuY3Rpb24nKTtcclxuICAgIGFzc2VydC5lcXVhbCh0eXBlb2YgbW9kZWwsICdzdHJpbmcnKTtcclxuICAgIGFzc2VydChkZWZhdWx0cyk7XHJcbiAgICBhc3NlcnQoc2NlbmUpO1xyXG5cclxuICAgIHRoaXMub3duZXIgPSBvd25lcjtcclxuICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuICAgIHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzKTtcclxuXHJcbiAgICBpZiAoZGF0YU5vZGUpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IG5ldyBEYXRhTm9kZSgpO1xyXG4gICAgICAgIGRhdGEuaW5zZXJ0QmVmb3JlKGNyZWF0ZVhmbG93RGF0YShkZWZhdWx0cyksIG51bGwpO1xyXG4gICAgICAgIGRhdGEuaW5zZXJ0QmVmb3JlKGRhdGFOb2RlLCBudWxsKTtcclxuICAgICAgICB0aGlzLmRhdGFOb2RlID0gZGF0YTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5kYXRhTm9kZSA9IGNyZWF0ZVhmbG93RGF0YShkZWZhdWx0cyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmRhdGFOb2RlLmluc2VydEJlZm9yZSh0aGlzLnNjZW5lLmRhdGEuZGF0YSwgbnVsbCk7XHJcblxyXG4gICAgdGhpcy5jYW1lcmFQYXJhbWV0ZXJSZXF1ZXN0ID0gbmV3IENvbXB1dGVSZXF1ZXN0KHRoaXMuZGF0YU5vZGUsIHRoaXMucGFyYW1ldGVycywgdGhpcy5jYW1lcmFQYXJhbWV0ZXJzQ2hhbmdlZC5iaW5kKHRoaXMpKTtcclxuICAgIHRoaXMuY2FtZXJhUGFyYW1ldGVyc0NoYW5nZWQodGhpcy5jYW1lcmFQYXJhbWV0ZXJSZXF1ZXN0LCBudWxsKTtcclxufTtcclxuXHJcbkFic3RyYWN0Q2FtZXJhTW9kZWwucHJvdG90eXBlID0ge1xyXG4gICAgY2FtZXJhUGFyYW1ldGVyc0NoYW5nZWQ6IGZ1bmN0aW9uIChyZXF1ZXN0LCBjaGFuZ2VUeXBlKSB7XHJcbiAgICAgICAgaWYgKGNoYW5nZVR5cGUpIHtcclxuICAgICAgICAgICAgdGhpcy5vd25lci52aWV3RnJ1c3R1bUNoYW5nZWQoY2hhbmdlVHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmNhbWVyYVBhcmFtZXRlclJlcXVlc3QuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmRhdGFOb2RlLmNsZWFyKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSBkYXRhTm9kZVxyXG4gKiBAcGFyYW0ge1NjZW5lfSBzY2VuZVxyXG4gKiBAcGFyYW0ge1JlbmRlclZpZXd9IG93bmVyXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdENhbWVyYU1vZGVsXHJcbiAqL1xyXG52YXIgUHJvamVjdGl2ZUNhbWVyYU1vZGVsID0gZnVuY3Rpb24gKGRhdGFOb2RlLCBzY2VuZSwgb3duZXIpIHtcclxuICAgIEFic3RyYWN0Q2FtZXJhTW9kZWwuY2FsbCh0aGlzLCBkYXRhTm9kZSwgc2NlbmUsIG93bmVyLCBcInByb2plY3RpdmVcIiwgUHJvamVjdGl2ZUNhbWVyYURhdGEpO1xyXG59O1xyXG5cclxuWE1MM0QuY3JlYXRlQ2xhc3MoUHJvamVjdGl2ZUNhbWVyYU1vZGVsLCBBYnN0cmFjdENhbWVyYU1vZGVsLCB7XHJcbiAgICBnZXRQcm9qZWN0aW9uTWF0cml4OiBmdW5jdGlvbiAoYXNwZWN0KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2FtZXJhUGFyYW1ldGVyUmVxdWVzdC5nZXRSZXN1bHQoKTtcclxuICAgICAgICB2YXIgcHJvamVjdGlvbk1hdHJpeCA9IHJlc3VsdC5nZXRPdXRwdXREYXRhKFwicHJvamVjdGlvbk1hdHJpeFwiKS5nZXRWYWx1ZSgpO1xyXG4gICAgICAgIHJldHVybiBwcm9qZWN0aW9uTWF0cml4O1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBUT0RPKGtzb25zKTogQ29tcHV0ZSBmcnVzdHVtIGZyb20gcHJvamVjdGlvbiBtYXRyaXhcclxuICAgIGdldEZydXN0dW06IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogUGVyc3BlY3RpdmUgQ2FtZXJhIE1vZGVsXHJcbiAqIEBwYXJhbSBkYXRhTm9kZVxyXG4gKiBAcGFyYW0gc2NlbmVcclxuICogQHBhcmFtIG93bmVyXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0Q2FtZXJhTW9kZWxcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgUGVyc3BlY3RpdmVDYW1lcmFNb2RlbCA9IGZ1bmN0aW9uIChkYXRhTm9kZSwgc2NlbmUsIG93bmVyKSB7XHJcbiAgICBBYnN0cmFjdENhbWVyYU1vZGVsLmNhbGwodGhpcywgZGF0YU5vZGUsIHNjZW5lLCBvd25lciwgXCJwZXJzcGVjdGl2ZVwiLCBQZXJzcGVjdGl2ZUNhbWVyYURhdGEpO1xyXG4gICAgdGhpcy5mcnVzdHVtID0gbmV3IEZydXN0dW0oMC4wMSwgMTAwMCwgMCwgMC43OCwgMSk7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhQZXJzcGVjdGl2ZUNhbWVyYU1vZGVsLCBBYnN0cmFjdENhbWVyYU1vZGVsLCB7XHJcblxyXG4gICAgX3VwZGF0ZUZydXN0dW06IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jYW1lcmFQYXJhbWV0ZXJSZXF1ZXN0LmdldFJlc3VsdCgpO1xyXG5cclxuICAgICAgICB2YXIgZm92diwgZm92aCwgbmVhciwgZmFyO1xyXG5cclxuICAgICAgICB2YXIgZm92aEVudHJ5ID0gcmVzdWx0LmdldE91dHB1dERhdGEoXCJmb3ZIb3Jpem9udGFsXCIpO1xyXG4gICAgICAgIGlmIChmb3ZoRW50cnkpIHtcclxuICAgICAgICAgICAgZm92aCA9IGZvdmhFbnRyeS5nZXRWYWx1ZSgpWzBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvdnYgPSByZXN1bHQuZ2V0T3V0cHV0RGF0YShcImZvdlZlcnRpY2FsXCIpLmdldFZhbHVlKClbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbmVhckVudHJ5ID0gcmVzdWx0LmdldE91dHB1dERhdGEoXCJuZWFyXCIpO1xyXG4gICAgICAgIGlmIChuZWFyRW50cnkpIHtcclxuICAgICAgICAgICAgbmVhciA9IG5lYXJFbnRyeS5nZXRWYWx1ZSgpWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGZhckVudHJ5ID0gcmVzdWx0LmdldE91dHB1dERhdGEoXCJmYXJcIik7XHJcbiAgICAgICAgaWYgKGZhckVudHJ5KSB7XHJcbiAgICAgICAgICAgIGZhciA9IGZhckVudHJ5LmdldFZhbHVlKClbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYXNwZWN0ID0gcmVzdWx0LmdldE91dHB1dERhdGEoXCJhc3BlY3RcIikuZ2V0VmFsdWUoKVswXTtcclxuXHJcbiAgICAgICAgaWYgKG5lYXIgPT0gdW5kZWZpbmVkIHx8IGZhciA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFyIGJvdW5kaW5nQm94ID0gbmV3IFhNTDNELkJveChyZXN1bHQuZ2V0T3V0cHV0RGF0YShcIndvcmxkQm91bmRpbmdCb3hcIikuZ2V0VmFsdWUoKSlcclxuICAgICAgICAgICAgdmFyIG5lYXJGYXIgPSB0aGlzLm93bmVyLmdldENsaXBwaW5nUGxhbmVzKGJvdW5kaW5nQm94KTtcclxuXHJcbiAgICAgICAgICAgIG5lYXIgPSBuZWFyID09IHVuZGVmaW5lZCA/IG5lYXJGYXIubmVhciA6IG5lYXI7XHJcbiAgICAgICAgICAgIGZhciA9IGZhciA9PSB1bmRlZmluZWQgPyBuZWFyRmFyLmZhciA6IGZhcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZnJ1c3R1bS5zZXRGcnVzdHVtKG5lYXIsIGZhciwgZm92aCwgZm92diwgYXNwZWN0IC8qLCBvcnRob2dyYXBoaWMgPSBmYWxzZSAqLyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFByb2plY3Rpb25NYXRyaXg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl91cGRhdGVGcnVzdHVtKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJ1c3R1bS5nZXRQcm9qZWN0aW9uTWF0cml4KG1hdDQuY3JlYXRlKCkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRGcnVzdHVtOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlRnJ1c3R1bSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZydXN0dW07XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlWGZsb3dEYXRhKGNvbmZpZykge1xyXG4gICAgdmFyIGRhdGEgPSBuZXcgRGF0YU5vZGUoKTtcclxuICAgIGZvciAodmFyIG5hbWUgaW4gY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gY29uZmlnW25hbWVdO1xyXG4gICAgICAgIGlmIChlbnRyeVsnZGVmYXVsdCddKSB7XHJcbiAgICAgICAgICAgIGNyZWF0ZVhmbG93VmFsdWUoZGF0YSwgbmFtZSwgZW50cnkudHlwZSwgZW50cnlbJ2RlZmF1bHQnXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVhmbG93VmFsdWUoZGF0YU5vZGUsIG5hbWUsIHR5cGUsIHZhbHVlKSB7XHJcbiAgICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlckVudHJ5KHR5cGUsIG5ldyBYQy5UWVBFRF9BUlJBWV9NQVBbdHlwZV0odmFsdWUpKTtcclxuICAgIHZhciBpbnB1dE5vZGUgPSBuZXcgSW5wdXROb2RlKCk7XHJcbiAgICBpbnB1dE5vZGUuZGF0YSA9IGJ1ZmZlcjtcclxuICAgIGlucHV0Tm9kZS5uYW1lID0gbmFtZTtcclxuICAgIGRhdGFOb2RlLmFwcGVuZENoaWxkKGlucHV0Tm9kZSk7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgQWJzdHJhY3RDYW1lcmFNb2RlbDogQWJzdHJhY3RDYW1lcmFNb2RlbCwgUGVyc3BlY3RpdmVDYW1lcmFNb2RlbDogUGVyc3BlY3RpdmVDYW1lcmFNb2RlbCwgUHJvamVjdGl2ZUNhbWVyYU1vZGVsOiBQcm9qZWN0aXZlQ2FtZXJhTW9kZWxcclxufTtcclxuIiwidmFyIE1vdXNlRXZlbnRzID0gcmVxdWlyZShcIi4vZXZlbnRzL21vdXNlLmpzXCIpO1xyXG52YXIgVG91Y2hFdmVudHMgPSByZXF1aXJlKFwiLi9ldmVudHMvdG91Y2guanNcIik7XHJcblxyXG52YXIgY19nbG9iYWxDYW52YXNJZCA9IDA7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtFbGVtZW50fSB4bWwzZEVsZW1lbnRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBBYnN0cmFjdENhbnZhc0hhbmRsZXIoeG1sM2RFbGVtZW50LCBjYW52YXMpIHtcclxuICAgIHRoaXMuX3htbDNkRWxlbWVudCA9IHhtbDNkRWxlbWVudDtcclxuICAgIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcclxuICAgIHRoaXMuaWQgPSArK2NfZ2xvYmFsQ2FudmFzSWQ7IC8vIGdsb2JhbCBjYW52YXMgaWQgc3RhcnRzIGF0IDFcclxuXHJcbiAgICB0aGlzLl9tb3VzZUhhbmRsZXIgPSBuZXcgTW91c2VFdmVudHMuTW91c2VFdmVudEhhbmRsZXIoeG1sM2RFbGVtZW50LCB0aGlzKTtcclxuICAgIHRoaXMuX3JlZ2lzdGVyQ2FudmFzTGlzdGVuZXJzKHRoaXMuX21vdXNlSGFuZGxlciwgTW91c2VFdmVudHMuRVZFTlRTKTtcclxuICAgIGlmKHRoaXMuaGFzVG91Y2hFdmVudHMoKSkge1xyXG4gICAgICAgIHRoaXMuX3RvdWNoSGFuZGxlciA9IG5ldyBUb3VjaEV2ZW50cy5Ub3VjaEV2ZW50SGFuZGxlcih4bWwzZEVsZW1lbnQsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyQ2FudmFzTGlzdGVuZXJzKHRoaXMuX3RvdWNoSGFuZGxlciwgVG91Y2hFdmVudHMuRVZFTlRTKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuQWJzdHJhY3RDYW52YXNIYW5kbGVyLnByb3RvdHlwZS5oYXNUb3VjaEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdztcclxufTtcclxuXHJcbkFic3RyYWN0Q2FudmFzSGFuZGxlci5wcm90b3R5cGUuZ2V0Q2FudmFzID0gZnVuY3Rpb24oKSB7XHJcbiAgIHJldHVybiB0aGlzLl9jYW52YXM7XHJcbn07XHJcblxyXG5BYnN0cmFjdENhbnZhc0hhbmRsZXIucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgdGhpcy5feG1sM2RFbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG59O1xyXG5cclxuQWJzdHJhY3RDYW52YXNIYW5kbGVyLnByb3RvdHlwZS5fcmVnaXN0ZXJDYW52YXNMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoaGFuZGxlciwgZXZlbnRzKSB7XHJcbiAgICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzO1xyXG4gICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBoYW5kbGVyW25hbWVdICYmIGhhbmRsZXJbbmFtZV0uY2FsbChoYW5kbGVyLCBlKTtcclxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuQWJzdHJhY3RDYW52YXNIYW5kbGVyLnByb3RvdHlwZS5kaXNwYXRjaEN1c3RvbUV2ZW50ID0gZnVuY3Rpb24odHlwZSwgZGV0YWlsKSB7XHJcbiAgICBkZXRhaWwgPSBkZXRhaWwgfHwgbnVsbDtcclxuICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xyXG4gICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KHR5cGUsIHRydWUsIHRydWUsIGRldGFpbCk7XHJcbiAgICB0aGlzLl94bWwzZEVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbn07XHJcblxyXG5BYnN0cmFjdENhbnZhc0hhbmRsZXIucHJvdG90eXBlLmRpc3BhdGNoUmVzaXplRXZlbnQgPSBmdW5jdGlvbiAoZGltZW5zaW9ucykge1xyXG4gICAgdGhpcy5kaXNwYXRjaEN1c3RvbUV2ZW50KFwicmVzaXplXCIsIGRpbWVuc2lvbnMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERpc3BhdGNoZXMgYSBGcmFtZURyYXduRXZlbnQgdG8gbGlzdGVuZXJzXHJcbiAqXHJcbiAqIEBwYXJhbSBzdGFydFxyXG4gKiBAcGFyYW0gZW5kXHJcbiAqIEBwYXJhbSBzdGF0c1xyXG4gKiBAcmV0dXJuXHJcbiAqL1xyXG5BYnN0cmFjdENhbnZhc0hhbmRsZXIucHJvdG90eXBlLmRpc3BhdGNoRnJhbWVEcmF3bkV2ZW50ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHN0YXRzKSB7XHJcbiAgICBzdGF0cyA9IHN0YXRzIHx8IHtcclxuICAgICAgICBjb3VudDoge1xyXG4gICAgICAgICAgICBwcmltaXRpdmVzOiAwLCBvYmplY3RzOiAwXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBkYXRhID0ge1xyXG4gICAgICAgIHRpbWVTdGFydDogc3RhcnQsIHRpbWVFbmQ6IGVuZCwgcmVuZGVyVGltZUluTWlsbGlzZWNvbmRzOiBlbmQgLSBzdGFydCwgY291bnQ6IHN0YXRzLmNvdW50XHJcbiAgICB9O1xyXG4gICAgdGhpcy5kaXNwYXRjaEN1c3RvbUV2ZW50KFwiZnJhbWVkcmF3blwiLCBkYXRhKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWJzdHJhY3RDYW52YXNIYW5kbGVyO1xyXG4iLCJ2YXIgZmFjdG9yeSA9IHJlcXVpcmUoXCIuL3JlbmRlcmVyLWZhY3RvcnkuanNcIik7XHJcblxyXG52YXIgY29uZmlndXJlID0gZnVuY3Rpb24oeG1sM2RzKSB7XHJcbiAgICBpZiAoISh4bWwzZHMgaW5zdGFuY2VvZiBBcnJheSkpXHJcbiAgICAgICAgeG1sM2RzID0gW3htbDNkc107XHJcblxyXG4gICAgeG1sM2RzLmZvckVhY2goZnVuY3Rpb24oeG1sM2RFbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKHhtbDNkRWxlbWVudC5fY29uZmlndXJlZC5jYW52YXNIYW5kbGVyLnJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgZWxlbWVudCBoYXMgYWxyZWFkeSBiZWVuIGNvbmZpZ3VyZWRcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dEZWJ1ZyhcIkNvbmZpZ3VyaW5nIFJlbmRlcmVyIGZvclwiLCB4bWwzZEVsZW1lbnQuaWQpO1xyXG4gICAgICAgIHZhciByZW5kZXJlciA9IGZhY3RvcnkuY3JlYXRlUmVuZGVyZXIoeG1sM2RFbGVtZW50KVxyXG5cclxuICAgIH0pO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjb25maWd1cmU7IiwidmFyIE9wdGlvbnMgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvb3B0aW9ucy5qc1wiKTtcclxuXHJcbnZhciBPUFRJT05fTU9VU0VNT1ZFX1BJQ0tJTkcgPSBcInJlbmRlcmVyLW1vdXNlbW92ZS1waWNraW5nXCI7XHJcbnZhciBPUFRJT05fTU9WRU1FTlRfQVdBUkVfQ0xJQ0tfSEFORExFUiA9IFwicmVuZGVyZXItbW92ZW1lbnQtYXdhcmUtY2xpY2staGFuZGxlclwiO1xyXG5PcHRpb25zLnJlZ2lzdGVyKE9QVElPTl9NT1VTRU1PVkVfUElDS0lORywgdHJ1ZSk7XHJcbk9wdGlvbnMucmVnaXN0ZXIoT1BUSU9OX01PVkVNRU5UX0FXQVJFX0NMSUNLX0hBTkRMRVIsIGZhbHNlKTtcclxuXHJcbnZhciBFVkVOVFMgPSBbXCJjbGlja1wiLCBcImRibGNsaWNrXCIsIFwibW91c2Vkb3duXCIsIFwibW91c2V1cFwiLCBcIm1vdXNlb3ZlclwiLCBcIm1vdXNlbW92ZVwiLCBcIm1vdXNlb3V0XCIsIFwid2hlZWxcIl07XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSBkZWZhdWx0VGFyZ2V0XHJcbiAqIEBwYXJhbSB7QWJzdHJhY3RDYW52YXNIYW5kbGVyfSBjYW52YXNIYW5kbGVyXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIE1vdXNlRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24oZGVmYXVsdFRhcmdldCwgY2FudmFzSGFuZGxlcikge1xyXG4gICAgdGhpcy5fZGVmYXVsdFRhcmdldCA9IGRlZmF1bHRUYXJnZXQ7XHJcbiAgICB0aGlzLl9jYW52YXNIYW5kbGVyID0gY2FudmFzSGFuZGxlcjtcclxuICAgIHRoaXMuX2xhc3RNb3VzZVBvc2l0aW9uID0gIHt4OiAwLCB5OiAwfTtcclxufTtcclxuXHJcbnZhciBzdXBwb3J0c0V2ZW50Q29uc3RydWN0b3JzID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBuZXcgTW91c2VFdmVudChcImNsaWNrXCIsIHt9KTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gY2F0Y2ggKGUpe1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufSkoKTtcclxuXHJcbk1vdXNlRXZlbnRIYW5kbGVyLnByb3RvdHlwZSA9ICB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50ICBUaGUgb3JpZ2luYWwgZXZlbnRcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0ICB0YXJnZXQgdG8gZGlzcGF0Y2ggb25cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0P30gICAgIG9wdCAgICBPcHRpb25zXHJcbiAgICAgKi9cclxuICAgIGRpc3BhdGNoTW91c2VFdmVudDogZnVuY3Rpb24gKGV2ZW50LCB0YXJnZXQsIG9wdCkge1xyXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcclxuICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgdGhpcy5fZGVmYXVsdFRhcmdldDtcclxuICAgICAgICB2YXIgeCA9IG9wdC54ICE9PSB1bmRlZmluZWQgPyBvcHQueCA6IGV2ZW50LmNsaWVudFg7XHJcbiAgICAgICAgdmFyIHkgPSBvcHQueSAhPT0gdW5kZWZpbmVkID8gb3B0LnkgOiBldmVudC5jbGllbnRZO1xyXG4gICAgICAgIHZhciBub0NvcHkgPSBvcHQubm9Db3B5IHx8IGZhbHNlO1xyXG4gICAgICAgIC8vIENvcHkgZXZlbnQgdG8gYXZvaWQgRE9NIGRpc3BhdGNoIGVycm9ycyAoY2Fubm90IGRpc3BhdGNoIGV2ZW50IG1vcmVcclxuICAgICAgICAvLyB0aGFuIG9uY2UpXHJcbiAgICAgICAgaWYgKCFub0NvcHkpIHtcclxuICAgICAgICAgICAgZXZlbnQgPSB0aGlzLmNvcHlNb3VzZUV2ZW50KGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbml0RXh0ZW5kZWRNb3VzZUV2ZW50KGV2ZW50LCB4LCB5KTtcclxuXHJcbiAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudHxXaGVlbEV2ZW50fSBldmVudCB0aGUgZXZlbnQgdG8gY29weVxyXG4gICAgICogQHJldHVybiB7TW91c2VFdmVudH0gdGhlIG5ldyBldmVudFxyXG4gICAgICovXHJcbiAgICBjb3B5TW91c2VFdmVudDogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgdmFyIGV2dDtcclxuICAgICAgICBpZiAoc3VwcG9ydHNFdmVudENvbnN0cnVjdG9ycykge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQudG9TdHJpbmcoKSA9PT0gXCJbb2JqZWN0IFdoZWVsRXZlbnRdXCIpIHtcclxuICAgICAgICAgICAgICAgIGV2dCA9IG5ldyBXaGVlbEV2ZW50KGV2ZW50LnR5cGUsIGV2ZW50KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV2dCA9IG5ldyBNb3VzZUV2ZW50KGV2ZW50LnR5cGUsIGV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vVGhlc2UgZXZlbnQgQVBJcyBhcmUgZGVwcmVjYXRlZCBidXQgc3RpbGwgcmVxdWlyZWQgYnkgSUUsIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBldmVudCBjb25zdHJ1Y3RvcnMgeWV0XHJcbiAgICAgICAgICAgIGlmIChldmVudC50b1N0cmluZygpID09PSBcIltvYmplY3QgV2hlZWxFdmVudF1cIikge1xyXG4gICAgICAgICAgICAgICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJXaGVlbEV2ZW50XCIpO1xyXG4gICAgICAgICAgICAgICAgZXZ0LmluaXRXaGVlbEV2ZW50KGV2ZW50LnR5cGUsIGV2ZW50LmJ1YmJsZXMsIGV2ZW50LmNhbmNlbGFibGUsIGV2ZW50LnZpZXcsIGV2ZW50LmRldGFpbCxcclxuICAgICAgICAgICAgICAgICAgICBldmVudC5zY3JlZW5YLCBldmVudC5zY3JlZW5ZLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZLCBldmVudC5idXR0b24sIGV2ZW50LnJlbGF0ZWRUYXJnZXQsIFwiXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGVsdGFYLCBldmVudC5kZWx0YVksIGV2ZW50LmRlbHRhWiwgZXZlbnQuZGVsdGFNb2RlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudFwiKTtcclxuICAgICAgICAgICAgICAgIGV2dC5pbml0TW91c2VFdmVudChldmVudC50eXBlLCBldmVudC5idWJibGVzLCBldmVudC5jYW5jZWxhYmxlLCBldmVudC52aWV3LCBldmVudC5kZXRhaWwsXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc2NyZWVuWCwgZXZlbnQuc2NyZWVuWSwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSwgZXZlbnQuY3RybEtleSwgZXZlbnQuYWx0S2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnNoaWZ0S2V5LCBldmVudC5tZXRhS2V5LCBldmVudC5idXR0b24sIGV2ZW50LnJlbGF0ZWRUYXJnZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChldmVudC5kYXRhVHJhbnNmZXIpXHJcbiAgICAgICAgICAgIGV2dC5kYXRhID0ge3VybDogZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJVUkxcIiksIHRleHQ6IGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwiVGV4dFwiKX07XHJcbiAgICAgICAgLy8gb3ZlcnJpZGUgcHJldmVudERlZmF1bHQgdG8gYWN0dWFsbHkgcHJldmVudCB0aGUgZGVmYXVsdCBvZiB0aGUgb3JpZ2luYWwgZXZlbnRcclxuICAgICAgICBldnQucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gZXZ0O1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVNb3VzZUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgb3B0cykge1xyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xyXG4gICAgICAgIHZhciBkaWN0ID0ge1xyXG4gICAgICAgICAgICBidWJibGVzXHRcdDogb3B0cy5idWJibGVzICE9PSB1bmRlZmluZWQgPyBvcHRzLmJ1YmJsZXMgOiB0cnVlLFxyXG4gICAgICAgICAgICBjYW5jZWxhYmxlIFx0OiBvcHRzLmNhbmNlbGFibGUgIT09IHVuZGVmaW5lZCA/IG9wdHMuY2FuY2VsYWJsZSA6IHRydWUsXHJcbiAgICAgICAgICAgIHZpZXcgXHRcdDogb3B0cy52aWV3IHx8IHdpbmRvdyxcclxuICAgICAgICAgICAgZGV0YWlsIFx0XHQ6IG9wdHMuZGV0YWlsICE9PSB1bmRlZmluZWQgPyBvcHRzLmRldGFpbCA6IDAsXHJcbiAgICAgICAgICAgIHNjcmVlblhcdFx0OiBvcHRzLnNjcmVlblggIT09IHVuZGVmaW5lZCA/IG9wdHMuc2NyZWVuWCA6IDAsXHJcbiAgICAgICAgICAgIHNjcmVlbllcdFx0OiBvcHRzLnNjcmVlblkgIT09IHVuZGVmaW5lZCA/IG9wdHMuc2NyZWVuWSA6IDAsXHJcbiAgICAgICAgICAgIGNsaWVudFhcdFx0OiBvcHRzLmNsaWVudFggIT09IHVuZGVmaW5lZCA/IG9wdHMuY2xpZW50WCA6IDAsXHJcbiAgICAgICAgICAgIGNsaWVudFlcdFx0OiBvcHRzLmNsaWVudFkgIT09IHVuZGVmaW5lZCA/IG9wdHMuY2xpZW50WSA6IDAsXHJcbiAgICAgICAgICAgIGN0cmwgXHRcdDogb3B0cy5jdHJsICE9PSB1bmRlZmluZWQgPyBvcHRzLmN0cmwgOiBmYWxzZSxcclxuICAgICAgICAgICAgYWx0IFx0XHQ6IG9wdHMuYWx0ICE9PSB1bmRlZmluZWQgPyBvcHRzLmFsdCA6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaGlmdCBcdFx0OiBvcHRzLnNoaWZ0ICE9PSB1bmRlZmluZWQgPyBvcHRzLnNoaWZ0IDogZmFsc2UsXHJcbiAgICAgICAgICAgIG1ldGEgXHRcdDogb3B0cy5tZXRhICE9PSB1bmRlZmluZWQgPyBvcHRzLm1ldGEgOiBmYWxzZSxcclxuICAgICAgICAgICAgYnV0dG9uIFx0XHQ6IG9wdHMuYnV0dG9uICE9PSB1bmRlZmluZWQgPyBvcHRzLmJ1dHRvbiA6IDAsXHJcbiAgICAgICAgICAgIHJlbGF0ZWRUYXJnZXQgOiBvcHRzLnJlbGF0ZWRUYXJnZXRcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChzdXBwb3J0c0V2ZW50Q29uc3RydWN0b3JzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW91c2VFdmVudCh0eXBlLCBkaWN0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50XCIpO1xyXG4gICAgICAgICAgICBldnQuaW5pdE1vdXNlRXZlbnQodHlwZSwgZGljdC5idWJibGVzLCBkaWN0LmNhbmNlbGFibGUsIGRpY3QudmlldywgZGljdC5kZXRhaWwsXHJcbiAgICAgICAgICAgICAgICBkaWN0LnNjcmVlblgsIGRpY3Quc2NyZWVuWSwgZGljdC5jbGllbnRYLCBkaWN0LmNsaWVudFksIGRpY3QuY3RybEtleSwgZGljdC5hbHRLZXksXHJcbiAgICAgICAgICAgICAgICBkaWN0LnNoaWZ0S2V5LCBkaWN0Lm1ldGFLZXksIGRpY3QuYnV0dG9uLCBkaWN0LnJlbGF0ZWRUYXJnZXQpO1xyXG4gICAgICAgICAgICByZXR1cm4gZXZ0O1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHBvc2l0aW9uIGFuZCBub3JtYWwgYXR0cmlidXRlcyB0byB0aGUgZ2l2ZW4gZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxyXG4gICAgICogQHJldHVybiB7WE1MM0QuVmVjM31cclxuICAgICAqL1xyXG4gICAgaW5pdEV4dGVuZGVkTW91c2VFdmVudDogZnVuY3Rpb24gKGV2ZW50LCB4LCB5KSB7XHJcbiAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9jYW52YXNIYW5kbGVyO1xyXG5cclxuICAgICAgICAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY2FjaGVkUG9zaXRpb24gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHZhciBjYWNoZWROb3JtYWwgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnQsIFwibm9ybWFsXCIsIHtcclxuICAgICAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FjaGVkTm9ybWFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3JtID0gKGhhbmRsZXIuZ2V0V29ybGRTcGFjZU5vcm1hbEJ5UG9pbnQoeCwgeSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWROb3JtYWwgPSBub3JtIHx8IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWROb3JtYWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV2ZW50LCBcInBvc2l0aW9uXCIsIHtcclxuICAgICAgICAgICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FjaGVkUG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IGhhbmRsZXIuZ2V0V29ybGRTcGFjZVBvc2l0aW9uQnlQb2ludCh4LCB5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkUG9zaXRpb24gPSBwb3MgfHwgbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZ0XHJcbiAgICAgKiBAcGFyYW0ge29iamVjdD99IG9wdFxyXG4gICAgICovXHJcbiAgICBkaXNwYXRjaE1vdXNlRXZlbnRPblBpY2tlZE9iamVjdDogZnVuY3Rpb24gKGV2dCwgb3B0KSB7XHJcbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xyXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLmdldE1vdXNlUG9zaXRpb24oZXZ0KTtcclxuXHJcbiAgICAgICAgdmFyIHBpY2tlZCA9IG51bGw7XHJcbiAgICAgICAgaWYgKCFvcHQub21pdFVwZGF0ZSlcclxuICAgICAgICAgICAgcGlja2VkID0gdGhpcy5fY2FudmFzSGFuZGxlci5nZXRQaWNrT2JqZWN0QnlQb2ludChwb3MueCwgcG9zLnkpO1xyXG5cclxuICAgICAgICB0aGlzLmRpc3BhdGNoTW91c2VFdmVudChldnQsIHBpY2tlZCAmJiBwaWNrZWQubm9kZSwgcG9zKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0TW91c2VQb3NpdGlvbjogZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXNIYW5kbGVyLmdldE1vdXNlUG9zaXRpb24oZXZ0KVxyXG4gICAgfSxcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2dFxyXG4gICAgICovXHJcbiAgICBtb3VzZXVwOiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaE1vdXNlRXZlbnRPblBpY2tlZE9iamVjdChldnQpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZ0XHJcbiAgICAgKi9cclxuICAgIG1vdXNlZG93bjogZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIHRoaXMuX2xhc3RNb3VzZVBvc2l0aW9uID0gdGhpcy5nZXRNb3VzZVBvc2l0aW9uKGV2dCk7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaE1vdXNlRXZlbnRPblBpY2tlZE9iamVjdChldnQpO1xyXG4gICAgfSxcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2dFxyXG4gICAgICovXHJcbiAgICBjbGljazogZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIGlmIChPcHRpb25zLmdldFZhbHVlKFwicmVuZGVyZXItbW92ZW1lbnQtYXdhcmUtY2xpY2staGFuZGxlclwiKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRNb3VzZVBvc2l0aW9uKGV2dCk7XHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhwb3MueCAtIHRoaXMuX2xhc3RNb3VzZVBvc2l0aW9uLngpID4gNCB8fCBNYXRoLmFicyhwb3MueSAtIHRoaXMuX2xhc3RNb3VzZVBvc2l0aW9uLnkpID4gNClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaE1vdXNlRXZlbnRPblBpY2tlZE9iamVjdChldnQpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZ0XHJcbiAgICAgKi9cclxuICAgIGRibGNsaWNrOiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaE1vdXNlRXZlbnRPblBpY2tlZE9iamVjdChldnQpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBlYWNoIHRpbWUgYSBtb3VzZU1vdmUgZXZlbnQgaXMgdHJpZ2dlcmVkIG9uIHRoZVxyXG4gICAgICogY2FudmFzLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGFsc28gdHJpZ2dlcnMgbW91c2VvdmVyIGFuZCBtb3VzZW91dCBldmVudHMgb2Ygb2JqZWN0cyBpbiB0aGVcclxuICAgICAqIHNjZW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZ0XHJcbiAgICAgKi9cclxuICAgIG1vdXNlbW92ZTogZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLmdldE1vdXNlUG9zaXRpb24oZXZ0KTtcclxuXHJcbiAgICAgICAgdmFyIGRvTW91c2VNb3ZlUGljayA9IE9wdGlvbnMuZ2V0VmFsdWUoT1BUSU9OX01PVVNFTU9WRV9QSUNLSU5HKTtcclxuXHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaE1vdXNlRXZlbnRPblBpY2tlZE9iamVjdChldnQsIHtvbWl0VXBkYXRlOiAhZG9Nb3VzZU1vdmVQaWNrfSk7XHJcbiAgICAgICAgaWYgKCFkb01vdXNlTW92ZVBpY2spXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgdmFyIGN1ck9iaiA9IHRoaXMuX2NhbnZhc0hhbmRsZXIuZ2V0UGlja2VkT2JqZWN0KCk7XHJcblxyXG4gICAgICAgIC8vIHRyaWdnZXIgbW91c2VvdmVyIGFuZCBtb3VzZW91dFxyXG4gICAgICAgIGlmIChjdXJPYmogIT09IHRoaXMubGFzdFBpY2tPYmopIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGFzdFBpY2tPYmopIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBtb3VzZSBoYXMgbGVmdCB0aGUgbGFzdCBvYmplY3RcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hNb3VzZUV2ZW50KHRoaXMuY3JlYXRlTW91c2VFdmVudChcIm1vdXNlb3V0XCIsIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiBwb3MueCwgY2xpZW50WTogcG9zLnksIGJ1dHRvbjogZXZ0LmJ1dHRvblxyXG4gICAgICAgICAgICAgICAgfSksIHRoaXMubGFzdFBpY2tPYmopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjdXJPYmopIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBtb3VzZSBpcyBub3cgb3ZlciBhIGRpZmZlcmVudCBvYmplY3QsIHNvIGNhbGwgdGhlIG5ld1xyXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0J3MgbW91c2VvdmVyIG1ldGhvZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaE1vdXNlRXZlbnQodGhpcy5jcmVhdGVNb3VzZUV2ZW50KFwibW91c2VvdmVyXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiBwb3MueCwgY2xpZW50WTogcG9zLnksIGJ1dHRvbjogZXZ0LmJ1dHRvblxyXG4gICAgICAgICAgICAgICAgfSksIGN1ck9iaik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMubGFzdFBpY2tPYmogPSBjdXJPYmo7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZ0XHJcbiAgICAgKi9cclxuICAgIG1vdXNlb3V0OiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0TW91c2VQb3NpdGlvbihldnQpO1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hNb3VzZUV2ZW50KGV2dCwgdGhpcy5sYXN0UGlja09iaiwgcG9zKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2dFxyXG4gICAgICovXHJcbiAgICBtb3VzZW92ZXI6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICB2YXIgZG9Nb3VzZU1vdmVQaWNrID0gT3B0aW9ucy5nZXRWYWx1ZShPUFRJT05fTU9VU0VNT1ZFX1BJQ0tJTkcpO1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hNb3VzZUV2ZW50T25QaWNrZWRPYmplY3QoZXZ0LCB7b21pdFVwZGF0ZTogIWRvTW91c2VNb3ZlUGlja30pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7V2hlZWxFdmVudH0gZXZ0XHJcbiAgICAgKi9cclxuICAgIHdoZWVsOiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaE1vdXNlRXZlbnRPblBpY2tlZE9iamVjdChldnQsIHsgdHlwZTogXCJ3aGVlbFwiIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIEVWRU5UUzogRVZFTlRTLCBNb3VzZUV2ZW50SGFuZGxlcjogTW91c2VFdmVudEhhbmRsZXJcclxufTtcclxuIiwiLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZGVmYXVsdFRhcmdldFxyXG4gKiBAcGFyYW0ge0Fic3RyYWN0Q2FudmFzSGFuZGxlcn0gY2FudmFzSGFuZGxlclxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBUb3VjaEV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChkZWZhdWx0VGFyZ2V0LCBjYW52YXNIYW5kbGVyKSB7XHJcbiAgICB0aGlzLl9kZWZhdWx0VGFyZ2V0ID0gZGVmYXVsdFRhcmdldDtcclxuICAgIHRoaXMuX2NhbnZhc0hhbmRsZXIgPSBjYW52YXNIYW5kbGVyO1xyXG59O1xyXG5cclxuXHJcbnZhciBFVkVOVFMgPSBbXCJ0b3VjaHN0YXJ0XCIsIFwidG91Y2htb3ZlXCIsIFwidG91Y2hlbmRcIiwgXCJ0b3VjaGNhbmNlbFwiXTtcclxudmFyIHVhID0gL2lQaG9uZXxpUFtvYV1kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpID8gJ2lPUycgOiAvQW5kcm9pZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSA/ICdBbmRyb2lkJyA6ICdQQyc7XHJcblxyXG5Ub3VjaEV2ZW50SGFuZGxlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgY29weVRvdWNoRXZlbnQ6IGZ1bmN0aW9uIChldmVudCwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciB0b3VjaEV2ZW50RGF0YSA9IHRoaXMuY29weVRvdWNoRXZlbnREYXRhKGV2ZW50LCBvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUb3VjaEV2ZW50KHRvdWNoRXZlbnREYXRhKTtcclxuICAgIH0sXHJcblxyXG5cclxuICAgIGNvcHlUb3VjaEV2ZW50RGF0YTogZnVuY3Rpb24gKGV2ZW50LCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogb3B0aW9ucy50eXBlIHx8IGV2ZW50LnR5cGUsXHJcbiAgICAgICAgICAgIHRpbWVTdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgICAgYnViYmxlczogZXZlbnQuYnViYmxlcyxcclxuICAgICAgICAgICAgY2FuY2VsYWJsZTogZXZlbnQuY2FuY2VsYWJsZSxcclxuICAgICAgICAgICAgZGV0YWlsOiBldmVudC5kZXRhaWwsXHJcbiAgICAgICAgICAgIHNjcmVlblg6IGV2ZW50LnNjcmVlblgsXHJcbiAgICAgICAgICAgIHNjcmVlblk6IGV2ZW50LnNjcmVlblksXHJcbiAgICAgICAgICAgIHBhZ2VYOiBldmVudC5wYWdlWCxcclxuICAgICAgICAgICAgcGFnZVk6IGV2ZW50LnBhZ2VZLFxyXG4gICAgICAgICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICAgICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICAgICAgICBjdHJsS2V5OiBldmVudC5jdHJsS2V5LFxyXG4gICAgICAgICAgICBhbHRLZXk6IGV2ZW50LmFsdEtleSxcclxuICAgICAgICAgICAgc2hpZnRLZXk6IGV2ZW50LnNoaWZ0S2V5LFxyXG4gICAgICAgICAgICBtZXRhS2V5OiBldmVudC5tZXRhS2V5LFxyXG4gICAgICAgICAgICBzY2FsZTogZXZlbnQuc2NhbGUsXHJcbiAgICAgICAgICAgIHJvdGF0aW9uOiBldmVudC5yb3RhdGlvbixcclxuICAgICAgICAgICAgdmlldzogZXZlbnQudmlldyxcclxuICAgICAgICAgICAgdG91Y2hlczogZXZlbnQudG91Y2hlcyxcclxuICAgICAgICAgICAgY2hhbmdlZFRvdWNoZXM6IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxyXG4gICAgICAgICAgICB0YXJnZXRUb3VjaGVzOiBldmVudC50YXJnZXRUb3VjaGVzXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlVG91Y2hFdmVudDogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB2YXIgdG91Y2hFdmVudDtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdG91Y2hFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdUb3VjaEV2ZW50Jyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiQ3JlYXRlIFRvdWNoIEV2ZW50IGZhaWxlZCwgY3JlYXRpbmcgVUkgaW5zdGVhZFwiKTtcclxuICAgICAgICAgICAgdG91Y2hFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdVSUV2ZW50Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodG91Y2hFdmVudCAmJiB0b3VjaEV2ZW50LmluaXRUb3VjaEV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmICh0b3VjaEV2ZW50LmluaXRUb3VjaEV2ZW50Lmxlbmd0aCA9PSAwICYmIHVhICE9PSBcImlPU1wiKSB7IC8vY2hyb21lXHJcbiAgICAgICAgICAgICAgICB0b3VjaEV2ZW50LmluaXRUb3VjaEV2ZW50KGRhdGEudG91Y2hlcywgZGF0YS50YXJnZXRUb3VjaGVzLCBkYXRhLmNoYW5nZWRUb3VjaGVzLCBkYXRhLnR5cGUsIGRhdGEudmlldywgZGF0YS5zY3JlZW5YLCBkYXRhLnNjcmVlblksIGRhdGEuY2xpZW50WCwgZGF0YS5jbGllbnRZKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0b3VjaEV2ZW50LmluaXRUb3VjaEV2ZW50Lmxlbmd0aCA9PSAxMikgeyAvL2ZpcmVmb3hcclxuICAgICAgICAgICAgICAgIHRvdWNoRXZlbnQuaW5pdFRvdWNoRXZlbnQoZGF0YS50eXBlLCBkYXRhLmJ1YmJsZXMsIGRhdGEuY2FuY2VsYWJsZSwgZGF0YS52aWV3LCBkYXRhLmRldGFpbCwgZGF0YS5jdHJsS2V5LCBkYXRhLmFsdEtleSwgZGF0YS5zaGlmdEtleSwgZGF0YS5tZXRhS2V5LCBkYXRhLnRvdWNoZXMsIGRhdGEudGFyZ2V0VG91Y2hlcywgZGF0YS5jaGFuZ2VkVG91Y2hlcyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vaU9TIGxlbmd0aCA9IDE4XHJcbiAgICAgICAgICAgICAgICB0b3VjaEV2ZW50LmluaXRUb3VjaEV2ZW50KGRhdGEudHlwZSwgZGF0YS5idWJibGVzLCBkYXRhLmNhbmNlbGFibGUsIGRhdGEudmlldywgZGF0YS5kZXRhaWwsIGRhdGEuc2NyZWVuWCwgZGF0YS5zY3JlZW5ZLCBkYXRhLnBhZ2VYLCBkYXRhLnBhZ2VZLCBkYXRhLmN0cmxLZXksIGRhdGEuYWx0S2V5LCBkYXRhLnNoaWZ0S2V5LCBkYXRhLm1ldGFLZXksIGRhdGEudG91Y2hlcywgZGF0YS50YXJnZXRUb3VjaGVzLCBkYXRhLmNoYW5nZWRUb3VjaGVzLCBkYXRhLnNjYWxlLCBkYXRhLnJvdGF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG91Y2hFdmVudDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldnRcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0P30gb3B0XHJcbiAgICAgKi9cclxuICAgIGRpc3BhdGNoVG91Y2hFdmVudE9uUGlja2VkT2JqZWN0OiBmdW5jdGlvbiAoZXZ0LCBvcHQpIHtcclxuICAgICAgICBvcHQgPSBvcHQgfHwge307XHJcbiAgICAgICAgdmFyIHRvdWNoRXZlbnQgPSB0aGlzLmNvcHlUb3VjaEV2ZW50KGV2dCwgb3B0KTtcclxuICAgICAgICB0b3VjaEV2ZW50LnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX2RlZmF1bHRUYXJnZXQuZGlzcGF0Y2hFdmVudCh0b3VjaEV2ZW50KTtcclxuICAgIH0sXHJcblxyXG4gICAgdG91Y2hzdGFydDogZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hUb3VjaEV2ZW50T25QaWNrZWRPYmplY3QoZXZ0KTtcclxuICAgIH0sXHJcblxyXG4gICAgdG91Y2hlbmQ6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoVG91Y2hFdmVudE9uUGlja2VkT2JqZWN0KGV2dCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHRvdWNobW92ZTogZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hUb3VjaEV2ZW50T25QaWNrZWRPYmplY3QoZXZ0KTtcclxuICAgIH0sXHJcblxyXG4gICAgdG91Y2hjYW5jZWw6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoVG91Y2hFdmVudE9uUGlja2VkT2JqZWN0KGV2dCk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgRVZFTlRTOiBFVkVOVFMsIFRvdWNoRXZlbnRIYW5kbGVyOiBUb3VjaEV2ZW50SGFuZGxlclxyXG59O1xyXG4iLCJmdW5jdGlvbiBMaWdodE1hbmFnZXIoKSB7XHJcbiAgICB0aGlzLl9saWdodHMgPSBbXTtcclxuICAgIHRoaXMuX21vZGVscyA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRpbmcgbGlnaHQgcGFyYW1ldGVycyBjYW4gbGVhZCB0byB1cGRhdGluZyB0aGUgKGxhenkpIHNjZW5lIHN0cnVjdHVyZSwgd2hpY2hcclxuICAgICAqIGluIHR1cm4gdXBkYXRlcyB0aGUgbGlnaHRzLiBJZiB3ZSBhcmUgaW4gdXBkYXRpbmcgdGhlIGxpZ2h0cywgZmxhZyBpcyBzZXQgdG8gdHJ1ZS5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5faW5VcGRhdGUgPSBmYWxzZTtcclxufVxyXG5cclxuTGlnaHRNYW5hZ2VyLnByb3RvdHlwZSA9IHtcclxuICAgIGFkZDogZnVuY3Rpb24gKGxpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5fbGlnaHRzLnB1c2gobGlnaHQpO1xyXG4gICAgICAgIHRoaXMuX2FkZE1vZGVsKGxpZ2h0Lm1vZGVsKTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAobGlnaHQpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9saWdodHMuaW5kZXhPZihsaWdodCk7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpZ2h0cy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yZW1vdmVNb2RlbChsaWdodC5tb2RlbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZpbGxHbG9iYWxQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoZ2xvYmFscywgZm9yY2UpIHtcclxuICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9tb2RlbHMpIHtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fbW9kZWxzW2lkXTtcclxuICAgICAgICAgICAgLyogRmlsbCBnbG9iYWxzIG9ubHkgaWYgdGhpcyB3YXMgbm90IGFscmVhZHkgZG9uZSBiZWZvcmUgKi9cclxuICAgICAgICAgICAgaWYgKGVudHJ5LmNoYW5nZWQgfHwgZm9yY2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcmVmaXggPSBpZCArIFwiTGlnaHRcIjtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHBhcmFtIGluIGVudHJ5LnBhcmFtZXRlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHByZWZpeCArIHBhcmFtLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcGFyYW0uc2xpY2UoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsc1tuYW1lXSA9IGVudHJ5LnBhcmFtZXRlcnNbcGFyYW1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZW50cnkuY2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBsaWdodFZhbHVlQ2hhbmdlZDogZnVuY3Rpb24gKGxpZ2h0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2luVXBkYXRlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5faW5VcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgICAgICB2YXIgbGlnaHRzID0gbGlnaHQgPyBbbGlnaHRdIDogdGhpcy5fbGlnaHRzO1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICAgICAgbGlnaHRzLmZvckVhY2goZnVuY3Rpb24obGlnaHQpIHtcclxuICAgICAgICAgICAgdmFyIG1vZGVsID0gbGlnaHQubW9kZWw7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoYXQuZ2V0TW9kZWxFbnRyeShtb2RlbC5pZCk7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBlbnRyeS5saWdodE1vZGVscy5pbmRleE9mKG1vZGVsKTtcclxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcclxuICAgICAgICAgICAgICAgIC8vVGhlc2UgY2hhbmdlcyBhcmUgZm9yIGEgbGlnaHQgdGhhdCBubyBsb25nZXIgZXhpc3RzIHNvIHdlIGNhbiBpZ25vcmUgdGhlbVxyXG4gICAgICAgICAgICAgICAgLy9UaGlzIGNhbiBoYXBwZW4gZm9yIGV4LiBkdXJpbmcgYSBkZWxheWVkIGNoYW5nZSBub3RpZmljYXRpb24gdGhhdCBpc24ndCBmaXJlZCB1bnRpbCBhZnRlciBhIHJlbW92ZSgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbW9kZWwuZmlsbExpZ2h0UGFyYW1ldGVycyhlbnRyeS5wYXJhbWV0ZXJzLCBvZmZzZXQpO1xyXG4gICAgICAgICAgICBtb2RlbC5nZXRMaWdodERhdGEoZW50cnkucGFyYW1ldGVycywgb2Zmc2V0KTtcclxuICAgICAgICAgICAgZW50cnkuY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5faW5VcGRhdGUgPSBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0TW9kZWxFbnRyeTogZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGVsc1tpZF07XHJcbiAgICB9LFxyXG5cclxuICAgIGdldE1vZGVsczogZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX21vZGVscyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldE1vZGVsQ291bnQ6IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMuZ2V0TW9kZWxFbnRyeShpZCk7XHJcbiAgICAgICAgcmV0dXJuIG1vZGVsID8gbW9kZWwubGlnaHRNb2RlbHMubGVuZ3RoIDogMDtcclxuICAgIH0sXHJcblxyXG4gICAgX2FkZE1vZGVsOiBmdW5jdGlvbiAobW9kZWwpIHtcclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9tb2RlbHNbbW9kZWwuaWRdO1xyXG4gICAgICAgIGlmICghZW50cnkpIHtcclxuICAgICAgICAgICAgZW50cnkgPSB0aGlzLl9tb2RlbHNbbW9kZWwuaWRdID0ge2xpZ2h0TW9kZWxzOiBbXSwgcGFyYW1ldGVyczoge319O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbnRyeS5saWdodE1vZGVscy5wdXNoKG1vZGVsKTtcclxuICAgICAgICB0aGlzLl9saWdodFN0cnVjdHVyZUNoYW5nZWQoZW50cnkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfcmVtb3ZlTW9kZWw6IGZ1bmN0aW9uIChtb2RlbCkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuZ2V0TW9kZWxFbnRyeShtb2RlbC5pZCk7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gZW50cnkubGlnaHRNb2RlbHMuaW5kZXhPZihtb2RlbCk7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XHJcbiAgICAgICAgICAgIGVudHJ5LmxpZ2h0TW9kZWxzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xpZ2h0U3RydWN0dXJlQ2hhbmdlZChlbnRyeSk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9saWdodFN0cnVjdHVyZUNoYW5nZWQ6IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIHRoaXMuX2luVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gZW50cnkubGlnaHRNb2RlbHMubGVuZ3RoO1xyXG4gICAgICAgIGlmICghbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGVudHJ5LnBhcmFtZXRlcnMgPSB7fTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbW9kZWwgPSBlbnRyeS5saWdodE1vZGVsc1swXTtcclxuICAgICAgICBlbnRyeS5wYXJhbWV0ZXJzID0gbW9kZWwuYWxsb2NhdGVQYXJhbWV0ZXJBcnJheShsZW5ndGgpO1xyXG4gICAgICAgIGVudHJ5LmxpZ2h0TW9kZWxzLmZvckVhY2goZnVuY3Rpb24gKGxpZ2h0TW9kZWwsIG9mZnNldCkge1xyXG4gICAgICAgICAgICBsaWdodE1vZGVsLmZpbGxMaWdodFBhcmFtZXRlcnMoZW50cnkucGFyYW1ldGVycywgb2Zmc2V0KVxyXG4gICAgICAgICAgICBsaWdodE1vZGVsLmdldExpZ2h0RGF0YShlbnRyeS5wYXJhbWV0ZXJzLCBvZmZzZXQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVudHJ5LmNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2luVXBkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaWdodE1hbmFnZXI7XHJcbiIsInZhciBGcnVzdHVtID0gcmVxdWlyZShcIi4uL3Rvb2xzL2ZydXN0dW0uanNcIikuRnJ1c3R1bTtcclxudmFyIFhDID0gcmVxdWlyZShcIi4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XHJcbnZhciBEYXRhTm9kZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvZ3JhcGguanNcIikuRGF0YU5vZGU7XHJcbnZhciBJbnB1dE5vZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2dyYXBoLmpzXCIpLklucHV0Tm9kZTtcclxudmFyIEJ1ZmZlckVudHJ5ID0gcmVxdWlyZShcIi4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9kYXRhLmpzXCIpLkJ1ZmZlckVudHJ5O1xyXG52YXIgQ29tcHV0ZVJlcXVlc3QgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL3JlcXVlc3QuanNcIikuQ29tcHV0ZVJlcXVlc3Q7XHJcbnZhciBtYXQ0ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS5tYXQ0O1xyXG52YXIgdmVjMyA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikudmVjMztcclxudmFyIHF1YXQgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLnF1YXQ7XHJcblxyXG52YXIgUG9pbnRMaWdodERhdGEgPSB7XHJcbiAgICBcImludGVuc2l0eVwiOiB7dHlwZTogWEMuREFUQV9UWVBFLkZMT0FUMywgJ2RlZmF1bHQnOiBbMSwgMSwgMV19LFxyXG4gICAgXCJhdHRlbnVhdGlvblwiOiB7dHlwZTogWEMuREFUQV9UWVBFLkZMT0FUMywgJ2RlZmF1bHQnOiBbMCwgMCwgMV19LFxyXG4gICAgXCJwb3NpdGlvblwiOiB7dHlwZTogWEMuREFUQV9UWVBFLkZMT0FUMywgJ2RlZmF1bHQnOiBbMCwgMCwgMF19LFxyXG4gICAgXCJzaGFkb3dCaWFzXCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQsICdkZWZhdWx0JzogWzAuMDAwMV19LFxyXG4gICAgXCJkaXJlY3Rpb25cIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5GTE9BVDMsICdkZWZhdWx0JzogWzAsIDAsIC0xXX0sXHJcbiAgICBcImNhc3RTaGFkb3dcIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5CT09MLCAnZGVmYXVsdCc6IFtmYWxzZV19LFxyXG4gICAgXCJvblwiOiB7dHlwZTogWEMuREFUQV9UWVBFLkJPT0wsICdkZWZhdWx0JzogW3RydWVdfSxcclxuICAgIFwibWF0cml4XCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQ0WDQsICdkZWZhdWx0JzogWzEsIDAsIDAsIDAsICAgMCwgMSwgMCwgMCwgICAgMCwgMCwgMSwgMCwgIDAsIDAsIDAsIDFdfSxcclxuICAgIFwibmVhckZhclwiOiB7dHlwZTogWEMuREFUQV9UWVBFLkZMT0FUMiwgJ2RlZmF1bHQnOiBbMS4wLCAxMDAuMF19XHJcbn07XHJcblxyXG52YXIgU3BvdExpZ2h0RGF0YSA9IHtcclxuICAgIFwiaW50ZW5zaXR5XCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQzLCAnZGVmYXVsdCc6IFsxLCAxLCAxXX0sXHJcbiAgICBcImF0dGVudWF0aW9uXCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQzLCAnZGVmYXVsdCc6IFswLCAwLCAxXX0sXHJcbiAgICBcInBvc2l0aW9uXCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQzLCAnZGVmYXVsdCc6IFswLCAwLCAwXX0sXHJcbiAgICBcImRpcmVjdGlvblwiOiB7dHlwZTogWEMuREFUQV9UWVBFLkZMT0FUMywgJ2RlZmF1bHQnOiBbMCwgMCwgLTFdfSxcclxuICAgIFwiY3V0b2ZmQW5nbGVcIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5GTE9BVCwgJ2RlZmF1bHQnOiBbTWF0aC5QSSAvIDRdfSxcclxuICAgIFwic29mdG5lc3NcIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5GTE9BVCwgJ2RlZmF1bHQnOiBbMC4wXX0sXHJcbiAgICBcInNoYWRvd0JpYXNcIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5GTE9BVCwgJ2RlZmF1bHQnOiBbMC4wMDAxXX0sXHJcbiAgICBcImNhc3RTaGFkb3dcIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5CT09MLCAnZGVmYXVsdCc6IFtmYWxzZV19LFxyXG4gICAgXCJtYXRyaXhcIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5GTE9BVDRYNCwgJ2RlZmF1bHQnOiBbMSwgMCwgMCwgMCwgICAwLCAxLCAwLCAwLCAgICAwLCAwLCAxLCAwLCAgMCwgMCwgMCwgMV19LFxyXG4gICAgXCJvblwiOiB7dHlwZTogWEMuREFUQV9UWVBFLkJPT0wsICdkZWZhdWx0JzogW3RydWVdfVxyXG59O1xyXG5cclxudmFyIERpcmVjdGlvbmFsTGlnaHREYXRhID0ge1xyXG4gICAgXCJpbnRlbnNpdHlcIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5GTE9BVDMsICdkZWZhdWx0JzogWzEsIDEsIDFdfSxcclxuICAgIFwiZGlyZWN0aW9uXCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQzLCAnZGVmYXVsdCc6IFswLCAwLCAtMV19LFxyXG4gICAgXCJzaGFkb3dCaWFzXCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQsICdkZWZhdWx0JzogWzAuMDAwMV19LFxyXG4gICAgXCJwb3NpdGlvblwiOiB7dHlwZTogWEMuREFUQV9UWVBFLkZMT0FUMywgJ2RlZmF1bHQnOiBbMCwgMCwgMF19LFxyXG4gICAgXCJjYXN0U2hhZG93XCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuQk9PTCwgJ2RlZmF1bHQnOiBbZmFsc2VdfSxcclxuICAgIFwib25cIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5CT09MLCAnZGVmYXVsdCc6IFt0cnVlXX0sXHJcbiAgICBcIm1hdHJpeFwiOiB7dHlwZTogWEMuREFUQV9UWVBFLkZMT0FUNFg0LCAnZGVmYXVsdCc6IFsxLCAwLCAwLCAwLCAgIDAsIDEsIDAsIDAsICAgIDAsIDAsIDEsIDAsICAwLCAwLCAwLCAxXX1cclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBjcmVhdGVYZmxvd0RhdGEoY29uZmlnKSB7XHJcbiAgICB2YXIgZGF0YSA9IG5ldyBEYXRhTm9kZSgpO1xyXG4gICAgZm9yICh2YXIgbmFtZSBpbiBjb25maWcpIHtcclxuICAgICAgICB2YXIgZW50cnkgPSBjb25maWdbbmFtZV07XHJcbiAgICAgICAgY3JlYXRlWGZsb3dWYWx1ZShkYXRhLCBuYW1lLCBlbnRyeS50eXBlLCBlbnRyeVsnZGVmYXVsdCddKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkYXRhO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVYZmxvd1ZhbHVlKGRhdGFOb2RlLCBuYW1lLCB0eXBlLCB2YWx1ZSkge1xyXG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXJFbnRyeSh0eXBlLCBuZXcgWEMuVFlQRURfQVJSQVlfTUFQW3R5cGVdKHZhbHVlKSk7XHJcbiAgICB2YXIgaW5wdXROb2RlID0gbmV3IElucHV0Tm9kZSgpO1xyXG4gICAgaW5wdXROb2RlLmRhdGEgPSBidWZmZXI7XHJcbiAgICBpbnB1dE5vZGUubmFtZSA9IG5hbWU7XHJcbiAgICBkYXRhTm9kZS5hcHBlbmRDaGlsZChpbnB1dE5vZGUpO1xyXG59XHJcblxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgbGlnaHQgbW9kZWxzXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbmlxdWUgaWQgdGhhdCBpZGVudGlmaWVzIHRoZSBsaWdodCBtb2RlbFxyXG4gKiBAcGFyYW0ge1JlbmRlckxpZ2h0fSBsaWdodFxyXG4gKiBAcGFyYW0ge0RhdGFOb2RlfSBkYXRhTm9kZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gdGhhdCBjb250YWlucyB0aGUgbGlnaHQgbW9kZWwncyBwYXJhbWV0ZXJzIGFuZCBkZWZhdWx0IHZhbHVlc1xyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBMaWdodE1vZGVsID0gZnVuY3Rpb24gKGlkLCBsaWdodCwgZGF0YU5vZGUsIGNvbmZpZykge1xyXG4gICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgdGhpcy5saWdodCA9IGxpZ2h0O1xyXG4gICAgdGhpcy5jb25maWd1cmF0aW9uID0gY29uZmlnO1xyXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmtleXMoY29uZmlnKTtcclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIGxpZ2h0IGhhcyBub3QgZGF0YSwganVzdCB1c2UgdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xyXG4gICAgICovXHJcbiAgICBpZiAoZGF0YU5vZGUpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IG5ldyBEYXRhTm9kZSgpO1xyXG4gICAgICAgIGRhdGEuaW5zZXJ0QmVmb3JlKGNyZWF0ZVhmbG93RGF0YShjb25maWcpLCBudWxsKTtcclxuICAgICAgICBkYXRhLmluc2VydEJlZm9yZShkYXRhTm9kZSwgbnVsbCk7XHJcbiAgICAgICAgdGhpcy5kYXRhTm9kZSA9IGRhdGE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZGF0YU5vZGUgPSBjcmVhdGVYZmxvd0RhdGEoY29uZmlnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBIb3Jpem9udGFsIG9wZW5pbmcgYW5nbGUgb2YgdGhlIGxpZ2h0IGNhbWVyYS4gRGVyaXZlZCBmcm9tIGN1dG9mZkFuZ2xlIGluIGNhc2Ugb2Ygc3BvdCBsaWdodFxyXG4gICAgdGhpcy5mb3Z5ID0gIE1hdGguUEkvMi4wO1xyXG5cclxuICAgIHRoaXMubGlnaHRQYXJhbWV0ZXJSZXF1ZXN0ID0gbmV3IENvbXB1dGVSZXF1ZXN0KHRoaXMuZGF0YU5vZGUsIHRoaXMucGFyYW1ldGVycywgdGhpcy5saWdodFBhcmFtZXRlcnNDaGFuZ2VkLmJpbmQodGhpcykpO1xyXG4gICAgdGhpcy5saWdodFBhcmFtZXRlcnNDaGFuZ2VkKHRoaXMubGlnaHRQYXJhbWV0ZXJSZXF1ZXN0LCBudWxsKTtcclxufTtcclxuXHJcbkxpZ2h0TW9kZWwucHJvdG90eXBlID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb3BpZXMgdGhlIGxpZ2h0IHBhcmFtZXRlcnMgaW4gYW4gYXJyYXkgb2YgdGhlIHNhbWUgc2l6ZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBOYW1lIHRvIHR5cGVkIGFycmF5IG1hcCBjb250YWluaW5nIHRoZSBkYXRhXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFNsb3QgaW4gdGhlIGFycmF5IHRvIGJlIGZpbGxlZFxyXG4gICAgICovXHJcbiAgICBmaWxsTGlnaHRQYXJhbWV0ZXJzOiBmdW5jdGlvbiAodGFyZ2V0LCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5saWdodFBhcmFtZXRlclJlcXVlc3QuZ2V0UmVzdWx0KCk7XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gcmVzdWx0LmdldE91dHB1dERhdGEobmFtZSk7XHJcbiAgICAgICAgICAgIHZhciBzaXplID0gWEMuREFUQV9UWVBFX1RVUExFX1NJWkVbZW50cnkudHlwZV07XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVudHJ5LmdldFZhbHVlKCk7XHJcbiAgICAgICAgICAgIHRhcmdldFtuYW1lXS5zZXQodmFsdWUuc3ViYXJyYXkoMCwgc2l6ZSksIG9mZnNldCAqIHNpemUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtUGFyYW1ldGVycyh0YXJnZXQsIG9mZnNldCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFsbG9jYXRlUGFyYW1ldGVyQXJyYXk6IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgICAgICAgdmFyIHBhcmFtZXRlckFycmF5cyA9IHt9O1xyXG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZ3VyYXRpb247XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIHR5cGUgPSBjb25maWdbbmFtZV0udHlwZTtcclxuICAgICAgICAgICAgdmFyIHR1cGxlU2l6ZSA9IFhDLkRBVEFfVFlQRV9UVVBMRV9TSVpFW3R5cGVdO1xyXG4gICAgICAgICAgICBwYXJhbWV0ZXJBcnJheXNbbmFtZV0gPSBuZXcgWEMuVFlQRURfQVJSQVlfTUFQW3R5cGVdKHR1cGxlU2l6ZSAqIHNpemUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJBcnJheXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFBhcmFtZXRlcjogZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgIGlmKG5hbWUgaW4gdGhpcy5jb25maWd1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIC8vIE5vIG90aGVyIGNoZWNrcyByZXF1aXJlZCBiZWNhdXNlIHBhcmFtZXRlcnMgYXJlIGFsd2F5cyBkZWZpbmVkXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpZ2h0UGFyYW1ldGVyUmVxdWVzdC5nZXRSZXN1bHQoKS5nZXRPdXRwdXREYXRhKG5hbWUpLmdldFZhbHVlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICBsaWdodFBhcmFtZXRlcnNDaGFuZ2VkOiBmdW5jdGlvbiAocmVxdWVzdCwgY2hhbmdlVHlwZSkge1xyXG4gICAgICAgIGlmIChjaGFuZ2VUeXBlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlnaHQubGlnaHRWYWx1ZUNoYW5nZWQoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF9leHBhbmROZWFyRmFyOmZ1bmN0aW9uKG5mb2JqZWN0KXtcclxuICAgICAgICB2YXIgZXhwYW5kID0gTWF0aC5tYXgoKG5mb2JqZWN0LmZhciAtIG5mb2JqZWN0Lm5lYXIpICogMC4zMCwgMC4wNSk7XHJcbiAgICAgICAgbmZvYmplY3QubmVhciAtPSBleHBhbmQ7XHJcbiAgICAgICAgbmZvYmplY3QuZmFyICArPSBleHBhbmQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldExpZ2h0RGF0YTogZnVuY3Rpb24gKHRhcmdldCwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IHRhcmdldFtcIm1hdHJpeFwiXS5zdWJhcnJheShvZmZzZXQgKiAxNiwgb2Zmc2V0ICogMTYgKyAxNik7XHJcbiAgICAgICAgdGhpcy5nZXRMaWdodFZpZXdQcm9qZWN0aW9uTWF0cml4KG1hdHJpeCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldExpZ2h0Vmlld1Byb2plY3Rpb25NYXRyaXg6IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICB2YXIgTFZNID0gbWF0NC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgTFBNID0gbWF0NC5jcmVhdGUoKTtcclxuICAgICAgICB0aGlzLmdldExpZ2h0Vmlld01hdHJpeChMVk0pO1xyXG4gICAgICAgIHRoaXMuZ2V0TGlnaHRQcm9qZWN0aW9uTWF0cml4KExQTSk7XHJcbiAgICAgICAgWE1MM0QubWF0aC5tYXQ0Lm11bHRpcGx5KHRhcmdldCwgTFBNLCBMVk0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRMaWdodFByb2plY3Rpb25NYXRyaXg6IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICB0aGlzLmxpZ2h0LmdldEZydXN0dW0oMSkuZ2V0UHJvamVjdGlvbk1hdHJpeCh0YXJnZXQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRMaWdodFZpZXdNYXRyaXg6IChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdG1wID0gbWF0NC5jcmVhdGUoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtYXQpIHtcclxuICAgICAgICAgICAgdmFyIHBfZGlyID0gdGhpcy5nZXRQYXJhbWV0ZXIoXCJkaXJlY3Rpb25cIik7XHJcbiAgICAgICAgICAgIHZhciBwX3BvcyA9IHRoaXMuZ2V0UGFyYW1ldGVyKFwicG9zaXRpb25cIik7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHdvcmxkIG1hdHJpeCBmcm9tIHRoZSBsaWdodCBpbiB0aGUgdHJhbnNmb3JtYXRpb24gaGllcmFyY2h5XHJcbiAgICAgICAgICAgIC8vIHdvcmxkID0+IGxpZ2h0XHJcbiAgICAgICAgICAgIHRoaXMubGlnaHQuZ2V0V29ybGRNYXRyaXgobWF0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIERlcml2ZSByb3RhdGlvbiBmcm9tIHRoZSBkaXJlY3Rpb24gYW5kIHN0YW5kYXJkIGRpcmVjdGlvbiAoLXogPT4gbm8gcm90YXRpb24pXHJcbiAgICAgICAgICAgIHZhciBxX3JvdCA9IFhNTDNELm1hdGgucXVhdC5yb3RhdGlvblRvKHF1YXQuY3JlYXRlKCksY19zdGFuZGFyZERpcmVjdGlvbiwgcF9kaXIpO1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgbWF0cml4IGZyb20gcm90YXRpb24gYW5kIHRyYW5zbGF0aW9uXHJcbiAgICAgICAgICAgIG1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24odG1wLCBxX3JvdCwgcF9wb3MpO1xyXG4gICAgICAgICAgICAvLyBBZGQgdG8gd29ybGQgbWF0cml4XFxcclxuICAgICAgICAgICAgbWF0NC5tdWwobWF0LCBtYXQsIHRtcCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbnZlcnQ6ICBsaWdodCA9PiB3b3JsZFxyXG4gICAgICAgICAgICBtYXQ0LmludmVydChtYXQsIG1hdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSkoKVxyXG5cclxufTtcclxuXHJcbnZhciBjX3RtcFdvcmxkTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcclxudmFyIGNfc3RhbmRhcmREaXJlY3Rpb24gPSB2ZWMzLmZyb21WYWx1ZXMoMCwwLC0xKTtcclxuXHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb3NlKGxpZ2h0LCBwb3NpdGlvbiwgZGlyZWN0aW9uKSB7XHJcbiAgICBsaWdodC5nZXRXb3JsZE1hdHJpeChjX3RtcFdvcmxkTWF0cml4KTtcclxuICAgIGlmIChwb3NpdGlvbikge1xyXG4gICAgICAgIHZlYzMudHJhbnNmb3JtTWF0NChwb3NpdGlvbiwgcG9zaXRpb24sIGNfdG1wV29ybGRNYXRyaXgpO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpcmVjdGlvbikge1xyXG4gICAgICAgIFhNTDNELm1hdGgudmVjMy50cmFuc2Zvcm1EaXJlY3Rpb24oZGlyZWN0aW9uLCBkaXJlY3Rpb24sIGNfdG1wV29ybGRNYXRyaXgpO1xyXG4gICAgICAgIHZlYzMubm9ybWFsaXplKGRpcmVjdGlvbiwgZGlyZWN0aW9uKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtRGVmYXVsdCh0YXJnZXQsIG9mZnNldCwgbGlnaHQpIHtcclxuICAgIHRhcmdldFtcIm9uXCJdW29mZnNldF0gPSBsaWdodC52aXNpYmxlO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudCBYTUwzRCdzIHByZWRlZmluZWQgcG9pbnQgbGlnaHQgbW9kZWwgdXJuOnhtbDNkOmxpZ2h0OnBvaW50XHJcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IGRhdGFOb2RlXHJcbiAqIEBwYXJhbSB7UmVuZGVyTGlnaHR9IGxpZ2h0XHJcbiAqIEBleHRlbmRzIExpZ2h0TW9kZWxcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgUG9pbnRMaWdodE1vZGVsID0gZnVuY3Rpb24gKGRhdGFOb2RlLCBsaWdodCkge1xyXG4gICAgTGlnaHRNb2RlbC5jYWxsKHRoaXMsIFwicG9pbnRcIiwgbGlnaHQsIGRhdGFOb2RlLCBQb2ludExpZ2h0RGF0YSk7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhQb2ludExpZ2h0TW9kZWwsIExpZ2h0TW9kZWwsIHtcclxuICAgIGdldEZydXN0dW06IGZ1bmN0aW9uIChhc3BlY3QsIHNjZW5lQm91bmRpbmdCb3gpIHtcclxuICAgICAgICB2YXIgb3J0aG9nb25hbCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMubGlnaHQuc2NlbmUubGlnaHRzLmdldE1vZGVsRW50cnkodGhpcy5pZCk7XHJcblxyXG4gICAgICAgIGlmIChzY2VuZUJvdW5kaW5nQm94LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICBlbnRyeS5wYXJhbWV0ZXJzW1wibmVhckZhclwiXVswXSA9IDEuMDtcclxuICAgICAgICAgICAgZW50cnkucGFyYW1ldGVyc1tcIm5lYXJGYXJcIl1bMV0gPSAxMTAuMDtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGcnVzdHVtKDEuMCwgMTEwLjAsIDAsIHRoaXMuZm92eSwgYXNwZWN0LCBvcnRob2dvbmFsKVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHZhciB0X21hdCA9IG1hdDQuY3JlYXRlKCk7XHJcbiAgICAgICAgdGhpcy5nZXRMaWdodFZpZXdNYXRyaXgodF9tYXQpO1xyXG4gICAgICAgIHNjZW5lQm91bmRpbmdCb3gudHJhbnNmb3JtQXhpc0FsaWduZWQodF9tYXQpO1xyXG5cclxuICAgICAgICB2YXIgbmYgPSB7XHJcbiAgICAgICAgICAgIG5lYXI6IC1zY2VuZUJvdW5kaW5nQm94Lm1heC56LCBmYXI6IC1zY2VuZUJvdW5kaW5nQm94Lm1pbi56XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBFeHBhbmQgdGhlIHZpZXcgZnJ1c3R1bSBhIGJpdCB0byBlbnN1cmUgMkQgb2JqZWN0cyBwYXJhbGxlbCB0byB0aGUgY2FtZXJhIGFyZSByZW5kZXJlZFxyXG4gICAgICAgIHRoaXMuX2V4cGFuZE5lYXJGYXIobmYpO1xyXG5cclxuICAgICAgICBpZiAobmYuZmFyIDwgMS4wKSB7XHJcbiAgICAgICAgICAgIG5mLmZhciA9IDExMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVudHJ5LnBhcmFtZXRlcnNbXCJuZWFyRmFyXCJdWzBdID0gMS4wO1xyXG4gICAgICAgIGVudHJ5LnBhcmFtZXRlcnNbXCJuZWFyRmFyXCJdWzFdID0gbmYuZmFyO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEZydXN0dW0oMS4wLCBuZi5mYXIsIDAsIHRoaXMuZm92eSwgYXNwZWN0LCBvcnRob2dvbmFsKTtcclxuICAgIH0sXHJcblxyXG4gICAgdHJhbnNmb3JtUGFyYW1ldGVyczogZnVuY3Rpb24gKHRhcmdldCwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGFyZ2V0W1wicG9zaXRpb25cIl0uc3ViYXJyYXkob2Zmc2V0ICogMywgb2Zmc2V0ICogMyArIDMpO1xyXG4gICAgICAgIHRyYW5zZm9ybVBvc2UodGhpcy5saWdodCwgcG9zaXRpb24sIG51bGwpO1xyXG4gICAgICAgIHRyYW5zZm9ybURlZmF1bHQodGFyZ2V0LCBvZmZzZXQsIHRoaXMubGlnaHQpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnQgWE1MM0QncyBwcmVkZWZpbmVkIHNwb3QgbGlnaHQgbW9kZWwgdXJuOnhtbDNkOmxpZ2h0OnNwb3RcclxuICogQHBhcmFtIHtEYXRhTm9kZX0gZGF0YU5vZGVcclxuICogQHBhcmFtIHtSZW5kZXJMaWdodH0gbGlnaHRcclxuICogQGV4dGVuZHMgTGlnaHRNb2RlbFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBTcG90TGlnaHRNb2RlbCA9IGZ1bmN0aW9uIChkYXRhTm9kZSwgbGlnaHQpIHtcclxuICAgIExpZ2h0TW9kZWwuY2FsbCh0aGlzLCBcInNwb3RcIiwgbGlnaHQsIGRhdGFOb2RlLCBTcG90TGlnaHREYXRhKTtcclxufTtcclxuXHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhTcG90TGlnaHRNb2RlbCwgTGlnaHRNb2RlbCwge1xyXG4gICAgZ2V0RnJ1c3R1bTogZnVuY3Rpb24gKGFzcGVjdCwgc2NlbmVCb3VuZGluZ0JveCkge1xyXG5cclxuICAgICAgICBpZiAoc2NlbmVCb3VuZGluZ0JveC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGcnVzdHVtKDEuMCwgMTEwLjAsIDAsIHRoaXMuZm92eSwgYXNwZWN0LCBmYWxzZSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0X21hdCA9IG1hdDQuY3JlYXRlKCk7XHJcbiAgICAgICAgdGhpcy5nZXRMaWdodFZpZXdNYXRyaXgodF9tYXQpO1xyXG4gICAgICAgIHNjZW5lQm91bmRpbmdCb3gudHJhbnNmb3JtQXhpc0FsaWduZWQodF9tYXQpO1xyXG5cclxuICAgICAgICB2YXIgbmYgPSB7XHJcbiAgICAgICAgICAgIG5lYXI6IC1zY2VuZUJvdW5kaW5nQm94Lm1heC56LCBmYXI6IC1zY2VuZUJvdW5kaW5nQm94Lm1pbi56XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBFeHBhbmQgdGhlIHZpZXcgZnJ1c3R1bSBhIGJpdCB0byBlbnN1cmUgMkQgb2JqZWN0cyBwYXJhbGxlbCB0byB0aGUgY2FtZXJhIGFyZSByZW5kZXJlZFxyXG4gICAgICAgIHRoaXMuX2V4cGFuZE5lYXJGYXIobmYpO1xyXG5cclxuICAgICAgICBpZiAobmYuZmFyIDwgMS4wKSB7XHJcbiAgICAgICAgICAgIG5mLmZhciA9IDExMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRnJ1c3R1bSgxLjAsIG5mLmZhciwgMCwgdGhpcy5mb3Z5LCBhc3BlY3QsIGZhbHNlKTtcclxuICAgIH0sXHJcblxyXG4gICAgdHJhbnNmb3JtUGFyYW1ldGVyczogZnVuY3Rpb24gKHRhcmdldCwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGFyZ2V0W1wicG9zaXRpb25cIl0uc3ViYXJyYXkob2Zmc2V0ICogMywgb2Zmc2V0ICogMyArIDMpO1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB0YXJnZXRbXCJkaXJlY3Rpb25cIl0uc3ViYXJyYXkob2Zmc2V0ICogMywgb2Zmc2V0ICogMyArIDMpO1xyXG4gICAgICAgIC8vIFRyYW5zZm9ybSBwb3NpdGlvbiBhbmQgZGlyZWN0aW9uIGZyb20gb2JqZWN0IHRvIHdvcmxkIHNwYWNlXHJcbiAgICAgICAgdHJhbnNmb3JtUG9zZSh0aGlzLmxpZ2h0LCBwb3NpdGlvbiwgZGlyZWN0aW9uKTtcclxuICAgICAgICB0cmFuc2Zvcm1EZWZhdWx0KHRhcmdldCwgb2Zmc2V0LCB0aGlzLmxpZ2h0KTtcclxuICAgIH0sXHJcblxyXG4gICAgbGlnaHRQYXJhbWV0ZXJzQ2hhbmdlZDogZnVuY3Rpb24gKHJlcXVlc3QsIGNoYW5nZVR5cGUpIHtcclxuICAgICAgICB0aGlzLmZvdnkgPSB0aGlzLmdldFBhcmFtZXRlcihcImN1dG9mZkFuZ2xlXCIpWzBdICogMjtcclxuICAgICAgICBMaWdodE1vZGVsLnByb3RvdHlwZS5saWdodFBhcmFtZXRlcnNDaGFuZ2VkLmNhbGwodGhpcywgcmVxdWVzdCwgY2hhbmdlVHlwZSk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudCBYTUwzRCdzIHByZWRlZmluZWQgc3BvdCBsaWdodCBtb2RlbCB1cm46eG1sM2Q6bGlnaHQ6ZGlyZWN0aW9uYWxcclxuICogQHBhcmFtIHtEYXRhTm9kZX0gZGF0YU5vZGVcclxuICogQHBhcmFtIHtSZW5kZXJMaWdodH0gbGlnaHRcclxuICogQGV4dGVuZHMgTGlnaHRNb2RlbFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBEaXJlY3Rpb25hbExpZ2h0TW9kZWwgPSBmdW5jdGlvbiAoZGF0YU5vZGUsIGxpZ2h0KSB7XHJcbiAgICBMaWdodE1vZGVsLmNhbGwodGhpcywgXCJkaXJlY3Rpb25hbFwiLCBsaWdodCwgZGF0YU5vZGUsIERpcmVjdGlvbmFsTGlnaHREYXRhKTtcclxufTtcclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKERpcmVjdGlvbmFsTGlnaHRNb2RlbCwgTGlnaHRNb2RlbCwge1xyXG4gICAgZ2V0RnJ1c3R1bTogZnVuY3Rpb24oYXNwZWN0LCBzY2VuZUJvdW5kaW5nQm94KSB7XHJcbiAgICAgICAgdmFyIG9ydGhvZ29uYWwgPSB0cnVlO1xyXG5cclxuICAgICAgICBpZiAoc2NlbmVCb3VuZGluZ0JveC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGcnVzdHVtKDEuMCwgMTEwLjAsIDAsIHRoaXMuZm92eSwgYXNwZWN0LCBvcnRob2dvbmFsKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRfbWF0ID0gbWF0NC5jcmVhdGUoKTtcclxuICAgICAgICB0aGlzLmdldExpZ2h0Vmlld01hdHJpeCh0X21hdCk7XHJcbiAgICAgICAgc2NlbmVCb3VuZGluZ0JveC50cmFuc2Zvcm1BeGlzQWxpZ25lZCh0X21hdCk7XHJcblxyXG4gICAgICAgIHZhciBuZiA9IHsgIG5lYXI6IC1zY2VuZUJvdW5kaW5nQm94Lm1heC56LFxyXG4gICAgICAgICAgICAgICAgICAgIGZhcjogIC1zY2VuZUJvdW5kaW5nQm94Lm1pbi56fTtcclxuICAgICAgICAvLyBFeHBhbmQgdGhlIHZpZXcgZnJ1c3R1bSBhIGJpdCB0byBlbnN1cmUgMkQgb2JqZWN0cyBwYXJhbGxlbCB0byB0aGUgY2FtZXJhIGFyZSByZW5kZXJlZFxyXG4gICAgICAgIHRoaXMuX2V4cGFuZE5lYXJGYXIobmYpO1xyXG5cclxuICAgICAgICBpZiAobmYuZmFyIDwgMS4wKSB7XHJcbiAgICAgICAgICAgIG5mLmZhciA9IDExMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRnJ1c3R1bSgxLjAsIG5mLmZhciwgMCwgdGhpcy5mb3Z5LCBhc3BlY3QsIG9ydGhvZ29uYWwpO1xyXG4gICAgfSxcclxuXHJcbiAgICB0cmFuc2Zvcm1QYXJhbWV0ZXJzOiBmdW5jdGlvbiAodGFyZ2V0LCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGFyZ2V0W1wiZGlyZWN0aW9uXCJdLnN1YmFycmF5KG9mZnNldCAqIDMsIG9mZnNldCAqIDMgKyAzKTtcclxuICAgICAgICB0cmFuc2Zvcm1Qb3NlKHRoaXMubGlnaHQsIG51bGwsIGRpcmVjdGlvbik7XHJcbiAgICAgICAgdHJhbnNmb3JtRGVmYXVsdCh0YXJnZXQsIG9mZnNldCwgdGhpcy5saWdodCk7XHJcbiAgICB9LFxyXG5cclxuXHJcblxyXG4gICAgZ2V0TGlnaHRWaWV3TWF0cml4OiBmdW5jdGlvbiAobWF0KSB7XHJcbiAgICAgICAgdmFyIG1hbmFnZXIgPSB0aGlzLmxpZ2h0LnNjZW5lLmxpZ2h0cztcclxuICAgICAgICB2YXIgZW50cnkgPSBtYW5hZ2VyLmdldE1vZGVsRW50cnkodGhpcy5pZCk7XHJcbiAgICAgICAgdmFyIHBfZGlyID0gZW50cnkucGFyYW1ldGVyc1tcImRpcmVjdGlvblwiXTtcclxuICAgICAgICB2YXIgcF9wb3MgPSBlbnRyeS5wYXJhbWV0ZXJzW1wicG9zaXRpb25cIl07XHJcblxyXG4gICAgICAgIHZhciBiYiA9IG5ldyBYTUwzRC5Cb3goKTtcclxuICAgICAgICB0aGlzLmxpZ2h0LnNjZW5lLmdldEJvdW5kaW5nQm94KGJiKTtcclxuICAgICAgICB2YXIgb2ZmID0gdmVjMy5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgYmJDZW50ZXIgPSBiYi5jZW50ZXIoKTtcclxuICAgICAgICB2YXIgYmJTaXplID0gYmIuc2l6ZSgpO1xyXG4gICAgICAgIHZhciBkID0gYmJTaXplLmxlbmd0aCgpOyAvL2RpYW1ldGVyIG9mIGJvdW5kaW5nIHNwaGVyZSBvZiB0aGUgc2NlbmVcclxuICAgICAgICB2ZWMzLnNjYWxlKG9mZiwgcF9kaXIsIC0wLjU1ICogZCk7IC8vZW5sYXJnZSBhIGJpdCBvbiB0aGUgcmFkaXVzIG9mIHRoZSBzY2VuZVxyXG4gICAgICAgIHBfcG9zID0gdmVjMy5hZGQocF9wb3MsIGJiQ2VudGVyLmRhdGEsIG9mZik7XHJcbiAgICAgICAgZW50cnkucGFyYW1ldGVyc1tcInBvc2l0aW9uXCJdID0gcF9wb3M7XHJcblxyXG5cclxuICAgICAgICAvL2NyZWF0ZSBuZXcgdHJhbnNmb3JtYXRpb24gbWF0cml4IGRlcGVuZGluZyBvbiB0aGUgdXBkYXRlZCBwYXJhbWV0ZXJzXHJcbiAgICAgICAgbWF0NC5pZGVudGl0eShtYXQpO1xyXG4gICAgICAgIHZhciBsb29rYXRfbWF0ID0gbWF0NC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgdG9wX3ZlYyA9IHZlYzMuZnJvbVZhbHVlcygwLjAsIDEuMCwgMC4wKTtcclxuICAgICAgICBpZiAoKHBfZGlyWzBdID09IDAuMCkgJiYgKHBfZGlyWzJdID09IDAuMCkpIC8vY2hlY2sgaWYgdG9wX3ZlYyBjb2xpbmVhciB3aXRoIGRpcmVjdGlvblxyXG4gICAgICAgICAgICB0b3BfdmVjID0gdmVjMy5mcm9tVmFsdWVzKDAuMCwgMC4wLCAxLjApO1xyXG4gICAgICAgIHZhciB1cF92ZWMgPSB2ZWMzLmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBkaXJfbGVuID0gdmVjMy5sZW4ocF9kaXIpO1xyXG4gICAgICAgIHZlYzMuc2NhbGUodXBfdmVjLCBwX2RpciwgLXZlYzMuZG90KHRvcF92ZWMsIHBfZGlyKSAvIChkaXJfbGVuICogZGlyX2xlbikpO1xyXG4gICAgICAgIHZlYzMuYWRkKHVwX3ZlYywgdXBfdmVjLCB0b3BfdmVjKTtcclxuICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh1cF92ZWMsIHVwX3ZlYyk7XHJcbiAgICAgICAgbWF0NC5sb29rQXQobG9va2F0X21hdCwgdmVjMy5mcm9tVmFsdWVzKDAuMCwgMC4wLCAwLjApLCBwX2RpciwgdXBfdmVjKTtcclxuICAgICAgICBtYXQ0LmludmVydChsb29rYXRfbWF0LCBsb29rYXRfbWF0KTtcclxuICAgICAgICBtYXQ0LnRyYW5zbGF0ZShtYXQsIG1hdCwgcF9wb3MpO1xyXG4gICAgICAgIG1hdDQubXVsdGlwbHkobWF0LCBtYXQsIGxvb2thdF9tYXQpO1xyXG5cclxuICAgICAgICBiYiA9IG5ldyBYTUwzRC5Cb3goKTtcclxuICAgICAgICB0aGlzLmxpZ2h0LnNjZW5lLmdldEJvdW5kaW5nQm94KGJiKTtcclxuICAgICAgICBiYi50cmFuc2Zvcm1BeGlzQWxpZ25lZChtYXQpO1xyXG4gICAgICAgIGJiU2l6ZSA9IGJiLnNpemUoKS5kYXRhO1xyXG4gICAgICAgIHZhciBtYXggPSAoYmJTaXplWzBdID4gYmJTaXplWzFdKSA/IGJiU2l6ZVswXSA6IGJiU2l6ZVsxXTtcclxuICAgICAgICBtYXggPSAwLjU1ICogKG1heCk7Ly9lbmxhcmdlIDEwcGVyY2VudCB0byBtYWtlIHN1cmUgbm90aGluZyBnZXRzIGN1dCBvZmZcclxuICAgICAgICB0aGlzLmZvdnkgPSBtYXggPD0gMCA/IE1hdGguUEkgOiBNYXRoLmF0YW4obWF4KSoyLjA7XHJcblxyXG4gICAgICAgIGVudHJ5LnBhcmFtZXRlcnNbXCJkaXJlY3Rpb25cIl0gPSBwX2RpcjtcclxuICAgICAgICBlbnRyeS5wYXJhbWV0ZXJzW1wicG9zaXRpb25cIl0gID0gcF9wb3M7XHJcblxyXG4gICAgICAgIG1hdDQuaW52ZXJ0KG1hdCwgbWF0KTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBQb2ludExpZ2h0TW9kZWw6IFBvaW50TGlnaHRNb2RlbCwgU3BvdExpZ2h0TW9kZWw6IFNwb3RMaWdodE1vZGVsLCBEaXJlY3Rpb25hbExpZ2h0TW9kZWw6IERpcmVjdGlvbmFsTGlnaHRNb2RlbFxyXG5cclxufTtcclxuIiwidmFyIEdMUmVuZGVyZXIgPSByZXF1aXJlKFwiLi4vd2ViZ2wvcmVuZGVyZXIuanNcIik7XHJcbnZhciBHTENhbnZhc0hhbmRsZXIgPSByZXF1aXJlKFwiLi4vd2ViZ2wvY2FudmFzLWhhbmRsZXIuanNcIik7XHJcblxyXG52YXIgUmVuZGVyZXJGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5jcmVhdGVSZW5kZXJlciA9IGZ1bmN0aW9uICh4bWwzZEVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgY2FudmFzID0geG1sM2RFbGVtZW50Ll9jb25maWd1cmVkLmNhbnZhcztcclxuICAgICAgICB2YXIgY2FudmFzSGFuZGxlciA9IG5ldyBHTENhbnZhc0hhbmRsZXIoeG1sM2RFbGVtZW50LCBjYW52YXMpO1xyXG4gICAgICAgIHZhciByZW5kZXJlciA9IG5ldyBHTFJlbmRlcmVyKHhtbDNkRWxlbWVudCwgY2FudmFzSGFuZGxlcik7XHJcbiAgICAgICAgY2FudmFzSGFuZGxlci5zZXRSZW5kZXJlcihyZW5kZXJlcik7XHJcbiAgICAgICAgeG1sM2RFbGVtZW50Ll9jb25maWd1cmVkLmNhbnZhc0hhbmRsZXIgPSBjYW52YXNIYW5kbGVyO1xyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FudmFzSGFuZGxlci50aWNrKTtcclxuICAgICAgICByZXR1cm4gcmVuZGVyZXI7XHJcbiAgICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IFJlbmRlcmVyRmFjdG9yeSgpO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIiwidmFyIHVuaXF1ZU9iamVjdElkID0gcmVxdWlyZShcIi4uLy4uL3dlYmdsL2Jhc2UvdXRpbHMuanNcIikuZ2V0VW5pcXVlQ291bnRlcigpO1xyXG4vKipcclxuICogQSBjb25maWd1cmF0aW9uIGNvbm5lY3RzIGEgbW9kZWwgKG1hdGVyaWFsLCBsaWdodCwgY2FtZXJhKSB3aXRoIGEgZGF0YSBub2RlIGNvbnRhaW5pbmdcclxuICogdGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBtb2RlbFxyXG4gKiBUaGUgQ29uZmlndXJhdGlvbiBpcyBpbW11dGFibGVcclxuICpcclxuICogQHBhcmFtIG1vZGVsIFRoZSBtb2RlbCAoZS5nLiBpZGVudGlmaWVkIGJ5IGFuIFVSTilcclxuICogQHBhcmFtIHtYZmxvdy5EYXRhTm9kZX0gZGF0YU5vZGUgIFRoZSBwYXJhbWV0ZXJzIG9mIHRoaXMgbW9kZWwgaW5zdGFuY2VcclxuICogQHBhcmFtIHt7fX0gb3B0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIENvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbihtb2RlbCwgZGF0YU5vZGUsIG9wdCkge1xyXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xyXG5cclxuICAgIHRoaXMuaWQgPSB1bmlxdWVPYmplY3RJZCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge3t0eXBlOiBzdHJpbmd9fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEYXRhIE5vZGUgb2YgdGhlIHJlbmRlck9iamVjdFxyXG4gICAgICogQHR5cGUge1hmbG93LkRhdGFOb2RlfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRhdGFOb2RlID0gZGF0YU5vZGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIG5hbWUgZm9yIGRlYnVnIHB1cnBvc2VzXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubmFtZSA9IG9wdC5uYW1lIHx8IG51bGw7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbmZpZ3VyYXRpb247XHJcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgTk9ERV9UWVBFOiB7XHJcbiAgICAgICAgR1JPVVA6IFwiZ3JvdXBcIiwgT0JKRUNUOiBcIm9iamVjdFwiLCBMSUdIVDogXCJsaWdodFwiLCBWSUVXOiBcInZpZXdcIlxyXG4gICAgfSxcclxuXHJcbiAgICBFVkVOVF9UWVBFOiB7XHJcbiAgICAgICAgVklFV19DSEFOR0VEOiBcInZpZXdfY2hhbmdlZFwiLFxyXG4gICAgICAgIExJR0hUX1NUUlVDVFVSRV9DSEFOR0VEOiBcImxpZ2h0X3N0cnVjdHVyZV9jaGFuZ2VkXCIsXHJcbiAgICAgICAgTElHSFRfVkFMVUVfQ0hBTkdFRDogXCJsaWdodF92YWx1ZV9jaGFuZ2VkXCIsXHJcbiAgICAgICAgU0NFTkVfU0hBUEVfQ0hBTkdFRDogXCJzY2VuZV9zaGFwZV9jaGFuZ2VkXCIsXHJcbiAgICAgICAgU0NFTkVfU1RSVUNUVVJFX0NIQU5HRUQ6IFwic2NlbmVfc3RydWN0dXJlX2NoYW5nZWRcIixcclxuICAgICAgICBEUkFXQUJMRV9TVEFURV9DSEFOR0VEOiBcImRyYXdhYmxlX3N0YXRlX2NoYW5nZWRcIlxyXG5cclxuICAgIH1cclxufTtcclxuIiwidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcclxuXHJcbnZhciBEcmF3YWJsZUNsb3N1cmUgPSBmdW5jdGlvbiAoY29udGV4dCwgdHlwZSkge1xyXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XHJcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgdGhpcy5fdHlwZSA9IHR5cGU7XHJcbiAgICB0aGlzLl92YWxpZCA9IGZhbHNlO1xyXG4gICAgLy8gRG8gbm90IGxpbWl0IHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzXHJcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygwKTtcclxufTtcclxuXHJcbkRyYXdhYmxlQ2xvc3VyZS5UWVBFUyA9IHtcclxuICAgIE1FU0g6IFwibWVzaFwiLCBWT0xVTUU6IFwidm9sdW1lXCJcclxufTtcclxuXHJcbkRyYXdhYmxlQ2xvc3VyZS5SRUFEWV9TVEFURSA9IHtcclxuICAgIENPTVBMRVRFOiBcImNvbXBsZXRlXCIsIElOQ09NUExFVEU6IFwiaW5jb21wbGV0ZVwiXHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhEcmF3YWJsZUNsb3N1cmUsIEV2ZW50RW1pdHRlciwge1xyXG4gICAgZ2V0VHlwZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xyXG4gICAgfSwgaXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92YWxpZDtcclxuICAgIH0sIHNldFNoYWRlckNvbXBvc2VyOiBmdW5jdGlvbiAoc2hhZGVyQ29tcG9zZXIpIHtcclxuICAgICAgICAvLyBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc1xyXG4gICAgfSwgdXBkYXRlOiBmdW5jdGlvbiAoc2NlbmUpIHtcclxuICAgICAgICAvLyBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc1xyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRHJhd2FibGVDbG9zdXJlO1xyXG5cclxuIiwidmFyIERFRkFVTFRfUEFHRV9TSVpFID0gMSA8PCAxMjtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBQYWdlciA9IGZ1bmN0aW9uIChvcHQpIHtcclxuICAgIG9wdCA9IG9wdCB8fCB7fTtcclxuXHJcbiAgICB0aGlzLnBhZ2VTaXplID0gb3B0LnBhZ2VTaXplIHx8IERFRkFVTFRfUEFHRV9TSVpFO1xyXG5cclxuICAgIC8qKiBAdHlwZSBBcnJheTxGbG9hdDMyQXJyYXk+ICovXHJcbiAgICB0aGlzLnBhZ2VzID0gW107XHJcbiAgICAvKiogQHR5cGUgbnVtYmVyICovXHJcbiAgICB0aGlzLm5leHRPZmZzZXQgPSAwO1xyXG4gICAgLyoqIEB0eXBlIEFycmF5PCo+ICovXHJcbiAgICB0aGlzLmZyZWVFbnRyaWVzID0gW107XHJcbiAgICAvLyBBZGQgYSBmaXJzdCBwYWdlXHJcbiAgICB0aGlzLmFkZFBhZ2UoKTtcclxufTtcclxuXHJcblhNTDNELmV4dGVuZChQYWdlci5wcm90b3R5cGUsIHtcclxuICAgIGFkZFBhZ2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGFnZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5wYWdlU2l6ZSk7XHJcbiAgICAgICAgdGhpcy5wYWdlcy5wdXNoKHBhZ2UpO1xyXG4gICAgICAgIHRoaXMubmV4dE9mZnNldCA9IDA7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nSW5mbyhcIkFkZGluZyBwYWdlXCIsIHRoaXMucGFnZXMubGVuZ3RoLCBcIihcIiwgdGhpcy5wYWdlU2l6ZSAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAqIHRoaXMucGFnZXMubGVuZ3RoIC8gMTAyNCwgXCJrQilcIik7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFBhZ2VFbnRyeTogZnVuY3Rpb24gKHNpemUpIHtcclxuICAgICAgICBpZiAoIXNpemUpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNpemUgZ2l2ZW4gZm9yIHBhZ2UgZW50cnlcIik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmV1c2VQYWdlRW50cnkoc2l6ZSkgfHwgdGhpcy5jcmVhdGVQYWdlRW50cnkoc2l6ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgUmVxdWVzdGVkIHNpemUgaW4gbnVtYmVyIG9mIGZsb2F0c1xyXG4gICAgICogQHJldHVybnMge3sgcGFnZTogRmxvYXQzMkFycmF5LCBvZmZzZXQ6IG51bWJlciwgc2l6ZTogbnVtYmVyIH19XHJcbiAgICAgKi9cclxuICAgIHJldXNlUGFnZUVudHJ5OiBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgICAgIHZhciBzYW1lU2l6ZUVudHJpZXMgPSB0aGlzLmZyZWVFbnRyaWVzW3NpemVdO1xyXG4gICAgICAgIGlmIChzYW1lU2l6ZUVudHJpZXMgJiYgc2FtZVNpemVFbnRyaWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2FtZVNpemVFbnRyaWVzLnBvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSAgU2l6ZSBpbiBudW1iZXIgb2YgZmxvYXRzXHJcbiAgICAgKiBAcmV0dXJucyB7eyBwYWdlOiBGbG9hdDMyQXJyYXksIG9mZnNldDogbnVtYmVyLCBzaXplOiBudW1iZXIgfX1cclxuICAgICAqL1xyXG4gICAgY3JlYXRlUGFnZUVudHJ5OiBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLm5leHRPZmZzZXQgKyBzaXplID4gdGhpcy5wYWdlU2l6ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZFBhZ2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFnZUVudHJ5KHNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGFnZSA9IHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAxXTtcclxuICAgICAgICB2YXIgbG9jYWxPZmZzZXQgPSB0aGlzLm5leHRPZmZzZXQ7XHJcbiAgICAgICAgdGhpcy5uZXh0T2Zmc2V0ICs9IHNpemU7XHJcbiAgICAgICAgcmV0dXJuIHtwYWdlOiBwYWdlLCBvZmZzZXQ6IGxvY2FsT2Zmc2V0LCBzaXplOiBzaXplfTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHt7IHBhZ2U6IEZsb2F0MzJBcnJheSwgb2Zmc2V0OiBudW1iZXIsIHNpemU6IG51bWJlciB9fSBlbnRyeUluZm9cclxuICAgICAqL1xyXG4gICAgZnJlZVBhZ2VFbnRyeTogZnVuY3Rpb24gKGVudHJ5SW5mbykge1xyXG4gICAgICAgIHZhciBzYW1lU2l6ZUVudHJpZXMgPSB0aGlzLmZyZWVFbnRyaWVzW2VudHJ5SW5mby5zaXplXTtcclxuICAgICAgICBpZiAoIXNhbWVTaXplRW50cmllcykge1xyXG4gICAgICAgICAgICBzYW1lU2l6ZUVudHJpZXMgPSB0aGlzLmZyZWVFbnRyaWVzW2VudHJ5SW5mby5zaXplXSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzYW1lU2l6ZUVudHJpZXMucHVzaChlbnRyeUluZm8pO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGFnZXI7XHJcblxyXG4iLCJ2YXIgUmVuZGVyTm9kZSA9IHJlcXVpcmUoXCIuL3JlbmRlcm5vZGUuanNcIik7XHJcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XHJcbnZhciBGcnVzdHVtID0gcmVxdWlyZShcIi4uL3Rvb2xzL2ZydXN0dW0uanNcIikuRnJ1c3R1bTtcclxudmFyIHZlYzMgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLnZlYzM7XHJcbnZhciBtYXQ0ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS5tYXQ0O1xyXG5cclxudmFyIE5PREVfVFlQRSA9IENvbnN0YW50cy5OT0RFX1RZUEU7XHJcbnZhciBFVkVOVF9UWVBFID0gQ29uc3RhbnRzLkVWRU5UX1RZUEU7XHJcblxyXG4vKiogQGNvbnN0ICovXHJcbnZhciBXT1JMRF9NQVRSSVhfT0ZGU0VUID0gMDtcclxuLyoqIEBjb25zdCAqL1xyXG52YXIgTE9DQUxfTUFUUklYX09GRlNFVCA9IFdPUkxEX01BVFJJWF9PRkZTRVQgKyAxNjtcclxuLyoqIEBjb25zdCAqL1xyXG52YXIgV09STERfQkJfT0ZGU0VUID0gTE9DQUxfTUFUUklYX09GRlNFVCArIDE2O1xyXG4vKiogQGNvbnN0ICovXHJcbnZhciBFTlRSWV9TSVpFID0gV09STERfQkJfT0ZGU0VUICsgNjtcclxuXHJcblxyXG4gICAvKiogQGNvbnN0ICovXHJcbiAgICB2YXIgQ0xJUFBMQU5FX05FQVJfTUlOID0gMC4wMTtcclxuXHJcbiAgICAvKiogQGNvbnN0ICovXHJcbiAgICB2YXIgREVGQVVMVF9GSUVMRE9GVklFVyA9IDQ1IC8gMTgwICogTWF0aC5QSTtcclxuLyoqXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyB7UmVuZGVyTm9kZX1cclxuICovXHJcbnZhciBSZW5kZXJHcm91cCA9IGZ1bmN0aW9uIChzY2VuZSwgcGFnZUVudHJ5LCBvcHQpIHtcclxuICAgIFJlbmRlck5vZGUuY2FsbCh0aGlzLCBOT0RFX1RZUEUuR1JPVVAsIHNjZW5lLCBwYWdlRW50cnksIG9wdCk7XHJcbiAgICBvcHQgPSBvcHQgfHwge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWF0ZXJpYWwgYXR0YWNoZWQgdG8gdGhpcyBncm91cFxyXG4gICAgICogQHR5cGUge01hdGVyaWFsQ29uZmlndXJhdGlvbnxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9tYXRlcmlhbCA9IG9wdC5tYXRlcmlhbCB8fCBudWxsO1xyXG4gICAgdGhpcy5ib3VuZGluZ0JveERpcnR5ID0gZmFsc2U7XHJcbiAgICB0aGlzLnNldFdvcmxkU3BhY2VCb3VuZGluZ0JveChYTUwzRC5Cb3guRU1QVFlfQk9YKTtcclxufTtcclxuUmVuZGVyR3JvdXAuRU5UUllfU0laRSA9IEVOVFJZX1NJWkU7XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhSZW5kZXJHcm91cCwgUmVuZGVyTm9kZSk7XHJcblxyXG5YTUwzRC5leHRlbmQoUmVuZGVyR3JvdXAucHJvdG90eXBlLCB7XHJcbiAgICBnZXRMb2NhbE1hdHJpeDogZnVuY3Rpb24gKGRlc3QpIHtcclxuICAgICAgICB2YXIgbyA9IHRoaXMub2Zmc2V0ICsgTE9DQUxfTUFUUklYX09GRlNFVDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyssIG8rKykge1xyXG4gICAgICAgICAgICBkZXN0W2ldID0gdGhpcy5wYWdlW29dO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc2V0TG9jYWxNYXRyaXg6IGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICB2YXIgbyA9IHRoaXMub2Zmc2V0ICsgTE9DQUxfTUFUUklYX09GRlNFVDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyssIG8rKykge1xyXG4gICAgICAgICAgICB0aGlzLnBhZ2Vbb10gPSBzb3VyY2VbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtRGlydHkoKTtcclxuICAgICAgICB0aGlzLnNldEJvdW5kaW5nQm94RGlydHkoKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0V29ybGRTcGFjZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoYmJveCkge1xyXG4gICAgICAgIGlmICh0aGlzLmJvdW5kaW5nQm94RGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVXb3JsZFNwYWNlQm91bmRpbmdCb3goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG8gPSB0aGlzLm9mZnNldCArIFdPUkxEX0JCX09GRlNFVDtcclxuICAgICAgICBiYm94LmRhdGFbMF0gPSB0aGlzLnBhZ2Vbb107XHJcbiAgICAgICAgYmJveC5kYXRhWzFdID0gdGhpcy5wYWdlW28gKyAxXTtcclxuICAgICAgICBiYm94LmRhdGFbMl0gPSB0aGlzLnBhZ2VbbyArIDJdO1xyXG4gICAgICAgIGJib3guZGF0YVszXSA9IHRoaXMucGFnZVtvICsgM107XHJcbiAgICAgICAgYmJveC5kYXRhWzRdID0gdGhpcy5wYWdlW28gKyA0XTtcclxuICAgICAgICBiYm94LmRhdGFbNV0gPSB0aGlzLnBhZ2VbbyArIDVdO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRXb3JsZFNwYWNlQm91bmRpbmdCb3g6IGZ1bmN0aW9uIChiYm94KSB7XHJcbiAgICAgICAgdmFyIG8gPSB0aGlzLm9mZnNldCArIFdPUkxEX0JCX09GRlNFVDtcclxuICAgICAgICB0aGlzLnBhZ2Vbb10gPSBiYm94LmRhdGFbMF07XHJcbiAgICAgICAgdGhpcy5wYWdlW28gKyAxXSA9IGJib3guZGF0YVsxXTtcclxuICAgICAgICB0aGlzLnBhZ2VbbyArIDJdID0gYmJveC5kYXRhWzJdO1xyXG4gICAgICAgIHRoaXMucGFnZVtvICsgM10gPSBiYm94LmRhdGFbM107XHJcbiAgICAgICAgdGhpcy5wYWdlW28gKyA0XSA9IGJib3guZGF0YVs0XTtcclxuICAgICAgICB0aGlzLnBhZ2VbbyArIDVdID0gYmJveC5kYXRhWzVdO1xyXG4gICAgfSxcclxuXHJcblxyXG4gICAgdXBkYXRlV29ybGRTcGFjZUJvdW5kaW5nQm94OiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjaGlsZEJCID0gbmV3IFhNTDNELkJveCgpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbG9jYWxCQiA9IG5ldyBYTUwzRC5Cb3goKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBvYmogPSB0aGlzLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgb2JqLmdldFdvcmxkU3BhY2VCb3VuZGluZ0JveChjaGlsZEJCKTtcclxuICAgICAgICAgICAgICAgIGxvY2FsQkIuZXh0ZW5kKGNoaWxkQkIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2V0V29ybGRTcGFjZUJvdW5kaW5nQm94KGxvY2FsQkIpO1xyXG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94RGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9KSgpLFxyXG5cclxuICAgIGFkZENoaWxkOiBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xyXG4gICAgICAgIHRoaXMuc2V0Qm91bmRpbmdCb3hEaXJ0eSgpO1xyXG4gICAgICAgIHRoaXMuc2NlbmUuZW1pdChFVkVOVF9UWVBFLlNDRU5FX1NUUlVDVFVSRV9DSEFOR0VELCBjaGlsZCwgZmFsc2UpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVDaGlsZDogZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcclxuICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNjZW5lLmVtaXQoRVZFTlRfVFlQRS5TQ0VORV9TVFJVQ1RVUkVfQ0hBTkdFRCwgY2hpbGQsIHRydWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRDaGlsZHJlbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVXb3JsZE1hdHJpeDogZnVuY3Rpb24gKHNvdXJjZU1hdDQpIHtcclxuICAgICAgICB2YXIgcGFnZSA9IHRoaXMucGFnZTtcclxuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgWE1MM0QubWF0aC5tYXQ0Lm11bHRpcGx5T2Zmc2V0KHBhZ2UsIG9mZnNldCArIFdPUkxEX01BVFJJWF9PRkZTRVQsIHBhZ2UsIG9mZnNldCArIExPQ0FMX01BVFJJWF9PRkZTRVQsIHNvdXJjZU1hdDQsIDApO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtRGlydHkgPSBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VHJhbnNmb3JtRGlydHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm1EaXJ0eSkge1xyXG4gICAgICAgICAgICAvL1dlIGNhbiBiZSBzdXJlIGFsbCBjaGlsZCBub2RlcyBhcmUgYWxyZWFkeSBzZXQgdG8gdHJhbnNmb3JtRGlydHkgZnJvbSBoZXJlXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1EaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcclxuICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuW2ldLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7TWF0ZXJpYWxDb25maWd1cmF0aW9ufG51bGx9IG1hdGVyaWFsXHJcbiAgICAgKi9cclxuICAgIHNldE1hdGVyaWFsOiBmdW5jdGlvbiAobWF0ZXJpYWwpIHtcclxuICAgICAgICBpZih0aGlzLl9tYXRlcmlhbCA9PT0gbWF0ZXJpYWwpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB0aGlzLl9tYXRlcmlhbCA9IG1hdGVyaWFsO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgIG9iai5wYXJlbnRNYXRlcmlhbENoYW5nZWQgJiYgb2JqLnBhcmVudE1hdGVyaWFsQ2hhbmdlZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBwYXJlbnRNYXRlcmlhbENoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fbWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgLy8gTG9jYWwgbWF0ZXJpYWwgb3ZlcnJpZGVzIGFueXRoaW5nIGNvbWluZyBmcm9tIHVwc3RyZWFtXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgb2JqLnBhcmVudE1hdGVyaWFsQ2hhbmdlZCAmJiBvYmoucGFyZW50TWF0ZXJpYWxDaGFuZ2VkKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMge01hdGVyaWFsQ29uZmlndXJhdGlvbn1cclxuICAgICAqL1xyXG4gICAgZ2V0TWF0ZXJpYWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWF0ZXJpYWwgfHwgdGhpcy5wYXJlbnQuZ2V0TWF0ZXJpYWwoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGdyb3VwIHByb3BhZ2F0ZXMgaXRzIHZpc2liaWxpdHlcclxuICAgICAqL1xyXG4gICAgdmlzaWJpbGl0eUNoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuW2ldLmV2YWx1YXRlVmlzaWJpbGl0eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG5cclxuXHJcbiAgICBzZXRCb3VuZGluZ0JveERpcnR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveERpcnR5ID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuc2V0Qm91bmRpbmdCb3hEaXJ0eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZmluZFJheUludGVyc2VjdGlvbnM6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGJib3ggPSBuZXcgWE1MM0QuQm94KCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocmF5LCBpbnRlcnNlY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0V29ybGRTcGFjZUJvdW5kaW5nQm94KGJib3gpO1xyXG4gICAgICAgICAgICBpZiAocmF5LmludGVyc2VjdHMoYmJveCkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uZmluZFJheUludGVyc2VjdGlvbnMocmF5LCBpbnRlcnNlY3Rpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pKClcclxuXHJcbn0pO1xyXG5cclxuLy8gRXhwb3J0XHJcbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyR3JvdXA7XHJcblxyXG4iLCJ2YXIgUmVuZGVyTm9kZSA9IHJlcXVpcmUoXCIuL3JlbmRlcm5vZGUuanNcIik7XHJcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XHJcbnZhciBMaWdodE1vZGVscyA9IHJlcXVpcmUoXCIuLi9saWdodHMvbGlnaHQtbW9kZWxzLmpzXCIpO1xyXG5cclxudmFyIE5PREVfVFlQRSA9IENvbnN0YW50cy5OT0RFX1RZUEU7XHJcbnZhciBFVkVOVF9UWVBFID0gQ29uc3RhbnRzLkVWRU5UX1RZUEU7XHJcblxyXG52YXIgdG1wX3dvcmxkTWF0cml4ID0gWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpO1xyXG5cclxudmFyIFNIQURPV01BUF9PRkZTRVRfTUFUUklYID0gbmV3IEZsb2F0MzJBcnJheShbMC41LCAwLjAsIDAuMCwgMC4wLCAwLjAsIDAuNSwgMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjUsIDAuMCwgMC41LCAwLjUsIDAuNSwgMS4wXSk7XHJcblxyXG4vKiogQGNvbnN0ICovXHJcbnZhciBDTElQUExBTkVfTkVBUl9NSU4gPSAxLjA7XHJcblxyXG4vKiogQGNvbnN0ICovXHJcbnZhciBFTlRSWV9TSVpFID0gMTY7XHJcblxyXG52YXIgY19Cb3VuZGluZ0JveCA9IG5ldyBYTUwzRC5Cb3goKTtcclxuXHJcblxyXG5mdW5jdGlvbiBjcmVhdGVMaWdodE1vZGVsKHR5cGUsIGRhdGEsIGxpZ2h0KSB7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlIFwidXJuOnhtbDNkOmxpZ2h0OnBvaW50XCI6XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlnaHRNb2RlbHMuUG9pbnRMaWdodE1vZGVsKGRhdGEsIGxpZ2h0KTtcclxuICAgICAgICBjYXNlIFwidXJuOnhtbDNkOmxpZ2h0OnNwb3RcIjpcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaWdodE1vZGVscy5TcG90TGlnaHRNb2RlbChkYXRhLCBsaWdodCk7XHJcbiAgICAgICAgY2FzZSBcInVybjp4bWwzZDpsaWdodDpkaXJlY3Rpb25hbFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IExpZ2h0TW9kZWxzLkRpcmVjdGlvbmFsTGlnaHRNb2RlbChkYXRhLCBsaWdodCk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIlVua25vd24gbGlnaHQgbW9kZWw6IFwiLCB0eXBlLCBcIi4gVXNpbmcgZGlyZWN0aW9uYWwgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlnaHRNb2RlbHMuRGlyZWN0aW9uYWxMaWdodE1vZGVsKGRhdGEsIGxpZ2h0KTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1NjZW5lfSBzY2VuZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gcGFnZUVudHJ5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcclxuICogQGV4dGVuZHMge1JlbmRlck5vZGV9XHJcbiAqL1xyXG52YXIgUmVuZGVyTGlnaHQgPSBmdW5jdGlvbiAoc2NlbmUsIHBhZ2VFbnRyeSwgb3B0KSB7XHJcbiAgICBSZW5kZXJOb2RlLmNhbGwodGhpcywgTk9ERV9UWVBFLkxJR0hULCBzY2VuZSwgcGFnZUVudHJ5LCBvcHQpO1xyXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xyXG4gICAgdmFyIGNvbmZpZ3VyYXRpb24gPSBvcHQuY29uZmlndXJhdGlvbiB8fCB7fTtcclxuICAgIHRoaXMuc2V0TGlnaHRUeXBlKGNvbmZpZ3VyYXRpb24ubW9kZWwsIGNvbmZpZ3VyYXRpb24uZGF0YU5vZGUpO1xyXG59O1xyXG5SZW5kZXJMaWdodC5FTlRSWV9TSVpFID0gRU5UUllfU0laRTtcclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKFJlbmRlckxpZ2h0LCBSZW5kZXJOb2RlKTtcclxuWE1MM0QuZXh0ZW5kKFJlbmRlckxpZ2h0LnByb3RvdHlwZSwge1xyXG5cclxuICAgIHNldExpZ2h0VHlwZTogZnVuY3Rpb24gKG1vZGVsSWQsIGRhdGEpIHtcclxuICAgICAgICBpZiAodGhpcy5tb2RlbCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5pZCA9PSBtb2RlbElkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIE5vdGhpbmcgY2hhbmdlZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmUubGlnaHRzLnJlbW92ZSh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5saWdodFN0cnVjdHVyZUNoYW5nZWQodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubW9kZWwgPSBjcmVhdGVMaWdodE1vZGVsKG1vZGVsSWQsIGRhdGEsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2NlbmUubGlnaHRzLmFkZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmxpZ2h0U3RydWN0dXJlQ2hhbmdlZChmYWxzZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldExvY2FsTWF0cml4OiBmdW5jdGlvbiAoc291cmNlKSB7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJSZW5kZXJMaWdodDo6c2V0TG9jYWxNYXRyaXggbm90IGltcGxlbWVudGVkXCIpO1xyXG4gICAgfSxcclxuXHJcblxyXG4gICAgZ2V0RnJ1c3R1bTogZnVuY3Rpb24gKGFzcGVjdCkge1xyXG4gICAgICAgIHRoaXMuc2NlbmUuZ2V0Qm91bmRpbmdCb3goY19Cb3VuZGluZ0JveCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZ2V0RnJ1c3R1bShhc3BlY3QsIGNfQm91bmRpbmdCb3gpO1xyXG4gICAgfSxcclxuXHJcbiAgICBsaWdodFZhbHVlQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm1vZGVsKSB7IC8vIEZJWE1FOiBDb21wbGV4IGRlcGVuZGVuY3lcclxuICAgICAgICAgICAgdGhpcy5zY2VuZS5lbWl0KEVWRU5UX1RZUEUuTElHSFRfVkFMVUVfQ0hBTkdFRCwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBsaWdodFN0cnVjdHVyZUNoYW5nZWQ6IGZ1bmN0aW9uIChyZW1vdmVkKSB7XHJcbiAgICAgICAgdGhpcy5zY2VuZS5lbWl0KEVWRU5UX1RZUEUuTElHSFRfU1RSVUNUVVJFX0NIQU5HRUQsIHRoaXMsIHJlbW92ZWQpO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVXb3JsZE1hdHJpeDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudC5nZXRXb3JsZE1hdHJpeCh0bXBfd29ybGRNYXRyaXgpO1xyXG4gICAgICAgICAgICB0aGlzLnNldFdvcmxkTWF0cml4KHRtcF93b3JsZE1hdHJpeCk7XHJcbiAgICAgICAgICAgIC8vIFdlIGNoYW5nZSBwb3NpdGlvbiAvIGRpcmVjdGlvbiBvZiB0aGUgbGlnaHRcclxuICAgICAgICAgICAgdGhpcy5saWdodFZhbHVlQ2hhbmdlZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgdmlzaWJpbGl0eUNoYW5nZWQ6IGZ1bmN0aW9uIChuZXdWYWwpIHtcclxuICAgICAgICAvLyBWaXNpYmlsaXR5IGlzIGEgbGlnaHQgcGFyYW1ldGVyXHJcbiAgICAgICAgdGhpcy5saWdodFZhbHVlQ2hhbmdlZCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRUcmFuc2Zvcm1EaXJ0eTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlV29ybGRNYXRyaXgoKTtcclxuICAgIH0sXHJcblxyXG5cclxuICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2NlbmUubGlnaHRzLnJlbW92ZSh0aGlzKTtcclxuICAgICAgICB0aGlzLmxpZ2h0U3RydWN0dXJlQ2hhbmdlZCh0cnVlKTtcclxuICAgIH0sXHJcblxyXG5cclxuICAgIGdldFdvcmxkU3BhY2VCb3VuZGluZ0JveDogZnVuY3Rpb24gKGJib3gpIHtcclxuICAgICAgICBiYm94LnNldEVtcHR5KCk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJMaWdodDtcclxuXHJcblxyXG4iLCIvKiogQGNvbnN0ICovXHJcbnZhciBXT1JMRF9NQVRSSVhfT0ZGU0VUID0gMDtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHR5cGVcclxuICogQHBhcmFtIHtTY2VuZX0gc2NlbmVcclxuICogQHBhcmFtIHtPYmplY3R9IHBhZ2VFbnRyeVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0XHJcbiAqL1xyXG52YXIgUmVuZGVyTm9kZSA9IGZ1bmN0aW9uICh0eXBlLCBzY2VuZSwgcGFnZUVudHJ5LCBvcHQpIHtcclxuICAgIG9wdCA9IG9wdCB8fCB7fTtcclxuXHJcbiAgICB0aGlzLnNjZW5lID0gc2NlbmU7XHJcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgdGhpcy5uYW1lID0gb3B0Lm5hbWUgfHwgXCJcIjtcclxuICAgIHRoaXMucGFnZSA9IHBhZ2VFbnRyeS5wYWdlO1xyXG4gICAgdGhpcy5vZmZzZXQgPSBwYWdlRW50cnkub2Zmc2V0O1xyXG4gICAgdGhpcy5lbnRyeVNpemUgPSBwYWdlRW50cnkuc2l6ZTtcclxuICAgIHRoaXMudHJhbnNmb3JtRGlydHkgPSB0cnVlO1xyXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuc2V0UGFyZW50KG9wdC5wYXJlbnQgfHwgc2NlbmUucm9vdE5vZGUpO1xyXG5cclxuICAgIHRoaXMubG9jYWxWaXNpYmxlID0gb3B0LnZpc2libGUgIT09IHVuZGVmaW5lZCA/IG9wdC52aXNpYmxlIDogdHJ1ZTtcclxuICAgIC8vIFRoZSBnbG9iYWwgdmlzaWJpbGl0eSBkZXBlbmRzIG9uIHZpc2liaWxpdHkgb2YgcGFyZW50c1xyXG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuICAgIHRoaXMuZXZhbHVhdGVWaXNpYmlsaXR5KCk7XHJcbn07XHJcblxyXG5YTUwzRC5leHRlbmQoUmVuZGVyTm9kZS5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBnZXRDaGlsZHJlbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuO1xyXG4gICAgfSxcclxuXHJcbiAgICBldmFsdWF0ZVZpc2liaWxpdHk6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBvbGRWaXNpYmxlID0gdGhpcy52aXNpYmxlO1xyXG4gICAgICAgIGlmKHRoaXMucGFyZW50ICYmICF0aGlzLnBhcmVudC52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZSA9IHRoaXMubG9jYWxWaXNpYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihvbGRWaXNpYmxlICE9PSB0aGlzLnZpc2libGUpIHtcclxuICAgICAgICAgICAgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lLnJlcXVlc3RSZWRyYXcgJiYgdGhpcy5zY2VuZS5yZXF1ZXN0UmVkcmF3KFwiVmlzaWJpbGl0eSBjaGFuZ2VkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldExvY2FsVmlzaWJsZTogZnVuY3Rpb24obmV3VmlzaWJsZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmxvY2FsVmlzaWJsZSA9PT0gbmV3VmlzaWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9jYWxWaXNpYmxlID0gbmV3VmlzaWJsZTtcclxuICAgICAgICB0aGlzLmV2YWx1YXRlVmlzaWJpbGl0eSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBOZWVkcyB0byBiZSBvdmVyd3JpdHRlblxyXG4gICAgdmlzaWJpbGl0eUNoYW5nZWQ6IGZ1bmN0aW9uKCkge30sXHJcblxyXG4gICAgZ2V0UGFyZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRQYXJlbnQ6IGZ1bmN0aW9uIChwYXJlbnQpIHtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5hZGRDaGlsZCkge1xyXG4gICAgICAgICAgICBwYXJlbnQuYWRkQ2hpbGQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlZXZhbHVhdGUgdmlzaWJpbGl0eSwgd2hpY2ggbWlnaHQgY2hhbmdlIGR1ZSB0b1xyXG4gICAgICAgIC8vIGludmlzaWJpbGl0eSBvZiBwYXJlbnRcclxuICAgICAgICB0aGlzLmV2YWx1YXRlVmlzaWJpbGl0eSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY2FsbGJhY2sodGhpcyk7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICBjaGlsZC50cmF2ZXJzZShjYWxsYmFjayk7XHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge01hdDR9IHNvdXJjZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxyXG4gICAgICovXHJcbiAgICBzZXRNYXQ0SW5QYWdlOiBmdW5jdGlvbihzb3VyY2UsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciBvID0gdGhpcy5vZmZzZXQgKyBvZmZzZXQ7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDE2OyBpKyssIG8rKykge1xyXG4gICAgICAgICAgICB0aGlzLnBhZ2Vbb10gPSBzb3VyY2VbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7TWF0NH0gZGVzdFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxyXG4gICAgICovXHJcbiAgICBnZXRNYXQ0RnJvbVBhZ2U6IGZ1bmN0aW9uKGRlc3QsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciBvID0gdGhpcy5vZmZzZXQgKyBvZmZzZXQ7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDE2OyBpKyssIG8rKykge1xyXG4gICAgICAgICAgICBkZXN0W2ldID0gdGhpcy5wYWdlW29dO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0V29ybGRNYXRyaXg6IGZ1bmN0aW9uIChkZXN0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtRGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuZ2V0V29ybGRNYXRyaXgoZGVzdCk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlV29ybGRNYXRyaXgoZGVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ2V0TWF0NEZyb21QYWdlKGRlc3QsIFdPUkxEX01BVFJJWF9PRkZTRVQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRXb3JsZE1hdHJpeDogZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgIHRoaXMuc2V0TWF0NEluUGFnZShzb3VyY2UsIFdPUkxEX01BVFJJWF9PRkZTRVQpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtRGlydHkgPSBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5zZXRCb3VuZGluZ0JveERpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Qm91bmRpbmdCb3hEaXJ0eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgc2V0VHJhbnNmb3JtRGlydHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybURpcnR5ID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zY2VuZS5wYWdlci5mcmVlUGFnZUVudHJ5KHtwYWdlOiB0aGlzLnBhZ2UsIG9mZnNldDogdGhpcy5vZmZzZXQsIHNpemU6IHRoaXMuZW50cnlTaXplfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZpbmRSYXlJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbiAoLyogcmF5LCBjbG9zZXN0SW50ZXJzZWN0aW9uKi8pIHtcclxuICAgICAgICAvL1RoaXMgZnVuY3Rpb24gaXMgb3ZlcnJpZGRlbiBieSBncm91cHMgYW5kIGRyYXdhYmxlc1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlck5vZGU7XHJcbiIsInZhciBTeXN0ZW1Ob3RpZmllciA9IHJlcXVpcmUoXCIuLi8uLi93ZWJnbC9zeXN0ZW0vc3lzdGVtLW5vdGlmaWVyLmpzXCIpO1xyXG52YXIgUmVuZGVyTm9kZSA9IHJlcXVpcmUoXCIuL3JlbmRlcm5vZGUuanNcIik7XHJcbnZhciBEcmF3YWJsZUNsb3N1cmU9IHJlcXVpcmUoXCIuL2RyYXdhYmxlY2xvc3VyZS5qc1wiKTtcclxudmFyIEMgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XHJcbnZhciBTY2VuZT0gcmVxdWlyZShcIi4vc2NlbmUuanNcIik7XHJcbnZhciBDb21wdXRlUmVxdWVzdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvcmVxdWVzdC5qc1wiKS5Db21wdXRlUmVxdWVzdDtcclxudmFyIG1hdDQgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLm1hdDQ7XHJcblxyXG4vLyBFbnRyeTpcclxuLyoqIEBjb25zdCAqL1xyXG52YXIgV09STERfTUFUUklYX09GRlNFVCA9IDA7XHJcbi8qKiBAY29uc3QgKi9cclxudmFyIExPQ0FMX01BVFJJWF9PRkZTRVQgPSBXT1JMRF9NQVRSSVhfT0ZGU0VUICsgMTY7XHJcbi8qKiBAY29uc3QgKi9cclxudmFyIE9CSkVDVF9CQl9PRkZTRVQgPSBMT0NBTF9NQVRSSVhfT0ZGU0VUICsgMTY7XHJcbi8qKiBAY29uc3QgKi9cclxudmFyIFdPUkxEX0JCX09GRlNFVCA9IE9CSkVDVF9CQl9PRkZTRVQgKyA2O1xyXG4vKiogQGNvbnN0ICovXHJcbnZhciBNT0RFTFZJRVdfTUFUUklYX09GRlNFVCA9IFdPUkxEX0JCX09GRlNFVCArIDY7XHJcbi8qKiBAY29uc3QgKi9cclxudmFyIE1PREVMVklFV1BST0pFQ1RJT05fTUFUUklYX09GRlNFVCA9IE1PREVMVklFV19NQVRSSVhfT0ZGU0VUICsgMTY7XHJcbi8qKiBAY29uc3QgKi9cclxudmFyIE1PREVMX01BVFJJWF9OX09GRlNFVCA9IE1PREVMVklFV1BST0pFQ1RJT05fTUFUUklYX09GRlNFVCArIDE2O1xyXG4vKiogQGNvbnN0ICovXHJcbnZhciBNT0RFTFZJRVdfTUFUUklYX05fT0ZGU0VUID0gTU9ERUxfTUFUUklYX05fT0ZGU0VUICsgMTY7XHJcbi8qKiBAY29uc3QgKi9cclxudmFyIEVOVFJZX1NJWkUgPSBNT0RFTFZJRVdfTUFUUklYX05fT0ZGU0VUICsgMTY7XHJcblxyXG4vL25vaW5zcGVjdGlvbiBKU0Nsb3N1cmVDb21waWxlclN5bnRheCxKU0Nsb3N1cmVDb21waWxlclN5bnRheFxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIHJlbmRlcmFibGUgb2JqZWN0IGluIHRoZSBzY2VuZS5cclxuICogVGhlIFJlbmRlck9iamVjdCBoYXMgdGhlc2UgcmVzcG9uc2liaWxpdGllczpcclxuICogIDEuIEtlZXAgdHJhY2sgb2YgdGhlIHRyYW5zZm9ybWF0aW9uIGhpZXJhcmNoeSBhbmQgYm91bmRpbmcgYm94ZXNcclxuICogIDIuIENvbm5lY3QgdGhlIERyYXdhYmxlQ2xvc3VyZSB3aXRoIHRoZSBTaGFkZXJDbG9zdXJlXHJcbiAqXHJcbiAqICBUaGUge0BsaW5rIERyYXdhYmxlQ2xvc3VyZX0gaXMgYSBEcmF3YWJsZU9iamVjdCBwbHVzIGl0J3MgZGF0YVxyXG4gKiAgVGhlIHtAbGluayBTaGFkZXJDbG9zdXJlfSBpcyBhIFByb2dyYW1PYmplY3QgcGx1cyBpdCdzIGRhdGFcclxuICogIFRoZSBjb25jcmV0ZSBTaGFkZXJDbG9zdXJlIGNhbiB2YXJ5IHBlciBEcmF3YWJsZU9iamVjdCBhbmQgY2hhbmdlXHJcbiAqICBkdWUgdG8gc2NlbmUgb3Igb2JqZWN0IGNoYW5nZXMuIFRodXMgd2UgaGF2ZSB0byBrZWVwIHRyYWNrIG9mIHRoZVxyXG4gKiAgcmVsYXRlZCB7QGxpbmsgSVNoYWRlckNvbXBvc2VyfS5cclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBpbXBsZW1lbnRzIHtJUmVuZGVyT2JqZWN0fVxyXG4gKiBAcGFyYW0ge1NjZW5lfSBzY2VuZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gcGFnZUVudHJ5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcclxuICovXHJcbnZhciBSZW5kZXJPYmplY3QgPSBmdW5jdGlvbiAoc2NlbmUsIHBhZ2VFbnRyeSwgb3B0KSB7XHJcbiAgICBSZW5kZXJOb2RlLmNhbGwodGhpcywgQy5OT0RFX1RZUEUuT0JKRUNULCBzY2VuZSwgcGFnZUVudHJ5LCBvcHQpO1xyXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogS2VlcCByZWZlcmVuY2UgdG8gRE9NIEVsZW1lbnQgbmVlZCBlLmcuIGZvciBwaWNraW5nXHJcbiAgICAgKiBAdHlwZSB7RWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5ub2RlID0gb3B0Lm5vZGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYmplY3QgcmVsYXRlZCBkYXRhXHJcbiAgICAgKiBAdHlwZSB7e2RhdGE6IERhdGFOb2RlfG51bGwsIHR5cGU6IHN0cmluZ319XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IG9wdC5jb25maWd1cmF0aW9uIHx8IHtkYXRhOiBudWxsLCB0eXBlOiBcInRyaWFuZ2xlc1wifTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbiB3ZSByZWx5IG9uIGN1cnJlbnQgV29ybGRNYXRyaXg/XHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy50cmFuc2Zvcm1EaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW4gd2UgcmVseSBvbiBjdXJyZW50IEJvdW5kaW5nIEJveGVzP1xyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYm91bmRpbmdCb3hEaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZHJhd2FibGUgY2xvc3VyZSB0cmFuc2Zvcm1zIG9iamVjdCBkYXRhIGFuZCB0eXBlIGludG9cclxuICAgICAqIGEgZHJhd2FibGUgZW50aXR5XHJcbiAgICAgKiBAdHlwZSB7RHJhd2FibGVDbG9zdXJlfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRyYXdhYmxlID0gdGhpcy5jcmVhdGVEcmF3YWJsZSgpO1xyXG5cclxuICAgIHRoaXMuX21hdGVyaWFsID0gb3B0Lm1hdGVyaWFsIHx8IG51bGw7XHJcbiAgICB0aGlzLl96SW5kZXggPSBvcHQuekluZGV4IHx8IFwiMFwiO1xyXG4gICAgdGhpcy5fYWN0dWFsTWF0ZXJpYWwgPSBudWxsO1xyXG4gICAgdGhpcy5waWNrSWQgPSAtMTtcclxuICAgIHRoaXMuaW5pdE1hdGVyaWFsKCk7XHJcblxyXG4gICAgLyoqIHtPYmplY3Q/fSAqKi9cclxuICAgIHRoaXMub3ZlcnJpZGUgPSBudWxsO1xyXG59O1xyXG5SZW5kZXJPYmplY3QuRU5UUllfU0laRSA9IEVOVFJZX1NJWkU7XHJcblxyXG5SZW5kZXJPYmplY3QuSURFTlRJVFlfTUFUUklYID0gbWF0NC5jcmVhdGUoKTtcclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKFJlbmRlck9iamVjdCwgUmVuZGVyTm9kZSwge1xyXG4gICAgY3JlYXRlRHJhd2FibGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5zY2VuZS5jcmVhdGVEcmF3YWJsZSh0aGlzKTtcclxuICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgcmVzdWx0Lm9uKEMuRVZFTlRfVFlQRS5EUkFXQUJMRV9TVEFURV9DSEFOR0VELCBmdW5jdGlvbiAobmV3U3RhdGUsIG9sZFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09IERyYXdhYmxlQ2xvc3VyZS5SRUFEWV9TVEFURS5DT01QTEVURSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2NlbmUubW92ZUZyb21RdWV1ZVRvUmVhZHkodGhhdCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5ld1N0YXRlID09PSBEcmF3YWJsZUNsb3N1cmUuUkVBRFlfU1RBVEUuSU5DT01QTEVURSAmJiBvbGRTdGF0ZSA9PT0gRHJhd2FibGVDbG9zdXJlLlJFQURZX1NUQVRFLkNPTVBMRVRFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zY2VuZS5tb3ZlRnJvbVJlYWR5VG9RdWV1ZSh0aGF0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJlc3VsdC51cGRhdGVUeXBlUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICByZXN1bHQuY2FsY3VsYXRlQm91bmRpbmdCb3goKTtcclxuICAgICAgICAgICAgcmVzdWx0Lm9uKEMuRVZFTlRfVFlQRS5TQ0VORV9TSEFQRV9DSEFOR0VELCBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnNjZW5lLmVtaXQoQy5FVkVOVF9UWVBFLlNDRU5FX1NIQVBFX0NIQU5HRUQpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldExvY2FsTWF0cml4OiBmdW5jdGlvbiAoZGVzdCkge1xyXG4gICAgICAgIHRoaXMuZ2V0TWF0NEZyb21QYWdlKGRlc3QsIExPQ0FMX01BVFJJWF9PRkZTRVQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRMb2NhbE1hdHJpeDogZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgIHRoaXMuc2V0TWF0NEluUGFnZShzb3VyY2UsIExPQ0FMX01BVFJJWF9PRkZTRVQpO1xyXG4gICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtRGlydHkoKTtcclxuICAgICAgICB0aGlzLnNldEJvdW5kaW5nQm94RGlydHkoKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2NlbmUucmVtb3ZlKHRoaXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvblRyYW5zZm9ybURhdGFDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldE1vZGVsVmlld01hdHJpeDogZnVuY3Rpb24gKGRlc3QpIHtcclxuICAgICAgICB0aGlzLmdldE1hdDRGcm9tUGFnZShkZXN0LCBNT0RFTFZJRVdfTUFUUklYX09GRlNFVCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldE1vZGVsTWF0cml4TjogZnVuY3Rpb24gKGRlc3QpIHtcclxuICAgICAgICB2YXIgbyA9IHRoaXMub2Zmc2V0ICsgTU9ERUxfTUFUUklYX05fT0ZGU0VUO1xyXG4gICAgICAgIGRlc3RbMF0gPSB0aGlzLnBhZ2Vbb107XHJcbiAgICAgICAgZGVzdFsxXSA9IHRoaXMucGFnZVtvICsgMV07XHJcbiAgICAgICAgZGVzdFsyXSA9IHRoaXMucGFnZVtvICsgMl07XHJcbiAgICAgICAgZGVzdFszXSA9IHRoaXMucGFnZVtvICsgNF07XHJcbiAgICAgICAgZGVzdFs0XSA9IHRoaXMucGFnZVtvICsgNV07XHJcbiAgICAgICAgZGVzdFs1XSA9IHRoaXMucGFnZVtvICsgNl07XHJcbiAgICAgICAgZGVzdFs2XSA9IHRoaXMucGFnZVtvICsgOF07XHJcbiAgICAgICAgZGVzdFs3XSA9IHRoaXMucGFnZVtvICsgOV07XHJcbiAgICAgICAgZGVzdFs4XSA9IHRoaXMucGFnZVtvICsgMTBdO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRNb2RlbFZpZXdNYXRyaXhOOiBmdW5jdGlvbiAoZGVzdCkge1xyXG4gICAgICAgIHZhciBvID0gdGhpcy5vZmZzZXQgKyBNT0RFTFZJRVdfTUFUUklYX05fT0ZGU0VUO1xyXG4gICAgICAgIGRlc3RbMF0gPSB0aGlzLnBhZ2Vbb107XHJcbiAgICAgICAgZGVzdFsxXSA9IHRoaXMucGFnZVtvICsgMV07XHJcbiAgICAgICAgZGVzdFsyXSA9IHRoaXMucGFnZVtvICsgMl07XHJcbiAgICAgICAgZGVzdFszXSA9IHRoaXMucGFnZVtvICsgNF07XHJcbiAgICAgICAgZGVzdFs0XSA9IHRoaXMucGFnZVtvICsgNV07XHJcbiAgICAgICAgZGVzdFs1XSA9IHRoaXMucGFnZVtvICsgNl07XHJcbiAgICAgICAgZGVzdFs2XSA9IHRoaXMucGFnZVtvICsgOF07XHJcbiAgICAgICAgZGVzdFs3XSA9IHRoaXMucGFnZVtvICsgOV07XHJcbiAgICAgICAgZGVzdFs4XSA9IHRoaXMucGFnZVtvICsgMTBdO1xyXG4gICAgfSxcclxuXHJcblxyXG4gICAgZ2V0TW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeDogZnVuY3Rpb24gKGRlc3QpIHtcclxuICAgICAgICB0aGlzLmdldE1hdDRGcm9tUGFnZShkZXN0LCBNT0RFTFZJRVdQUk9KRUNUSU9OX01BVFJJWF9PRkZTRVQpO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVXb3JsZFNwYWNlTWF0cmljZXM6IGZ1bmN0aW9uICh2aWV3LCBwcm9qZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtRGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVwZGF0ZU1vZGVsVmlld01hdHJpeCh2aWV3KTtcclxuICAgICAgICB0aGlzLnVwZGF0ZU1vZGVsTWF0cml4TigpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTW9kZWxWaWV3TWF0cml4TigpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeChwcm9qZWN0aW9uKTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlV29ybGRNYXRyaXg6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRtcF9tYXQgPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmdldFdvcmxkTWF0cml4KHRtcF9tYXQpO1xyXG4gICAgICAgICAgICB2YXIgcGFnZSA9IHRoaXMucGFnZTtcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgICAgICBYTUwzRC5tYXRoLm1hdDQubXVsdGlwbHlPZmZzZXQodG1wX21hdCwgMCwgcGFnZSwgb2Zmc2V0ICsgTE9DQUxfTUFUUklYX09GRlNFVCwgdG1wX21hdCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0V29ybGRNYXRyaXgodG1wX21hdCk7XHJcbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3hEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtRGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9KSgpLFxyXG5cclxuICAgIC8qKiBSZWxpZXMgb24gYW4gdXAtdG8tZGF0ZSB0cmFuc2Zvcm0gbWF0cml4ICoqL1xyXG4gICAgdXBkYXRlTW9kZWxWaWV3TWF0cml4OiBmdW5jdGlvbiAodmlldykge1xyXG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybURpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlV29ybGRNYXRyaXgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhZ2UgPSB0aGlzLnBhZ2U7XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIFhNTDNELm1hdGgubWF0NC5tdWx0aXBseU9mZnNldChwYWdlLCBvZmZzZXQgKyBNT0RFTFZJRVdfTUFUUklYX09GRlNFVCwgcGFnZSwgb2Zmc2V0ICsgV09STERfTUFUUklYX09GRlNFVCwgdmlldywgMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZU1vZGVsTWF0cml4TjogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY190bXBNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0V29ybGRNYXRyaXgoY190bXBNYXRyaXgpO1xyXG4gICAgICAgICAgICBtYXQ0LmludmVydChjX3RtcE1hdHJpeCwgY190bXBNYXRyaXgpO1xyXG4gICAgICAgICAgICB2YXIgbm9ybWFsTWF0cml4ID0gY190bXBNYXRyaXggPyBtYXQ0LnRyYW5zcG9zZShjX3RtcE1hdHJpeCwgY190bXBNYXRyaXgpIDogUmVuZGVyT2JqZWN0LklERU5USVRZX01BVFJJWDtcclxuICAgICAgICAgICAgdGhpcy5zZXRNYXQ0SW5QYWdlKG5vcm1hbE1hdHJpeCwgTU9ERUxfTUFUUklYX05fT0ZGU0VUKTtcclxuICAgICAgICB9XHJcbiAgICB9KSgpLFxyXG5cclxuICAgIC8qKiBSZWxpZXMgb24gYW4gdXAtdG8tZGF0ZSB2aWV3IG1hdHJpeCAqKi9cclxuICAgIHVwZGF0ZU1vZGVsVmlld01hdHJpeE46IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNfdG1wTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmdldE1vZGVsVmlld01hdHJpeChjX3RtcE1hdHJpeCk7XHJcbiAgICAgICAgICAgIG1hdDQuaW52ZXJ0KGNfdG1wTWF0cml4LCBjX3RtcE1hdHJpeCk7XHJcbiAgICAgICAgICAgIHZhciBub3JtYWxNYXRyaXggPSBjX3RtcE1hdHJpeCA/IG1hdDQudHJhbnNwb3NlKGNfdG1wTWF0cml4LCBjX3RtcE1hdHJpeCkgOiBSZW5kZXJPYmplY3QuSURFTlRJVFlfTUFUUklYO1xyXG4gICAgICAgICAgICB0aGlzLnNldE1hdDRJblBhZ2Uobm9ybWFsTWF0cml4LCBNT0RFTFZJRVdfTUFUUklYX05fT0ZGU0VUKTtcclxuICAgICAgICB9XHJcbiAgICB9KSgpLFxyXG5cclxuXHJcbiAgICAvKiogUmVsaWVzIG9uIGFuIHVwLXRvLWRhdGUgdmlldyBtYXRyaXggKiovXHJcbiAgICB1cGRhdGVNb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4OiBmdW5jdGlvbiAocHJvamVjdGlvbikge1xyXG4gICAgICAgIHZhciBwYWdlID0gdGhpcy5wYWdlO1xyXG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldDtcclxuICAgICAgICBYTUwzRC5tYXRoLm1hdDQubXVsdGlwbHlPZmZzZXQocGFnZSwgb2Zmc2V0ICsgTU9ERUxWSUVXUFJPSkVDVElPTl9NQVRSSVhfT0ZGU0VULCBwYWdlLCBvZmZzZXQgKyBNT0RFTFZJRVdfTUFUUklYX09GRlNFVCwgcHJvamVjdGlvbiwgMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRyYW5zZm9ybURpcnR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1EaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZXRCb3VuZGluZ0JveERpcnR5KCk7XHJcbiAgICAgICAgdGhpcy5zY2VuZS5lbWl0KEMuRVZFTlRfVFlQRS5TQ0VORV9TSEFQRV9DSEFOR0VEKTtcclxuICAgICAgICB0aGlzLnNjZW5lLnJlcXVlc3RSZWRyYXcoXCJUcmFuc2Zvcm1hdGlvbiBjaGFuZ2VkXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRPYmplY3RTcGFjZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoYm94KSB7XHJcbiAgICAgICAgdmFyIG8gPSB0aGlzLm9mZnNldCArIE9CSkVDVF9CQl9PRkZTRVQ7XHJcbiAgICAgICAgdGhpcy5wYWdlW29dID0gYm94LmRhdGFbMF07XHJcbiAgICAgICAgdGhpcy5wYWdlW28gKyAxXSA9IGJveC5kYXRhWzFdO1xyXG4gICAgICAgIHRoaXMucGFnZVtvICsgMl0gPSBib3guZGF0YVsyXTtcclxuICAgICAgICB0aGlzLnBhZ2VbbyArIDNdID0gYm94LmRhdGFbM107XHJcbiAgICAgICAgdGhpcy5wYWdlW28gKyA0XSA9IGJveC5kYXRhWzRdO1xyXG4gICAgICAgIHRoaXMucGFnZVtvICsgNV0gPSBib3guZGF0YVs1XTtcclxuICAgICAgICB0aGlzLnNldEJvdW5kaW5nQm94RGlydHkoKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0T2JqZWN0U3BhY2VCb3VuZGluZ0JveDogZnVuY3Rpb24gKGJveCkge1xyXG4gICAgICAgIHZhciBvID0gdGhpcy5vZmZzZXQgKyBPQkpFQ1RfQkJfT0ZGU0VUO1xyXG4gICAgICAgIGJveC5kYXRhWzBdID0gdGhpcy5wYWdlW29dO1xyXG4gICAgICAgIGJveC5kYXRhWzFdID0gdGhpcy5wYWdlW28gKyAxXTtcclxuICAgICAgICBib3guZGF0YVsyXSA9IHRoaXMucGFnZVtvICsgMl07XHJcbiAgICAgICAgYm94LmRhdGFbM10gPSB0aGlzLnBhZ2VbbyArIDNdO1xyXG4gICAgICAgIGJveC5kYXRhWzRdID0gdGhpcy5wYWdlW28gKyA0XTtcclxuICAgICAgICBib3guZGF0YVs1XSA9IHRoaXMucGFnZVtvICsgNV07XHJcbiAgICB9LFxyXG5cclxuICAgIHNldEJvdW5kaW5nQm94RGlydHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nQm94RGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucGFyZW50LnNldEJvdW5kaW5nQm94RGlydHkoKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0V29ybGRTcGFjZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoYmJveCkge1xyXG4gICAgICAgIHZhciBvID0gdGhpcy5vZmZzZXQgKyBXT1JMRF9CQl9PRkZTRVQ7XHJcbiAgICAgICAgdGhpcy5wYWdlW29dID0gYmJveC5kYXRhWzBdO1xyXG4gICAgICAgIHRoaXMucGFnZVtvICsgMV0gPSBiYm94LmRhdGFbMV07XHJcbiAgICAgICAgdGhpcy5wYWdlW28gKyAyXSA9IGJib3guZGF0YVsyXTtcclxuICAgICAgICB0aGlzLnBhZ2VbbyArIDNdID0gYmJveC5kYXRhWzNdO1xyXG4gICAgICAgIHRoaXMucGFnZVtvICsgNF0gPSBiYm94LmRhdGFbNF07XHJcbiAgICAgICAgdGhpcy5wYWdlW28gKyA1XSA9IGJib3guZGF0YVs1XTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0V29ybGRTcGFjZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoYmJveCkge1xyXG4gICAgICAgIGlmICh0aGlzLmJvdW5kaW5nQm94RGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVXb3JsZFNwYWNlQm91bmRpbmdCb3goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG8gPSB0aGlzLm9mZnNldCArIFdPUkxEX0JCX09GRlNFVDtcclxuICAgICAgICBiYm94LmRhdGFbMF0gPSB0aGlzLnBhZ2Vbb107XHJcbiAgICAgICAgYmJveC5kYXRhWzFdID0gdGhpcy5wYWdlW28gKyAxXTtcclxuICAgICAgICBiYm94LmRhdGFbMl0gPSB0aGlzLnBhZ2VbbyArIDJdO1xyXG4gICAgICAgIGJib3guZGF0YVszXSA9IHRoaXMucGFnZVtvICsgM107XHJcbiAgICAgICAgYmJveC5kYXRhWzRdID0gdGhpcy5wYWdlW28gKyA0XTtcclxuICAgICAgICBiYm94LmRhdGFbNV0gPSB0aGlzLnBhZ2VbbyArIDVdO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlV29ybGRTcGFjZUJvdW5kaW5nQm94OiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjX2JveCA9IG5ldyBYTUwzRC5Cb3goKTtcclxuICAgICAgICB2YXIgY190cmFucyA9IG1hdDQuY3JlYXRlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmKCF0aGlzLnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIGNfYm94LnNldEVtcHR5KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldE9iamVjdFNwYWNlQm91bmRpbmdCb3goY19ib3gpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRXb3JsZE1hdHJpeChjX3RyYW5zKTtcclxuICAgICAgICAgICAgICAgIGNfYm94LnRyYW5zZm9ybUF4aXNBbGlnbmVkKGNfdHJhbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2V0V29ybGRTcGFjZUJvdW5kaW5nQm94KGNfYm94KTtcclxuICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveERpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSkoKSxcclxuXHJcbiAgICB2aXNpYmlsaXR5Q2hhbmdlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2V0Qm91bmRpbmdCb3hEaXJ0eSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRQcm9ncmFtOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd2FibGUuZ2V0UHJvZ3JhbSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBoYXNUcmFuc3BhcmVuY3k6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcHJvZ3JhbSA9IHRoaXMuZ2V0UHJvZ3JhbSgpO1xyXG4gICAgICAgIHJldHVybiBwcm9ncmFtID8gcHJvZ3JhbS5oYXNUcmFuc3BhcmVuY3koKSA6IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVGb3JSZW5kZXJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBTeXN0ZW1Ob3RpZmllci5zZXROb2RlKHRoaXMubm9kZSk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5kcmF3YWJsZSAmJiB0aGlzLmRyYXdhYmxlLnVwZGF0ZSh0aGlzLnNjZW5lKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiTWVzaCBFcnJvcjogXCIgKyBlLm1lc3NhZ2UsIHRoaXMubm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFN5c3RlbU5vdGlmaWVyLnNldE5vZGUobnVsbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZpbmRSYXlJbnRlcnNlY3Rpb25zOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBiYm94ID0gbmV3IFhNTDNELkJveCgpO1xyXG4gICAgICAgIHZhciBvcHQgPSB7ZGlzdDogMH07XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocmF5LCBpbnRlcnNlY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0V29ybGRTcGFjZUJvdW5kaW5nQm94KGJib3gpO1xyXG4gICAgICAgICAgICBpZiAocmF5LmludGVyc2VjdHMoYmJveCwgb3B0KSkge1xyXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSkoKSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge01hdGVyaWFsQ29uZmlndXJhdGlvbnxudWxsfSBtYXRlcmlhbFxyXG4gICAgICovXHJcbiAgICBzZXRNYXRlcmlhbDogZnVuY3Rpb24gKG1hdGVyaWFsKSB7XHJcbiAgICAgICAgaWYodGhpcy5fbWF0ZXJpYWwgPT09IG1hdGVyaWFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbWF0ZXJpYWwgPSBtYXRlcmlhbDtcclxuICAgICAgICBpZiAobWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0dWFsTWF0ZXJpYWwgPSBtYXRlcmlhbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3R1YWxNYXRlcmlhbCA9IHRoaXMucGFyZW50LmdldE1hdGVyaWFsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWF0ZXJpYWxDaGFuZ2VkKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFpJbmRleDogZnVuY3Rpb24oekluZGV4KXtcclxuICAgICAgICB0aGlzLl96SW5kZXggPSB6SW5kZXg7XHJcbiAgICB9LFxyXG5cclxuICAgIHBhcmVudE1hdGVyaWFsQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9tYXRlcmlhbCkge1xyXG4gICAgICAgICAgICAvLyBMb2NhbCBtYXRlcmlhbCBvdmVycmlkZXMgdGhlIGNoYW5nZSBmcm9tIGFib3ZlXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbml0TWF0ZXJpYWwoKTtcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdE1hdGVyaWFsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21hdGVyaWFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdHVhbE1hdGVyaWFsID0gdGhpcy5fbWF0ZXJpYWw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0dWFsTWF0ZXJpYWwgPSB0aGlzLnBhcmVudC5nZXRNYXRlcmlhbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1hdGVyaWFsQ2hhbmdlZCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBtYXRlcmlhbENoYW5nZWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKFwibWF0ZXJpYWwgY2hhbmdlZFwiLCB0aGlzLl9hY3R1YWxNYXRlcmlhbCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZHJhd2FibGUpIHtcclxuICAgICAgICAgICAgdmFyIGNvbXBvc2VyID0gdGhpcy5zY2VuZS5zaGFkZXJGYWN0b3J5LmNyZWF0ZUNvbXBvc2VyRnJvbU1hdGVyaWFsQ29uZmlndXJhdGlvbih0aGlzLl9hY3R1YWxNYXRlcmlhbCk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd2FibGUuc2V0U2hhZGVyQ29tcG9zZXIoY29tcG9zZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnNjZW5lLnBhZ2VyLmZyZWVQYWdlRW50cnkoe3BhZ2U6IHRoaXMucGFnZSwgb2Zmc2V0OiB0aGlzLm9mZnNldCwgc2l6ZTogdGhpcy5lbnRyeVNpemV9KTtcclxuICAgICAgICBpZiAodGhpcy5kcmF3YWJsZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdhYmxlLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcblxyXG4vLyBFeHBvcnRcclxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJPYmplY3Q7XHJcblxyXG4iLCJ2YXIgUmVuZGVyTm9kZSA9IHJlcXVpcmUoXCIuL3JlbmRlcm5vZGUuanNcIik7XHJcbnZhciBDYW1lcmFNb2RlbHMgPSByZXF1aXJlKFwiLi4vY2FtZXJhcy9jYW1lcmEtbW9kZWxzLmpzXCIpO1xyXG52YXIgQ29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xyXG52YXIgRnJ1c3R1bSA9IHJlcXVpcmUoXCIuLi90b29scy9mcnVzdHVtLmpzXCIpLkZydXN0dW07XHJcbnZhciB2ZWMzID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS52ZWMzO1xyXG52YXIgbWF0NCA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikubWF0NDtcclxuXHJcbi8qKiBAY29uc3QgKi9cclxudmFyIENMSVBQTEFORV9ORUFSX01JTiA9IDAuMDE7XHJcblxyXG52YXIgTk9ERV9UWVBFID0gQ29uc3RhbnRzLk5PREVfVFlQRTtcclxudmFyIEVWRU5UX1RZUEUgPSBDb25zdGFudHMuRVZFTlRfVFlQRTtcclxuXHJcbi8qKiBAY29uc3QgKi9cclxudmFyIFZJRVdfVE9fV09STERfTUFUUklYX09GRlNFVCA9IDA7XHJcbi8qKiBAY29uc3QgKi9cclxudmFyIFdPUkxEX1RPX1ZJRVdfTUFUUklYX09GRlNFVCA9IDE2O1xyXG4vKiogQGNvbnN0ICovXHJcbnZhciBQUk9KRUNUSU9OX01BVFJJWF9PRkZTRVQgPSAzMjtcclxuLyoqIEBjb25zdCAqL1xyXG52YXIgRU5UUllfU0laRSA9IFBST0pFQ1RJT05fTUFUUklYX09GRlNFVCArIDE2O1xyXG5cclxudmFyIERFRkFVTFRfQ0FNRVJBX0NPTkZJR1VSQVRJT04gPSB7IG1vZGVsOiBcInVybjp4bWwzZDp2aWV3OnBlcnNwZWN0aXZlXCIsIGRhdGFOb2RlOiBudWxsIH07XHJcblxyXG4vKipcclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIHtSZW5kZXJOb2RlfVxyXG4gKi9cclxudmFyIFJlbmRlclZpZXcgPSBmdW5jdGlvbiAoc2NlbmUsIHBhZ2VFbnRyeSwgb3B0KSB7XHJcbiAgICBSZW5kZXJOb2RlLmNhbGwodGhpcywgTk9ERV9UWVBFLlZJRVcsIHNjZW5lLCBwYWdlRW50cnksIG9wdCk7XHJcbiAgICBvcHQgPSBvcHQgfHwge307XHJcblxyXG4gICAgdGhpcy5sYXN0QXNwZWN0UmF0aW8gPSAxO1xyXG4gICAgdGhpcy5wcm9qZWN0aW9uRGlydHkgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMuY2FtZXJhID0gY3JlYXRlQ2FtZXJhKG9wdC5jYW1lcmEgPyBvcHQuY2FtZXJhIDogREVGQVVMVF9DQU1FUkFfQ09ORklHVVJBVElPTiwgc2NlbmUsIHRoaXMpO1xyXG4gICAgdGhpcy5sb2NhbE1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XHJcbiAgICB0aGlzLndvcmxkU3BhY2VQb3NpdGlvbiA9IHZlYzMuY3JlYXRlKCk7XHJcbiAgICB0aGlzLnZpZXdEaXJ0eSA9IHRydWU7XHJcbiAgICB0aGlzLmZydXN0dW0gPSBudWxsO1xyXG59O1xyXG5SZW5kZXJWaWV3LkVOVFJZX1NJWkUgPSBFTlRSWV9TSVpFO1xyXG5cclxuWE1MM0QuY3JlYXRlQ2xhc3MoUmVuZGVyVmlldywgUmVuZGVyTm9kZSk7XHJcblxyXG5YTUwzRC5leHRlbmQoUmVuZGVyVmlldy5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBzZXRMb2NhbE1hdHJpeDogZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgIHRoaXMubG9jYWxNYXRyaXggPSBzb3VyY2U7XHJcbiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1EaXJ0eSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRGcnVzdHVtOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJ1c3R1bTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlVmlld01hdHJpeDogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdG1wX21hdDQgPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciB0bXBfcGFyZW50ID0gbWF0NC5jcmVhdGUoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbWF0NC5jb3B5KHRtcF9tYXQ0LCB0aGlzLmxvY2FsTWF0cml4KTtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuZ2V0V29ybGRNYXRyaXgodG1wX3BhcmVudCk7XHJcbiAgICAgICAgICAgIG1hdDQubXVsdGlwbHkodG1wX21hdDQsIHRtcF9wYXJlbnQsIHRtcF9tYXQ0KTtcclxuICAgICAgICAgICAgdmVjMy5zZXQodGhpcy53b3JsZFNwYWNlUG9zaXRpb24sIHRtcF9tYXQ0WzEyXSwgdG1wX21hdDRbMTNdLCB0bXBfbWF0NFsxNF0pO1xyXG4gICAgICAgICAgICB0aGlzLnNldFZpZXdUb1dvcmxkTWF0cml4KHRtcF9tYXQ0KTtcclxuICAgICAgICAgICAgbWF0NC5pbnZlcnQodG1wX21hdDQsIHRtcF9tYXQ0KTtcclxuICAgICAgICAgICAgdGhpcy5zZXRXb3JsZFRvVmlld01hdHJpeCh0bXBfbWF0NCk7XHJcbiAgICAgICAgICAgIHRoaXMudmlld0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIFZpZXcgZnJ1c3R1bSBtaWdodCBoYXZlIGNoYW5nZWQgZHVlIHRvIGNsaXBwaW5nIHBsYW5lc1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdGcnVzdHVtQ2hhbmdlZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pKCksXHJcblxyXG4gICAgc2V0V29ybGRUb1ZpZXdNYXRyaXg6IGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICB0aGlzLnNldE1hdDRJblBhZ2Uoc291cmNlLCBXT1JMRF9UT19WSUVXX01BVFJJWF9PRkZTRVQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRWaWV3VG9Xb3JsZE1hdHJpeDogZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgIHRoaXMuc2V0TWF0NEluUGFnZShzb3VyY2UsIFZJRVdfVE9fV09STERfTUFUUklYX09GRlNFVCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFByb2plY3Rpb25NYXRyaXg6IGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICB0aGlzLnNldE1hdDRJblBhZ2Uoc291cmNlLCBQUk9KRUNUSU9OX01BVFJJWF9PRkZTRVQpO1xyXG4gICAgICAgIHRoaXMucHJvamVjdGlvbkRpcnR5ID0gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRyYW5zZm9ybURpcnR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy52aWV3RGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2NlbmUucmVxdWVzdFJlZHJhdyhcInZpZXcgcG9zZSBjaGFuZ2VkXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRWaWV3VG9Xb3JsZE1hdHJpeDogZnVuY3Rpb24gKGRlc3QpIHtcclxuICAgICAgICBpZiAodGhpcy52aWV3RGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3TWF0cml4KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ2V0TWF0NEZyb21QYWdlKGRlc3QsIFZJRVdfVE9fV09STERfTUFUUklYX09GRlNFVCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFdvcmxkVG9WaWV3TWF0cml4OiBmdW5jdGlvbiAoZGVzdCkge1xyXG4gICAgICAgIGlmICh0aGlzLnZpZXdEaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXdNYXRyaXgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5nZXRNYXQ0RnJvbVBhZ2UoZGVzdCwgV09STERfVE9fVklFV19NQVRSSVhfT0ZGU0VUKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UHJvamVjdGlvbk1hdHJpeDogZnVuY3Rpb24gKGRlc3QsIGFzcGVjdCkge1xyXG4gICAgICAgIGlmICh0aGlzLnByb2plY3Rpb25EaXJ0eSB8fCBNYXRoLmFicyhhc3BlY3QgLSB0aGlzLmxhc3RBc3BlY3RSYXRpbykgPiAwLjAwMSApIHtcclxuICAgICAgICAgICAgLy8gU2V0IHByb2plY3Rpb25NYXRyaXhcclxuICAgICAgICAgICAgdGhpcy5mcnVzdHVtID0gdGhpcy5jYW1lcmEuZ2V0RnJ1c3R1bShhc3BlY3QpO1xyXG4gICAgICAgICAgICBpZih0aGlzLmZydXN0dW0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UHJvamVjdGlvbk1hdHJpeCh0aGlzLmZydXN0dW0uZ2V0UHJvamVjdGlvbk1hdHJpeChtYXQ0LmNyZWF0ZSgpKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFByb2plY3Rpb25NYXRyaXgodGhpcy5jYW1lcmEuZ2V0UHJvamVjdGlvbk1hdHJpeCgpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubGFzdEFzcGVjdFJhdGlvID0gYXNwZWN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdldE1hdDRGcm9tUGFnZShkZXN0LCBQUk9KRUNUSU9OX01BVFJJWF9PRkZTRVQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRXb3JsZFNwYWNlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53b3JsZFNwYWNlUG9zaXRpb247XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFdvcmxkU3BhY2VCb3VuZGluZ0JveDogZnVuY3Rpb24gKGJib3gpIHtcclxuICAgICAgICBiYm94LnNldEVtcHR5KCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHZpZXdGcnVzdHVtQ2hhbmdlZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2NlbmUucmVxdWVzdFJlZHJhdyhcInZpZXcgZnJ1c3R1bSBjaGFuZ2VkXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRDbGlwcGluZ1BsYW5lczogZnVuY3Rpb24oYmIpIHtcclxuICAgICAgICBpZighYmIpIHtcclxuICAgICAgICAgICAgYmIgPSBuZXcgWE1MM0QuQm94KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuZ2V0Qm91bmRpbmdCb3goYmIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmIuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7bmVhcjogMSwgZmFyOiAxMH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB3MnYgPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHRoaXMuZ2V0V29ybGRUb1ZpZXdNYXRyaXgodzJ2KTtcclxuICAgICAgICBiYi50cmFuc2Zvcm1BeGlzQWxpZ25lZCh3MnYpO1xyXG5cclxuICAgICAgICB2YXIgbmVhciA9IC1iYi5tYXgueiwgZmFyID0gLWJiLm1pbi56LCBleHBhbmQgPSBNYXRoLm1heCgoZmFyIC0gbmVhcikgKiAwLjAwNSwgMC4wNSk7XHJcblxyXG4gICAgICAgIC8vIEV4cGFuZCB0aGUgdmlldyBmcnVzdHVtIGEgYml0IHRvIGVuc3VyZSAyRCBvYmplY3RzIHBhcmFsbGVsIHRvIHRoZSBjYW1lcmEgYXJlIHJlbmRlcmVkXHJcbiAgICAgICAgbmVhciA9IE1hdGgubWF4KG5lYXIgLSBleHBhbmQsIGV4cGFuZCwgQ0xJUFBMQU5FX05FQVJfTUlOKTtcclxuICAgICAgICBmYXIgPSBNYXRoLm1heChmYXIgKyBleHBhbmQsIG5lYXIgKyBleHBhbmQpO1xyXG4gICAgICAgIHJldHVybiB7bmVhcjogbmVhciwgZmFyOiBmYXJ9O1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuY2FtZXJhLmRlc3Ryb3koKTtcclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtDb25maWd1cmF0aW9ufSBjb25maWd1cmF0aW9uXHJcbiAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lXHJcbiAqIEBwYXJhbSB7UmVuZGVyVmlld30gb3duZXJcclxuICogQHJldHVybnMge09iamVjdH1cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUNhbWVyYShjb25maWd1cmF0aW9uLCBzY2VuZSwgb3duZXIpIHtcclxuXHJcbiAgICBzd2l0Y2goY29uZmlndXJhdGlvbi5tb2RlbCkge1xyXG4gICAgICAgIGNhc2UgXCJ1cm46eG1sM2Q6dmlldzpwZXJzcGVjdGl2ZVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENhbWVyYU1vZGVscy5QZXJzcGVjdGl2ZUNhbWVyYU1vZGVsKGNvbmZpZ3VyYXRpb24uZGF0YU5vZGUsIHNjZW5lLCBvd25lcik7XHJcbiAgICAgICAgY2FzZSBcInVybjp4bWwzZDp2aWV3OnByb2plY3RpdmVcIjpcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYW1lcmFNb2RlbHMuUHJvamVjdGl2ZUNhbWVyYU1vZGVsKGNvbmZpZ3VyYXRpb24uZGF0YU5vZGUsIHNjZW5lLCBvd25lcik7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIlVua25vd24gY2FtZXJhIG1vZGVsOlwiLCBjb25maWd1cmF0aW9uLm1vZGVsKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYW1lcmFNb2RlbHMuUGVyc3BlY3RpdmVDYW1lcmFNb2RlbChjb25maWd1cmF0aW9uLmRhdGFOb2RlLCBzY2VuZSwgb3duZXIpO1xyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcbi8vIEV4cG9ydFxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlclZpZXc7XHJcblxyXG4iLCJ2YXIgRGF0YU5vZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2dyYXBoLmpzXCIpLkRhdGFOb2RlO1xyXG52YXIgQ29tcHV0ZVJlcXVlc3QgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL3JlcXVlc3QuanNcIikuQ29tcHV0ZVJlcXVlc3Q7XHJcbnZhciBYQyA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xyXG52YXIgQnVmZmVyRW50cnkgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2RhdGEuanNcIikuQnVmZmVyRW50cnk7XHJcbnZhciBJbnB1dE5vZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2dyYXBoLmpzXCIpLklucHV0Tm9kZTtcclxuXHJcbnZhciBTY2VuZVBhcmFtZXRlcnMgPSBbXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcImFzcGVjdFwiLCBcIndvcmxkQm91bmRpbmdCb3hcIl07XHJcblxyXG4vKipcclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgU2NlbmVEYXRhID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmRhdGEgPSBuZXcgRGF0YU5vZGUoZmFsc2UpO1xyXG5cclxuICAgIHZhciB3aWR0aCA9IGNyZWF0ZUlucHV0Tm9kZSh0aGlzLmRhdGEsIFwid2lkdGhcIiwgWEMuREFUQV9UWVBFLkZMT0FULCBuZXcgRmxvYXQzMkFycmF5KFs2MDBdKSk7XHJcbiAgICB2YXIgaGVpZ2h0ID0gY3JlYXRlSW5wdXROb2RlKHRoaXMuZGF0YSwgXCJoZWlnaHRcIiwgWEMuREFUQV9UWVBFLkZMT0FULCBuZXcgRmxvYXQzMkFycmF5KFs4MDBdKSk7XHJcbiAgICB2YXIgd29ybGRCb3VuZGluZ0JveCA9IGNyZWF0ZUlucHV0Tm9kZSh0aGlzLmRhdGEsIFwid29ybGRCb3VuZGluZ0JveFwiLCBYQy5EQVRBX1RZUEUuRkxPQVQsIG5ldyBYTUwzRC5Cb3goKS5kYXRhKTtcclxuXHJcbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBDb21wdXRlUmVxdWVzdCh0aGlzLmRhdGEsIFNjZW5lUGFyYW1ldGVycywgbnVsbCk7XHJcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHQgPSByZXF1ZXN0LmdldFJlc3VsdCgpO1xyXG5cclxuICAgIGRlZmluZUZsb2F0UHJvcGVydHkodGhpcywgXCJ3aWR0aFwiLCByZXN1bHQsIHdpZHRoKTtcclxuICAgIGRlZmluZUZsb2F0UHJvcGVydHkodGhpcywgXCJoZWlnaHRcIiwgcmVzdWx0LCBoZWlnaHQpO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndvcmxkQm91bmRpbmdCb3hcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmdldE91dHB1dERhdGEoXCJ3b3JsZEJvdW5kaW5nQm94XCIpLmdldFZhbHVlKCk7XHJcbiAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgd29ybGRCb3VuZGluZ0JveC5kYXRhLnNldFZhbHVlKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhc3BlY3RcIiwgeyB3cml0ZWFibGU6IGZhbHNlLCBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiByZXN1bHQuZ2V0T3V0cHV0RGF0YShcImFzcGVjdFwiKS5nZXRWYWx1ZSgpWzBdO1xyXG4gICAgfX0pO1xyXG5cclxuICAgIHRoaXMuZGF0YS5zZXRDb21wdXRlKFwiYXNwZWN0ID0geGZsb3cuZGl2KHdpZHRoLCBoZWlnaHQpXCIpO1xyXG5cclxufTtcclxuXHJcbmZ1bmN0aW9uIGRlZmluZUZsb2F0UHJvcGVydHkob2JqLCBuYW1lLCByZXN1bHQsIGZpZWxkKSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZ2V0T3V0cHV0RGF0YShuYW1lKS5nZXRWYWx1ZSgpWzBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgZmllbGQuZGF0YS5zZXRWYWx1ZShuZXcgRmxvYXQzMkFycmF5KFt2YWx1ZV0pKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUlucHV0Tm9kZShkYXRhTm9kZSwgbmFtZSwgdHlwZSwgdmFsdWUpIHtcclxuICAgIHZhciBpbnB1dE5vZGUgPSBuZXcgSW5wdXROb2RlKCk7XHJcbiAgICBpbnB1dE5vZGUuZGF0YSA9IG5ldyBCdWZmZXJFbnRyeSh0eXBlLCB2YWx1ZSk7XHJcbiAgICBpbnB1dE5vZGUubmFtZSA9IG5hbWU7XHJcbiAgICBkYXRhTm9kZS5hcHBlbmRDaGlsZChpbnB1dE5vZGUpO1xyXG4gICAgcmV0dXJuIGlucHV0Tm9kZTtcclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2NlbmVEYXRhO1xyXG4iLCJ2YXIgUGFnZXIgPSByZXF1aXJlKFwiLi9wYWdlci5qc1wiKTtcclxudmFyIFJlbmRlck9iamVjdCA9IHJlcXVpcmUoXCIuL3JlbmRlcm9iamVjdC5qc1wiKTtcclxudmFyIFJlbmRlclZpZXcgPSByZXF1aXJlKFwiLi9yZW5kZXJ2aWV3LmpzXCIpO1xyXG52YXIgUmVuZGVyR3JvdXAgPSByZXF1aXJlKFwiLi9yZW5kZXJncm91cC5qc1wiKTtcclxudmFyIFJlbmRlckxpZ2h0ID0gcmVxdWlyZShcIi4vcmVuZGVybGlnaHQuanNcIik7XHJcbnZhciBNYXRlcmlhbENvbmZpZ3VyYXRpb24gPSByZXF1aXJlKFwiLi9jb25maWd1cmF0aW9uLmpzXCIpO1xyXG52YXIgTGlnaHRNYW5hZ2VyID0gcmVxdWlyZShcIi4uL2xpZ2h0cy9saWdodC1tYW5hZ2VyLmpzXCIpO1xyXG52YXIgQyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIElucHV0Tm9kZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvZ3JhcGguanNcIikuSW5wdXROb2RlO1xyXG52YXIgRGF0YU5vZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2dyYXBoLmpzXCIpLkRhdGFOb2RlO1xyXG52YXIgQnVmZmVyRW50cnkgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2RhdGEuanNcIikuQnVmZmVyRW50cnk7XHJcbnZhciBTY2VuZURhdGEgPSByZXF1aXJlKFwiLi9zY2VuZS1kYXRhLmpzXCIpO1xyXG52YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIFVSSSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy91cmkuanNcIikuVVJJO1xyXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xyXG52YXIgbWF0NCA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikubWF0NDtcclxudmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XHJcbi8qKlxyXG4gKiBAZXh0ZW5kcyB7RXZlbnRFbWl0dGVyfVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBTY2VuZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xyXG4gICAgdGhpcy5ib3VuZGluZ0JveCA9IG5ldyBYTUwzRC5Cb3goKTtcclxuICAgIHRoaXMubGlnaHRzID0gbmV3IExpZ2h0TWFuYWdlcigpO1xyXG4gICAgdGhpcy5wYWdlciA9IG5ldyBQYWdlcigpO1xyXG5cclxuICAgIC8qKiBAdHlwZSBSZW5kZXJWaWV3ICovXHJcbiAgICB0aGlzLmFjdGl2ZVZpZXcgPSBudWxsO1xyXG5cclxuICAgIC8qKiBAdHlwZSBNYXRlcmlhbENvbmZpZ3VyYXRpb24gKi9cclxuICAgIHRoaXMuX2RlZmF1bHRNYXRlcmlhbCA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5yb290Tm9kZSA9IHRoaXMuY3JlYXRlUm9vdE5vZGUoKTtcclxuXHJcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSA9IG5ldyBTY2VuZURhdGEoKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3aWR0aFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIGRhdGEud2lkdGg7IH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbih3aWR0aCkgeyBkYXRhLndpZHRoID0gd2lkdGg7IH1cclxuICAgIH0pO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhlaWdodFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIGRhdGEuaGVpZ2h0OyB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24oaGVpZ2h0KSB7IGRhdGEuaGVpZ2h0ID0gaGVpZ2h0OyB9XHJcbiAgICB9KTtcclxuXHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhTY2VuZSwgRXZlbnRFbWl0dGVyLCB7XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIHtSZW5kZXJWaWV3fVxyXG4gICAgICovXHJcbiAgICBnZXRBY3RpdmVWaWV3OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlVmlldztcclxuICAgIH0sIC8qKlxyXG4gICAgICogQHBhcmFtIHtSZW5kZXJWaWV3fSB2aWV3XHJcbiAgICAgKi9cclxuICAgIHNldEFjdGl2ZVZpZXc6IGZ1bmN0aW9uICh2aWV3KSB7XHJcbiAgICAgICAgaWYgKHZpZXcgIT0gdGhpcy5hY3RpdmVWaWV3KSB7XHJcbiAgICAgICAgICAgIGFzc2VydCh2aWV3LCBcIkFjdGl2ZSB2aWV3IG11c3Qgbm90IGJlIG51bGxcIik7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlVmlldyA9IHZpZXc7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdChDLkVWRU5UX1RZUEUuVklFV19DSEFOR0VELCB0aGlzLmFjdGl2ZVZpZXcpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0P30gb3B0XHJcbiAgICAgKiBAcmV0dXJucyB7UmVuZGVyT2JqZWN0fVxyXG4gICAgICovXHJcbiAgICBjcmVhdGVSZW5kZXJPYmplY3Q6IGZ1bmN0aW9uIChvcHQpIHtcclxuICAgICAgICB2YXIgcGFnZUVudHJ5ID0gdGhpcy5wYWdlci5nZXRQYWdlRW50cnkoUmVuZGVyT2JqZWN0LkVOVFJZX1NJWkUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVuZGVyT2JqZWN0KHRoaXMsIHBhZ2VFbnRyeSwgb3B0KTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlUmVuZGVyR3JvdXA6IGZ1bmN0aW9uIChvcHQpIHtcclxuICAgICAgICB2YXIgcGFnZUVudHJ5ID0gdGhpcy5wYWdlci5nZXRQYWdlRW50cnkoUmVuZGVyR3JvdXAuRU5UUllfU0laRSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZW5kZXJHcm91cCh0aGlzLCBwYWdlRW50cnksIG9wdCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVJlbmRlclZpZXc6IGZ1bmN0aW9uIChvcHQpIHtcclxuICAgICAgICB2YXIgcGFnZUVudHJ5ID0gdGhpcy5wYWdlci5nZXRQYWdlRW50cnkoUmVuZGVyVmlldy5FTlRSWV9TSVpFKTtcclxuICAgICAgICByZXR1cm4gbmV3IFJlbmRlclZpZXcodGhpcywgcGFnZUVudHJ5LCBvcHQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVSZW5kZXJMaWdodDogZnVuY3Rpb24gKG9wdCkge1xyXG4gICAgICAgIHZhciBwYWdlRW50cnkgPSB0aGlzLnBhZ2VyLmdldFBhZ2VFbnRyeShSZW5kZXJMaWdodC5FTlRSWV9TSVpFKTtcclxuICAgICAgICByZXR1cm4gbmV3IFJlbmRlckxpZ2h0KHRoaXMsIHBhZ2VFbnRyeSwgb3B0KTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlTWF0ZXJpYWxDb25maWd1cmF0aW9uOiBmdW5jdGlvbihtb2RlbCwgZGF0YSwgb3B0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNYXRlcmlhbENvbmZpZ3VyYXRpb24obW9kZWwsIGRhdGEsIG9wdCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVJvb3ROb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhZ2VFbnRyeSA9IHRoaXMucGFnZXIuZ2V0UGFnZUVudHJ5KFJlbmRlckdyb3VwLkVOVFJZX1NJWkUpO1xyXG4gICAgICAgIHZhciByb290ID0gbmV3IFJlbmRlckdyb3VwKHRoaXMsIHBhZ2VFbnRyeSwge1xyXG4gICAgICAgICAgICBtYXRlcmlhbDogdGhpcy5nZXREZWZhdWx0TWF0ZXJpYWwoKSwgbmFtZTogXCJAc2NlbmVcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJvb3Quc2V0V29ybGRNYXRyaXgobWF0NC5jcmVhdGUoKSk7XHJcbiAgICAgICAgcm9vdC5zZXRMb2NhbE1hdHJpeChtYXQ0LmNyZWF0ZSgpKTtcclxuICAgICAgICByb290LnRyYW5zZm9ybURpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHJvb3Q7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucm9vdE5vZGUuYm91bmRpbmdCb3hEaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLnJvb3ROb2RlLmdldFdvcmxkU3BhY2VCb3VuZGluZ0JveCh0aGlzLmJvdW5kaW5nQm94KTtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLndvcmxkQm91bmRpbmdCb3ggPSB0aGlzLmJvdW5kaW5nQm94LmRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRCb3VuZGluZ0JveDogZnVuY3Rpb24gKGJiKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCgpO1xyXG4gICAgICAgIGJiLmNvcHkodGhpcy5ib3VuZGluZ0JveCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZURyYXdhYmxlOiBmdW5jdGlvbiAoLypvYmoqLykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNjZW5lOjpjcmVhdGVEcmF3YWJsZSBub3QgaW1wbGVtZW50ZWRcIik7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlcXVlc3RSZWRyYXc6IGZ1bmN0aW9uICgvKnJlYXNvbiovKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2NlbmU6OnJlcXVlc3RSZWRyYXcgbm90IGltcGxlbWVudGVkXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5yb290Tm9kZS50cmF2ZXJzZShjYWxsYmFjayk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgb2JqZWN0cyBpbnRlcnNlY3RlZCBieSB0aGUgZ2l2ZW4gcmF5LCBiYXNlZCBvbiB0aGVpciBib3VuZGluZyBib3hlc1xyXG4gICAgICogQHBhcmFtIHJheVxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBvZiBSZW5kZXJPYmplY3RzIHRoYXQgd2VyZSBoaXQgYnkgdGhpcyByYXlcclxuICAgICAqL1xyXG4gICAgZmluZFJheUludGVyc2VjdGlvbnM6IGZ1bmN0aW9uIChyYXkpIHtcclxuICAgICAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IFtdO1xyXG4gICAgICAgIHRoaXMucm9vdE5vZGUuZmluZFJheUludGVyc2VjdGlvbnMocmF5LCBpbnRlcnNlY3Rpb25zKTtcclxuICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0RGVmYXVsdE1hdGVyaWFsOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZighdGhpcy5fZGVmYXVsdE1hdGVyaWFsKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnB1dE5vZGUgPSBuZXcgSW5wdXROb2RlKCk7XHJcbiAgICAgICAgICAgIGlucHV0Tm9kZS5kYXRhID0gbmV3IEJ1ZmZlckVudHJ5KFhDLkRBVEFfVFlQRS5GTE9BVDMsIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDBdKSk7XHJcbiAgICAgICAgICAgIGlucHV0Tm9kZS5uYW1lID0gXCJkaWZmdXNlQ29sb3JcIjtcclxuXHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gbmV3IERhdGFOb2RlKGZhbHNlKTtcclxuICAgICAgICAgICAgZGF0YS5hcHBlbmRDaGlsZChpbnB1dE5vZGUpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdE1hdGVyaWFsID0gdGhpcy5jcmVhdGVNYXRlcmlhbENvbmZpZ3VyYXRpb24oXHJcbiAgICAgICAgICAgICAgICB7XCJ0eXBlXCI6IFwidXJuXCIsIFwidXJuXCI6IG5ldyBVUkkoXCJ1cm46eG1sM2Q6bWF0ZXJpYWw6bWF0dGVcIil9LFxyXG4gICAgICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgICAgIHtuYW1lOiBcImRlZmF1bHRcIn1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRNYXRlcmlhbDtcclxuICAgIH0sXHJcblxyXG4gICAgaGFuZGxlUmVzaXplRXZlbnQ6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2NlbmU7XHJcbiIsInZhciBEYXRhQ2hhbmdlTm90aWZpZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2RhdGEuanNcIikuRGF0YUNoYW5nZU5vdGlmaWVyO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIERhdGFDaGFuZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIERhdGFDaGFuZ2VOb3RpZmllci5hZGRMaXN0ZW5lcih0aGlzLmRhdGFFbnRyeUNoYW5nZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7WGZsb3cuRGF0YUVudHJ5fSBlbnRyeVxyXG4gKiBAcGFyYW0ge1hmbG93LkRBVEFfRU5UUllfU1RBVEV9IG5vdGlmaWNhdGlvblxyXG4gKi9cclxuRGF0YUNoYW5nZUxpc3RlbmVyLnByb3RvdHlwZS5kYXRhRW50cnlDaGFuZ2VkID0gZnVuY3Rpb24gKGVudHJ5LCBub3RpZmljYXRpb24pIHtcclxuICAgIGlmIChlbnRyeS51c2VyRGF0YS53ZWJnbERhdGEpIHtcclxuICAgICAgICBmb3IgKHZhciBpIGluIGVudHJ5LnVzZXJEYXRhLndlYmdsRGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgb2xkQ2hhbmdlZCA9IGVudHJ5LnVzZXJEYXRhLndlYmdsRGF0YVtpXS5jaGFuZ2VkO1xyXG4gICAgICAgICAgICBlbnRyeS51c2VyRGF0YS53ZWJnbERhdGFbaV0uY2hhbmdlZCA9IE1hdGgubWF4KG9sZENoYW5nZWQsIG5vdGlmaWNhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEYXRhQ2hhbmdlTGlzdGVuZXI7XHJcbiIsInZhciB2ZWMzID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS52ZWMzO1xyXG52YXIgdG1wMSA9IHZlYzMuY3JlYXRlKCk7XHJcbnZhciB0bXAyID0gdmVjMy5jcmVhdGUoKTtcclxudmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXJQbGFuZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyUGxhbmVcclxuICogQHBhcmFtIHtudW1iZXJ9IGZvdnhcclxuICogQHBhcmFtIHtudW1iZXJ9IGZvdnlcclxuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9ydGhvZ3JhcGhpY1xyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBGcnVzdHVtID0gZnVuY3Rpb24gKG5lYXJQbGFuZSwgZmFyUGxhbmUsIGZvdngsIGZvdnksIGFzcGVjdCwgb3J0aG9ncmFwaGljKSB7XHJcbiAgICB0aGlzLnNldEZydXN0dW0obmVhclBsYW5lLCBmYXJQbGFuZSwgZm92eCwgZm92eSwgYXNwZWN0LCBvcnRob2dyYXBoaWMpO1xyXG59O1xyXG5cclxuWE1MM0QuZXh0ZW5kKEZydXN0dW0ucHJvdG90eXBlLCB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmVhclBsYW5lXHJcbiAgICAgKiBAcGFyYW0gZmFyUGxhbmVcclxuICAgICAqIEBwYXJhbSBmb3Z4IEhvcml6b250YWwgZmllbGQgb2YgdmlldyBpbiByYWRpYW5zXHJcbiAgICAgKiBAcGFyYW0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcclxuICAgICAqIEBwYXJhbSBhc3BlY3RcclxuICAgICAqIEBwYXJhbSB7Ym9vbD99IG9ydGhvZ3JhcGhpY1xyXG4gICAgICovXHJcbiAgICBzZXRGcnVzdHVtOiBmdW5jdGlvbiAobmVhclBsYW5lLCBmYXJQbGFuZSwgZm92eCwgZm92eSwgYXNwZWN0ICwgb3J0aG9ncmFwaGljKSB7XHJcbiAgICAgICAgYXNzZXJ0KG5lYXJQbGFuZSA+IDAgJiYgZmFyUGxhbmUgPiAwLCBcIk5lYXIgb3IgZmFyIHBsYW5lIHVuZGVmaW5lZCBvciBub24tcG9zaXRpdmVcIik7XHJcbiAgICAgICAgYXNzZXJ0KCEoZm92eCAmJiBmb3Z5KSwgXCJmb3Z4IGFuZCBmb3Z5IGNhbm5vdCBib3RoIGJlIG5vbi16ZXJvLlwiKTtcclxuICAgICAgICBhc3NlcnQoYXNwZWN0ID4gMCwgXCJhc3BlY3QgY2Fubm90IGJvdGggYmUgbm9uLXplcm8uXCIpO1xyXG5cclxuICAgICAgICBpZiAoZm92eCkge1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gbmVhclBsYW5lICogTWF0aC50YW4oZm92eCAvIDIpO1xyXG4gICAgICAgICAgICB0aGlzLmxlZnQgPSAtdGhpcy5yaWdodDtcclxuICAgICAgICAgICAgdGhpcy50b3AgPSAoKHRoaXMucmlnaHQgLSB0aGlzLmxlZnQpIC8gYXNwZWN0KSAvIDI7XHJcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID0gLXRoaXMudG9wO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudG9wID0gbmVhclBsYW5lICogTWF0aC50YW4oMC41ICogZm92eSk7XHJcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID0gLXRoaXMudG9wO1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gKHRoaXMudG9wIC0gdGhpcy5ib3R0b20pICogYXNwZWN0IC8gMjtcclxuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gLXRoaXMucmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubmVhclBsYW5lID0gbmVhclBsYW5lO1xyXG4gICAgICAgIHRoaXMuZmFyUGxhbmUgPSBmYXJQbGFuZTtcclxuXHJcbiAgICAgICAgdGhpcy5vcnRob2dyYXBoaWMgPSBvcnRob2dyYXBoaWMgPT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcnRob2dyYXBoaWM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFByb2plY3Rpb25NYXRyaXg6IGZ1bmN0aW9uIChtYXRyaXgpIHtcclxuICAgICAgICB2YXIgbGltaXRNYXggPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIHZhciByaWdodFBsdXNMZWZ0ID0gdGhpcy5yaWdodCArIHRoaXMubGVmdDtcclxuICAgICAgICB2YXIgcmlnaHRNaW51c0xlZnQgPSB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0O1xyXG5cclxuICAgICAgICB2YXIgdG9wUGx1c0JvdHRvbSA9IHRoaXMudG9wICsgdGhpcy5ib3R0b207XHJcbiAgICAgICAgdmFyIHRvcE1pbnVzQm90dG9tID0gdGhpcy50b3AgLSB0aGlzLmJvdHRvbTtcclxuXHJcbiAgICAgICAgdmFyIGZhclBsdXNOZWFyID0gdGhpcy5mYXJQbGFuZSArIHRoaXMubmVhclBsYW5lO1xyXG4gICAgICAgIHZhciBmYXJNaW51c05lYXIgPSB0aGlzLmZhclBsYW5lIC0gdGhpcy5uZWFyUGxhbmU7XHJcblxyXG4gICAgICAgIGlmICgoTWF0aC5hYnMocmlnaHRNaW51c0xlZnQpIDwgMSAmJiBNYXRoLmFicyhyaWdodFBsdXNMZWZ0KSA+IGxpbWl0TWF4ICogTWF0aC5hYnMocmlnaHRNaW51c0xlZnQpKSB8fCAoTWF0aC5hYnModG9wTWludXNCb3R0b20pIDwgMSAmJiBNYXRoLmFicyh0b3BQbHVzQm90dG9tKSA+IGxpbWl0TWF4ICogTWF0aC5hYnModG9wTWludXNCb3R0b20pKSB8fCAoTWF0aC5hYnMoZmFyTWludXNOZWFyKSA8IDEgJiYgTWF0aC5hYnMoZmFyUGx1c05lYXIpID4gbGltaXRNYXggKiBNYXRoLmFicyhmYXJNaW51c05lYXIpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgdmlld2luZyBmcnVzdHVtOiBwcm9qZWN0aW9uIG1hdHJpeCBjYW5ub3QgYmUgY29tcHV0ZWQuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIEEsIEIsIEMsIEQsIEUsIEY7XHJcbiAgICAgICAgdmFyIG0gPSBtYXRyaXguZGF0YSA/IG1hdHJpeC5kYXRhIDogbWF0cml4O1xyXG5cclxuICAgICAgICBpZiAodGhpcy5vcnRob2dyYXBoaWMpIHtcclxuICAgICAgICAgICAgdmFyIHR4ID0gLXJpZ2h0UGx1c0xlZnQgLyByaWdodE1pbnVzTGVmdDtcclxuICAgICAgICAgICAgdmFyIHR5ID0gLXRvcFBsdXNCb3R0b20gLyB0b3BNaW51c0JvdHRvbTtcclxuICAgICAgICAgICAgdmFyIHR6ID0gLWZhclBsdXNOZWFyIC8gZmFyTWludXNOZWFyO1xyXG5cclxuICAgICAgICAgICAgaWYgKChNYXRoLmFicyhyaWdodE1pbnVzTGVmdCkgPCAxICYmIDIgPiBsaW1pdE1heCAqIE1hdGguYWJzKHJpZ2h0TWludXNMZWZ0KSkgfHwgKE1hdGguYWJzKHRvcE1pbnVzQm90dG9tKSA8IDEgJiYgMiA+IGxpbWl0TWF4ICogTWF0aC5hYnModG9wTWludXNCb3R0b20pKSB8fCAoTWF0aC5hYnMoZmFyTWludXNOZWFyKSA8IDEgJiYgMiA+IGxpbWl0TWF4ICogTWF0aC5hYnMoZmFyTWludXNOZWFyKSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhZCB2aWV3aW5nIGZydXN0dW06ICBwcm9qZWN0aW9uIG1hdHJpeCBjYW5ub3QgYmUgY29tcHV0ZWQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBBID0gMiAvIHJpZ2h0TWludXNMZWZ0O1xyXG4gICAgICAgICAgICBCID0gMiAvIHRvcE1pbnVzQm90dG9tO1xyXG4gICAgICAgICAgICBDID0gLTIgLyBmYXJNaW51c05lYXI7XHJcblxyXG4gICAgICAgICAgICBYTUwzRC5tYXRoLm1hdDQuaWRlbnRpdHkobSk7XHJcbiAgICAgICAgICAgIG1bMF0gPSBBO1xyXG4gICAgICAgICAgICBtWzVdID0gQjtcclxuICAgICAgICAgICAgbVsxMF0gPSBDO1xyXG4gICAgICAgICAgICBtWzEyXSA9IHR4O1xyXG4gICAgICAgICAgICBtWzEzXSA9IHR5O1xyXG4gICAgICAgICAgICBtWzE0XSA9IHR6O1xyXG4gICAgICAgICAgICBtWzE1XSA9IDEuMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBBID0gcmlnaHRQbHVzTGVmdCAvIHJpZ2h0TWludXNMZWZ0O1xyXG4gICAgICAgICAgICBCID0gdG9wUGx1c0JvdHRvbSAvIHRvcE1pbnVzQm90dG9tO1xyXG4gICAgICAgICAgICBDID0gLWZhclBsdXNOZWFyIC8gZmFyTWludXNOZWFyO1xyXG5cclxuICAgICAgICAgICAgdmFyIGZhclRpbWVzTmVhciA9IC0yICogdGhpcy5mYXJQbGFuZSAqIHRoaXMubmVhclBsYW5lO1xyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZmFyTWludXNOZWFyKSA8IDEgJiYgTWF0aC5hYnMoZmFyVGltZXNOZWFyKSA+IGxpbWl0TWF4ICogTWF0aC5hYnMoZmFyTWludXNOZWFyKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFkIHZpZXdpbmcgZnJ1c3R1bTogcHJvamVjdGlvbiBtYXRyaXggY2Fubm90IGJlIGNvbXB1dGVkLlwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRCA9IGZhclRpbWVzTmVhciAvIGZhck1pbnVzTmVhcjtcclxuXHJcbiAgICAgICAgICAgIHZhciB0d29UaW1lc05lYXIgPSAyICogdGhpcy5uZWFyUGxhbmU7XHJcblxyXG4gICAgICAgICAgICBpZiAoKE1hdGguYWJzKHJpZ2h0TWludXNMZWZ0KSA8IDEgJiYgTWF0aC5hYnModHdvVGltZXNOZWFyKSA+IGxpbWl0TWF4ICogTWF0aC5hYnMocmlnaHRNaW51c0xlZnQpKSB8fCAoTWF0aC5hYnModG9wTWludXNCb3R0b20pIDwgMSAmJiBNYXRoLmFicyh0d29UaW1lc05lYXIpID4gbGltaXRNYXggKiBNYXRoLmFicyh0b3BNaW51c0JvdHRvbSkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgdmlld2luZyBmcnVzdHVtOiBwcm9qZWN0aW9uIG1hdHJpeCBjYW5ub3QgYmUgY29tcHV0ZWQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBFID0gdHdvVGltZXNOZWFyIC8gcmlnaHRNaW51c0xlZnQ7XHJcbiAgICAgICAgICAgIEYgPSB0d29UaW1lc05lYXIgLyB0b3BNaW51c0JvdHRvbTtcclxuXHJcbiAgICAgICAgICAgIFhNTDNELm1hdGgubWF0NC5pZGVudGl0eShtKTtcclxuICAgICAgICAgICAgbVswXSA9IEU7XHJcbiAgICAgICAgICAgIG1bNV0gPSBGO1xyXG4gICAgICAgICAgICBtWzhdID0gQTtcclxuICAgICAgICAgICAgbVs5XSA9IEI7XHJcbiAgICAgICAgICAgIG1bMTBdID0gQztcclxuICAgICAgICAgICAgbVsxMV0gPSAtMTtcclxuICAgICAgICAgICAgbVsxNF0gPSBEO1xyXG4gICAgICAgICAgICBtWzE1XSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFBsYW5lczogKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIGNfYSA9IHZlYzMuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIGNfYiA9IHZlYzMuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIGNfYyA9IHZlYzMuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIGNfZCA9IHZlYzMuY3JlYXRlKCk7XHJcblxyXG4gICAgICAgIHZhciBjX2UgPSB2ZWMzLmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBjX2YgPSB2ZWMzLmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBjX2cgPSB2ZWMzLmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBjX28gPSB2ZWMzLmNyZWF0ZSgpO1xyXG5cclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwbGFuZXMsIE0pIHtcclxuICAgICAgICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KGNfYSwgW3RoaXMubGVmdCwgdGhpcy5ib3R0b20sIC10aGlzLm5lYXJQbGFuZV0sIE0pO1xyXG4gICAgICAgICAgICB2ZWMzLnRyYW5zZm9ybU1hdDQoY19iLCBbdGhpcy5sZWZ0LCB0aGlzLnRvcCwgLXRoaXMubmVhclBsYW5lXSwgTSk7XHJcbiAgICAgICAgICAgIHZlYzMudHJhbnNmb3JtTWF0NChjX2MsIFt0aGlzLnJpZ2h0LCB0aGlzLnRvcCwgLXRoaXMubmVhclBsYW5lXSwgTSk7XHJcbiAgICAgICAgICAgIHZlYzMudHJhbnNmb3JtTWF0NChjX2QsIFt0aGlzLnJpZ2h0LCB0aGlzLmJvdHRvbSwgLXRoaXMubmVhclBsYW5lXSwgTSk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5vcnRob2dyYXBoaWMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzID0gdGhpcy5mYXJQbGFuZSAvIHRoaXMubmVhclBsYW5lO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZhckxlZnQgPSBzICogdGhpcy5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGZhclJpZ2h0ID0gcyAqIHRoaXMucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmFyVG9wID0gcyAqIHRoaXMudG9wO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZhckJvdHRvbSA9IHMgKiB0aGlzLmJvdHRvbTtcclxuICAgICAgICAgICAgICAgIHZlYzMudHJhbnNmb3JtTWF0NChjX2UsIFtmYXJMZWZ0LCBmYXJCb3R0b20sIC10aGlzLmZhclBsYW5lXSwgTSk7XHJcbiAgICAgICAgICAgICAgICB2ZWMzLnRyYW5zZm9ybU1hdDQoY19mLCBbZmFyTGVmdCwgZmFyVG9wLCAtdGhpcy5mYXJQbGFuZV0sIE0pO1xyXG4gICAgICAgICAgICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KGNfZywgW2ZhclJpZ2h0LCBmYXJUb3AsIC10aGlzLmZhclBsYW5lXSwgTSk7XHJcbiAgICAgICAgICAgICAgICB2ZWMzLnRyYW5zZm9ybU1hdDQoY19vLCBbMCwgMCwgMF0sIE0pO1xyXG4gICAgICAgICAgICAgICAgcGxhbmVzWzBdLnNldEZyb21Qb2ludHMoY19vLCBjX2MsIGNfYik7XHJcbiAgICAgICAgICAgICAgICBwbGFuZXNbMV0uc2V0RnJvbVBvaW50cyhjX28sIGNfZCwgY19jKTtcclxuICAgICAgICAgICAgICAgIHBsYW5lc1syXS5zZXRGcm9tUG9pbnRzKGNfbywgY19hLCBjX2QpO1xyXG4gICAgICAgICAgICAgICAgcGxhbmVzWzNdLnNldEZyb21Qb2ludHMoY19vLCBjX2IsIGNfYSk7XHJcbiAgICAgICAgICAgICAgICBwbGFuZXNbNF0uc2V0RnJvbVBvaW50cyhjX2EsIGNfZCwgY19jKTtcclxuICAgICAgICAgICAgICAgIHBsYW5lc1s1XS5zZXRGcm9tUG9pbnRzKGNfZSwgY19mLCBjX2cpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KGNfZSwgW3RoaXMubGVmdCwgdGhpcy5ib3R0b20sIC10aGlzLmZhclBsYW5lXSwgTSk7XHJcbiAgICAgICAgICAgICAgICB2ZWMzLnRyYW5zZm9ybU1hdDQoY19mLCBbdGhpcy5sZWZ0LCB0aGlzLnRvcCwgLXRoaXMuZmFyUGxhbmVdLCBNKTtcclxuICAgICAgICAgICAgICAgIHZlYzMudHJhbnNmb3JtTWF0NChjX2csIFt0aGlzLnJpZ2h0LCB0aGlzLnRvcCwgLXRoaXMuZmFyUGxhbmVdLCBNKTtcclxuICAgICAgICAgICAgICAgIHZlYzMudHJhbnNmb3JtTWF0NChjX28sIFt0aGlzLnJpZ2h0LCB0aGlzLmJvdHRvbSwgLXRoaXMuZmFyUGxhbmVdLCBNKTtcclxuICAgICAgICAgICAgICAgIHBsYW5lc1swXS5zZXRGcm9tUG9pbnRzKGNfYywgY19nLCBjX2YpO1xyXG4gICAgICAgICAgICAgICAgcGxhbmVzWzFdLnNldEZyb21Qb2ludHMoY19kLCBjX28sIGNfZyk7XHJcbiAgICAgICAgICAgICAgICBwbGFuZXNbMl0uc2V0RnJvbVBvaW50cyhjX2EsIGNfZSwgY19vKTtcclxuICAgICAgICAgICAgICAgIHBsYW5lc1szXS5zZXRGcm9tUG9pbnRzKGNfYiwgY19mLCBjX2UpO1xyXG4gICAgICAgICAgICAgICAgcGxhbmVzWzRdLnNldEZyb21Qb2ludHMoY19hLCBjX2QsIGNfYyk7XHJcbiAgICAgICAgICAgICAgICBwbGFuZXNbNV0uc2V0RnJvbVBvaW50cyhjX2UsIGNfZiwgY19nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9KCkpXHJcblxyXG5cclxufSk7XHJcblxyXG5cclxudmFyIFBsYW5lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5kaXN0YW5jZSA9IDA7XHJcbiAgICB0aGlzLm5vcm1hbCA9IHZlYzMuY3JlYXRlKCk7XHJcbn07XHJcblxyXG5YTUwzRC5leHRlbmQoUGxhbmUucHJvdG90eXBlLCB7XHJcbiAgICBzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAocG9pbnQxLCBwb2ludDIsIHBvaW50Mykge1xyXG4gICAgICAgIHZlYzMuY3Jvc3ModGhpcy5ub3JtYWwsIHZlYzMuc3ViKHRtcDIsIHBvaW50MywgcG9pbnQxKSwgdmVjMy5zdWIodG1wMSwgcG9pbnQyLCBwb2ludDEpKTtcclxuICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh0aGlzLm5vcm1hbCwgdGhpcy5ub3JtYWwpO1xyXG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSAtdmVjMy5kb3QodGhpcy5ub3JtYWwsIHBvaW50MSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldDogZnVuY3Rpb24gKHgsIHksIHosIGRpc3RhbmNlKSB7XHJcbiAgICAgICAgdmVjMy5zZXQodGhpcy5ub3JtYWwsIHgsIHksIHopO1xyXG4gICAgICAgIHZlYzMubm9ybWFsaXplKHRoaXMubm9ybWFsLCB0aGlzLm5vcm1hbCk7XHJcbiAgICAgICAgdGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbnZhciBGcnVzdHVtVGVzdCA9IGZ1bmN0aW9uIChmcnVzdHVtLCBjYW1lcmFNYXRyaXgpIHtcclxuICAgIHRoaXMuZnJ1c3R1bVBsYW5lcyA9IFtuZXcgUGxhbmUoKSwgbmV3IFBsYW5lKCksIG5ldyBQbGFuZSgpLCBuZXcgUGxhbmUoKSwgbmV3IFBsYW5lKCksIG5ldyBQbGFuZSgpXTtcclxuICAgIGlmIChmcnVzdHVtICYmIGNhbWVyYU1hdHJpeCkge1xyXG4gICAgICAgIHRoaXMuc2V0KGZydXN0dW0sIGNhbWVyYU1hdHJpeCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuWE1MM0QuZXh0ZW5kKEZydXN0dW1UZXN0LnByb3RvdHlwZSwge1xyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtGcnVzdHVtfSBmcnVzdHVtXHJcbiAgICAgKiBAcGFyYW0ge21hdDR9IG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBzZXQ6IGZ1bmN0aW9uIChmcnVzdHVtLCBtYXRyaXgpIHtcclxuICAgICAgICBmcnVzdHVtLmdldFBsYW5lcyh0aGlzLmZydXN0dW1QbGFuZXMsIG1hdHJpeCk7XHJcblxyXG4gICAgfSwgLyoqXHJcbiAgICAgKiBAcGFyYW0gYmJveFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGlzQm94VmlzaWJsZTogIGZ1bmN0aW9uIChiYm94KSB7XHJcbiAgICAgICAgICAgIGlmIChiYm94LmlzRW1wdHkoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mcnVzdHVtUGxhbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGxhbmUgPSB0aGlzLmZydXN0dW1QbGFuZXNbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsID0gcGxhbmUubm9ybWFsO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJieCA9IG5vcm1hbFswXSA+PSAwLjAgPyBiYm94LmRhdGFbM10gOiBiYm94LmRhdGFbMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgYmJ5ID0gbm9ybWFsWzFdID49IDAuMCA/IGJib3guZGF0YVs0XSA6IGJib3guZGF0YVsxXTtcclxuICAgICAgICAgICAgICAgIHZhciBiYnogPSBub3JtYWxbMl0gPj0gMC4wID8gYmJveC5kYXRhWzVdIDogYmJveC5kYXRhWzJdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGRpc3RhbmNlXHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBiYnggKiBub3JtYWxbMF0gKyBiYnkgKiBub3JtYWxbMV0gKyBiYnogKiBub3JtYWxbMl0gKyBwbGFuZS5kaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGFzc2VydCghaXNOYU4oZGlzdGFuY2UpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBoaWdoZXN0IHBvaW50IGlzIGJlbG93IHBsYW5lIHRoZW4gYWxsIGJlbG93LlxyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgMC4wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIFBsYW5lOiBQbGFuZSxcclxuICAgIEZydXN0dW06IEZydXN0dW0sXHJcbiAgICBGcnVzdHVtVGVzdDogRnJ1c3R1bVRlc3RcclxufTtcclxuIiwidmFyIHZlYzMgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLnZlYzM7XHJcblxyXG4vKipcclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgT2JqZWN0U29ydGVyID0gZnVuY3Rpb24gKCkge1xyXG5cclxufTtcclxuXHJcbnZhciBjX2Jib3ggPSBuZXcgWE1MM0QuQm94KCk7XHJcbnZhciBjX2NlbnRlciA9IHZlYzMuY3JlYXRlKCk7XHJcblxyXG5YTUwzRC5leHRlbmQoT2JqZWN0U29ydGVyLnByb3RvdHlwZSwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VPYmplY3RBcnJheVxyXG4gICAgICogQHBhcmFtIHtYTUwzRC5NYXQ0P30gdmlld01hdHJpeCBNYXRyaXggdG8gYXBwbHkgdG8gb2JqZWN0cyB3b3JsZCBzcGFjZSBleHRlbmQgYmVmb3JlIHNvcnRpbmdcclxuICAgICAqL1xyXG4gICAgc29ydE9iamVjdHM6IGZ1bmN0aW9uIChzb3VyY2VPYmplY3RBcnJheSwgdmlld01hdHJpeCkge1xyXG4gICAgICAgIHZhciBwcmVzb3J0T3BhcXVlID0ge30sIHByZXNvcnRUcmFuc3BhcmVudCA9IHt9LCBvYmosIHpMYXllciwgaSwgbCwgbjtcclxuXHJcbiAgICAgICAgLy8gU29ydCBieSB0cmFuc3BhcmVuY3kgYW5kIHotaW5kZXhcclxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gc291cmNlT2JqZWN0QXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG9iaiA9IHNvdXJjZU9iamVjdEFycmF5W2ldO1xyXG4gICAgICAgICAgICBpZiAob2JqLmluRnJ1c3R1bSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvYmouaGFzVHJhbnNwYXJlbmN5KCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcHJlc29ydFRyYW5zcGFyZW50W29iai5fekluZGV4XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXNvcnRUcmFuc3BhcmVudFtvYmouX3pJbmRleF0gPSBbb2JqXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlc29ydFRyYW5zcGFyZW50W29iai5fekluZGV4XS5wdXNoKG9iaik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByZXNvcnRPcGFxdWVbb2JqLl96SW5kZXhdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlc29ydE9wYXF1ZVtvYmouX3pJbmRleF0gPSBbb2JqXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlc29ydE9wYXF1ZVtvYmouX3pJbmRleF0ucHVzaChvYmopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTZXBhcmF0ZSB0aGUgc2NlbmUgaW50byB6LWxheWVycyBhY2NvcmRpbmcgdG8gei1pbmRleFxyXG4gICAgICAgIHZhciB6TGF5ZXJzID0gT2JqZWN0LmtleXMocHJlc29ydE9wYXF1ZSkuY29uY2F0KE9iamVjdC5rZXlzKHByZXNvcnRUcmFuc3BhcmVudCkpO1xyXG4gICAgICAgIHpMYXllcnMgPSB6TGF5ZXJzLnNvcnQoZnVuY3Rpb24oYSxiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLmxvY2FsZUNvbXBhcmUoYik7XHJcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0sIHBvcywgYXJ5KSB7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBkdXBsaWNhdGVzXHJcbiAgICAgICAgICAgIHJldHVybiAhcG9zIHx8IGl0ZW0gIT0gYXJ5W3BvcyAtIDFdO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBTb3J0IG9wYXF1ZSB6LWJ1Y2tldHMgYnkgc2hhZGVyXHJcbiAgICAgICAgdmFyIG9wYXF1ZSA9IHt9O1xyXG4gICAgICAgIGZvciAoaT0wOyBpPHpMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgekxheWVyID0gekxheWVyc1tpXTtcclxuICAgICAgICAgICAgb3BhcXVlW3pMYXllcl0gPSB7fTtcclxuICAgICAgICAgICAgZm9yIChuIGluIHByZXNvcnRPcGFxdWVbekxheWVyXSkge1xyXG4gICAgICAgICAgICAgICAgb2JqID0gcHJlc29ydE9wYXF1ZVt6TGF5ZXJdW25dO1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb2dyYW0gPSBvYmouZ2V0UHJvZ3JhbSgpO1xyXG4gICAgICAgICAgICAgICAgb3BhcXVlW3pMYXllcl1bcHJvZ3JhbS5pZF0gPSBvcGFxdWVbekxheWVyXVtwcm9ncmFtLmlkXSB8fCBbXTtcclxuICAgICAgICAgICAgICAgIG9wYXF1ZVt6TGF5ZXJdW3Byb2dyYW0uaWRdLnB1c2gob2JqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU29ydCBvcGFxdWUgc2hhZGVyIGJ1Y2tldHMgYnkgZGVwdGggZm9yIGVhcmx5IHogZmFpbHNcclxuICAgICAgICBmb3IgKHpMYXllciBpbiB6TGF5ZXJzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHByb2dJZCBpbiBvcGFxdWVbekxheWVyXSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHdpdGhpblNoYWRlciA9IG9wYXF1ZVt6TGF5ZXJdW3Byb2dJZF07XHJcbiAgICAgICAgICAgICAgICB2YXIgc29ydGVkQXJyYXkgPSBuZXcgQXJyYXkod2l0aGluU2hhZGVyLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgd2l0aGluU2hhZGVyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gd2l0aGluU2hhZGVyW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIG9iai5nZXRXb3JsZFNwYWNlQm91bmRpbmdCb3goY19iYm94KTtcclxuICAgICAgICAgICAgICAgICAgICBjX2Jib3guY2VudGVyKGNfY2VudGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3TWF0cml4ICYmIHZlYzMudHJhbnNmb3JtTWF0NChjX2NlbnRlciwgY19jZW50ZXIsIHZpZXdNYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZEFycmF5W2ldID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmo6IG9iaiwgZGVwdGg6IGNfY2VudGVyLnpcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc29ydGVkQXJyYXkuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiLmRlcHRoIC0gYS5kZXB0aDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgb3BhcXVlW3pMYXllcl1bcHJvZ0lkXSA9IHNvcnRlZEFycmF5Lm1hcChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLm9iajtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1NvcnQgdHJhbnNwYXJlbnQgei1idWNrZXRzIGJhY2sgdG8gZnJvbnRcclxuICAgICAgICB2YXIgdHJhbnNwYXJlbnQgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBpbmQgaW4gekxheWVycykge1xyXG4gICAgICAgICAgICB6TGF5ZXIgPSB6TGF5ZXJzW2luZF07XHJcbiAgICAgICAgICAgIHZhciB0bGF5ZXIgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChuIGluIHByZXNvcnRUcmFuc3BhcmVudFt6TGF5ZXJdKSB7XHJcbiAgICAgICAgICAgICAgICBvYmogPSBwcmVzb3J0VHJhbnNwYXJlbnRbekxheWVyXVtuXTtcclxuICAgICAgICAgICAgICAgIG9iai5nZXRXb3JsZFNwYWNlQm91bmRpbmdCb3goY19iYm94KTtcclxuICAgICAgICAgICAgICAgIGNfYmJveC5jZW50ZXIoY19jZW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgdmlld01hdHJpeCAmJiB2ZWMzLnRyYW5zZm9ybU1hdDQoY19jZW50ZXIsIGNfY2VudGVyLCB2aWV3TWF0cml4KTtcclxuICAgICAgICAgICAgICAgIHRsYXllci5wdXNoKFtvYmosIGNfY2VudGVyLnpdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGxheWVyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhWzFdIC0gYlsxXTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGxheWVyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0bGF5ZXJbaV0gPSB0bGF5ZXJbaV1bMF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRyYW5zcGFyZW50W3pMYXllcl0gPSB0bGF5ZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB6TGF5ZXJzIGNvbnRhaW5zIGFsbCB1bmlxdWUgei1pbmRleCB2YWx1ZXMgaW4gdGhlIHNjZW5lLCBwYXJ0aXRpb25pbmcgaXQgaW50byB6LWJ1Y2tldHNcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvcGFxdWU6IG9wYXF1ZSwgdHJhbnNwYXJlbnQ6IHRyYW5zcGFyZW50LCB6TGF5ZXJzIDogekxheWVyc1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0U29ydGVyO1xyXG5cclxuXHJcbiIsIi8qKiBDYWxjdWxhdGUgdGhlIG9mZnNldCBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBhbmQgcmV0dXJuIGl0LlxyXG4gKlxyXG4gKiAgQHBhcmFtIHtPYmplY3R9IGVsZW1lbnRcclxuICogIEByZXR1cm4ge3t0b3A6bnVtYmVyLCBsZWZ0Om51bWJlcn19IHRoZSBvZmZzZXRcclxuICpcclxuICogIFRoaXMgY29kZSBpcyB0YWtlbiBmcm9tIGh0dHA6Ly9qYXZhc2NyaXB0LmluZm8vdHV0b3JpYWwvY29vcmRpbmF0ZXMgLlxyXG4gKiAgV2UgZG9uJ3Qgd2FudCB0byBkbyBpdCB3aXRoIHRoZSBvZmZzZXRQYXJlbnQgd2F5LCBiZWNhdXNlIHRoZSB4bWwzZFxyXG4gKiAgZWxlbWVudCBpcyBhY3R1YWxseSBpbnZpc2libGUgYW5kIHRodXMgb2Zmc2V0UGFyZW50IHdpbGwgcmV0dXJuIG51bGxcclxuICogIGF0IGxlYXN0IGluIFdlYktpdC4gQWxzbyBpdCdzIHNsb3cuIFNvIHdlIHVzZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5cclxuICogIEhvd2V2ZXIgaXQgcmV0dXJucyB0aGUgYm94IHJlbGF0aXZlIHRvIHRoZSB3aW5kb3csIG5vdCB0aGUgZG9jdW1lbnQuXHJcbiAqICBUaHVzLCB3ZSBuZWVkIHRvIGluY29ycG9yYXRlIHRoZSBzY3JvbGwgZmFjdG9yLiBBbmQgYmVjYXVzZSBJRSBpcyBzb1xyXG4gKiAgYXdlc29tZSBzb21lIHdvcmthcm91bmRzIGhhdmUgdG8gYmUgZG9uZSBhbmQgdGhlIGNvZGUgZ2V0cyBjb21wbGljYXRlZC5cclxuICovXHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldChlbGVtZW50KSB7XHJcbiAgICB2YXIgYm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcclxuICAgIHZhciBkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG5cclxuICAgIC8vIGdldCBzY3JvbGwgZmFjdG9yIChldmVyeSBicm93c2VyIGV4Y2VwdCBJRSBzdXBwb3J0cyBwYWdlIG9mZnNldHMpXHJcbiAgICB2YXIgc2Nyb2xsVG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY0VsZW0uc2Nyb2xsVG9wIHx8IGJvZHkuc2Nyb2xsVG9wO1xyXG4gICAgdmFyIHNjcm9sbExlZnQgPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxMZWZ0IHx8IGJvZHkuc2Nyb2xsTGVmdDtcclxuXHJcbiAgICAvLyB0aGUgZG9jdW1lbnQgKGBodG1sYCBvciBgYm9keWApIGNhbiBiZSBzaGlmdGVkIGZyb20gbGVmdC11cHBlciBjb3JuZXIgaW4gSUUuIEdldCB0aGUgc2hpZnQuXHJcbiAgICB2YXIgY2xpZW50VG9wID0gZG9jRWxlbS5jbGllbnRUb3AgfHwgYm9keS5jbGllbnRUb3AgfHwgMDtcclxuICAgIHZhciBjbGllbnRMZWZ0ID0gZG9jRWxlbS5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwO1xyXG5cclxuICAgIHZhciB0b3AgPSBib3gudG9wICsgc2Nyb2xsVG9wIC0gY2xpZW50VG9wO1xyXG4gICAgdmFyIGxlZnQgPSBib3gubGVmdCArIHNjcm9sbExlZnQgLSBjbGllbnRMZWZ0O1xyXG5cclxuICAgIC8vIGZvciBGaXJlZm94IGFuIGFkZGl0aW9uYWwgcm91bmRpbmcgaXMgc29tZXRpbWVzIHJlcXVpcmVkXHJcbiAgICByZXR1cm4ge3RvcDogTWF0aC5yb3VuZCh0b3ApLCBsZWZ0OiBNYXRoLnJvdW5kKGxlZnQpfTtcclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIC8qKiBDb252ZXJ0IGEgZ2l2ZW4gbW91c2UgcGFnZSBwb3NpdGlvbiB0byBiZSByZWxhdGl2ZSB0byB0aGUgZ2l2ZW4gdGFyZ2V0IGVsZW1lbnQuXHJcbiAgICAgKiAgTW9zdCBwcm9iYWJseSB0aGUgcGFnZSBwb3NpdGlvbiBhcmUgdGhlIE1vdXNlRXZlbnQncyBwYWdlWCBhbmQgcGFnZVkgYXR0cmlidXRlcy5cclxuICAgICAqXHJcbiAgICAgKiAgQHBhcmFtIHshT2JqZWN0fSB4bWwzZEVsIHRoZSB4bWwzZCBlbGVtZW50IHRvIHdoaWNoIHRoZSBjb29yZHMgbmVlZCB0byBiZSB0cmFuc2xhdGVkXHJcbiAgICAgKiAgQHBhcmFtIHshbnVtYmVyfSBwYWdlWCB0aGUgeC1jb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBwYWdlXHJcbiAgICAgKiAgQHBhcmFtIHshbnVtYmVyfSBwYWdlWSB0aGUgeS1jb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBwYWdlXHJcbiAgICAgKiAgQHJldHVybiB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gdGhlIGNvbnZlcnRlZCBjb29yZGluYXRlc1xyXG4gICAgICovXHJcbiAgICBjb252ZXJ0UGFnZUNvb3JkczogZnVuY3Rpb24gKHhtbDNkRWwsIHBhZ2VYLCBwYWdlWSkge1xyXG4gICAgICAgIHZhciBvZmYgPSBjYWxjdWxhdGVPZmZzZXQoeG1sM2RFbCk7XHJcblxyXG4gICAgICAgIHJldHVybiB7eDogcGFnZVggLSBvZmYubGVmdCwgeTogcGFnZVkgLSBvZmYudG9wfTtcclxuICAgIH1cclxufTtcclxuIiwidmFyIFRleHR1cmVNYW5hZ2VyID0gcmVxdWlyZShcInRleHR1cmUtbWFuYWdlclwiKS5TaW1wbGVUZXh0dXJlTWFuYWdlcjtcclxudmFyIEdMVGV4dHVyZSA9IHJlcXVpcmUoXCIuL3RleHR1cmUuanNcIikuR0xUZXh0dXJlO1xyXG52YXIgR0xDdWJlTWFwID0gcmVxdWlyZShcIi4vdGV4dHVyZS5qc1wiKS5HTEN1YmVNYXA7XHJcbnZhciBHTENhbnZhc1RhcmdldCA9IHJlcXVpcmUoXCIuL3JlbmRlcnRhcmdldC5qc1wiKS5HTENhbnZhc1RhcmdldDtcclxudmFyIFByb2dyYW1GYWN0b3J5ID0gcmVxdWlyZShcIi4vLi4vc2hhZGVyL3Byb2dyYW1mYWN0b3J5LmpzXCIpO1xyXG52YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIEdMID0gcmVxdWlyZShcIi4uL2NvbnN0YW50cy5qc1wiKTtcclxuXHJcbnZhciBDT05URVhUX09QVElPTlMgPSB7XHJcbiAgICBhbHBoYTogdHJ1ZSwgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSwgYW50aWFsaWFzOiB0cnVlLCBzdGVuY2lsOiB0cnVlLCBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWVcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50IX0gY2FudmFzXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yQ2FudmFzKGNhbnZhcykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIENPTlRFWFRfT1BUSU9OUyk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb250ZXh0IHRoYXQgaW5jbHVkZXMgYWxsIEdMIHJlbGF0ZWQgcmVzb3VyY2VzIC8gaGFuZGxlcnNcclxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudCF9IGNhbnZhc1xyXG4gKiBAcGFyYW0ge251bWJlcn0gaWRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgR0xDb250ZXh0ID0gZnVuY3Rpb24gKGNhbnZhcywgaWQpIHtcclxuICAgIHRoaXMuZ2wgPSBnZXRDb250ZXh0Rm9yQ2FudmFzKGNhbnZhcyk7XHJcbiAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICB0aGlzLmNhbnZhc1RhcmdldCA9IG5ldyBHTENhbnZhc1RhcmdldCh0aGlzLCBjYW52YXMuY2xpZW50V2lkdGgsIGNhbnZhcy5jbGllbnRIZWlnaHQpO1xyXG4gICAgdGhpcy5wcm9ncmFtRmFjdG9yeSA9IG5ldyBQcm9ncmFtRmFjdG9yeSh0aGlzKTtcclxuICAgIHRoaXMudGV4dHVyZU1hbmFnZXIgPSBuZXcgVGV4dHVyZU1hbmFnZXIoeyB1bml0czogdGhpcy5nbC5nZXRQYXJhbWV0ZXIoR0wuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMgKX0pO1xyXG4gICAgdGhpcy5zdGF0cyA9IHtcclxuICAgICAgICBtYXRlcmlhbHM6IDAsIG1lc2hlczogMFxyXG4gICAgfTtcclxuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHBvcHVsYXRlRXh0ZW5zaW9ucyh0aGlzLmdsKTtcclxuXHJcbn07XHJcblxyXG52YXIgRVhURU5TSU9OUyA9IEdMQ29udGV4dC5FWFRFTlNJT05TID0ge307XHJcbkVYVEVOU0lPTlMuU1RBTkRBUkRfREVSSVZBVEVTID0gJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyc7XHJcbkVYVEVOU0lPTlMuTVVMVElQTEVfUkVOREVSX1RBUkdFVFMgPSAnV0VCR0xfZHJhd19idWZmZXJzJztcclxuRVhURU5TSU9OUy5ERVBUSF9URVhUVVJFID0gJ1dFQkdMX2RlcHRoX3RleHR1cmUnO1xyXG5FWFRFTlNJT05TLkZMT0FUX0NPTE9SX0JVRkZFUiA9ICdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnO1xyXG5FWFRFTlNJT05TLkZMT0FUX1RFWFRVUkVTID0gJ09FU190ZXh0dXJlX2Zsb2F0JztcclxuRVhURU5TSU9OUy5GTE9BVF9URVhUVVJFU19MSU5FQVIgPSBcIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclwiO1xyXG5FWFRFTlNJT05TLlVJTlQzMl9JTkRJQ0VTID0gJ09FU19lbGVtZW50X2luZGV4X3VpbnQnOyAvL0Fsc28gZGVmaW5lZCBpbiB4Zmxvdy91dGlscy91dGlscy5qc1xyXG5cclxuWE1MM0QuZXh0ZW5kKEdMQ29udGV4dC5wcm90b3R5cGUsIHtcclxuICAgIGdldFhmbG93RW50cnlXZWJHbERhdGE6IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIHJldHVybiBnZXRYZmxvd0VudHJ5V2ViR2xEYXRhKGVudHJ5LCB0aGlzLmlkKTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVxdWVzdFJlZHJhdzogZnVuY3Rpb24gKHJlYXNvbikge1xyXG4gICAgICAgIC8vaGFuZGxlci5yZWRyYXcocmVhc29uLCBmb3JjZVBpY2tpbmcpO1xyXG4gICAgfSxcclxuXHJcbiAgICBoYW5kbGVSZXNpemVFdmVudDogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB0aGlzLmNhbnZhc1RhcmdldCA9IG5ldyBHTENhbnZhc1RhcmdldCh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0U3RhdGlzdGljczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRzO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRFeHRlbnNpb25CeU5hbWU6IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9uc1tuYW1lXTtcclxuICAgIH0gLFxyXG5cclxuICAgIGNyZWF0ZVRleHR1cmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgR0xUZXh0dXJlKHRoaXMpO1xyXG4gICAgfSAsXHJcbiAgICBjcmVhdGVDdWJlTWFwOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEdMQ3ViZU1hcCh0aGlzKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0WGZsb3dFbnRyeVdlYkdsRGF0YShlbnRyeSwgY2FudmFzSWQpe1xyXG4gICAgaWYoIWVudHJ5KSByZXR1cm4gbnVsbDtcclxuICAgIGlmKCFlbnRyeS51c2VyRGF0YS53ZWJnbERhdGEpXHJcbiAgICAgICAgZW50cnkudXNlckRhdGEud2ViZ2xEYXRhID0ge307XHJcbiAgICBpZighZW50cnkudXNlckRhdGEud2ViZ2xEYXRhW2NhbnZhc0lkXSlcclxuICAgICAgICBlbnRyeS51c2VyRGF0YS53ZWJnbERhdGFbY2FudmFzSWRdID0ge1xyXG4gICAgICAgICAgICBjaGFuZ2VkIDogWEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX05FV1xyXG4gICAgICAgIH07XHJcbiAgICByZXR1cm4gZW50cnkudXNlckRhdGEud2ViZ2xEYXRhW2NhbnZhc0lkXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxyXG4gKiBAcmV0dXJucyB7e319XHJcbiAqL1xyXG5mdW5jdGlvbiBwb3B1bGF0ZUV4dGVuc2lvbnMoZ2wpIHtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGZvciAodmFyIG5hbWUgaW4gRVhURU5TSU9OUykge1xyXG4gICAgICAgIHZhciBleHRlbnNpb25OYW1lID0gRVhURU5TSU9OU1tuYW1lXTtcclxuICAgICAgICB2YXIgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKGV4dGVuc2lvbk5hbWUpO1xyXG4gICAgICAgIGlmICghZXh0KSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0luZm8oZXh0ZW5zaW9uTmFtZSwgXCJpcyBub3Qgc3VwcG9ydGVkIG9uIHlvdXIgZ3JhcGhpY3MgY2FyZFwiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHRbZXh0ZW5zaW9uTmFtZV0gPSBleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHTENvbnRleHQ7XHJcblxyXG5cclxuIiwidmFyIEZ1bGxzY3JlZW5RdWFkID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgIHRoaXMuZ2wgPSBjb250ZXh0LmdsO1xyXG4gICAgdGhpcy5jcmVhdGVHTEFzc2V0cygpO1xyXG59O1xyXG5cclxuWE1MM0QuZXh0ZW5kKEZ1bGxzY3JlZW5RdWFkLnByb3RvdHlwZSwge1xyXG5cclxuICAgIGNyZWF0ZUdMQXNzZXRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgICAgICB0aGlzLnBvc0J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnBvc0J1ZmZlcik7XHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDAsIC0xLCAxLCAwLCAxLCAtMSwgMCwgLTEsIC0xLCAwXSksIGdsLlNUQVRJQ19EUkFXKTtcclxuICAgIH0sXHJcblxyXG4gICAgZHJhdzogZnVuY3Rpb24gKHByb2dyYW0pIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIHZhciBwb3NBdHRyID0gcHJvZ3JhbS5hdHRyaWJ1dGVzW1wicG9zaXRpb25cIl07XHJcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zQXR0ci5sb2NhdGlvbik7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMucG9zQnVmZmVyKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc0F0dHIubG9jYXRpb24sIDMsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcblxyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xyXG5cclxuICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkocG9zQXR0ci5sb2NhdGlvbik7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRnVsbHNjcmVlblF1YWQ7XHJcblxyXG4iLCJ2YXIgR0wgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBjb250ZXh0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIEdMTWVzaCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgdGhpcy5idWZmZXJzID0ge307XHJcbiAgICB0aGlzLnVuaWZvcm1PdmVycmlkZSA9IHt9O1xyXG4gICAgdGhpcy5taW5JbmRleCA9IDA7XHJcbiAgICB0aGlzLm1heEluZGV4ID0gMDtcclxuICAgIHRoaXMuaXNJbmRleGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLnZlcnRleENvdW50ID0gbnVsbDtcclxuICAgIHRoaXMubWluQXR0cmlidXRlQ291bnQgPSAtMTtcclxuICAgIHRoaXMuY29udGV4dC5nZXRTdGF0aXN0aWNzKCkubWVzaGVzKys7XHJcbiAgICB0aGlzLmdsVHlwZSA9IG51bGw7XHJcbiAgICB0aGlzLm11bHRpRHJhdyA9IGZhbHNlO1xyXG59O1xyXG5cclxuWE1MM0QuZXh0ZW5kKEdMTWVzaC5wcm90b3R5cGUsIHtcclxuICAgIHNldEluZGV4UmFuZ2U6IGZ1bmN0aW9uIChtaW5JbmRleCwgbWF4SW5kZXgpIHtcclxuICAgICAgICB0aGlzLm1pbkluZGV4ID0gbWluSW5kZXg7XHJcbiAgICAgICAgdGhpcy5tYXhJbmRleCA9IG1heEluZGV4O1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRQcmltaXRpdmVUeXBlOiBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICAgICAgdGhpcy5nbFR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMubXVsdGlEcmF3ID0gKHRoaXMuZ2xUeXBlID09IEdMLkxJTkVfU1RSSVAgfHwgdGhpcy5nbFR5cGUgPT0gR0wuVFJJQU5HTEVfU1RSSVApO1xyXG4gICAgfSxcclxuXHJcbiAgICBjaGVja0J1ZmZlckNvbXBhdGlibGU6IGZ1bmN0aW9uIChuYW1lLCB4Zmxvd0RhdGFCdWZmZXIpIHtcclxuICAgICAgICB2YXIgY250ID0geGZsb3dEYXRhQnVmZmVyLmdldEl0ZXJhdGVDb3VudCgpO1xyXG4gICAgICAgIHRoaXMubWluQXR0cmlidXRlQ291bnQgPSAodGhpcy5taW5BdHRyaWJ1dGVDb3VudCA9PSAtMSA/IGNudCA6IE1hdGgubWluKHRoaXMubWluQXR0cmlidXRlQ291bnQsIGNudCkpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5pc0luZGV4ZWQpIHtcclxuICAgICAgICAgICAgaWYgKGNudCA8PSB0aGlzLm1heEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmRleCByYW5nZSBvZiBbXCIgKyB0aGlzLm1pbkluZGV4ICsgXCIsIFwiICsgdGhpcy5tYXhJbmRleCArIFwiXSBcIiArIFwiIGdvZXMgYmV5b25kIGVsZW1lbnQgY291bnQgXCIgKyBjbnQgKyBcIiBvZiBhdHRyaWJ1dGUgJ1wiICsgbmFtZSArIFwiJ1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy52ZXJ0ZXhDb3VudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoY250IDwgdGhpcy52ZXJ0ZXhDb3VudClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZlcnRleENvdW50IFwiICsgdGhpcy52ZXJ0ZXhDb3VudCArIFwiIGlzIGxhcmdlciB0aGFuIGVsZW1lbnQgY291bnQgXCIgKyBjbnQgKyBcIiBvZiBhdHRyaWJ1dGUgJ1wiICsgbmFtZSArIFwiJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZUJ1ZmZlcjogZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5idWZmZXJzW25hbWVdO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRCdWZmZXI6IGZ1bmN0aW9uIChuYW1lLCBidWZmZXIpIHtcclxuICAgICAgICB0aGlzLmJ1ZmZlcnNbbmFtZV0gPSBidWZmZXI7XHJcbiAgICAgICAgdGhpcy5pc0luZGV4ZWQgPSB0aGlzLmlzSW5kZXhlZCB8fCBuYW1lID09IFwiaW5kZXhcIjtcclxuICAgIH0sXHJcblxyXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSB7fTtcclxuICAgICAgICB0aGlzLnVuaWZvcm1PdmVycmlkZSA9IHt9O1xyXG4gICAgICAgIHRoaXMubWluSW5kZXggPSB0aGlzLm1heEluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLmlzSW5kZXhlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubWluQXR0cmlidXRlQ291bnQgPSAtMTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VW5pZm9ybU92ZXJyaWRlOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMudW5pZm9ybU92ZXJyaWRlW25hbWVdO1xyXG4gICAgICAgIHRoaXMudW5pZm9ybU92ZXJyaWRlW25hbWVdID0gdmFsdWU7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFZlcnRleENvdW50OiBmdW5jdGlvbiAodmVydGV4Q291bnQpIHtcclxuICAgICAgICB0aGlzLnZlcnRleENvdW50ID0gdmVydGV4Q291bnQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzUmVhZHlUb1JlbmRlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1pbkF0dHJpYnV0ZUNvdW50ID4gMDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXRFbGVtZW50Q291bnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJzLmluZGV4Lmxlbmd0aDtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vWE1MM0QuZGVidWcubG9nRXJyb3IoXCJDb3VsZCBub3QgY2FsY3VsYXRlIGVsZW1lbnQgY291bnQuXCIsIGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9LCAvKipcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldFZlcnRleENvdW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnZlcnRleENvdW50ICE9IG51bGwgPyB0aGlzLnZlcnRleENvdW50IDogdGhpcy5taW5BdHRyaWJ1dGVDb3VudCApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy9YTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNvdWxkIG5vdCBjYWxjdWxhdGUgdmVydGV4IGNvdW50LlwiLCBlKTtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7QWJzdHJhY3RTaGFkZXJDbG9zdXJlfSBwcm9ncmFtXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfYmluZFZlcnRleEJ1ZmZlcnM6IGZ1bmN0aW9uKHByb2dyYW0pIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2wsIHNBdHRyaWJ1dGVzID0gcHJvZ3JhbS5hdHRyaWJ1dGVzLCBidWZmZXJzID0gdGhpcy5idWZmZXJzLCBpLCBuYW1lO1xyXG5cclxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNBdHRyaWJ1dGVzKTtcclxuICAgICAgICB2YXIga2V5TGVuZ3RoID0ga2V5cy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBuYW1lID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGJ1ZmZlcnNbbmFtZV07XHJcbiAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHNBdHRyaWJ1dGVzW25hbWVdLmxvY2F0aW9uO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFidWZmZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvY2F0aW9uKTtcclxuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobG9jYXRpb24sIGJ1ZmZlci50dXBsZVNpemUsIGJ1ZmZlci5nbFR5cGUsIGZhbHNlLCAwLCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF91bmJpbmRWZXJ0ZXhCdWZmZXJzOiBmdW5jdGlvbiAocHJvZ3JhbSkge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbCwgc0F0dHJpYnV0ZXMgPSBwcm9ncmFtLmF0dHJpYnV0ZXM7XHJcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBzQXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICB2YXIgc2hhZGVyQXR0cmlidXRlID0gc0F0dHJpYnV0ZXNbbmFtZV07XHJcbiAgICAgICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShzaGFkZXJBdHRyaWJ1dGUubG9jYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbnVsbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtBYnN0cmFjdFNoYWRlckNsb3N1cmV9IHByb2dyYW1cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGRyYXc6IGZ1bmN0aW9uIChwcm9ncmFtKSB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsLCBzQXR0cmlidXRlcyA9IHByb2dyYW0uYXR0cmlidXRlcywgYnVmZmVycyA9IHRoaXMuYnVmZmVycywgdHJpQ291bnQgPSAwLCBvZmZzZXQsIGo7XHJcblxyXG4gICAgICAgIC8vQmluZCB2ZXJ0ZXggYnVmZmVyc1xyXG4gICAgICAgIHRoaXMuX2JpbmRWZXJ0ZXhCdWZmZXJzKHByb2dyYW0pO1xyXG5cclxuICAgICAgICAvL0RyYXcgdGhlIG9iamVjdFxyXG4gICAgICAgIGlmICh0aGlzLmlzSW5kZXhlZCkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXhCdWZmZXIgPSBidWZmZXJzLmluZGV4O1xyXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLGluZGV4QnVmZmVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpRHJhdyAmJiB0aGlzLnZlcnRleENvdW50KSB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMudmVydGV4Q291bnQubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSB0aGlzLnZlcnRleENvdW50W2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyh0aGlzLmdsVHlwZSwgY291bnQsIGluZGV4QnVmZmVyLmdsVHlwZSwgb2Zmc2V0ICogaW5kZXhCdWZmZXIuYnl0ZXNQZXJFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gY291bnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBnbC5kcmF3RWxlbWVudHModGhpcy5nbFR5cGUsIHRoaXMuZ2V0RWxlbWVudENvdW50KCksIGluZGV4QnVmZmVyLmdsVHlwZSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJpQ291bnQgPSB0aGlzLmdldEVsZW1lbnRDb3VudCgpIC8gMztcclxuICAgICAgICB9IGVsc2UgeyAvLyBub3QgaW5kZXhlZFxyXG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aURyYXcgJiYgdGhpcy52ZXJ0ZXhDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLnZlcnRleENvdW50Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy52ZXJ0ZXhDb3VudFtqXTtcclxuICAgICAgICAgICAgICAgICAgICBnbC5kcmF3QXJyYXlzKHRoaXMuZ2xUeXBlLCBvZmZzZXQsIGNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gY291bnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBnbC5kcmF3QXJyYXlzKHRoaXMuZ2xUeXBlLCAwLCB0aGlzLmdldFZlcnRleENvdW50KCkpO1xyXG4gICAgICAgICAgICAgICAgdHJpQ291bnQgPSB0aGlzLmdldFZlcnRleENvdW50KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vVW5iaW5kIHZlcnRleCBidWZmZXJzXHJcbiAgICAgICAgdGhpcy5fdW5iaW5kVmVydGV4QnVmZmVycyhwcm9ncmFtKTtcclxuXHJcblxyXG4gICAgICAgIGlmIChwcm9ncmFtLnVuZG9Vbmlmb3JtVmFyaWFibGVPdmVycmlkZSlcclxuICAgICAgICAgICAgcHJvZ3JhbS51bmRvVW5pZm9ybVZhcmlhYmxlT3ZlcnJpZGUodGhpcy51bmlmb3JtT3ZlcnJpZGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gdHJpQ291bnQ7XHJcbiAgICB9XHJcblxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdMTWVzaDtcclxuIiwiXHJcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xyXG52YXIgU3lzdGVtTm90aWZpZXIgPSByZXF1aXJlKFwiLi4vc3lzdGVtL3N5c3RlbS1ub3RpZmllci5qc1wiKTtcclxudmFyIEdMID0gcmVxdWlyZShcIi4uL2NvbnN0YW50cy5qc1wiKTtcclxuXHJcbi8vbm9pbnNwZWN0aW9uIEpTVmFsaWRhdGVKU0RvY1xyXG4vKipcclxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaGFkZXJTb3VyY2VcclxuICogQHJldHVybiB7V2ViR0xTaGFkZXJ9XHJcbiAqL1xyXG52YXIgY3JlYXRlV2ViR0xTaGFkZXJGcm9tU291cmNlID0gZnVuY3Rpb24gKGdsLCB0eXBlLCBzaGFkZXJTb3VyY2UpIHtcclxuICAgIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XHJcbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzaGFkZXJTb3VyY2UpO1xyXG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xyXG5cclxuICAgIGlmIChnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBHTC5DT01QSUxFX1NUQVRVUykgPT0gMCkge1xyXG4gICAgICAgIHZhciBtZXNzYWdlID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xyXG4gICAgICAgIHZhciBlcnJvclN0cmluZyA9IFwiXCI7XHJcbiAgICAgICAgaWYgKHR5cGUgPT0gR0wuVkVSVEVYX1NIQURFUilcclxuICAgICAgICAgICAgZXJyb3JTdHJpbmcgPSBcIlZlcnRleCBzaGFkZXIgZmFpbGVkIHRvIGNvbXBpbGU6IFxcblwiOyBlbHNlXHJcbiAgICAgICAgICAgIGVycm9yU3RyaW5nID0gXCJGcmFnbWVudCBzaGFkZXIgZmFpbGVkIHRvIGNvbXBpbGU6IFxcblwiO1xyXG5cclxuICAgICAgICBlcnJvclN0cmluZyArPSBtZXNzYWdlICsgXCJcXG4tLS0tLS0tLVxcblwiO1xyXG4gICAgICAgIGVycm9yU3RyaW5nICs9IFwiU2hhZGVyIFNvdXJjZTpcXG4tLS0tLS0tLVxcblwiO1xyXG4gICAgICAgIGVycm9yU3RyaW5nICs9IFhNTDNELmRlYnVnLmZvcm1hdFNvdXJjZUNvZGUoc2hhZGVyU291cmNlKTtcclxuICAgICAgICBnbC5nZXRFcnJvcigpO1xyXG4gICAgICAgIFN5c3RlbU5vdGlmaWVyLnNlbmRFdmVudCgnZ2xzbCcsIHtcclxuICAgICAgICAgICAgICAgIGdsc2xUeXBlOiBcImNvbXBpbGVfZXJyb3JcIixcclxuICAgICAgICAgICAgICAgIHNoYWRlclR5cGU6IHR5cGUgPT0gR0wuVkVSVEVYX1NIQURFUiA/IFwidmVydGV4XCIgOiBcImZyYWdtZW50XCIsXHJcbiAgICAgICAgICAgICAgICBjb2RlOiBzaGFkZXJTb3VyY2UsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JTdHJpbmcpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2hhZGVyO1xyXG59O1xyXG5cclxuLy9ub2luc3BlY3Rpb24gSlNWYWxpZGF0ZUpTRG9jXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcclxuICogQHBhcmFtIHZlcnRleFNvdXJjZXNcclxuICogQHBhcmFtIGZyYWdtZW50U291cmNlc1xyXG4gKiBAcmV0dXJucyB7V2ViR0xQcm9ncmFtfVxyXG4gKi9cclxudmFyIGNyZWF0ZVByb2dyYW1Gcm9tU291cmNlcyA9IGZ1bmN0aW9uIChnbCwgdmVydGV4U291cmNlcywgZnJhZ21lbnRTb3VyY2VzKSB7XHJcbiAgICB2YXIgc2hkLCBzLCBzcmM7XHJcbiAgICB2YXIgc2hhZGVycyA9IFtdO1xyXG4gICAgZm9yIChzIGluIHZlcnRleFNvdXJjZXMpIHtcclxuICAgICAgICBzcmMgPSB2ZXJ0ZXhTb3VyY2VzW3NdO1xyXG4gICAgICAgIHNoZCA9IGNyZWF0ZVdlYkdMU2hhZGVyRnJvbVNvdXJjZShnbCwgR0wuVkVSVEVYX1NIQURFUiwgc3JjKTtcclxuICAgICAgICBzaGFkZXJzLnB1c2goc2hkKTtcclxuICAgIH1cclxuICAgIGZvciAocyBpbiBmcmFnbWVudFNvdXJjZXMpIHtcclxuICAgICAgICBzcmMgPSBmcmFnbWVudFNvdXJjZXNbc107XHJcbiAgICAgICAgc2hkID0gY3JlYXRlV2ViR0xTaGFkZXJGcm9tU291cmNlKGdsLCBHTC5GUkFHTUVOVF9TSEFERVIsIHNyYyk7XHJcbiAgICAgICAgc2hhZGVycy5wdXNoKHNoZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlUHJvZ3JhbUZyb21TaGFkZXJzKGdsLCBzaGFkZXJzKTtcclxufTtcclxuXHJcbi8vbm9pbnNwZWN0aW9uIEpTVmFsaWRhdGVKU0RvY1xyXG4vKipcclxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzaGFkZXJzXHJcbiAqIEByZXR1cm4ge1dlYkdMUHJvZ3JhbX1cclxuICovXHJcbnZhciBjcmVhdGVQcm9ncmFtRnJvbVNoYWRlcnMgPSBmdW5jdGlvbiAoZ2wsIHNoYWRlcnMpIHtcclxuICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgZm9yICh2YXIgcyBpbiBzaGFkZXJzKSB7XHJcbiAgICAgICAgdmFyIHNoYWRlciA9IHNoYWRlcnNbc107XHJcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHNoYWRlcik7XHJcbiAgICB9XHJcbiAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgIGlmIChnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIEdMLkxJTktfU1RBVFVTKSA9PSAwKSB7XHJcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKTtcclxuICAgICAgICB2YXIgZXJyb3JTdHJpbmcgPSBcIlNoYWRlciBsaW5raW5nIGZhaWxlZDogXFxuXCI7XHJcbiAgICAgICAgZXJyb3JTdHJpbmcgKz0gbWVzc2FnZTtcclxuICAgICAgICBlcnJvclN0cmluZyArPSBcIlxcbi0tLS0tLS0tXFxuXCI7XHJcbiAgICAgICAgZ2wuZ2V0RXJyb3IoKTtcclxuICAgICAgICBTeXN0ZW1Ob3RpZmllci5zZW5kRXZlbnQoJ2dsc2wnLCB7Z2xzbFR5cGU6IFwibGlua19lcnJvclwiLCBtZXNzYWdlOiBtZXNzYWdlfSk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yU3RyaW5nKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm9ncmFtO1xyXG59O1xyXG5cclxudmFyIHRhbGx5ID0gZnVuY3Rpb24gKGdsLCBoYW5kbGUsIHByb2dyYW1PYmplY3QpIHtcclxuICAgIHZhciBpO1xyXG4gICAgLy8gVGFsbHkgc2hhZGVyIGF0dHJpYnV0ZXNcclxuICAgIHZhciBudW1BdHRyaWJ1dGVzID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihoYW5kbGUsIGdsLkFDVElWRV9BVFRSSUJVVEVTKTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBudW1BdHRyaWJ1dGVzOyBpKyspIHtcclxuICAgICAgICB2YXIgYXR0ID0gZ2wuZ2V0QWN0aXZlQXR0cmliKGhhbmRsZSwgaSk7XHJcbiAgICAgICAgaWYgKCFhdHQpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIHZhciBhdHRJbmZvID0ge307XHJcbiAgICAgICAgYXR0SW5mby5uYW1lID0gYXR0Lm5hbWU7XHJcbiAgICAgICAgYXR0SW5mby5zaXplID0gYXR0LnNpemU7XHJcbiAgICAgICAgYXR0SW5mby5nbFR5cGUgPSBhdHQudHlwZTtcclxuICAgICAgICBhdHRJbmZvLmxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oaGFuZGxlLCBhdHQubmFtZSk7XHJcbiAgICAgICAgcHJvZ3JhbU9iamVjdC5hdHRyaWJ1dGVzW2F0dC5uYW1lXSA9IGF0dEluZm87XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIFRhbGx5IHNoYWRlciB1bmlmb3JtcyBhbmQgc2FtcGxlcnNcclxuICAgIHZhciBudW1Vbmlmb3JtcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoaGFuZGxlLCBnbC5BQ1RJVkVfVU5JRk9STVMpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG51bVVuaWZvcm1zOyBpKyspIHtcclxuICAgICAgICB2YXIgdW5pID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybShoYW5kbGUsIGkpO1xyXG4gICAgICAgIGlmICghdW5pKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB2YXIgdW5pSW5mbyA9IHt9O1xyXG4gICAgICAgIHVuaUluZm8ubmFtZSA9IHVuaS5uYW1lO1xyXG4gICAgICAgIHVuaUluZm8uc2l6ZSA9IHVuaS5zaXplO1xyXG4gICAgICAgIHVuaUluZm8uZ2xUeXBlID0gdW5pLnR5cGU7XHJcbiAgICAgICAgdW5pSW5mby5sb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihoYW5kbGUsIHVuaS5uYW1lKTtcclxuXHJcbiAgICAgICAgdmFyIG5hbWUgPSB1bmlJbmZvLm5hbWU7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBhcnJheSBpZGVudGlmaWVyIGZyb20gbmFtZSwgdGhpcyBpcyBoYW5kbGVkIGJ5IHNpemVcclxuICAgICAgICBpZiAobmFtZS5zdWJzdHJpbmcobmFtZS5sZW5ndGggLSAzKSA9PSBcIlswXVwiKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygwLCBuYW1lLmxlbmd0aCAtIDMpOyAvLyBSZW1vdmUgWzBdXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodW5pLnR5cGUgPT0gZ2wuU0FNUExFUl8yRCB8fCB1bmkudHlwZSA9PSBnbC5TQU1QTEVSX0NVQkUpIHtcclxuICAgICAgICAgICAgLy8gU2V0IGFsbCB0ZXh0dXJlIHVuaXRzIHRvIDAsIG5lZWRzIHRvIGJlIEludDMyQXJyYXlcclxuICAgICAgICAgICAgdW5pSW5mby5jYWNoZWRVbml0cyA9IG5ldyBJbnQzMkFycmF5KHVuaUluZm8uc2l6ZSk7XHJcbiAgICAgICAgICAgIHVuaUluZm8udGV4dHVyZXMgPSBbXTtcclxuICAgICAgICAgICAgLy8gQ2FjaGVzIHRoaXMgaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgdXRpbHMuc2V0VW5pZm9ybShnbCwgdW5pSW5mbywgdW5pSW5mby5jYWNoZWRVbml0cyk7XHJcblxyXG4gICAgICAgICAgICBwcm9ncmFtT2JqZWN0LnNhbXBsZXJzW25hbWVdID0gdW5pSW5mbztcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgcHJvZ3JhbU9iamVjdC51bmlmb3Jtc1tuYW1lXSA9IHVuaUluZm87XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxudmFyIHVuaXF1ZU9iamVjdElkID0gdXRpbHMuZ2V0VW5pcXVlQ291bnRlcigpO1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcclxuICogQHBhcmFtIHt7IGZyYWdtZW50OiBzdHJpbmcsIHZlcnRleDogc3RyaW5nIH19IHNvdXJjZXNcclxuICovXHJcbnZhciBQcm9ncmFtT2JqZWN0ID0gZnVuY3Rpb24gKGdsLCBzb3VyY2VzKSB7XHJcbiAgICB0aGlzLmdsID0gZ2w7XHJcbiAgICB0aGlzLnNvdXJjZXMgPSBzb3VyY2VzO1xyXG5cclxuICAgIHRoaXMuaWQgPSB1bmlxdWVPYmplY3RJZCgpO1xyXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XHJcbiAgICB0aGlzLnVuaWZvcm1zID0ge307XHJcbiAgICB0aGlzLnNhbXBsZXJzID0ge307XHJcbiAgICB0aGlzLmhhbmRsZSA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5jcmVhdGUoKTtcclxufTtcclxuXHJcblhNTDNELmV4dGVuZChQcm9ncmFtT2JqZWN0LnByb3RvdHlwZSwge1xyXG4gICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJDcmVhdGUgc2hhZGVyIHByb2dyYW06IFwiLCB0aGlzLmlkKTtcclxuICAgICAgICB0aGlzLmhhbmRsZSA9IGNyZWF0ZVByb2dyYW1Gcm9tU291cmNlcyh0aGlzLmdsLCBbdGhpcy5zb3VyY2VzLnZlcnRleF0sIFt0aGlzLnNvdXJjZXMuZnJhZ21lbnRdKTtcclxuICAgICAgICBpZiAoIXRoaXMuaGFuZGxlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgU3lzdGVtTm90aWZpZXIuc2VuZEV2ZW50KCdnbHNsJywge2dsc2xUeXBlOiBcInN1Y2Nlc3NcIn0pO1xyXG4gICAgICAgIHRoaXMuYmluZCgpO1xyXG4gICAgICAgIHRhbGx5KHRoaXMuZ2wsIHRoaXMuaGFuZGxlLCB0aGlzKTtcclxuICAgIH0sXHJcblxyXG4gICAgYmluZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5oYW5kbGUpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJUcnlpbmcgdG8gYmluZCBpbnZhbGlkIEdMUHJvZ3JhbS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLmhhbmRsZSk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNvbWUgb2YgdGhlIGRlcGVuZGVudCB0ZXh0dXJlcyBtYXkgaGF2ZSBjaGFuZ2VkIHRoZWlyIHRleHR1cmUgdW5pdHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMuc2FtcGxlcnMpIHtcclxuICAgICAgICAgICAgdmFyIHNhbXBsZXIgPSB0aGlzLnNhbXBsZXJzW25hbWVdO1xyXG4gICAgICAgICAgICBpZihzYW1wbGVyLnRleHR1cmVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTYW1wbGVyRnJvbVRleHR1cmVzKHNhbXBsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIH0sIGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLmhhbmRsZTtcclxuICAgIH0sIHNldFVuaWZvcm1WYXJpYWJsZXM6IGZ1bmN0aW9uIChlbnZOYW1lcywgc3lzTmFtZXMsIGlucHV0Q29sbGVjdGlvbikge1xyXG4gICAgICAgIHZhciBpLCBiYXNlLCBvdmVycmlkZSwgbmFtZTtcclxuICAgICAgICBpZiAoZW52TmFtZXMgJiYgaW5wdXRDb2xsZWN0aW9uLmVudkJhc2UpIHtcclxuICAgICAgICAgICAgaSA9IGVudk5hbWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgYmFzZSA9IGlucHV0Q29sbGVjdGlvbi5lbnZCYXNlO1xyXG4gICAgICAgICAgICBvdmVycmlkZSA9IGlucHV0Q29sbGVjdGlvbi5lbnZPdmVycmlkZTtcclxuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IGVudk5hbWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRVbmlmb3JtVmFyaWFibGUobmFtZSwgb3ZlcnJpZGUgJiYgb3ZlcnJpZGVbbmFtZV0gIT09IHVuZGVmaW5lZCA/IG92ZXJyaWRlW25hbWVdIDogYmFzZVtuYW1lXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN5c05hbWVzICYmIGlucHV0Q29sbGVjdGlvbi5zeXNCYXNlKSB7XHJcbiAgICAgICAgICAgIGkgPSBzeXNOYW1lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGJhc2UgPSBpbnB1dENvbGxlY3Rpb24uc3lzQmFzZTtcclxuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IHN5c05hbWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRVbmlmb3JtVmFyaWFibGUobmFtZSwgYmFzZVtuYW1lXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBzZXRVbmlmb3JtVmFyaWFibGU6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XHJcbiAgICAgICAgaWYgKHRoaXMudW5pZm9ybXNbbmFtZV0pIHtcclxuICAgICAgICAgICAgdXRpbHMuc2V0VW5pZm9ybSh0aGlzLmdsLCB0aGlzLnVuaWZvcm1zW25hbWVdLCB2YWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNhbXBsZXJzW25hbWVdKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VW5pZm9ybVNhbXBsZXIodGhpcy5zYW1wbGVyc1tuYW1lXSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB0ZXh0dXJlIHVuaXRzIGZyb20gdGhlIHRleHR1cmVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgc2FtcGxlclxyXG4gICAgICogQHBhcmFtIHNhbXBsZXJcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBzZXRTYW1wbGVyRnJvbVRleHR1cmVzOiBmdW5jdGlvbiAoc2FtcGxlcikge1xyXG4gICAgICAgIHZhciB0ZXh0dXJlcyA9IHNhbXBsZXIudGV4dHVyZXM7XHJcbiAgICAgICAgdmFyIGNhY2hlZFVuaXRzID0gc2FtcGxlci5jYWNoZWRVbml0cztcclxuICAgICAgICB2YXIgdGV4dHVyZVVuaXRzQ2hhbmdlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0ZXh0dXJlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB1bml0ID0gdGV4dHVyZXNbaV0udW5pdDtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRleHR1cmUgaXMgbm90IGJvdW5kIHRvIGEgdGV4dHVyZSB1bml0ICgtMSksIGJpbmQgaXQgbm93XHJcbiAgICAgICAgICAgIGlmICh1bml0ID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB1bml0ID0gdGV4dHVyZXNbaV0uX2JpbmQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodW5pdCAhPSBjYWNoZWRVbml0c1tpXSkge1xyXG4gICAgICAgICAgICAgICAgY2FjaGVkVW5pdHNbaV0gPSB1bml0O1xyXG4gICAgICAgICAgICAgICAgdGV4dHVyZVVuaXRzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRleHR1cmVVbml0c0NoYW5nZWQpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJTZXR0aW5nIG5ldyB0ZXh0dXJlIHVuaXRzOlwiLCBzYW1wbGVyLm5hbWUsIGNhY2hlZFVuaXRzKTtcclxuICAgICAgICAgICAgdXRpbHMuc2V0VW5pZm9ybSh0aGlzLmdsLCBzYW1wbGVyLCBjYWNoZWRVbml0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTYW1wbGVyRnJvbUFycmF5OiBmdW5jdGlvbihzYW1wbGVyLCBhcnIpIHtcclxuICAgICAgICB2YXIgY2FjaGVkVW5pdHMgPSBzYW1wbGVyLmNhY2hlZFVuaXRzO1xyXG4gICAgICAgIHZhciB0ZXh0dXJlVW5pdHNDaGFuZ2VkID0gZmFsc2U7XHJcblxyXG4gICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJyLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHVuaXQgPSBhcnJbaV07XHJcbiAgICAgICAgICAgIGlmICh1bml0ICE9IGNhY2hlZFVuaXRzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBjYWNoZWRVbml0c1tpXSA9IHVuaXQ7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlVW5pdHNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGV4dHVyZVVuaXRzQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICB1dGlscy5zZXRVbmlmb3JtKHRoaXMuZ2wsIHNhbXBsZXIsIGNhY2hlZFVuaXRzKTtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJTZXR0aW5nIGdsb2JhbCB0ZXh0dXJlIHVuaXRzOlwiLCBzYW1wbGVyLm5hbWUsIGNhY2hlZFVuaXRzLCB0aGlzLmlkKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzYW1wbGVyXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxHTFRleHR1cmU+fEludDMyQXJyYXl9IHZhbHVlXHJcbiAgICAgKi9cclxuICAgIHNldFVuaWZvcm1TYW1wbGVyOiBmdW5jdGlvbiAoc2FtcGxlciwgdmFsdWUpIHtcclxuICAgICAgICBYTUwzRC5kZWJ1Zy5hc3NlcnQodmFsdWUgJiYgc2FtcGxlcik7XHJcbiAgICAgICAgLy8gVGV4dHVyZXMgYXJlIGFsd2F5cyBhbiBhcnJheSB2YWx1ZVxyXG4gICAgICAgIFhNTDNELmRlYnVnLmFzc2VydChBcnJheS5pc0FycmF5KHZhbHVlKSwgXCJQcm9ncmFtOjpzZXRVbmlmb3JtU2FtcGxlcjogVW5leHBlY3RlZCB2YWx1ZS5cIik7XHJcbiAgICAgICAgLy8gV2UgaGF2ZSBhdCBsZWFzdCBvbmUgZW50cnlcclxuICAgICAgICBYTUwzRC5kZWJ1Zy5hc3NlcnQodmFsdWUubGVuZ3RoLCBcIlByb2dyYW06OnNldFVuaWZvcm1TYW1wbGVyOiBObyBlbnRyeSBpbiB2YWx1ZS5cIik7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFZhbHVlIGNhbiBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgR0xUZXh0dXJlcyB0aGF0IGtub3cgdGhlaXIgY3VycmVudCB0ZXh0dXJlIHVuaXQsXHJcbiAgICAgICAgICogb3RoZXJ3aXNlIGEgdHlwZWQgYXJyYXkgY29udGFpbmluZyB0aGUgdGV4dHVyZSB1bml0cyB3ZSBoYXZlIHRvIGJpbmQuXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGhhc1RleHR1cmVzID0gdmFsdWVbMF0udW5pdCAhPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIGlmKGhhc1RleHR1cmVzKSB7XHJcbiAgICAgICAgICAgIHNhbXBsZXIudGV4dHVyZXMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5zZXRTYW1wbGVyRnJvbVRleHR1cmVzKHNhbXBsZXIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U2FtcGxlckZyb21BcnJheShzYW1wbGVyLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJvZ3JhbU9iamVjdDtcclxuXHJcbiIsIi8qKlxyXG4gKiBAaW50ZXJmYWNlXHJcbiAqL1xyXG52YXIgSVJlbmRlclRhcmdldCA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuSVJlbmRlclRhcmdldC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuSVJlbmRlclRhcmdldC5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5JUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuSVJlbmRlclRhcmdldC5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5JUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5nZXRTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuSVJlbmRlclRhcmdldC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcmFwcGVyIHRvIGhhbmRsZSBzY3JlZW4gY29udGV4dCBhcyByZW5kZXIgdGFyZ2V0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0dMQ29udGV4dH0gY29udGV4dFxyXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcclxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxyXG4gKiBAaW1wbGVtZW50cyBJUmVuZGVyVGFyZ2V0XHJcbiAqL1xyXG52YXIgR0xDYW52YXNUYXJnZXQgPSBmdW5jdGlvbiAoY29udGV4dCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG59O1xyXG5cclxudmFyIGVtcHR5ID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5cclxuWE1MM0QuZXh0ZW5kKEdMQ2FudmFzVGFyZ2V0LnByb3RvdHlwZSwge1xyXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcclxuICAgIH0sIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcclxuICAgIH0sIGdldFNjYWxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9LCBiaW5kOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmNvbnRleHQuZ2wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgfSwgdW5iaW5kOiBlbXB0eSwgcmVzaXplOiBlbXB0eVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gY29udGV4dFxyXG4gKiBAcGFyYW0gb3B0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAaW1wbGVtZW50cyBJUmVuZGVyVGFyZ2V0XHJcbiAqL1xyXG52YXIgR0xSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoY29udGV4dCwgb3B0KSB7XHJcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgdGhpcy53aWR0aCA9IG9wdC53aWR0aCB8fCA4MDA7XHJcbiAgICB0aGlzLmhlaWdodCA9IG9wdC5oZWlnaHQgfHwgNjAwO1xyXG4gICAgdGhpcy5zY2FsZSA9IG9wdC5zY2FsZSB8fCAxO1xyXG4gICAgdGhpcy5vcHQgPSB0aGlzLmZpbGxPcHRpb25zKG9wdCk7XHJcbiAgICB0aGlzLmhhbmRsZSA9IG51bGw7XHJcbiAgICB0aGlzLmNvbG9yVGFyZ2V0ID0ge2hhbmRsZTogbnVsbCwgaXNUZXh0dXJlOiBmYWxzZX07XHJcbiAgICB0aGlzLmRlcHRoVGFyZ2V0ID0ge2hhbmRsZTogbnVsbCwgaXNUZXh0dXJlOiBmYWxzZX07XHJcbiAgICB0aGlzLnN0ZW5jaWxUYXJnZXQgPSB7aGFuZGxlOiBudWxsLCBpc1RleHR1cmU6IGZhbHNlfTtcclxuICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcclxufTtcclxuXHJcblhNTDNELmV4dGVuZChHTFJlbmRlclRhcmdldC5wcm90b3R5cGUsIHtcclxuICAgIGdldFdpZHRoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XHJcbiAgICB9LCBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XHJcbiAgICB9LCBnZXRTY2FsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlO1xyXG4gICAgfSwgYmluZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5oYW5kbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmFtZUJ1ZmZlcih0aGlzLm9wdC5jb2xvckZvcm1hdCwgdGhpcy5vcHQuZGVwdGhGb3JtYXQsIHRoaXMub3B0LnN0ZW5jaWxGb3JtYXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy52YWxpZCkge1xyXG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XHJcbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5oYW5kbGUpO1xyXG4gICAgICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgdW5iaW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xyXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XHJcbiAgICB9LCByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuYmluZCgpO1xyXG4gICAgfSwgY3JlYXRlRnJhbWVCdWZmZXI6IGZ1bmN0aW9uIChjb2xvckZvcm1hdCwgZGVwdGhGb3JtYXQsIHN0ZW5jaWxGb3JtYXQpIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XHJcblxyXG4gICAgICAgIHRoaXMuaGFuZGxlID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcclxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuaGFuZGxlKTtcclxuICAgICAgICBjb2xvckZvcm1hdCAmJiB0aGlzLmNyZWF0ZUNvbG9yVGFyZ2V0KGNvbG9yRm9ybWF0KTtcclxuICAgICAgICBkZXB0aEZvcm1hdCAmJiB0aGlzLmNyZWF0ZURlcHRoVGFyZ2V0KGRlcHRoRm9ybWF0KTtcclxuICAgICAgICBzdGVuY2lsRm9ybWF0ICYmIHRoaXMuY3JlYXRlU3RlbmNpbFRhcmdldChzdGVuY2lsRm9ybWF0KTtcclxuICAgICAgICB0aGlzLmNoZWNrU3RhdHVzKCk7XHJcbiAgICB9LCBjcmVhdGVDb2xvclRhcmdldDogZnVuY3Rpb24gKGNvbG9yRm9ybWF0KSB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xyXG4gICAgICAgIGlmICh0aGlzLm9wdC5jb2xvckFzUmVuZGVyYnVmZmVyKSB7XHJcbiAgICAgICAgICAgIHZhciBjdCA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xyXG4gICAgICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgY3QpO1xyXG4gICAgICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgY29sb3JGb3JtYXQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xyXG5cclxuICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5SRU5ERVJCVUZGRVIsIGN0KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY29sb3JUYXJnZXQgPSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGU6IGN0LCBpc1RleHR1cmU6IGZhbHNlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9vcHQuZ2VuZXJhdGVNaXBtYXAgPSBvcHQuZ2VuZXJhdGVDb2xvcnNNaXBtYXA7XHJcbiAgICAgICAgICAgIHZhciBjdGV4ID0gdGhpcy5jb250ZXh0LmNyZWF0ZVRleHR1cmUoKTtcclxuICAgICAgICAgICAgY3RleC5jcmVhdGVUZXgyREZyb21EYXRhKGNvbG9yRm9ybWF0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgZ2wuUkdCQSwgdGhpcy5vcHQuY29sb3JUeXBlIHx8IGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMub3B0KTtcclxuICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCBjdGV4LmhhbmRsZSwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29sb3JUYXJnZXQgPSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGU6IGN0ZXgsIGlzVGV4dHVyZTogdHJ1ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0sIGNyZWF0ZURlcHRoVGFyZ2V0OiBmdW5jdGlvbiAoZGVwdGhGb3JtYXQpIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XHJcbiAgICAgICAgdGhpcy5vcHQuaXNEZXB0aCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0LmRlcHRoQXNSZW5kZXJidWZmZXIpIHtcclxuICAgICAgICAgICAgdmFyIGR0ID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XHJcbiAgICAgICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBkdCk7XHJcbiAgICAgICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBkZXB0aEZvcm1hdCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XHJcblxyXG4gICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCBkdCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRlcHRoVGFyZ2V0ID0ge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlOiBkdCwgaXNUZXh0dXJlOiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9vcHQuZ2VuZXJhdGVNaXBtYXAgPSBvcHQuZ2VuZXJhdGVEZXB0aE1pcG1hcDtcclxuICAgICAgICAgICAgdmFyIGR0ZXggPSB0aGlzLmNvbnRleHQuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICAgICAgICBkdGV4LmNyZWF0ZVRleDJERnJvbURhdGEoZGVwdGhGb3JtYXQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBnbC5ERVBUSF9DT01QT05FTlQsIGdsLkZMT0FULCB0aGlzLm9wdCk7XHJcbiAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5URVhUVVJFXzJELCBkdGV4LmhhbmRsZSwgMCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRlcHRoVGFyZ2V0ID0ge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlOiBkdGV4LCBpc1RleHR1cmU6IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIGNyZWF0ZVN0ZW5jaWxUYXJnZXQ6IGZ1bmN0aW9uIChzdGVuY2lsRm9ybWF0KSB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xyXG4gICAgICAgIGlmICh0aGlzLm9wdC5zdGVuY2lsQXNSZW5kZXJidWZmZXIpIHtcclxuICAgICAgICAgICAgdmFyIHN0ID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XHJcbiAgICAgICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBzdCk7XHJcbiAgICAgICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBzdGVuY2lsRm9ybWF0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcclxuXHJcbiAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5TVEVOQ0lMX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgc3QpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zdGVuY2lsVGFyZ2V0ID0ge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlOiBzdCwgaXNUZXh0dXJlOiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9vcHQuZ2VuZXJhdGVNaXBtYXAgPSBvcHQuZ2VuZXJhdGVTdGVuY2lsTWlwbWFwO1xyXG4gICAgICAgICAgICB2YXIgc3RleCA9IHRoaXMuY29udGV4dC5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICAgICAgICAgIHN0ZXguY3JlYXRlVGV4MkRGcm9tRGF0YShzdGVuY2lsRm9ybWF0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgZ2wuU1RFTkNJTF9DT01QT05FTlQsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMub3B0KTtcclxuICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLlNURU5DSUxfQVRUQUNITUVOVCwgZ2wuVEVYVFVSRV8yRCwgc3RleC5oYW5kbGUsIDApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zdGVuY2lsVGFyZ2V0ID0ge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlOiBzdGV4LCBpc1RleHR1cmU6IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIGNoZWNrU3RhdHVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xyXG5cclxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuaGFuZGxlKTtcclxuICAgICAgICAvL0ZpbmFsaXplIGZyYW1lYnVmZmVyIGNyZWF0aW9uXHJcbiAgICAgICAgdmFyIGZiU3RhdHVzID0gZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUik7XHJcblxyXG4gICAgICAgIHN3aXRjaCAoZmJTdGF0dXMpIHtcclxuICAgICAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURTpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVDpcclxuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UXCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQ6XHJcbiAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkluY29tcGxldGUgZnJhbWVidWZmZXI6IEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UXCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TOlxyXG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJJbmNvbXBsZXRlIGZyYW1lYnVmZmVyOiBGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlNcIik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9VTlNVUFBPUlRFRDpcclxuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogRlJBTUVCVUZGRVJfVU5TVVBQT1JURURcIik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogXCIgKyBmYlN0YXR1cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xyXG5cclxuICAgICAgICB0aGlzLnZhbGlkID0gKGZiU3RhdHVzID09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKTtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZDtcclxuICAgIH0sIGZpbGxPcHRpb25zOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcclxuICAgICAgICB2YXIgb3B0ID0ge1xyXG4gICAgICAgICAgICB3cmFwUzogZ2wuQ0xBTVBfVE9fRURHRSxcclxuICAgICAgICAgICAgd3JhcFQ6IGdsLkNMQU1QX1RPX0VER0UsXHJcbiAgICAgICAgICAgIG1pbkZpbHRlcjogZ2wuTkVBUkVTVCxcclxuICAgICAgICAgICAgbWFnRmlsdGVyOiBnbC5ORUFSRVNULFxyXG4gICAgICAgICAgICBkZXB0aE1vZGU6IGdsLkxVTUlOQU5DRSxcclxuICAgICAgICAgICAgZGVwdGhDb21wYXJlTW9kZTogZ2wuQ09NUEFSRV9SX1RPX1RFWFRVUkUsXHJcbiAgICAgICAgICAgIGRlcHRoQ29tcGFyZUZ1bmM6IGdsLkxFUVVBTCxcclxuICAgICAgICAgICAgY29sb3JzQXNSZW5kZXJidWZmZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICBkZXB0aEFzUmVuZGVyYnVmZmVyOiBmYWxzZSxcclxuICAgICAgICAgICAgc3RlbmNpbEFzUmVuZGVyYnVmZmVyOiBmYWxzZSxcclxuICAgICAgICAgICAgaXNEZXB0aDogZmFsc2VcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpdGVtIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgb3B0W2l0ZW1dID0gb3B0aW9uc1tpdGVtXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9wdDtcclxuICAgIH0sIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaGFuZGxlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcclxuICAgICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLmhhbmRsZSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmNvbG9yVGFyZ2V0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yVGFyZ2V0LmlzVGV4dHVyZSlcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sb3JUYXJnZXQuaGFuZGxlLmRpc3Bvc2UoKTsgZWxzZVxyXG4gICAgICAgICAgICAgICAgZ2wuZGVsZXRlUmVuZGVyQnVmZmVyKHRoaXMuY29sb3JUYXJnZXQuaGFuZGxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZGVwdGhUYXJnZXQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGVwdGhUYXJnZXQuaXNUZXh0dXJlKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kZXB0aFRhcmdldC5oYW5kbGUuZGlzcG9zZSgpOyBlbHNlXHJcbiAgICAgICAgICAgICAgICBnbC5kZWxldGVSZW5kZXJCdWZmZXIodGhpcy5kZXB0aFRhcmdldC5oYW5kbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zdGVuY2lsVGFyZ2V0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0ZW5jaWxUYXJnZXQuaXNUZXh0dXJlKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGVuY2lsVGFyZ2V0LmhhbmRsZS5kaXNwb3NlKCk7IGVsc2VcclxuICAgICAgICAgICAgICAgIGdsLmRlbGV0ZVJlbmRlckJ1ZmZlcih0aGlzLnN0ZW5jaWxUYXJnZXQuaGFuZGxlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxudmFyIEdMU2NhbGVkUmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKGNvbnRleHQsIG1heERpbWVuc2lvbiwgb3B0KSB7XHJcbiAgICBHTFJlbmRlclRhcmdldC5jYWxsKHRoaXMsIGNvbnRleHQsIG9wdCk7XHJcbiAgICB0aGlzLnNjYWxlVG9NYXhEaW1lbnNpb24obWF4RGltZW5zaW9uKTtcclxufTtcclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKEdMU2NhbGVkUmVuZGVyVGFyZ2V0LCBHTFJlbmRlclRhcmdldCk7XHJcblhNTDNELmV4dGVuZChHTFNjYWxlZFJlbmRlclRhcmdldC5wcm90b3R5cGUsIHtcclxuICAgIHNjYWxlVG9NYXhEaW1lbnNpb246IGZ1bmN0aW9uIChtYXhEaW1lbnNpb24pIHtcclxuICAgICAgICB2YXIgaERpZmYgPSB0aGlzLmhlaWdodCAtIG1heERpbWVuc2lvbjtcclxuICAgICAgICB2YXIgd0RpZmYgPSB0aGlzLndpZHRoIC0gbWF4RGltZW5zaW9uO1xyXG5cclxuICAgICAgICBpZiAoaERpZmYgPiAwIHx8IHdEaWZmID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgc2NhbGU7XHJcbiAgICAgICAgICAgIGlmIChoRGlmZiA+IHdEaWZmKSB7XHJcbiAgICAgICAgICAgICAgICBzY2FsZSA9IG1heERpbWVuc2lvbiAvIHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2NhbGUgPSBtYXhEaW1lbnNpb24gLyB0aGlzLndpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBNYXRoLmZsb29yKHRoaXMud2lkdGggKiBzY2FsZSk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5mbG9vcih0aGlzLmhlaWdodCAqIHNjYWxlKTtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbnRleHRcclxuICAgICAqIEBwYXJhbSBvcHRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGltcGxlbWVudHMgSVJlbmRlclRhcmdldFxyXG4gICAgICovXHJcbiAgICB2YXIgR0xDdWJlTWFwUmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKGNvbnRleHQsIG9wdCkge1xyXG4gICAgICAgIHZhciBnbCA9IGNvbnRleHQuZ2w7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLndpZHRoID0gb3B0LndpZHRoIHx8IDgwMDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMud2lkdGg7XHJcbiAgICAgICAgdGhpcy5zY2FsZSA9IG9wdC5zY2FsZSB8fCAxO1xyXG4gICAgICAgIHRoaXMub3B0ID0gdGhpcy5maWxsT3B0aW9ucyhvcHQpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmN0ZXggPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZHRleCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdGV4ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbG9yVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmRlcHRoVGFyZ2V0ID0gIG51bGw7XHJcbiAgICAgICAgdGhpcy5zdGVuY2lsVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5nbFNpZGVzID0gW2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ksIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aLCBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1pdO1xyXG4gICAgICAgIHRoaXMuZnJhbWVidWZmZXJzID0gW107XHJcbiAgICB9O1xyXG5cclxuICAgIFhNTDNELmV4dGVuZChHTEN1YmVNYXBSZW5kZXJUYXJnZXQucHJvdG90eXBlLCB7XHJcbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFNjYWxlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBiaW5kOiBmdW5jdGlvbiAoc2lkZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5mcmFtZWJ1ZmZlcnMubGVuZ3RoIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJhbWVCdWZmZXJzKHRoaXMub3B0LmNvbG9yRm9ybWF0LCB0aGlzLm9wdC5kZXB0aEZvcm1hdCwgdGhpcy5vcHQuc3RlbmNpbEZvcm1hdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMudmFsaWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcclxuICAgICAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcnNbc2lkZV0pO1xyXG4gICAgICAgICAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xyXG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLmJpbmQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNyZWF0ZUZyYW1lQnVmZmVyczogZnVuY3Rpb24gKGNvbG9yRm9ybWF0LCBkZXB0aEZvcm1hdCwgc3RlbmNpbEZvcm1hdCkge1xyXG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XHJcblxyXG4gICAgICAgICAgICBpZihjb2xvckZvcm1hdCkgeyAvL1RPRE8gY2hlY2sgaWYgcmVuZGVyYnVmZmVycyBpbnN0ZWFkIG9mIHRleHR1cmVzLi4uXHJcbiAgICAgICAgICAgICAgICB0aGlzLmN0ZXggPSB0aGlzLmNvbnRleHQuY3JlYXRlQ3ViZU1hcCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdGV4LmNyZWF0ZVRleDJERnJvbURhdGEoY29sb3JGb3JtYXQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBnbC5SR0JBLCB0aGlzLm9wdC5jb2xvclR5cGUgfHwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5vcHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvclRhcmdldCA9IHsgaGFuZGxlOiB0aGlzLmN0ZXgsICBpc1RleHR1cmU6IHRydWV9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGRlcHRoRm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdC5pc0RlcHRoID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHQuZGVwdGhBc1JlbmRlcmJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmR0ZXggPSB0aGlzLmNvbnRleHQuY3JlYXRlQ3ViZU1hcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHRleC5jcmVhdGVUZXgyREZyb21EYXRhKGRlcHRoRm9ybWF0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgZ2wuREVQVEhfQ09NUE9ORU5ULCBnbC5GTE9BVCwgdGhpcy5vcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVwdGhUYXJnZXQgPSB7IGhhbmRsZTogdGhpcy5kdGV4LCAgaXNUZXh0dXJlOiB0cnVlfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihzdGVuY2lsRm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0ZXggPSB0aGlzLmNvbnRleHQuY3JlYXRlQ3ViZU1hcCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGV4LmNyZWF0ZVRleDJERnJvbURhdGEoc3RlbmNpbEZvcm1hdCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIGdsLlNURU5DSUxfQ09NUE9ORU5ULCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLm9wdCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0ZW5jaWxUYXJnZXQgPSB7IGhhbmRsZTogdGhpcy5zdGV4LCBpc1RleHR1cmU6IHRydWV9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5nbFNpZGVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lYnVmZmVyc1tpXSA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXJzW2ldKTtcclxuICAgICAgICAgICAgICAgIGNvbG9yRm9ybWF0ICYmIHRoaXMuY3JlYXRlQ29sb3JUYXJnZXQoY29sb3JGb3JtYXQsIGkpO1xyXG4gICAgICAgICAgICAgICAgZGVwdGhGb3JtYXQgJiYgdGhpcy5jcmVhdGVEZXB0aFRhcmdldChkZXB0aEZvcm1hdCwgaSk7XHJcbiAgICAgICAgICAgICAgICBzdGVuY2lsRm9ybWF0ICYmIHRoaXMuY3JlYXRlU3RlbmNpbFRhcmdldChzdGVuY2lsRm9ybWF0LCBpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tTdGF0dXMoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNyZWF0ZUNvbG9yVGFyZ2V0OiBmdW5jdGlvbiAoY29sb3JGb3JtYXQsIHNpZGUpIHtcclxuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xyXG4gICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIHRoaXMuZ2xTaWRlc1tzaWRlXSwgdGhpcy5jdGV4LmhhbmRsZSwgMCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjcmVhdGVEZXB0aFRhcmdldDogZnVuY3Rpb24gKGRlcHRoRm9ybWF0LCBzaWRlKSB7XHJcbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdC5kZXB0aEFzUmVuZGVyYnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZHRleCkgdGhpcy5kdGV4ID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLmR0ZXhbc2lkZV0gPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcclxuICAgICAgICAgICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCB0aGlzLmR0ZXhbc2lkZV0pO1xyXG4gICAgICAgICAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGRlcHRoRm9ybWF0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5kdGV4W3NpZGVdKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kZXB0aFRhcmdldCkgdGhpcy5kZXB0aFRhcmdldCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZXB0aFRhcmdldFtzaWRlXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGU6IHRoaXMuZHRleFtzaWRlXSxcclxuICAgICAgICAgICAgICAgICAgICBpc1RleHR1cmU6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQwLCB0aGlzLmdsU2lkZXNbc2lkZV0sIHRoaXMuZHRleC5oYW5kbGUsIDApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3JlYXRlU3RlbmNpbFRhcmdldDogZnVuY3Rpb24gKHN0ZW5jaWxGb3JtYXQsIHNpZGUpIHtcclxuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xyXG5cclxuICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLlNURU5DSUxfQVRUQUNITUVOVCwgdGhpcy5nbFNpZGVzW3NpZGVdLCB0aGlzLnN0ZXguaGFuZGxlLCAwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNoZWNrU3RhdHVzOiBmdW5jdGlvbiAoc2lkZSkge1xyXG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XHJcblxyXG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXJzW3NpZGVdKTtcclxuICAgICAgICAgICAgLy9GaW5hbGl6ZSBmcmFtZWJ1ZmZlciBjcmVhdGlvblxyXG4gICAgICAgICAgICB2YXIgZmJTdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKTtcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAoZmJTdGF0dXMpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEU6XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVDpcclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkluY29tcGxldGUgZnJhbWVidWZmZXI6IEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQ6XHJcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJJbmNvbXBsZXRlIGZyYW1lYnVmZmVyOiBGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TOlxyXG4gICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9VTlNVUFBPUlRFRDpcclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkluY29tcGxldGUgZnJhbWVidWZmZXI6IEZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkluY29tcGxldGUgZnJhbWVidWZmZXI6IFwiICsgZmJTdGF0dXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy52YWxpZCA9IChmYlN0YXR1cyA9PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZmlsbE9wdGlvbnM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcclxuICAgICAgICAgICAgdmFyIG9wdCA9IHtcclxuICAgICAgICAgICAgICAgIHdyYXBTOiBnbC5DTEFNUF9UT19FREdFLFxyXG4gICAgICAgICAgICAgICAgd3JhcFQ6IGdsLkNMQU1QX1RPX0VER0UsXHJcbiAgICAgICAgICAgICAgICBtaW5GaWx0ZXI6IGdsLk5FQVJFU1QsXHJcbiAgICAgICAgICAgICAgICBtYWdGaWx0ZXI6IGdsLk5FQVJFU1QsXHJcbiAgICAgICAgICAgICAgICBkZXB0aE1vZGU6IGdsLkxVTUlOQU5DRSxcclxuICAgICAgICAgICAgICAgIGRlcHRoQ29tcGFyZU1vZGU6IGdsLkNPTVBBUkVfUl9UT19URVhUVVJFLFxyXG4gICAgICAgICAgICAgICAgZGVwdGhDb21wYXJlRnVuYzogZ2wuTEVRVUFMLFxyXG4gICAgICAgICAgICAgICAgY29sb3JzQXNSZW5kZXJidWZmZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgZGVwdGhBc1JlbmRlcmJ1ZmZlcjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzdGVuY2lsQXNSZW5kZXJidWZmZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgaXNEZXB0aDogZmFsc2VcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGl0ZW0gaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgb3B0W2l0ZW1dID0gb3B0aW9uc1tpdGVtXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG9wdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZnJhbWVidWZmZXJzLmxlbmd0aCA8PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xyXG4gICAgICAgICAgICBmb3IodmFyIHNpZGUgaW4gdGhpcy5mcmFtZWJ1ZmZlcnMpXHJcbiAgICAgICAgICAgICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLmZyYW1lYnVmZmVyc1tzaWRlXSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvclRhcmdldC5oYW5kbGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbG9yVGFyZ2V0LmhhbmRsZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZGVwdGhUYXJnZXQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVwdGhUYXJnZXQuaGFuZGxlLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGVuY2lsVGFyZ2V0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGVuY2lsVGFyZ2V0LmhhbmRsZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWVidWZmZXJzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIEdMQ2FudmFzVGFyZ2V0OiBHTENhbnZhc1RhcmdldCxcclxuICAgIEdMUmVuZGVyVGFyZ2V0OiBHTFJlbmRlclRhcmdldCxcclxuICAgIEdMU2NhbGVkUmVuZGVyVGFyZ2V0OiBHTFNjYWxlZFJlbmRlclRhcmdldCxcclxuICAgIEdMQ3ViZU1hcFJlbmRlclRhcmdldDogR0xDdWJlTWFwUmVuZGVyVGFyZ2V0XHJcbn07XHJcblxyXG5cclxuIiwidmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XHJcbnZhciBTdGF0ZU1hY2hpbmUgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29udHJpYi9zdGF0ZS1tYWNoaW5lLmpzXCIpO1xyXG52YXIgU2FtcGxlckNvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvZGF0YS5qc1wiKS5TYW1wbGVyQ29uZmlnO1xyXG52YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIHVuaXF1ZU9iamVjdElkID0gdXRpbHMuZ2V0VW5pcXVlQ291bnRlcigpO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XHJcbiAqL1xyXG52YXIgR0wgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzLmpzXCIpO1xyXG5cclxuLy9ub2luc3BlY3Rpb24gSlNWYWxpZGF0ZUpTRG9jXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0dMQ29udGV4dH0gY29udGV4dFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBHTFRleHR1cmUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgU2FtcGxlckNvbmZpZy5jYWxsKHRoaXMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge0dMQ29udGV4dH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaWQgPSB1bmlxdWVPYmplY3RJZCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVW5pdCB0aGUgdGV4dHVyZSBpcyBjdXJyZW50bHkgYm91bmQgdG8gKG9yIC0xIGlmIGJvdW5kIHRvIG5vIHVuaXQpXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnVuaXQgPSAtMTtcclxuXHJcbiAgICB0aGlzLnNldERlZmF1bHRzKCk7XHJcblxyXG4gICAgdGhpcy53aWR0aCA9IDA7XHJcbiAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICB0aGlzLmhhbmRsZSA9IG51bGw7XHJcblxyXG4gICAgdGhpcy50ZXh0dXJlVHlwZSA9IGNvbnRleHQuZ2wuVEVYVFVSRV8yRDtcclxuXHJcbiAgICB0aGlzLnRleHR1cmVVbml0Q2FsbGJhY2sgPSB0aGlzLmxvc3RUZXh0dXJlVW5pdC5iaW5kKHRoaXMpO1xyXG59O1xyXG5cclxuWE1MM0QuY3JlYXRlQ2xhc3MoR0xUZXh0dXJlLCBTYW1wbGVyQ29uZmlnKTtcclxuXHJcbkdMVGV4dHVyZS5TdGF0ZSA9IHtcclxuICAgIE5PTkU6IFwibm9uZVwiLCBMT0FESU5HOiBcImxvYWRpbmdcIiwgUkVBRFk6IFwicmVhZHlcIiwgRVJST1I6IFwiZXJyb3JcIlxyXG59O1xyXG5cclxuXHJcbnZhciBnZXRPckNyZWF0ZUZhbGxiYWNrVGV4dHVyZSA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIGNfZmFsbGJhY2tUZXh0dXJlID0gbnVsbDtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICBpZiAoIWNfZmFsbGJhY2tUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIGNfZmFsbGJhY2tUZXh0dXJlID0gbmV3IEdMVGV4dHVyZShjb250ZXh0KTtcclxuICAgICAgICAgICAgdmFyIHNpemUgPSAxNjtcclxuICAgICAgICAgICAgdmFyIHRleGVscyA9IG5ldyBVaW50OEFycmF5KHNpemUgKiBzaXplICogMyk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4ZWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXhlbHNbaV0gPSAxMjg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY19mYWxsYmFja1RleHR1cmUuY3JlYXRlVGV4MkRGcm9tRGF0YShHTC5SR0IsIHNpemUsIHNpemUsIEdMLlJHQiwgR0wuVU5TSUdORURfQllURSwge1xyXG4gICAgICAgICAgICAgICAgdGV4ZWxzOiB0ZXhlbHMsIHdyYXBTOiBHTC5SRVBFQVQsIHdyYXBUOiBHTC5SRVBFQVQsIG1pbkZpbHRlcjogR0wuTElORUFSLCBtYWdGaWx0ZXI6IEdMLkxJTkVBUlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNfZmFsbGJhY2tUZXh0dXJlO1xyXG4gICAgfVxyXG59KCkpO1xyXG5cclxudmFyIGlzUG93ZXJPZlR3byA9IGZ1bmN0aW9uIChkaW1lbnNpb24pIHtcclxuICAgIHJldHVybiAoZGltZW5zaW9uICYgKGRpbWVuc2lvbiAtIDEpKSA9PSAwO1xyXG59O1xyXG52YXIgbmV4dEhpZ2hlc3RQb3dlck9mVHdvID0gZnVuY3Rpb24gKHgpIHtcclxuICAgIC0teDtcclxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgMzI7IGkgPDw9IDEpIHtcclxuICAgICAgICB4ID0geCB8IHggPj4gaTtcclxuICAgIH1cclxuICAgIHJldHVybiB4ICsgMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTY2FsZSB1cCB0aGUgdGV4dHVyZSB0byB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIHR3byBkaW1lbnNpb25zLlxyXG4gKiBAcmV0dXJucyB7SFRNTENhbnZhc0VsZW1lbnR9XHJcbiAqL1xyXG52YXIgc2NhbGVJbWFnZSA9IGZ1bmN0aW9uIChpbWFnZSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgY2FudmFzLndpZHRoID0gbmV4dEhpZ2hlc3RQb3dlck9mVHdvKHdpZHRoKTtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSBuZXh0SGlnaGVzdFBvd2VyT2ZUd28oaGVpZ2h0KTtcclxuXHJcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICBpZiAoaW1hZ2UgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgdG1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgICAgICB0bXBDYW52YXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0bXBDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHZhciB0bXBDb250ZXh0ID0gdG1wQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgICAgICB2YXIgaW1hZ2VEYXRhID0gdG1wQ29udGV4dC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGEuc2V0KGltYWdlLmRhdGEpO1xyXG4gICAgICAgIHRtcENvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XHJcblxyXG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHRtcENhbnZhcywgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2FudmFzO1xyXG59O1xyXG5cclxudmFyIGdsVGV4dHVyZUZvcm1hdEZyb21YZmxvdyA9IGZ1bmN0aW9uIChmb3JtYXQsIGdsKSB7XHJcbiAgICBzd2l0Y2ggKGZvcm1hdCkge1xyXG4gICAgICAgIGNhc2UgWEMuVEVYVFVSRV9GT1JNQVQuQUxQSEE6XHJcbiAgICAgICAgICAgIHJldHVybiBnbC5BTFBIQTtcclxuICAgICAgICBjYXNlIFhDLlRFWFRVUkVfRk9STUFULlJHQjpcclxuICAgICAgICAgICAgcmV0dXJuIGdsLlJHQjtcclxuICAgICAgICBjYXNlIFhDLlRFWFRVUkVfRk9STUFULlJHQkE6XHJcbiAgICAgICAgICAgIHJldHVybiBnbC5SR0JBO1xyXG4gICAgICAgIGNhc2UgWEMuVEVYVFVSRV9GT1JNQVQuTFVNSU5BTkNFOlxyXG4gICAgICAgICAgICByZXR1cm4gZ2wuTFVNSU5BTkNFO1xyXG4gICAgICAgIGNhc2UgWEMuVEVYVFVSRV9GT1JNQVQuTFVNSU5BTkNFX0FMUEhBOlxyXG4gICAgICAgICAgICByZXR1cm4gZ2wuTFVNSU5BTkNFX0FMUEhBO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIFRleHR1cmUgRm9ybWF0IVwiKTtcclxuICAgIH1cclxufTtcclxuXHJcbnZhciBnbFRleHR1cmVUeXBlRnJvbVhmbG93ID0gZnVuY3Rpb24gKHR5cGUsIGdsKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlIFhDLlRFWFRVUkVfVFlQRS5GTE9BVDpcclxuICAgICAgICAgICAgcmV0dXJuIGdsLkZMT0FUO1xyXG4gICAgICAgIGNhc2UgWEMuVEVYVFVSRV9UWVBFLlVCWVRFOlxyXG4gICAgICAgICAgICByZXR1cm4gZ2wuVU5TSUdORURfQllURTtcclxuICAgICAgICBjYXNlIFhDLlRFWFRVUkVfVFlQRS5VU0hPUlRfNF80XzRfNDpcclxuICAgICAgICAgICAgcmV0dXJuIGdsLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQ7XHJcbiAgICAgICAgY2FzZSBYQy5URVhUVVJFX1RZUEUuVVNIT1JUXzVfNV81XzE6XHJcbiAgICAgICAgICAgIHJldHVybiBnbC5VTlNJR05FRF9TSE9SVF81XzVfNV8xO1xyXG4gICAgICAgIGNhc2UgWEMuVEVYVFVSRV9UWVBFLlVTSE9SVF81XzZfNTpcclxuICAgICAgICAgICAgcmV0dXJuIGdsLkdMX1VOU0lHTkVEX1NIT1JUXzVfNl81O1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIFRleHR1cmUgVHlwZSFcIik7XHJcbiAgICB9XHJcbn07XHJcblxyXG5YTUwzRC5leHRlbmQoR0xUZXh0dXJlLnByb3RvdHlwZSwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge1hmbG93LlRleHR1cmVFbnRyeX0gdGV4dHVyZUVudHJ5XHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUZyb21UZXh0dXJlRW50cnk6IGZ1bmN0aW9uICh0ZXh0dXJlRW50cnkpIHtcclxuICAgICAgICBpZiAoIXRleHR1cmVFbnRyeS5pc0xvYWRpbmcoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldCh0ZXh0dXJlRW50cnkuZ2V0U2FtcGxlckNvbmZpZygpKTtcclxuICAgICAgICAgICAgdmFyIGltZyA9IHRleHR1cmVFbnRyeS5hc0dMVGV4dHVyZVZhbHVlKCk7XHJcbiAgICAgICAgICAgIGlmICghaW1nKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbGVkKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlT3JVcGRhdGVUZXh0dXJlKGltZyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkcygpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIC8qKlxyXG4gICAgICogV2UgbmVlZCB0byBzY2FsZSB0ZXh0dXJlIHdoZW4gb25lIG9mIHRoZSB3cmFwIG1vZGVzIGlzIG5vdCBDTEFNUF9UT19FREdFIGFuZFxyXG4gICAgICogb25lIG9mIHRoZSB0ZXh0dXJlIGRpbWVuc2lvbnMgaXMgbm90IHBvd2VyIG9mIHR3by5cclxuICAgICAqIE90aGVyd2lzZSByZW5kZXJlZCB0ZXh0dXJlIHdpbGwgYmUganVzdCBibGFjay5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIG5lZWRzU2NhbGU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmdlbmVyYXRlTWlwTWFwIHx8IHRoaXMud3JhcFMgIT0gR0wuQ0xBTVBfVE9fRURHRSB8fCB0aGlzLndyYXBUICE9IEdMLkNMQU1QX1RPX0VER0UpICYmICghaXNQb3dlck9mVHdvKHdpZHRoKSB8fCAhaXNQb3dlck9mVHdvKGhlaWdodCkpXHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICBfYmluZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcclxuICAgICAgICB2YXIgdGV4dHVyZU1hbmFnZXIgPSB0aGlzLmNvbnRleHQudGV4dHVyZU1hbmFnZXI7XHJcbiAgICAgICAgdmFyIHVuaXQgPSB0aGlzLnVuaXQgPSB0ZXh0dXJlTWFuYWdlci5iaW5kKHRoaXMuaWQsIHsgZGlzcG9zZTogdGhpcy50ZXh0dXJlVW5pdENhbGxiYWNrIH0pO1xyXG4gICAgICAgIGlmICh1bml0ID09IC0yKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiQWxsIGF2YWlsYWJsZSB0ZXh0dXJlIHVuaXRzIGFyZSBmdWxsLlwiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKEdMLlRFWFRVUkUwICsgdW5pdCk7XHJcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKHRoaXMudGV4dHVyZVR5cGUsIHRoaXMuaGFuZGxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuaXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHVuYmluZDogZnVuY3Rpb24gKHVuaXQpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nLCB0ZXh0dXJlIG1hbmFnZXIgd2lsbCBoYW5kbGUgdGhpc1xyXG4gICAgfSxcclxuXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xyXG4gICAgICAgIHZhciB0ZXh0dXJlTWFuYWdlciA9IHRoaXMuY29udGV4dC50ZXh0dXJlTWFuYWdlcjtcclxuICAgICAgICB0ZXh0dXJlTWFuYWdlci5kaXNwb3NlKHRoaXMuaWQpO1xyXG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUodGhpcy5oYW5kbGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjYW5CaW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudCA9PSBHTFRleHR1cmUuU3RhdGUuUkVBRFk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZU9yVXBkYXRlVGV4dHVyZTogZnVuY3Rpb24gKHRleGVsU291cmNlKSB7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5oYW5kbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGUgPSB0aGlzLmNvbnRleHQuZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0dXJlRnJvbURhdGEodGV4ZWxTb3VyY2UpO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVUZXh0dXJlRnJvbURhdGE6IGZ1bmN0aW9uICh0ZXhlbFNvdXJjZSkge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcclxuICAgICAgICB0aGlzLl9iaW5kKCk7XHJcblxyXG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRoaXMuZmxpcFkpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXh0dXJlVHlwZSwgZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMud3JhcFMpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXh0dXJlVHlwZSwgZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMud3JhcFQpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXh0dXJlVHlwZSwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLm1pbkZpbHRlcik7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleHR1cmVUeXBlLCBnbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMubWFnRmlsdGVyKTtcclxuXHJcbiAgICAgICAgdmFyIHR5cGUgPSBnbFRleHR1cmVUeXBlRnJvbVhmbG93KHRleGVsU291cmNlLnRleGVsVHlwZSwgZ2wpO1xyXG4gICAgICAgIHZhciBmb3JtYXQgPSBnbFRleHR1cmVGb3JtYXRGcm9tWGZsb3codGV4ZWxTb3VyY2UudGV4ZWxGb3JtYXQsIGdsKTtcclxuXHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGV4ZWxTb3VyY2Uud2lkdGg7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0ZXhlbFNvdXJjZS5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmdlbmVyYXRlTWlwTWFwICYmIHRoaXMubmVlZHNTY2FsZSh3aWR0aCwgaGVpZ2h0KSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gZ2wuRkxPQVQpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaG91bGQgZ2VuZXJhdGUgTWlwTWFwcyBidXQgdGV4dHVyZSBkYXRhIGlzIGZsb2F0IGFuZCBub3QgcG93ZXIgb2YgdHdvIGluIHNpemUhXCIpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB0ZXhlbFNvdXJjZSA9IHNjYWxlSW1hZ2UodGV4ZWxTb3VyY2UsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRleGVsU291cmNlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBmb3JtYXQsIGZvcm1hdCwgdHlwZSwgdGV4ZWxTb3VyY2UpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0ZXhlbFNvdXJjZS5kYXRhIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlYkdMIGRvZXMgbm90IHN1cHBvcnQgVWludDhDbGFtcGVkQXJyYXksIHdoaWNoIGlzIChjb3JyZWN0bHkpIHVzZWQgYnkgYXN5bmMuIFhmbG93LiBXZSBqdXN0IGJ1aWxkIGEgbmV3IHZpZXdcclxuICAgICAgICAgICAgICAgIC8vIG9uIHRvcCBvZiB0aGUgdW5kZXJseWluZyBhcnJheSBidWZmZXIgd2hpY2ggc2hvdWxkIGJlIHJlbGF0aXZlbHkgZmFzdFxyXG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGZvcm1hdCwgdHlwZSwgbmV3IFVpbnQ4QXJyYXkodGV4ZWxTb3VyY2UuZGF0YS5idWZmZXIpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBmb3JtYXQsIHR5cGUsIHRleGVsU291cmNlLmRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5nZW5lcmF0ZU1pcE1hcClcclxuICAgICAgICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAodGhpcy50ZXh0dXJlVHlwZSk7XHJcblxyXG4gICAgICAgIHRoaXMuY3JlYXRlZCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVUZXgyREZyb21EYXRhOiBmdW5jdGlvbiAoaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIHNvdXJjZUZvcm1hdCwgc291cmNlVHlwZSwgb3B0KSB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xyXG5cclxuICAgICAgICB2YXIgb3B0ID0gb3B0IHx8IHt9O1xyXG4gICAgICAgIHZhciB0ZXhlbHMgPSBvcHQudGV4ZWxzO1xyXG5cclxuICAgICAgICBpZiAoIXRleGVscykge1xyXG4gICAgICAgICAgICBpZiAoc291cmNlVHlwZSA9PSBnbC5GTE9BVCkge1xyXG4gICAgICAgICAgICAgICAgdGV4ZWxzID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGV4ZWxzID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5oYW5kbGUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICAgICAgdGhpcy5fYmluZCgpO1xyXG5cclxuICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBvcHQuZmxpcFkpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXh0dXJlVHlwZSwgZ2wuVEVYVFVSRV9XUkFQX1MsIG9wdC53cmFwUyk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleHR1cmVUeXBlLCBnbC5URVhUVVJFX1dSQVBfVCwgb3B0LndyYXBUKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGV4dHVyZVR5cGUsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgb3B0Lm1pbkZpbHRlcik7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleHR1cmVUeXBlLCBnbC5URVhUVVJFX01BR19GSUxURVIsIG9wdC5tYWdGaWx0ZXIpO1xyXG5cclxuICAgICAgICBpZiAoIW9wdC5pc0RlcHRoKSB7XHJcbiAgICAgICAgICAgIGlmICh0ZXhlbHMgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgc291cmNlRm9ybWF0LCBzb3VyY2VUeXBlLCBuZXcgVWludDhBcnJheSh0ZXhlbHMuYnVmZmVyKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBzb3VyY2VGb3JtYXQsIHNvdXJjZVR5cGUsIHRleGVscyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBzb3VyY2VGb3JtYXQsIHNvdXJjZVR5cGUsIG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdC5nZW5lcmF0ZU1pcG1hcCkge1xyXG4gICAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcCh0aGlzLnRleHR1cmVUeXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jcmVhdGVkKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGxvc3RUZXh0dXJlVW5pdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy51bml0ID0gLTE7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcblN0YXRlTWFjaGluZS5jcmVhdGUoe1xyXG4gICAgdGFyZ2V0OiBHTFRleHR1cmUucHJvdG90eXBlLFxyXG4gICAgaW5pdGlhbDogR0xUZXh0dXJlLlN0YXRlLk5PTkUsXHJcbiAgICBldmVudHM6IFt7bmFtZTogJ2NyZWF0ZWQnLCBmcm9tOiAnKicsIHRvOiBHTFRleHR1cmUuU3RhdGUuUkVBRFl9LCB7XHJcbiAgICAgICAgbmFtZTogJ2ZhaWxlZCcsIGZyb206ICcqJywgdG86IEdMVGV4dHVyZS5TdGF0ZS5FUlJPUlxyXG4gICAgfSwge25hbWU6ICdsb2FkcycsIGZyb206ICcqJywgdG86IEdMVGV4dHVyZS5TdGF0ZS5MT0FESU5HfV1cclxufSk7XHJcblxyXG4vL25vaW5zcGVjdGlvbiBKU1ZhbGlkYXRlSlNEb2NcclxuLyoqXHJcbiAqIEBwYXJhbSB7R0xDb250ZXh0fSBjb250ZXh0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIEdMQ3ViZU1hcCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICBHTFRleHR1cmUuY2FsbCh0aGlzLCBjb250ZXh0LCBjb250ZXh0LmdsLlRFWFRVUkVfQ1VCRV9NQVApO1xyXG4gICAgdmFyIGdsID0gY29udGV4dC5nbDtcclxuICAgIHRoaXMudGV4dHVyZVR5cGUgPSBjb250ZXh0LmdsLlRFWFRVUkVfQ1VCRV9NQVA7XHJcbiAgICB0aGlzLmdsU2lkZXMgPSBbZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YLCBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1gsIGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWSwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZLCBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1osIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWl07XHJcblxyXG59O1xyXG5YTUwzRC5jcmVhdGVDbGFzcyhHTEN1YmVNYXAsIEdMVGV4dHVyZSwge1xyXG4gICAgdXBkYXRlVGV4dHVyZUZyb21EYXRhOiBmdW5jdGlvbiAodGV4ZWxTb3VyY2UpIHtcclxuICAgICAgICBkZWJ1Zy5sb2coXCJ1cGRhdGVUZXh0dXJlRnJvbURhdGEgbm90IGltcGxlbWVudGVkIGZvciBDdWJlTWFwcGluZyFcIik7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVRleDJERnJvbURhdGE6IGZ1bmN0aW9uIChpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgc291cmNlRm9ybWF0LCBzb3VyY2VUeXBlLCBvcHQpIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XHJcblxyXG4gICAgICAgIHZhciBvcHQgPSBvcHQgfHwge307XHJcbiAgICAgICAgdmFyIHRleGVscyA9IG9wdC50ZXhlbHM7XHJcblxyXG4gICAgICAgIGlmICghdGV4ZWxzKSB7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2VUeXBlID09IGdsLkZMT0FUKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXhlbHMgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ZXhlbHMgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLmhhbmRsZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcclxuICAgICAgICB0aGlzLl9iaW5kKCk7XHJcblxyXG4gICAgICAgIC8vIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXh0dXJlVHlwZSwgZ2wuVEVYVFVSRV9XUkFQX1MsIG9wdC53cmFwUyk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleHR1cmVUeXBlLCBnbC5URVhUVVJFX1dSQVBfVCwgb3B0LndyYXBUKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGV4dHVyZVR5cGUsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgb3B0Lm1pbkZpbHRlcik7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleHR1cmVUeXBlLCBnbC5URVhUVVJFX01BR19GSUxURVIsIG9wdC5tYWdGaWx0ZXIpO1xyXG5cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5nbFNpZGVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICghb3B0LmlzRGVwdGgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0ZXhlbHMgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLnRleEltYWdlMkQodGhpcy5nbFNpZGVzW2ldLCAwLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgc291cmNlRm9ybWF0LCBzb3VyY2VUeXBlLCBuZXcgVWludDhBcnJheSh0ZXhlbHMuYnVmZmVyKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLnRleEltYWdlMkQodGhpcy5nbFNpZGVzW2ldLCAwLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgc291cmNlRm9ybWF0LCBzb3VyY2VUeXBlLCB0ZXhlbHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRCh0aGlzLmdsU2lkZXNbaV0sIDAsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBzb3VyY2VGb3JtYXQsIHNvdXJjZVR5cGUsIG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0LmdlbmVyYXRlTWlwbWFwKSB7XHJcbiAgICAgICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKHRoaXMudGV4dHVyZVR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNyZWF0ZWQoKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5HTEN1YmVNYXAuU3RhdGUgPSB7XHJcbiAgICBOT05FOiBcIm5vbmVcIiwgTE9BRElORzogXCJsb2FkaW5nXCIsIFJFQURZOiBcInJlYWR5XCIsIEVSUk9SOiBcImVycm9yXCJcclxufTtcclxuXHJcblN0YXRlTWFjaGluZS5jcmVhdGUoe1xyXG4gICAgdGFyZ2V0OiBHTEN1YmVNYXAucHJvdG90eXBlLFxyXG4gICAgaW5pdGlhbDogR0xDdWJlTWFwLlN0YXRlLk5PTkUsXHJcbiAgICBldmVudHM6IFt7bmFtZTogJ2NyZWF0ZWQnLCBmcm9tOiAnKicsIHRvOiBHTEN1YmVNYXAuU3RhdGUuUkVBRFl9LCB7XHJcbiAgICAgICAgbmFtZTogJ2ZhaWxlZCcsIGZyb206ICcqJywgdG86IEdMQ3ViZU1hcC5TdGF0ZS5FUlJPUlxyXG4gICAgfSwge25hbWU6ICdsb2FkcycsIGZyb206ICcqJywgdG86IEdMQ3ViZU1hcC5TdGF0ZS5MT0FESU5HfV1cclxufSk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBHTFRleHR1cmU6IEdMVGV4dHVyZSxcclxuICAgIEdMQ3ViZU1hcDogR0xDdWJlTWFwXHJcbn07XHJcblxyXG5cclxuIiwiXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdW5pZm9ybXMgZm9yIGFjdGl2ZSBwcm9ncmFtXHJcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcclxuICAgICAqIEBwYXJhbSB1XHJcbiAgICAgKiBAcGFyYW0gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHRyYW5zcG9zZWRcclxuICAgICAqL1xyXG4gICAgc2V0VW5pZm9ybTogZnVuY3Rpb24gKGdsLCB1LCB2YWx1ZSwgdHJhbnNwb3NlZCkge1xyXG5cclxuICAgICAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcclxuICAgICAgICBzd2l0Y2ggKHUuZ2xUeXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMzU2NzA6IC8vZ2wuQk9PTFxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIGEgVW5pdDhBcnJheSBpbnRvIGEgSlMgQXJyYXlcclxuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWl2KHUubG9jYXRpb24sIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbCh2YWx1ZSwgZnVuY3Rpb24odikgeyByZXR1cm4gdjsgfSkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkodS5sb2NhdGlvbiwgdmFsdWUgfHwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA1MTI0OiAgLy9nbC5JTlRcclxuICAgICAgICAgICAgY2FzZSAzNTY3ODogLy9nbC5TQU1QTEVSXzJEXHJcbiAgICAgICAgICAgIGNhc2UgMzU2ODA6IC8vZ2wuU0FNUExFUl9DVUJFXHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWl2KHUubG9jYXRpb24sIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFpKHUubG9jYXRpb24sIHZhbHVlIHx8IDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIDM1NjcxOiAvLyBnbC5CT09MX1ZFQzJcclxuICAgICAgICAgICAgY2FzZSAzNTY2NzpcclxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0yaXYodS5sb2NhdGlvbiwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIGdsLklOVF9WRUMyXHJcblxyXG4gICAgICAgICAgICBjYXNlIDM1NjcyOiAvLyBnbC5CT09MX1ZFQzNcclxuICAgICAgICAgICAgY2FzZSAzNTY2ODpcclxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0zaXYodS5sb2NhdGlvbiwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIGdsLklOVF9WRUMzXHJcblxyXG4gICAgICAgICAgICBjYXNlIDM1NjczOiAvLyBnbC5CT09MX1ZFQzRcclxuICAgICAgICAgICAgY2FzZSAzNTY2OTpcclxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm00aXYodS5sb2NhdGlvbiwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIGdsLklOVF9WRUM0XHJcblxyXG4gICAgICAgICAgICBjYXNlIDUxMjY6XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFmdih1LmxvY2F0aW9uLCB2YWx1ZSk7IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYodS5sb2NhdGlvbiwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIGdsLkZMT0FUXHJcbiAgICAgICAgICAgIGNhc2UgMzU2NjQ6XHJcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMmZ2KHUubG9jYXRpb24sIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBnbC5GTE9BVF9WRUMyXHJcbiAgICAgICAgICAgIGNhc2UgMzU2NjU6XHJcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2Z2KHUubG9jYXRpb24sIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBnbC5GTE9BVF9WRUMzXHJcbiAgICAgICAgICAgIGNhc2UgMzU2NjY6XHJcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtNGZ2KHUubG9jYXRpb24sIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBnbC5GTE9BVF9WRUM0XHJcblxyXG4gICAgICAgICAgICBjYXNlIDM1Njc0OlxyXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDJmdih1LmxvY2F0aW9uLCB0cmFuc3Bvc2VkIHx8IGZhbHNlLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhazsvLyBnbC5GTE9BVF9NQVQyXHJcbiAgICAgICAgICAgIGNhc2UgMzU2NzU6XHJcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHUubG9jYXRpb24sIHRyYW5zcG9zZWQgfHwgZmFsc2UsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrOy8vIGdsLkZMT0FUX01BVDNcclxuICAgICAgICAgICAgY2FzZSAzNTY3NjpcclxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodS5sb2NhdGlvbiwgdHJhbnNwb3NlZCB8fCBmYWxzZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7Ly8gZ2wuRkxPQVRfTUFUNFxyXG5cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiVW5rbm93biB1bmlmb3JtIHR5cGUgXCIgKyB1LmdsVHlwZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFVuaXF1ZUNvdW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY19jb3VudGVyID0gMDtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY19jb3VudGVyKys7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjaGVja0Vycm9yOiBmdW5jdGlvbiAoZ2wsIHRleHQpIHtcclxuICAgICAgICB2YXIgZXJyb3IgPSBnbC5nZXRFcnJvcigpO1xyXG4gICAgICAgIGlmIChlcnJvciAhPT0gZ2wuTk9fRVJST1IpIHtcclxuICAgICAgICAgICAgdmFyIHRleHRFcnIgPSBcIlwiICsgZXJyb3I7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTI4MDpcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0RXJyID0gXCIxMjgwICggR0xfSU5WQUxJRF9FTlVNIClcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTI4MTpcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0RXJyID0gXCIxMjgxICggR0xfSU5WQUxJRF9WQUxVRSApXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEyODI6XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEVyciA9IFwiMTI4MiAoIEdMX0lOVkFMSURfT1BFUkFUSU9OIClcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTI4MzpcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0RXJyID0gXCIxMjgzICggR0xfU1RBQ0tfT1ZFUkZMT1cgKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxMjg0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRFcnIgPSBcIjEyODQgKCBHTF9TVEFDS19VTkRFUkZMT1cgKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxMjg1OlxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRFcnIgPSBcIjEyODUgKCBHTF9PVVRfT0ZfTUVNT1JZIClcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbXNnID0gXCJHTCBlcnJvciBcIiArIHRleHRFcnIgKyBcIiBvY2N1cmVkLlwiO1xyXG4gICAgICAgICAgICBpZiAodGV4dCAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgbXNnICs9IFwiIFwiICsgdGV4dDtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcudHJhY2UobXNnKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHN1cHBvcnRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhISh3aW5kb3cuV2ViR0xSZW5kZXJpbmdDb250ZXh0ICYmIChjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJykpKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuIiwidmFyIEFic3RyYWN0Q2FudmFzSGFuZGxlciA9IHJlcXVpcmUoXCIuLi9yZW5kZXJlci9jYW52YXMtaGFuZGxlci5qc1wiKTtcclxudmFyIE9wdGlvbnMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvb3B0aW9ucy5qc1wiKTtcclxudmFyIFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvbWlzYy5qc1wiKTtcclxuXHJcbnZhciBNQVhGUFMgPSAzMDtcclxuXHJcbnZhciBPUFRJT05fQ09OVElOVU9VUyA9IFwicmVuZGVyZXItY29udGludW91c1wiO1xyXG5PcHRpb25zLnJlZ2lzdGVyKE9QVElPTl9DT05USU5VT1VTLCBmYWxzZSk7XHJcblxyXG4vKipcclxuICogR0xDYW52YXNIYW5kbGVyIGNsYXNzLlxyXG4gKiBSZWdpc3RlcnMgYW5kIGhhbmRsZXMgdGhlIGV2ZW50cyB0aGF0IGhhcHBlbiBvbiB0aGUgY2FudmFzIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB4bWwzZEVsZW1cclxuICogICAgICAgICAgICB0aGUgcm9vdCB4bWwzZCBub2RlLCBjb250YWluaW5nIHRoZSBYTUwzRCBzY2VuZSBzdHJ1Y3R1cmVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0Q2FudmFzSGFuZGxlclxyXG4gKi9cclxuZnVuY3Rpb24gR0xDYW52YXNIYW5kbGVyKHhtbDNkRWxlbSwgY2FudmFzKSB7XHJcbiAgICBBYnN0cmFjdENhbnZhc0hhbmRsZXIuY2FsbCh0aGlzLCB4bWwzZEVsZW0sIGNhbnZhcyk7XHJcbiAgICB0aGlzLnJlbmRlckludGVyZmFjZSA9IHt9O1xyXG5cclxuICAgIHRoaXMubGFzdFBpY2tPYmogPSBudWxsO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemVkIGxhdGVyXHJcbiAgICB0aGlzLmxhc3RLbm93bkRpbWVuc2lvbnMgPSB7d2lkdGg6IDAsIGhlaWdodDogMH07XHJcblxyXG4gICAgdGhpcy5pbml0aWFsaXplKCk7XHJcbn1cclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKEdMQ2FudmFzSGFuZGxlciwgQWJzdHJhY3RDYW52YXNIYW5kbGVyKTtcclxuXHJcbkdMQ2FudmFzSGFuZGxlci5wcm90b3R5cGUuc2V0UmVuZGVyZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIpIHtcclxuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcclxufTtcclxuXHJcbkdMQ2FudmFzSGFuZGxlci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICB0aGlzLmNvbmZpZ3VyZUNhbnZhcygpO1xyXG5cclxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGF0IHJlZ3VsYXIgaW50ZXJ2YWxzIGJ5IHJlcXVlc3RBbmltYXRpb25GcmFtZSB0b1xyXG4gICAgLy8gZGV0ZXJtaW5lIGlmIGEgcmVkcmF3XHJcbiAgICAvLyBpcyBuZWVkZWRcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHRoaXMudGljayA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgaWYoIXRoYXQucmVuZGVyZXIpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgWE1MM0QudXBkYXRlWGZsb3dPYnNlcnZlcigpO1xyXG4gICAgICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG5cclxuICAgICAgICBpZiAodGhhdC5jYW52YXNTaXplQ2hhbmdlZCgpIHx8IHRoYXQucmVuZGVyZXIubmVlZHNSZWRyYXcoKSB8fCBPcHRpb25zLmdldFZhbHVlKE9QVElPTl9DT05USU5VT1VTKSkge1xyXG4gICAgICAgICAgICB0aGF0LmRyYXcoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhhdC50aWNrLCBNQVhGUFMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAgIC8vIEJsb2NrIHRoZSByaWdodC1jbGljayBjb250ZXh0IG1lbnUgb24gdGhlIGNhbnZhcyB1bmxlc3MgaXQncyBleHBsaWNpdGx5IHRvZ2dsZWRcclxuICAgIHZhciBjbSA9IHRoaXMuX3htbDNkRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjb250ZXh0bWVudVwiKTtcclxuICAgIGlmICghY20gfHwgY20gPT0gXCJmYWxzZVwiKSB7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ICYmIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24gJiYgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9LCBmYWxzZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5HTENhbnZhc0hhbmRsZXIucHJvdG90eXBlLmNvbmZpZ3VyZUNhbnZhcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB4bWwzZEVsZW1lbnQgPSB0aGlzLl94bWwzZEVsZW1lbnQ7XHJcbiAgICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzO1xyXG5cclxuICAgIHZhciBwYXJlbnQgPSB4bWwzZEVsZW1lbnQucGFyZW50Tm9kZTtcclxuICAgIGlmICghVXRpbC5lbGVtZW50SXMocGFyZW50LCBcImRpdlwiKSB8fCBwYXJlbnQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgIT09IFwiX3htbDNkX2hpZGVEaXZcIikge1xyXG4gICAgICAgIC8vIFBsYWNlIHhtbDNkRWxlbWVudCBpbnNpZGUgYW4gaW52aXNibGUgZGl2XHJcbiAgICAgICAgdmFyIGhpZGVEaXYgPSBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBoaWRlRGl2LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiX3htbDNkX2hpZGVEaXZcIik7XHJcbiAgICAgICAgLy9oaWRlRGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGhpZGVEaXYsIHhtbDNkRWxlbWVudCk7XHJcbiAgICAgICAgaGlkZURpdi5hcHBlbmRDaGlsZCh4bWwzZEVsZW1lbnQpO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgY2FudmFzIGFuZCBhcHBlbmQgaXQgd2hlcmUgdGhlIHhtbDNkIGVsZW1lbnQgd2FzIGJlZm9yZVxyXG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2FudmFzLCBoaWRlRGl2KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gVGhlIGludmlzaWJsZSBkaXYgYWxyZWFkeSBleGlzdHMgKHByb2JhYmx5IGZyb20gYW4gZWFybGllciBjb25maWd1cmF0aW9uKVxyXG4gICAgICAgIHBhcmVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjYW52YXMsIHBhcmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHN0eWxlID0gY2FudmFzLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh4bWwzZEVsZW1lbnQpO1xyXG4gICAgaWYgKCFjYW52YXMuc3R5bGUuYmFja2dyb3VuZENvbG9yKSB7XHJcbiAgICAgICAgdmFyIGJnY29sb3IgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiYmFja2dyb3VuZC1jb2xvclwiKTtcclxuICAgICAgICBpZiAoYmdjb2xvciAmJiBiZ2NvbG9yICE9IFwidHJhbnNwYXJlbnRcIilcclxuICAgICAgICAgICAgY2FudmFzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGJnY29sb3I7XHJcbiAgICB9XHJcbiAgICAvLyBOZWVkIHRvIGJlIHNldCBmb3IgY29ycmVjdCBjYW52YXMgc2l6ZVxyXG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XHJcbiAgICB0aGlzLmxhc3RLbm93bkRpbWVuc2lvbnMgPSB7d2lkdGg6IGNhbnZhcy53aWR0aCwgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0fTtcclxuICAgIHJldHVybiBjYW52YXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQmluZHMgdGhlIHBpY2tpbmcgYnVmZmVyIGFuZCBwYXNzZXMgdGhlIHJlcXVlc3QgZm9yIGEgcGlja2luZyBwYXNzIHRvIHRoZVxyXG4gKiByZW5kZXJlclxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gY2FudmFzWFxyXG4gKiBAcGFyYW0ge251bWJlcn0gY2FudmFzWVxyXG4gKiBAcmV0dXJuIHtEcmF3YWJsZXxudWxsfSBuZXdseSBwaWNrZWQgb2JqZWN0XHJcbiAqL1xyXG5HTENhbnZhc0hhbmRsZXIucHJvdG90eXBlLmdldFBpY2tPYmplY3RCeVBvaW50ID0gZnVuY3Rpb24gKGNhbnZhc1gsIGNhbnZhc1kpIHtcclxuICAgIC8vIFRPRE9cclxuICAgIC8vaWYgKCF0aGlzLnJlbmRlck9wdGlvbnMucGlja2luZ0VuYWJsZWQpXHJcbiAgICAvLyAgICByZXR1cm4gbnVsbDtcclxuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldFJlbmRlck9iamVjdEZyb21QaWNraW5nQnVmZmVyKGNhbnZhc1gsIGNhbnZhc1kpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cclxuICovXHJcbkdMQ2FudmFzSGFuZGxlci5wcm90b3R5cGUuZ2V0UGlja2VkT2JqZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5waWNrZWRPYmplY3QgPyB0aGlzLnJlbmRlcmVyLnBpY2tlZE9iamVjdC5ub2RlIDogbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gY2FudmFzWFxyXG4gKiBAcGFyYW0ge251bWJlcn0gY2FudmFzWVxyXG4gKiBAcmV0dXJuIHt2ZWMzfG51bGx9IFRoZSB3b3JsZCBzcGFjZSBub3JtYWwgb24gdGhlIG9iamVjdCdzIHN1cmZhY2UgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGVzXHJcbiAqL1xyXG5HTENhbnZhc0hhbmRsZXIucHJvdG90eXBlLmdldFdvcmxkU3BhY2VOb3JtYWxCeVBvaW50ID0gZnVuY3Rpb24gKGNhbnZhc1gsIGNhbnZhc1kpIHtcclxuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldFdvcmxkU3BhY2VOb3JtYWxCeVBvaW50KGNhbnZhc1gsIGNhbnZhc1kpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjYW52YXNYXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjYW52YXNZXHJcbiAqIEByZXR1cm4ge3ZlYzN8bnVsbH0gVGhlIHdvcmxkIHNwYWNlIHBvc2l0aW9uIG9uIHRoZSBvYmplY3QncyBzdXJmYWNlIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlc1xyXG4gKi9cclxuR0xDYW52YXNIYW5kbGVyLnByb3RvdHlwZS5nZXRXb3JsZFNwYWNlUG9zaXRpb25CeVBvaW50ID0gZnVuY3Rpb24gKGNhbnZhc1gsIGNhbnZhc1kpIHtcclxuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldFdvcmxkU3BhY2VQb3NpdGlvbkJ5UG9pbnQoY2FudmFzWCwgY2FudmFzWSk7XHJcbn07XHJcblxyXG5HTENhbnZhc0hhbmRsZXIucHJvdG90eXBlLmNhbnZhc1NpemVDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcclxuICAgIGlmIChjYW52YXMuY2xpZW50V2lkdGggIT09IHRoaXMubGFzdEtub3duRGltZW5zaW9ucy53aWR0aCB8fCBjYW52YXMuY2xpZW50SGVpZ2h0ICE9PSB0aGlzLmxhc3RLbm93bkRpbWVuc2lvbnMuaGVpZ2h0KSB7XHJcblxyXG4gICAgICAgIHRoaXMubGFzdEtub3duRGltZW5zaW9ucy53aWR0aCA9IGNhbnZhcy53aWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aDtcclxuICAgICAgICB0aGlzLmxhc3RLbm93bkRpbWVuc2lvbnMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5oYW5kbGVSZXNpemVFdmVudChjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hSZXNpemVFdmVudCh7d2lkdGg6IGNhbnZhcy53aWR0aCwgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0fSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG52YXIgY190aW1lciA9IHdpbmRvdy5wZXJmb3JtYW5jZSB8fCBEYXRlO1xyXG5cclxuLyoqXHJcbiAqIENhbGxlZCBieSB0aWNrKCkgdG8gcmVkcmF3IHRoZSBzY2VuZSBpZiBuZWVkZWRcclxuICovXHJcbkdMQ2FudmFzSGFuZGxlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgc3RhcnQgPSBjX3RpbWVyLm5vdygpO1xyXG4gICAgICAgIHZhciBzdGF0cyA9IHRoaXMucmVuZGVyZXIucmVuZGVyVG9DYW52YXMoKTtcclxuICAgICAgICB2YXIgZW5kID0gY190aW1lci5ub3coKTtcclxuXHJcblxyXG4gICAgICAgIHZhciBmYWN0b3J5ID0gWE1MM0QueG1sM2RGb3JtYXRIYW5kbGVyLmdldEZhY3RvcnkoXCJzY2VuZVwiLCB0aGlzLmlkKTtcclxuICAgICAgICB2YXIgeG1sM2RBZGFwdGVyID0gZmFjdG9yeS5nZXRBZGFwdGVyKHRoaXMuX3htbDNkRWxlbWVudCk7XHJcbiAgICAgICAgeG1sM2RBZGFwdGVyLm9uRnJhbWVEcmF3bigpO1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hGcmFtZURyYXduRXZlbnQoc3RhcnQsIGVuZCwgc3RhdHMpO1xyXG5cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgLy8gQXZvaWQgZW5kbGVzcyByZW5kZXJpbmcgZHVlIHRvIGVycm9yLiBXaXRob3V0IGEgY2hhbmdlLCB0aGUgcmVuZGVyZXIgd2lsbCBub3QgZ2V0IGJhY2sgaW50byBub3JtYWwgb3BlcmF0aW9uXHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5uZWVkc0RyYXcgPSBmYWxzZTtcclxuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFeGNlcHRpb24oZSk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuR0xDYW52YXNIYW5kbGVyLnByb3RvdHlwZS5nZXRNb3VzZVBvc2l0aW9uID0gZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgdmFyIHJjdCA9IHRoaXMuX2NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogKGV2dC5jbGllbnRYIC0gcmN0LmxlZnQpLCB5OiAoZXZ0LmNsaWVudFkgLSByY3QudG9wKVxyXG4gICAgfTtcclxufTtcclxuXHJcbkdMQ2FudmFzSGFuZGxlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5yZW5kZXJlci5kaXNwb3NlKCk7XHJcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gIEdMQ2FudmFzSGFuZGxlcjtcclxuXHJcbiIsIi8vIDAxLjEwLjIwMTU6IFdvcmthcm91bmQgZm9yIFNhZmFyaSBidWcgb24gaU9TIDkgKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDg0NDkpXHJcbm1vZHVsZS5leHBvcnRzID0gV2ViR0xSZW5kZXJpbmdDb250ZXh0Lk9ORSA/IFdlYkdMUmVuZGVyaW5nQ29udGV4dCA6IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5wcm90b3R5cGU7XHJcbiIsInZhciBHTFByb2dyYW1PYmplY3QgPSByZXF1aXJlKFwiLi4vYmFzZS9wcm9ncmFtLmpzXCIpO1xyXG52YXIgWGZsb3dVdGlscz0gcmVxdWlyZShcIi4uL3hmbG93L3V0aWxzLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIEEgU2hhZGVyQ2xvc3VyZSBjb25uZWN0cyBhIG1lc2gtc3BlY2lmaWMgR0xQcm9ncmFtIHdpdGggaXQncyBYZmxvdyBkYXRhXHJcbiAqIEBwYXJhbSB7R0xDb250ZXh0fSBjb250ZXh0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIEFic3RyYWN0U2hhZGVyQ2xvc3VyZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7R0xQcm9ncmFtT2JqZWN0fG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XHJcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZsYWcgdXNlZCBieSBzaGFkZXJjb21wb3NlciB0byBzb3J0IG91dCBvYnNvbGV0ZSBzaGFkZXJjbG9zdXJlc1xyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMub2Jzb2xldGUgPSBmYWxzZTtcclxuICAgIHRoaXMuaWQgPSBcIlwiO1xyXG5cclxuICAgIHRoaXMudW5pZm9ybUNvbGxlY3Rpb24gPSB7XHJcbiAgICAgICAgZW52QmFzZToge30sIGVudk92ZXJyaWRlOiBudWxsLCBzeXNCYXNlOiBudWxsXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcmVzLCBpZiB0aGUgdW5kZXJseWluZyBzaGFkZXIgaGFzIHNlbWktdHJhbnNwYXJlbmNpZXNcclxuICAgICAqIGFuZCB0aHVzIG5lZWRzIHRvIGNvbnNpZGVyZWQgZm9yIGFscGhhLWJsZW5kaW5nXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pc1RyYW5zcGFyZW50ID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc291cmNlIG9mIGEgc2hhZGVyXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge3t2ZXJ0ZXg6IHN0cmluZywgZnJhZ21lbnQ6IHN0cmluZ319XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc291cmNlID0ge1xyXG4gICAgICAgIHZlcnRleDogXCJcIiwgZnJhZ21lbnQ6IFwiXCJcclxuICAgIH1cclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEFic3RyYWN0U2hhZGVyQ2xvc3VyZS5wcm90b3R5cGUsIHtcclxuICAgICAgICBhdHRyaWJ1dGVzOiB7XHJcbiAgICAgICAgICAgIHdyaXRlYWJsZTogZmFsc2UsIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvZ3JhbSA/IHRoaXMucHJvZ3JhbS5hdHRyaWJ1dGVzIDoge31cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHVuaWZvcm1zOiB7XHJcbiAgICAgICAgICAgIHdyaXRlYWJsZTogZmFsc2UsIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvZ3JhbSA/IHRoaXMucHJvZ3JhbS51bmlmb3JtcyA6IHt9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBzYW1wbGVyczoge1xyXG4gICAgICAgICAgICB3cml0ZWFibGU6IGZhbHNlLCBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2dyYW0gPyB0aGlzLnByb2dyYW0uc2FtcGxlcnMgOiB7fVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblhNTDNELmNyZWF0ZUNsYXNzKEFic3RyYWN0U2hhZGVyQ2xvc3VyZSwgbnVsbCwge1xyXG5cclxuICAgIGVxdWFsczogZnVuY3Rpb24gKHRoYXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UudmVydGV4ID09PSB0aGF0LnNvdXJjZS52ZXJ0ZXggJiYgdGhpcy5zb3VyY2UuZnJhZ21lbnQgPT09IHRoYXQuc291cmNlLmZyYWdtZW50O1xyXG4gICAgfSxcclxuXHJcbiAgICBoYXNUcmFuc3BhcmVuY3k6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc1RyYW5zcGFyZW50O1xyXG4gICAgfSxcclxuXHJcbiAgICBjb21waWxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZS5mcmFnbWVudCB8fCAhdGhpcy5zb3VyY2UudmVydGV4KSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiTm8gc291cmNlIGZvdW5kIGZvciBtYXRlcmlhbFwiLCB0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHByb2dyYW1PYmplY3QgPSBuZXcgR0xQcm9ncmFtT2JqZWN0KHRoaXMuY29udGV4dC5nbCwgdGhpcy5zb3VyY2UpO1xyXG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW1PYmplY3Q7XHJcbiAgICAgICAgdGhpcy5pZCA9IHByb2dyYW1PYmplY3QuaWQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGJpbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnByb2dyYW0uYmluZCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnByb2dyYW0udW5iaW5kKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcm9ncmFtLmlzVmFsaWQoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge1hmbG93LkNvbXB1dGVSZXN1bHR9IHhmbG93UmVzdWx0XHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZVVuaWZvcm1zRnJvbUNvbXB1dGVSZXN1bHQ6IGZ1bmN0aW9uICh4Zmxvd1Jlc3VsdCkge1xyXG4gICAgICAgIHZhciBtYXAgPSB4Zmxvd1Jlc3VsdC5nZXRPdXRwdXRNYXAoKTtcclxuXHJcbiAgICAgICAgdmFyIGVudkJhc2UgPSB0aGlzLnVuaWZvcm1Db2xsZWN0aW9uLmVudkJhc2UgPSB7fTtcclxuICAgICAgICB0aGlzLnNldERlZmF1bHRVbmlmb3Jtcyh0aGlzLnVuaWZvcm1Db2xsZWN0aW9uLmVudkJhc2UpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIG1hcCkge1xyXG4gICAgICAgICAgICBlbnZCYXNlW25hbWVdID0gWGZsb3dVdGlscy5nZXRHTFVuaWZvcm1WYWx1ZUZyb21YZmxvd0RhdGFFbnRyeShtYXBbbmFtZV0sIHRoaXMuY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKGVudkJhc2UpO1xyXG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybVZhcmlhYmxlcyhuYW1lcywgbnVsbCwgdGhpcy51bmlmb3JtQ29sbGVjdGlvbik7XHJcblxyXG4gICAgICAgIHRoaXMuaXNUcmFuc3BhcmVudCA9IHRoaXMuZ2V0VHJhbnNwYXJlbmN5RnJvbUlucHV0RGF0YShtYXApO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRVbmlmb3JtVmFyaWFibGVzOiBmdW5jdGlvbiAoZW52TmFtZXMsIHN5c05hbWVzLCB1bmlmb3JtQ29sbGVjdGlvbikge1xyXG4gICAgICAgIHRoaXMucHJvZ3JhbS5zZXRVbmlmb3JtVmFyaWFibGVzKGVudk5hbWVzLCBzeXNOYW1lcywgdW5pZm9ybUNvbGxlY3Rpb24pO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTeXN0ZW1Vbmlmb3JtVmFyaWFibGVzOiBmdW5jdGlvbiAoc3lzTmFtZXMsIHN5c1ZhbHVlcykge1xyXG4gICAgICAgIHRoaXMudW5pZm9ybUNvbGxlY3Rpb24uc3lzQmFzZSA9IHN5c1ZhbHVlcztcclxuICAgICAgICB0aGlzLnNldFVuaWZvcm1WYXJpYWJsZXMobnVsbCwgc3lzTmFtZXMsIHRoaXMudW5pZm9ybUNvbGxlY3Rpb24pO1xyXG4gICAgfSxcclxuXHJcbiAgICBjaGFuZ2VVbmlmb3JtVmFyaWFibGVPdmVycmlkZTogZnVuY3Rpb24gKHByZXZPdmVycmlkZSwgbmV3T3ZlcnJpZGUpIHtcclxuICAgICAgICB2YXIgb3ZlcnJpZGVOYW1lcyA9IHByZXZPdmVycmlkZSA/IE9iamVjdC5rZXlzKHByZXZPdmVycmlkZSkgOiBbXTtcclxuICAgICAgICBpZiAobmV3T3ZlcnJpZGUpIG92ZXJyaWRlTmFtZXMucHVzaC5hcHBseShvdmVycmlkZU5hbWVzLCBPYmplY3Qua2V5cyhuZXdPdmVycmlkZSkpO1xyXG4gICAgICAgIHRoaXMudW5pZm9ybUNvbGxlY3Rpb24uZW52T3ZlcnJpZGUgPSBuZXdPdmVycmlkZTtcclxuICAgICAgICB0aGlzLnNldFVuaWZvcm1WYXJpYWJsZXMob3ZlcnJpZGVOYW1lcywgbnVsbCwgdGhpcy51bmlmb3JtQ29sbGVjdGlvbik7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdFNoYWRlckNsb3N1cmU7XHJcblxyXG4iLCJ2YXIgR0xTY2VuZSA9IHJlcXVpcmUoXCIuLi9zY2VuZS9nbHNjZW5lLmpzXCIpO1xyXG52YXIgR0xMaWdodHMgPSByZXF1aXJlKFwiLi4vc2NlbmUvZ2xsaWdodHMuanNcIik7XHJcbnZhciBNYXRlcmlhbEV2ZW50cyA9IHJlcXVpcmUoXCIuLi9tYXRlcmlhbHMvZXZlbnRzLmpzXCIpO1xyXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcImV2ZW50c1wiKS5FdmVudEVtaXR0ZXI7XHJcbnZhciBDb21wdXRlUmVxdWVzdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvcmVxdWVzdC5qc1wiKS5Db21wdXRlUmVxdWVzdDtcclxudmFyIFhDID0gcmVxdWlyZShcIi4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XHJcblxyXG4vKipcclxuICogQGludGVyZmFjZVxyXG4gKi9cclxudmFyIElTaGFkZXJDb21wb3NlciA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAZW51bVxyXG4gKi9cclxuSVNoYWRlckNvbXBvc2VyLlVwZGF0ZVN0YXRlID0ge1xyXG4gICAgU0hBREVSX1VQREFURUQ6IDEsIFNIQURFUl9DT01QSUxFRDogMiwgU0hBREVSX1VOQ0hBTkdFRDogM1xyXG59O1xyXG5cclxuSVNoYWRlckNvbXBvc2VyLlN0YXRlID0ge1xyXG4gICAgT0s6IDEsIE5PX1NDUklQVDogMiwgTk9fUFJPR1JBTTogM1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7c2NlbmV9IHNjZW5lXHJcbiAqIEBwYXJhbSB7e309fSBvcHRcclxuICovXHJcbklTaGFkZXJDb21wb3Nlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHNjZW5lLCBvcHQpIHtcclxufTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBYnN0cmFjdFNoYWRlckNsb3N1cmV8bnVsbFxyXG4gKi9cclxuSVNoYWRlckNvbXBvc2VyLnByb3RvdHlwZS5nZXRTaGFkZXJDbG9zdXJlID0gZnVuY3Rpb24gKHNjZW5lKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59XHJcbiAqL1xyXG5JU2hhZGVyQ29tcG9zZXIucHJvdG90eXBlLmdldFJlcXVlc3RGaWVsZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gW107XHJcbn07XHJcblxyXG4vKipcclxuICogQHJldHVybnMge3t9fVxyXG4gKi9cclxuSVNoYWRlckNvbXBvc2VyLnByb3RvdHlwZS5nZXRTaGFkZXJBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHt9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcclxuICovXHJcbnZhciBBYnN0cmFjdFNoYWRlckNvbXBvc2VyID0gZnVuY3Rpb24gKGNvbnRleHQsIHNoYWRlckluZm8pIHtcclxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xyXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgIHRoaXMuc2hhZGVyQ2xvc3VyZXMgPSBbXTtcclxuICAgIHRoaXMuZGF0YUNoYW5nZWQgPSBmYWxzZTtcclxuICAgIHRoaXMudXBkYXRlTGlnaHRWYWx1ZXMgPSBmYWxzZTtcclxuICAgIHRoaXMucmVxdWVzdCA9IG51bGw7XHJcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygwKTtcclxufTtcclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKEFic3RyYWN0U2hhZGVyQ29tcG9zZXIsIEV2ZW50RW1pdHRlciwge1xyXG5cclxuICAgIC8vIEltcGxlbWVudGVkIGJ5IHN1YmNsYXNzXHJcbiAgICBzZXRTaGFkZXJJbmZvOiBudWxsLFxyXG5cclxuXHJcbiAgICB1cGRhdGVSZXF1ZXN0OiBmdW5jdGlvbiAoeGZsb3dEYXRhTm9kZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3QpIHRoaXMucmVxdWVzdC5jbGVhcigpO1xyXG5cclxuICAgICAgICB0aGlzLnJlcXVlc3QgPSBuZXcgQ29tcHV0ZVJlcXVlc3QoeGZsb3dEYXRhTm9kZSwgdGhpcy5nZXRSZXF1ZXN0RmllbGRzKCksIHRoaXMub25TaGFkZXJSZXF1ZXN0Q2hhbmdlLmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMuc2V0U2hhZGVyUmVjb21waWxlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uU2hhZGVySW5mb0NoYW5nZWQ6IGZ1bmN0aW9uIChzaGFkZXJJbmZvKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTaGFkZXJJbmZvKHNoYWRlckluZm8pO1xyXG4gICAgICAgIHRoaXMuc2V0U2hhZGVyUmVjb21waWxlKCk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlcXVlc3RSZWRyYXcoXCJNYXRlcmlhbCBtb2RlbCBjaGFuZ2VkXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvblNoYWRlclJlcXVlc3RDaGFuZ2U6IGZ1bmN0aW9uIChyZXF1ZXN0LCBjaGFuZ2VUeXBlKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKGNoYW5nZVR5cGUgPT0gWEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKVxyXG4gICAgICAgICAgICB0aGlzLnNldFNoYWRlclJlY29tcGlsZSgpO1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5yZXF1ZXN0UmVkcmF3KFwiTWF0ZXJpYWwgZGF0YSBjaGFuZ2VkXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lXHJcbiAgICAgKiBAcGFyYW0ge3t9PX0gb3B0XHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHNjZW5lLCBvcHQpIHtcclxuICAgICAgICBvcHQgPSBvcHQgfHwge307XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgICAgICAvLyBDbGVhbiB1cCBzaGFkZXJDbG9zdXJlcyB0aGF0IGFyZSBub3QgdXNlZCFcclxuICAgICAgICB2YXIgaSA9IHRoaXMuc2hhZGVyQ2xvc3VyZXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2hhZGVyQ2xvc3VyZXNbaV0ub2Jzb2xldGUpIHRoaXMuc2hhZGVyQ2xvc3VyZXMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLnNoYWRlckNsb3N1cmVzLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kYXRhQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5nZXRTaGFkZXJEYXRhUmVzdWx0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyQ2xvc3VyZXMuZm9yRWFjaChmdW5jdGlvbiAoc2hhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZUNsb3N1cmVGcm9tQ29tcHV0ZVJlc3VsdChzaGFkZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy51cGRhdGVMaWdodFZhbHVlcykge1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRlckNsb3N1cmVzLmZvckVhY2goZnVuY3Rpb24gKHNoYWRlcikge1xyXG4gICAgICAgICAgICAgICAgdGhhdC51cGRhdGVDbG9zdXJlRnJvbUxpZ2h0UGFyYW1ldGVycyhzaGFkZXIsIHNjZW5lKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7QWJzdHJhY3RTaGFkZXJDbG9zdXJlfSBzaGFkZXJDbG9zdXJlXHJcbiAgICAgKiBAcGFyYW0ge1hmbG93LkNvbXB1dGVSZXN1bHR9IHJlc3VsdFxyXG4gICAgICovXHJcbiAgICB1cGRhdGVDbG9zdXJlRnJvbUNvbXB1dGVSZXN1bHQ6IGZ1bmN0aW9uIChzaGFkZXJDbG9zdXJlLCByZXN1bHQpIHtcclxuICAgICAgICBpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LmdldE91dHB1dE1hcCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNoYWRlckNsb3N1cmUuYmluZCgpO1xyXG4gICAgICAgIHNoYWRlckNsb3N1cmUudXBkYXRlVW5pZm9ybXNGcm9tQ29tcHV0ZVJlc3VsdChyZXN1bHQpO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVDbG9zdXJlRnJvbUxpZ2h0UGFyYW1ldGVyczogZnVuY3Rpb24gKHNoYWRlckNsb3N1cmUsIHNjZW5lKSB7XHJcbiAgICAgICAgc2hhZGVyQ2xvc3VyZS5iaW5kKCk7XHJcbiAgICAgICAgc2hhZGVyQ2xvc3VyZS5zZXRTeXN0ZW1Vbmlmb3JtVmFyaWFibGVzKEdMTGlnaHRzLkFMTF9QQVJBTUVURVJTLCBzY2VuZS5zeXN0ZW1Vbmlmb3Jtcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVN5c3RlbVVuaWZvcm1zOiBmdW5jdGlvbiAobmFtZXMsIHNjZW5lKSB7XHJcbiAgICAgICAgdGhpcy5zaGFkZXJDbG9zdXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChzaGFkZXIpIHtcclxuICAgICAgICAgICAgc2hhZGVyLmJpbmQoKTtcclxuICAgICAgICAgICAgc2hhZGVyLnNldFN5c3RlbVVuaWZvcm1WYXJpYWJsZXMobmFtZXMsIHNjZW5lLnN5c3RlbVVuaWZvcm1zKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG5cclxuICAgIGNyZWF0ZVNoYWRlckNsb3N1cmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYnN0cmFjdENvbXBvc2VyOjpjcmVhdGVTaGFkZXJDbG9zdXJlIG5lZWRzIHRvIGJlIG92ZXJyaWRkZW5cIik7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZU9iamVjdERhdGFSZXF1ZXN0OiBmdW5jdGlvbiAob2JqZWN0RGF0YU5vZGUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWJzdHJhY3RDb21wb3Nlcjo6Y3JlYXRlT2JqZWN0RGF0YVJlcXVlc3QgbmVlZHMgdG8gYmUgb3ZlcnJpZGRlblwiKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGlzdHJpYnV0ZU9iamVjdFNoYWRlckRhdGE6IGZ1bmN0aW9uIChvYmplY3RSZXF1ZXN0LCBhdHRyaWJ1dGVDYWxsYmFjaywgdW5pZm9ybUNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWJzdHJhY3RDb21wb3Nlcjo6ZGlzdHJpYnV0ZU9iamVjdFNoYWRlckRhdGEgbmVlZHMgdG8gYmUgb3ZlcnJpZGRlblwiKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0U2hhZGVyQ2xvc3VyZTogZnVuY3Rpb24gKHNjZW5lLCB2c1JlcXVlc3QpIHtcclxuICAgICAgICB2YXIgc2hhZGVyID0gdGhpcy5jcmVhdGVTaGFkZXJDbG9zdXJlKCk7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHNoYWRlci5jcmVhdGVTb3VyY2VzKHNjZW5lLCB0aGlzLmdldFNoYWRlckRhdGFSZXN1bHQoKSwgdnNSZXF1ZXN0KVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hhZGVyOiBcIiArIGUubWVzc2FnZSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zaGFkZXJDbG9zdXJlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zaGFkZXJDbG9zdXJlc1tpXS5lcXVhbHMoc2hhZGVyKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkZXJDbG9zdXJlc1tpXS5vYnNvbGV0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hhZGVyQ2xvc3VyZXNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVNoYWRlckNsb3N1cmUoc2hhZGVyLCBzY2VuZSk7XHJcbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdGlhbGl6ZVNoYWRlckNsb3N1cmU6IGZ1bmN0aW9uIChzaGFkZXJDbG9zdXJlLCBzY2VuZSkge1xyXG4gICAgICAgIHNoYWRlckNsb3N1cmUuY29tcGlsZSgpO1xyXG5cclxuICAgICAgICBzY2VuZS5lbWl0KE1hdGVyaWFsRXZlbnRzLk1BVEVSSUFMX0lOSVRJQUxJWkVEKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUNsb3N1cmVGcm9tQ29tcHV0ZVJlc3VsdChzaGFkZXJDbG9zdXJlLCB0aGlzLmdldFNoYWRlckRhdGFSZXN1bHQoKSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVDbG9zdXJlRnJvbUxpZ2h0UGFyYW1ldGVycyhzaGFkZXJDbG9zdXJlLCBzY2VuZSk7XHJcbiAgICAgICAgdGhpcy5zaGFkZXJDbG9zdXJlcy5wdXNoKHNoYWRlckNsb3N1cmUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTaGFkZXJSZWNvbXBpbGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNoYWRlckNsb3N1cmVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyQ2xvc3VyZXNbaV0ub2Jzb2xldGUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVtaXQoTWF0ZXJpYWxFdmVudHMuTUFURVJJQUxfU1RSVUNUVVJFX0NIQU5HRUQpO1xyXG4gICAgICAgIHRoaXMuZGF0YUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTGlnaHRWYWx1ZXMgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB7WGZsb3cuQ29tcHV0ZVJlc3VsdHxudWxsfVxyXG4gICAgICovXHJcbiAgICBnZXRTaGFkZXJEYXRhUmVzdWx0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCA/IHRoaXMucmVxdWVzdC5nZXRSZXN1bHQoKSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG5cclxufSk7XHJcblxyXG5cclxuLyoqXHJcbiAqIEBpbXBsZW1lbnRzIElTaGFkZXJDb21wb3NlclxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBEZWZhdWx0Q29tcG9zZXIgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoRGVmYXVsdENvbXBvc2VyLCBBYnN0cmFjdFNoYWRlckNvbXBvc2VyLCB7XHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0U2hhZGVyQ2xvc3VyZTogZnVuY3Rpb24gKHNjZW5lLCB2c1JlcXVlc3QpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1GYWN0b3J5LmdldEZhbGxiYWNrUHJvZ3JhbSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRTaGFkZXJBdHRyaWJ1dGVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtjb2xvcjogbnVsbCwgbm9ybWFsOiBudWxsIC8qIGZvciBwaWNraW5nICovfTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UmVxdWVzdEZpZWxkczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBbXCJkaWZmdXNlQ29sb3JcIiwgXCJ1c2VWZXJ0ZXhDb2xvclwiXTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlT2JqZWN0RGF0YVJlcXVlc3Q6IGZ1bmN0aW9uIChvYmplY3REYXRhTm9kZSwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXB1dGVSZXF1ZXN0KG9iamVjdERhdGFOb2RlLCBbXCJwb3NpdGlvblwiLCBcImNvbG9yXCIsIFwibm9ybWFsXCIsIFwiZGlmZnVzZUNvbG9yXCIsIFwidXNlVmVydGV4Q29sb3JcIl0sIGNhbGxiYWNrKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGlzdHJpYnV0ZU9iamVjdFNoYWRlckRhdGE6IGZ1bmN0aW9uIChvYmplY3RSZXF1ZXN0LCBhdHRyaWJ1dGVDYWxsYmFjaywgdW5pZm9ybUNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdFJlcXVlc3QuZ2V0UmVzdWx0KCk7XHJcblxyXG4gICAgICAgIHZhciBkYXRhTWFwID0gcmVzdWx0LmdldE91dHB1dE1hcCgpLCByZXF1ZXN0RmllbGRzID0gdGhpcy5nZXRSZXF1ZXN0RmllbGRzKCk7XHJcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBkYXRhTWFwKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0RmllbGRzLmluZGV4T2YobmFtZSkgIT0gLTEpXHJcbiAgICAgICAgICAgICAgICB1bmlmb3JtQ2FsbGJhY2sobmFtZSwgZGF0YU1hcFtuYW1lXSk7IGVsc2VcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUNhbGxiYWNrKG5hbWUsIGRhdGFNYXBbbmFtZV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBBYnN0cmFjdFNoYWRlckNvbXBvc2VyOiBBYnN0cmFjdFNoYWRlckNvbXBvc2VyLFxyXG4gICAgRGVmYXVsdENvbXBvc2VyOiBEZWZhdWx0Q29tcG9zZXJcclxufVxyXG5cclxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBNQVRFUklBTF9TVFJVQ1RVUkVfQ0hBTkdFRDogXCJtYXRlcmlhbF9zdHJ1Y3R1cmVfY2hhbmdlZFwiLFxyXG4gICAgTUFURVJJQUxfSU5JVElBTElaRUQ6IFwibWF0ZXJpYWxfaW5pdGlhbGl6ZWRcIlxyXG59O1xyXG4iLCJ2YXIgQWJzdHJhY3RTaGFkZXJDbG9zdXJlID0gcmVxdWlyZShcIi4vLi4vYWJzdHJhY3RzaGFkZXJjbG9zdXJlLmpzXCIpO1xyXG52YXIgSlNTaGFkZXJDb21wb3NlciA9IHJlcXVpcmUoXCIuL2pzc2hhZGVyY29tcG9zZXIuanNcIik7XHJcbnZhciBTeXN0ZW1Ob3RpZmllciA9IHJlcXVpcmUoXCIuLi8uLi9zeXN0ZW0vc3lzdGVtLW5vdGlmaWVyLmpzXCIpO1xyXG52YXIgZ2V0SlNTeXN0ZW1Db25maWd1cmF0aW9uID0gcmVxdWlyZShcIi4vanNzeXN0ZW1jb25maWd1cmF0aW9uLmpzXCIpO1xyXG52YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIE9wdGlvbnMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vdXRpbHMvb3B0aW9ucy5qc1wiKTtcclxuXHJcblxyXG52YXIgY19qc1NoYWRlckNhY2hlID0ge307XHJcblxyXG5cclxuZnVuY3Rpb24gY29udmVydEVudk5hbWUobmFtZSkge1xyXG4gICAgcmV0dXJuIChcIl9lbnZfXCIgKyBuYW1lKS5yZXBsYWNlKC9fKy9nLCBcIl9cIik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZERlZmF1bHRDaGFubmVsaW5nKHZzQ29uZmlnLCBpbnB1dE5hbWUpIHtcclxuICAgIHZhciBvdXRwdXROYW1lID0gY29udmVydEVudk5hbWUoaW5wdXROYW1lKTtcclxuICAgIHZzQ29uZmlnLmNoYW5uZWxBdHRyaWJ1dGUoaW5wdXROYW1lLCBvdXRwdXROYW1lLCBudWxsKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGNoYW5uZWxWc0F0dHJpYnV0ZSh2c0NvbmZpZywgaW5wdXROYW1lLCBzcGFjZUluZm8pIHtcclxuICAgIGlmICghc3BhY2VJbmZvIHx8ICFzcGFjZUluZm9baW5wdXROYW1lXSkge1xyXG4gICAgICAgIGFkZERlZmF1bHRDaGFubmVsaW5nKHZzQ29uZmlnLCBpbnB1dE5hbWUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaSA9IHNwYWNlSW5mb1tpbnB1dE5hbWVdLmxlbmd0aDtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICB2YXIgZW50cnkgPSBzcGFjZUluZm9baW5wdXROYW1lXVtpXTtcclxuICAgICAgICB2YXIgb3V0cHV0TmFtZSA9IGNvbnZlcnRFbnZOYW1lKGVudHJ5Lm5hbWUpLCBjb2RlID0gbnVsbDtcclxuICAgICAgICBzd2l0Y2ggKGVudHJ5LnNwYWNlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgU2hhZGUuU1BBQ0VfVkVDVE9SX1RZUEVTLk9CSkVDVDpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFNoYWRlLlNQQUNFX1ZFQ1RPUl9UWVBFUy5WSUVXX1BPSU5UOlxyXG4gICAgICAgICAgICAgICAgdnNDb25maWcuYWRkSW5wdXRQYXJhbWV0ZXIoWEMuREFUQV9UWVBFLkZMT0FUNFg0LCBcIm1vZGVsVmlld01hdHJpeFwiLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGNvZGUgPSBvdXRwdXROYW1lICsgXCIgPSAoIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoI0l7XCIgKyBpbnB1dE5hbWUgKyBcIn0sIDEuMCkgKS54eXo7XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBTaGFkZS5TUEFDRV9WRUNUT1JfVFlQRVMuVklFV19OT1JNQUw6XHJcbiAgICAgICAgICAgICAgICB2c0NvbmZpZy5hZGRJbnB1dFBhcmFtZXRlcihYQy5EQVRBX1RZUEUuRkxPQVQzWDMsIFwibW9kZWxWaWV3TWF0cml4TlwiLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGNvZGUgPSBvdXRwdXROYW1lICsgXCIgPSBub3JtYWxpemUoIG1vZGVsVmlld01hdHJpeE4gKiAjSXtcIiArIGlucHV0TmFtZSArIFwifSApO1wiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU2hhZGUuU1BBQ0VfVkVDVE9SX1RZUEVTLldPUkxEX1BPSU5UOlxyXG4gICAgICAgICAgICAgICAgdnNDb25maWcuYWRkSW5wdXRQYXJhbWV0ZXIoWEMuREFUQV9UWVBFLkZMT0FUNFg0LCBcIm1vZGVsTWF0cml4XCIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgY29kZSA9IG91dHB1dE5hbWUgKyBcIiA9ICggbW9kZWxNYXRyaXggKiB2ZWM0KCNJe1wiICsgaW5wdXROYW1lICsgXCJ9LCAxLjApICkueHl6O1wiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU2hhZGUuU1BBQ0VfVkVDVE9SX1RZUEVTLldPUkxEX05PUk1BTDpcclxuICAgICAgICAgICAgICAgIHZzQ29uZmlnLmFkZElucHV0UGFyYW1ldGVyKFhDLkRBVEFfVFlQRS5GTE9BVDNYMywgXCJtb2RlbE1hdHJpeE5cIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBjb2RlID0gb3V0cHV0TmFtZSArIFwiID0gbm9ybWFsaXplKCBtb2RlbE1hdHJpeE4gKiAjSXtcIiArIGlucHV0TmFtZSArIFwifSApO1wiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBoYW5kbGUgU3BhY2UgVHlwZTogXCIgKyBlbnRyeS5zcGFjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZzQ29uZmlnLmNoYW5uZWxBdHRyaWJ1dGUoaW5wdXROYW1lLCBvdXRwdXROYW1lLCBjb2RlKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1hDLkRBVEFfVFlQRX0geGZsb3dUeXBlXHJcbiAqL1xyXG52YXIgY29udmVydFhmbG93MlNoYWRlVHlwZSA9IGZ1bmN0aW9uICh4Zmxvd1R5cGUsIHNvdXJjZSkge1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9XHJcbiAgICBzd2l0Y2ggKHhmbG93VHlwZSkge1xyXG4gICAgICAgIGNhc2UgWEMuREFUQV9UWVBFLkJPT0w6XHJcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gU2hhZGUuVFlQRVMuQk9PTEVBTjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuSU5UOlxyXG4gICAgICAgICAgICByZXN1bHQudHlwZSA9IFNoYWRlLlRZUEVTLklOVDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuRkxPQVQ6XHJcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gU2hhZGUuVFlQRVMuTlVNQkVSO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFhDLkRBVEFfVFlQRS5GTE9BVDI6XHJcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gU2hhZGUuVFlQRVMuT0JKRUNUO1xyXG4gICAgICAgICAgICByZXN1bHQua2luZCA9IFNoYWRlLk9CSkVDVF9LSU5EUy5GTE9BVDI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWEMuREFUQV9UWVBFLkZMT0FUMzpcclxuICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSBTaGFkZS5UWVBFUy5PQkpFQ1Q7XHJcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0gU2hhZGUuT0JKRUNUX0tJTkRTLkZMT0FUMztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuRkxPQVQ0OlxyXG4gICAgICAgICAgICByZXN1bHQudHlwZSA9IFNoYWRlLlRZUEVTLk9CSkVDVDtcclxuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBTaGFkZS5PQkpFQ1RfS0lORFMuRkxPQVQ0O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFhDLkRBVEFfVFlQRS5GTE9BVDNYMzpcclxuICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSBTaGFkZS5UWVBFUy5PQkpFQ1Q7XHJcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0gU2hhZGUuT0JKRUNUX0tJTkRTLk1BVFJJWDM7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWEMuREFUQV9UWVBFLkZMT0FUNFg0OlxyXG4gICAgICAgICAgICByZXN1bHQudHlwZSA9IFNoYWRlLlRZUEVTLk9CSkVDVDtcclxuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBTaGFkZS5PQkpFQ1RfS0lORFMuTUFUUklYNDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuVEVYVFVSRTpcclxuICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSBTaGFkZS5UWVBFUy5PQkpFQ1Q7XHJcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0gU2hhZGUuT0JKRUNUX0tJTkRTLlRFWFRVUkU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWEMuREFUQV9UWVBFLlVOS05PV046XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBYZmxvdyBEYXRhVHlwZTogXCIgKyB4Zmxvd1R5cGUpO1xyXG4gICAgfVxyXG4gICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gY29udGV4dFxyXG4gKiBAcGFyYW0gc291cmNlVGVtcGxhdGVcclxuICogQHBhcmFtIGRhdGFDYWxsYmFja1xyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBKU1NoYWRlckNsb3N1cmUgPSBmdW5jdGlvbiAoY29udGV4dCwgc291cmNlVGVtcGxhdGUsIGV4dHJhY3RlZFBhcmFtcykge1xyXG4gICAgQWJzdHJhY3RTaGFkZXJDbG9zdXJlLmNhbGwodGhpcywgY29udGV4dCk7XHJcbiAgICB0aGlzLnNvdXJjZVRlbXBsYXRlID0gc291cmNlVGVtcGxhdGU7XHJcbiAgICB0aGlzLmV4dHJhY3RlZFBhcmFtcyA9IGV4dHJhY3RlZFBhcmFtcztcclxuICAgIHRoaXMudW5pZm9ybVNldHRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIH07XHJcbiAgICB0aGlzLnVuaWZvcm1Db252ZXJ0ZXIgPSBbXTtcclxufTtcclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKEpTU2hhZGVyQ2xvc3VyZSwgQWJzdHJhY3RTaGFkZXJDbG9zdXJlLCB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0dMU2NlbmV9IHNjZW5lXHJcbiAgICAgKiBAcGFyYW0ge1hmbG93LkNvbXB1dGVSZXN1bHR9IHNoYWRlclJlc3VsdFxyXG4gICAgICogQHBhcmFtIG9iamVjdERhdGFcclxuICAgICAqL1xyXG4gICAgY3JlYXRlU291cmNlczogZnVuY3Rpb24gKHNjZW5lLCBzaGFkZXJSZXN1bHQsIHZzUmVxdWVzdCkge1xyXG5cclxuICAgICAgICB2YXIgdnNEYXRhUmVzdWx0ID0gdnNSZXF1ZXN0LmdldFJlc3VsdCgpO1xyXG5cclxuICAgICAgICB2YXIgc3lzdGVtUGFyYW1ldGVycyA9IGdldFN5c3RlbVBhcmFtZXRlcnModGhpcy5jb250ZXh0LCBzY2VuZS5zeXN0ZW1Vbmlmb3Jtcyk7XHJcbiAgICAgICAgdmFyIGVudmlyb25tZW50UGFyYW1ldGVycyA9IHt9O1xyXG5cclxuXHJcblxyXG4gICAgICAgIHZhciBzaGFkZXJFbnRyaWVzID0gc2hhZGVyUmVzdWx0ICYmIHNoYWRlclJlc3VsdC5nZXRPdXRwdXRNYXAoKSwgdnNTaGFkZXJPdXRwdXQgPSB2c0RhdGFSZXN1bHQgJiYgdnNEYXRhUmVzdWx0Lm91dHB1dE5hbWVzO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXh0cmFjdGVkUGFyYW1zLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJhbU5hbWUgPSB0aGlzLmV4dHJhY3RlZFBhcmFtc1tpXTtcclxuICAgICAgICAgICAgaWYgKHZzU2hhZGVyT3V0cHV0ICYmIHZzU2hhZGVyT3V0cHV0LmluZGV4T2YocGFyYW1OYW1lKSAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgZW52aXJvbm1lbnRQYXJhbWV0ZXJzW3BhcmFtTmFtZV0gPSBjb252ZXJ0WGZsb3cyU2hhZGVUeXBlKHZzRGF0YVJlc3VsdC5nZXRPdXRwdXRUeXBlKHBhcmFtTmFtZSksIHZzRGF0YVJlc3VsdC5pc091dHB1dFVuaWZvcm0ocGFyYW1OYW1lKSA/IFNoYWRlLlNPVVJDRVMuVU5JRk9STSA6IFNoYWRlLlNPVVJDRVMuVkVSVEVYKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFkZXJFbnRyaWVzICYmIHNoYWRlckVudHJpZXNbcGFyYW1OYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgZW52aXJvbm1lbnRQYXJhbWV0ZXJzW3BhcmFtTmFtZV0gPSBjb252ZXJ0WGZsb3cyU2hhZGVUeXBlKHNoYWRlckVudHJpZXNbcGFyYW1OYW1lXS50eXBlLCBTaGFkZS5TT1VSQ0VTLlVOSUZPUk0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY29udGV4dERhdGEgPSB7XHJcbiAgICAgICAgICAgIFwidGhpc1wiOiB7IFwidHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJhbnlcIiwgXCJpbmZvXCI6IHN5c3RlbVBhcmFtZXRlcnMgfSxcclxuICAgICAgICAgICAgXCJnbG9iYWwuc2hhZGVcIjogW3tcImV4dHJhXCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwiYW55XCIsIFwiZ2xvYmFsXCI6IHRydWUsIFwiaW5mb1wiOiBlbnZpcm9ubWVudFBhcmFtZXRlcnMgfX1dXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJDT05URVhUOlwiLCBjb250ZXh0RGF0YSk7XHJcblxyXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBwcm9wYWdhdGVDb25zdGFudHM6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbGlkYXRlOiB0cnVlLFxyXG4gICAgICAgICAgICBzYW5pdGl6ZTogdHJ1ZSxcclxuICAgICAgICAgICAgdHJhbnNmb3JtU3BhY2VzOiBPcHRpb25zLmdldFZhbHVlKFwic2hhZGVqcy10cmFuc2Zvcm1TcGFjZXNcIiksXHJcbiAgICAgICAgICAgIGV4dHJhY3RVbmlmb3JtRXhwcmVzc2lvbnM6IE9wdGlvbnMuZ2V0VmFsdWUoXCJzaGFkZWpzLWV4dHJhY3RVbmlmb3JtRXhwcmVzc2lvbnNcIilcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBjb21waWxlT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgdXNlU3RhdGljOiB0cnVlLCB1bmlmb3JtRXhwcmVzc2lvbnM6IG9wdGlvbnMudW5pZm9ybUV4cHJlc3Npb25zXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgaW1wbGVtZW50YXRpb24gPSBzY2VuZS5kZWZlcnJlZCA/IFwieG1sM2QtZ2xzbC1kZWZlcnJlZFwiIDogXCJ4bWwzZC1nbHNsLWZvcndhcmRcIjtcclxuXHJcbiAgICAgICAgdmFyIGpzU2hhZGVyS2V5ID0gaW1wbGVtZW50YXRpb24gKyBcIjtcIiArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpICsgXCI7XCIgKyBKU09OLnN0cmluZ2lmeShlbnZpcm9ubWVudFBhcmFtZXRlcnMpICsgXCI7XCIgKyB0aGlzLnNvdXJjZVRlbXBsYXRlO1xyXG5cclxuICAgICAgICB2YXIgY2FjaGVFbnRyeTtcclxuICAgICAgICBpZiAoIShjYWNoZUVudHJ5ID0gY19qc1NoYWRlckNhY2hlW2pzU2hhZGVyS2V5XSkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhciB3b3JrU2V0ID0gbmV3IFNoYWRlLldvcmtpbmdTZXQoKTtcclxuICAgICAgICAgICAgICAgIHdvcmtTZXQucGFyc2UodGhpcy5zb3VyY2VUZW1wbGF0ZSwge2xvYzogdHJ1ZX0pO1xyXG4gICAgICAgICAgICAgICAgd29ya1NldC5hbmFseXplKGNvbnRleHREYXRhLCBpbXBsZW1lbnRhdGlvbiwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2VJbmZvID0gd29ya1NldC5nZXRQcm9jZXNzaW5nRGF0YSgnc3BhY2VJbmZvJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ2xzbFNoYWRlciA9IHdvcmtTZXQuY29tcGlsZUZyYWdtZW50U2hhZGVyKGNvbXBpbGVPcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjYWNoZUVudHJ5ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogZ2xzbFNoYWRlci5zb3VyY2UsIHVuaWZvcm1TZXR0ZXI6IGdsc2xTaGFkZXIudW5pZm9ybVNldHRlciwgc3BhY2VJbmZvOiBzcGFjZUluZm9cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjYWNoZUVudHJ5Lmhhc1RyYW5zcGFyZW50U2hhZGVyQ2xvc3VyZSA9IHdvcmtTZXQuZ2V0UHJvY2Vzc2luZ0RhdGEoXCJpc1RyYW5zcGFyZW50XCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMudW5pZm9ybVNldHRlciA9IGdsc2xTaGFkZXIudW5pZm9ybVNldHRlcjtcclxuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50OiBnbHNsU2hhZGVyLnNvdXJjZSwgdmVydGV4OiB0aGlzLmNyZWF0ZVZlcnRleFNoYWRlcih2c1JlcXVlc3QsIHZzRGF0YVJlc3VsdCwgc3BhY2VJbmZvKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzY2VuZS5kZWZlcnJlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlRW50cnkuc2lnbmF0dXJlcyA9IHdvcmtTZXQuZ2V0UHJvY2Vzc2luZ0RhdGEoXCJjb2xvckNsb3N1cmVTaWduYXR1cmVzXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKE9wdGlvbnMuZ2V0VmFsdWUoXCJzaGFkZWpzLWNhY2hlXCIpKVxyXG4gICAgICAgICAgICAgICAgICAgIGNfanNTaGFkZXJDYWNoZVtqc1NoYWRlcktleV0gPSBjYWNoZUVudHJ5O1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBTeXN0ZW1Ob3RpZmllci5zZW5kRXZlbnQoJ3NoYWRlanMnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhZGVqc1R5cGU6IFwiZXJyb3JcIiwgZXZlbnQ6IGUsIGNvZGU6IHRoaXMuc291cmNlVGVtcGxhdGVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBcIlNoYWRlLmpzIENvbXBpbGUgRXJyb3I6XFxuXCIgKyBlLm1lc3NhZ2UgKyBcIlxcbi0tLS0tLS0tLS0tLVxcblwiICsgXCJTaGFkZXIgU291cmNlOlwiICsgXCJcXG4tLS0tLS0tLS0tLS1cXG5cIiArIFhNTDNELmRlYnVnLmZvcm1hdFNvdXJjZUNvZGUodGhpcy5zb3VyY2VUZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNvdXJjZSA9IHtcclxuICAgICAgICAgICAgZnJhZ21lbnQ6IGNhY2hlRW50cnkuc291cmNlLCB2ZXJ0ZXg6IHRoaXMuY3JlYXRlVmVydGV4U2hhZGVyKHZzUmVxdWVzdCwgdnNEYXRhUmVzdWx0LCBjYWNoZUVudHJ5LnNwYWNlSW5mbylcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaGFzVHJhbnNwYXJlbnRTaGFkZXJDbG9zdXJlID0gY2FjaGVFbnRyeS5oYXNUcmFuc3BhcmVudFNoYWRlckNsb3N1cmU7XHJcblxyXG4gICAgICAgIHRoaXMudW5pZm9ybVNldHRlciA9IGNhY2hlRW50cnkudW5pZm9ybVNldHRlcjtcclxuICAgICAgICBpZiAoc2NlbmUuZGVmZXJyZWQpIHtcclxuICAgICAgICAgICAgc2NlbmUuY29sb3JDbG9zdXJlU2lnbmF0dXJlcy5wdXNoLmFwcGx5KHNjZW5lLmNvbG9yQ2xvc3VyZVNpZ25hdHVyZXMsIGNhY2hlRW50cnkuc2lnbmF0dXJlcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUT0RPOiBIYW5kbGUgZXJyb3JzLlxyXG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKHRoaXMuc291cmNlLnZlcnRleCk7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcodGhpcy5zb3VyY2UuZnJhZ21lbnQpO1xyXG5cclxuICAgICAgICBTeXN0ZW1Ob3RpZmllci5zZW5kRXZlbnQoJ3NoYWRlanMnLCB7XHJcbiAgICAgICAgICAgIHNoYWRlanNUeXBlOiBcInN1Y2Nlc3NcIiwgdmVydGV4U2hhZGVyOiB0aGlzLnNvdXJjZS52ZXJ0ZXgsIGZyYWdtZW50U2hhZGVyOiB0aGlzLnNvdXJjZS5mcmFnbWVudFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlVmVydGV4U2hhZGVyOiBmdW5jdGlvbiAodnNSZXF1ZXN0LCB2c0RhdGFSZXN1bHQsIHNwYWNlSW5mbykge1xyXG4gICAgICAgIHZhciB2c0NvbmZpZyA9IHZzUmVxdWVzdC5nZXRDb25maWcoKTtcclxuICAgICAgICB2YXIgbmFtZXMgPSB2c0RhdGFSZXN1bHQub3V0cHV0TmFtZXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBjaGFubmVsVnNBdHRyaWJ1dGUodnNDb25maWcsIG5hbWVzW2ldLCBzcGFjZUluZm8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2c0NvbmZpZy5hZGRJbnB1dFBhcmFtZXRlcihYQy5EQVRBX1RZUEUuRkxPQVQ0WDQsIFwibW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeFwiLCB0cnVlKTtcclxuICAgICAgICB2c0NvbmZpZy5hZGRDb2RlRnJhZ21lbnQoXCJnbF9Qb3NpdGlvbiA9IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggKiB2ZWM0KCNJe3Bvc2l0aW9ufSwgMS4wKTtcIik7XHJcbiAgICAgICAgcmV0dXJuIHZzUmVxdWVzdC5nZXRWZXJ0ZXhTaGFkZXIoKS5nZXRHTFNMQ29kZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRVbmlmb3JtVmFyaWFibGVzOiBmdW5jdGlvbiAoZW52TmFtZXMsIHN5c05hbWVzLCBpbnB1dENvbGxlY3Rpb24pIHtcclxuICAgICAgICB0aGlzLnVuaWZvcm1TZXR0ZXIoZW52TmFtZXMsIHN5c05hbWVzLCBpbnB1dENvbGxlY3Rpb24sIHRoaXMucHJvZ3JhbS5zZXRVbmlmb3JtVmFyaWFibGUuYmluZCh0aGlzLnByb2dyYW0pKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VHJhbnNwYXJlbmN5RnJvbUlucHV0RGF0YTogZnVuY3Rpb24gKGRhdGFNYXApIHtcclxuICAgICAgICAvLyBUT0RPOiBDb21wdXRlIFRyYW5zcGFyZW5jeVxyXG4gICAgICAgIHJldHVybiB0aGlzLmhhc1RyYW5zcGFyZW50U2hhZGVyQ2xvc3VyZTtcclxuICAgIH0sXHJcblxyXG4gICAgLyogRGVmYXVsdCB2YWx1ZXMgYXJlIGNvbXBpbGVkIGludG8gc2hhZGUuanMgKi9cclxuICAgIHNldERlZmF1bHRVbmlmb3JtczogZnVuY3Rpb24gKCkge1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtHTENvbnRleHR9IGNvbnRleHRcclxuICogQHBhcmFtIHt7fX0gZ2xvYmFsc1xyXG4gKiBAcmV0dXJucyB7e319XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTeXN0ZW1QYXJhbWV0ZXJzKGNvbnRleHQsIGdsb2JhbHMpIHtcclxuICAgIHZhciByZXN1bHQgPSBnZXRKU1N5c3RlbUNvbmZpZ3VyYXRpb24oY29udGV4dCk7XHJcblxyXG4gICAgLy8gVXBkYXRlIGxpZ2h0IHBhcmFtZXRlcnMgd2hpY2ggdmFyeSBpbiB0aGVpciBzaXplIGRlcGVuZGluZyBvbiBudW1iZXIgb2YgbGlnaHRzIGRlZmluZWRcclxuICAgIFtcInBvaW50XCIsIFwiZGlyZWN0aW9uYWxcIiwgXCJzcG90XCJdLmZvckVhY2goZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICB2YXIgb24gPSBtb2RlbCArIFwiTGlnaHRPblwiO1xyXG4gICAgICAgIHJlc3VsdFtcIk1BWF9cIiArIG1vZGVsLnRvVXBwZXJDYXNlKCkgKyBcIkxJR0hUU1wiXS5zdGF0aWNWYWx1ZSA9IGdsb2JhbHNbb25dICYmIGdsb2JhbHNbb25dLmxlbmd0aDtcclxuICAgIH0pO1xyXG5cclxuICAgIGZvciAodmFyIGdsb2JhbCBpbiBnbG9iYWxzKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gcmVzdWx0W2dsb2JhbF07XHJcbiAgICAgICAgaWYoZW50cnkgJiYgZW50cnkuc3RhdGljU2l6ZSkge1xyXG4gICAgICAgICAgICB2YXIgYUxlbmd0aCA9IGdsb2JhbHNbZ2xvYmFsXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChhTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHVwbGVTaXplID0gZ2V0VHVwbGVTaXplKGVudHJ5KTtcclxuICAgICAgICAgICAgICAgIGVudHJ5LnN0YXRpY1NpemUgPSBhTGVuZ3RoIC8gdHVwbGVTaXplO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGFsbG93IGEgYXJyYXkgb2Ygc2l6ZSAwLCByZW1vdmUgZW50cnkgaW5zdGVhZFxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyhrc29ucyk6IFJlbW92ZSBvbmNlIHdlIGNhbiBjaGVjayBhcnJheSBzaXplIGluIHNoYWRlLmpzXHJcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0W2dsb2JhbF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7e319IGRlc2MgT2JqZWN0IHR5cGUgZGVzY3JpcHRvclxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VHVwbGVTaXplKGRlc2MpIHtcclxuICAgIGlmKGRlc2MudHlwZSA9PSBcImFycmF5XCIpIHtcclxuICAgICAgICB2YXIgZWxlbWVudHMgPSBkZXNjLmVsZW1lbnRzO1xyXG4gICAgICAgIGlmIChlbGVtZW50cy50eXBlID09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgc3dpdGNoKGVsZW1lbnRzLmtpbmQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0dXJlXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmxvYXRcIjogcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmxvYXQyXCI6IHJldHVybiAyO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImZsb2F0M1wiOiByZXR1cm4gMztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJmbG9hdDRcIjogcmV0dXJuIDQ7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibWF0cml4NFwiOiByZXR1cm4gMTY7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyAoXCJVbmtub3duIGFycmF5IGVsZW1lbnQga2luZDpcIiArIGVsZW1lbnRzLmtpbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIDE7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSlNTaGFkZXJDbG9zdXJlO1xyXG5cclxuIiwidmFyIEFic3RyYWN0U2hhZGVyQ29tcG9zZXIgPSByZXF1aXJlKFwiLi8uLi9hYnN0cmFjdHNoYWRlcmNvbXBvc2VyLmpzXCIpLkFic3RyYWN0U2hhZGVyQ29tcG9zZXI7XHJcbnZhciBKU1NoYWRlckNsb3N1cmUgPSByZXF1aXJlKFwiLi9qc3NoYWRlcmNsb3N1cmUuanNcIik7XHJcbnZhciBWU0NvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi94Zmxvdy9wcm9jZXNzaW5nL3ZzLWNvbm5lY3QuanNcIikuVlNDb25maWc7XHJcbnZhciBWZXJ0ZXhTaGFkZXJSZXF1ZXN0ID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9yZXF1ZXN0LmpzXCIpLlZlcnRleFNoYWRlclJlcXVlc3Q7XHJcbnZhciBYQyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7R0xDb250ZXh0fSBjb250ZXh0XHJcbiAqIEBwYXJhbSB7TWF0ZXJpYWxDb25maWd1cmF0aW9ufSBjb25maWdcclxuICogQGV4dGVuZHMgQWJzdHJhY3RTaGFkZXJDb21wb3NlclxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBKU1NoYWRlckNvbXBvc2VyID0gZnVuY3Rpb24gKGNvbnRleHQsIGNvbmZpZykge1xyXG4gICAgQWJzdHJhY3RTaGFkZXJDb21wb3Nlci5jYWxsKHRoaXMsIGNvbnRleHQsIGNvbmZpZyk7XHJcblxyXG4gICAgaWYgKCF3aW5kb3cuU2hhZGUpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2hhZGUuanMgbGlicmFyeSBub3QgZm91bmRcIik7XHJcblxyXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuXHJcbiAgICAvKiogQHR5cGUgc3RyaW5nKi9cclxuICAgIHRoaXMuc291cmNlVGVtcGxhdGUgPSBjb25maWcubW9kZWwuc2NyaXB0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5leHRyYWN0ZWRQYXJhbXMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7WGZsb3cuQ29tcHV0ZVJlcXVlc3R8bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXF1ZXN0ID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLnNldFNoYWRlckluZm8oY29uZmlnKTtcclxufTtcclxuXHJcbkpTU2hhZGVyQ29tcG9zZXIuY29udmVydFN5c05hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgcmV0dXJuIG5hbWU7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhKU1NoYWRlckNvbXBvc2VyLCBBYnN0cmFjdFNoYWRlckNvbXBvc2VyLCB7XHJcbiAgICBzZXRTaGFkZXJJbmZvOiBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIGFzdCA9IFNoYWRlLnBhcnNlKHRoaXMuc291cmNlVGVtcGxhdGUsIHtsb2M6IHRydWV9KTtcclxuICAgICAgICAgICAgdGhpcy5leHRyYWN0ZWRQYXJhbXMgPSBTaGFkZS5leHRyYWN0UGFyYW1ldGVycyhhc3QsIHtpbXBsZW1lbnRhdGlvbjogXCJ4bWwzZC1nbHNsLWZvcndhcmRcIn0pLnNoYWRlclBhcmFtZXRlcnM7XHJcbiAgICAgICAgICAgIC8vIEZJWE1FOiBTaGFkZXIuanMgc2hvdWxkIGFsd2F5cyByZXF1ZXN0IHBvc2l0aW9uIChpbiBjYXNlXHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBXZSBpZ25vcmUgZXJyb3JzIGhlcmUuIFRoZXkgd2lsbCByZW9jY3VyIHdoZW4gdXBkYXRpbmcgY29ubmVjdGVkIG1lc2ggY2xvc3VyZXNcclxuICAgICAgICAgICAgdGhpcy5leHRyYWN0ZWRQYXJhbXMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZXh0cmFjdGVkUGFyYW1zLmluZGV4T2YoXCJwb3NpdGlvblwiKSA9PSAtMSkgdGhpcy5leHRyYWN0ZWRQYXJhbXMucHVzaChcInBvc2l0aW9uXCIpO1xyXG5cclxuICAgICAgICAvLyBUaGUgY29tcG9zZXIgaXMgaW50ZXJlc3RlZCBpbiBjaGFuZ2VzIG9mIGFsbCBwb3NzaWJsZSBzaGFkZXIgcGFyYW1ldGVycyAoZXh0cmFjdGVkKVxyXG4gICAgICAgIC8vIHRoZSBpbnN0YW5jZXMgKGNsb3N1cmVzKSB3aWxsIG9ubHkgc2V0IHRob3NlLCB0aGF0IG9jY3VyIGluIHRoZSBpbnN0YW5jZVxyXG4gICAgICAgIGlmICh0aGlzLmV4dHJhY3RlZFBhcmFtcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVSZXF1ZXN0KGNvbmZpZy5kYXRhTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRSZXF1ZXN0RmllbGRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdGVkUGFyYW1zO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRTaGFkZXJBdHRyaWJ1dGVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtjb2xvcjogbnVsbCwgbm9ybWFsOiBudWxsLCB0ZXhjb29yZDogbnVsbH07XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVNoYWRlckNsb3N1cmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEpTU2hhZGVyQ2xvc3VyZSh0aGlzLmNvbnRleHQsIHRoaXMuc291cmNlVGVtcGxhdGUsIHRoaXMuZXh0cmFjdGVkUGFyYW1zKTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlT2JqZWN0RGF0YVJlcXVlc3Q6IGZ1bmN0aW9uIChvYmplY3REYXRhTm9kZSwgY2FsbGJhY2spIHtcclxuXHJcbiAgICAgICAgdmFyIHZzQ29uZmlnID0gbmV3IFZTQ29uZmlnKCk7XHJcbiAgICAgICAgdmFyIG5hbWVzID0gdGhpcy5leHRyYWN0ZWRQYXJhbXMuc2xpY2UoKTtcclxuICAgICAgICAvL2lmKG5hbWVzLmluZGV4T2YoXCJwb3NpdGlvblwiKSA9PSAtMSkgbmFtZXMucHVzaChcInBvc2l0aW9uXCIpO1xyXG4gICAgICAgIHZzQ29uZmlnLmFkZEF0dHJpYnV0ZShYQy5EQVRBX1RZUEUuRkxPQVQzLCBcInBvc2l0aW9uXCIsIHRydWUpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcclxuICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJwb3NpdGlvblwiKSBjb250aW51ZTtcclxuICAgICAgICAgICAgdmFyIHhmbG93SW5mbyA9IG9iamVjdERhdGFOb2RlLmdldE91dHB1dENoYW5uZWxJbmZvKG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoeGZsb3dJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICB2c0NvbmZpZy5hZGRBdHRyaWJ1dGUoeGZsb3dJbmZvLnR5cGUsIG5hbWUsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVmVydGV4U2hhZGVyUmVxdWVzdChvYmplY3REYXRhTm9kZSwgdnNDb25maWcsIGNhbGxiYWNrKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGlzdHJpYnV0ZU9iamVjdFNoYWRlckRhdGE6IGZ1bmN0aW9uIChvYmplY3RSZXF1ZXN0LCBhdHRyaWJ1dGVDYWxsYmFjaywgdW5pZm9ybUNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHZlcnRleFNoYWRlciA9IG9iamVjdFJlcXVlc3QuZ2V0VmVydGV4U2hhZGVyKCk7XHJcbiAgICAgICAgdmFyIGlucHV0TmFtZXMgPSB2ZXJ0ZXhTaGFkZXIuaW5wdXROYW1lcztcclxuICAgICAgICB2YXIgaSwgbmFtZSwgZW50cnk7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dE5hbWVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBpbnB1dE5hbWVzW2ldO1xyXG4gICAgICAgICAgICBlbnRyeSA9IHZlcnRleFNoYWRlci5nZXRJbnB1dERhdGEobmFtZSk7XHJcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXhTaGFkZXIuaXNJbnB1dFVuaWZvcm0obmFtZSkpXHJcbiAgICAgICAgICAgICAgICB1bmlmb3JtQ2FsbGJhY2sobmFtZSwgZW50cnkpOyBlbHNlXHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVDYWxsYmFjayhuYW1lLCBlbnRyeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvdXRwdXROYW1lcyA9IHZlcnRleFNoYWRlci5vdXRwdXROYW1lcztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3V0cHV0TmFtZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgbmFtZSA9IG91dHB1dE5hbWVzW2ldO1xyXG4gICAgICAgICAgICBpZiAodmVydGV4U2hhZGVyLmlzT3V0cHV0RnJhZ21lbnRVbmlmb3JtKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICB1bmlmb3JtQ2FsbGJhY2sodmVydGV4U2hhZGVyLmdldE91dHB1dFNvdXJjZU5hbWUobmFtZSksIHZlcnRleFNoYWRlci5nZXRVbmlmb3JtT3V0cHV0RGF0YShuYW1lKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEpTU2hhZGVyQ29tcG9zZXI7XHJcblxyXG5cclxuIiwidmFyIEdMQ29udGV4dCA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2NvbnRleHQuanNcIik7XHJcbnZhciBzaW5nbGV0b24gPSBudWxsO1xyXG5cclxudmFyIFNZU1RFTV9DT05URVhUX1RFTVBMQVRFID0gIHtcclxuICAgICAgICBcImNvb3Jkc1wiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcImZsb2F0M1wiLCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIn0sXHJcbiAgICAgICAgXCJjYW1lcmFQb3NpdGlvblwiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcImZsb2F0M1wiLCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIn0sXHJcbiAgICAgICAgXCJ2aWV3TWF0cml4XCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwibWF0cml4NFwiLCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIn0sXHJcbiAgICAgICAgXCJ2aWV3SW52ZXJzZU1hdHJpeFwiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcIm1hdHJpeDRcIiwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJ9LFxyXG4gICAgICAgIFwibW9kZWxNYXRyaXhcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJtYXRyaXg0XCIsIFwic291cmNlXCI6IFwidW5pZm9ybVwifSxcclxuICAgICAgICBcIm1vZGVsVmlld01hdHJpeFwiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcIm1hdHJpeDRcIiwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJ9LFxyXG4gICAgICAgIFwibW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeFwiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcIm1hdHJpeDRcIiwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJ9LFxyXG4gICAgICAgIFwibW9kZWxNYXRyaXhOXCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwibWF0cml4M1wiLCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIn0sXHJcbiAgICAgICAgXCJtb2RlbFZpZXdNYXRyaXhOXCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwibWF0cml4M1wiLCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIn0sXHJcblxyXG4gICAgICAgIFwiTUFYX1BPSU5UTElHSFRTXCI6IHtcInR5cGVcIjogXCJpbnRcIiwgXCJzb3VyY2VcIjogXCJjb25zdGFudFwiLCBcInN0YXRpY1ZhbHVlXCI6IDV9LFxyXG4gICAgICAgIFwicG9pbnRMaWdodE9uXCI6IHtcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJib29sZWFuXCJ9LCBcInN0YXRpY1NpemVcIjogNSwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJ9LFxyXG4gICAgICAgIFwicG9pbnRMaWdodEF0dGVudWF0aW9uXCI6IHtcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcImZsb2F0M1wifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInBvaW50TGlnaHRJbnRlbnNpdHlcIjoge1xyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwiZmxvYXQzXCJ9LCBcInN0YXRpY1NpemVcIjogNSwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwicG9pbnRMaWdodFBvc2l0aW9uXCI6IHtcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcImZsb2F0M1wifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInBvaW50TGlnaHRDYXN0U2hhZG93XCI6IHtcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwiYm9vbGVhblwifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInBvaW50TGlnaHRTaGFkb3dCaWFzXCI6IHtcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwibnVtYmVyXCJ9LCBcInN0YXRpY1NpemVcIjogNSwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwicG9pbnRMaWdodFNoYWRvd01hcFwiOiB7XHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJ0ZXh0dXJlXCJ9LCBcInN0YXRpY1NpemVcIjogNSwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwicG9pbnRMaWdodE1hdHJpeFwiOiB7XHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXHJcbiAgICAgICAgICAgIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJtYXRyaXg0XCJ9LFxyXG4gICAgICAgICAgICBcInN0YXRpY1NpemVcIjogNSxcclxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwicG9pbnRMaWdodFByb2plY3Rpb25cIjoge1xyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxyXG4gICAgICAgICAgICBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwibWF0cml4NFwifSxcclxuICAgICAgICAgICAgXCJzdGF0aWNTaXplXCI6IDUsXHJcbiAgICAgICAgICAgIFwic291cmNlXCI6IFwidW5pZm9ybVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInBvaW50TGlnaHROZWFyRmFyXCI6IHtcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcclxuICAgICAgICAgICAgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcImZsb2F0MlwifSxcclxuICAgICAgICAgICAgXCJzdGF0aWNTaXplXCI6IDUsXHJcbiAgICAgICAgICAgIFwic291cmNlXCI6IFwidW5pZm9ybVwiXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJNQVhfRElSRUNUSU9OQUxMSUdIVFNcIjoge1widHlwZVwiOiBcImludFwiLCBcInNvdXJjZVwiOiBcImNvbnN0YW50XCIsIFwic3RhdGljVmFsdWVcIjogNX0sXHJcbiAgICAgICAgXCJkaXJlY3Rpb25hbExpZ2h0T25cIjoge1widHlwZVwiOiBcImFycmF5XCIsIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcImJvb2xlYW5cIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIn0sXHJcbiAgICAgICAgXCJkaXJlY3Rpb25hbExpZ2h0SW50ZW5zaXR5XCI6IHtcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcImZsb2F0M1wifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25cIjoge1xyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwiZmxvYXQzXCJ9LCBcInN0YXRpY1NpemVcIjogNSwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZGlyZWN0aW9uYWxMaWdodENhc3RTaGFkb3dcIjoge1xyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJib29sZWFuXCJ9LCBcInN0YXRpY1NpemVcIjogNSwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZGlyZWN0aW9uYWxMaWdodFNoYWRvd0JpYXNcIjoge1xyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJudW1iZXJcIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJkaXJlY3Rpb25hbExpZ2h0U2hhZG93TWFwXCI6IHtcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcInRleHR1cmVcIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJkaXJlY3Rpb25hbExpZ2h0TWF0cml4XCI6IHtcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcclxuICAgICAgICAgICAgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcIm1hdHJpeDRcIn0sXHJcbiAgICAgICAgICAgIFwic3RhdGljU2l6ZVwiOiA1LFxyXG4gICAgICAgICAgICBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIFwiTUFYX1NQT1RMSUdIVFNcIjoge1widHlwZVwiOiBcImludFwiLCBcInNvdXJjZVwiOiBcImNvbnN0YW50XCIsIFwic3RhdGljVmFsdWVcIjogNX0sXHJcbiAgICAgICAgXCJzcG90TGlnaHRPblwiOiB7XCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwiYm9vbGVhblwifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwifSxcclxuICAgICAgICBcInNwb3RMaWdodEF0dGVudWF0aW9uXCI6IHtcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcImZsb2F0M1wifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInNwb3RMaWdodEludGVuc2l0eVwiOiB7XHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJmbG9hdDNcIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzcG90TGlnaHRQb3NpdGlvblwiOiB7XHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJmbG9hdDNcIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzcG90TGlnaHREaXJlY3Rpb25cIjoge1xyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwiZmxvYXQzXCJ9LCBcInN0YXRpY1NpemVcIjogNSwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwic3BvdExpZ2h0Q29zQ3V0b2ZmQW5nbGVcIjoge1xyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJudW1iZXJcIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzcG90TGlnaHRDb3NTb2Z0Q3V0b2ZmQW5nbGVcIjoge1xyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJudW1iZXJcIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzcG90TGlnaHRDYXN0U2hhZG93XCI6IHtcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwiYm9vbGVhblwifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInNwb3RMaWdodFNoYWRvd0JpYXNcIjoge1xyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJudW1iZXJcIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzcG90TGlnaHRTaGFkb3dNYXBcIjoge1xyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwidGV4dHVyZVwifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInNwb3RMaWdodE1hdHJpeFwiOiB7XHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXHJcbiAgICAgICAgICAgIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJtYXRyaXg0XCJ9LFxyXG4gICAgICAgICAgICBcInN0YXRpY1NpemVcIjogNSxcclxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwic3Nhb01hcFwiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcInRleHR1cmVcIiwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJ9LFxyXG4gICAgICAgIFwiZW52aXJvbm1lbnRcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJ0ZXh0dXJlXCIsIFwic291cmNlXCI6IFwidW5pZm9ybVwifVxyXG59O1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3lzdGVtQ29uZmlndXJhdGlvbihjb250ZXh0KSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gU1lTVEVNX0NPTlRFWFRfVEVNUExBVEU7XHJcbiAgICB2YXIgZXh0ID0gY29udGV4dC5nZXRFeHRlbnNpb25CeU5hbWUoR0xDb250ZXh0LkVYVEVOU0lPTlMuU1RBTkRBUkRfREVSSVZBVEVTKTtcclxuICAgIGlmIChleHQpIHtcclxuICAgICAgICByZXN1bHQuZndpZHRoID0ge3R5cGU6IFNoYWRlLlRZUEVTLkZVTkNUSU9OfTtcclxuICAgICAgICByZXN1bHQuZHggPSB7dHlwZTogU2hhZGUuVFlQRVMuRlVOQ1RJT059O1xyXG4gICAgICAgIHJlc3VsdC5keSA9IHt0eXBlOiBTaGFkZS5UWVBFUy5GVU5DVElPTn07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgaWYgKCFzaW5nbGV0b24pIHtcclxuICAgICAgICBzaW5nbGV0b24gPSBjcmVhdGVTeXN0ZW1Db25maWd1cmF0aW9uKGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNpbmdsZXRvbjtcclxufTtcclxuXHJcblxyXG5cclxuIiwidmFyIEpTU2hhZGVyQ29tcG9zZXIgPSByZXF1aXJlKFwiLi9qcy9qc3NoYWRlcmNvbXBvc2VyLmpzXCIpO1xyXG52YXIgVVJOU2hhZGVyQ29tcG9zZXIgPSByZXF1aXJlKFwiLi91cm4vdXJuc2hhZGVyY29tcG9zZXIuanNcIik7XHJcbnZhciBEZWZhdWx0Q29tcG9zZXIgPSByZXF1aXJlKFwiLi9hYnN0cmFjdHNoYWRlcmNvbXBvc2VyLmpzXCIpLkRlZmF1bHRDb21wb3NlcjtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0dMQ29udGV4dH0gY29udGV4dFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBTaGFkZXJDb21wb3NlckZhY3RvcnkgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgIC8qKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsIElTaGFkZXJDb21wb3Nlcj59ICovXHJcbiAgICB0aGlzLmNvbXBvc2VycyA9IHt9O1xyXG4gICAgdGhpcy5kZWZhdWx0Q29tcG9zZXIgPSBuZXcgRGVmYXVsdENvbXBvc2VyKGNvbnRleHQpO1xyXG4gICAgdGhpcy5saWdodFZhbHVlc0RpcnR5ID0gdHJ1ZTtcclxufTtcclxuXHJcblxyXG5YTUwzRC5leHRlbmQoU2hhZGVyQ29tcG9zZXJGYWN0b3J5LnByb3RvdHlwZSwge1xyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtNYXRlcmlhbENvbmZpZ3VyYXRpb259IG1hdGVyaWFsQ29uZmlndXJhdGlvblxyXG4gICAgICogQHJldHVybnMge0lTaGFkZXJDb21wb3Nlcn1cclxuICAgICAqL1xyXG4gICAgY3JlYXRlQ29tcG9zZXJGcm9tTWF0ZXJpYWxDb25maWd1cmF0aW9uOiBmdW5jdGlvbiAobWF0ZXJpYWxDb25maWd1cmF0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFtYXRlcmlhbENvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdENvbXBvc2VyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jb21wb3NlcnNbbWF0ZXJpYWxDb25maWd1cmF0aW9uLmlkXTtcclxuICAgICAgICBpZiAoIXJlc3VsdCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1vZGVsVHlwZSA9IG1hdGVyaWFsQ29uZmlndXJhdGlvbi5tb2RlbC50eXBlO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChtb2RlbFR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidXJuXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBVUk5TaGFkZXJDb21wb3Nlcih0aGlzLmNvbnRleHQsIG1hdGVyaWFsQ29uZmlndXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L2phdmFzY3JpcHRcIjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L3NoYWRlLWphdmFzY3JpcHRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEpTU2hhZGVyQ29tcG9zZXIodGhpcy5jb250ZXh0LCBtYXRlcmlhbENvbmZpZ3VyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNhbiBub3QgY3JlYXRlIHNoYWRlciBvZiB0eXBlOlwiLCBtb2RlbFR5cGUsIG1hdGVyaWFsQ29uZmlndXJhdGlvbi5tb2RlbClcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiTm8gc2hhZGVyIGNvdWxkIGJlIGNyZWF0ZWQgZm9yICdcIiArIG1hdGVyaWFsQ29uZmlndXJhdGlvbi5uYW1lICsgXCInOlwiLCBlLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5kZWZhdWx0Q29tcG9zZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb3NlcnNbbWF0ZXJpYWxDb25maWd1cmF0aW9uLmlkXSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5nZXRTdGF0aXN0aWNzKCkubWF0ZXJpYWxzKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCB0aGlzLmRlZmF1bHRDb21wb3NlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VGVtcGxhdGVCeUlkOiBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wb3NlcnNbaWRdO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChzY2VuZSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5jb21wb3NlcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wb3NlcnNbaV0udXBkYXRlKHNjZW5lLCB7dXBkYXRlTGlnaHRWYWx1ZXM6IHRoaXMubGlnaHRWYWx1ZXNEaXJ0eX0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxpZ2h0VmFsdWVzRGlydHkgPSBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0TGlnaHRTdHJ1Y3R1cmVEaXJ0eTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2V0U2hhZGVyUmVjb21waWxlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNoYWRlclJlY29tcGlsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5jb21wb3NlcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wb3NlcnNbaV0uc2V0U2hhZGVyUmVjb21waWxlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVTeXN0ZW1Vbmlmb3JtczogZnVuY3Rpb24gKG5hbWVzLCBzY2VuZSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5jb21wb3NlcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wb3NlcnNbaV0udXBkYXRlU3lzdGVtVW5pZm9ybXMobmFtZXMsIHNjZW5lKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldExpZ2h0VmFsdWVDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmNvbXBvc2Vycykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBvc2Vyc1tpXS51cGRhdGVMaWdodFZhbHVlcyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNoYWRlckNvbXBvc2VyRmFjdG9yeTtcclxuXHJcblxyXG4iLCJ2YXIgRVZFTlRfVFlQRSA9IHJlcXVpcmUoXCIuLi8uLi9yZW5kZXJlci9zY2VuZS9jb25zdGFudHMuanNcIikuRVZFTlRfVFlQRTtcclxudmFyIFRhcmdldHMgPSByZXF1aXJlKFwiLi4vYmFzZS9yZW5kZXJ0YXJnZXRcIik7XHJcblxyXG52YXIgTGlnaHRQYXNzID0gcmVxdWlyZShcIi4uL3JlbmRlci1wYXNzZXMvbGlnaHQtcGFzc1wiKTtcclxudmFyIFBvaW50TGlnaHRQYXNzID0gcmVxdWlyZShcIi4uL3JlbmRlci1wYXNzZXMvcG9pbnRsaWdodC1wYXNzXCIpO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7R0xDb250ZXh0fSBjb250ZXh0XHJcbiAqIEBwYXJhbSB7R0xTY2VuZX0gc2NlbmVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgU2hhZG93TWFwU2VydmljZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBzY2VuZSkge1xyXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgIHNjZW5lLm9uKEVWRU5UX1RZUEUuTElHSFRfU1RSVUNUVVJFX0NIQU5HRUQsIHRoaXMub25MaWdodFN0cnVjdHVyZUNoYW5nZWQuYmluZCh0aGlzKSk7XHJcbiAgICBzY2VuZS5vbihFVkVOVF9UWVBFLkxJR0hUX1ZBTFVFX0NIQU5HRUQsIHRoaXMub25MaWdodFZhbHVlQ2hhbmdlZC5iaW5kKHRoaXMpKTtcclxuICAgIHNjZW5lLm9uKEVWRU5UX1RZUEUuU0NFTkVfU0hBUEVfQ0hBTkdFRCwgdGhpcy5vblNjZW5lU2hhcGVDaGFuZ2VkLmJpbmQodGhpcykpO1xyXG5cclxuICAgIHRoaXMuc2hhZG93TWFwSW5mb3MgPSBbXTtcclxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG59O1xyXG5cclxuWE1MM0QuZXh0ZW5kKFNoYWRvd01hcFNlcnZpY2UucHJvdG90eXBlLCB7XHJcbiAgICBvbkxpZ2h0U3RydWN0dXJlQ2hhbmdlZDogZnVuY3Rpb24gKGxpZ2h0LCByZW1vdmVkKSB7XHJcbiAgICAgICAgdmFyIHNoYWRvd01hcEluZm9zID0gdGhpcy5zaGFkb3dNYXBJbmZvcztcclxuICAgICAgICBpZiAocmVtb3ZlZCkge1xyXG4gICAgICAgICAgICByZW1vdmVMaWdodChzaGFkb3dNYXBJbmZvcywgbGlnaHQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChsaWdodE5lZWRzU2hhZG93TWFwKGxpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgYWRkTGlnaHQoc2hhZG93TWFwSW5mb3MsIGxpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFJlbmRlcmluZyhcImxpZ2h0IGFkZGVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBvbkxpZ2h0VmFsdWVDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyaW5nKFwibGlnaHQgdmFsdWUgY2hhbmdlZFwiKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25TY2VuZVNoYXBlQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlcmluZyhcInNjZW5lIHNoYXBlIGNoYW5nZWRcIik7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlcXVlc3RSZW5kZXJpbmc6IGZ1bmN0aW9uKC8qcmVhc29uKi8pIHtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlRm9yUmVuZGVyaW5nOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZih0aGlzLmRpcnR5KSB7XHJcbiAgICAgICAgICAgIHZhciBzaGFkb3dNYXBzID0gdGhpcy5zaGFkb3dNYXBJbmZvcztcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFkb3dNYXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzaGFkb3dNYXBzW2ldLnBhc3MucmVuZGVyU2NlbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBmaWxsR2xvYmFsUGFyYW1ldGVyczogZnVuY3Rpb24oZ2xvYmFscykge1xyXG4gICAgICAgIHZhciBzaGFkb3dVbml0cyA9IG1lcmdlU2hhZG93UGFyYW1ldGVycyh0aGlzLnNoYWRvd01hcEluZm9zKTtcclxuICAgICAgICBYTUwzRC5leHRlbmQoZ2xvYmFscywgc2hhZG93VW5pdHMpO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5mdW5jdGlvbiBsaWdodE5lZWRzU2hhZG93TWFwKGxpZ2h0KSB7XHJcbiAgICByZXR1cm4gISFsaWdodC5tb2RlbC5nZXRQYXJhbWV0ZXIoXCJjYXN0U2hhZG93XCIpWzBdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRMaWdodChzaGFkb3dNYXBJbmZvcywgbGlnaHQpIHtcclxuICAgIHZhciBjb250ZXh0ID0gbGlnaHQuc2NlbmUuY29udGV4dDtcclxuICAgIHZhciBwYXNzSW5mbyA9IGNyZWF0ZVBhc3NJbmZvKGxpZ2h0LCBjb250ZXh0KTtcclxuICAgIHNoYWRvd01hcEluZm9zLnB1c2gocGFzc0luZm8pO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlTGlnaHQoc2hhZG93TWFwSW5mb3MsIGxpZ2h0KSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYWRvd01hcEluZm9zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHNoYWRvd01hcEluZm9zW2ldLmxpZ2h0ID09PSBsaWdodCkge1xyXG4gICAgICAgICAgICBzaGFkb3dNYXBJbmZvcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBGcmVlIHBhc3MgYW5kIG90aGVyIHJlc291cmNlcywgZnJlZSB0ZXh0dXJlIHNsb3RcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlUGFzc0luZm8obGlnaHQsIGNvbnRleHQpIHtcclxuICAgIHZhciBzaXplID0gTWF0aC5tYXgoY29udGV4dC5jYW52YXNUYXJnZXQud2lkdGgsIGNvbnRleHQuY2FudmFzVGFyZ2V0LmhlaWdodCkgKiAyO1xyXG4gICAgdmFyIHBhcmFtcyA9IHtcclxuICAgICAgICB3aWR0aDogc2l6ZSxcclxuICAgICAgICBoZWlnaHQ6IHNpemUsXHJcbiAgICAgICAgY29sb3JGb3JtYXQ6IGNvbnRleHQuZ2wuUkdCQSxcclxuICAgICAgICBkZXB0aEZvcm1hdDogY29udGV4dC5nbC5ERVBUSF9DT01QT05FTlQxNixcclxuICAgICAgICBzdGVuY2lsRm9ybWF0OiBudWxsLFxyXG4gICAgICAgIGRlcHRoQXNSZW5kZXJidWZmZXI6IHRydWVcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHBhc3MgPSBsaWdodC5tb2RlbC5pZCA9PSBcInBvaW50XCIgPyBjcmVhdGVQb2ludExpZ2h0UGFzcyhsaWdodCwgY29udGV4dCwgcGFyYW1zKSA6IGNyZWF0ZUxpZ2h0UGFzcyhsaWdodCwgY29udGV4dCwgcGFyYW1zKTtcclxuICAgIHBhc3MuaW5pdChjb250ZXh0KTtcclxuXHJcbiAgICAvLyBCaW5kIHRhcmdldCBpbiBvcmRlciB0byBjcmVhdGUgdGV4dHVyZSBtYXBcclxuICAgIHBhc3Mub3V0cHV0LmJpbmQoKTtcclxuXHJcbiAgICAvLyBUT0RPOiBCZXR0ZXIgd2F5IHRvIGZpeCB0aGUgdGV4dHVyZSB1bml0P1xyXG4gICAgdmFyIHVuaXRFbnRyeSA9IGNvbnRleHQudGV4dHVyZU1hbmFnZXIuZ2V0RW50cnkocGFzcy5vdXRwdXQuY29sb3JUYXJnZXQuaGFuZGxlLmlkKTtcclxuICAgIHVuaXRFbnRyeS5maXhlZCA9IHRydWU7XHJcblxyXG4gICAgcGFzcy5vdXRwdXQudW5iaW5kKCk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsaWdodDogbGlnaHQsIHBhc3M6IHBhc3MsIHNsb3Q6IHVuaXRFbnRyeS5zbG90XHJcbiAgICB9O1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTGlnaHRQYXNzKGxpZ2h0LCBjb250ZXh0LCBwYXJhbXMpIHtcclxuICAgIHZhciBsaWdodEZyYW1lYnVmZmVyID0gbmV3IFRhcmdldHMuR0xSZW5kZXJUYXJnZXQoY29udGV4dCwgcGFyYW1zKTtcclxuICAgIHJldHVybiBuZXcgTGlnaHRQYXNzKHtjb250ZXh0OiBjb250ZXh0fSwgbGlnaHRGcmFtZWJ1ZmZlciwgbGlnaHQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVQb2ludExpZ2h0UGFzcyhsaWdodCwgY29udGV4dCwgcGFyYW1zKSB7XHJcbiAgICB2YXIgbGlnaHRGcmFtZWJ1ZmZlciA9IG5ldyBUYXJnZXRzLkdMQ3ViZU1hcFJlbmRlclRhcmdldChjb250ZXh0LCBwYXJhbXMpO1xyXG4gICAgcmV0dXJuIG5ldyBQb2ludExpZ2h0UGFzcyh7Y29udGV4dDogY29udGV4dH0sIGxpZ2h0RnJhbWVidWZmZXIsIGxpZ2h0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWVyZ2VTaGFkb3dQYXJhbWV0ZXJzKHNoYWRvd01hcEluZm9zKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBbXCJzcG90XCIsIFwicG9pbnRcIiwgXCJkaXJlY3Rpb25hbFwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgdmFyIHNhbWVNb2RlbCA9IHNoYWRvd01hcEluZm9zLmZpbHRlcihmdW5jdGlvbihpbmZvKSB7IHJldHVybiBpbmZvLmxpZ2h0Lm1vZGVsLmlkID09IG1vZGVsOyB9KTtcclxuICAgICAgICByZXN1bHRbbW9kZWwgKyBcIkxpZ2h0U2hhZG93TWFwXCJdID0gc2FtZU1vZGVsLm1hcChmdW5jdGlvbiAoaW5mbykge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5mby5zbG90O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNoYWRvd01hcFNlcnZpY2U7XHJcbiIsIlhNTDNELm1hdGVyaWFscy5yZWdpc3RlcihcImRpZmZ1c2VcIiwge1xyXG5cclxuICAgIHZlcnRleCA6IFtcclxuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1wiLFxyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzMgbm9ybWFsO1wiLFxyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzMgY29sb3I7XCIsXHJcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMiB0ZXhjb29yZDtcIixcclxuXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ05vcm1hbDtcIixcclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnVmVydGV4UG9zaXRpb247XCIsXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ0V5ZVZlY3RvcjtcIixcclxuICAgICAgICBcInZhcnlpbmcgdmVjMiBmcmFnVGV4Q29vcmQ7XCIsXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ1ZlcnRleENvbG9yO1wiLFxyXG5cclxuICAgICAgICBcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4O1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDtcIixcclxuICAgICAgICBcInVuaWZvcm0gbWF0MyBtb2RlbFZpZXdNYXRyaXhOO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIGV5ZVBvc2l0aW9uO1wiLFxyXG5cclxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXHJcbiAgICAgICAgXCIgICAgdmVjMyBwb3MgPSBwb3NpdGlvbjtcIixcclxuICAgICAgICBcIiAgICB2ZWMzIG5vcm0gPSBub3JtYWw7XCIsXHJcblxyXG4gICAgICAgIFwiICAgIGdsX1Bvc2l0aW9uID0gbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQocG9zLCAxLjApO1wiLFxyXG4gICAgICAgIFwiICAgIGZyYWdOb3JtYWwgPSBub3JtYWxpemUobW9kZWxWaWV3TWF0cml4TiAqIG5vcm0pO1wiLFxyXG4gICAgICAgIFwiICAgIGZyYWdWZXJ0ZXhQb3NpdGlvbiA9IChtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvcywgMS4wKSkueHl6O1wiLFxyXG4gICAgICAgIFwiICAgIGZyYWdFeWVWZWN0b3IgPSBub3JtYWxpemUoZnJhZ1ZlcnRleFBvc2l0aW9uKTtcIixcclxuICAgICAgICBcIiAgICBmcmFnVGV4Q29vcmQgPSB0ZXhjb29yZDtcIixcclxuICAgICAgICBcIiAgICBmcmFnVmVydGV4Q29sb3IgPSBjb2xvcjtcIixcclxuICAgICAgICBcIn1cIlxyXG4gICAgXS5qb2luKFwiXFxuXCIpLFxyXG5cclxuICAgIGZyYWdtZW50IDogW1xyXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCBhbWJpZW50SW50ZW5zaXR5O1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2VDb2xvcjtcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBlbWlzc2l2ZUNvbG9yO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIGJvb2wgdXNlVmVydGV4Q29sb3I7XCIsXHJcblxyXG4gICAgICAgIFwiI2lmIEhBU19FTUlTU0lWRVRFWFRVUkVcIixcclxuICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIGVtaXNzaXZlVGV4dHVyZTtcIixcclxuICAgICAgICBcIiNlbmRpZlwiLFxyXG4gICAgICAgIFwiI2lmIEhBU19ESUZGVVNFVEVYVFVSRVwiLFxyXG4gICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgZGlmZnVzZVRleHR1cmU7XCIsXHJcbiAgICAgICAgXCIjZW5kaWZcIixcclxuXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ05vcm1hbDtcIixcclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnVmVydGV4UG9zaXRpb247XCIsXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ0V5ZVZlY3RvcjtcIixcclxuICAgICAgICBcInZhcnlpbmcgdmVjMiBmcmFnVGV4Q29vcmQ7XCIsXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ1ZlcnRleENvbG9yO1wiLFxyXG5cclxuICAgICAgICBcIiNpZiBNQVhfUE9JTlRMSUdIVFMgPiAwXCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgcG9pbnRMaWdodEF0dGVudWF0aW9uW01BWF9QT0lOVExJR0hUU107XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uW01BWF9QT0lOVExJR0hUU107XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgcG9pbnRMaWdodEludGVuc2l0eVtNQVhfUE9JTlRMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBib29sIHBvaW50TGlnaHRPbltNQVhfUE9JTlRMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwiI2VuZGlmXCIsXHJcblxyXG4gICAgICAgIFwiI2lmIE1BWF9ESVJFQ1RJT05BTExJR0hUUyA+IDBcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uW01BWF9ESVJFQ1RJT05BTExJR0hUU107XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodEludGVuc2l0eVtNQVhfRElSRUNUSU9OQUxMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBib29sIGRpcmVjdGlvbmFsTGlnaHRPbltNQVhfRElSRUNUSU9OQUxMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwiI2VuZGlmXCIsXHJcblxyXG4gICAgICAgIFwiI2lmIE1BWF9TUE9UTElHSFRTID4gMFwiLFxyXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIHNwb3RMaWdodEF0dGVudWF0aW9uW01BWF9TUE9UTElHSFRTXTtcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBzcG90TGlnaHRQb3NpdGlvbltNQVhfU1BPVExJR0hUU107XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgc3BvdExpZ2h0SW50ZW5zaXR5W01BWF9TUE9UTElHSFRTXTtcIixcclxuICAgICAgICBcInVuaWZvcm0gYm9vbCBzcG90TGlnaHRPbltNQVhfU1BPVExJR0hUU107XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgc3BvdExpZ2h0RGlyZWN0aW9uW01BWF9TUE9UTElHSFRTXTtcIixcclxuICAgICAgICBcInVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0Q29zQ3V0b2ZmQW5nbGVbTUFYX1NQT1RMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCBzcG90TGlnaHRDb3NTb2Z0Q3V0b2ZmQW5nbGVbTUFYX1NQT1RMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCBzcG90TGlnaHRTb2Z0bmVzc1tNQVhfU1BPVExJR0hUU107XCIsXHJcbiAgICAgICAgXCIjZW5kaWZcIixcclxuXHJcbiAgICAgICAgXCJ2b2lkIG1haW4odm9pZCkge1wiLFxyXG4gICAgICAgIFwiICBmbG9hdCBhbHBoYSA9ICBtYXgoMC4wLCBvcGFjaXR5KTtcIixcclxuICAgICAgICBcIiAgdmVjMyBvYmpEaWZmdXNlID0gZGlmZnVzZUNvbG9yO1wiLFxyXG4gICAgICAgIFwiICBpZih1c2VWZXJ0ZXhDb2xvcilcIixcclxuICAgICAgICBcIiAgICBvYmpEaWZmdXNlICo9IGZyYWdWZXJ0ZXhDb2xvcjtcIixcclxuICAgICAgICBcIiAgI2lmIEhBU19ESUZGVVNFVEVYVFVSRVwiLFxyXG4gICAgICAgIFwiICAgIHZlYzQgdGV4RGlmZnVzZSA9IHRleHR1cmUyRChkaWZmdXNlVGV4dHVyZSwgZnJhZ1RleENvb3JkKTtcIixcclxuICAgICAgICBcIiAgICBhbHBoYSAqPSB0ZXhEaWZmdXNlLmE7XCIsXHJcbiAgICAgICAgXCIgICAgb2JqRGlmZnVzZSAqPSB0ZXhEaWZmdXNlLnJnYjtcIixcclxuICAgICAgICBcIiAgI2VuZGlmXCIsXHJcbiAgICAgICAgXCIgIGlmIChhbHBoYSA8IDAuMDUpIGRpc2NhcmQ7XCIsXHJcblxyXG4gICAgICAgIFwiICAjaWYgSEFTX0VNSVNTSVZFVEVYVFVSRVwiLFxyXG4gICAgICAgIFwiICAgIHZlYzMgY29sb3IgPSBlbWlzc2l2ZUNvbG9yICogdGV4dHVyZTJEKGVtaXNzaXZlVGV4dHVyZSwgZnJhZ1RleENvb3JkKS5yZ2IgKyAoYW1iaWVudEludGVuc2l0eSAqIG9iakRpZmZ1c2UpO1wiLFxyXG4gICAgICAgIFwiICAjZWxzZVwiLFxyXG4gICAgICAgIFwiICAgIHZlYzMgY29sb3IgPSBlbWlzc2l2ZUNvbG9yICsgKGFtYmllbnRJbnRlbnNpdHkgKiBvYmpEaWZmdXNlKTtcIixcclxuICAgICAgICBcIiAgI2VuZGlmXCIsXHJcblxyXG4gICAgICAgIFwiICAjaWYgTUFYX1BPSU5UTElHSFRTID4gMFwiLFxyXG4gICAgICAgIFwiICAgIGZvciAoaW50IGk9MDsgaTxNQVhfUE9JTlRMSUdIVFM7IGkrKykge1wiLFxyXG4gICAgICAgIFwiICAgICAgaWYgKCFwb2ludExpZ2h0T25baV0pXCIsXHJcbiAgICAgICAgXCIgICAgICAgICBjb250aW51ZTtcIixcclxuICAgICAgICBcIiAgICAgIHZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHBvaW50TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcIixcclxuICAgICAgICBcIiAgICAgIHZlYzMgTCA9IGxQb3NpdGlvbi54eXogLSBmcmFnVmVydGV4UG9zaXRpb247XCIsXHJcbiAgICAgICAgXCIgICAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKEwpO1wiLFxyXG4gICAgICAgIFwiICAgICAgTCA9IG5vcm1hbGl6ZShMKTtcIixcclxuICAgICAgICBcIiAgICAgIGZsb2F0IGF0dGVuID0gMS4wIC8gKHBvaW50TGlnaHRBdHRlbnVhdGlvbltpXS54ICsgcG9pbnRMaWdodEF0dGVudWF0aW9uW2ldLnkgKiBkaXN0ICsgcG9pbnRMaWdodEF0dGVudWF0aW9uW2ldLnogKiBkaXN0ICogZGlzdCk7XCIsXHJcbiAgICAgICAgXCIgICAgICB2ZWMzIElkaWZmID0gcG9pbnRMaWdodEludGVuc2l0eVtpXSAqIG9iakRpZmZ1c2UgKiBtYXgoZG90KGZyYWdOb3JtYWwsTCksMC4wKTtcIixcclxuICAgICAgICBcIiAgICAgIGNvbG9yID0gY29sb3IgKyBhdHRlbipJZGlmZjtcIixcclxuICAgICAgICBcIiAgICB9XCIsXHJcbiAgICAgICAgXCIgICNlbmRpZlwiLFxyXG5cclxuICAgICAgICBcIiNpZiBNQVhfRElSRUNUSU9OQUxMSUdIVFMgPiAwXCIsXHJcbiAgICAgICAgXCIgIGZvciAoaW50IGk9MDsgaTxNQVhfRElSRUNUSU9OQUxMSUdIVFM7IGkrKykge1wiLFxyXG4gICAgICAgIFwiICAgICAgaWYgKCFkaXJlY3Rpb25hbExpZ2h0T25baV0pXCIsXHJcbiAgICAgICAgXCIgICAgICAgICBjb250aW51ZTtcIixcclxuICAgICAgICBcIiAgICB2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNChkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uW2ldLCAwLjApO1wiLFxyXG4gICAgICAgIFwiICAgIHZlYzMgTCA9ICBub3JtYWxpemUoLWxEaXJlY3Rpb24ueHl6KTtcIixcclxuICAgICAgICBcIiAgICB2ZWMzIElkaWZmID0gZGlyZWN0aW9uYWxMaWdodEludGVuc2l0eVtpXSAqIG9iakRpZmZ1c2UgKiBtYXgoZG90KGZyYWdOb3JtYWwsTCksMC4wKTtcIixcclxuICAgICAgICBcIiAgICBjb2xvciA9IGNvbG9yICsgSWRpZmY7XCIsXHJcbiAgICAgICAgXCIgIH1cIixcclxuICAgICAgICBcIiNlbmRpZlwiLFxyXG5cclxuICAgICAgICBcIiNpZiBNQVhfU1BPVExJR0hUUyA+IDBcIixcclxuICAgICAgICBcIiAgZm9yIChpbnQgaT0wOyBpPE1BWF9TUE9UTElHSFRTOyBpKyspIHtcIixcclxuICAgICAgICBcIiAgICAgIGlmICghc3BvdExpZ2h0T25baV0pXCIsXHJcbiAgICAgICAgXCIgICAgICAgICBjb250aW51ZTtcIixcclxuICAgICAgICBcIiAgICB2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBzcG90TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcIixcclxuICAgICAgICBcIiAgICB2ZWMzIEwgPSBsUG9zaXRpb24ueHl6IC0gZnJhZ1ZlcnRleFBvc2l0aW9uO1wiLFxyXG4gICAgICAgIFwiICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgoTCk7XCIsXHJcbiAgICAgICAgXCIgICAgTCA9IG5vcm1hbGl6ZShMKTtcIixcclxuICAgICAgICBcIiAgICBmbG9hdCBhdHRlbiA9IDEuMCAvIChzcG90TGlnaHRBdHRlbnVhdGlvbltpXS54ICsgc3BvdExpZ2h0QXR0ZW51YXRpb25baV0ueSAqIGRpc3QgKyBzcG90TGlnaHRBdHRlbnVhdGlvbltpXS56ICogZGlzdCAqIGRpc3QpO1wiLFxyXG4gICAgICAgIFwiICAgIHZlYzMgSWRpZmYgPSBzcG90TGlnaHRJbnRlbnNpdHlbaV0gKiBvYmpEaWZmdXNlICogbWF4KGRvdChmcmFnTm9ybWFsLEwpLDAuMCk7XCIsXHJcbiAgICAgICAgXCIgICAgdmVjNCBsRGlyZWN0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoLXNwb3RMaWdodERpcmVjdGlvbltpXSwgMC4wKTtcIixcclxuICAgICAgICBcIiAgICB2ZWMzIEQgPSBub3JtYWxpemUobERpcmVjdGlvbi54eXopO1wiLFxyXG4gICAgICAgIFwiICAgIGZsb2F0IGFuZ2xlID0gZG90KEwsIEQpO1wiLFxyXG4gICAgICAgIFwiICAgIGlmKGFuZ2xlID4gc3BvdExpZ2h0Q29zQ3V0b2ZmQW5nbGVbaV0pIHtcIixcclxuICAgICAgICBcIiAgICAgICBmbG9hdCBzb2Z0bmVzcyA9IDEuMDtcIixcclxuICAgICAgICBcIiAgICAgICBpZiAoYW5nbGUgPCBzcG90TGlnaHRDb3NTb2Z0Q3V0b2ZmQW5nbGVbaV0pXCIsXHJcbiAgICAgICAgXCIgICAgICAgICAgIHNvZnRuZXNzID0gKGFuZ2xlIC0gc3BvdExpZ2h0Q29zQ3V0b2ZmQW5nbGVbaV0pIC8gIChzcG90TGlnaHRDb3NTb2Z0Q3V0b2ZmQW5nbGVbaV0gLSAgc3BvdExpZ2h0Q29zQ3V0b2ZmQW5nbGVbaV0pO1wiLFxyXG4gICAgICAgIFwiICAgICAgIGNvbG9yICs9IGF0dGVuICogc29mdG5lc3MgKiBJZGlmZjtcIixcclxuICAgICAgICBcIiAgICB9XCIsXHJcbiAgICAgICAgXCIgIH1cIixcclxuICAgICAgICBcIiNlbmRpZlwiLFxyXG5cclxuICAgICAgICBcIiAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgYWxwaGEpO1wiLFxyXG4gICAgICAgIFwifVwiXHJcbiAgICBdLmpvaW4oXCJcXG5cIiksXHJcblxyXG4gICAgYWRkRGlyZWN0aXZlczogZnVuY3Rpb24oZGlyZWN0aXZlcywgbGlnaHRzLCBwYXJhbXMpIHtcclxuICAgICAgICBbXCJwb2ludFwiLCBcImRpcmVjdGlvbmFsXCIsIFwic3BvdFwiXS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBudW1MaWdodHMgPSBsaWdodHMuZ2V0TW9kZWxDb3VudCh0eXBlKTtcclxuICAgICAgICAgICAgZGlyZWN0aXZlcy5wdXNoKFwiTUFYX1wiICsgdHlwZS50b1VwcGVyQ2FzZSgpICsgXCJMSUdIVFMgXCIgKyBudW1MaWdodHMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGRpcmVjdGl2ZXMucHVzaChcIkhBU19ESUZGVVNFVEVYVFVSRSBcIiArICgnZGlmZnVzZVRleHR1cmUnIGluIHBhcmFtcyA/IFwiMVwiIDogXCIwXCIpKTtcclxuICAgICAgICBkaXJlY3RpdmVzLnB1c2goXCJIQVNfRU1JU1NJVkVURVhUVVJFIFwiICsgKCdlbWlzc2l2ZVRleHR1cmUnIGluIHBhcmFtcyA/IFwiMVwiIDogXCIwXCIpKTtcclxuICAgIH0sXHJcbiAgICBoYXNUcmFuc3BhcmVuY3k6IGZ1bmN0aW9uKHBhcmFtcykge1xyXG4gICAgICAgIHJldHVybiBwYXJhbXMub3BhY2l0eSAmJiBwYXJhbXMub3BhY2l0eS5nZXRWYWx1ZSgpWzBdIDwgMTtcclxuICAgIH0sXHJcbiAgICB1bmlmb3Jtczoge1xyXG4gICAgICAgIGRpZmZ1c2VDb2xvciAgICA6IFsxLjAsIDEuMCwgMS4wXSxcclxuICAgICAgICBlbWlzc2l2ZUNvbG9yICAgOiBbMC4wLCAwLjAsIDAuMF0sXHJcbiAgICAgICAgb3BhY2l0eSAgICAgICAgIDogMS4wLFxyXG4gICAgICAgIGFtYmllbnRJbnRlbnNpdHk6IDAuMCxcclxuICAgICAgICB1c2VWZXJ0ZXhDb2xvciA6IGZhbHNlXHJcbiAgICB9LFxyXG4gICAgc2FtcGxlcnM6IHtcclxuICAgICAgICBkaWZmdXNlVGV4dHVyZSA6IG51bGwsXHJcbiAgICAgICAgZW1pc3NpdmVUZXh0dXJlIDogbnVsbFxyXG4gICAgfSxcclxuICAgIGF0dHJpYnV0ZXM6IHtcclxuICAgICAgICBub3JtYWwgOiB7XHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0ZXhjb29yZDogbnVsbCxcclxuICAgICAgICBjb2xvcjogbnVsbFxyXG4gICAgfVxyXG59KTtcclxuIiwiWE1MM0QubWF0ZXJpYWxzLnJlZ2lzdGVyKFwibWF0dGVcIiwge1xyXG5cclxuICAgIHZlcnRleDogW1xyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XCIsXHJcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMyBjb2xvcjtcIixcclxuXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ1ZlcnRleENvbG9yO1wiLFxyXG5cclxuICAgICAgICBcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4O1wiLFxyXG5cclxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXHJcbiAgICAgICAgXCIgICBmcmFnVmVydGV4Q29sb3IgPSBjb2xvcjtcIixcclxuICAgICAgICBcIiAgIGdsX1Bvc2l0aW9uID0gbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XCIsXHJcbiAgICAgICAgXCJ9XCJcclxuICAgIF0uam9pbihcIlxcblwiKSxcclxuXHJcbiAgICBmcmFnbWVudDogW1xyXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2VDb2xvcjtcIixcclxuICAgICAgICBcInVuaWZvcm0gYm9vbCB1c2VWZXJ0ZXhDb2xvcjtcIixcclxuXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ1ZlcnRleENvbG9yO1wiLFxyXG5cclxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXHJcbiAgICAgICAgXCIgICAgdmVjMyBjb2xvciA9IGRpZmZ1c2VDb2xvcjtcIixcclxuICAgICAgICBcIiAgICBpZiAodXNlVmVydGV4Q29sb3IpXCIsXHJcbiAgICAgICAgXCIgICAgICAgY29sb3IgKj0gIGZyYWdWZXJ0ZXhDb2xvcjtcIixcclxuICAgICAgICBcIiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCAxLjApO1wiLFxyXG4gICAgICAgIFwifVwiXHJcbiAgICBdLmpvaW4oXCJcXG5cIiksXHJcblxyXG4gICAgdW5pZm9ybXM6IHtcclxuICAgICAgICBkaWZmdXNlQ29sb3IgOiBbMS4wLCAxLjAsIDEuMF0sXHJcbiAgICAgICAgdXNlVmVydGV4Q29sb3I6IGZhbHNlXHJcbiAgICB9LFxyXG4gICAgYXR0cmlidXRlczoge1xyXG4gICAgICAgIGNvbG9yOiBudWxsLFxyXG4gICAgICAgIG5vcm1hbDogbnVsbCAvLyBGb3IgcGlja2luZ1xyXG4gICAgfVxyXG59KTtcclxuXHJcblhNTDNELm1hdGVyaWFscy5yZWdpc3RlcihcImZsYXRcIiwgWE1MM0QubWF0ZXJpYWxzLmdldFNjcmlwdChcIm1hdHRlXCIpKTtcclxuIiwiWE1MM0QubWF0ZXJpYWxzLnJlZ2lzdGVyKFwicGhvbmdcIiwge1xyXG5cclxuICAgIHZlcnRleCA6IFtcclxuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1wiLFxyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzMgbm9ybWFsO1wiLFxyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzMgY29sb3I7XCIsXHJcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMiB0ZXhjb29yZDtcIixcclxuXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ05vcm1hbDtcIixcclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnVmVydGV4UG9zaXRpb247XCIsXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ0V5ZVZlY3RvcjtcIixcclxuICAgICAgICBcInZhcnlpbmcgdmVjMiBmcmFnVGV4Q29vcmQ7XCIsXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ1ZlcnRleENvbG9yO1wiLFxyXG5cclxuICAgICAgICBcIiNpZiAoSEFTX1BPSU5UTElHSFRfU0hBRE9XTUFQUyB8fCBIQVNfRElSRUNUSU9OQUxMSUdIVF9TSEFET1dNQVBTIHx8IEhBU19TUE9UTElHSFRfU0hBRE9XTUFQUylcIixcclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnV29ybGRQb3NpdGlvbjtcIiwgLy9uZWVkZWQgYnkgYW55IG9mIHRoZSBsaWdodCB0eXBlc1xyXG4gICAgICAgIFwiI2VuZGlmXCIsXHJcblxyXG4gICAgICAgIFwidW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBtYXQ0IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXg7XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4O1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBtYXQzIG1vZGVsVmlld01hdHJpeE47XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgZXllUG9zaXRpb247XCIsXHJcblxyXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcclxuICAgICAgICBcIiAgICB2ZWMzIHBvcyA9IHBvc2l0aW9uO1wiLFxyXG4gICAgICAgIFwiICAgIHZlYzMgbm9ybSA9IG5vcm1hbDtcIixcclxuICAgICAgICBcIiAgICBnbF9Qb3NpdGlvbiA9IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggKiB2ZWM0KHBvcywgMS4wKTtcIixcclxuICAgICAgICBcIiAgICBmcmFnTm9ybWFsID0gbm9ybWFsaXplKG1vZGVsVmlld01hdHJpeE4gKiBub3JtKTtcIixcclxuICAgICAgICBcIiAgICBmcmFnVmVydGV4UG9zaXRpb24gPSAobW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3MsIDEuMCkpLnh5ejtcIixcclxuICAgICAgICBcIiAgICBmcmFnRXllVmVjdG9yID0gbm9ybWFsaXplKGZyYWdWZXJ0ZXhQb3NpdGlvbik7XCIsXHJcbiAgICAgICAgXCIgICAgZnJhZ1RleENvb3JkID0gdGV4Y29vcmQ7XCIsXHJcbiAgICAgICAgXCIgICAgZnJhZ1ZlcnRleENvbG9yID0gY29sb3I7XCIsXHJcbiAgICAgICAgXCIjaWYgKEhBU19QT0lOVExJR0hUX1NIQURPV01BUFMgfHwgSEFTX0RJUkVDVElPTkFMTElHSFRfU0hBRE9XTUFQUyB8fCBIQVNfU1BPVExJR0hUX1NIQURPV01BUFMpXCIsXHJcbiAgICAgICAgXCIgICAgZnJhZ1dvcmxkUG9zaXRpb24gPSAobW9kZWxNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApKS54eXo7XCIsXHJcbiAgICAgICAgXCIjZW5kaWZcIixcclxuICAgICAgICBcIn1cIlxyXG4gICAgXS5qb2luKFwiXFxuXCIpLFxyXG5cclxuICAgIGZyYWdtZW50IDogW1xyXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCBhbWJpZW50SW50ZW5zaXR5O1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2VDb2xvcjtcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBlbWlzc2l2ZUNvbG9yO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCBzaGluaW5lc3M7XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgc3BlY3VsYXJDb2xvcjtcIixcclxuICAgICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuICAgICAgICBcInVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBib29sIHVzZVZlcnRleENvbG9yO1wiLFxyXG5cdFx0XCJ1bmlmb3JtIHZlYzMgY29vcmRzO1wiLFxyXG5cclxuICAgICAgICBcIiNpZiBIQVNfRU1JU1NJVkVURVhUVVJFXCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCBlbWlzc2l2ZVRleHR1cmU7XCIsXHJcbiAgICAgICAgXCIjZW5kaWZcIixcclxuICAgICAgICBcIiNpZiBIQVNfRElGRlVTRVRFWFRVUkVcIixcclxuICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIGRpZmZ1c2VUZXh0dXJlO1wiLFxyXG4gICAgICAgIFwiI2VuZGlmXCIsXHJcbiAgICAgICAgXCIjaWYgSEFTX1NQRUNVTEFSVEVYVFVSRVwiLFxyXG4gICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgc3BlY3VsYXJUZXh0dXJlO1wiLFxyXG4gICAgICAgIFwiI2VuZGlmXCIsXHJcblxyXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIGZyYWdOb3JtYWw7XCIsXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ1ZlcnRleFBvc2l0aW9uO1wiLFxyXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIGZyYWdFeWVWZWN0b3I7XCIsXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzIgZnJhZ1RleENvb3JkO1wiLFxyXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIGZyYWdWZXJ0ZXhDb2xvcjtcIixcclxuXHJcbiAgICAgICAgXCIjaWYgKEhBU19QT0lOVExJR0hUX1NIQURPV01BUFMgfHwgSEFTX0RJUkVDVElPTkFMTElHSFRfU0hBRE9XTUFQUyB8fCBIQVNfU1BPVExJR0hUX1NIQURPV01BUFMpXCIsXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ1dvcmxkUG9zaXRpb247XCIsICAvL2lmIHRoZXJlIGlzIFNoYWRvdyB3ZSBuZWVkIHdvcmxkIHBvc2l0aW9uIGFuZCB1bnBhY2tpbmcgZnVuY3Rpb25cclxuICAgICAgICBcImZsb2F0IHVucGFja0RlcHRoKCBjb25zdCBpbiB2ZWM0IHJnYmFfZGVwdGggKSB7XCIsXHJcbiAgICAgICAgXCIgIGNvbnN0IHZlYzQgYml0X3NoaWZ0ID0gdmVjNCggMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICksIDEuMCAvIDI1Ni4wLCAxLjAgKTtcIixcclxuICAgICAgICBcIiAgZmxvYXQgZGVwdGggPSBkb3QoIHJnYmFfZGVwdGgsIGJpdF9zaGlmdCApO1wiLFxyXG4gICAgICAgIFwiICByZXR1cm4gZGVwdGg7XCIsXHJcbiAgICAgICAgXCJ9XCIsXHJcbiAgICAgICAgXCIjZW5kaWZcIixcclxuXHJcbiAgICAgICAgXCIjaWYgTUFYX1BPSU5UTElHSFRTID4gMFwiLFxyXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRBdHRlbnVhdGlvbltNQVhfUE9JTlRMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRQb3NpdGlvbltNQVhfUE9JTlRMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRJbnRlbnNpdHlbTUFYX1BPSU5UTElHSFRTXTtcIixcclxuICAgICAgICBcInVuaWZvcm0gYm9vbCBwb2ludExpZ2h0T25bTUFYX1BPSU5UTElHSFRTXTtcIixcclxuICAgICAgICBcInVuaWZvcm0gYm9vbCBwb2ludExpZ2h0Q2FzdFNoYWRvd1tNQVhfUE9JTlRMSUdIVFNdO1wiLFxyXG4gICAgICAgICAgICBcIiNpZiBIQVNfUE9JTlRMSUdIVF9TSEFET1dNQVBTXCIsXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSBzYW1wbGVyQ3ViZSBwb2ludExpZ2h0U2hhZG93TWFwW01BWF9QT0lOVExJR0hUU107XCIsXHJcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0U2hhZG93Qmlhc1tNQVhfUE9JTlRMSUdIVFNdO1wiLFxyXG4gICAgICAgICAgICBcInVuaWZvcm0gdmVjMiBwb2ludExpZ2h0TmVhckZhcltNQVhfUE9JTlRMSUdIVFNdO1wiLFxyXG4gICAgICAgICAgICBcImZsb2F0IHZlY1RvRGVwdGgodmVjMyB2ZWMsIGZsb2F0IG4sIGZsb2F0IGYpe1wiLFxyXG4gICAgICAgICAgICAgICAgXCJ2ZWMzIGFic1ZlYyA9IGFicyh2ZWMpO1wiICtcclxuICAgICAgICAgICAgICAgIFwiZmxvYXQgbWF4Q29tcCA9IG1heChhYnNWZWMueCwgbWF4KGFic1ZlYy55LCBhYnNWZWMueikpO1wiLFxyXG4gICAgICAgICAgICAgICAgXCJmbG9hdCByZXMgPSAoZituKS8oZi1uKS0oMi4wKmYqbikvKGYtbikvbWF4Q29tcDtcIixcclxuICAgICAgICAgICAgICAgIFwicmV0dXJuIHJlcyowLjUrMC41O1wiLFxyXG4gICAgICAgICAgICBcIn1cIixcclxuICAgICAgICAgICAgXCIjZW5kaWZcIixcclxuICAgICAgICBcIiNlbmRpZlwiLFxyXG5cclxuICAgICAgICBcIiNpZiBNQVhfU1BPVExJR0hUUyA+IDBcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBzcG90TGlnaHRBdHRlbnVhdGlvbltNQVhfU1BPVExJR0hUU107XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgc3BvdExpZ2h0UG9zaXRpb25bTUFYX1NQT1RMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIHNwb3RMaWdodEludGVuc2l0eVtNQVhfU1BPVExJR0hUU107XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIGJvb2wgc3BvdExpZ2h0T25bTUFYX1NQT1RMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIHNwb3RMaWdodERpcmVjdGlvbltNQVhfU1BPVExJR0hUU107XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodENvc0N1dG9mZkFuZ2xlW01BWF9TUE9UTElHSFRTXTtcIixcclxuICAgICAgICBcInVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0Q29zU29mdEN1dG9mZkFuZ2xlW01BWF9TUE9UTElHSFRTXTtcIixcclxuICAgICAgICBcInVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0U29mdG5lc3NbTUFYX1NQT1RMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBib29sIHNwb3RMaWdodENhc3RTaGFkb3dbTUFYX1NQT1RMSUdIVFNdO1wiLFxyXG4gICAgICAgICAgICBcIiNpZiBIQVNfU1BPVExJR0hUX1NIQURPV01BUFNcIixcclxuICAgICAgICAgICAgXCJ1bmlmb3JtIG1hdDQgc3BvdExpZ2h0TWF0cml4WyBNQVhfU1BPVExJR0hUUyBdO1wiLC8vdXNlZCBmb3Igc2hhZG93bWFwY29vcmQgY2FsY3VsYXRpb25cclxuICAgICAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCBzcG90TGlnaHRTaGFkb3dNYXBbTUFYX1NQT1RMSUdIVFNdO1wiLFxyXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0U2hhZG93Qmlhc1tNQVhfU1BPVExJR0hUU107XCIsXHJcbiAgICAgICAgICAgIFwiI2VuZGlmXCIsXHJcbiAgICAgICAgXCIjZW5kaWZcIixcclxuXHJcblxyXG4gICAgICAgIFwiI2lmIE1BWF9ESVJFQ1RJT05BTExJR0hUUyA+IDBcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uW01BWF9ESVJFQ1RJT05BTExJR0hUU107XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodEludGVuc2l0eVtNQVhfRElSRUNUSU9OQUxMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBib29sIGRpcmVjdGlvbmFsTGlnaHRPbltNQVhfRElSRUNUSU9OQUxMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBib29sIGRpcmVjdGlvbmFsTGlnaHRDYXN0U2hhZG93W01BWF9ESVJFQ1RJT05BTExJR0hUU107XCIsXHJcbiAgICAgICAgICAgIFwiI2lmIEhBU19ESVJFQ1RJT05BTExJR0hUX1NIQURPV01BUFNcIixcclxuICAgICAgICAgICAgXCJ1bmlmb3JtIG1hdDQgZGlyZWN0aW9uYWxMaWdodE1hdHJpeFtNQVhfRElSRUNUSU9OQUxMSUdIVFNdO1wiLFxyXG4gICAgICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dNYXBbTUFYX0RJUkVDVElPTkFMTElHSFRTXTtcIixcclxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dCaWFzW01BWF9ESVJFQ1RJT05BTExJR0hUU107XCIsXHJcbiAgICAgICAgICAgIFwiI2VuZGlmXCIsXHJcbiAgICAgICAgXCIjZW5kaWZcIixcclxuXHJcblxyXG5cdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBzc2FvTWFwO1wiLFxyXG5cclxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXHJcbiAgICAgICAgLy9jYWxjdWxhdGUgc2hhZG93bWFwIGNvb3JkcyAodmVjdG9yIGZvciBwb2ludGxpZ2h0KVxyXG4gICAgICAgIFwiI2lmIE1BWF9QT0lOVExJR0hUUyA+IDAgJiYgSEFTX1BPSU5UTElHSFRfU0hBRE9XTUFQU1wiLFxyXG4gICAgICAgIFwiICAgIHZlYzMgcG9pbnRMaWdodFNoYWRvd01hcERpcmVjdGlvbltNQVhfUE9JTlRMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwiICAgIGZvcihpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRMSUdIVFM7IGkrKykge1wiLFxyXG4gICAgICAgIFwiICAgICAgIHBvaW50TGlnaHRTaGFkb3dNYXBEaXJlY3Rpb25baV0gPSBmcmFnV29ybGRQb3NpdGlvbiAtIHBvaW50TGlnaHRQb3NpdGlvbltpXTtcIixcclxuICAgICAgICBcIiAgICB9XCIsXHJcbiAgICAgICAgXCIjZW5kaWZcIixcclxuICAgICAgICBcIiNpZiBNQVhfU1BPVExJR0hUUyA+IDAgJiYgSEFTX1NQT1RMSUdIVF9TSEFET1dNQVBTXCIsXHJcbiAgICAgICAgXCIgICAgdmVjNCBzcG90TGlnaHRTaGFkb3dNYXBDb29yZFtNQVhfU1BPVExJR0hUU107XCIsXHJcbiAgICAgICAgXCIgICAgZm9yKGludCBpID0gMDsgaSA8IE1BWF9TUE9UTElHSFRTOyBpKyspIHtcIixcclxuICAgICAgICBcIiAgICAgIHNwb3RMaWdodFNoYWRvd01hcENvb3JkW2ldID0gc3BvdExpZ2h0TWF0cml4W2ldICogdmVjNChmcmFnV29ybGRQb3NpdGlvbiwgMS4wKTtcIixcclxuICAgICAgICBcIiAgICB9XCIsXHJcbiAgICAgICAgXCIjZW5kaWZcIixcclxuICAgICAgICBcIiNpZiBNQVhfRElSRUNUSU9OQUxMSUdIVFMgPiAwICYmIEhBU19ESVJFQ1RJT05BTExJR0hUX1NIQURPV01BUFNcIixcclxuICAgICAgICBcIiAgICB2ZWM0IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dNYXBDb29yZFtNQVhfRElSRUNUSU9OQUxMSUdIVFNdO1wiLFxyXG4gICAgICAgIFwiICAgIGZvcihpbnQgaSA9IDA7IGkgPCBNQVhfRElSRUNUSU9OQUxMSUdIVFM7IGkrKykge1wiLFxyXG4gICAgICAgIFwiICAgICAgZGlyZWN0aW9uYWxMaWdodFNoYWRvd01hcENvb3JkW2ldID0gZGlyZWN0aW9uYWxMaWdodE1hdHJpeFtpXSAqIHZlYzQoZnJhZ1dvcmxkUG9zaXRpb24sIDEuMCk7XCIsXHJcbiAgICAgICAgXCIgICAgfVwiLFxyXG4gICAgICAgIFwiI2VuZGlmXCIsXHJcblxyXG4gICAgICAgIFwiICBmbG9hdCBhbHBoYSA9ICBtYXgoMC4wLCBvcGFjaXR5KTtcIixcclxuICAgICAgICBcIiAgdmVjMyBvYmpEaWZmdXNlID0gZGlmZnVzZUNvbG9yO1wiLFxyXG4gICAgICAgIFwiICBpZih1c2VWZXJ0ZXhDb2xvcilcIixcclxuICAgICAgICBcIiAgICBvYmpEaWZmdXNlICo9IGZyYWdWZXJ0ZXhDb2xvcjtcIixcclxuICAgICAgICBcIiAgI2lmIEhBU19ESUZGVVNFVEVYVFVSRVwiLFxyXG4gICAgICAgIFwiICAgIHZlYzQgdGV4RGlmZnVzZSA9IHRleHR1cmUyRChkaWZmdXNlVGV4dHVyZSwgZnJhZ1RleENvb3JkKTtcIixcclxuICAgICAgICBcIiAgICBhbHBoYSAqPSB0ZXhEaWZmdXNlLmE7XCIsXHJcbiAgICAgICAgXCIgICAgb2JqRGlmZnVzZSAqPSB0ZXhEaWZmdXNlLnJnYjtcIixcclxuICAgICAgICBcIiAgI2VuZGlmXCIsXHJcbiAgICAgICAgXCIgIGlmIChhbHBoYSA8IDAuMDUpIGRpc2NhcmQ7XCIsXHJcbiAgICAgICAgXCIgICNpZiBIQVNfRU1JU1NJVkVURVhUVVJFXCIsXHJcbiAgICAgICAgXCIgICAgdmVjMyBjb2xvciA9IGVtaXNzaXZlQ29sb3IgKiB0ZXh0dXJlMkQoZW1pc3NpdmVUZXh0dXJlLCBmcmFnVGV4Q29vcmQpLnJnYiArIChhbWJpZW50SW50ZW5zaXR5ICogb2JqRGlmZnVzZSk7XCIsXHJcbiAgICAgICAgXCIgICNlbHNlXCIsXHJcbiAgICAgICAgXCIgICAgdmVjMyBjb2xvciA9IGVtaXNzaXZlQ29sb3IgKyAoYW1iaWVudEludGVuc2l0eSAqIG9iakRpZmZ1c2UpO1wiLFxyXG4gICAgICAgIFwiICAjZW5kaWZcIixcclxuICAgICAgICBcIiAgdmVjMyBvYmpTcGVjdWxhciA9IHNwZWN1bGFyQ29sb3I7XCIsXHJcbiAgICAgICAgXCIgICNpZiBIQVNfU1BFQ1VMQVJURVhUVVJFXCIsXHJcbiAgICAgICAgXCIgICAgb2JqU3BlY3VsYXIgPSBvYmpTcGVjdWxhciAqIHRleHR1cmUyRChzcGVjdWxhclRleHR1cmUsIGZyYWdUZXhDb29yZCkucmdiO1wiLFxyXG4gICAgICAgIFwiICAjZW5kaWZcIixcclxuXHRcdFwiICAjaWYgSEFTX1NTQU9NQVBcIixcclxuXHRcdFwiXHQgZmxvYXQgc3NhbyA9IDEuMCAtIHRleHR1cmUyRChzc2FvTWFwLCBnbF9GcmFnQ29vcmQueHkgLyBjb29yZHMueHkpLnI7XCIsXHJcbiAgICAgICAgXCIgICNlbmRpZlwiLFxyXG5cclxuICAgICAgICBcIiAgZmxvYXQgc2hhZG93SW5mbHVlbmNlID0gMC4wO1wiLCAvL3VzZWQgZm9yIHNhbXBsaW5nIHNoYWRvd1xyXG5cclxuXHRcdFwiI2lmIE1BWF9QT0lOVExJR0hUUyA+IDBcIixcclxuICAgICAgICBcIiAgZm9yIChpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRMSUdIVFM7IGkrKykge1wiLFxyXG4gICAgICAgIFwiICAgIHNoYWRvd0luZmx1ZW5jZSA9IDEuMDtcIixcclxuICAgICAgICBcIiAgICBpZihwb2ludExpZ2h0T25baV0pe1wiLFxyXG4gICAgICAgIFwiICAgI2lmIEhBU19QT0lOVExJR0hUX1NIQURPV01BUFNcIixcclxuICAgICAgICBcIiAgICAgICBpZihwb2ludExpZ2h0Q2FzdFNoYWRvd1tpXSl7XCIsXHJcbiAgICAgICAgXCIgICAgICAgICAgIHNoYWRvd0luZmx1ZW5jZSA9IDAuMDtcIixcclxuICAgICAgICBcIiAgICAgICAgICAgZmxvYXQgbHNEZXB0aCA9IHZlY1RvRGVwdGgocG9pbnRMaWdodFNoYWRvd01hcERpcmVjdGlvbltpXSwgcG9pbnRMaWdodE5lYXJGYXJbaV0ueCwgcG9pbnRMaWdodE5lYXJGYXJbaV0ueSApO1wiLFxyXG4gICAgICAgIFwiXHRcdCAgICBmbG9hdCBkZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlQ3ViZShwb2ludExpZ2h0U2hhZG93TWFwW2ldLCBwb2ludExpZ2h0U2hhZG93TWFwRGlyZWN0aW9uW2ldKSkgKyAgcG9pbnRMaWdodFNoYWRvd0JpYXNbaV07XCIsXHJcbiAgICAgICAgXCIgICAgICAgICAgIGlmKGxzRGVwdGggPCBkZXB0aClcIixcclxuICAgICAgICBcIiAgICAgICAgICAgICAgIHNoYWRvd0luZmx1ZW5jZSA9IDEuMDtcIixcclxuICAgICAgICBcIiAgICAgICB9XCIsXHJcbiAgICAgICAgXCIgICAgICAgaWYoc2hhZG93SW5mbHVlbmNlID4gMC4wKXtcIixcclxuICAgICAgICBcIiAgICNlbmRpZlwiLFxyXG4gICAgICAgIFwiICAgICAgIHZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHBvaW50TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcIixcclxuICAgICAgICBcIiAgICAgICB2ZWMzIEwgPSBsUG9zaXRpb24ueHl6IC0gZnJhZ1ZlcnRleFBvc2l0aW9uO1wiLFxyXG4gICAgICAgIFwiICAgICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgoTCk7XCIsXHJcbiAgICAgICAgXCIgICAgICAgTCA9IG5vcm1hbGl6ZShMKTtcIixcclxuICAgICAgICBcIiAgICAgICB2ZWMzIFIgPSBub3JtYWxpemUocmVmbGVjdChMLGZyYWdOb3JtYWwpKTtcIixcclxuICAgICAgICBcIiAgICAgICBmbG9hdCBhdHRlbiA9IDEuMCAvIChwb2ludExpZ2h0QXR0ZW51YXRpb25baV0ueCArIHBvaW50TGlnaHRBdHRlbnVhdGlvbltpXS55ICogZGlzdCArIHBvaW50TGlnaHRBdHRlbnVhdGlvbltpXS56ICogZGlzdCAqIGRpc3QpO1wiLFxyXG4gICAgICAgIFwiICAgICAgIHZlYzMgSWRpZmYgPSBwb2ludExpZ2h0SW50ZW5zaXR5W2ldICogb2JqRGlmZnVzZSAqIG1heChkb3QoZnJhZ05vcm1hbCxMKSwwLjApO1wiLFxyXG5cdFx0XCIgICAjaWYgSEFTX1NTQU9NQVBcIixcclxuXHRcdFwiICAgICAgIElkaWZmICo9IHNzYW87XCIsXHJcblx0XHRcIiAgICNlbmRpZlwiLFxyXG4gICAgICAgIFwiICAgICAgIHZlYzMgSXNwZWMgPSBwb2ludExpZ2h0SW50ZW5zaXR5W2ldICogb2JqU3BlY3VsYXIgKiBwb3cobWF4KGRvdChSLGZyYWdFeWVWZWN0b3IpLDAuMCksIHNoaW5pbmVzcyoxMjguMCk7XCIsXHJcbiAgICAgICAgXCIgICAgICAgY29sb3IgPSBjb2xvciArIChhdHRlbipzaGFkb3dJbmZsdWVuY2UqKElkaWZmICsgSXNwZWMpKTtcIixcclxuICAgICAgICBcIiAgICNpZiBIQVNfUE9JTlRMSUdIVF9TSEFET1dNQVBTXCIsXHJcbiAgICAgICAgXCIgICAgICAgfVwiLCAgLy9wb2ludGxpZ2h0IHZpc2libGVcclxuICAgICAgICBcIiAgICNlbmRpZlwiLFxyXG4gICAgICAgIFwiICAgICB9XCIsIC8vcG9pbnRMaWdodCBvblxyXG4gICAgICAgIFwiICB9XCIsIC8vcG9pbnRMaWdodCBsb29wXHJcbiAgICAgICAgXCIjZW5kaWZcIixcclxuXHJcbiAgICAgICAgXCIjaWYgTUFYX1NQT1RMSUdIVFMgPiAwXCIsXHJcbiAgICAgICAgXCIgIGZvciAoaW50IGk9MDsgaTxNQVhfU1BPVExJR0hUUzsgaSsrKSB7XCIsXHJcbiAgICAgICAgXCIgICAgc2hhZG93SW5mbHVlbmNlID0gMS4wO1wiLFxyXG4gICAgICAgIFwiICAgIGlmKHNwb3RMaWdodE9uW2ldKSB7XCIsXHJcbiAgICAgICAgXCIgICNpZiBIQVNfU1BPVExJR0hUX1NIQURPV01BUFNcIixcclxuICAgICAgICBcIiAgICAgICBpZihzcG90TGlnaHRDYXN0U2hhZG93W2ldKXtcIixcclxuICAgICAgICBcIiAgICAgICAgICAgc2hhZG93SW5mbHVlbmNlID0gMC4wO1wiLFxyXG4gICAgICAgIFwiICAgICAgICAgICB2ZWM0IGxzcG9zID0gc3BvdExpZ2h0U2hhZG93TWFwQ29vcmRbaV07XCIsXHJcbiAgICAgICAgXCJcdFx0XHR2ZWMzIHBlcnNwZWN0aXZlRGl2UG9zID0gbHNwb3MueHl6IC8gbHNwb3MudyAqIDAuNSArIDAuNTtcIixcclxuICAgICAgICBcIlx0XHRcdGZsb2F0IGxzRGVwdGggPSBwZXJzcGVjdGl2ZURpdlBvcy56O1wiLFxyXG4gICAgICAgIFwiXHRcdFx0dmVjMiBsaWdodHV2ID0gcGVyc3BlY3RpdmVEaXZQb3MueHk7XCIsXHJcbiAgICAgICAgXCJcdFx0XHRmbG9hdCBkZXB0aCA9IHVucGFja0RlcHRoKHRleHR1cmUyRChzcG90TGlnaHRTaGFkb3dNYXBbaV0sIGxpZ2h0dXYpKSArIHNwb3RMaWdodFNoYWRvd0JpYXNbaV07XCIsXHJcbiAgICAgICAgXCIgICAgICAgICAgIGlmKGxzRGVwdGggPCBkZXB0aClcIixcclxuICAgICAgICBcIiAgICAgICAgICAgICAgIHNoYWRvd0luZmx1ZW5jZSA9IDEuMDtcIixcclxuICAgICAgICBcIiAgICAgICB9XCIsXHJcbiAgICAgICAgXCIgICAgICAgaWYoc2hhZG93SW5mbHVlbmNlID4gMC4wKXtcIixcclxuICAgICAgICBcIiAgI2VuZGlmXCIsXHJcbiAgICAgICAgXCIgICAgICAgdmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggc3BvdExpZ2h0UG9zaXRpb25bIGkgXSwgMS4wICk7XCIsXHJcbiAgICAgICAgXCIgICAgICAgdmVjMyBMID0gbFBvc2l0aW9uLnh5eiAtIGZyYWdWZXJ0ZXhQb3NpdGlvbjtcIixcclxuICAgICAgICBcIiAgICAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKEwpO1wiLFxyXG4gICAgICAgIFwiICAgICAgIEwgPSBub3JtYWxpemUoTCk7XCIsXHJcbiAgICAgICAgXCIgICAgICAgdmVjMyBSID0gbm9ybWFsaXplKHJlZmxlY3QoTCxmcmFnTm9ybWFsKSk7XCIsXHJcbiAgICAgICAgXCIgICAgICAgZmxvYXQgYXR0ZW4gPSAxLjAgLyAoc3BvdExpZ2h0QXR0ZW51YXRpb25baV0ueCArIHNwb3RMaWdodEF0dGVudWF0aW9uW2ldLnkgKiBkaXN0ICsgc3BvdExpZ2h0QXR0ZW51YXRpb25baV0ueiAqIGRpc3QgKiBkaXN0KTtcIixcclxuICAgICAgICBcIiAgICAgICB2ZWMzIElkaWZmID0gc3BvdExpZ2h0SW50ZW5zaXR5W2ldICogb2JqRGlmZnVzZSAqIG1heChkb3QoZnJhZ05vcm1hbCxMKSwwLjApO1wiLFxyXG4gICAgICAgIFwiICAgI2lmIEhBU19TU0FPTUFQXCIsXHJcbiAgICAgICAgXCJcdCAgICBJZGlmZiAqPSBzc2FvO1wiLFxyXG4gICAgICAgIFwiICAgI2VuZGlmXCIsXHJcbiAgICAgICAgXCIgICAgICAgdmVjMyBJc3BlYyA9IHNwb3RMaWdodEludGVuc2l0eVtpXSAqIG9ialNwZWN1bGFyICogcG93KG1heChkb3QoUixmcmFnRXllVmVjdG9yKSwwLjApLCBzaGluaW5lc3MqMTI4LjApO1wiLFxyXG4gICAgICAgIFwiICAgICAgIHZlYzQgbERpcmVjdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KC1zcG90TGlnaHREaXJlY3Rpb25baV0sIDAuMCk7XCIsXHJcbiAgICAgICAgXCIgICAgICAgdmVjMyBEID0gbm9ybWFsaXplKGxEaXJlY3Rpb24ueHl6KTtcIixcclxuICAgICAgICBcIiAgICAgICBmbG9hdCBhbmdsZSA9IGRvdChMLCBEKTtcIixcclxuICAgICAgICBcIiAgICAgICBpZihhbmdsZSA+IHNwb3RMaWdodENvc0N1dG9mZkFuZ2xlW2ldKSB7XCIsXHJcbiAgICAgICAgXCIgICAgICAgICAgIGZsb2F0IHNvZnRuZXNzID0gMS4wO1wiLFxyXG4gICAgICAgIFwiICAgICAgICAgICBpZiAoYW5nbGUgPCBzcG90TGlnaHRDb3NTb2Z0Q3V0b2ZmQW5nbGVbaV0pXCIsXHJcbiAgICAgICAgXCIgICAgICAgICAgICAgICBzb2Z0bmVzcyA9IChhbmdsZSAtIHNwb3RMaWdodENvc0N1dG9mZkFuZ2xlW2ldKSAvICAoc3BvdExpZ2h0Q29zU29mdEN1dG9mZkFuZ2xlW2ldIC0gIHNwb3RMaWdodENvc0N1dG9mZkFuZ2xlW2ldKTtcIixcclxuICAgICAgICBcIiAgICAgICAgICAgY29sb3IgKz0gYXR0ZW4qc29mdG5lc3Mqc2hhZG93SW5mbHVlbmNlKihJZGlmZiArIElzcGVjKTtcIixcclxuICAgICAgICBcIiAgICAgICB9XCIsXHJcbiAgICAgICAgXCIgICAjaWYgSEFTX1NQT1RMSUdIVF9TSEFET1dNQVBTXCIsXHJcbiAgICAgICAgXCIgICAgICAgfVwiLCAvL2xpZ2h0IHZpc2libGUgaWYgc2hhZG93IGVuYWJsZWRcclxuICAgICAgICBcIiAgICNlbmRpZlwiLFxyXG4gICAgICAgIFwiICAgfSBcIiwgLy8gc3BvdGxpZ2h0IG9uXHJcbiAgICAgICAgXCIgIH1cIiwgLy8gbGlnaHQgbG9vcFxyXG4gICAgICAgIFwiI2VuZGlmXCIsXHJcblxyXG4gICAgICAgIFwiI2lmIE1BWF9ESVJFQ1RJT05BTExJR0hUUyA+IDBcIixcclxuICAgICAgICBcIiAgZm9yIChpbnQgaT0wOyBpPE1BWF9ESVJFQ1RJT05BTExJR0hUUzsgaSsrKSB7XCIsXHJcbiAgICAgICAgXCIgICBzaGFkb3dJbmZsdWVuY2UgPSAxLjA7XCIsXHJcbiAgICAgICAgXCIgICBpZihkaXJlY3Rpb25hbExpZ2h0T25baV0pe1wiLFxyXG4gICAgICAgIFwiICAgI2lmIEhBU19ESVJFQ1RJT05BTExJR0hUX1NIQURPV01BUFNcIixcclxuICAgICAgICBcIiAgICAgICBpZihkaXJlY3Rpb25hbExpZ2h0Q2FzdFNoYWRvd1tpXSl7XCIsXHJcbiAgICAgICAgXCIgICAgICAgICAgIHNoYWRvd0luZmx1ZW5jZSA9IDAuMDtcIixcclxuICAgICAgICBcIiAgICAgICAgICAgdmVjNCBsc3BvcyA9IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dNYXBDb29yZFtpXTtcIixcclxuICAgICAgICBcIiAgICAgICAgICAgdmVjMyBvcnRob2dvbmFsRGl2UG9zID0gbHNwb3MueHl6IC8gbHNwb3MudyAqMC41ICsgMC41O1wiLFxyXG4gICAgICAgIFwiICAgICAgICAgICBmbG9hdCBsc0RlcHRoID0gb3J0aG9nb25hbERpdlBvcy56O1wiLFxyXG4gICAgICAgIFwiICAgICAgICAgICB2ZWMyIGxpZ2h0dXYgPSBvcnRob2dvbmFsRGl2UG9zLnh5O1wiLFxyXG4gICAgICAgIFwiICAgICAgICAgICAgICAgZmxvYXQgZGVwdGggPSB1bnBhY2tEZXB0aCh0ZXh0dXJlMkQoZGlyZWN0aW9uYWxMaWdodFNoYWRvd01hcFtpXSwgbGlnaHR1dikpK2RpcmVjdGlvbmFsTGlnaHRTaGFkb3dCaWFzW2ldO1wiLFxyXG4gICAgICAgIFwiICAgICAgICAgICAgICAgaWYobHNEZXB0aCA8IGRlcHRoKSBzaGFkb3dJbmZsdWVuY2UgPSAxLjA7XCIsXHJcbiAgICAgICAgXCIgICAgICAgfVwiLFxyXG4gICAgICAgIFwiICAgICAgIGlmKHNoYWRvd0luZmx1ZW5jZSA+IDAuMCl7XCIsXHJcbiAgICAgICAgXCIgICAjZW5kaWZcIixcclxuICAgICAgICBcIiAgICAgICB2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNChkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uW2ldLCAwLjApO1wiLFxyXG4gICAgICAgIFwiICAgICAgIHZlYzMgTCA9ICBub3JtYWxpemUoLWxEaXJlY3Rpb24ueHl6KTtcIixcclxuICAgICAgICBcIiAgICAgICB2ZWMzIFIgPSBub3JtYWxpemUocmVmbGVjdChMLGZyYWdOb3JtYWwpKTtcIixcclxuICAgICAgICBcIiAgICAgICB2ZWMzIElkaWZmID0gZGlyZWN0aW9uYWxMaWdodEludGVuc2l0eVtpXSAqIG9iakRpZmZ1c2UgKiBtYXgoZG90KGZyYWdOb3JtYWwsTCksMC4wKTtcIixcclxuXHRcdFwiICAgI2lmIEhBU19TU0FPTUFQXCIsXHJcblx0XHRcIiAgICAgICBJZGlmZiAqPSBzc2FvO1wiLFxyXG5cdFx0XCIgICAjZW5kaWZcIixcclxuICAgICAgICBcIiAgICAgICB2ZWMzIElzcGVjID0gZGlyZWN0aW9uYWxMaWdodEludGVuc2l0eVtpXSAqIG9ialNwZWN1bGFyICogcG93KG1heChkb3QoUixmcmFnRXllVmVjdG9yKSwwLjApLCBzaGluaW5lc3MqMTI4LjApO1wiLFxyXG4gICAgICAgIFwiICAgICAgIGNvbG9yID0gY29sb3IgKyBzaGFkb3dJbmZsdWVuY2UqKChJZGlmZiArIElzcGVjKSk7XCIsXHJcbiAgICAgICAgXCIgICAjaWYgSEFTX0RJUkVDVElPTkFMTElHSFRfU0hBRE9XTUFQU1wiLFxyXG4gICAgICAgIFwiICAgICAgIH1cIiwgLy9saWdodCB2aXNpYmxlXHJcbiAgICAgICAgXCIgICAjZW5kaWZcIixcclxuICAgICAgICBcIiAgIH1cIiwgLy9kaXJMaWdodCBvblxyXG4gICAgICAgIFwiICB9XCIsIC8vIGRpckxpZ2h0IGxvb3BcclxuICAgICAgICBcIiNlbmRpZlwiLFxyXG4gICAgICAgIFwiICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCBhbHBoYSk7XCIsXHJcbiAgICAgICAgXCJ9XCJcclxuICAgIF0uam9pbihcIlxcblwiKSxcclxuXHJcbiAgICBhZGREaXJlY3RpdmVzOiBmdW5jdGlvbiAoZGlyZWN0aXZlcywgbGlnaHRzLCBwYXJhbXMpIHtcclxuICAgICAgICBbXCJwb2ludFwiLCBcImRpcmVjdGlvbmFsXCIsIFwic3BvdFwiXS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBudW1MaWdodHMgPSBsaWdodHMuZ2V0TW9kZWxDb3VudCh0eXBlKTtcclxuICAgICAgICAgICAgdmFyIGNhc3RTaGFkb3dzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmKG51bUxpZ2h0cykge1xyXG4gICAgICAgICAgICAgICAgY2FzdFNoYWRvd3MgPSBBcnJheS5wcm90b3R5cGUuc29tZS5jYWxsKGxpZ2h0cy5nZXRNb2RlbEVudHJ5KHR5cGUpLnBhcmFtZXRlcnNbXCJjYXN0U2hhZG93XCJdLCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkaXJlY3RpdmVzLnB1c2goXCJNQVhfXCIgKyB0eXBlLnRvVXBwZXJDYXNlKCkgKyBcIkxJR0hUUyBcIiArIG51bUxpZ2h0cyk7XHJcbiAgICAgICAgICAgIGRpcmVjdGl2ZXMucHVzaChcIkhBU19cIiArIHR5cGUudG9VcHBlckNhc2UoKSArIFwiTElHSFRfU0hBRE9XTUFQUyBcIiArIChjYXN0U2hhZG93cyA/IDEgOiAwKSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGRpcmVjdGl2ZXMucHVzaChcIkhBU19ESUZGVVNFVEVYVFVSRSBcIiArICgnZGlmZnVzZVRleHR1cmUnIGluIHBhcmFtcyA/IFwiMVwiIDogXCIwXCIpKTtcclxuICAgICAgICBkaXJlY3RpdmVzLnB1c2goXCJIQVNfU1BFQ1VMQVJURVhUVVJFIFwiICsgKCdzcGVjdWxhclRleHR1cmUnIGluIHBhcmFtcyA/IFwiMVwiIDogXCIwXCIpKTtcclxuICAgICAgICBkaXJlY3RpdmVzLnB1c2goXCJIQVNfRU1JU1NJVkVURVhUVVJFIFwiICsgKCdlbWlzc2l2ZVRleHR1cmUnIGluIHBhcmFtcyA/IFwiMVwiIDogXCIwXCIpKTtcclxuICAgICAgICBkaXJlY3RpdmVzLnB1c2goXCJIQVNfU1NBT01BUCBcIiArIChYTUwzRC5vcHRpb25zLmdldFZhbHVlKFwicmVuZGVyZXItc3Nhb1wiKSA/IFwiMVwiIDogXCIwXCIpKTtcclxuICAgIH0sXHJcbiAgICBoYXNUcmFuc3BhcmVuY3k6IGZ1bmN0aW9uKHBhcmFtcykge1xyXG4gICAgICAgIHJldHVybiBwYXJhbXMub3BhY2l0eSAmJiBwYXJhbXMub3BhY2l0eS5nZXRWYWx1ZSgpWzBdIDwgMTtcclxuICAgIH0sXHJcbiAgICB1bmlmb3Jtczoge1xyXG4gICAgICAgIGRpZmZ1c2VDb2xvciAgICA6IFsxLjAsIDEuMCwgMS4wXSxcclxuICAgICAgICBlbWlzc2l2ZUNvbG9yICAgOiBbMC4wLCAwLjAsIDAuMF0sXHJcbiAgICAgICAgc3BlY3VsYXJDb2xvciAgIDogWzAuMCwgMC4wLCAwLjBdLFxyXG4gICAgICAgIG9wYWNpdHkgICAgICAgICA6IDEuMCxcclxuICAgICAgICBzaGluaW5lc3MgICAgICAgOiAwLjIsXHJcbiAgICAgICAgYW1iaWVudEludGVuc2l0eTogMC4wLFxyXG4gICAgICAgIHVzZVZlcnRleENvbG9yIDogZmFsc2VcclxuICAgIH0sXHJcblxyXG4gICAgc2FtcGxlcnM6IHtcclxuICAgICAgICBkaWZmdXNlVGV4dHVyZSA6IG51bGwsXHJcbiAgICAgICAgZW1pc3NpdmVUZXh0dXJlIDogbnVsbCxcclxuICAgICAgICBzcGVjdWxhclRleHR1cmUgOiBudWxsLFxyXG4gICAgICAgIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dNYXAgOiBudWxsLFxyXG4gICAgICAgIHNwb3RMaWdodFNoYWRvd01hcCA6IG51bGwsXHJcbiAgICAgICAgcG9pbnRMaWdodFNoYWRvd01hcCA6IG51bGwsXHJcblx0XHRzc2FvTWFwOiBudWxsXHJcbiAgICB9LFxyXG5cclxuICAgIGF0dHJpYnV0ZXM6IHtcclxuICAgICAgICBub3JtYWwgOiB7XHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0ZXhjb29yZDogbnVsbCxcclxuICAgICAgICBjb2xvcjogbnVsbFxyXG4gICAgfVxyXG59KTtcclxuIiwiWE1MM0QubWF0ZXJpYWxzLnJlZ2lzdGVyKFwicG9pbnRcIiwge1xyXG5cclxuICAgIHZlcnRleCA6IFtcclxuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1wiLFxyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzMgY29sb3I7XCIsXHJcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMiB0ZXhjb29yZDtcIixcclxuXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ05vcm1hbDtcIixcclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnVmVydGV4UG9zaXRpb247XCIsXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ0V5ZVZlY3RvcjtcIixcclxuICAgICAgICBcInZhcnlpbmcgdmVjMiBmcmFnVGV4Q29vcmQ7XCIsXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ1ZlcnRleENvbG9yO1wiLFxyXG5cclxuICAgICAgICBcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4O1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDtcIixcclxuICAgICAgICBcInVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4O1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBtYXQzIG1vZGVsVmlld01hdHJpeE47XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgZXllUG9zaXRpb247XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgY29vcmRzO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCBwb2ludFNpemU7XCIsXHJcblxyXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcclxuICAgICAgICBcIiAgICB2ZWMzIHBvcyA9IHBvc2l0aW9uO1wiLFxyXG5cclxuICAgICAgICBcIiAgICBnbF9Qb3NpdGlvbiA9IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggKiB2ZWM0KHBvcywgMS4wKTtcIixcclxuICAgICAgICBcIiAgICBmcmFnVmVydGV4UG9zaXRpb24gPSAobW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3MsIDEuMCkpLnh5ejtcIixcclxuICAgICAgICBcIiAgICBmcmFnRXllVmVjdG9yID0gbm9ybWFsaXplKGZyYWdWZXJ0ZXhQb3NpdGlvbik7XCIsXHJcbiAgICAgICAgXCIgICAgZnJhZ1RleENvb3JkID0gdGV4Y29vcmQ7XCIsXHJcbiAgICAgICAgXCIgICAgZnJhZ1ZlcnRleENvbG9yID0gY29sb3I7XCIsXHJcbiAgICAgICAgXCIgICAgdmVjNCBwb3MyID0gdmVjNChmcmFnVmVydGV4UG9zaXRpb24sIDEuMCk7IHBvczIueCArPSBwb2ludFNpemU7XCIsXHJcbiAgICAgICAgXCIgICAgZ2xfUG9pbnRTaXplID0gZGlzdGFuY2UoIGdsX1Bvc2l0aW9uLnh5LCAocHJvamVjdGlvbk1hdHJpeCAqIHBvczIpLnh5ICkgKiBjb29yZHMueCAvIGdsX1Bvc2l0aW9uLnc7XCIsXHJcbiAgICAgICAgXCJ9XCJcclxuICAgIF0uam9pbihcIlxcblwiKSxcclxuXHJcbiAgICBmcmFnbWVudCA6IFtcclxuICAgICAgICBcInVuaWZvcm0gdmVjMyBkaWZmdXNlQ29sb3I7XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcIixcclxuICAgICAgICBcInVuaWZvcm0gYm9vbCB1c2VWZXJ0ZXhDb2xvcjtcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMiB0ZXhDb29yZE9mZnNldDtcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMiB0ZXhDb29yZFNpemU7XCIsXHJcblxyXG4gICAgICAgIFwiI2lmIEhBU19ESUZGVVNFVEVYVFVSRVwiLFxyXG4gICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgZGlmZnVzZVRleHR1cmU7XCIsXHJcbiAgICAgICAgXCIjZW5kaWZcIixcclxuXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ05vcm1hbDtcIixcclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnVmVydGV4UG9zaXRpb247XCIsXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ0V5ZVZlY3RvcjtcIixcclxuICAgICAgICBcInZhcnlpbmcgdmVjMiBmcmFnVGV4Q29vcmQ7XCIsXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ1ZlcnRleENvbG9yO1wiLFxyXG5cclxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXHJcbiAgICAgICAgXCIgIGZsb2F0IGFscGhhID0gIG1heCgwLjAsIG9wYWNpdHkpO1wiLFxyXG4gICAgICAgIFwiICB2ZWMzIG9iakRpZmZ1c2UgPSBkaWZmdXNlQ29sb3I7XCIsXHJcbiAgICAgICAgXCIgIGlmKHVzZVZlcnRleENvbG9yKVwiLFxyXG4gICAgICAgIFwiICAgIG9iakRpZmZ1c2UgKj0gZnJhZ1ZlcnRleENvbG9yO1wiLFxyXG4gICAgICAgIFwiICAjaWYgSEFTX0RJRkZVU0VURVhUVVJFXCIsXHJcbiAgICAgICAgXCIgICAgdmVjMiB0ZXhDb29yZCA9IGZyYWdUZXhDb29yZCArIHRleENvb3JkT2Zmc2V0ICsgZ2xfUG9pbnRDb29yZCp0ZXhDb29yZFNpemU7XCIsXHJcbiAgICAgICAgXCIgICAgdGV4Q29vcmQueSA9IDEuMCAtIHRleENvb3JkLnk7XCIsXHJcbiAgICAgICAgXCIgICAgdmVjNCB0ZXhEaWZmdXNlID0gdGV4dHVyZTJEKGRpZmZ1c2VUZXh0dXJlLCB0ZXhDb29yZCk7XCIsXHJcbiAgICAgICAgXCIgICAgYWxwaGEgKj0gdGV4RGlmZnVzZS5hO1wiLFxyXG4gICAgICAgIFwiICAgIG9iakRpZmZ1c2UgKj0gdGV4RGlmZnVzZS5yZ2I7XCIsXHJcbiAgICAgICAgXCIgICNlbmRpZlwiLFxyXG4gICAgICAgIFwiICBpZiAoYWxwaGEgPCAwLjA1KSBkaXNjYXJkO1wiLFxyXG4gICAgICAgIFwiICBnbF9GcmFnQ29sb3IgPSB2ZWM0KG9iakRpZmZ1c2UsIGFscGhhKTtcIixcclxuICAgICAgICBcIn1cIlxyXG4gICAgXS5qb2luKFwiXFxuXCIpLFxyXG4gICAgYWRkRGlyZWN0aXZlczogZnVuY3Rpb24oZGlyZWN0aXZlcywgbGlnaHRzLCBwYXJhbXMpIHtcclxuICAgICAgICBkaXJlY3RpdmVzLnB1c2goXCJIQVNfRElGRlVTRVRFWFRVUkUgXCIgKyAoJ2RpZmZ1c2VUZXh0dXJlJyBpbiBwYXJhbXMgPyBcIjFcIiA6IFwiMFwiKSk7XHJcbiAgICB9LFxyXG4gICAgaGFzVHJhbnNwYXJlbmN5OiBmdW5jdGlvbihwYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gcGFyYW1zLm9wYWNpdHkgJiYgcGFyYW1zLm9wYWNpdHkuZ2V0VmFsdWUoKVswXSA8IDE7XHJcbiAgICB9LFxyXG4gICAgdW5pZm9ybXM6IHtcclxuICAgICAgICBkaWZmdXNlQ29sb3IgICAgOiBbMS4wLCAxLjAsIDEuMF0sXHJcbiAgICAgICAgdGV4Q29vcmRPZmZzZXQgIDogWzAsIDBdLFxyXG4gICAgICAgIHRleENvb3JkU2l6ZSAgICA6IFsxLCAxXSxcclxuICAgICAgICBvcGFjaXR5ICAgICAgICAgOiAxLjAsXHJcbiAgICAgICAgdXNlVmVydGV4Q29sb3IgIDogZmFsc2UsXHJcbiAgICAgICAgcG9pbnRTaXplICAgICAgIDogMS4wXHJcbiAgICB9LFxyXG4gICAgc2FtcGxlcnM6IHtcclxuICAgICAgICBkaWZmdXNlVGV4dHVyZTogbnVsbFxyXG4gICAgfSxcclxuICAgIGF0dHJpYnV0ZXM6IHtcclxuICAgICAgICB0ZXhjb29yZDogbnVsbCxcclxuICAgICAgICBjb2xvcjogbnVsbFxyXG4gICAgfVxyXG59KTtcclxuIiwidmFyIGNfZ2xvYmFsU2NyaXB0cyA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChuYW1lLCBzY3JpcHQpIHtcclxuICAgICAgICBjX2dsb2JhbFNjcmlwdHNbbmFtZV0gPSBzY3JpcHQ7XHJcbiAgICAgICAgc2NyaXB0Lm5hbWUgPSBuYW1lO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRTY3JpcHQ6IGZ1bmN0aW9uIChzY3JpcHQpIHtcclxuICAgICAgICByZXR1cm4gY19nbG9iYWxTY3JpcHRzW3NjcmlwdF07XHJcbiAgICB9XHJcbn07XHJcbiIsInZhciBTaGFkZXJEZXNjcmlwdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy51bmlmb3JtcyA9IHt9O1xyXG4gICAgdGhpcy5zYW1wbGVycyA9IHt9O1xyXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XHJcbiAgICB0aGlzLm5hbWUgPSBcIlwiO1xyXG4gICAgdGhpcy5mcmFnbWVudCA9IFwiXCI7XHJcbiAgICB0aGlzLnZlcnRleCA9IFwiXCI7XHJcbn07XHJcblNoYWRlckRlc2NyaXB0b3IucHJvdG90eXBlLmFkZERpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbn07XHJcblNoYWRlckRlc2NyaXB0b3IucHJvdG90eXBlLmhhc1RyYW5zcGFyZW5jeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2hhZGVyRGVzY3JpcHRvcjtcclxuIiwidmFyIEFic3RyYWN0U2hhZGVyQ2xvc3VyZSA9IHJlcXVpcmUoXCIuLy4uL2Fic3RyYWN0c2hhZGVyY2xvc3VyZS5qc1wiKTtcclxudmFyIFN5c3RlbU5vdGlmaWVyID0gcmVxdWlyZShcIi4uLy4uL3N5c3RlbS9zeXN0ZW0tbm90aWZpZXIuanNcIik7XHJcblxyXG4vKipcclxuICogQSBTaGFkZXJDbG9zdXJlIGNvbm5lY3RzIGEgbWVzaC1zcGVjaWZpYyBHTFByb2dyYW0gd2l0aCBpdCdzIFhmbG93IGRhdGFcclxuICogQHBhcmFtIHtHTENvbnRleHR9IGNvbnRleHRcclxuICogQHBhcmFtIGRlc2NyaXB0b3JcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgU2hhZGVyQ2xvc3VyZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBkZXNjcmlwdG9yKSB7XHJcbiAgICBBYnN0cmFjdFNoYWRlckNsb3N1cmUuY2FsbCh0aGlzLCBjb250ZXh0KTtcclxuICAgIHRoaXMuZGVzY3JpcHRvciA9IGRlc2NyaXB0b3I7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhTaGFkZXJDbG9zdXJlLCBBYnN0cmFjdFNoYWRlckNsb3N1cmUpO1xyXG5cclxuWE1MM0QuZXh0ZW5kKFNoYWRlckNsb3N1cmUucHJvdG90eXBlLCB7XHJcblxyXG4gICAgc2V0RGVmYXVsdFVuaWZvcm1zOiBmdW5jdGlvbiAoZGVzdCkge1xyXG4gICAgICAgIFhNTDNELmV4dGVuZChkZXN0LCB0aGlzLmRlc2NyaXB0b3IudW5pZm9ybXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVTb3VyY2VzOiBmdW5jdGlvbiAoc2NlbmUsIHNoYWRlckRhdGEsIHZzUmVxdWVzdCkge1xyXG5cclxuICAgICAgICB2YXIgb2JqZWN0RGF0YSA9IHZzUmVxdWVzdCAmJiB2c1JlcXVlc3QuZ2V0UmVzdWx0KCk7XHJcbiAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBbXTtcclxuXHJcbiAgICAgICAgdmFyIGlucHV0RGF0YSA9IHt9O1xyXG4gICAgICAgIHNoYWRlckRhdGEgJiYgWE1MM0QuZXh0ZW5kKGlucHV0RGF0YSwgc2hhZGVyRGF0YS5nZXRPdXRwdXRNYXAoKSk7XHJcbiAgICAgICAgb2JqZWN0RGF0YSAmJiBYTUwzRC5leHRlbmQoaW5wdXREYXRhLCBvYmplY3REYXRhLmdldE91dHB1dE1hcCgpKTtcclxuXHJcblxyXG4gICAgICAgIGZvciAodmFyIGF0dHJOYW1lIGluIHRoaXMuZGVzY3JpcHRvci5hdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuZGVzY3JpcHRvci5hdHRyaWJ1dGVzW2F0dHJOYW1lXTtcclxuICAgICAgICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5LnJlcXVpcmVkICYmICFpbnB1dERhdGFbYXR0ck5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXNoIGlzIG1pc3NpbmcgJ1wiICsgYXR0ck5hbWUgKyBcIicgYXR0cmlidXRlLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdG9yLmFkZERpcmVjdGl2ZXMoZGlyZWN0aXZlcywgc2NlbmUubGlnaHRzIHx8IHt9LCBpbnB1dERhdGEpO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0ge1xyXG4gICAgICAgICAgICBmcmFnbWVudDogdGhpcy5hZGREaXJlY3RpdmVzVG9Tb3VyY2UoZGlyZWN0aXZlcywgdGhpcy5kZXNjcmlwdG9yLmZyYWdtZW50KSxcclxuICAgICAgICAgICAgdmVydGV4OiB0aGlzLmFkZERpcmVjdGl2ZXNUb1NvdXJjZShkaXJlY3RpdmVzLCB0aGlzLmRlc2NyaXB0b3IudmVydGV4KVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIFN5c3RlbU5vdGlmaWVyLnNlbmRFdmVudCgndXJuc2hhZGVyJywge1xyXG4gICAgICAgICAgICB1cm5zaGFkZXJUeXBlOiBcImNvZGVcIiwgdmVydGV4U2hhZGVyOiB0aGlzLnNvdXJjZS52ZXJ0ZXgsIGZyYWdtZW50U2hhZGVyOiB0aGlzLnNvdXJjZS5mcmFnbWVudFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkRGlyZWN0aXZlc1RvU291cmNlOiBmdW5jdGlvbiAoZGlyZWN0aXZlcywgc291cmNlKSB7XHJcbiAgICAgICAgdmFyIGhlYWRlciA9IFwiXCI7XHJcbiAgICAgICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGhlYWRlciArPSBcIiNkZWZpbmUgXCIgKyB2ICsgXCJcXG5cIjtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gaGVhZGVyICsgXCJcXG5cIiArIHNvdXJjZTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VHJhbnNwYXJlbmN5RnJvbUlucHV0RGF0YTogZnVuY3Rpb24gKGRhdGFNYXApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZXNjcmlwdG9yLmhhc1RyYW5zcGFyZW5jeShkYXRhTWFwKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNoYWRlckNsb3N1cmU7XHJcblxyXG4iLCJ2YXIgQWJzdHJhY3RTaGFkZXJDb21wb3NlciA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdHNoYWRlcmNvbXBvc2VyLmpzXCIpLkFic3RyYWN0U2hhZGVyQ29tcG9zZXI7XHJcbnZhciBVUk5TaGFkZXJDbG9zdXJlPSByZXF1aXJlKFwiLi91cm5zaGFkZXJjbG9zdXJlLmpzXCIpO1xyXG52YXIgU2hhZGVyRGVzY3JpcHRvciA9IHJlcXVpcmUoXCIuL3NoYWRlci1kZXNjcmlwdG9yLmpzXCIpO1xyXG52YXIgQ29tcHV0ZVJlcXVlc3QgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL3JlcXVlc3QuanNcIikuQ29tcHV0ZVJlcXVlc3Q7XHJcbnZhciBhZGRGcmFnbWVudFNoYWRlckhlYWRlciA9IHJlcXVpcmUoXCIuLi8uLi9zaGFkZXIvc2hhZGVyLXV0aWxzLmpzXCIpLmFkZEZyYWdtZW50U2hhZGVySGVhZGVyO1xyXG5yZXF1aXJlKFwiLi9kaWZmdXNlLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9waG9uZy5qc1wiKTtcclxucmVxdWlyZShcIi4vbWF0dGUuanNcIik7XHJcbnJlcXVpcmUoXCIuL3BvaW50LmpzXCIpO1xyXG5yZXF1aXJlKFwiLi91dGlsaXR5LmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxudmFyIGdldFNoYWRlckRlc2NyaXB0b3IgPSBmdW5jdGlvbiAocGF0aCkge1xyXG4gICAgdmFyIHNoYWRlck5hbWUgPSBwYXRoLnN1YnN0cmluZyhwYXRoLmxhc3RJbmRleE9mKCc6JykgKyAxKTtcclxuICAgIHJldHVybiBYTUwzRC5tYXRlcmlhbHMuZ2V0U2NyaXB0KHNoYWRlck5hbWUpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAaW1wbGVtZW50cyB7SVNoYWRlckNvbXBvc2VyfVxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFNoYWRlckNvbXBvc2VyXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIFVSTlNoYWRlckNvbXBvc2VyID0gZnVuY3Rpb24gKGNvbnRleHQsIG1hdGVyaWFsQ29uZmlndXJhdGlvbikge1xyXG4gICAgQWJzdHJhY3RTaGFkZXJDb21wb3Nlci5jYWxsKHRoaXMsIGNvbnRleHQsIG1hdGVyaWFsQ29uZmlndXJhdGlvbik7XHJcbiAgICB0aGlzLmRlc2NyaXB0b3IgPSBudWxsO1xyXG4gICAgdGhpcy5zZXRNYXRlcmlhbENvbmZpZ3VyYXRpb24obWF0ZXJpYWxDb25maWd1cmF0aW9uKTtcclxufTtcclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKFVSTlNoYWRlckNvbXBvc2VyLCBBYnN0cmFjdFNoYWRlckNvbXBvc2VyLCB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge01hdGVyaWFsQ29uZmlndXJhdGlvbn0gbWF0ZXJpYWxDb25maWd1cmF0aW9uXHJcbiAgICAgKi9cclxuICAgIHNldE1hdGVyaWFsQ29uZmlndXJhdGlvbjogZnVuY3Rpb24gKG1hdGVyaWFsQ29uZmlndXJhdGlvbikge1xyXG4gICAgICAgIHZhciBzaGFkZXJTY3JpcHRVUkkgPSBtYXRlcmlhbENvbmZpZ3VyYXRpb24ubW9kZWwudXJuO1xyXG4gICAgICAgIHRoaXMuc2V0U2hhZGVyU2NyaXB0KHNoYWRlclNjcmlwdFVSSSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRlc2NyaXB0b3IpIHtcclxuICAgICAgICAgICAgbWF0ZXJpYWxDb25maWd1cmF0aW9uLmRhdGFOb2RlICYmIHRoaXMudXBkYXRlUmVxdWVzdChtYXRlcmlhbENvbmZpZ3VyYXRpb24uZGF0YU5vZGUpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kZXNjcmlwdG9yLmZyYWdtZW50ID0gYWRkRnJhZ21lbnRTaGFkZXJIZWFkZXIodGhpcy5kZXNjcmlwdG9yLmZyYWdtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNoYWRlclNjcmlwdDogZnVuY3Rpb24gKHVyaSkge1xyXG5cclxuICAgICAgICBpZiAoIXVyaSkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIk1hdGVyaWFsIGhhcyBubyBzY3JpcHQgYXR0YWNoZWQ6IFwiLCB0aGlzLmFkYXB0ZXIubm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVyaS5zY2hlbWUgIT0gXCJ1cm5cIikge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIk1hdGVyaWFsIG1vZGVsIHJlZmVyZW5jZSBzaG91bGQgc3RhcnQgd2l0aCBhbiBVUk46IFwiLCB0aGlzLmFkYXB0ZXIubm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRTaGFkZXJEZXNjcmlwdG9yKHVyaS5wYXRoKTtcclxuICAgICAgICBpZiAoIWRlc2NyaXB0b3IpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBVUk46IFwiICsgdXJpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRvciA9IG5ldyBTaGFkZXJEZXNjcmlwdG9yKCk7XHJcbiAgICAgICAgWE1MM0QuZXh0ZW5kKHRoaXMuZGVzY3JpcHRvciwgZGVzY3JpcHRvcik7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFJlcXVlc3RGaWVsZHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5kZXNjcmlwdG9yLnVuaWZvcm1zKS5jb25jYXQoT2JqZWN0LmtleXModGhpcy5kZXNjcmlwdG9yLnNhbXBsZXJzKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBhdHRyaWJ1dGVzIHJlcXVpcmVkIGJ5IHRoZSBzaGFkZXJcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3Q8c3RyaW5nLCAqPn1cclxuICAgICAqL1xyXG4gICAgZ2V0U2hhZGVyQXR0cmlidXRlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlc2NyaXB0b3IuYXR0cmlidXRlcztcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlU2hhZGVyQ2xvc3VyZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVVJOU2hhZGVyQ2xvc3VyZSh0aGlzLmNvbnRleHQsIHRoaXMuZGVzY3JpcHRvcik7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZU9iamVjdERhdGFSZXF1ZXN0OiBmdW5jdGlvbiAob2JqZWN0RGF0YU5vZGUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHJlcXVlc3ROYW1lcyA9IFtcInBvc2l0aW9uXCJdO1xyXG4gICAgICAgIHJlcXVlc3ROYW1lcy5wdXNoLmFwcGx5KHJlcXVlc3ROYW1lcywgT2JqZWN0LmtleXModGhpcy5kZXNjcmlwdG9yLmF0dHJpYnV0ZXMpKTtcclxuICAgICAgICByZXF1ZXN0TmFtZXMucHVzaC5hcHBseShyZXF1ZXN0TmFtZXMsIE9iamVjdC5rZXlzKHRoaXMuZGVzY3JpcHRvci51bmlmb3JtcykpO1xyXG4gICAgICAgIHJlcXVlc3ROYW1lcy5wdXNoLmFwcGx5KHJlcXVlc3ROYW1lcywgT2JqZWN0LmtleXModGhpcy5kZXNjcmlwdG9yLnNhbXBsZXJzKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wdXRlUmVxdWVzdChvYmplY3REYXRhTm9kZSwgcmVxdWVzdE5hbWVzLCBjYWxsYmFjayk7XHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3RyaWJ1dGVPYmplY3RTaGFkZXJEYXRhOiBmdW5jdGlvbiAob2JqZWN0UmVxdWVzdCwgYXR0cmlidXRlQ2FsbGJhY2ssIHVuaWZvcm1DYWxsYmFjaykge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBvYmplY3RSZXF1ZXN0LmdldFJlc3VsdCgpO1xyXG5cclxuICAgICAgICB2YXIgZGF0YU1hcCA9IHJlc3VsdC5nZXRPdXRwdXRNYXAoKTtcclxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGRhdGFNYXApIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChuYW1lID09IFwicG9zaXRpb25cIiB8fCB0aGlzLmRlc2NyaXB0b3IuYXR0cmlidXRlc1tuYW1lXSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlQ2FsbGJhY2sobmFtZSwgZGF0YU1hcFtuYW1lXSk7IGVsc2UgaWYgKHRoaXMuZGVzY3JpcHRvci51bmlmb3Jtc1tuYW1lXSAhPT0gdW5kZWZpbmVkIHx8IHRoaXMuZGVzY3JpcHRvci5zYW1wbGVyc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB1bmlmb3JtQ2FsbGJhY2sobmFtZSwgZGF0YU1hcFtuYW1lXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVVJOU2hhZGVyQ29tcG9zZXI7XHJcblxyXG5cclxuIiwiWE1MM0QubWF0ZXJpYWxzLnJlZ2lzdGVyKFwicGlja29iamVjdGlkXCIsIHtcclxuICAgIHZlcnRleCA6IFtcclxuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBtYXQ0IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXg7XCIsXHJcblxyXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcclxuICAgICAgICBcIiAgICBnbF9Qb3NpdGlvbiA9IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1wiLFxyXG4gICAgICAgIFwifVwiXHJcbiAgICBdLmpvaW4oXCJcXG5cIiksXHJcblxyXG4gICAgZnJhZ21lbnQgOiBbXHJcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgaWQ7XCIsXHJcblxyXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcclxuICAgICAgICBcIiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGlkLCAwLjApO1wiLFxyXG4gICAgICAgIFwifVwiXHJcbiAgICBdLmpvaW4oXCJcXG5cIiksXHJcblxyXG4gICAgdW5pZm9ybXMgOiB7fVxyXG59KTtcclxuXHJcblhNTDNELm1hdGVyaWFscy5yZWdpc3RlcihcInBpY2tlZHBvc2l0aW9uXCIsIHtcclxuICAgIHZlcnRleCA6IFtcclxuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBtYXQ0IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXg7XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgYmJveFsyXTtcIiwgIC8vIG1pbiA9IGJib3hbMF0sIG1heCA9IGJib3hbMV1cclxuXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgd29ybGRDb29yZDtcIixcclxuXHJcbiAgICAgICAgXCJ2b2lkIG1haW4odm9pZCkge1wiLFxyXG4gICAgICAgIFwiICAgIHdvcmxkQ29vcmQgPSAobW9kZWxNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApKS54eXo7XCIsXHJcbiAgICAgICAgXCIgICAgdmVjMyBkaWZmID0gYmJveFsxXSAtIGJib3hbMF07XCIsXHJcbiAgICAgICAgXCIgICAgd29ybGRDb29yZCA9IHdvcmxkQ29vcmQgLSBiYm94WzBdO1wiLFxyXG4gICAgICAgIFwiICAgIHdvcmxkQ29vcmQgPSB3b3JsZENvb3JkIC8gZGlmZjtcIixcclxuICAgICAgICBcIiAgICBnbF9Qb3NpdGlvbiA9IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1wiLFxyXG4gICAgICAgIFwifVwiXHJcbiAgICBdLmpvaW4oXCJcXG5cIiksXHJcblxyXG4gICAgZnJhZ21lbnQgOiBbXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgd29ybGRDb29yZDtcIixcclxuXHJcbiAgICAgICAgXCJ2b2lkIG1haW4odm9pZCkge1wiLFxyXG4gICAgICAgIFwiICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQod29ybGRDb29yZCwgMS4wKTtcIixcclxuICAgICAgICBcIn1cIlxyXG4gICAgXS5qb2luKFwiXFxuXCIpLFxyXG5cclxuICAgIHVuaWZvcm1zIDoge31cclxufSk7XHJcblxyXG5cclxuWE1MM0QubWF0ZXJpYWxzLnJlZ2lzdGVyKFwicGlja2VkTm9ybWFsc1wiLCB7XHJcbiAgICB2ZXJ0ZXggOiBbXHJcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcIixcclxuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMzIG5vcm1hbDtcIixcclxuICAgICAgICBcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4O1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBtYXQzIG1vZGVsVmlld01hdHJpeE47XCIsXHJcblxyXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIGZyYWdOb3JtYWw7XCIsXHJcblxyXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcclxuICAgICAgICBcIiAgICBmcmFnTm9ybWFsID0gbm9ybWFsaXplKG1vZGVsVmlld01hdHJpeE4gKiBub3JtYWwpO1wiLFxyXG4gICAgICAgIFwiICAgIGdsX1Bvc2l0aW9uID0gbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XCIsXHJcbiAgICAgICAgXCJ9XCJcclxuICAgIF0uam9pbihcIlxcblwiKSxcclxuXHJcbiAgICBmcmFnbWVudCA6IFtcclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnTm9ybWFsO1wiLFxyXG5cclxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXHJcbiAgICAgICAgXCIgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgoZnJhZ05vcm1hbCsxLjApLzIuMCAqICgyNTQuMCAvIDI1NS4wKSwgMS4wKTtcIixcclxuICAgICAgICBcIn1cIlxyXG4gICAgXS5qb2luKFwiXFxuXCIpLFxyXG5cclxuICAgIHVuaWZvcm1zIDoge31cclxufSk7XHJcblxyXG5YTUwzRC5tYXRlcmlhbHMucmVnaXN0ZXIoXCJsaWdodC1kZXB0aFwiLCB7XHJcblxyXG4gICAgdmVydGV4OiBbXHJcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcIixcclxuICAgICAgICBcInZhcnlpbmcgdmVjNCB3b3JsZFBvc2l0aW9uO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBtYXQ0IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXg7XCIsXHJcblxyXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcclxuICAgICAgICBcIiAgIHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XCIsXHJcbiAgICAgICAgXCIgICBnbF9Qb3NpdGlvbiAgID0gbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XCIsXHJcbiAgICAgICAgXCJ9XCJcclxuICAgIF0uam9pbihcIlxcblwiKSxcclxuXHJcbiAgICBmcmFnbWVudDogW1xyXG4gICAgICAgIFwidmFyeWluZyB2ZWM0IHdvcmxkUG9zaXRpb247XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcIixcclxuXHJcbiAgICAgICAgXCJ2ZWM0IHBhY2tfZGVwdGgoIGNvbnN0IGluIGZsb2F0IGRlcHRoICkge1wiLFxyXG4gICAgICAgIFwiY29uc3QgdmVjNCBiaXRfc2hpZnQgPSB2ZWM0KCAyNTYuMCAqIDI1Ni4wICogMjU2LjAsIDI1Ni4wICogMjU2LjAsIDI1Ni4wLCAxLjAgKTtcIixcclxuICAgICAgICBcImNvbnN0IHZlYzQgYml0X21hc2sgID0gdmVjNCggMC4wLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjAsIDEuMCAvIDI1Ni4wICk7XCIsXHJcbiAgICAgICAgXCJ2ZWM0IHJlcyA9IGZyYWN0KCBkZXB0aCAqIGJpdF9zaGlmdCApO1wiLFxyXG4gICAgICAgIFwicmVzIC09IHJlcy54eHl6ICogYml0X21hc2s7XCIsXHJcbiAgICAgICAgXCJyZXR1cm4gcmVzO1wiLFxyXG4gICAgICAgIFwifVwiLFxyXG5cclxuXHJcbiAgICAgICAgXCJ2b2lkIG1haW4odm9pZCkge1wiLFxyXG4gICAgICAgIFwiICAgIGdsX0ZyYWdDb2xvciA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdDb29yZC56ICk7XCIsXHJcbiAgICAgICAgXCJ9XCJcclxuICAgIF0uam9pbihcIlxcblwiKSxcclxuXHJcbiAgICB1bmlmb3Jtczoge31cclxufSk7XHJcblxyXG5YTUwzRC5tYXRlcmlhbHMucmVnaXN0ZXIoXCJyZW5kZXItbm9ybWFsXCIsIHtcclxuICAgIHZlcnRleCA6IFtcclxuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1wiLFxyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzMgbm9ybWFsO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBtYXQ0IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXg7XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDMgbW9kZWxNYXRyaXhOO1wiLFxyXG5cclxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnTm9ybWFsO1wiLFxyXG5cclxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXHJcbiAgICAgICAgXCIgICAgZnJhZ05vcm1hbCA9IG1vZGVsTWF0cml4TiAqIG5vcm1hbDtcIixcclxuICAgICAgICBcIiAgICBnbF9Qb3NpdGlvbiA9IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1wiLFxyXG4gICAgICAgIFwifVwiXHJcbiAgICBdLmpvaW4oXCJcXG5cIiksXHJcblxyXG4gICAgZnJhZ21lbnQgOiBbXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ05vcm1hbDtcIixcclxuXHJcbiAgICAgICAgXCJ2b2lkIG1haW4odm9pZCkge1wiLFxyXG4gICAgICAgIFwiICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgobm9ybWFsaXplKGZyYWdOb3JtYWwpICsgMS4wKSAvIDIuMCwgMS4wKTtcIixcclxuICAgICAgICBcIn1cIlxyXG4gICAgXS5qb2luKFwiXFxuXCIpLFxyXG5cclxuICAgIHVuaWZvcm1zIDoge31cclxufSk7XHJcblxyXG5YTUwzRC5tYXRlcmlhbHMucmVnaXN0ZXIoXCJyZW5kZXItcG9zaXRpb25cIiwge1xyXG4gICAgdmVydGV4IDogW1xyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeDtcIixcclxuXHJcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgd29ybGRDb29yZDtcIixcclxuXHJcbiAgICAgICAgXCJ2b2lkIG1haW4odm9pZCkge1wiLFxyXG4gICAgICAgIFwiICAgIHdvcmxkQ29vcmQgPSAobW9kZWxNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApKS54eXo7XCIsXHJcbiAgICAgICAgXCIgICAgZ2xfUG9zaXRpb24gPSBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcIixcclxuICAgICAgICBcIn1cIlxyXG4gICAgXS5qb2luKFwiXFxuXCIpLFxyXG5cclxuICAgIGZyYWdtZW50IDogW1xyXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIHdvcmxkQ29vcmQ7XCIsXHJcblxyXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcclxuICAgICAgICBcIiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHdvcmxkQ29vcmQsIDEuMCk7XCIsXHJcbiAgICAgICAgXCJ9XCJcclxuICAgIF0uam9pbihcIlxcblwiKSxcclxuXHJcbiAgICB1bmlmb3JtcyA6IHt9XHJcbn0pO1xyXG5cclxuWE1MM0QubWF0ZXJpYWxzLnJlZ2lzdGVyKFwiYm94Ymx1clwiLCB7XHJcbiAgICB2ZXJ0ZXg6IFtcclxuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1wiLFxyXG5cclxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXHJcbiAgICAgICAgXCIgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDEuMCk7XCIsXHJcbiAgICAgICAgXCJ9XCJcclxuICAgIF0uam9pbihcIlxcblwiKSxcclxuXHJcbiAgICBmcmFnbWVudDogW1xyXG4gICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgc0luVGV4dHVyZTtcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMiBjYW52YXNTaXplO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSB2ZWMyIGJsdXJPZmZzZXQ7XCIsXHJcblxyXG4gICAgICAgIFwiY29uc3QgZmxvYXQgYmx1clNpemUgPSAxLjAvNTEyLjA7XCIsXHJcblxyXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcclxuICAgICAgICBcIiAgIHZlYzIgdGV4Y29vcmQgPSAoZ2xfRnJhZ0Nvb3JkLnh5IC8gY2FudmFzU2l6ZS54eSk7XCIsXHJcbiAgICAgICAgXCIgICB2ZWM0IHN1bSA9IHZlYzQoMC4wKTtcIixcclxuICAgICAgICBcIiAgIGZsb2F0IGJsdXJTaXplWSA9IGJsdXJPZmZzZXQueSAvIGNhbnZhc1NpemUueTtcIixcclxuICAgICAgICBcIiAgIGZsb2F0IGJsdXJTaXplWCA9IGJsdXJPZmZzZXQueCAvIGNhbnZhc1NpemUueDtcIixcclxuXHJcbiAgICAgICAgXCIgICBzdW0gKz0gdGV4dHVyZTJEKHNJblRleHR1cmUsIHZlYzIodGV4Y29vcmQueCwgdGV4Y29vcmQueSAtIDEuNSpibHVyU2l6ZVkpKTtcIixcclxuICAgICAgICBcIiAgIHN1bSArPSB0ZXh0dXJlMkQoc0luVGV4dHVyZSwgdmVjMih0ZXhjb29yZC54LCB0ZXhjb29yZC55IC0gMi4wKmJsdXJTaXplWSkpO1wiLFxyXG4gICAgICAgIFwiICAgc3VtICs9IHRleHR1cmUyRChzSW5UZXh0dXJlLCB2ZWMyKHRleGNvb3JkLngsIHRleGNvb3JkLnkgLSBibHVyU2l6ZVkpKTtcIixcclxuICAgICAgICBcIiAgIHN1bSArPSB0ZXh0dXJlMkQoc0luVGV4dHVyZSwgdmVjMih0ZXhjb29yZC54LCB0ZXhjb29yZC55ICsgYmx1clNpemVZKSk7XCIsXHJcbiAgICAgICAgXCIgICBzdW0gKz0gdGV4dHVyZTJEKHNJblRleHR1cmUsIHZlYzIodGV4Y29vcmQueCwgdGV4Y29vcmQueSArIDIuMCpibHVyU2l6ZVkpKTtcIixcclxuICAgICAgICBcIiAgIHN1bSArPSB0ZXh0dXJlMkQoc0luVGV4dHVyZSwgdmVjMih0ZXhjb29yZC54LCB0ZXhjb29yZC55ICsgMS41KmJsdXJTaXplWSkpO1wiLFxyXG5cclxuICAgICAgICBcIiAgIHN1bSArPSB0ZXh0dXJlMkQoc0luVGV4dHVyZSwgdmVjMih0ZXhjb29yZC54IC0gMS41KmJsdXJTaXplWCwgdGV4Y29vcmQueSkpO1wiLFxyXG4gICAgICAgIFwiICAgc3VtICs9IHRleHR1cmUyRChzSW5UZXh0dXJlLCB2ZWMyKHRleGNvb3JkLnggLSAyLjAqYmx1clNpemVYLCB0ZXhjb29yZC55KSk7XCIsXHJcbiAgICAgICAgXCIgICBzdW0gKz0gdGV4dHVyZTJEKHNJblRleHR1cmUsIHZlYzIodGV4Y29vcmQueCAtIGJsdXJTaXplWCwgdGV4Y29vcmQueSkpO1wiLFxyXG4gICAgICAgIFwiICAgc3VtICs9IHRleHR1cmUyRChzSW5UZXh0dXJlLCB2ZWMyKHRleGNvb3JkLnggKyBibHVyU2l6ZVgsIHRleGNvb3JkLnkpKTtcIixcclxuICAgICAgICBcIiAgIHN1bSArPSB0ZXh0dXJlMkQoc0luVGV4dHVyZSwgdmVjMih0ZXhjb29yZC54ICsgMi4wKmJsdXJTaXplWCwgdGV4Y29vcmQueSkpO1wiLFxyXG4gICAgICAgIFwiICAgc3VtICs9IHRleHR1cmUyRChzSW5UZXh0dXJlLCB2ZWMyKHRleGNvb3JkLnggKyAxLjUqYmx1clNpemVYLCB0ZXhjb29yZC55KSk7XCIsXHJcblxyXG4gICAgICAgIFwiICAgZ2xfRnJhZ0NvbG9yID0gc3VtIC8gMTIuMDtcIixcclxuICAgICAgICBcIn1cIlxyXG4gICAgXS5qb2luKFwiXFxuXCIpLFxyXG5cclxuICAgIHVuaWZvcm1zOiB7XHJcbiAgICAgICAgY2FudmFzU2l6ZSA6IFs1MTIsIDUxMl0sXHJcbiAgICAgICAgYmx1ck9mZnNldCA6IFsxLjAsIDEuMF1cclxuICAgIH0sXHJcblxyXG4gICAgc2FtcGxlcnM6IHtcclxuICAgICAgICBzSW5UZXh0dXJlIDogbnVsbFxyXG4gICAgfVxyXG59KTtcclxuXHJcblhNTDNELm1hdGVyaWFscy5yZWdpc3RlcihcInNzYW9cIiwge1xyXG4gICAgdmVydGV4IDogW1xyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XCIsXHJcblxyXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcclxuICAgICAgICBcIiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDAuMCwgMS4wKTtcIixcclxuICAgICAgICBcIn1cIlxyXG4gICAgXS5qb2luKFwiXFxuXCIpLFxyXG5cclxuICAgIGZyYWdtZW50IDogW1xyXG4gICAgICAgIFwiI2lmZGVmIEdMX0VTXCIsXHJcbiAgICAgICAgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XCIsXHJcbiAgICAgICAgXCIjZW5kaWZcIixcclxuXHJcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzIgY2FudmFzU2l6ZTtcIixcclxuICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIHNQb3NpdGlvblRleDtcIixcclxuICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIHNOb3JtYWxUZXg7XCIsXHJcbiAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCBzUmFuZG9tTm9ybWFscztcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMiB1UmFuZG9tVGV4U2l6ZTtcIixcclxuICAgICAgICBcInVuaWZvcm0gZmxvYXQgdVNhbXBsZVJhZGl1cztcIixcclxuICAgICAgICBcInVuaWZvcm0gZmxvYXQgdVNjYWxlO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCB1QmlhcztcIixcclxuICAgICAgICBcInVuaWZvcm0gZmxvYXQgdUludGVuc2l0eTtcIixcclxuICAgICAgICBcInVuaWZvcm0gdmVjMiB1Q29uc3RWZWN0b3JzWzRdO1wiLFxyXG4gICAgICAgIFwidW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XCIsXHJcblxyXG4gICAgICAgIFwidmVjMyBnZXRQb3NpdGlvbih2ZWMyIHV2KSB7XCIsXHJcbiAgICAgICAgXCJyZXR1cm4gdGV4dHVyZTJEKHNQb3NpdGlvblRleCwgdXYpLnh5ejtcIixcclxuICAgICAgICBcIn1cIixcclxuXHJcbiAgICAgICAgXCJmbG9hdCBjYWxjQW1iaWVudE9jY2x1c2lvbih2ZWMyIHNjcmVlblVWLCB2ZWMyIHV2T2Zmc2V0LCB2ZWMzIG9yaWdpbiwgdmVjMyBjbm9ybSkge1wiLFxyXG4gICAgICAgIFwiICAgdmVjMyBkaWZmID0gZ2V0UG9zaXRpb24oc2NyZWVuVVYgKyB1dk9mZnNldCkgLSBvcmlnaW47XCIsXHJcbiAgICAgICAgXCIgICB2ZWMzIHYgPSBub3JtYWxpemUoZGlmZik7XCIsXHJcbiAgICAgICAgXCIgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKGRpZmYpICogdVNjYWxlO1wiLFxyXG4gICAgICAgIFwiICAgcmV0dXJuIG1heCgwLjAsIGRvdChjbm9ybSwgdikgLSB1QmlhcykgKiAoMS4wLygxLjAgKyBkaXN0KSkgKiB1SW50ZW5zaXR5O1wiLFxyXG4gICAgICAgIFwifVwiLFxyXG5cclxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXHJcbiAgICAgICAgXCIgICB2ZWMyIHNjcmVlblVWID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gY2FudmFzU2l6ZS54eTtcIixcclxuICAgICAgICBcIiAgIHZlYzIgcmFuZCA9IG5vcm1hbGl6ZSh0ZXh0dXJlMkQoc1JhbmRvbU5vcm1hbHMsIGdsX0ZyYWdDb29yZC54eSAvIHVSYW5kb21UZXhTaXplKS54eSAqIDIuMCAtIDEuMCApO1wiLFxyXG4gICAgICAgIFwiICAgdmVjMyBub3JtID0gbm9ybWFsaXplKHRleHR1cmUyRChzTm9ybWFsVGV4LCBzY3JlZW5VVikueHl6ICogMi4wIC0gMS4wICk7XCIsXHJcbiAgICAgICAgXCIgICB2ZWMzIG9yaWdpbiA9IGdldFBvc2l0aW9uKHNjcmVlblVWKTtcIixcclxuICAgICAgICBcIiAgIGZsb2F0IHJhZGl1cyA9IHVTYW1wbGVSYWRpdXMgLyAodmlld01hdHJpeCAqIHZlYzQob3JpZ2luLCAxLjApKS56O1wiLFxyXG4gICAgICAgIFwiICAgZmxvYXQgYW8gPSAwLjA7XCIsXHJcblxyXG4gICAgICAgIFwiICAgY29uc3QgaW50IGl0ZXJhdGlvbnMgPSA0O1wiLFxyXG4gICAgICAgIFwiICAgZm9yIChpbnQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyArK2kpIHtcIixcclxuICAgICAgICBcIiAgICAgICB2ZWMyIGNvb3JkMSA9IHJlZmxlY3QodUNvbnN0VmVjdG9yc1tpXSwgcmFuZCkgKiByYWRpdXM7XCIsXHJcbiAgICAgICAgXCIgICAgICAgdmVjMiBjb29yZDIgPSB2ZWMyKGNvb3JkMS54KjAuNzA3IC0gY29vcmQxLnkqMC43MDcsIGNvb3JkMS54KjAuNzA3ICsgY29vcmQxLnkqMC43MDcpO1wiLFxyXG4gICAgICAgIFwiICAgICAgIGFvICs9IGNhbGNBbWJpZW50T2NjbHVzaW9uKHNjcmVlblVWLCBjb29yZDEqMC4yNSwgb3JpZ2luLCBub3JtKTtcIixcclxuICAgICAgICBcIiAgICAgICBhbyArPSBjYWxjQW1iaWVudE9jY2x1c2lvbihzY3JlZW5VViwgY29vcmQyKjAuNSwgb3JpZ2luLCBub3JtKTtcIixcclxuICAgICAgICBcIiAgICAgICBhbyArPSBjYWxjQW1iaWVudE9jY2x1c2lvbihzY3JlZW5VViwgY29vcmQxKjAuNzUsIG9yaWdpbiwgbm9ybSk7XCIsXHJcbiAgICAgICAgXCIgICAgICAgYW8gKz0gY2FsY0FtYmllbnRPY2NsdXNpb24oc2NyZWVuVVYsIGNvb3JkMiwgb3JpZ2luLCBub3JtKTtcIixcclxuICAgICAgICBcIiAgIH1cIixcclxuICAgICAgICBcIiAgIGFvIC89IChmbG9hdChpdGVyYXRpb25zKSAqIDQuMCk7XCIsXHJcbiAgICAgICAgXCIgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGFvLCBhbywgYW8sIDEuMCk7XCIsXHJcbiAgICAgICAgXCJ9XCJcclxuICAgIF0uam9pbihcIlxcblwiKSxcclxuXHJcbiAgICB1bmlmb3Jtczoge1xyXG4gICAgICAgIGNhbnZhc1NpemUgICAgICA6IFs1MTIsIDUxMl0sXHJcbiAgICAgICAgdUNvbnN0VmVjdG9ycyAgIDogWzEsMCwgLTEsMCwgMCwxLCAwLC0xXSxcclxuICAgICAgICB1UmFuZG9tVGV4U2l6ZSAgOiBbNjQsNjRdLFxyXG4gICAgICAgIHVTYW1wbGVSYWRpdXMgICA6IDAuOSxcclxuICAgICAgICB1U2NhbGUgICAgICAgICAgOiAwLjksXHJcbiAgICAgICAgdUJpYXMgICAgICAgICAgIDogMC4yLFxyXG4gICAgICAgIHVJbnRlbnNpdHkgICAgICA6IDEuMFxyXG4gICAgfSxcclxuXHJcbiAgICBzYW1wbGVyczoge1xyXG4gICAgICAgIHNQb3NpdGlvblRleCAgIDogbnVsbCxcclxuICAgICAgICBzTm9ybWFsVGV4ICAgICA6IG51bGwsXHJcbiAgICAgICAgc1JhbmRvbU5vcm1hbHMgOiBudWxsXHJcbiAgICB9LFxyXG5cclxuICAgIGF0dHJpYnV0ZXM6IHtcclxuICAgIH1cclxufSk7XHJcbiIsIi8vIE5vdGU6IFRoaXMgY29udGV4dCBzaG91bGQgb25seSBiZSB1c2VkIHRvIGFjY2VzcyBHTCBjb25zdGFudHNcclxudmFyIEdMID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xyXG52YXIgVGFyZ2V0cyA9IHJlcXVpcmUoXCIuL2Jhc2UvcmVuZGVydGFyZ2V0LmpzXCIpO1xyXG52YXIgRnVsbFNjcmVlblF1YWQgPSByZXF1aXJlKFwiLi9iYXNlL2Z1bGxzY3JlZW5xdWFkLmpzXCIpO1xyXG52YXIgRm9yd2FyZFJlbmRlclRyZWUgPSByZXF1aXJlKFwiLi9yZW5kZXItdHJlZXMvZm9yd2FyZC5qc1wiKTtcclxudmFyIEZvcndhcmRSZW5kZXJQYXNzID0gcmVxdWlyZShcIi4vcmVuZGVyLXBhc3Nlcy9mb3J3YXJkLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7R0xDb250ZXh0fSBjb250ZXh0XHJcbiAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIEdMUmVuZGVySW50ZXJmYWNlID0gZnVuY3Rpb24gKGNvbnRleHQsIHNjZW5lKSB7XHJcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG4gICAgdGhpcy5zaGFkZXJzID0ge307XHJcbiAgICB0aGlzLm9wdGlvbnMgPSB7XHJcbiAgICAgICAgcGlja2luZ0VuYWJsZWQ6IHRydWUsXHJcbiAgICAgICAgbW91c2VNb3ZlUGlja2luZ0VuYWJsZWQ6IHRydWUsXHJcbiAgICAgICAgZ2xCbGVuZEZ1bmNTZXBhcmF0ZTogW0dMLlNSQ19BTFBIQSwgR0wuT05FX01JTlVTX1NSQ19BTFBIQSwgR0wuT05FLCBHTC5PTkVfTUlOVVNfU1JDX0FMUEhBXVxyXG4gICAgfTtcclxuICAgIHRoaXMucmVuZGVyVHJlZSA9IG51bGw7XHJcbn07XHJcblxyXG5YTUwzRC5leHRlbmQoR0xSZW5kZXJJbnRlcmZhY2UucHJvdG90eXBlLCB7XHJcbiAgICBnZXRSZW5kZXJUcmVlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnJlbmRlclRyZWUgPSB0aGlzLnJlbmRlclRyZWUgfHwgbmV3IEZvcndhcmRSZW5kZXJUcmVlKHRoaXMuY29udGV4dCkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRSZW5kZXJUcmVlOiBmdW5jdGlvbiAodHJlZSkge1xyXG4gICAgICAgIC8vVE9ETyBjbGVhbnVwIG9sZCBwaXBlbGluZVxyXG4gICAgICAgIHRoaXMucmVuZGVyVHJlZSA9IHRyZWU7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlcXVlc3RSZWRyYXcoXCJQaXBlbGluZSBjaGFuZ2VkXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVSZW5kZXJUYXJnZXQ6IGZ1bmN0aW9uKG9wdCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0cy5HTFJlbmRlclRhcmdldCh0aGlzLmNvbnRleHQsIG9wdCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVNjYWxlZFJlbmRlclRhcmdldDogZnVuY3Rpb24obWF4RGltZW5zaW9uLCBvcHQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFRhcmdldHMuR0xTY2FsZWRSZW5kZXJUYXJnZXQodGhpcy5jb250ZXh0LCBtYXhEaW1lbnNpb24sIG9wdCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFNoYWRlclByb2dyYW06IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2hhZGVyc1tuYW1lXSB8fCAhdGhpcy5zaGFkZXJzW25hbWVdLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRlcnNbbmFtZV0gPSB0aGlzLmNvbnRleHQucHJvZ3JhbUZhY3RvcnkuZ2V0UHJvZ3JhbUJ5TmFtZShuYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnNoYWRlcnNbbmFtZV07XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZUZ1bGxzY3JlZW5RdWFkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEZ1bGxTY3JlZW5RdWFkKHRoaXMuY29udGV4dCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVNjZW5lUmVuZGVyUGFzczogZnVuY3Rpb24odGFyZ2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGb3J3YXJkUmVuZGVyUGFzcyh0aGlzLCB0YXJnZXQgfHwgdGhpcy5jb250ZXh0LmNhbnZhc1RhcmdldCk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHTFJlbmRlckludGVyZmFjZTtcclxuXHJcbiIsIi8qKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBCYXNlUmVuZGVyUGFzcyA9IGZ1bmN0aW9uIChyZW5kZXJJbnRlcmZhY2UsIG91dHB1dCwgb3B0KSB7XHJcbiAgICB0aGlzLnJlbmRlckludGVyZmFjZSA9IHJlbmRlckludGVyZmFjZTtcclxuICAgIHRoaXMub3V0cHV0ID0gb3V0cHV0O1xyXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xyXG4gICAgdGhpcy5pbnB1dHMgPSBvcHQuaW5wdXRzIHx8IHt9O1xyXG4gICAgdGhpcy5pZCA9IG9wdC5pZCB8fCBcIlwiO1xyXG4gICAgdGhpcy5wcmVQYXNzZXMgPSBbXTtcclxuICAgIHRoaXMucG9zdFBhc3NlcyA9IFtdO1xyXG4gICAgdGhpcy5wcm9jZXNzZWQgPSBmYWxzZTtcclxufTtcclxuXHJcblhNTDNELmV4dGVuZChCYXNlUmVuZGVyUGFzcy5wcm90b3R5cGUsIHtcclxuICAgIGFkZFByZVBhc3M6IGZ1bmN0aW9uIChwYXNzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJlUGFzc2VzLmluZGV4T2YocGFzcykgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlUGFzc2VzLnB1c2gocGFzcyk7XHJcbiAgICAgICAgICAgIHBhc3MucG9zdFBhc3Nlcy5wdXNoKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlUHJlUGFzczogZnVuY3Rpb24gKHBhc3MpIHtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5wcmVQYXNzZXMuaW5kZXhPZihwYXNzKTtcclxuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLnByZVBhc3Nlcy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICAgICAgcGFzcy5wb3N0UGFzc2VzLnNwbGljZShwYXNzLnBvc3RQYXNzZXMuaW5kZXhPZih0aGlzKSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhclByZVBhc3NlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5wcmVQYXNzZXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChpLS0pXHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUHJlUGFzcyh0aGlzLnByZVBhc3Nlc1tpXSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFByb2Nlc3NlZDogZnVuY3Rpb24gKHByb2Nlc3NlZCkge1xyXG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NlZCAmJiAhcHJvY2Vzc2VkKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5wb3N0UGFzc2VzLmxlbmd0aDtcclxuICAgICAgICAgICAgd2hpbGUgKGktLSlcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zdFBhc3Nlc1tpXS5zZXRQcm9jZXNzZWQoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnByb2Nlc3NlZCA9IHByb2Nlc3NlZDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVuZGVyVHJlZTogZnVuY3Rpb24gKHNjZW5lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlO1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5wcmVQYXNzZXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChpLS0pXHJcbiAgICAgICAgICAgIHRoaXMucHJlUGFzc2VzW2ldLnJlbmRlclRyZWUoc2NlbmUpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyKHNjZW5lKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBwaXhlbHMgZnJvbSB0aGUgcGFzcydzIHRhcmdldFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBnbFggT3BlbkdMIENvb3JkaW5hdGUgaW4gdGhlIHRhcmdldFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdsWSBPcGVuR0wgQ29vcmRpbmF0ZSBpbiB0aGUgdGFyZ2V0XHJcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX0gcGl4ZWwgZGF0YVxyXG4gICAgICovXHJcbiAgICByZWFkUGl4ZWxEYXRhRnJvbUJ1ZmZlcjogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY19kYXRhID0gbmV3IFVpbnQ4QXJyYXkoOCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ2xYLCBnbFksIHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlckludGVyZmFjZS5jb250ZXh0LmdsO1xyXG4gICAgICAgICAgICB2YXIgc2NhbGUgPSB0YXJnZXQuZ2V0U2NhbGUoKTtcclxuICAgICAgICAgICAgdmFyIHggPSBnbFggKiBzY2FsZTtcclxuICAgICAgICAgICAgdmFyIHkgPSBnbFkgKiBzY2FsZTtcclxuXHJcbiAgICAgICAgICAgIHRhcmdldC5iaW5kKCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBnbC5yZWFkUGl4ZWxzKHgsIHksIDEsIDEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGNfZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQudW5iaW5kKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY19kYXRhO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFeGNlcHRpb24oZSk7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQudW5iaW5kKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0oKSlcclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYXNlUmVuZGVyUGFzcztcclxuXHJcbiIsInZhciBCYXNlUmVuZGVyUGFzcyA9IHJlcXVpcmUoXCIuL2Jhc2UuanNcIik7XHJcbnZhciBGdWxsc2NyZWVuUXVhZCA9IHJlcXVpcmUoXCIuLi9iYXNlL2Z1bGxzY3JlZW5xdWFkLmpzXCIpO1xyXG5cclxudmFyIEJveEJsdXJQYXNzID0gZnVuY3Rpb24gKHJlbmRlckludGVyZmFjZSwgb3V0cHV0LCBvcHQpIHtcclxuICAgIEJhc2VSZW5kZXJQYXNzLmNhbGwodGhpcywgcmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCk7XHJcbiAgICB0aGlzLl9wcm9ncmFtID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5wcm9ncmFtRmFjdG9yeS5nZXRQcm9ncmFtQnlOYW1lKFwiYm94Ymx1clwiKTtcclxuICAgIHRoaXMuX3NjcmVlblF1YWQgPSBuZXcgRnVsbHNjcmVlblF1YWQodGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dCk7XHJcbiAgICB0aGlzLl91bmlmb3Jtc0RpcnR5ID0gdHJ1ZTtcclxufTtcclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKEJveEJsdXJQYXNzLCBCYXNlUmVuZGVyUGFzcyk7XHJcblxyXG5YTUwzRC5leHRlbmQoQm94Qmx1clBhc3MucHJvdG90eXBlLCB7XHJcbiAgICByZW5kZXI6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5nbDtcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMub3V0cHV0O1xyXG5cclxuICAgICAgICAgICAgdGFyZ2V0LmJpbmQoKTtcclxuICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmFtLmJpbmQoKTtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Tm9uVm9sYXRpbGVTaGFkZXJVbmlmb3JtcygpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fc2NyZWVuUXVhZC5kcmF3KHRoaXMuX3Byb2dyYW0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fcHJvZ3JhbS51bmJpbmQoKTtcclxuICAgICAgICAgICAgdGFyZ2V0LnVuYmluZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0oKSksXHJcblxyXG4gICAgX3NldE5vblZvbGF0aWxlU2hhZGVyVW5pZm9ybXM6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHVuaWZvcm1zID0ge307XHJcbiAgICAgICAgdmFyIHVuaWZvcm1OYW1lcyA9IFtcImNhbnZhc1NpemVcIiwgXCJzSW5UZXh0dXJlXCIsIFwiYmx1ck9mZnNldFwiXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl91bmlmb3Jtc0RpcnR5KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgdmFyIHByb2dyYW0gPSB0aGlzLl9wcm9ncmFtO1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5vdXRwdXQ7XHJcblxyXG4gICAgICAgICAgICB1bmlmb3Jtc1tcImNhbnZhc1NpemVcIl0gPSBbdGFyZ2V0LndpZHRoLCB0YXJnZXQuaGVpZ2h0XTtcclxuICAgICAgICAgICAgdW5pZm9ybXNbXCJzSW5UZXh0dXJlXCJdID0gW3RoaXMuaW5wdXRzLmJ1ZmZlci5jb2xvclRhcmdldC5oYW5kbGVdO1xyXG4gICAgICAgICAgICB1bmlmb3Jtc1tcImJsdXJPZmZzZXRcIl0gPSBbMS4wLCAxLjBdO1xyXG4gICAgICAgICAgICBwcm9ncmFtLnNldFN5c3RlbVVuaWZvcm1WYXJpYWJsZXModW5pZm9ybU5hbWVzLCB1bmlmb3Jtcyk7XHJcblxyXG4vLyAgICAgICAgICAgICAgICB0aGlzLl91bmlmb3Jtc0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSkoKVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQm94Qmx1clBhc3M7XHJcblxyXG4iLCJ2YXIgU2NlbmVSZW5kZXJQYXNzID0gcmVxdWlyZShcIi4vc2NlbmUtcGFzcy5qc1wiKTtcclxudmFyIE9iamVjdFNvcnRlciA9IHJlcXVpcmUoXCIuLi8uLi9yZW5kZXJlci90b29scy9vYmplY3Rzb3J0ZXIuanNcIik7XHJcbnZhciBtYXQ0ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS5tYXQ0O1xyXG5cclxudmFyIEZvcndhcmRSZW5kZXJQYXNzID0gZnVuY3Rpb24gKHJlbmRlckludGVyZmFjZSwgb3V0cHV0LCBvcHQpIHtcclxuICAgIFNjZW5lUmVuZGVyUGFzcy5jYWxsKHRoaXMsIHJlbmRlckludGVyZmFjZSwgb3V0cHV0LCBvcHQpO1xyXG4gICAgdGhpcy5zb3J0ZXIgPSBuZXcgT2JqZWN0U29ydGVyKCk7XHJcbiAgICB0aGlzLmxhc3RSZW5kZXJTdGF0cyA9IHt9O1xyXG59O1xyXG5cclxuWE1MM0QuY3JlYXRlQ2xhc3MoRm9yd2FyZFJlbmRlclBhc3MsIFNjZW5lUmVuZGVyUGFzcyk7XHJcblxyXG5YTUwzRC5leHRlbmQoRm9yd2FyZFJlbmRlclBhc3MucHJvdG90eXBlLCB7XHJcblxyXG5cclxuICAgIHJlbmRlcjogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAdHlwZSBtYXQ0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGNfd29ybGRUb1ZpZXdNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBjX3ZpZXdUb1dvcmxkTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgY19wcm9qZWN0aW9uTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgY19wcm9ncmFtU3lzdGVtVW5pZm9ybXMgPSBbXCJ2aWV3TWF0cml4XCIsIFwidmlld0ludmVyc2VNYXRyaXhcIiwgXCJwcm9qZWN0aW9uTWF0cml4XCIsIFwiY2FtZXJhUG9zaXRpb25cIiwgXCJjb29yZHNcIiwgXCJzc2FvTWFwXCIsIFwid2lkdGhcIl07XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc2NlbmUpIHtcclxuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5nbCwgY291bnQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0czogMCxcclxuICAgICAgICAgICAgICAgICAgICBwcmltaXRpdmVzOiAwXHJcbiAgICAgICAgICAgICAgICB9LCB0YXJnZXQgPSB0aGlzLm91dHB1dCwgc3lzdGVtVW5pZm9ybXMgPSBzY2VuZS5zeXN0ZW1Vbmlmb3Jtcywgd2lkdGggPSB0YXJnZXQuZ2V0V2lkdGgoKSwgaGVpZ2h0ID0gdGFyZ2V0LmdldEhlaWdodCgpLCBhc3BlY3QgPSB3aWR0aCAvIGhlaWdodDtcclxuXHJcbiAgICAgICAgICAgIHRhcmdldC5iaW5kKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0R0xTdGF0ZXMoKTtcclxuXHJcbiAgICAgICAgICAgIHNjZW5lLnVwZGF0ZVJlYWR5T2JqZWN0c0Zyb21BY3RpdmVWaWV3KGFzcGVjdCk7XHJcbiAgICAgICAgICAgIHNjZW5lLmdldEFjdGl2ZVZpZXcoKS5nZXRXb3JsZFRvVmlld01hdHJpeChjX3dvcmxkVG9WaWV3TWF0cml4KTtcclxuICAgICAgICAgICAgc2NlbmUuZ2V0QWN0aXZlVmlldygpLmdldFZpZXdUb1dvcmxkTWF0cml4KGNfdmlld1RvV29ybGRNYXRyaXgpO1xyXG4gICAgICAgICAgICBzY2VuZS5nZXRBY3RpdmVWaWV3KCkuZ2V0UHJvamVjdGlvbk1hdHJpeChjX3Byb2plY3Rpb25NYXRyaXgsIGFzcGVjdCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgc29ydGVkID0gdGhpcy5zb3J0ZXIuc29ydE9iamVjdHMoc2NlbmUucmVhZHksIGNfd29ybGRUb1ZpZXdNYXRyaXgpO1xyXG5cclxuICAgICAgICAgICAgc3lzdGVtVW5pZm9ybXNbXCJ2aWV3TWF0cml4XCJdID0gY193b3JsZFRvVmlld01hdHJpeDtcclxuICAgICAgICAgICAgc3lzdGVtVW5pZm9ybXNbXCJ2aWV3SW52ZXJzZU1hdHJpeFwiXSA9IGNfdmlld1RvV29ybGRNYXRyaXg7XHJcbiAgICAgICAgICAgIHN5c3RlbVVuaWZvcm1zW1wicHJvamVjdGlvbk1hdHJpeFwiXSA9IGNfcHJvamVjdGlvbk1hdHJpeDtcclxuICAgICAgICAgICAgc3lzdGVtVW5pZm9ybXNbXCJjYW1lcmFQb3NpdGlvblwiXSA9IHNjZW5lLmdldEFjdGl2ZVZpZXcoKS5nZXRXb3JsZFNwYWNlUG9zaXRpb24oKTtcclxuICAgICAgICAgICAgc3lzdGVtVW5pZm9ybXNbXCJjb29yZHNcIl0gPSBbdGFyZ2V0LndpZHRoLCB0YXJnZXQuaGVpZ2h0LCAxXTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0cy5zc2FvTWFwKVxyXG4gICAgICAgICAgICAgICAgc3lzdGVtVW5pZm9ybXNbXCJzc2FvTWFwXCJdID0gW3RoaXMuaW5wdXRzLnNzYW9NYXAuY29sb3JUYXJnZXQuaGFuZGxlXTtcclxuXHJcbiAgICAgICAgICAgIC8vUmVuZGVyIG9wYXF1ZSBvYmplY3RzXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gc29ydGVkLnpMYXllcnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciB6TGF5ZXIgPSBzb3J0ZWQuekxheWVyc1tpXTtcclxuICAgICAgICAgICAgICAgIGdsLmNsZWFyKGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvZ3JhbSBpbiBzb3J0ZWQub3BhcXVlW3pMYXllcl0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck9iamVjdHNUb0FjdGl2ZUJ1ZmZlcihzb3J0ZWQub3BhcXVlW3pMYXllcl1bcHJvZ3JhbV0sIHNjZW5lLCB0YXJnZXQsIHN5c3RlbVVuaWZvcm1zLCBjX3Byb2dyYW1TeXN0ZW1Vbmlmb3Jtcywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVudDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzOiBjb3VudFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNvcnRlZC50cmFuc3BhcmVudFt6TGF5ZXJdLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc29ydGVkLnRyYW5zcGFyZW50W3pMYXllcl0ubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdEFycmF5ID0gW3NvcnRlZC50cmFuc3BhcmVudFt6TGF5ZXJdW2tdXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJPYmplY3RzVG9BY3RpdmVCdWZmZXIob2JqZWN0QXJyYXksIHNjZW5lLCB0YXJnZXQsIHN5c3RlbVVuaWZvcm1zLCBjX3Byb2dyYW1TeXN0ZW1Vbmlmb3Jtcywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0czogY291bnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzY2VuZS5saWdodHMuY2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0YXJnZXQudW5iaW5kKCk7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdFJlbmRlclN0YXRzLmNvdW50ID0gY291bnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSgpKSxcclxuXHJcbiAgICBnZXRSZW5kZXJTdGF0czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RSZW5kZXJTdGF0cztcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRm9yd2FyZFJlbmRlclBhc3M7XHJcblxyXG4iLCJ2YXIgU2NlbmVSZW5kZXJQYXNzID0gcmVxdWlyZShcIi4vc2NlbmUtcGFzcy5qc1wiKTtcclxudmFyIE9iamVjdFNvcnRlciA9IHJlcXVpcmUoXCIuLi8uLi9yZW5kZXJlci90b29scy9vYmplY3Rzb3J0ZXIuanNcIik7XHJcbnZhciBtYXQ0ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS5tYXQ0O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7R0xSZW5kZXJJbnRlcmZhY2V9IHJlbmRlckludGVyZmFjZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gb3V0cHV0XHJcbiAqIEBwYXJhbSB7UmVuZGVyTGlnaHR9IGxpZ2h0XHJcbiAqIEBwYXJhbSB7Kn0gb3B0XHJcbiAqIEBleHRlbmRzIHtTY2VuZVJlbmRlclBhc3N9XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIExpZ2h0UGFzcyA9IGZ1bmN0aW9uIChyZW5kZXJJbnRlcmZhY2UsIG91dHB1dCwgbGlnaHQsIG9wdCkge1xyXG4gICAgU2NlbmVSZW5kZXJQYXNzLmNhbGwodGhpcywgcmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCk7XHJcbiAgICB0aGlzLmxpZ2h0ID0gbGlnaHQ7XHJcbiAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xyXG59O1xyXG5cclxuWE1MM0QuY3JlYXRlQ2xhc3MoTGlnaHRQYXNzLCBTY2VuZVJlbmRlclBhc3MsIHtcclxuXHJcbiAgICBpbml0OiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMuc29ydGVyID0gbmV3IE9iamVjdFNvcnRlcigpO1xyXG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IGNvbnRleHQucHJvZ3JhbUZhY3RvcnkuZ2V0UHJvZ3JhbUJ5TmFtZShcImxpZ2h0LWRlcHRoXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW5kZXJTY2VuZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIodGhpcy5saWdodC5zY2VuZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbmRlcjogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY192aWV3TWF0X3RtcCA9IG1hdDQuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIGNfcHJvak1hdF90bXAgPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBjX3Byb2dyYW1TeXN0ZW1Vbmlmb3JtcyA9IFtcInZpZXdNYXRyaXhcIiwgXCJwcm9qZWN0aW9uTWF0cml4XCJdO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNjZW5lKSB7XHJcbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmNvbnRleHQuZ2wsIHRhcmdldCA9IHRoaXMub3V0cHV0LCB3aWR0aCA9IHRhcmdldC5nZXRXaWR0aCgpLCBoZWlnaHQgPSB0YXJnZXQuZ2V0SGVpZ2h0KCksIGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0LCBmcnVzdHVtID0gdGhpcy5saWdodC5nZXRGcnVzdHVtKGFzcGVjdCksIHByb2dyYW0gPSB0aGlzLnByb2dyYW07XHJcblxyXG4gICAgICAgICAgICB0YXJnZXQuYmluZCgpO1xyXG4gICAgICAgICAgICBnbC5jbGVhcihnbC5ERVBUSF9CVUZGRVJfQklUIHwgZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjb3VudCA9IHtvYmplY3RzOiAwLCBwcmltaXRpdmVzOiAwfTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubGlnaHQubW9kZWwuZ2V0TGlnaHRWaWV3TWF0cml4KGNfdmlld01hdF90bXApO1xyXG4gICAgICAgICAgICBmcnVzdHVtLmdldFByb2plY3Rpb25NYXRyaXgoY19wcm9qTWF0X3RtcCwgYXNwZWN0KTtcclxuXHJcbiAgICAgICAgICAgIHNjZW5lLnVwZGF0ZVJlYWR5T2JqZWN0c0Zyb21NYXRyaWNlcyhjX3ZpZXdNYXRfdG1wLCBjX3Byb2pNYXRfdG1wKTtcclxuICAgICAgICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLnNvcnRlci5zb3J0T2JqZWN0cyhzY2VuZS5yZWFkeSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcGFyYW1ldGVycyA9IHt9O1xyXG4gICAgICAgICAgICBwYXJhbWV0ZXJzW1widmlld01hdHJpeFwiXSA9IGNfdmlld01hdF90bXA7XHJcbiAgICAgICAgICAgIHBhcmFtZXRlcnNbXCJwcm9qZWN0aW9uTWF0cml4XCJdID0gY19wcm9qTWF0X3RtcDtcclxuXHJcbiAgICAgICAgICAgIC8vUmVuZGVyIG9wYXF1ZSBvYmplY3RzXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gb2JqZWN0cy56TGF5ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgekxheWVyID0gb2JqZWN0cy56TGF5ZXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuREVQVEhfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcmcgaW4gb2JqZWN0cy5vcGFxdWVbekxheWVyXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyT2JqZWN0c1RvQWN0aXZlQnVmZmVyKG9iamVjdHMub3BhcXVlW3pMYXllcl1bcHJnXSwgc2NlbmUsIHRhcmdldCwgcGFyYW1ldGVycywgY19wcm9ncmFtU3lzdGVtVW5pZm9ybXMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0czogY291bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyYW06IHByb2dyYW1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRG8gbm90IHJlbmRlciB0cmFuc3BhcmVudCBvYmplY3RzIChjb25zaWRlcmVkIHRvIG5vdCB0aHJvdyBzaGFkb3dzXHJcbiAgICAgICAgICAgIHRhcmdldC51bmJpbmQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtjb3VudDogY291bnR9O1xyXG4gICAgICAgIH1cclxuICAgIH0oKSlcclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpZ2h0UGFzcztcclxuXHJcbiIsInZhciBCYXNlUmVuZGVyUGFzcyA9IHJlcXVpcmUoXCIuL2Jhc2UuanNcIik7XHJcbnZhciB2ZWMzID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS52ZWMzO1xyXG52YXIgbWF0NCA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikubWF0NDtcclxudmFyIG1hdDMgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLm1hdDM7XHJcblxyXG52YXIgUGlja05vcm1hbFJlbmRlclBhc3MgPSBmdW5jdGlvbiAocmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCkge1xyXG4gICAgQmFzZVJlbmRlclBhc3MuY2FsbCh0aGlzLCByZW5kZXJJbnRlcmZhY2UsIG91dHB1dCwgb3B0KTtcclxufTtcclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKFBpY2tOb3JtYWxSZW5kZXJQYXNzLCBCYXNlUmVuZGVyUGFzcywge1xyXG4gICAgcmVuZGVyOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjX21vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBjX3dvcmxkTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgY19ub3JtYWxNYXRyaXgzID0gbWF0My5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgY191bmlmb3JtQ29sbGVjdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgIGVudkJhc2U6IHt9LFxyXG4gICAgICAgICAgICAgICAgZW52T3ZlcnJpZGU6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBzeXNCYXNlOiB7fVxyXG4gICAgICAgICAgICB9LCBjX3N5c3RlbVVuaWZvcm1OYW1lcyA9IFtcIm1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXhcIiwgXCJtb2RlbFZpZXdNYXRyaXhOXCJdO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iamVjdCwgdmlld01hdHJpeCwgcHJvak1hdHJpeCkge1xyXG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlckludGVyZmFjZS5jb250ZXh0LmdsLCB0YXJnZXQgPSB0aGlzLm91dHB1dDtcclxuXHJcbiAgICAgICAgICAgIHRhcmdldC5iaW5kKCk7XHJcbiAgICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUIHwgZ2wuU1RFTkNJTF9CVUZGRVJfQklUKTtcclxuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkNVTExfRkFDRSk7XHJcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHZpZXdNYXRyaXggJiYgcHJvak1hdHJpeCkge1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0LnVwZGF0ZU1vZGVsVmlld01hdHJpeCh2aWV3TWF0cml4KTtcclxuICAgICAgICAgICAgICAgIG9iamVjdC51cGRhdGVNb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4KHByb2pNYXRyaXgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvYmplY3QuZ2V0TW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeChjX21vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgpO1xyXG5cclxuICAgICAgICAgICAgb2JqZWN0LmdldFdvcmxkTWF0cml4KGNfd29ybGRNYXRyaXgpO1xyXG4gICAgICAgICAgICBpZiAoIVhNTDNELm1hdGgubWF0My5ub3JtYWxGcm9tTWF0NChjX25vcm1hbE1hdHJpeDMsIGNfd29ybGRNYXRyaXgpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXQzLmlkZW50aXR5KGNfbm9ybWFsTWF0cml4Myk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBwcm9ncmFtID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5wcm9ncmFtRmFjdG9yeS5nZXRQaWNraW5nTm9ybWFsUHJvZ3JhbSgpO1xyXG4gICAgICAgICAgICBwcm9ncmFtLmJpbmQoKTtcclxuXHJcbiAgICAgICAgICAgIGNfdW5pZm9ybUNvbGxlY3Rpb24uc3lzQmFzZVtcIm1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXhcIl0gPSBjX21vZGVsVmlld1Byb2plY3Rpb25NYXRyaXg7XHJcbiAgICAgICAgICAgIGNfdW5pZm9ybUNvbGxlY3Rpb24uc3lzQmFzZVtcIm1vZGVsVmlld01hdHJpeE5cIl0gPSBjX25vcm1hbE1hdHJpeDM7XHJcblxyXG4gICAgICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm1WYXJpYWJsZXMobnVsbCwgY19zeXN0ZW1Vbmlmb3JtTmFtZXMsIGNfdW5pZm9ybUNvbGxlY3Rpb24pO1xyXG4gICAgICAgICAgICBvYmplY3QubWVzaC5kcmF3KHByb2dyYW0pO1xyXG5cclxuICAgICAgICAgICAgcHJvZ3JhbS51bmJpbmQoKTtcclxuICAgICAgICAgICAgdGFyZ2V0LnVuYmluZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0oKSksIC8qKlxyXG4gICAgICogUmVhZCBub3JtYWwgZnJvbSBwaWNraW5nIGJ1ZmZlclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdsWCBPcGVuR0wgQ29vcmRpbmF0ZSBvZiBjb2xvciBidWZmZXJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBnbFkgT3BlbkdMIENvb3JkaW5hdGUgb2YgY29sb3IgYnVmZmVyXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBWZWN0b3Igd2l0aCBub3JtYWwgZGF0YVxyXG4gICAgICovXHJcbiAgICByZWFkTm9ybWFsRnJvbVBpY2tpbmdCdWZmZXI6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNfcGlja1ZlY3RvciA9IHZlYzMuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIGNfb25lID0gdmVjMy5mcm9tVmFsdWVzKDEsIDEsIDEpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdsWCwgZ2xZKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5yZWFkUGl4ZWxEYXRhRnJvbUJ1ZmZlcihnbFgsIGdsWSwgdGhpcy5vdXRwdXQpO1xyXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNfcGlja1ZlY3RvclswXSA9IGRhdGFbMF0gLyAyNTQ7XHJcbiAgICAgICAgICAgIGNfcGlja1ZlY3RvclsxXSA9IGRhdGFbMV0gLyAyNTQ7XHJcbiAgICAgICAgICAgIGNfcGlja1ZlY3RvclsyXSA9IGRhdGFbMl0gLyAyNTQ7XHJcblxyXG4gICAgICAgICAgICB2ZWMzLnNjYWxlKGNfcGlja1ZlY3RvciwgY19waWNrVmVjdG9yLCAyKTtcclxuICAgICAgICAgICAgcmV0dXJuIHZlYzMuc3VidHJhY3QodmVjMy5jcmVhdGUoKSwgY19waWNrVmVjdG9yLCBjX29uZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSgpKVxyXG59KTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBpY2tOb3JtYWxSZW5kZXJQYXNzO1xyXG5cclxuIiwidmFyIEJhc2VSZW5kZXJQYXNzID0gcmVxdWlyZShcIi4vYmFzZS5qc1wiKTtcclxudmFyIG1hdDQgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLm1hdDQ7XHJcbnZhciBPYmplY3RTb3J0ZXIgPSByZXF1aXJlKFwiLi4vLi4vcmVuZGVyZXIvdG9vbHMvb2JqZWN0c29ydGVyLmpzXCIpO1xyXG5cclxudmFyIFBpY2tPYmplY3RSZW5kZXJQYXNzID0gZnVuY3Rpb24gKHJlbmRlckludGVyZmFjZSwgb3V0cHV0LCBvcHQpIHtcclxuICAgIEJhc2VSZW5kZXJQYXNzLmNhbGwodGhpcywgcmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCk7XHJcbiAgICB0aGlzLnNvcnRlciA9IG5ldyBPYmplY3RTb3J0ZXIoKTtcclxufTtcclxuWE1MM0QuY3JlYXRlQ2xhc3MoUGlja09iamVjdFJlbmRlclBhc3MsIEJhc2VSZW5kZXJQYXNzKTtcclxuXHJcblhNTDNELmV4dGVuZChQaWNrT2JqZWN0UmVuZGVyUGFzcy5wcm90b3R5cGUsIHtcclxuICAgIHJlbmRlcjogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY19tdnAgPSBtYXQ0LmNyZWF0ZSgpLCBjX3VuaWZvcm1Db2xsZWN0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgZW52QmFzZToge30sXHJcbiAgICAgICAgICAgICAgICBlbnZPdmVycmlkZTogbnVsbCxcclxuICAgICAgICAgICAgICAgIHN5c0Jhc2U6IHt9XHJcbiAgICAgICAgICAgIH0sIGNfc3lzdGVtVW5pZm9ybU5hbWVzID0gW1wiaWRcIiwgXCJtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4XCJdO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iamVjdHMsIHZpZXdNYXRyaXgsIHByb2pNYXRyaXgpIHtcclxuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5nbCwgdGFyZ2V0ID0gdGhpcy5vdXRwdXQ7XHJcbiAgICAgICAgICAgIHRhcmdldC5iaW5kKCk7XHJcbiAgICAgICAgICAgIHZhciBzb3J0ZWRPYmplY3RzID0gdGhpcy5zb3J0ZXIuc29ydE9iamVjdHMob2JqZWN0cywgdmlld01hdHJpeCk7XHJcblxyXG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XHJcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQ1VMTF9GQUNFKTtcclxuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwcm9ncmFtID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5wcm9ncmFtRmFjdG9yeS5nZXRQaWNraW5nT2JqZWN0SWRQcm9ncmFtKCk7XHJcbiAgICAgICAgICAgIHByb2dyYW0uYmluZCgpO1xyXG4gICAgICAgICAgICB2YXIgb2JqQ291bnQgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbiA9IHNvcnRlZE9iamVjdHMuekxheWVycy5sZW5ndGg7IGogPCBuOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB6TGF5ZXIgPSBzb3J0ZWRPYmplY3RzLnpMYXllcnNbal07XHJcbiAgICAgICAgICAgICAgICBnbC5jbGVhcihnbC5ERVBUSF9CVUZGRVJfQklUKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGluZCBpbiBzb3J0ZWRPYmplY3RzLm9wYXF1ZVt6TGF5ZXJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9ianMgPSBzb3J0ZWRPYmplY3RzLm9wYXF1ZVt6TGF5ZXJdW2luZF07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgb2Jqcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gb2Jqc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc2ggPSBvYmoubWVzaDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2JqLnZpc2libGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2aWV3TWF0cml4ICYmIHByb2pNYXRyaXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai51cGRhdGVNb2RlbFZpZXdNYXRyaXgodmlld01hdHJpeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmoudXBkYXRlTW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeChwcm9qTWF0cml4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmdldE1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgoY19tdnApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaklkID0gKytvYmpDb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnBpY2tJZCA9IG9iaklkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYzEgPSBvYmpJZCAmIDI1NTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqSWQgPSBvYmpJZCA+PiA4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYzIgPSBvYmpJZCAmIDI1NTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqSWQgPSBvYmpJZCA+PiA4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYzMgPSBvYmpJZCAmIDI1NTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNfdW5pZm9ybUNvbGxlY3Rpb24uc3lzQmFzZVtcImlkXCJdID0gW2MzIC8gMjU1LjAsIGMyIC8gMjU1LjAsIGMxIC8gMjU1LjBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjX3VuaWZvcm1Db2xsZWN0aW9uLnN5c0Jhc2VbXCJtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4XCJdID0gY19tdnA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm1WYXJpYWJsZXMobnVsbCwgY19zeXN0ZW1Vbmlmb3JtTmFtZXMsIGNfdW5pZm9ybUNvbGxlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoLmRyYXcocHJvZ3JhbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcm9ncmFtLnVuYmluZCgpO1xyXG4gICAgICAgICAgICB0YXJnZXQudW5iaW5kKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH0oKSksXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBwaXhlbHMgZnJvbSB0aGUgc2NyZWVuYnVmZmVyIHRvIGRldGVybWluZSBwaWNrZWQgb2JqZWN0IG9yIG5vcm1hbHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggU2NyZWVuIENvb3JkaW5hdGUgb2YgY29sb3IgYnVmZmVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBTY3JlZW4gQ29vcmRpbmF0ZSBvZiBjb2xvciBidWZmZXJcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9iamVjdHMgTGlzdCBvZiBvYmplY3RzIHRoYXQgd2VyZSByZW5kZXJlZCBpbiB0aGUgcHJldmlvdXMgcGlja2luZyBwYXNzXHJcbiAgICAgKiBAcmV0dXJucyB7UmVuZGVyT2JqZWN0fG51bGx9IFBpY2tlZCBPYmplY3RcclxuICAgICAqL1xyXG4gICAgZ2V0UmVuZGVyT2JqZWN0RnJvbVBpY2tpbmdCdWZmZXI6IGZ1bmN0aW9uICh4LCB5LCBvYmplY3RzKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnJlYWRQaXhlbERhdGFGcm9tQnVmZmVyKHgsIHksIHRoaXMub3V0cHV0KTtcclxuXHJcbiAgICAgICAgaWYgKCFkYXRhKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgdmFyIG9iaklkID0gZGF0YVswXSAqIDY1NTM2ICsgZGF0YVsxXSAqIDI1NiArIGRhdGFbMl07XHJcblxyXG4gICAgICAgIGlmIChvYmpJZCA+IDApIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdHNbaV0uaW5GcnVzdHVtICYmIG9iamVjdHNbaV0ucGlja0lkID09PSBvYmpJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG9iamVjdHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBpY2tPYmplY3RSZW5kZXJQYXNzO1xyXG5cclxuIiwidmFyIEJhc2VSZW5kZXJQYXNzID0gcmVxdWlyZShcIi4vYmFzZS5qc1wiKTtcclxudmFyIG1hdDQgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLm1hdDQ7XHJcbnZhciB2ZWMzID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS52ZWMzO1xyXG5cclxudmFyIFBpY2tQb3NpdGlvblJlbmRlclBhc3MgPSBmdW5jdGlvbiAocmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCkge1xyXG4gICAgQmFzZVJlbmRlclBhc3MuY2FsbCh0aGlzLCByZW5kZXJJbnRlcmZhY2UsIG91dHB1dCwgb3B0KTtcclxuICAgIHRoaXMub2JqZWN0Qm91bmRpbmdCb3ggPSBuZXcgWE1MM0QuQm94KCk7XHJcbn07XHJcblhNTDNELmNyZWF0ZUNsYXNzKFBpY2tQb3NpdGlvblJlbmRlclBhc3MsIEJhc2VSZW5kZXJQYXNzLCB7XHJcbiAgICByZW5kZXI6IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBjX21vZGVsTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgY19tb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ID0gbWF0NC5jcmVhdGUoKSwgY191bmlmb3JtQ29sbGVjdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgIGVudkJhc2U6IHt9LFxyXG4gICAgICAgICAgICAgICAgZW52T3ZlcnJpZGU6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBzeXNCYXNlOiB7fVxyXG4gICAgICAgICAgICB9LCBjX3N5c3RlbVVuaWZvcm1OYW1lcyA9IFtcImJib3hcIiwgXCJtb2RlbE1hdHJpeFwiLCBcIm1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXhcIl07XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCB2aWV3TWF0cml4LCBwcm9qTWF0cml4KSB7XHJcbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmNvbnRleHQuZ2wsIHRhcmdldCA9IHRoaXMub3V0cHV0O1xyXG5cclxuICAgICAgICAgICAgdGFyZ2V0LmJpbmQoKTtcclxuICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQgfCBnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XHJcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQ1VMTF9GQUNFKTtcclxuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodmlld01hdHJpeCAmJiBwcm9qTWF0cml4KSB7XHJcbiAgICAgICAgICAgICAgICBvYmoudXBkYXRlTW9kZWxWaWV3TWF0cml4KHZpZXdNYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgb2JqLnVwZGF0ZU1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgocHJvak1hdHJpeCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2JqLmdldFdvcmxkTWF0cml4KGNfbW9kZWxNYXRyaXgpO1xyXG5cclxuICAgICAgICAgICAgb2JqLmdldE9iamVjdFNwYWNlQm91bmRpbmdCb3godGhpcy5vYmplY3RCb3VuZGluZ0JveCk7XHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0Qm91bmRpbmdCb3gudHJhbnNmb3JtQXhpc0FsaWduZWQoY19tb2RlbE1hdHJpeCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcHJvZ3JhbSA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmNvbnRleHQucHJvZ3JhbUZhY3RvcnkuZ2V0UGlja2luZ1Bvc2l0aW9uUHJvZ3JhbSgpO1xyXG4gICAgICAgICAgICBwcm9ncmFtLmJpbmQoKTtcclxuICAgICAgICAgICAgb2JqLmdldE1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgoY19tb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4KTtcclxuXHJcbiAgICAgICAgICAgIGNfdW5pZm9ybUNvbGxlY3Rpb24uc3lzQmFzZVtcImJib3hcIl0gPSB0aGlzLm9iamVjdEJvdW5kaW5nQm94LmRhdGE7XHJcbiAgICAgICAgICAgIGNfdW5pZm9ybUNvbGxlY3Rpb24uc3lzQmFzZVtcIm1vZGVsTWF0cml4XCJdID0gY19tb2RlbE1hdHJpeDtcclxuICAgICAgICAgICAgY191bmlmb3JtQ29sbGVjdGlvbi5zeXNCYXNlW1wibW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeFwiXSA9IGNfbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeDtcclxuXHJcbiAgICAgICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybVZhcmlhYmxlcyhudWxsLCBjX3N5c3RlbVVuaWZvcm1OYW1lcywgY191bmlmb3JtQ29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgIG9iai5tZXNoLmRyYXcocHJvZ3JhbSk7XHJcblxyXG4gICAgICAgICAgICBwcm9ncmFtLnVuYmluZCgpO1xyXG4gICAgICAgICAgICB0YXJnZXQudW5iaW5kKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH0oKSksXHJcblxyXG4gICAgcmVhZFBvc2l0aW9uRnJvbVBpY2tpbmdCdWZmZXI6IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBjX3ZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnJlYWRQaXhlbERhdGFGcm9tQnVmZmVyKHgsIHksIHRoaXMub3V0cHV0KTtcclxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjX3ZlYzNbMF0gPSBkYXRhWzBdIC8gMjU1O1xyXG4gICAgICAgICAgICAgICAgY192ZWMzWzFdID0gZGF0YVsxXSAvIDI1NTtcclxuICAgICAgICAgICAgICAgIGNfdmVjM1syXSA9IGRhdGFbMl0gLyAyNTU7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSB0aGlzLm9iamVjdEJvdW5kaW5nQm94LnNpemUoKTtcclxuICAgICAgICAgICAgICAgIHZlYzMubXVsKGNfdmVjMywgY192ZWMzLCBzaXplLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlYzMuYWRkKHZlYzMuY3JlYXRlKCksIGNfdmVjMywgdGhpcy5vYmplY3RCb3VuZGluZ0JveC5taW4uZGF0YSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0oKSlcclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBpY2tQb3NpdGlvblJlbmRlclBhc3M7XHJcblxyXG4iLCJ2YXIgU2NlbmVSZW5kZXJQYXNzID0gcmVxdWlyZShcIi4vc2NlbmUtcGFzcy5qc1wiKTtcclxudmFyIE9iamVjdFNvcnRlciA9IHJlcXVpcmUoXCIuLi8uLi9yZW5kZXJlci90b29scy9vYmplY3Rzb3J0ZXIuanNcIik7XHJcbnZhciBtYXQ0ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS5tYXQ0O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7R0xSZW5kZXJJbnRlcmZhY2V9IHJlbmRlckludGVyZmFjZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gb3V0cHV0XHJcbiAqIEBwYXJhbSB7UmVuZGVyTGlnaHR9IGxpZ2h0XHJcbiAqIEBwYXJhbSB7Kn0gb3B0XHJcbiAqIEBleHRlbmRzIHtTY2VuZVJlbmRlclBhc3N9XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIFBvaW50TGlnaHRQYXNzID0gZnVuY3Rpb24gKHJlbmRlckludGVyZmFjZSwgb3V0cHV0LCBsaWdodCwgb3B0KSB7XHJcbiAgICBTY2VuZVJlbmRlclBhc3MuY2FsbCh0aGlzLCByZW5kZXJJbnRlcmZhY2UsIG91dHB1dCwgb3B0KTtcclxuICAgIHRoaXMubGlnaHQgPSBsaWdodDtcclxuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhQb2ludExpZ2h0UGFzcywgU2NlbmVSZW5kZXJQYXNzLCB7XHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLnNvcnRlciA9IG5ldyBPYmplY3RTb3J0ZXIoKTtcclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBjb250ZXh0LnByb2dyYW1GYWN0b3J5LmdldFByb2dyYW1CeU5hbWUoXCJsaWdodC1kZXB0aFwiKTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVuZGVyU2NlbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyKHRoaXMubGlnaHQuc2NlbmUpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW5kZXI6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNfdmlld01hdF90bXAgPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBjX3Byb2pNYXRfdG1wID0gbWF0NC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgY19wcm9ncmFtU3lzdGVtVW5pZm9ybXMgPSBbXCJ2aWV3TWF0cml4XCIsIFwicHJvamVjdGlvbk1hdHJpeFwiXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzY2VuZSkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5nbCwgdGFyZ2V0ID0gdGhpcy5vdXRwdXQsIHdpZHRoID0gdGFyZ2V0LmdldFdpZHRoKCksIGhlaWdodCA9IHRhcmdldC5nZXRIZWlnaHQoKSwgYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQsIGZydXN0dW0gPSB0aGlzLmxpZ2h0LmdldEZydXN0dW0oYXNwZWN0KSwgcHJvZ3JhbSA9IHRoaXMucHJvZ3JhbTtcclxuICAgICAgICAgICAgZm9yICh2YXIgc2lkZSA9IDA7IHNpZGUgPCB0YXJnZXQuZ2xTaWRlcy5sZW5ndGg7IHNpZGUrKykge1xyXG4gICAgICAgICAgICAgICAgLy9jYWxjdWxhdGUgcm90YXRpb25tYXRyaXggZm9yIHRoYXQgZmFjZVxyXG4gICAgICAgICAgICAgICAgdmFyIG1hdF9yb3QgPSBuZXcgWE1MM0QuTWF0NCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzaWRlID09IDApIHsgLy9sb29rIGludG8gK3ggb1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTExID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0xMiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMTMgPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0yMSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMjIgPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0yMyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMzEgPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0zMiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMzMgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2lkZSA9PSAxKSB7IC8vbG9vayBpbnRvIC14XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMTEgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTEyID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0xMyA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMjEgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTIyID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMjMgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTMxID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0zMiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMzMgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2lkZSA9PSAyKSB7IC8vbG9vayBpbnRvICt5XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMTEgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTEyID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0xMyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMjEgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTIyID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0yMyA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTMxID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0zMiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMzMgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2lkZSA9PSAzKSB7IC8vbG9vayBpbnRvIC15XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMTEgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTEyID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0xMyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMjEgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTIyID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0yMyA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMzEgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTMyID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMzMgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2lkZSA9PSA0KSB7IC8vbG9vayBpbnRvICt6XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMTEgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTEyID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0xMyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMjEgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTIyID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMjMgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTMxID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0zMiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMzMgPSAtMTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNpZGUgPT0gNSkgeyAvL2xvb2sgaW50byAtelxyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTExID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMTIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTEzID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0yMSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMjIgPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0yMyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMzEgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTMyID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0zMiA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmJpbmQoc2lkZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuREVQVEhfQlVGRkVSX0JJVCB8IGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IHtvYmplY3RzOiAwLCBwcmltaXRpdmVzOiAwfTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpZ2h0Lm1vZGVsLmdldExpZ2h0Vmlld01hdHJpeChjX3ZpZXdNYXRfdG1wKTtcclxuICAgICAgICAgICAgICAgIC8vcm90YXRlIGZvciB0aGUgYXByb3ByaWF0ZSBzaWRlIG9mIHRoZSBjdWJlbWFwXHJcbiAgICAgICAgICAgICAgICBYTUwzRC5tYXRoLm1hdDQubXVsKGNfdmlld01hdF90bXAsIG1hdF9yb3QuZGF0YSwgY192aWV3TWF0X3RtcCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZnJ1c3R1bS5nZXRQcm9qZWN0aW9uTWF0cml4KGNfcHJvak1hdF90bXAsIGFzcGVjdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgc2NlbmUudXBkYXRlUmVhZHlPYmplY3RzRnJvbU1hdHJpY2VzKGNfdmlld01hdF90bXAsIGNfcHJvak1hdF90bXApO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLnNvcnRlci5zb3J0T2JqZWN0cyhzY2VuZS5yZWFkeSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSB7fTtcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNbXCJ2aWV3TWF0cml4XCJdID0gY192aWV3TWF0X3RtcDtcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNbXCJwcm9qZWN0aW9uTWF0cml4XCJdID0gY19wcm9qTWF0X3RtcDtcclxuXHJcbiAgICAgICAgICAgICAgICAvL1JlbmRlciBvcGFxdWUgb2JqZWN0c1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBvYmplY3RzLnpMYXllcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgekxheWVyID0gb2JqZWN0cy56TGF5ZXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLmNsZWFyKGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHByZyBpbiBvYmplY3RzLm9wYXF1ZVt6TGF5ZXJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyT2JqZWN0c1RvQWN0aXZlQnVmZmVyKG9iamVjdHMub3BhcXVlW3pMYXllcl1bcHJnXSwgc2NlbmUsIHRhcmdldCwgcGFyYW1ldGVycywgY19wcm9ncmFtU3lzdGVtVW5pZm9ybXMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzOiBjb3VudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyYW06IHByb2dyYW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCByZW5kZXIgdHJhbnNwYXJlbnQgb2JqZWN0cyAoY29uc2lkZXJlZCB0byBub3QgdGhyb3cgc2hhZG93c1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnVuYmluZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7Y291bnQ6IGNvdW50fTtcclxuICAgICAgICB9XHJcbiAgICB9KCkpXHJcbn0pO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9pbnRMaWdodFBhc3M7XHJcblxyXG4iLCJ2YXIgQmFzZVJlbmRlclBhc3MgPSByZXF1aXJlKFwiLi9iYXNlLmpzXCIpO1xyXG52YXIgT3B0aW9ucyA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9vcHRpb25zLmpzXCIpO1xyXG52YXIgbWF0NCA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikubWF0NDtcclxudmFyIG1hdDMgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLm1hdDM7XHJcblxyXG52YXIgT1BUSU9OX0ZBQ0VDVUxMSU5HID0gXCJyZW5kZXJlci1mYWNlY3VsbGluZ1wiO1xyXG52YXIgT1BUSU9OX0ZST05URkFDRSA9IFwicmVuZGVyZXItZnJvbnRmYWNlXCI7XHJcblxyXG5PcHRpb25zLnJlZ2lzdGVyKE9QVElPTl9GQUNFQ1VMTElORywgXCJub25lXCIpO1xyXG5PcHRpb25zLnJlZ2lzdGVyKE9QVElPTl9GUk9OVEZBQ0UsIFwiY2N3XCIpO1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIFNjZW5lUmVuZGVyUGFzcyA9IGZ1bmN0aW9uIChyZW5kZXJJbnRlcmZhY2UsIG91dHB1dCwgb3B0KSB7XHJcbiAgICBCYXNlUmVuZGVyUGFzcy5jYWxsKHRoaXMsIHJlbmRlckludGVyZmFjZSwgb3V0cHV0LCBvcHQpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2V0RmFjZUN1bGxpbmcgPSBnZXRHbG9iYWxGYWNlQ3VsbGluZ1NldHRlcihPcHRpb25zLmdldFZhbHVlKE9QVElPTl9GQUNFQ1VMTElORykpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2V0RnJvbnRGYWNlID0gZ2V0R2xvYmFsRnJvbnRGYWNlU2V0dGVyKE9wdGlvbnMuZ2V0VmFsdWUoT1BUSU9OX0ZST05URkFDRSkpO1xyXG5cclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIE9wdGlvbnMuYWRkT2JzZXJ2ZXIoT1BUSU9OX0ZBQ0VDVUxMSU5HLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHRoYXQuc2V0RmFjZUN1bGxpbmcgPSBnZXRHbG9iYWxGYWNlQ3VsbGluZ1NldHRlcih2YWx1ZSk7XHJcbiAgICB9KTtcclxuICAgIE9wdGlvbnMuYWRkT2JzZXJ2ZXIoT1BUSU9OX0ZST05URkFDRSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICB0aGF0LnNldEZyb250RmFjZSA9IGdldEdsb2JhbEZyb250RmFjZVNldHRlcih2YWx1ZSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKFNjZW5lUmVuZGVyUGFzcywgQmFzZVJlbmRlclBhc3MsIHtcclxuICAgIHNldEdMU3RhdGVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5nbDtcclxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCB8IGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgdGhpcy5zZXRGYWNlQ3VsbGluZyhnbCk7XHJcbiAgICAgICAgdGhpcy5zZXRGcm9udEZhY2UoZ2wpO1xyXG4gICAgICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcclxuICAgIH0sIC8qKlxyXG4gICAgICogQHBhcmFtIEFycmF5XHJcbiAgICAgKi9cclxuICAgIHJlbmRlck9iamVjdHNUb0FjdGl2ZUJ1ZmZlcjogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdG1wTW9kZWxNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciB0bXBNb2RlbE1hdHJpeE4gPSBtYXQzLmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciB0bXBNb2RlbFZpZXcgPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciB0bXBNb2RlbFZpZXdQcm9qZWN0aW9uID0gbWF0NC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgdG1wTW9kZWxWaWV3TiA9IG1hdDMuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIGNfb2JqZWN0U3lzdGVtVW5pZm9ybXMgPSBbXCJtb2RlbE1hdHJpeFwiLCBcIm1vZGVsTWF0cml4TlwiLCBcIm1vZGVsVmlld01hdHJpeFwiLCBcIm1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXhcIiwgXCJtb2RlbFZpZXdNYXRyaXhOXCJdO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iamVjdEFycmF5LCBzY2VuZSwgdGFyZ2V0LCBzeXN0ZW1Vbmlmb3Jtcywgc2NlbmVQYXJhbWV0ZXJGaWx0ZXIsIG9wdCkge1xyXG4gICAgICAgICAgICB2YXIgb2JqQ291bnQgPSAwO1xyXG4gICAgICAgICAgICB2YXIgcHJpbWl0aXZlQ291bnQgPSAwO1xyXG4gICAgICAgICAgICB2YXIgc3RhdHMgPSBvcHQuc3RhdHMgfHwge307XHJcbiAgICAgICAgICAgIHZhciB0cmFuc3BhcmVudCA9IG9wdC50cmFuc3BhcmVudCA9PT0gdHJ1ZSB8fCBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5nbDtcclxuICAgICAgICAgICAgdmFyIHByb2dyYW0gPSBvcHQucHJvZ3JhbSB8fCBvYmplY3RBcnJheVswXS5nZXRQcm9ncmFtKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAob2JqZWN0QXJyYXkubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0cztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRyYW5zcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBndWFyYW50ZWUgdGhhdCB0aGUgUmVuZGVyT2JqZWN0IGhhcyBhIHZhbGlkIHNoYWRlclxyXG4gICAgICAgICAgICBwcm9ncmFtLmJpbmQoKTtcclxuXHJcbiAgICAgICAgICAgIC8vU2V0IGdsb2JhbCBkYXRhIHRoYXQgaXMgc2hhcmVkIGJldHdlZW4gYWxsIG9iamVjdHMgdXNpbmcgdGhpcyBzaGFkZXJcclxuICAgICAgICAgICAgcHJvZ3JhbS5zZXRTeXN0ZW1Vbmlmb3JtVmFyaWFibGVzKHNjZW5lUGFyYW1ldGVyRmlsdGVyLCBzeXN0ZW1Vbmlmb3Jtcyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcHJldk92ZXJyaWRlID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gb2JqZWN0QXJyYXkubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gb2JqZWN0QXJyYXlbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9iai52aXNpYmxlKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBtZXNoID0gb2JqLm1lc2g7XHJcbiAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5hc3NlcnQobWVzaCwgXCJXZSBuZWVkIGEgbWVzaCBhdCB0aGlzIHBvaW50LlwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICBvYmouZ2V0V29ybGRNYXRyaXgodG1wTW9kZWxNYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgc3lzdGVtVW5pZm9ybXNbXCJtb2RlbE1hdHJpeFwiXSA9IHRtcE1vZGVsTWF0cml4O1xyXG5cclxuICAgICAgICAgICAgICAgIG9iai5nZXRNb2RlbE1hdHJpeE4odG1wTW9kZWxNYXRyaXhOKTtcclxuICAgICAgICAgICAgICAgIHN5c3RlbVVuaWZvcm1zW1wibW9kZWxNYXRyaXhOXCJdID0gdG1wTW9kZWxNYXRyaXhOO1xyXG5cclxuICAgICAgICAgICAgICAgIG9iai5nZXRNb2RlbFZpZXdNYXRyaXgodG1wTW9kZWxWaWV3KTtcclxuICAgICAgICAgICAgICAgIHN5c3RlbVVuaWZvcm1zW1wibW9kZWxWaWV3TWF0cml4XCJdID0gdG1wTW9kZWxWaWV3O1xyXG5cclxuICAgICAgICAgICAgICAgIG9iai5nZXRNb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4KHRtcE1vZGVsVmlld1Byb2plY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgc3lzdGVtVW5pZm9ybXNbXCJtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4XCJdID0gdG1wTW9kZWxWaWV3UHJvamVjdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICBvYmouZ2V0TW9kZWxWaWV3TWF0cml4Tih0bXBNb2RlbFZpZXdOKTtcclxuICAgICAgICAgICAgICAgIHN5c3RlbVVuaWZvcm1zW1wibW9kZWxWaWV3TWF0cml4TlwiXSA9IHRtcE1vZGVsVmlld047XHJcblxyXG4gICAgICAgICAgICAgICAgcHJvZ3JhbS5zZXRTeXN0ZW1Vbmlmb3JtVmFyaWFibGVzKGNfb2JqZWN0U3lzdGVtVW5pZm9ybXMsIHN5c3RlbVVuaWZvcm1zKTtcclxuXHJcbiAgICAgICAgICAgICAgICBwcm9ncmFtLmNoYW5nZVVuaWZvcm1WYXJpYWJsZU92ZXJyaWRlKHByZXZPdmVycmlkZSwgbWVzaC51bmlmb3JtT3ZlcnJpZGUpO1xyXG4gICAgICAgICAgICAgICAgcHJldk92ZXJyaWRlID0gbWVzaC51bmlmb3JtT3ZlcnJpZGU7XHJcblxyXG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlQ291bnQgKz0gbWVzaC5kcmF3KHByb2dyYW0pO1xyXG4gICAgICAgICAgICAgICAgb2JqQ291bnQrKztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRyYW5zcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHJvZ3JhbS5jaGFuZ2VVbmlmb3JtVmFyaWFibGVPdmVycmlkZShwcmV2T3ZlcnJpZGUsIG51bGwpO1xyXG5cclxuICAgICAgICAgICAgcHJvZ3JhbS51bmJpbmQoKTtcclxuICAgICAgICAgICAgc3RhdHMub2JqZWN0cyArPSBvYmpDb3VudDtcclxuICAgICAgICAgICAgc3RhdHMucHJpbWl0aXZlcyArPSBwcmltaXRpdmVDb3VudDtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRzO1xyXG4gICAgICAgIH1cclxuICAgIH0oKSlcclxuXHJcblxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIGdldEdsb2JhbEZyb250RmFjZVNldHRlcihtb2RlKSB7XHJcbiAgICBpZiAobW9kZS50b0xvd2VyQ2FzZSgpID09IFwiY3dcIikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ2wpIHtcclxuICAgICAgICAgICAgZ2wuZnJvbnRGYWNlKGdsLkNXKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChnbCkge1xyXG4gICAgICAgIGdsLmZyb250RmFjZShnbC5DQ1cpO1xyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0R2xvYmFsRmFjZUN1bGxpbmdTZXR0ZXIobW9kZSkge1xyXG4gICAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXHJcbiAgICBzd2l0Y2ggKG1vZGUudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgIGNhc2UgXCJiYWNrXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ2wpIHtcclxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZShnbC5DVUxMX0ZBQ0UpO1xyXG4gICAgICAgICAgICAgICAgZ2wuY3VsbEZhY2UoZ2wuQkFDSyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJmcm9udFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdsKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKTtcclxuICAgICAgICAgICAgICAgIGdsLmN1bGxGYWNlKGdsLkZST05UKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImJvdGhcIjpcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChnbCkge1xyXG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkNVTExfRkFDRSk7XHJcbiAgICAgICAgICAgICAgICBnbC5jdWxsRmFjZShnbC5GUk9OVF9BTkRfQkFDSyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJub25lXCI6XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChnbCkge1xyXG4gICAgICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNjZW5lUmVuZGVyUGFzcztcclxuIiwidmFyIEJhc2VSZW5kZXJQYXNzID0gcmVxdWlyZShcIi4vYmFzZS5qc1wiKTtcclxudmFyIFZlcnRleEF0dHJpYnV0ZVBhc3MgPSByZXF1aXJlKFwiLi92ZXJ0ZXhhdHRyaWJ1dGUtcGFzcy5qc1wiKTtcclxudmFyIEdMUmVuZGVyVGFyZ2V0ID0gcmVxdWlyZShcIi4uL2Jhc2UvcmVuZGVydGFyZ2V0LmpzXCIpLkdMUmVuZGVyVGFyZ2V0O1xyXG52YXIgRnVsbHNjcmVlblF1YWQgPSByZXF1aXJlKFwiLi4vYmFzZS9mdWxsc2NyZWVucXVhZC5qc1wiKTtcclxudmFyIE9wdGlvbnMgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvb3B0aW9ucy5qc1wiKTtcclxuXHJcbnZhciBiYXNlNjRSYW5kb21Ob3JtYWxzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUlBQUFBQ0FDQUlBQUFCTVhQYWNBQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBS1QybERRMUJRYUc5MGIzTm9iM0FnU1VORElIQnliMlpwYkdVQUFIamFuVk5uVkZQcEZqMzMzdlJDUzRpQWxFdHZVaFVJSUZKQ2k0QVVrU1lxSVFrUVNvZ2hvZGtWVWNFUlJVVUVHOGlnaUFPT2pvQ01GVkVzRElvSzJBZmtJYUtPZzZPSWlzcjc0WHVqYTlhODkrYk4vclhYUHVlczg1Mnp6d2ZBQ0F5V1NETlJOWUFNcVVJZUVlQ0R4OFRHNGVRdVFJRUtKSEFBRUFpelpDRnovU01CQVBoK1BEd3JJc0FIdmdBQmVOTUxDQURBVFp2QU1CeUgvdy9xUXBsY0FZQ0VBY0Iwa1RoTENJQVVBRUI2amtLbUFFQkdBWUNkbUNaVEFLQUVBR0RMWTJMakFGQXRBR0FuZitiVEFJQ2QrSmw3QVFCYmxDRVZBYUNSQUNBVFpZaEVBR2c3QUt6UFZvcEZBRmd3QUJSbVM4UTVBTmd0QURCSlYyWklBTEMzQU1ET0VBdXlBQWdNQURCUmlJVXBBQVI3QUdESUl5TjRBSVNaQUJSRzhsYzg4U3V1RU9jcUFBQjRtYkk4dVNRNVJZRmJDQzF4QjFkWExoNG96a2tYS3hRMllRSmhta0F1d25tWkdUS0JOQS9nODh3QUFLQ1JGUkhnZy9QOWVNNE9yczdPTm82MkRsOHQ2cjhHL3lKaVl1UCs1YytyY0VBQUFPRjBmdEgrTEMrekdvQTdCb0J0L3FJbDdnUm9YZ3VnZGZlTFpySVBRTFVBb09uYVYvTncrSDQ4UEVXaGtMbloyZVhrNU5oS3hFSmJZY3BYZmY1bndsL0FWLzFzK1g0OC9QZjE0TDdpSklFeVhZRkhCUGpnd3N6MFRLVWN6NUlKaEdMYzVvOUgvTGNMLy93ZDB5TEVTV0s1V0NvVTQxRVNjWTVFbW96ek1xVWlpVUtTS2NVbDB2OWs0dDhzK3dNKzN6VUFzR28rQVh1UkxhaGRZd1AyU3ljUVdIVEE0dmNBQVBLN2I4SFVLQWdEZ0dpRDRjOTMvKzgvL1VlZ0pRQ0Faa21TY1FBQVhrUWtMbFRLc3ovSENBQUFSS0NCS3JCQkcvVEJHQ3pBQmh6QkJkekJDL3hnTm9SQ0pNVENRaEJDQ21TQUhISmdLYXlDUWlpR3piQWRLbUF2MUVBZE5NQlJhSWFUY0E0dXdsVzREajF3RC9waENKN0JLTHlCQ1FSQnlBZ1RZU0hhaUFGaWlsZ2pqZ2dYbVlYNEljRklCQktMSkNESmlCUlJJa3VSTlVneFVvcFVJRlZJSGZJOWNnSTVoMXhHdXBFN3lBQXlndnlHdkVjeGxJR3lVVDNVRExWRHVhZzNHb1JHb2d2UVpIUXhtbzhXb0p2UWNyUWFQWXcyb2VmUXEyZ1AybzgrUThjd3dPZ1lCelBFYkRBdXhzTkNzVGdzQ1pOank3RWlyQXlyeGhxd1Zxd0R1NG4xWTgreGR3UVNnVVhBQ1RZRWQwSWdZUjVCU0ZoTVdFN1lTS2dnSENRMEVkb0pOd2tEaEZIQ0p5S1RxRXUwSnJvUitjUVlZakl4aDFoSUxDUFdFbzhUTHhCN2lFUEVOeVFTaVVNeUo3bVFBa214cEZUU0V0SkcwbTVTSStrc3FaczBTQm9qazhuYVpHdXlCem1VTENBcnlJWGtuZVRENURQa0crUWg4bHNLbldKQWNhVDRVK0lvVXNwcVNobmxFT1UwNVFabG1ESkJWYU9hVXQyb29WUVJOWTlhUXEyaHRsS3ZVWWVvRXpSMW1qbk5neFpKUzZXdG9wWFRHbWdYYVBkcHIraDB1aEhkbFI1T2w5Qlgwc3ZwUitpWDZBUDBkd3dOaGhXRHg0aG5LQm1iR0FjWVp4bDNHSytZVEtZWjA0c1p4MVF3TnpIcm1PZVpENWx2VlZncXRpcDhGWkhLQ3BWS2xTYVZHeW92VkttcXBxcmVxZ3RWODFYTFZJK3BYbE45cmtaVk0xUGpxUW5VbHF0VnFwMVE2MU1iVTJlcE82aUhxbWVvYjFRL3BINVovWWtHV2NOTXcwOURwRkdnc1YvanZNWWdDMk1aczNnc0lXc05xNFoxZ1RYRUpySE4yWHgyS3J1WS9SMjdpejJxcWFFNVF6TktNMWV6VXZPVVpqOEg0NWh4K0p4MFRnbm5LS2VYODM2SzNoVHZLZUlwRzZZMFRMa3haVnhycXBhWGxsaXJTS3RScTBmcnZUYXU3YWVkcHIxRnUxbjdnUTVCeDBvblhDZEhaNC9PQlozblU5bFQzYWNLcHhaTlBUcjFyaTZxYTZVYm9idEVkNzl1cCs2WW5yNWVnSjVNYjZmZWViM24raHg5TC8xVS9XMzZwL1ZIREZnR3N3d2tCdHNNemhnOHhUVnhiendkTDhmYjhWRkRYY05BUTZWaGxXR1g0WVNSdWRFOG85VkdqVVlQakduR1hPTWs0MjNHYmNhakpnWW1JU1pMVGVwTjdwcFNUYm1tS2FZN1REdE14ODNNemFMTjFwazFtejB4MXpMbm0rZWIxNXZmdDJCYWVGb3N0cWkydUdWSnN1UmFwbG51dHJ4dWhWbzVXYVZZVlZwZHMwYXRuYTBsMXJ1dHU2Y1JwN2xPazA2cm50Wm53N0R4dHNtMnFiY1pzT1hZQnR1dXRtMjJmV0ZuWWhkbnQ4V3V3KzZUdlpOOXVuMk4vVDBIRFlmWkRxc2RXaDErYzdSeUZEcFdPdDZhenB6dVAzM0Y5SmJwTDJkWXp4RFAyRFBqdGhQTEtjUnBuVk9iMDBkbkYyZTVjNFB6aUl1SlM0TExMcGMrTHBzYnh0M0l2ZVJLZFBWeFhlRjYwdldkbTdPYnd1Mm8yNi91TnU1cDdvZmNuOHcwbnltZVdUTnowTVBJUStCUjVkRS9DNStWTUd2ZnJINVBRMCtCWjdYbkl5OWpMNUZYcmRld3Q2VjNxdmRoN3hjKzlqNXluK00rNHp3MzNqTGVXVi9NTjhDM3lMZkxUOE52bmwrRjMwTi9JLzlrLzNyLzBRQ25nQ1VCWndPSmdVR0JXd0w3K0hwOEliK09QenJiWmZheTJlMUJqS0M1UVJWQmo0S3RndVhCclNGb3lPeVFyU0gzNTVqT2tjNXBEb1ZRZnVqVzBBZGg1bUdMdzM0TUo0V0hoVmVHUDQ1d2lGZ2EwVEdYTlhmUjNFTnozMFQ2UkpaRTNwdG5NVTg1cnkxS05TbytxaTVxUE5vM3VqUzZQOFl1WmxuTTFWaWRXRWxzU3h3NUxpcXVObTVzdnQvODdmT0g0cDNpQytON0Y1Z3Z5RjF3ZWFIT3d2U0ZweGFwTGhJc09wWkFUSWhPT0pUd1FSQXFxQmFNSmZJVGR5V09Dbm5DSGNKbklpL1JOdEdJMkVOY0toNU84a2dxVFhxUzdKRzhOWGtreFRPbExPVzVoQ2Vwa0x4TURVemRtenFlRnBwMklHMHlQVHE5TVlPU2taQnhRcW9oVFpPMlorcG41bVoyeTZ4bGhiTCt4VzZMdHk4ZWxRZkphN09RckFWWkxRcTJRcWJvVkZvbzF5b0hzbWRsVjJhL3pZbktPWmFybml2TjdjeXp5dHVRTjV6dm4vL3RFc0lTNFpLMnBZWkxWeTBkV09hOXJHbzVzanh4ZWRzSzR4VUZLNFpXQnF3OHVJcTJLbTNWVDZ2dFY1ZXVmcjBtZWsxcmdWN0J5b0xCdFFGcjZ3dFZDdVdGZmV2YzErMWRUMWd2V2QrMVlmcUduUnMrRlltS3JoVGJGNWNWZjlnbzNIamxHNGR2eXIrWjNKUzBxYXZFdVdUUFp0Sm02ZWJlTFo1YkRwYXFsK2FYRG00TjJkcTBEZDlXdE8zMTlrWGJMNWZOS051N2c3WkR1YU8vUExpOFphZkp6czA3UDFTa1ZQUlUrbFEyN3RMZHRXSFgrRzdSN2h0N3ZQWTA3TlhiVzd6My9UN0p2dHRWQVZWTjFXYlZaZnRKKzdQM1A2NkpxdW40bHZ0dFhhMU9iWEh0eHdQU0EvMEhJdzYyMTduVTFSM1NQVlJTajlZcjYwY094eCsrL3AzdmR5ME5OZzFWalp6RzRpTndSSG5rNmZjSjMvY2VEVHJhZG94N3JPRUgweDkySFdjZEwycENtdkthUnB0VG12dGJZbHU2VDh3KzBkYnEzbnI4UjlzZkQ1dzBQRmw1U3ZOVXlXbmE2WUxUazJmeXo0eWRsWjE5Zmk3NTNHRGJvclo3NTJQTzMyb1BiKys2RUhUaDBrWC9pK2M3dkR2T1hQSzRkUEt5MitVVFY3aFhtcTg2WDIzcWRPbzgvcFBUVDhlN25MdWFycmxjYTdudWVyMjFlMmIzNlJ1ZU44N2Q5TDE1OFJiLzF0V2VPVDNkdmZONmIvZkY5L1hmRnQxK2NpZjl6c3U3MlhjbjdxMjhUN3hmOUVEdFFkbEQzWWZWUDF2KzNOanYzSDlxd0hlZzg5SGNSL2NHaFlQUC9wSDFqdzlEQlkrWmo4dUdEWWJybmpnK09UbmlQM0w5NmZ5blE4OWt6eWFlRi82aS9zdXVGeFl2ZnZqVjY5Zk8wWmpSb1pmeWw1Ty9iWHlsL2VyQTZ4bXYyOGJDeGg2K3lYZ3pNVjcwVnZ2dHdYZmNkeDN2bzk4UFQrUjhJSDhvLzJqNXNmVlQwS2Y3a3htVGsvOEVBNWp6L0dNekxkc0FBQUFnWTBoU1RRQUFlaVVBQUlDREFBRDUvd0FBZ09rQUFIVXdBQURxWUFBQU9wZ0FBQmR2a2wvRlJnQUFuUnhKUkVGVWVOb0U0WGVNcG5tQ0dPYjkwcHZEbDNOOWxhdTZxcnM2VDNkUDN0bWQzYjNiUzd5ampxSVlaSkt3TE1LV0xjdUNTZGl3RE1nMkxFQTJEUU1HQkZpd3FUOHMrY1I0UHBHMzVPYVoyY25UdWF0RDVmamwvTDA1L0lLZkIvN0QvelgvQWZaY1UvcC9McnRYczFxaHIxMXc5dmY3MDcxYzdyOEtKbmU5OHQ4T1JsK3lrdmR1ck5ySmw5TTBlMmgvMk9DTjVmN1B1S1h0WnIxakhqckpYNzlLRDVqNTdhcGY3T3VuTVBnd05NZ0lXQkxuQ0xDNjJGT0ZtT0xsQ0g1N0h0WHFhbGFIc0pta2o2UjNpLzQvaTlXZHEzVDFXUHczYy80L3JmTXhWNTR0VVFaQTEzTGpudnAzaitTMnEremVUZTRlU3Y5ZE10L2NrLy80Sit5NGIvdkxhZU01L0l1RjlHT29yTlFubjlVRm9yZ213RGV2amRZcjd4OGVwYlNvLzZOU2N1T2VkY3ZCbnhySjMzSG9FS3EvTWJnK1ZNNXg4TGVwdEtFUFA4ZlZwNFVvVTBpQUhSNWZTaXR1dGpFbmhYb29RaHlrV0RnNG40a2pSeHJOeUdzL2VaN3QvTlhac2g2SlJaeCtaMHNyRUV3cDNNdkUvK0V3L01ldXBoSDBIMVltNTFlVS8xc3Iya0dGeFVQeXdvai9RVzNXaVRQLzlVVnk1V2xzbUtwYjF3d2RJd1FjbjkyUkJZUWdWMktrUW9tNkp2b2xnRUNhVTVFYmdRMlpXU2ZTa0JqaUF0NGJGY3lYZzhjTDlwdGJyR1FucGFHU3B4SVZRdW5pcmxSbUdLeFZvOU9lbXBtVFBVOGRhL0Rxd0FpZk1TYm9jVU5jVjBHZEJkL0U1a3luaXd5bUNqaE5BYjROTFNpc0M1Q09KRHlrbDJWdHBzVkU1MjRUVlJmUlFPZlZreGdDOHRMMXQvSllDVXluU2xNRjZneVpIcjNXMGNIQStmcXJmTFFOeXZtNFZBTExBN003Rm90ZC9UemhWU1JaQlIvcXZIeE5UNjZBaVlVemlKZjZTbWt2S0xkRlY4T2pBdW0vN2E1bHBKS0d4M084WkFLM0VpTE84cTU2T1pYelozTFRsUzluekxHVTIwbENMYkJIUk5PSWdoenJiTkZHTEEzT3M1WGQyS0hneFlJTU1VaFcwL0pqZkpwREI2WmRYZWRCQ0NaWWRTUm9WM0V1QVdvRk5ydVN3elF3WVdWRG15d1MzVlJybzhRYnAyMkY0NllDRktTbXZKdVJRUTdpUDB6KzB6ZlVQTlJSWmFxdi9CeXBMOVBSU0NUWFpGMFJkN3Z1R2RCZkdTSzVKc2czMnRXdi9mbHI1SGdNUnZKaEMrb0crVUUwU1ZOOWlIRFlvYTJNME9mWTJJQlRHVkZiYkd1aXJJYUhFL1Vzb2JVelVzNnlhQTlJWE9ydkoyNFJiL1hTeW9Md3ZnbVBSMG4wUWw2THNCRW93OThBb0NtdFBtRUhzUEZURko3eGJFVUdtamhxdytheUFEZWcreUZKQjdKR1VOeFJtb1U0MzRWZktDeVZkRG9oeGJiTUxqV2lrTHN4UmhoOG9uQ1Fvc1pBcnZmOWhlNzhlRVMva3ROUk5ka3FLbGxYeXZiZ3dxbS9kMVRvUEJlRjcxQjdOOG1GeWowbmVCVkI5RTE4b3hXd3p5UDNpNGgrSzdvWCt0a0NzekEyWS9XK20zaGMraUx2cjA0VlVZQU94VTJLVUFoQUcvVVE5NkdXSUt5bDZzS0FoREdzY0NCNlhHR3NkVVdqVndHNXlnWkZxWElIT1RVaTI2aHNRR0NDTkVIcFBpYWpxaTdlK09wVXJVMFR0UzYzQm1KaFhYb3pnYlUxOWxhbDErVHJ2enFmU09mNGU1bmk0bGJ5MzhkeUFuamxCdTJIME1NczJGZnBxdkN2aFpzSjFvNlV1U2FDZXJ5aVMrY3RkbjRrcWgvQzZnejJmQklPS0ZOd3J3UkNRWFBMeWcyYmViZkpxeXo3UXorWm5PaC9RZHJ2bkZmVkNtNHBhR1VsbmNiUVhzTDFuUHBFRlU4bytFSEsxaGZ4WjluMFJqbTY3K0hMdXQ1K0hnT1BnblVVWDRGS0kzQ3o3cFdEbk5GbCs4L1RiZ0lsSmhkVm1ianMvaGd2WmVMNTJ6cjY5Mmxpd1BuY1VYcEc1VUFXcnhNempnOFhpNWN5dTdXdWtnVEdDbFVRekZ4UUhLdCtMREdiOStvVzREQmVCZ2NnU21lbzBORjJJaDQrRU9DQVpKRGlUdExzcjRCM0RaV3BlTFhJOUM1NWk1REpETUpMZ29XNHpJQmxLSXFMcWJjanhlVTBld0NUeHlnTnhOb1NTWDNnenVMbGxtaHJ1RkFtVFJiTlI0Q00zZ1o4cUx0Um1vTnk1bjRhMm13Y0EzRWdlUzE1dnFGaUxTZ3VSZHBCU1NuNnJvdTFYR1ROMVBHNWpDN1RwWFl5WFZmMlpiQTRVNjYyL1gvem5MR1EwbDhub2FWa2x6V3JnS0tuVXJnSVZ2cFlzK0NiUzZyZGtzR1YwQitLNUpDWTUyR3dwRm5sNkNNcS90bFo5QW9qdG82a2JhOHowUFErK3I3UE9oeTJYTy9kYzZVdzYvOHlVR1lvT1Nya3F3WDE2bXFjWDVOM3gvaUZSS3A5Mmp6SVBoL1BkaUJUTnRIWlcrSm1vdG9aN21SWUhMR2NEenNqYWI5SmYwS1NHaVRnd2l3KzBkVysxN2RWNjZZZVhVdnFRcWdKOUhlVlpsdWVUYnhRcFVZT2pMYnhhRkdhWGV0WnR0c2xTVzVtWGYxODhhVEY5Y3NFYTlvc0Q1WjBNcTl5T1NMR0JLcUNWMDZrNUFxTmRuRmY1NENJMnhhWWVWQzZqSStiU24rQmZ6L0xiU3ltOThYVTVhVUFyRDF5UVQrWlpKVFRMRjZ2cUIvT0prRmVJb1BkK0U3ZTFEamEzVWpIaDdMZUVMZFB3MThoK2FLWHVKMkNkRTNUcVd6TlpPOFoycjJ1RXkwb2F0QVU0bzRDNVR6NktsWE9Yb1kzVWlsTmhQNUExMVV4T0JPVUNCZHhLUWZpUFhEdWlyY01QcmtHRDNtaTUrTDZ2clhRRnJyQjVSTHUwT2hGcnJSNTQzSXRxbDFNUVJwRlc0R1VTNFc2VE1semdBV0FISkIzWlNtMjh0MXNPbzJrQVBvUzdCWUlBcnhTUnZBTkgzZEJHaVZscUNpR21Nd3hYWTU4eVBncGxoNnhVZ3p6WnRncm1lUm52TTN5QnlGclhKRjNORWxiU3gxQ3dzMmtPOE8vMDRmbUMrKy9WMWpEVnRVZGV5UlRVNGRIMkQrRGV1WVh0UzZyeWJ0SklVTTQ1elVKMGZ2cXl3bTRtbWZzSFA0TE5YeTNZTllwUHd1UXRPK2gxeEFuN0ZwZS9xNkdCcGU0NUlRWEV1bkhOQVdpZlptOVdwNUJiajRkUWRYbXN6K1JvWUhWb1ZKOUNlZDc3S0JXdEg0NEkwdC96STBUcG41Smt6RWJSZkU3aC9KVXg3YWJoQ1g4QkdlOE1jeDdaTWVEWnB4K2VZYUR0bFN2U3lzaVNtWDB6VFcxbTRuS2txUm13K3d3OHZLeXZxZjlMdkwrMFNoS3d2aFBnMXh3ai9SbXNXb2hKU2JBUTF1dmRmcmFPVnN6SXBPc2ZoaUFCQnpYazBVbzFwZWM5aWhKZHEzaVU4UFJBRzhtMmJkblNXQ2hVMlFQUWRLQTRWSmNkZVQyQ2ZQQ2NQM1hrR2NJeFVnVUVWdUJWb1AxdEtUdjZGRWJaVi9JRFFtS2tKNWR4MmFMc0VWeE1FaS9Md0hURC85aUNkbFhZWjBMZW9uSGcxUjhEcGNEVk1wNkIrdlpZbFZrRGQ3cUl6Z0RvM013SzFBUVN6SVQyZU9FQ3lBUEUzeE5uZWVBVW1TclhSZ013QjduTjhja2dORlFJMXNOdHYrQkdidGljQ3ZCWXlrS2t3SWw1WXdZNVVUK2tiVFhEOCtJVkZiMFlDSTN6bGxVUmxNVFZTdXpzQkJrNUl4eUtGMVdZU2FMQ0gxcHhGbHc5VmI2UE5MU043RmZrMGVMb0ZoSSs1ajJ0YVFrVUUzaS9rQVJ0bUFkWWZXSjlFaDRDR3AxQVRDZ21HL3ZxM3pJRGtKSko2UXc5OEtNVURFcDJIbzNrWU52eFdxV2pNL1k1MFc2TTFCVzJ0T3ZkQ213T0tzem5VZzVKcXEvVVhzSEtJYnlsWUk4aUZuZ3h0T2lGQnlEWk12d2dMS1RJTzJwOCtaejVsNkY5aWE2VjRISEk5SXRBcjZJQkFNTHhXZ3ZWQTdIZkdXV3RlcXhIbk4xQzc4NFlROXVRSXdFM3dJWU1GREE5V3ZCaWFuTSswNzl5QVF6SGkwaWRKdVhlakliaVZGV0M3YVRnUnl0dk1sY2Y1MmM2RkpZNFJsRHNVS3hCb1BkaHQ2NndyWXZwSk1FS0Y5RzlUQ1pRQnpmTkdtZDNneklkeTE4VUVpdTIxeVh5TEdWVmhCZkxzWHlXUEVtTURpV1hxdGdqY0IxVnowUTNvZFR2TmlnSjVzNG1JQ2poMm42dEZSYkJyV0dENHZpNTEySXZyTkk1dWMrWFRRNjc4aUpHUm1iYUtXWC9OeERVQ01yRVR3Nlo0MlJHTnJ5ZEFYODdwUXFSK1EzVG5Bc3FTdXIvR1JCdmh6SGQ3OVJTNGY5VTZpd0grZWFKbHRXMlhQWm1PVFB0K1NTTndEVGdWVEtNZUJpRXdEdEpwZE42RnBlMktPM3VwbloxK284anJieHpDbkpSMHE2TTRZbWh3YzZMTXdZeWFKWHo1VHNYVkRhcE9ZTmFGNmE0Z1M4aUlLckdZMjhGUW1aVTVVdTlOVDRUSHBKbzJaUnJycGkvRksyUTE0dG9NNEdFMWdvTHhBdG9wR3YyalhJVG1TM3FPazAvbmd2a0tiK0x5NFVzbTJ0SjFSMDQxOFFwWDhXL1UxSms0TGt1S0dnRlRhSUE0TkpqWEg0aG1nbmF5eXJpbUl0c2M3d0wycW9vVm5aVmY1dnk2UE5lYlpjbVhsNkxxMTc0a0pYc0FoOUZqOVZ0U21USnNrZ0JWd2s5d1VSaUIyYllsYU94bHErYjBJUWdXMU94U1dZQi9QelY1QXNtTmVDYVUzSnZpUXg0YjlyalMrRjhSanpEWUEzNC93RTFudmEvblAzQTFsYnpoREhUM2dPZDJmSnlGQ3VvdG1yVERZZXhSMmg3ZStKMjNVbFV4ZjhlcjZKd2I4eTNCcVJkMnpuV0FMS1ZMOURwVXNQeS9VMDRyQzM0RlhPVExzTGpuZzJ5dm1sUUpYR3NOYUpvd21kRk1qRlRTTlo2Vk1WcUJFdTlWVTZSVEZMNHl2a0xJUUdFN0hPYzl1emlsWTZ1WEF6aVpGcThpRk1QempTOGxIYVNtRTlyeVJuSWpSaGFvRHdEaDJPc2NxUWRjNDBDUTZnVUNtVFF1blMwNHJuNlVLcUduTHk2dnUxd1d6MklDYUEwdmEyRVJiajlYTjl3c1IwR1JXYXdUR0VwWmZhU2h0NU1pOFMxdDFIYmkrbUJkUnFTTklETDh2UzlsUUxQa01iL2ZSc3JkRE8rdSsrS1UwRE9sQ3hXVVBOQ2JMTk5FbkFlRWw5dlVnU2phNE55YnRmc2ZreGFMRjR0S0hDaGxnMjNmUHQzUGdTY29zY0tIRHJJMEpVQmlnamQwVHlwcXc4UFkwV2Y4MU9mcE9lMzhyZXZwRWNSd3A1QTZVTm1HWEVpY1hzMlNoOVVJdmVScnJFekM4MXVCdW1DZTI1UnI2RWtoeC9JVUd0cFpRVXlmV3lzaWtiaDlqeFpDRGdyQzRKU1dTUWVzMU4rbU01ZXU1bmJCaHFxYlVGNEQxTUl2V1ZMa0tkNXlQRDFWQmVZbkRieVUxVU4wQjZHeUFLVGgrS2JOMldxM0hqK2lTM3lDWnZoUEUxVkFPZ0tTa3Bjb0NodVorTzAvUzBxbXhkUWVtcDBqeWk4ang1MmxTMERiRTFCeWNsbVZ3dzlBN3RNQUpNS3BteGJVenpVd2ltL0pDaGxZYXpQeVMrUmpJTmV1N0lha2lrdG1UbitlSk1FQ3FlelJEamJDM20wWkJGSVo1M1FSdHJTeU52MVVNT1QxdW5rTlJRY3g0SEhFWW9UUUs0T0F3TmtUN0NScnNZM1Vna1hFdWljZ0J1TS9KYU5VKzErV1VhVDRHZms5TzdpZlFPdmY5R3Vuekd2djY1T1YzSHVnRkk5cUVyTERMZVRENVlNRnVlZkJ6RCswQlVVcVY3RjFqZnNtWXRlWDBJcHpkUWNzS29wMkJQVWo5S09oTjFmWTcwTi9SWHcvQUdNbFlXS2JUZ2hSS1hQYjBhZ1JVZ0MxVTRZODRrT0pteGhhRTB3a0phWVpzVlpYQUoyNTU3eHJYaVFyakpFaStVZm5QQ001ZVNPdWVIa3J4ZXc1TExYZ2syQUtoUUlka2NvUytUOFZqeFB5T2xEUWd4TU5iUjBsRE5UZDF2RXF1N2xiNS9tMzZwOGU3VVg4VjYwNkhkVldtR1NWU2dpY3AzRXE1ZzhrWkhnNEdTblhQOU52eDFtQUdDL3U2Rk9pUHd6U2xmT0RmaEtHbmVCOGVoN01uOHdTOWprWWlVQ3lVTDJwSXNyYUtOUEozWTZsUEUvWVRmdkRBaEVYeFphelRCSlJka0tta080QWF4SWhha0VCMUdkaFoyOHNiNWpXQ0pxL2xkOE93dllRTnA5VDlFdVh5eXBqc2oxenFPL2VNbFEyNmpuRUZLMzB3R3hQb3NuVmFuK1VXaEVQNUFLYlNnazhiUU5GWXIrTHVYcm5WdTN4UHBuSk5YUlhoN0tVYlg5TUpZWDd3TWpyK2lFRWF4YXlmTDZHNFkvbVZGbWFkcExzTy82NHBNRHI1M0lBVTZ3cS9UbkVHZlVNaXJlTzBaaTl4RTcwM21OMHZuTHZyNEIvT01aUXZBZzVIbzlKWHFMSzN1dVM5SHhBaVpLbGdBNE5rbHYxWlc4cjRJdCtSNHdFYTMyUldaeEF4R1BWSDdNdUlxaGt6RVphWHZFd1Z5OFFMdXZ5T0pLVFlnRGNaRXJQa1ZPZXJvd092SW14MjEyaHVkelRJYTVMTTVkNmJKeGhmQkxoSHJHZFBZWXQ5T3hQVmhtc1ZNNnJqemNhNGZSenQzYzNaTnVLN1VoVW43dXBUSnhiaXJEQTZ4cTREZ1BWY3RCUXNyK0hKdWRoS0lza2xFa2tYTFlBRlM5N2hVRXRZbGNyZTBWeld5S0NVd3dxTnYyTWZOdUpmWGZBeWYvUk12cnBLc25hNFR2cnNBTDQ3QXhpeCtQa3VURDh6RjVjUkFrbi9HQkFQa0lqU0FEaG5udTMyNDB4Q05kNlhTSVo5bDhQbVJxTDFQNlFtWklHRWV5Z3Vsc1U4Sy8zb2xYZWlJMGt5a0dzcmZvaDBYK2x3QUpDd0ZOQ1plN3pHZGpLTHAzZXF3UWFzUG91eXVhaW02bHhqVFVGQW12TjlZVmhPYlZKdTZmT3NWTHdnSEF1RTF6YUNNMzVJWXA5STRKNnd3TmhUdHE5YjAxbXBPajBDNndvcGhFbTlpdDIvUzU1UkN1SFErejIrcC95eDFRUm5wKzJiZUk0WWxTK2MwN2F2UkJaVlZncVBVTWlnRnNCRkVyYUxlcjlIZkwySjZuRDFQSFRTSEN3VlVOYVh5WGJyTGpKVUxDMHpZTjJ5Mnc4QjhuZWk1cEtKU2VDNHJuMkVjMDQ2RXU0dDBmQVNLeC9tYUZNT1ovTFFrR2c4VmVZbTVJYmFiU2J4QnN3Nzl3SXYvN1ZEYWUrTFhEU0o3Q2F3WnZrN3FhMUIwK1JNb1dvci9acU9BMWdJOVp2bnYwR1loZUo2MS83SVIzK2JTdS92bW8rTndJbUlTWG8yeVpuQ3RuU2xkb0lPMmFNdkpUeFI0aUdWNml4R0hYRlJndGt0cXZ4Tk1VdHhkbWxRNUs0c2c2Mmd2N1doK2JsL0xLZmdoOHZKeDVqSFdtOHpmekNsYllkQUgyVDJDLzF0K3ZvWlhRNTZXeEtUTHZHdTBPOU00QmRsSUxpS01sMUN2WURmTithMUUrb1FHVDVaUXRqSlBZdUozNUN5bHE4SWVaT0pnd3JkanVYTGdqK3pzdVJBZnZFMi93L0lzekZjWG9teUt0cmc2L3haa2ozeHZIamxDdkpqcnpicDZnNmYvTEN1bUtzRTNrcTZteWlTd09zb2N3Y3lIL3FLdkVETjlOSWMzZVF6MXBEdEZmK090MmFOVzJla2xVaUwyTy9wSnhxKzYwdXBobkVSaVV0RGtOVDZYUXRUR3pVQnVjMXdmdU9vODg4eUwzamxTWmhONnNNZVg3cEVvbjBpL3orU3BmaG9tY2wyODFjMGR4dUQ4aTZoV1NTZVdESDlvR1VGd01rQUxnYmt3QmJrOEY2ZGlXRXo3bjdnZkc3bXljTC9JazZtUmtsNHBNR2Z5Q3BYVUJGeENwanhFK3IwNDl4U2ZaVkM0SDJ2M1pFZGxuUjdvMUxWU1gwZ3RnM1NVY2ovOUptT3RIYWNsU1Z4MFpqQXZoZ1Y1WHBKUTNSL1pTWDZvTEszRFV5SWJCa0F4U0Y4THJVN21RNGFiVkJVZ0RPak9BVmRtU1djZlQrOFV1eFpBR1I1ZGFBdm42cmdMbzhVMEphaXVvclBYbkthcFBRZHpWWVcrdVBYR0MzVWNkaWFadjVNL25VaCtjMXI5MnR3WWgyNFlSeWxyclp0eEU1c1BrcnJQelFBYnovbnNZYWF6ckZxeXlCeWdTd1JPRjYyN1dIeTN4K2NlYTlycGFXenBsNm1laGRFb0xSYk1RY1RjbVNpZUtTcUIwbVlVZkp5KzBrSUZ3cFcranJpUzdkTzJncXlyMnZvNVEwRHVINFVzTDJzVDl2QXI5SU1sclg2dFh4ZVoxbElhUE05NjY3Uy94Ni8rb1RTeGFXcDdPWm1mbkhIOUdGWi9NeENUdENkSjhrNDJteUxmMW8raFhMUENEOC9rUjc4ZDR0OXQvKy96VDduYWhyTkZxYVBRbXFaNVo3SUp4ZW93ZmczQlJZSmtEV2Ric3Y1WWdxK2t5WXpJQkRVczFrcFJyaTVYaXZ6MGxxNWp0Y0hocXhZQnowbnVwVHIxc0hMSGkyOU5Od09sTWttUE0vSkZQc0lSMnZxUzBrTnhOSXJmaTJnQXllY1FiRUpVQzNucmpBd3VvL3llV0U3NHFFOU9JTGlTWXh6S1haTGNQR0prRlIycjh1Sk41bUp0YjF0bUF6UTVwMmJiM0Z4bTVINGMvZ0ZOZjBRR042TWtsdk1qYmFITjZVamQzTzMxVDVKZm40NCtuQnM2RldjeGx3OW91USs4UHAveXRHcnEvUVlrSDhSWDFYQmNzM3NLUkRhaFJWamdHRTJwWjZyem1TclAxWFJmbXdlZ1lhRE5JSjFQUkJvVHBDTSs1Zk9LUkZSRWJ4UDdoSkV1YmU4WnBhUFkreVZGVHllbEZ4Uk15WGxGdmxDWWtVOURYODRvNUVZeGdkZVU2SUZObDZ4NEc3UU1XakZWUllQZEJYeTFFaG1vUU9ZeUdpOFpxUUw5RkZRNzJLaEFHako0RDBSRTRoYXRYY3JzWmRvVGREcmh5WDA5V0lvZmhCVDY0TUlLYTlmQVRJMFZoUnRMNXJndkc2ZWttbUhPUHArWVBQcXZpVjZzS0N4bEdRaENVWGtEZklWM2xyUklnelVpOFdKb2M1Ni9Ra2VmYVBsQnlzN244cnBaWEZPZzRPNTVxb3pZNFVoclJoVEU2aTdpcUMyclYxbXU1THk4NVdTbHRIcFJsTS9sL25rYVBzSmcwM2pPeVYwN0taNFZSaGM4MDZjWHRxeGdVZnNUZENZVmFUeTFXdUswVE9RRHRxcWk1MExnRExrdHlkK2N4SXFtMUQzU0s4bDU2aThmbW9OaGttWkFibzJnZGZ4c3l0NDZGdG1FLzhvTkZrekRLb1BSb2d6VzRLUVBHeFc2ZUNOOWFhWTVUMTJaUytxS2pCMCtaUEJLZzRaNnJuMUZoeHkxZUZyN0J2R2VKUFkxVFFXZXlod0ZhRGZIRGNxTGx2N3JyL1JaT2IwT2xFRUEvSVRnclJqL0wzdjR3Ly80L3lUck1DZTQ4eW85MGhNdTRjb083TXJBRmtEWDRQUVNid2RVVFBoc1N4dGo0QTFGZlVnbUJtbFphZDNSdFhPMTA5YzJRMWdzUldncVpSTWFEc1Z6T1lZQWJ6c3NLU25wRlhDOEhXbWJlQjBxd0lDK0l1UUpqSVVTOWNsRktqVVYyTGcvM2ZzQkJDVzhBQ1FWQ0NWTFJJclBocTVxSzVrQ0h0OERsRUNSNTlLNUVjK00rWE83Z3BIaDQwQkdLTUgrRkE0dTBlS3VrcDNnV3BlVkIrNVhFdXl1aTlwSHc5Rml3S3YwZlE4OGQvV1ZSSlNXK0Q5ZkdtM2NrKzlpNmg3Q3M3MHgvVEpabHUwb1ZESzJNTS9SL3N6TkhaR3RJTjNyY00yV3F4Wi92b21jckZqM2tlMnhJQ0diUWZqNUZPL3BvSndGd2t4dnZZTHdDdXRyMHZSN2ZwWGlhRE5scC9xMVBqaVlrWXVHVnluSnRUZHNNR1RHY1JvcHlzbWVkbU1vaXEvajUyVTk3ckFQSFk2L21uL2xlRTRyWDA1eVpHa093RW5hSDFCK1EwZFo3bHNKa0NVNWdXTWZMejFKeEJLY1BpQkxjL3lyWVRvYlJlOXhLMXRNT3hleUljdXpUcXB3VUZXUkd6THFpbTNVUDJENjRYWGovVGs1MndTektRWUthSFZCMHpIa2hhU25nZUlSVHdhUllVb09JN1V5TTZiazlYMTNMUlRJVi9ROUxhdXpRWVlZaFNSM0RaQytQc3hUVllZa2d0b00rUmZpZkFWdFBrdEFqRnRQVS90dHZPN2lwVXp5YlJlZEZkMi9RblVhOFNNRjA3ZnlYaEpWZXVUby83RThzOUh2TzZGVEFlZHBkSGVIcHlQSnAyRThMdHVXcy8ydTlkTEpYQWFzbDVNcEFsY2l6eXBvNmdud3ZmaTViZVN5Y011T253V0taM2hYYy9iYVBQaldNOTU0d2NZMXNPaVR4OU5VRzZrMUU3TnE1RE5zeWlJOU0wYVFGMzhLbFNOdjNCMWZicEROWFBtZXlmZXlrbWZ4dWlOZEpMd1ZCdXdtWlZkU3BlQ29KNm95RUl0WE5Zc0pzRDlGWDgxSWJqR0lkNWpRQVRBSG9DVURWNTZNOEkxMm9zUnM5c1kvSUpsSWlMKzk0ZVVhaHROSFY3MjR1d3RPRWxmVkpMaXRDZ1Z3QUp2SGlVaW9oN1h1RGF0Yjg2K21Xbm9tTG5YMlZrN001dmo0UEdtZWt1SlZzZkFneXZUVTV6R0lZM1lsQkZLUDczVjRIMmErNTdEekpEMlRFTW1MNGpIMFphbkp3UFNyOERsSjc2WUtYU0VIY3FJYlNyMFJuQmpaVG9ldWRvVHcyU3VBUlIxVkphT1RKZFV3ZlVzSnBsTjVFcmpLWERhWXBMZFpXa1FkYkt4WWNGRDFKZ20rbmk2ay96Wjl2cE5mZUg5UXNxamF5bFUralY5MjREQXJ6KzRnNlYxSVRLN1AwamtRbzY1VW1vSzBMU1loeXhiRGNNMHdaT3l0em50VFlNaVI5S1hTM0V1U09ua2lnWlZiVVg1UFl4bXdrRS9tLzJNOE1ZdGFHTFNQay9ISUxLN3ljeW5oZWRBNDBPWkMyZDgzMWh1ZTFqRTJmS1RrbkVmdmNBekRtNitMVjc2aitGN3UvM2hwcUg0eG1aNGJ0WW0rMkpMRHJsaGt0SjNYK0IraFVRVjBNdTYvdXgvMm5NS0wwOW5ISGdxcm1sZFZteEMvR1FVMEltdXlTSmRRb1NMT1BwUy93MkUraDk0WnNGYVZIQlJtYjlsbzQ1TE9KL2lwR3NSVlZLbWtLTWVxTFRJN1kxR0s4eVk4MVdrdW8xOHIrMCt1YWk1RDk3VDBDTWk5bE51Ym9PWmh5d0U5SU1ZTHVJNGtjTUNoVUd4TG5LekhtK2RFTGtLQjBEakxSMmZoenBSa0pva1U4VTk3NkxLUjNuMDdxKzVnVzFmRlZmeUZuVndET0RxVzB4NXMrcVR0SkZKUDlOM3M5RXdyTW5sSlVOV1VKblhKVGRFc240WXhRZ0RWSEduTDl3OXRlZGpudDBaU0xnRy9Ra0pRV0h4cythNVVTTlgxT1ZpK0dQL0xWc3BUZk1WUVpnS3V1bWxVaEc4MFFoUStPZE5NS0syV3dET042aTNsYm91M2hxakZVeUpJaVFFWjREbUVLU0d5S3dQSHlHL01rOThaazI5QzMvNU92dGJOb0VDWVdaaDZBdXNRRnFDdDA2Z3ZTWmNvRHVDeFZ1UWEyRmpOaXpqdUxuTWE4YklQeVVTMGNIQTlNU1NMUzBxNmRRZysyeE44bWpvbFpXaW1hUTFxYmJpY0RMNjlzREh5NTRmQnEyYmhlMWNwcWtleXJNOEpLQ1JBcmFBOVAvMDk0VmswYzFpTmVZa09DNmtvZVpaQXhSM29EektzUzlnUmd5bElMYlM3SVZZbHNlanAybzIwWThOVHdHdGR0V1RianN2a2tGVHZjdVZ2aGlzVEdiekE1L3ZoVyt0b2ZvNTlPYzdiOUpMSUN1T2FBdGNXRERSbG4reTF5NVg4dFR4SFRUcFpvRDJLTWhmNnpuL0ZwNE5aUm9DOUswVll0VFlXNlJ0ZEZqVXlHTWo4T0pGWGRGa0dxZ2ZiQjlFN1NiaFE5RHEremkxKzcwdDdjZUw3S3Y2OG9jc0x1S1NTa3MwQ3lGMGYzZnNHWHFiMGNKeGthN2c1UVY2Sit3N1NvcFRtNVYwR1RJYk1QdUo3ZVNsdkVPZDNVMk9nMTUvNXp5Q285a2o5dXR6TnNKQWo3U1Y5UFlGUWhpdExtYkRPaVoybWFqaE15U1NFVFkwdlBwaFNGY2NSbHdKNUgyRFRKTXREejE0cnhDTjYrUUVxRGtqaWFKQ0wrVHNhK0d2SWNpMzRWRnY2d3BzK2RjT0Z2UHMySDY0N09VVnBPa1FMeVppYS9ZaXRXTExQUUtkUE40TDg0azhUdjZDV1l6aGZSRDBSdldXUmd4eDhUZWRYa0xWNkFYMUY3blhnU3BXYlhPeVhoTDRNUjZ0VXlBay96cFdlSURaS3RKb3NLUUxHVUdCd1poTzdHWVYxZnpveVNpR0VIcVpjb29nZjk3V1NLaFhIakhOU1RoaTlaNzdBV2pvbVpoWkpDamhWSkgwaldSSko4SmFvdkRCYUluUmlZelhEK0l5bksrcnI3VHBhR0pWaVRXOWhOVFlpaEdZU3F4cVFFQjdOb1lMeDVsUHZ5RFlQN09TUGZ5elJDOWgrd25vejcrVmk5dlkxWUUrZ3VBQXJZWHEySkg4citPMmhRcGE1MVZTSVhLQ2dqSEdYekJQb1A2T0wxRWxkUHJoV21DK0hWbDZNbnRsZUMyWURwRm9VWU53ak9NZ2FKcGVWY3k2TnVPU3cwM3RXOGU3a2p1NThCYVBoYnEyT0FEc2hMM1pJc2NMcVNxeEwrTmxXbEdzWWttUCtBbkc3bm16UDdSQUEwRWQzenNQelJTc00yVjNCZnZZYXVScHJDbDB1MGI2Rzk1ZkJkVWpscTlxK0M2WU90V2RxbU9KbEV2ZjZPQXlZOUcxcXBJa0ZKYytRU0Y0YnE0WUZRUDR0Q21Ma0pPRHN1U2dWZ1JyanlWT1JFMlM0bWs4VnNicm05bFJGd2F6eFJMZUI2TXJ3NW9SUklyMnc4TWZ2WDE0MzFDTXAxSS9MODBBS2hoZ0FrVENjT2poemhhZVhhbUVZa1lHd21UZ1YydE0wdlRvdHN3bTVhS09QMTJhZkt0bHhFS3lsV2RyREt4ZmNmak5KUkp3V1NIOHIvRll5MzE4UHQ3WnhiMlJJSG1LWXorck1oSGlZNFBnc3ViWXFaeXhLS2pLMFRDYmZTeVJYbzFuQk95QnBRcUNUdkIreFBwOGRCUXR4SnJrT2txeGd5eHhlZ0t3SFhBRFNEaXc2UWhsRWM0TmNtdkRxS1gwQ0ZpTUQzRXpnN0dtc0tHaEJ4MmN1VC81TStkN0UrVGVPN0d5SnRYZG5iKzRTTjRxM1h0U2lBMHFQWjZ1RzdCVGxiM3hSaEtSeE1ab0lEU293WjlEcENoZ1pFU201WWM5Y09sSFBBM3hPb2xXb0dhUDBJS3NZYjdNc2w4eUl1RkMveUVkck02VzB5OE9BNVRWeDhrSWFPMmtENDNDUnRFdThOSkd6R0wySnVISEV5MWwwMXNsa2lOaHVGeWhQaGpvUmZaQ25IaTJveDBiNDNoZWxWcXlNY2ZTeFFpWTVPRHZoeXdmU1pKWjJyaXJ5ZXZvMlFmR09NamtXaTk5THZwdkJFenIvNHk4S2lJbDlRdmRudVdVb3hsNnVIN084UVpyclBNM25XWjBlQmhqNWNmNVRJdVc0Y3g5T3JLQ2NoOUVicVpLRHlrWkNiVXJQdGN1eG1IcVlsUDdmdnNib2J0YVlWdU43UmNOeGVmVU1YTjYwd0laU2Z4QnJQeXZ5Q1h2b0ovZUF2UE9ZangyK1gwcjBWWnpJMkFKa3E2KzZFelFsQ1F2Z2kybWF6ZURmSWVHYjMxY3VoL2c2NTY4SGZHRWNONXF4OUVxTys4NWYvTFFpcjZsdlIyRG5aUGdsMU15S09ha3JaelZnbTN4NUNnY1ZNL0tvbFNIc1d4b2ZrbjFGb0VyK2RvMFZhZkRhTWxnc0NoVFdVVHh0aThNaHFLd3FCa3U3RlF6bVJGcU0ySUtZY0RRTXNEa0FPMWtZVUhDUjkwV0tha1cwUHVQbkJCbFRXUTNCNldtcVZLUmNUZ3B0Z0laaVZnYVFrMEkvSFV6bUljNWRxNE0zVWl5UFVBTElzRWpmaitralZUMU5na1pQVlhNMEs4Y3YxK1RIbVFTUnFCR2lRaVYyUXprUTFGVng4WVN2VGRHbjdYbm5TbDVmNDdVYjAxTURaeWZhaDI5eUIybUFUbkg1aEJVTk5adVZnM1Z4bHZBVmh5VG5zbFZoUlF0NUdVRE1kU05XY01zRVdpM1ZmRDRWcE5JSEx3OVEzalhlV1hNL2VZc3BlM0p3SG1sdk9sSWE3SnFaRktscnJqYk1TMUlDcG5maFlSSEx0bGdkMDlPWVJOK2x1cG5zRmhXMVFiZk81KzBEYzNqRjhPdGg3bm94NktmSGtuZ3JENGdrOEk2cWN0M1QyTFY5OXJPQVZSN3hKVE45ckpzWk9ibjZDdlg5RkVPV2t5SGJkNDVyVnZ5V2xpdXlwZGRhYmtaaHlHWjVRbzhjUEU1OHdRNnJ5bG5SKzJpWVJ5WG1ZcEt1K0VZaE9qRlM0OXd1VHRYVENXMGdZcDBGMlgwdUNpQk5lZlNPMU5MWVcxYlNPZEtlYTNGV2syWXJBSzZMSE5KR0JKSytNT2R5ejFUVVNCVFd3SlNob3B5U1F6VHNKQXRuNFJ1VXVjUWd1NmowcEhUSGxZbVh6bEppUWNSR1hKSVRWbFBpNjNoSzRuNG9sVnVtQUlya293MDFTVzVwazFyTUFTNWZ5T3JEZUg3T2NWTVoySEJUWnRvck5tL0hlajhnMmI4NUdtR3BHekRKVndnZ2hFdlZEOElYSStPMzNGMmNhamZML0tRdUxGT3BMK2VqdGR3d0grYjNqZXBYd1pPemhGaUsxakJRbGEzb3BNdHdlUmN0VFpKdjV1b2xkSDZjeTZ0cXlqZTFzMnZ6TTBsdnJyWHVuaFI3cjBYL3M3QjJSWC8xQUJzNDNEb2pCMXpSWFZGZms0OFhsVXNqZVd1cUZEaDlmRTE3TjVNZXAyVFVoNG9oR1NGb25QQmNoOGJqWkxCb1dIVU1iOW5SQlI0V1JKb0psUXlGUFQ0TXBQUlVpSmZtSlJDVkRMbzVkbjdEalI1emNwcVpOQ1JSVWdvQ2VoSHdremhCa0EybG9zRnNVeXErRnNPMkdWWndRN2YyVXJpVGdIZXBjVnJnbTY4WkkrUWhGWDhrQjRkRXZ4ak5Cd1hEV1VIcmZURHVBTzhzd0JZcXhtN2JVVXczem5INmVLdmdZckFXV3M0QjdVNlRuU29TQUJsVkdHVGgySTV5anJ3Y3N6TUZEUDQ5SVk4VWpyZzV4STRCY1l4S08zaHdQVS9tbjFkY2hJcVkxWTlnWkFrblJ0WTFxWFNPWmczakJKRUlKNWxtMktEZ2JHa2FNMXlmYTdrNjQvOGpnQlJwcXljL1BSTDcrKzRmb3l5dENMTUp5aitNWGtWVzlsZ2pmWENRS2VaL2YrVE93NHVDV3ZPVUlvRU5UV3RmWWZNSjAzK2pjUUdVY21MZVRESTlza0RTM2lNMExUQVpDT2MyR0xneGtPR0h1L0ZmVnFWWG52UCtHWWk3d1c0eHMzVEhPTDJhZHQzNGVqMTFHOUJSS09rVGRxeElGT2dtRCsrTDRpVUtJWEpQcUdSeE9PRlJVMEFkYVRDMXEzSTRnZDFtY3V1ZkoxWnZjcGd3WjZkbTJ0SlMxKzN0aGdkNStYb01VNHhlWktTck9XVnl5R0djY2dwbU5NRU5udXZ6eTJWWlRqbHJ3Nk1LYXc2d2V0OHc1bmllTThaWlhJNDFBNlFYRWVjcHYvTU11TzM0alNGZVVGdTlJdVFBV00vWlVrc2NLcUdXNHVXQ21IMEZBMVZjc0NUU3hUczVyRldaS1pJb1JXVGlJbXlDTE1KRUIxN0FJeWpjQWJZNXh4M1VkdGxtSVBld3JIQWdmNmtkS1NDdm9OVjZsUGdLMTBXUVlLMENza3dwenRQcGEyU1A0L2k1L3J3UTFrc215SUx6TWdwT3NxV0o2UjRvUmlKdUx2dCtGUndxYlB1aFJzK2o5dEFQYjltN2MzQmJnK1FzZlpqSDJZQmtGdm5vQ1RadEtIZmlVVkhycG00V0tlVTd3WmhuWWFwcXJ1ZzhoTEVLbEZQOWRWNklERnYwSkJ6SXN4UzdFZ0krejlqVWhTaDNGN0ZtbUVpbzJ0YVNQbkpmZzRzcTM0UndFY3JKOTJRcjFzNXFLUXpRRDFPd2VBM3VvNnJIb3lLVHozMHk4a05kUTBTUjJpc1FSS0FhcXBjS2xYTmtwU1IrYzRtWHFkaVJRSVJFS1NTblU4NVhNS3lISlRuV2U5STBsR3dURjk0WHBZbjZxaSttdmFUNFdwcVhBTm1TalRXNDVNT3F4N3NJN1duSmowYnhSSkl2NDNqQ2pIUWdHUUZsaWNCLzQrNy9ydTlBL3l4WjNzQ3RDckp0Ukh6aFl4UVVSY2JIYVkvM09rbTVURklCL1JKWWprVWZrTzRaWG1talBPRmRHZlV5L2sxWHRoRUxQYml2S0RQSTM2NnA4Z0ZYSGticHYrMlBEd042eWVVeEFvSGFpK1dOYjBXVjBGTko2dnhJY2txa3hpV3JRUXVtR0g0VWVUWWttd2tacWx0TVRIdzBlbHVrWmJBVWFDVWdYaTlLbmF2VEdsQWdrRWFVNGpLUjV6QWZFOWdDaGc5SmovYTZLWnlqYWl4NmdGQlo1Qk1KN2h1RkYzaDB5ZFg3TWwwUm5ZMUFTNlczVmtmTzFYQzNQTE55MEM0SlcrWitnL1ZDdUpTRjVVaThLQ2FPUnBhYktZeHhid0RYQlBaSEpMUjU0eG1jR3FpRXdHVUNzK2RVYmFWSE5nZU9wSDJIODQ4eDJCTlRvcWN0TGhka3VaN01sN2dOdGVKcEhKOG5PcGFWUE8rb0lBV295V21tUXNKdGRLWkNmNEhMV0ZKVzJXclpzY3NwZnBEN0I0ZDV1S3pLcFU3MDVEeVdrVndoZ3NlZzViTUhrMFRFNGluemJub1NWL0Z1a0ZROFV1bWxya244QnBoeXJIV2grUXhwcHFRV3VmSVR0M3VkWHl4NTNOV2JlYmdOZ3FCVWFIT1lwV2hvWTYxUG95V0pGa2o4WTI5OE0ybXVPU0RRb2dLOWNpYW1Odm4yVjZ6cUc1V3ZzYkVHSW96YUg0VmREOG9DdlRVQ1IwQkpXM2lMeWQxNkF1c3hiRkl1MEJwSHJabVlLUHg5UVROZWVubnBHOFBZZGVBTEd0MDhoSlZ2Snk4UFl6T2o2b3ZTZmc1STV5VEZXSjNoVWdkZi9vV3MvZ3ZLbnN2c1FGMW04TEJsc2hDdFRMSG40N25BQW9HQVlUMUdtMzJvbk5CT2h3YVlLRTJJUTRnZGtHK2x0U1Z4VkZPT3E5NGEwRW9RY0p1a2QvSHBRcXJaUk85aUZKQllBOW5sOElaTUw0RngrR3lJeGxLcEw4d2lPalJRejZabUxWMlNrQkVwclU1eTUxa2lFdm1USkVQRTMxVVNIT1V4eFdkU01rU1pQRXhTTU5xaUQzNUs3Uno3Y2tLTnE4YnNkVHJ5Z1N4ejZhWVlDZ2tCWWZkQXFBT0w4NW1CbndmOFQ3c0JmeVc5SEliMWJMWlJ4cU1GMFBpVGdGb1JZTXcrcnVoSDhtWEVpNjlTOGg1Ky90TEVtMzcyTi9XRkViZDdjWEx1cUJpYVFyd3A4bTJoT3hHZUE2QlNKQkpZRXFSWTk0ZUtmakFWNEpCNEhTMm53cElBeVJFdHplWW5KYXVseFdLWlpJUW81d3J1b2R0cnlJaEhDem1oQlpEbU0yOGFZRFVMSjIybVlkdzR3SmVFNTBDMGVWVTlYU3UzZWFCRnhNMkJrWndxeXhGTElESXBIc3ZBSll1dnBXZ0pPQldRMlJZckw4Z1RoUjhJdm5NL1NVSVNjVENWR0lEUlI1OW03WDUwcUtMR0RXbGtpalFGVnh1cENQSHBDSUFMckJZTVduTXpQdzYxdTRVTzVtUlhYdXBIRjVjOFUxTmFMNVZLRWVjdTZlc0NMNDdHSTZYMFNKM2h6Ti84WC9sejhEMGtSSTRxd0FEZkprZTl1RGlSYTR2d2JFVlJDbXBjRjNSSjBlK3hYcE1hQ21sZ3hoWFlpYUNpZ3hXYTBoVXk2ckxyTUozMHhlZFhvVnBTU29ia0hmTUUyRHlWRjJNMXk4QVJnTVVWZG1VTURwOGt3VmZEekxjazF4UHJTWGptWVBGT3B2K3VKdTRwUGdQeW9ub2xUaC9QbVhpQzdFaTJ6a1R1SUJtOWdnSEhqU0xxQkR6QVlMSE4xRFhzcnF1S3dNeUZZNGVVUG96SkEyLzJBK1pYRU1oSzcrQTB1OHgrcmFvdDdtNkZPbXVBMGd6bFczRnc2RnNPT0dpWTJVVVFZRHlYbWREbGJzVmZkalhGSjFGWHkvWGw5QklhUFVwZVI2MFFxVFZzYm9YZVhISDJFbW1rcmJZRUYrU29LeGtSK2Q3aDROTEJuOEx4dHAxeDI2Z2ZwSGVPWlVtR0V4dG1CVko2RExyNGxDaGd4WThCVU5hVCs1SDdxSkI1bGs0Zk1OMlVoR0xES0VjYVA0SW5XOUp1WVVJVy80dHdwcUFuOWR3R29zMXFHZ1R4ODNWNTVvWFhIa1RaaTh4NEk4My9Db01xN0YrUWFvQ2xNUXZiTTkxUXlqRUxMZlhMSlRVczhmb3R3aW9KTTNGR2RlRUliNzFHajdha3c0ZEpjVW5OOWFoV2dQZm0vQ2lFWEdaM0VQdHBTUjlIWEJOZ21ER3FOVEN0aUNrQXhiRjBlWkRFYVFwSEhsODNUblBKemhXa2hzaUtRYW9yb0FWU0JGVUsvUXgzcTZob3hUTUMxd2RnbkpFUCs0N2ltQmtTTjZ5NDhkeDQ3ckE5VTdsWlRQSk5jQmtuY1NaQ2M1S3VjSE1EVkNhWm1jWjZqRjJkd2VVMmVZUzl3a3R1eTlKbGQ2WmVMZmdhM0lDcGp3amNsRXN4T2g3dzU3K05mbkJEYlZScHF3aG1GNElMU0FlUWNWRWRpdUxOZUxxUW55Ry9Pa2pZcFRSNmtyWXpFZzlBSVF1WER4elNjNzROd0p0OStQWlN6Y3lpZUlWRlRmZU80YytIUmpzV2FZWm1WYkYrcUJ6cnhEaVFmK1F1NGcvK3QvOVhtREZ6L1RRcEt0RTZ6djRrSENOTnd0TEZ2aHJxK0owNGZsT1FyRDRFa1VoOVZtL0t0UUwyYmRYRnhNdkorOHRSdmdiWHE2R0RwVDVCeVVrT0hpaFhZNjVkQUhsQ3dlUEJWRkVpaVdnR2pBV2FieEx0RDN6MlBlRGZrQmFhdWxFUWNZZ2VwZUxrSW5qL0NqTlVZMUtHTjFUUnlXaGRHaTZlcWMzRFVBTG9VUjlyQldTM2VJclFZSlJRUWpZTytHQ2YyRFpJNnJDOXdKTnpITTJsbXdkUTAvZ2VocHU2V083T0hoL2J4NUZqMGt3eHdjVkNNcyt6YXNYbkZqOStqdXRWT05TZ3N4MDlHT0RhN3VBMVQyazNKaVhEaUFYRXlIV0Vtb0V4d2NxSTlWOUh6RkhXZktuRE9NdVJKVHVkV05oamFBZk52Z1NadzhIc280eU5BVXBOMVMyaVlaV3ZTV0JUOFpLQ0ZWaDI1TEN6NFpUT2hkMUcxUkZ1WHhwblU3WTBsSUkreWxCcGN4Sjk5Vklxdmt4dWp4MGlKVkRKZzRzZnk2aVVOaURLTVB6V01XajEyYlBoSkNOVnVrMEZySVYzVmZSVm9vWU9qbXJjeWJQS25GMlc0S1UrQjZGUWpzcnpsN0xoY2IySWx0bzh6cU9EQ3BHV2VYWTVtYlVyUXltOTFRYVpadmhNZ1JXVHRTRUdqRmV5ekJVSlNlSDkwRDAxc2hmVjlLSkIwMHE2QmNRWmhjb1pMMXhxU1k5S2xKMGpVNW5UcTNYWVRnQ3dBUEhCckpORVdYSkxpZmZ6Mmk1UEZwZmd5aHQ0Y1JCM0dOZC9oR2NGRDA2TWFVVWR4MmxWV0RlK1lQYjU4Rk1KSmJiMHQyNHFVNmczYXpES0pMSEs3NTVrbXRidzlROFdqcGE3K3FTSUpBQThyR3FpSGNJU0FOVUtTRTN0RFpPOERzTUVXeFNSZ1NEamRDSGtrNUR2YlZUZ1BpMWIyY2tCRmpjZytNakhMYlhTSTdsdTFMOWlUTGVpU3NKNisva2pmMUx5elEySGZlT29zeDN3dlNZNmk2bnpTdFJhMHJ3b1hYV2cvaDd1U3hLK0YvMHZWdDY0eWxCNjhuSXFoTDN6a0pXS2lZZlVwenNwN0tQcmZUYjdGYzg0dUhzbVpwQm45K0NZYTdvdDNFTFNQVk0yRDNPYnI5TTlBTllGZ3hDMkE2SGErTVJqNVdWbUMrR3N6ZFdKNFp1aWwwcEpKdGs4MG1lUHRNNGJuSXVObkNSc3hNR2Fmd1NsK2pkbTVzK0NaeStCb2VjMFF4UTBacFJSVXNPcjE5Slh5MENwNDB3TW56VFQrd1Z4V1lmV09ib1RCS05EK3QyUUtmdXBlYW11WERvUmtYb1JuVEwxZUI3OVR5WWowZ1AvaEZQYjB4WnlXcGczbkcwOXFVaWJFQTQxTXQwS3h3dzBCdkxpSU8xclJ2b0g0eG5YcjJ2eS9CbHZWNkZWRjljNGpWdmcrWGxpYitQVktheGR4SU1YazdZWGg1aXNxcEFZNk55VTZxcHdzOHBCeGEyT2pKd254dCtoSkVBYmUyR2d5N3RBRmpWUjA3M01pdit5NXFvMS9HRW1PYjJEWGxpelJVUGF1WVFCVlVBTWlJSktpS29YdFAwb0p2US9oOWMvazEvOXdwa3EvZHBUTmI1akRxOXdtQTBXT0dxbTZzamh2SWpkTFJLa0lMY1p5NCtJcHdqMkZPZWZtT1JreW5MeXBLbXNSeHdrdk4zai9EclpldXhxWjhHam44M05iRzZqbmw4RmJGSlFuaWwwWjZxWFVmUUZJa1pKYm53VzlGdzZCQ0M3azI5SzhtZ1ZKTGpBN1FnK3BMMitYcFFFYi9Jb0Ftb0U0Q3NsajZITmsxa3BWZnJLeGxocSszRTN3ZkV0SzJQQWdSMWYvMDJ5YmM4L3dlclJXOGtmcGFoK0pGK291VGlCRUVVYmZYS3I2VHpaTm9jOGxsTFVHaXNEUTdBOTdlb3B2WG0wL3pqSWZicXBneWVtQnZDVlZucVlreFphc1Bna21pVWlNVUZXa2ZiTzZaYVFyLzFFZkRITVN3TFVMRW1LWXp0TkN4UHA1eWJPVk9nYXlpUWZBbndLV1FqTm1TZzM0VzZWdkZEbkh4L1pzeXBFWTFKTU1ta0NwWkkzQ2FHeFo5NXVSNjJKMUYyQVpBSGJDQzJuVGpkV3VuV1ZsTG9tdU4wbjc1c0VLdkdCcW9Uc3VLOVNWVnpwNmpYTUlodXVHVVIwQlhreVNiK1dYNWNFS0pGY1NWNE5rczMxQW81NE8yUUZDUm5yYVBsQUhNemhxYTVaZjhWTVo3WWhxUzZEYkkzQkVPSVVHZ0cwVkZxWktJUHpLQld3SUtPOWpOUjZFOE1jRUhsWi9UaklqVW5YZ1p2UFBhUmk4SG5FVnMweGs3UTZISmhDeWFQcXBjYUo4RlZZL1NOTVRkWXJqMmdLTjhmbTFRZmM4WE9IcWEvV1VLT2J6SUV5em9EOFFxeXYwUDF4K0pOVDBIN0sxdytqS2hlbmVkYXRvY3lhZkhVK3ltZVRKeUU3S0l6LzRKdDZ1VUxta0MwSTNNS1VROUw0bTd4ZERNMU1TSDVkVFZiaVVUbXFmbnpKZXNYZ2RhNVA1Wm9XcFNXZU4za1N3c3lGY3VVOGFWc0t2UzhjUlF3Z1VWeWVTclR5aHNwdndJWEwxUUxLOXRsWndYWVFmNStva1JOQ3ptTkZrQll2NU1YalJtN2hvOUdPRVJENVo5Qi9QOE8yWXpXVnJBV3FQVWFaL1hUd0dVdTBOTHN1VGkvdzNNWTBBZHJ2RmJOSFhFWUNmaFVQZm96SlFwcXp2TUsvc3JyN3dheW9rUVZwcHhMWngzQ3dnOENIUFVNS2N1ZTF5YVV5SjJ5N2tyeTNLeXQ1OFNxeEp4dDhlYTRuVitoMHlVK0pXM0FVeHdOUE84NlB2N1hYWk1nMmVFT1dqeHljQkRSSzJhV2w1QzBSS0NCcDRkOTdNZlZUK0RoTGJhYnhTRkpmRmtBa0lNUG1ZdGZOQXc1OVpWamM2SThrS2ZQL0FuUlRNZDQ1TllZeEQ3SlJiVk5NM3JHZENXWURnYUtFVGtUMkRwM2ZRNUdlRm1sVStwa0VMK21YbkMyVlNXMExGZStBWUVxOEw2U0Z4SndSOFdVUXkvL2NyS2laYnBBdVc4TGRRaVdBNnBYNFg1M3prcXI4MEtQdGh2ckNqamF6eUdCd1FzVDZlWHAzMzR4UFJsSVN2dGdxb3pHNFlVckRQVzlhb1BIZGN2Qjl6QlNBdTF6NkxjaTEzUE5DOWhBVnpDMlhFQWwrOWEzKzZnMHBxZGIzRXF3TE55enA1d3ZwUGFaZ1BSZzNKWFBOelJ1UnFhYXplOVo4VHlOSGN2Nm40Y1NVU0ZuZnVqdS9WN0tlUGt0bS85L3g3SU1TWHNVREtSbi9sNlpXTG1ZclpKN25vd0ZZT3FWb0Z2d3JvRmQzdEkxcjhhWHFKMlBONk9vM0hwcXpiUkR1d29VZDJPcUsvQnFuQTR6ZWlnV1VwVlYvOFhtSnB5RDZQT1VHR3JxczhyRTVVM0NxVHBTQmpLQzBOS2NYRlBrNW9JekE1N21NY2FKZk0wdzNDOFVkVU9pb1VCWHRpR1kwUEZYSm5NTEsrbHozcFdSZEdwNURzY2M1UWYzOTVVNTVWcDR0TEd3RXd5MFMycEVseDVjQm5pVDQ3cVdzRi9FWXdIZGl6enZUdWtsY1ppSm95Z3RKY3ZBZGZjaTRYVmJYYzVBamtOZzh1Ukc2a3loem5pMStPbjllMEdCV3V0NWdSZHVZNC96SnhuUXh6VFpLNFp0YjJYcWJhMitTVjgrMStyc0V4Yno0MStONHJsek11TjJTekZFT3YvOS8rTi9RTFZZMGxFZ0JzaU5WNm5TOEF3ZUwzb3BReWg0OTlPVkx5UEZlTnZmSUVzZGFxU0h5WllpaGVoaEdRUWJkeU5JY2lmZkx4c1dtUk45TjVIWC9aa3pzUGZ6TW0vdUtVcW9nZTBDVzBzUzVxYnBYNUg0NTdsMlFySXB1UFlYQkl4RzlucVlUYWFRaXljSmlnZWZQU01IbGZsY1dYUUwzTFBpQ3VReEhCZksySEovVmxZdHI0Y2J5dUcySStYTnlKWlp4TEZvbVhIcVNtSFA0eTNQNVdsZXp4empWNVNieXYvR2s2Y053eTlNVWhzNGdSZ3d1UEZMNlIycnNTalZHNGlvd0pNMlpTcDJwK3U1WEtOSFZaeUdzQ1RsOHJnZUhhRE9TeVZZa04xTnZ5M05NdGE3aVpZd09FUTVpZW4wZXZVb3diYW9sQzUwU2hsMVFUOFR1R2NxK2dDc3o0Um9LeWhBbGgvRE54UDIrTy9oZzNNTHdhb05Za1l3TFREWElRNTJXWmNXVVFUREZoVmdtTWZLV2ttNGxRb2xNWmtmcXBCcmxUVm9meXFVNlA2ckpaNEF2ZlZHc2plS0JMQStOVko3Sk83TklzY0FUSnNFaCtQaUVlaHZncVlseURMMzZYRjhwMCtiSC9zaDAzSForK1ltUjgrUGtJNkwzN0xQSXplOW1GN1BDeU5KdkpLTWJzR2FpblBaWTlsRE9VV2VxRzVmL1VXN09oRlgzMmFIaFV0NWtpU2Z3WXc3V1kwQmtvSmF3dHN3bk1VcE00UjN3dzA5U205Vi83S2M5am9jOUh5MXFsVDRQRjVRUWlNWVkweHc4blNWSlE3bno3V3lwa0gxVTk3R0U3S1Bva3FhNHFLQXNvamxvSjhEUlJRUjR0Qm1GbWFUUU1VaE83cHloNGt3c2VQUWM4cUFHbGNQVWZ3cDdrMWd4VlhOTFVtNUZnMDJRQnJCMG9ZS0ZlTjFWdnMyRjNUNytYU285ejZPWEhEWmRTRldwYjRMa2dkTWN5UWZueXZRWFV2bWQwa2t0YUVLeDhjYVlYaUkzaFZ2NWxLbmE5SFk4b1RCcDhMWGY4ck1wWW4vSnJ5MllyZ1R3dmRwL1Z2d3lMZlJrZDh3bk5lUU5wWXJBOVJoSVJlQmtNS3REZVlSRVhrNFF6akxrN0NmTmVmcW1xSjNFM3ZjbGxjUkFVY0hQZXlEK1d2clJTenc4cGZHU2xtbUdyaWtOR1YyNHhGZEE2blhCYitmQzBxUUdCbXBBOEl5NTI1cCtMenF3WTVhaTRrVDFVM2ozRzE3aXlSTXFqMjdIN3kzRzR6VnhXbU5MbDFnOFNnSlhPVitoNjhRc2hNQUpnYkdNb3hRUGRSUmxVZjd0eEZ1QWVCT2tUZTQyZVc0bDNtcjRqNjdKblp6LzcwSTBWOVJMQmlRT054bHRVZktHeGRjalBPNkswWW5TdkZCaHBKZ21nd0RKRk00TWZIcUYyU3RpT1k4d0psWlJkU240Mms1TXFGM0plbTBWc1hXbllMSUlZK25VaUFPb0lUelRoS0tDN1lRbUV2N2E4eG92amU5OWZmR2txN3hTZ3NXWlJ2NGlaQWN5bk9BbVRtbUdkTStBTitYZUt5cGM4azRmNldYK3BLbElTNHJab3JnVGtOd2ZNbkJwdW8rb2plRGtHWk5pR3VkSnI0WnFpNG1EaE5hU3lob2dNVDlwZ3JMS3ROdTRvd0VQKzB1ZXNqZ0xUanc5Y25uK1NaQWFKTXpoOGUvZ25rWXJRcjQvRmlHMXhqaytoUko0VjFvZmtrdVl0Zy93KzFJUUNQRExKeUxmMFJLTEFRQ1dVaERIaUM5SWFCWkxpY2o5V2R6SDZCVEg5Wkt4N0F4VFpQOXI3QUpEL0wxcDlNbElUM3hxZWFqL0hqY01CbFhxZExSbHh0ZG44WDlqd29UeEQ3c3FGdmo2TDZWUHpQaXpxbm52QjMyTEs0VVhHZTFWZEJEVGF0TkFDbkJsc2R3SDV3REpMZy9ueEpIaHh1M2d5d3d0aEZMcFVITTFydDJPWjFsV1B0UDhTK241UVVqbitldXRaRG9qajFQMjdnNUdDbjgwQ3E3VXJXd1BTd2pFWGFyUmxCZEVPS0hHS3NxZm9hb3JvY05KUWxuelVmdXltSnVVYmZROXhYb1BWdk1KN2FqNnJtRFArMmMzeXRNU3ZmRitVc3JKODhna1MzTlF0TnlIOTYwTzUrdFB4Y1RFUjFHOG1XaktDeklxb0N1eHNHcnBweU9pY2xCQmRLU0FzNG9yZGUwUHhzUjVraWh4ckc3aXl3WHBQczRNQTNEWTl0OFhoa05BSnljV0NnSkNTVWdzSHFIYWdMWGJ3WG1SdkxWQm5Pc29IUWxBNFdZUGErUDBhY0p6YVpLOVQrSVpEdGRSWDFhMnJ5b0lpbm1XR3g1TVYxTjRETkNVK0NwcS9GSDZNa0ZnQU1pQURMTUpBcVNHUmZVZ3VwQjEydmVYRmd4bkRJYUZ6TlZrVkkwelg3Y0hOdzZ6NVF3a2hzQS9vWVcrZFNyY080NjVYcFhPNjZ5UzRTeENwUWxUdXVqRm9YYVo4VDZZYTRiUC9kZFVLVXJaUk1ycS9MbkhYSlA2dGxncitMdkN2QXhpRUdNTHNhS3VUVTY0WUdLV1IrcEhZSTNGbVo3TU52Qm9WVWdpemU2YlNjOGlkOE9Wb2YzMVZBUTQvZnM4UHBzb1g1MkJ2NUl3RktXVFptNHdTVnVTVi81cFh2MkFxam1YNkdNSUIxaXo0RlliekxlbElCR1NUZHdUYnJXOSthbmtxdktDbGl4TlFZdlMvMkVCWlhQeTFlOUtiRWdqU1VqWEpGRG5lOVd3cEx0WmtNdzdWdTFBNVJGd1VxNGJvdUtCaVNYaTV4dzdzU0dZVnRHSE9IZ045R3dwZUwrWnZqa3pKNWZ3cnNxZkYzQTF3aDBYelRha1c3V2d1a3AyV2RKSjQzZkxxRnRBc2N6V3VKMTB3TG1Nb25OWXliTnBpT1pKVW5zbXBZeTdCWnpUbzNaVG5VNlRVa0V4QWNibFJQd05KZ0xxN0NmOEN5WVMzQ3ltczdybCsrSUdzdzhjbmpyaS9WSDZaUVExRlc3bDJWbUEyU2h0ZHRQTVlucGtZL3Nqckx6bWZncUhEQmZ2Q2dlajhaRHBtY1I0T3g1UXQ1VVg5bGh1WUxUNkJUem51RmVNWTRVdDIrSGR1ZjVtekovMFZtcHZPZkpIbDJtZzFVL3R6ZkZZR3hlZjJrY1g2bldhRlV6aFY4SnBVSlEvV1pTWFBNV1dwUFpGV3FBWWhETHBmWmFhTnpRR0FGOUcxT1FUTGRtY0tVMlJPazBETUJEYTBwUUIxcFNXRHZFOFROSWdyWGhzRjVEdWpueXRHUTRXL1ZISEVEUGJkdFZtRzNDR1p3NzNpenc2SWRsek56UzFTWTZzZkVRWDM5QkhFWEpiYnN1VHV5L0luYnhhVnZGNkppN3h1RGZoeFdadWJjWTVRdVBQMUhNTERwT29rclc4YzN4WllzdGQyclQ0TXdlTk9YY1BrM2hOdlZXam1wRDJMV1owT0hUamFWNUp4NEFZMERpQW5TV2MzYmZxTTlDSWNubVBCVGx5SUxPYklUMDlVMlRBR3BiNHVrU0xzWlR1U0lVWGdLVkM3WVEzUlBTYk9UN05VNXFIVW9OWE1reTluMnhQeEt1SjlVMW51cEZrcWhFT1lxa1RtOHdJY0tLUHlwR0pSTzFIcy8wd005OUx0ait4aHBJcXRzU21oUEYrZW5adWRLOFlheVZnT29KUG9hVVQzZGZ5V2RxMUJjcW1hanVlenZTelFYVEhrbFNJUFN1eHZqUDk4NVRJTmFXTDhkam1helYvL053S2RKRHA4YzdiTUp1S215Rit6U2pJZ2RKR04vaWVGRjRRZkt5YkZacE5wY2N3TkE5MTB0ZnFJNmpOK1JzSS9ub3lFSjcxL3h1RkpEVkRHNXUzb0Fod3IwbFhBNnpWWW5FTzRuZXhKR1RPQU9TUTEybGZFWnFIbDd0V3dZVkRoZzdhOGUwYjhqdEs4cXl2SGZXRDlVTXhXdE85bkxKUjh1K015R1NLSHRkWkpjZlBGU1Frc0ZvSDJZdzBtTURaakMrTkp0bVlINEllTU90Z0NmaWVBaUpnbVNTdEkwTVJWa3g5V1J0S3NhNkIrcGtTWXpHd1lPMUhkSUxoeVhlWjIySXEyeGJQTWFMRDhTQUZYV21sQUxMQ09jR20wUGsyd0FDQ1kyNkRHSmlCbXZ3VU1Lek5pamlibzdhdDZsTk9kSFFpK05VVGdVcnNmRk9lQVo3NU9scFZtYXlDenU4ckUyMmFuK3JIajRuL1MvOTJETDBpYW1jVmV3elBpZ1M3MGwxTnpWNjZZU1NJYyt3Zjc4ZEJXVzJYTEtVQ1NBeURUYmgxUkZ1T0FucXBaS0FMS1BUZmxQSjVVREtocE1MNUdFMUN5QkIwYmI0MmhvdHQ5K1Z4K3VVaWdEYVFOdkcwTHRVQnJ2ZG9LTWloSmxBYlcvc3VYOGRLRldWVFl6NmdNa0lYVmVJZW9zSk5ybVRDekViaXZNcXRVTzU2eW9tV1VGY3BBdGpTaWJWQk11ZGgrMWpNOXZDQ0hWOVU3U21kV1pZVSs4cHROVGs1Vnk1a2NGMUpKOWVWS1pIejVYZ2Mwc3B2UmZnR0ZLYmVNcEpmNEdpdmFuZHI4WEFMNUtKa2thcnNCY0VBNEVqMEQyblJna1dDa25Vd1hRR1R4UllaNE8zdk1tY0g0c0x5WjRGZXVRR3p1YVF5MG1FTGpIc3MraEZIU2JxYXFOS01ERU14d2t6MHVkUVRxa2tXTWYzRUV1TmpxR1V3cmJKS1BkUXNmWElzemxOWWl4WGQ1WGRnWmluSFc5dUdoOEc0U2d5WklZTTdRNzRpVktORlZjd2JkWVY0TC9kUE55dzNhejVvMnBzMDJkWEUwVWlzallYRmFHdFowUk94Y0pHNEEvYzgwTUpGVktVeU9vMnFrTFIxTUhUcGdpSGx5b25heUUvOVFWcVJ3aVdxS3NsaXk3TE80dUVyT3Fxd1RWc1g5K1EzaWw0TGdIaXUrZ2ZEQW9PT3FRQUVYd3dzMnpldmxxUVhOY2dUQkh6UWZ4bmN6K0V0ZGY3WVVWOXVrdTExMVpXRnY0ZFhVZmY4WE5INndjS240bm1SbHFpMWpkMm5QdTdXakdrRmFqdk9Db2RSUzNLS1dQVVNMUXZDRkI5WDV2bEY4L2ZPTkx3ZnVZY3VLV3FIRXIreUlMVWczaXVMc3Eyd25IQVhZMUVRWkc1ZVYyR3pHVXdzWFQyR1hZSXJyL1Z1aFd4OUo3UXlHOGIwMm0vSUpBWWIvU2k2STg4Uk04c1k5VUJzb0w0VVdGT1ZCeWk1b2x6cmVwLzNjZkZYNUUvZmNoNC8wSWRWaDZuQ0hHay9mQ3BPQnZMVUVOa1ZNQWdWSDBOQTRvd0JMSjNuVXdqdUtDTmZJZlJYVmFXRmd4RWZkVUZ4QnMwRFVaOUYvRFp4QzRUVzQrSytndDZSR1plUnh1RWxrd1R3YnlvaFJHd2k5QzRIQUVnMnR5Mm1qc20zY3E3ZkI0MEd2SGNVbXZYa24wQ3JWWjk4ckNtRldmaHp5MXpqWXZQditHZGZOSmFQb2tjdnUxaFZ6bnRKOWtiMVJqWWhFZEI5dnFCanYyQ2RjTVFtVmxQSForTms5WXAwcys0Q2FNVG55dTZpUkRienRiN1IyWitVSkhaVXpiNWFTdC9Ma2NRQjh6ODNLek5SVU1IOTVWZ3hSYitVb1RXYWhTajdpb1M5NUNCRTBZUGlkVk84ckloSFZKUWI4VEtIdmhKQWl1UVl1Yjh0RmcvUzFHZTlPL0theEdaMStjQkxyeUg4NEpCSEdmSXFnOXdySU5NQjhYRjZiZDU3K09lRG8zeTYwR3dlLzhEbWVycmpXcFhlTk5QU2hrZHhFbnBCVGUycFV1SVNkeWJidjhnMExqM1U2WWFFbjhoR2Z6dmpjRzJOaUxBQm96MjhtZ0grQ0U3cU1HandVWDVLcWxvb21BV2Z5MFV1aHN0WXVzbXVYWkM5dVhJNm9YL1NwZzh6U2dJQXVlRlVmNXNwbnJLTzR5eFplQ2NJdnNhaXQ0anlkWVdHaU0yUmtWZk1NZkFQVXpjbno0bHdQbUo2eEJaalkzQkVhcjRTQ3hTdHA0bkNGLytnWFU0bzh6SkVJSHJPcDNXbmNDNTJ1dkI0REFjVlhpbVFYQ2k2bTlJVzU2OXArdFcvamY1YVdYY3M0dDhXcTVWcGtKMDZRQzZQTGRwUyt5RmN0WkV4RU1GK0tzdDRkQmVuOWZnOElSWEVSRDNRWjVheGw1WDI2YTIxNkdSQmY2bFFwMHU2WjhuMXVWUjdDRDZmQnJLRVlWWGRtUXNnSldNQ213MTUwQUYraG1TdXBDT1JGcjBvVHEwRGk4eFppaFNRdXg3d05ZMWxDczVacmpwTUVvLy9MQUtiUlZveVFRcXdmVldQZWpDYjVjdGRleFRFMzNUay9kWG94a2ZreWxmSXk1ZUZnbE5idVd4TzdsNW82ZzM2NVJSbEdyZ3dwOGU2bklVQUhtaUJwZUQvZlBBUFNnK3pCLzBnSTVseVI0dzl0S2pDd3lJWTFJTzd5NGxiRjUwVWtMNzJCK2M5TFlZL3AxNWF6RnpQczMzYmJNbnpEWmk1cG5uUEY5VCtzcmVRSThpVVU0Ym9IYUhJak00VS9KU3NQNS9GTzhhdndHemIxQ3IvV0p6TWk0R3RvQ3RkVXdZZUkvR1JkbTJFcmliOVBaWjVIYm8zRitWaEFleGJ3ZFVBUzJOZGpqQ2lPSzBpdmNoT3Z5eWNITWpsVC9JZnlHdytWNytLUXVOU0xWSUlyMkRwVGhMM2lmR0daQWZJMFNWNUtqYy80UmRUakJlbFdnNGN2U0N0TjlHaUtrZFZ0REFRamYzMnBPVjJZT3BxNk1hYXRoVTY3VUIrakNKUkpHVVRUa2NvNnNFRlF2UkdFcGJoTHZRTktKVWxzaFo3cWhYdHJRaXhGVjFDT3ArbTd4d1lpME1SeUpMZllPS2FsNVJnb0VrVlh4a2hrVUN3blJmd1hnaCtQRzk5a0hnbG1Ubks1c05ZTzB3ZlhzeWt1bEVqVXJUSVBDZ2doRklYRTBOUHh5NjgzQW1yV1E2cnFQQUdHMkZVdlZCZWw0WERyV0NCQU1vVkI4MC9KRlVuMUxnZFk5Njk3Z3M4TCs5YThEdld6VnB6R2Rtbm1WV1F6Z0RycVBqZ2E4RUcwblhaZXlZWnM5WE1PTVNNOHV3SnJtanA3b3ZnazMzL3c4S0dRWGt3U21yVGtFdnhwS0I0QmFqM2dQaG5vMWlWcUU1YlB6QVVCT1EvWVBCejRneEE3d3ZjV0tQZjJHemNoSEFYbW94ZUhSRi9VVXdoaHRtayswb3VqNkFXaTVlWVgzMEZxeFBYTFJwbWpQaEpTcDJvbVlWUDNnUEhHbDJLY0htSGlnOEx2QXo4RmcwN2ZGNkE5aXpTcGpvNWNJb3pNaGZBOWFLMExGMHNxbXFlWjNDeTJMZlNpVWg4UEtnWWZtQlhXK2lHeE1KQjJzbEU4T2tvWnVsalZUY3hydWJVQ1FWM2lzblpCbjU2NGxkSDh2NVg0ZFpHWmlHalJpVURGMm5lNHJuL0FPVys0aHFUNXQ5T080MHFDckdTZ296QnAyVkJYcHNMN29la2JodjhSSUFVTG1YRksxc1pkTmdTTmZhT1dkVVJjeE43SlQ0emNGd1BOZ2g2YzU2OHVDaGNVN2d4VVRzV2ZLaG9pWkd1K0ZMVW9zOHRmTnRKMC9QUTZ6cXZWNHVQcjhaLzlIWThPck5GeWxiT3ZmbzE3eFhDUFJZQVhscnFCTk9jRmpJd1hMTGN1bWcwcUJSYWFCOWVKRWx4RHFjdjJmb3dyTCtDdjVHOTVwYlZ1RU9lTGtINUZkSVh4Wm1sS2N1Qk9kRFB3c1ErVlJkK0NhVVRCOS9LaGdqUVJUSHNrL1VQNGNpZ2lEQnJyQTAxeGN0RTJoUjZjNzV5d0t3aTNjV210elpjS1JwT1RBYmZVT05hdkxFRS82bVNnQkg4dTE3NmVXcDdMVGYrcC9PVG5OSllNN0xMb254Q3JkWndwQ2lkdDdPckM2eVhTT0UwL3Q2Wk1sMnpGTUxEdTlqMVFDWUR5UVRUT0wxa29uWlRLK1M1MnNzNlhiRFBpVStBWXJJMURrczgxVyttSVFlVEpaNGFBdmtneDBFeWcwTkZZUHYvL0ovMkY0WTVHeUpIdDgvbFpaZ0tHVFpOMEVGd1hBR1pBbzVDWUp5TDErZUtpYXpHWEI1SlpIS0NxbTN0NHpkbjNYUHliOWdvQzh6YkN3bkt3OE1yU1dHTEx1eWs4NXZGeTdvME5LTkVrdS9PNFRUU2k3dWl4dnhYeCthYzBuWFBzSFV3TEVyR05WdzI2ZGZyOUlRa2Z3ejlCb24rdVIzbzYwcWhJS2V5M1BEaXM2eWlETGx4QnoyY0NyTWdiZTZoTTRIV3B5QmRvT2VlMkY1QXFveGI3OHB6QzJ3UDJPeUlPN05VV3RRS244T05wK0QxZDNSb2FBNUIrWmF4TUNMVVFoakNNNWNjUE9GdkRjM2NtTVJ6WnBYMWJrNmViWWRhR1ZSdUI2QW9GYWZHbk1KREpiU2FXdDJCOWhVZzF2V3pLNXBIeFIwdGlQUElyWk5iREQ1ZHh2UHJnQzhFb3B6ZVRsaXF3KzRDUHkvNTVXWnk5YlU2REhCSzRQUkJFQmZqWWtjemZ5Mjg3N2lubWhTcElndnROekllZytzWHpyVE45eThkdlBMMy95UFV5YngzbWRjbG5PL0J6RHo5N3BEN1ZUay9nVUlnM1FHdUFSUUxBUk5HWTZ3RDZKL0xjb3FNRUN4dEo3VnA4bGtvbkwzUk5aclRPbXozQ09ISVdDMTYvdmI4cFpWVVhtZldQaFZuYlNRb3ZyYkR4REw4eFcyYUYvWnlEelpjWDlvUGQwL1Q2Wm1ZK0xJNVZHc2F4REU4OVUyclJYZ2VYTjBNbHpiY1A4dEhwakEvYUFkZk9iQ1VsYThPay8zTGROYUJmS3FxWXdKVEhCU0V1ZXlYanRWMXhmOU00TXVkcU9ZWVZ5dy8wSlhmbHRoYVN3SjdRRkNVNFdDK3lwZGhqQ3ZneFNUTzJPb3FaYVU2dXV6SXI0dGN2TlpwVjJxK3Njc0phRmFpOWczbHpFcDMyZ3IvWmpLR0dxd2dkUzA4b1FKV2lSNEROODlMVFRxQVpJS3B2bWNBaXMydTBweW15WkY4ZEM2c3gzcWptOElFSGVaNHlKRGQxUlpEdnNGOTU3cnhUQUxqdWc4bjBvSWkyeHJNbDhHc3JnMFdKZnluVy8vM3RaK0pOOTk2d1I3L0tIRmVCZnBJRnRjYjRBUkJreURIRlJtQXpJendUem1JQVcxeGtjUDZTTmloTURXb2J5ZS9YaU9oSnEwYU5qR3dCYVh4WGpnZTJOS3BWUXYxZkIvbXp4MS9Sbzg5SDk0Mnc4WFVLakc3QUl1UzRteklvMnVxL0JhMjdrT2V5TU13clJFNXZlZUVWU2hNM0QrZ1RhSGtBLzRDYU5WYnFXRW9KMlZ1anVXZmpDOE9RTzYzamRrSEJXM1JZMStNb3dtSFd5ZUtQbWJSR200dlFyc0kxZWRrNFZib1hFbFAzdTVsdDNDeHBCaGpVcGltajA1VHI2bVY5ZFJmaFNTVlFBbkVHeEhKSSs0UmZDd3lVM2dSY1ZTUU52UFRnN0VsdjBIWHp0MXV5ZHlETWZlSjJaVXJZNEo5NGsrd0xjTldsaTFIMlBkSS96UmVCRXBaWWJObFVPd3plTWozNTdNYjE0M0R0L2llNml6SHh1WVlSQmFFV3hRWi9QVVVXcWZ5MGxpK3N6dWVQSE8ra1RWNlM1Q3RnS3k4Q0MyZFBxNFlxSXoxZkppVjBEaW03VU9rRTRodGtGNW5qZ05JZ3FwMXJLZThKUk13WUxpSWxmTzQvUnJERldOOVRYNzVWcmNmMEZVUXhhRjJWRkNxYmRESEtQZFZaSDJNL2J1V1d3dkVtZG9OQUQ2enMxMlVlSkNYdUY2TnBYb1FDbmdSWUdVUjNtMmc3eHgrNVhYcG5oWStWb1ZwU3ZhWTdSZnNKRE9Eb1c0VXdxdUI0UmdnV2RXeUdjSUh3cDJnWnVER0dBK0hUcG5vYW9uL2hWRGNOTDI5YjFqajhNbG4yWjRtcmtpNWxYa0tFdUgwM2Qyc0REampJV3o3Nm5LV0R6d1lPeWpyYTFFdDVScXkzNFBLR1pGU2NlcHlxWjZ2YlhtbGRTUUFJWWlhUGh5N1NRbEpNb1hlT1Y0WUpQdFRjdkVjM1d0UzE5T21XWXg3L0kyQmYvREtLYXZlSTU2N3VFZC9hY1BiTGhwMnNxRVBmQTNPVXBnZnlibUViaUw1alJmNkd2dnJ2S3M2OGIvNTduVGppK3dIcWt3eVRaaEJuRnp5WTgwZGpvMk14RFFIZWtVNFcwMzFBc1VUK1Q1TzkyZks0VVp5ajBIWkFONHhNWFBDS2lDcW9rOGtPZnNDM293YlIzTi9wMkZrQ2x4cGdIQUZwQXlXbDBFd1FoT043N3d3enF6NDlNUXZ5cGx5aVhXeVNKUlQrVUE5dUpEekR2blFUdlpzUEEyUW5hWGVIdktLU3JXRkNnVHVZcXdNWUJObEJrL1pIRmxyL2ZnaUVmMzdObmZSZGxBWVQyanZpbGxZU2tZenhnU2NFVExwc1pxbTVrMDIrbHZDRFdqVnd4cy9keTRuUEU1NTRZK3kva0pTNW9yMmM5cnJCN2lna2cyWlF6RGY0MkZld1d1aWtLTk56aDYzMGE0eWJrclZ0M240MmpRK3l5VDFERmlrK0NUaGpWMWVEc05mK1BJcUVaQ2hDM1U2THhSd21TNkVaS1ViLzFZaS9wU1Avc1NxdmpiZkcydXZ2N21FY3Y1cVJodVBnNzR1VlNUNDBwYnVZbFphNG1ORGtURU0vblpXcThiQmhWejY3ekpXcjAzYVRja3h3TXFpTkc4QmorTzhuZ1FWUE11bkpWZnFPREEzd2VXUnN5dUkrN05RM2RGOVJJd2FWODVSdTRaekNrMVg1OW1DeG9lU2NxSnBuSjhraXR0TnIyZmg1SndNVmxIbWdzZXZRTHcvdUpXSURrdGExVFExOVZzbCtPZ2tOdFZrR2VPamJIb0dpQXU1RGNRa0Ewc3J3a09JTGNNcW9ITktvQWY4QzFiMnNFM1NXVTZoeTNpWHlrcVdyeXdBTDBKUkRITFBOR2dFamlPVmpiZzhVYzR5b1p6WGx5Rm5DY3BOWVhsVCtJcjl5NVZvQzNMbUlIK0NyOTRSRThOSUtNaDNJTEZBWVFHMUlPdzlTMlJidGlJbmU5dW1mVEJHNHF5bkp3TG1Sb3BjQll2SGRJaEpqd0s3cW9SVkFtM0tzQ2hPTEc5UGttZDhLNHJ4MEZkbWFYSXIrek1ncVg5bDhyZitCZjJmRjhVbFR2KzlDbndFMUs4U0IyZHpXMWsrWjdJN2gyc3oraG1KUHczcTkzTXYzbHBRRjI2Q2JOZkVQL3pULzB6TkpHelI3OW84dndIc0RHTkVINzdrNlg1UzdLRW9GWnRML0x5aERodkFTQlFjUXBRZ0JHRjJ3TnVoQkQ4bDJTSkpJaHh2eGxjdlFDc2hKMTY0T3BjNUIzTUhGZTdGaTh0TWZhQU9pOFd6RzVxVVNtbFJ0aHhBM3pXVERSbXZTYU1zV005anRvUUhXd3hhRUJlWWdjQUdDMzFIZW5QQjFpWG9URUhGNFlWcDhDb2xFdzJWT0p6STBKaWppSUFqaFZZVmZPTVo4VHZKQzVlVXJrdmxFelE5amM4ZnMwcXM1bklNM0E3cWFienI2cE9maDh1aE5qQlpibzBhMWFnOXh1V0UxTitFTFZPV2orTFF3dm1uczV1Mjg5LzJZYmN3K3c5YVNscVN2bExaTWlMcFBwdTVvQXhneFJLelJieHZKS1ZtMG55dXdKZG8vblRreDZKbUkvV0cwaTlrenU2RFp6MzNUeXhRWHhwOHVtTTVsZlQ3STBXcVNsOVgwK0tpbGtGb3RBem1BRGJmRHJxTDZBVEVwVmNMNWZPQ2xFOHVGajB5R1pMcVZ5US9FUGZhZmxDUi8zeFZ2MXRIZWw3eDVwVExNUERqa2F2R0xqRFg0Y1JnUkJIM1hxWVhjeW5zeDM1V2dyTms5TG5paFVtMW9YTXBxczBwWWFLakEveUFVZ2FORHJiRzZlNnlWbHRNNDZKNEttaHBWVlE2Mk11ejcxRHdnUzdmbStINEN5b0drUjZsRnprZ21KUzMxWWtsRFl2a1ZsbEFJR0lrTnJKOGtGcVhkYjQ4QTk0Q2JJZXBycEgzbi9pN250STE2RzFKUEhwTGR5UmEyQWlzbVdGZWdxLzhhSURFa2k4dVhoVGpRbVJvUXZsNytPcVQ5TlZjK1A4WHB3aTRJVVhSbFVKM1RZdUtmSzBDOHpOMHVaYjVlaW5IWlA4NlhJaUJPTnBOczBnc0pNSGprdUhkQXo4TzZYR2d2TjZMbDZFYTdHbkFaVDhzaGQrWXBaT2FxQzRMYjkwcFNzNUZqQmhJMlNqaktObWliSmdwUmtVMkxZRkNSMHN2UUJTTHNBS1dJYWN6K2JEbDdLeFp4cHdmSy9Ma3U1SmR6K0cvQi85anp0R3hJSGJUZEQyNlowWmJpN0t5SG5vRkNWZ29NQkFva2FIT216T0puSUxDc1RBOCtzYVdGMnU0d01EQnV1UVNZRitUbHg5N1VWYTlKSGgyblMrT2lITUJ3eTZzUkdCU2tRZFZtc3ZFVVY4em9WejhCcmsrOGIrTnpnRGJPbEZYVDMwWFMzdUwwa0pabDZBOFJxeGlLZVl5SE5hQmFGQkpCcW9pZ2Jzc3FPUDVWdUNVeFhVRStCbnhaQ0RwMHNVR2lrTnc2OGZ1bXdVV0srTE9UekhPbzZ3aG5xN1Q1Snh0amNWeFF2SVZVYkxZTXkxc0FuWEprVENUcGpsOXNLclZZcGdRT0JtSllJZExDVjc0NGV4eWlRWVN1ckduT1FsMHQ1V0ZIQ243eVdQT0IxNXkyMFUyNTk5bFV6c2pWeURJMUVYZDlIZDE4M2t5bHBHKzlscTF2MWE4UDJkbnc4VFNDclZBQ045MkRtRjBrM0JGS0l0VWtVaXd4cElKdWQzeVI0L0JjU2ZjUERNMFQvUXRjaExIc2l1VC9GdnFZSmxNcXZIR2NqdjJiUDgwbGI2eThyOU9SN0xVcllIcGVyeVlsV1RJcFFtVUhKanB4Y20yUEd5a3FCN1ZueExSSS9LTXF5RldaTmlhY0VjVE9VOCtXR0VQbnZKOUhiOWVKZzhXWjg4ZEUycEtZZG03Tk1PcnNHQ0I5TmRiaW9JNW5DQ2tvOTZ0RUdYbkJRVHFuOVphRS9sYlAxbHZFcjJIeWdFY2MxekswTlpNMXNmbzJuN210ekE4TGhQN0JzcytRMnVXbDR5dHoydjBYem1tOFVaNld4TEhNYjJvcFBjYjZjMUVtY3RFbWRKU0RMOTZnUmZhZklYcnMyMnB2SlNFZnppUEUwa1ZMR3BuNGtOU0hVRDNTeW5kQk5LeHNUc1ZtMFAxZ2VuOGZ5bzZLc1ovTkhWM1A4aWV6cWEzMDRLU1JpZVJMREtKR2NLb3hpOEFyQnQ0bThVSHNUWWJNSjVnRXpONXk5WUVIN1pwVUpZWExxSUxnSU4vSEllYjVud0QzY0RBM01YZHAxNzdMZjM4eHlDWDBUT2Y0alJtOERoTkZsZ29PSmtpK2RkcDZ2TGc2bW0xeHZuNzNkTFVCR0xCOHJhQWRZbDRWNDErbFdBRDB5eXcxOFJ5TnYxVll1eGY5UDgwTVBOWlgrUEZYajFxOUdIdHgvd1pROGZJWDUrYjl3ZElYeFg3SUx6elNuT2ZLYWtYamE0YlpXSFZxcFp1UlpPTW1Nem9YLzBWQXM3c3ozT3EzVlhsc2ViRzRqWnQvOHF1dkVLRDI3TkZSZUV6aHJOOWpqUGdiRUp2YkdJWlErR0JxeWNKVjlBekdWbzlkZElQNUFLY20yQkxrNlVDbTk3a05VOXlocVQwQ01nTlBMZ1VjeE1rRFdDK2pWT0s2QkhzZW5Ld1crUXFOK1o0RmRPVEswbnJlbG80MVowUmRDYlNiUTJEcHRqTjY2TGtWWTR6cGh2bGh5ek5VaVFCRkltSkRXT0hhU3FRanFHaG8rbXFlclFVTG5aMTRrcGpHNWpYdll6bXlTZDRjRWw1QU1wWFVoUXFZNkl4eUhxRDZHT281SWZCWmRsNHZpRDBETnV5Y1BvT2p5U2g3OHZMKzB3Nkg1UEJvMUNWK0RRbm5aV043U1p0WkNtNDRVTTVsVldlRkRMTGoxU25JaWNCRFF3STJnQlZ1V3N5Q0RtUjJka0NNY3Y5R3d5ak1YOEZZU1pNTnpRUW5ERTBoNkdGa3BSZHJYTFQ0WE1kNnhJL3V3QmFCOUFzY1N1a1NNVk9zZmNRNUI0dGpQNGQyTHlsaUM5VDhkYjNyV3lOeDA2NDhGVmFHRGhmK1BMNUZhTzBCZFpzWWdJK3N1QmRwSitNK1VrdnV2VXhlRERwZjM2OThadlpOSWMwZjRuNUNFeTE2TzRUS1g0VGVtNjY4aXAxTWFGRjNVSGlXUTdmVHlHb3NGKzV5YzFYNnFZaURzN1NtUVNJZ0h4RFhZcjVYTUV2cXZBMllFODRpRjZTSHc3VWsxRndrTTkyeXhMaUtGUTRXYUtOa0w4NnhYTkZGQU8yQjJINlFqTjlkWUVMczVkKzZjS3pZZjUyR2R6aXlLV2lCNEJXQTB0ekVMNFhmSFhKdFVoZWZ6V1pGb3dFU2UyRElMZVhiQklKWjRTL29WaXlTSGZVc3pvbTZYOEN3aTZwZktmV2R0MVhGN0sycGdwczN2K0ZYMzdUKzVkeVBMNWV1Zk1PbXIrV1owZlJKR0xqUUMwQkNITG9HYmNMU2h5RjZvMG5rc2Z3dzRoZHl4R2pKMCtQWFBtQi9tc084N2F5cVk0L3NXcVQ0blRqV0RlMmhPaUFYZ2JPajFpdWdkMzNzYnZrYVVHUVRSM0NXS0N3U3lMTUticCt1S0wyZ3Nrb25TOFluVnk4TU5XcUxuODZnOE5LOG9kMVlWWFRuaW9kek1IM1haaW9NSjZualZ6Ty9VcU1TMEJOclIxMTFHK2EzNGxNdGV2MVNzWnU0Z21PSzErZ1JPYjVGWUIxbUZrUmFZRDhHeWhuMFdjVXBsT2UxempyaTlFQzg0RmNzVGcrQjgzTHprT2ovT2YzcFhlL2Q3azFWOEt4YjV4U1UvREtDSHRWL21RSkx0OEllVnV6UDZPdVJZQXY4Q1ladEVOVHlKVTVPQ0xKSFU2VXgrZ2dLMHBmWkZibkxKaWxBOU4wQ2pLT3djWkVXVXVqUFN6ZVFPK0dtY3RsNmIwb3loT1QyUDljVlVzQW1xQ1dnWWQ5N3pod2Z2eFFMbWJkOW1MNWZJM2xyeVNGdGhMV2dCNG9pZ1ZmRXRpUjJFOWVaektqOFNkZlJHbzlXNnhHWTgwY041TFZPYnNvS0JQSmlwaHdMNUxyWSt6S2hQUWRlQWQza25TZFMyYk0zQVJIT2xSMDhTZ3F5SjIwMk5jbUE5TXNwYklpemlTa2ovQjlCSEoza3FobytUcG96U1pwcDFISUo5RUd5UkVjRXNaYU9pWFEvaVpGN3pDbThVcFZaeDJSRXZET0UvL3hMSGhsSzhaN1VxcEQ3Njl3dzBrS0dNcmZhcldVdmdZTURZbXlEaUVSQnVjM0dPcWZTL05hZEJ0cHl0dy9JcElmeHVFQ0NRTlUvbEdnL3A2SWN1NTR3dXd2YW8xTGVXL3FIOVZOZVQxNjd5UHBzeW52MGZEV1F6TVNFQmJKcklIeU5WSEdkS1pJckFQcVo5T3NwZjg4bS80a0t5OG91RDlreEVUYmlVeHQwWTdsTlV6YlRiSy9rMDExcHNrY3RNRmtSaFpmOE54b1RrZy9nbjBXYjJ2cjIvN3o3ZXJlZmxlSGFQcE9QcmthcTZwenRvOHlhakZQNDMveHRweFBTRmxuSzJleXRJd0NKa0tiK0Rxbk44UllvbG9LY25GNGlOWDVkZ3g2cERHWDgyRzBiK2ZhUDhCbUVrRWI1aHp1NzhBZ0ZzcU5sRnpLRjBPMC9GalpSc0F4QkgzQ2N4SVpXSEM3SmhZV3ZXbExIU1JrNXhlUjUrUFVHeDVmeVIyVm5mY21XZVhTVlpJRVZUS1RhOUxSaW5rWnB6OE10T2NKSUhuVXNNbS9qaXd0SmIyTTFDNEdWeWpvYVJ5NXhMaE5jNXRJR3BETFBsZStadWZiY3FpaEpUMXVhV29jczFVMXBTRXlJRnhyeSswM1NZWUNlS3hOTnFzekNVbm5qSnluSzdOUVNzQXpEQXhxM0g0d0x2Znk1MEVxSHdSU1hXMi9MVGpqZll5VWgxSzVCaVlOa0xtbExPenBYMmVkY1VaSjZnRUw0UktHRXdoT0VyendKdEU5OXBCRGNqTXN1ZkpwSk53V3V4c2xkZXlBZ2sycVA4UnIzeW4vY3R6K1pXUDV4c3BzbkMreEtmd05nYUlyTDhWVzlwRE5sNkUzSWh5a09SZnBNVGgyeFE4Vy9QWjlGSHQ4N1pYMTNhY3NCV0FIS29kWnhWZEJQbENweHRjTElIaGJIc2R3dGVrY3R1RTRZUXBSMjZhZ0RCZG1KUE02TFl6VEF4T1AxbUhscXNpZWc3S0hEL2VEZVpjSXBHekRlVS9KR1VMa1ZndjlJKy9PeGJ6MDJ1RlpNaS9vOGYzY0FJUnZDeHoveWdnVnNobjRqNUgydWhoODcvdGUzUVluQUpQZHd0WXJRLzZxdjcraFNHV3lkVE8xWnJBZHdabktwSkxrenRuT0hHek4rNS96V3NlYTJsWkJLZEQ1a1NSemtKbkVQR0d2Ujg1QjI3eVpsVFVkamRiZ2ZJM05yTlRmRStVMm4zK2VOV3o0d3ppZkdNbUxpTTllaVE4OEV1bG9Zc0tiUG1XbnRIZkZHRzJtSEtadEY3N3pDU0p2NXArZnUwZUxPdjJUaXZMeERNdEJ2VmRzUDlHVmw4bjFBTStYUU05VWxUdVpia2tRS1JIUzl6RDFRWDhwV0E3Snd1MzVlS3lUa1p5UHNmbFVKQmI0NWdqZHY1WTJaMHBuSnZJVTNNclI4QVY0ZUM0WHBxQ1doVzBGS0FUVkt1Z2lCeVNGNTMwNEc4RnlqcVVkRW5WNC94ZktBbWVPalpTeG04aHFGMGJOckNvWlVBTTRJc2dmeDQwL3cxVjFjbkF1amNzRVZlMjdWUnhza3pNMWVhYzRhM0R0SENZVHFqTGZUaEs1RUxQOXhpd1lVSm5qQ1pLNHlsaVdMUTBrR29NblB6T2RURnBkWTFxYm5XY1F1SmR6VnNNWWh0cUZOV0c0MlV5dmpPRVhLK0Q4MUYrdTJVMmNrUlcwMGl0aWorMDZWdldqZEhQTXZ2dlE1QzZxMlB4VWlSYjJ5ZklvL083cmVCZ1lWNHRxSjhlakFPMWJvdXFLWmo3NVJwRzNXK25nVWZRQ2NXdk5WaFpnTnlDVlZkQ2JJUzZCTzJtaEwrZzB3TGNiU1ZKcVR0TGg4Qlc3dm1lcnkycEhrUm8yTkg5SXN0K2hOOE4wUkVGbVNUdlBwaVFZNEtnc2RDUzFIMk53a0ZaMTY1dXIwTXB4VWFIV2pySk84UDZjaGgxcHBaM01CVDVjd085Y3hIWEpPeG9GSzR2NWQ3RHpqelRVS0dxV1lLYzluSFBCbGJuemlHb1BDZjhZb1B3RFhqeVdSd1h1OXBLeWpiWmVlTEVUaCtIdytMM0YzRjI1b3ZIRDQyUnhqK251NktWUzZkN214VzBhT0pMUHBPeXBwbmI1K2E0VXY2M1VGYkZtU05NSmZ1bXI3b0ZXb0xSVzRlM2xlSEVpbXkzUWRia0wwcFJJdFNQUTdpdlhlSGpsQ24xNUQ5TWt6YmROUmlBc01VN0JHWlhJay9SNnJGZE93dEZkdlY4SkdwNHgxZGtoWVl1MXdKd2pUR1hNWU8wQzdUNlBvU3hMT3VYWDdNbmxiTGV2YmhjMXRNN0RFQ3FXbUdRd3UrMERBSEpEUXo4a1VaY2VQUXgzZHN6TTdUbkY2dVdaZUd0aUZoR092eDlieXNSdXlORXpNRHRKdjVuSUR5YktSaEZWY3VITEhMRC8vWGh6TGw4ZTZSZVAwdmh6UUk3KzJPdE5sRC80YmlFY3NtTVpiOGFSL3JNVUdiSkdFRm9CdTVCT2FyR21LYWdBb0NuaW1URHJDVlpUcWtNeDRHSUVqQzV5QWdwSFlwR3psd2E0RDlocUVYNStPUWRYU3ZvTVA5K09MSTNmRkVhd0UxZGtUY2tYMncvRDQ4VllSZkJ2eURTRmVmZmZvVUVoQWV0aDJrdHpwNFZ5bW40MjFLOGhvWEFSclF0SStPaXB1VFNnaVVmdEpVbVlhSlFUWnhNMUhJS05pNEJOQThqSWF0UEFHZWpXc09hQ3dZNFNSWGd3WWR1UHMwS0ZaMzBxNTZXQ1lMV2JxY0trZ1JDRGIyUGpMeDFDNDlLeU90eVMrb1hnMXIreDhzcVFEdzN1SnBJTWpKdytlQTgyTlhSSGRRY0hWcGl5U1FSaXdqZWZNMnNaLzd6RGtJYnZMZmh5Slg3WUpOTXpkWE5tRkwvMDMveGFHbVpoODIxVkFTRDE0TWt6cFdVdk56NDFQNkNBSDdydHQvQ0Zxcm9XblR2YXpjK0M5czJNUDBhVmQxMkhXMlVpa2NLaGRVa0FyNGpsTERqQlJHQ3BPTEFPM3N3clU2cnZwaUtIckI3UXMvUXNyMDFkZHEvRlJ3VjlZQmdWS3pVVGNyNnNMRjRYdWVkcUh3bm5DaS9MWXRiZ3B6elNVaEYyaFBZTnQxZTFVeWY2YTNvYTlJekpBN2F4MmpyNEkycC9VNTI1dEhkdXJwb0NEZEZSTVl1L2srb3ZVM3JvamN0SzB3UzBEbHNsaFdTanRDOVY4NG0vQ1R5SGhIT1lQVW0xaEY1bThZS01TdXVVbFl3aHh3dDlGQTE1dk1Jck5UekFLRXZCOWd4ZGN0RXpoVmZHMjRzTUl6WVlLSmJDbHgzWSsvdkl4a3J4TUw4dkoxYklieVY2eG8yT2pieTJqaXRaM29Fb1hSeURtZDJQNU9ZRjJVbWtMenBSNkVIekdJWkxzaEl3Ym9MU1QwSFBWNUNLaTNmMDlJYWZNOEhWYXZCbnZqMUZ5ZTBUS0IrN2lJT0p5cU5WWExUb3N4TG1KYk4yeE1ENU9FOVoyckJwbW5iK2RTSkZ0RDdJUmV1aWFGTDhQOVArazhFYmFhNlNHenc2bEFqMlNQMnVveXdaay9maDdENHFaNDNTOCtUc01ucXVnOEtpZERzZkgyUVZQd1B1dERHL2dBZVhVQUt5V1dmRDFaVG9QQlZnOVJLM0l5MkpTZDBVN2pvUUtjWTl1SkdtKzFCOXZSNHNIMmR5QTB2NUpicncwNklqdjZVNW44M1YxeWZncWlPYnNqeC9HMWNOd213NG1ZSkpTc0lBNVJKcE02WkJLS1VuNk43UnVIL2tIdElnbHJGVlZETkZNV2hBYXFFSHFUaGgrQkE0NzRReU9oVEJxOUJvSjNNSnozeXFVa3k2NUl6anNpbDJQTytGb3A3MitJZUNDaUI5NmM5TnJyenZVcHVuN1ZDWlVVU1gyS1VMb2hRdGY2TktHSHQ1Y05WeXg2WTV4TnhZa3NHMUpGMm5yTW1xaW00Q2d1clNSWXVlWHRLZHZyTDBRYi9meVBrdU1aNDVwb3hPdDR6SVFzc1dPVkVWWHVMYVpnU3JVbVpETjRVNm02VnJOZWpremN2NzZnWGthVlZzeVNrWjNiVW5LU0tld0IxR2lYaStSUitjbWVWQ2V1YkFacUNzZ3ZUbDc1Z1p6VWlTb0NORmlwVlFuY2lYY2xZUHZ5Z3I4Z3lheHlLS3lHZ2xxUTYxQjhQa2ZLcWM2TFFScTQyWjM2cVllaXNHT3ZuS1ZGVUw0S2RtWjRSV1ViTDJOdmc2Z1ZPQlJxcGlXcnpLY1NJNEFhSXIreXRaZlR1TWYxcVhTNDY4MFNHN2NucFlWcG8rdGE0UjFaQ0xQODdHZ3lETThISEt1Q0lHNThaQ0YxVFQyWm1RZkRVdUthRldrYisrcm9NaXRmT1JlYVpHcHlDS1JYWUtFd08yRmhURmpoYWVLWk5Id0FvU3M2NzBwWkN2RVlIcFdLSHpoSm9KMnFaNDk2a1NXNGpiZkpCSkhyaGgyVERiR2RHWWdmWS81VE5McWxPd21FOE9xOHFobWRTdW9CLy9uRXdsL3UzbnkrczZLOGVvbmRlOExXMEtZNWJsdzV4MFhuVTFDQmVPZEEwSldXTFdYVHAwakVjQ1pMS01hR3hZaWJhSEdmMDBKaTdFbGcxa0d6Q0NpeDdLZnBMQTd0UkJxTmRBYmgxYzNSRFpteDRkNkRkK3B1MGY5NzhzRmE1STFEWFJTVTZyZk9oekJwMEF4eS9rTy85Q0ZNYTlseEhnZDhvV3dPa0NkSWwyeFBqV05XWFRvTDlCck82Z2VoZDZGUmhVVVlHbHhNVlR3U3hPSjFSSllwVDNvVE5pZGlUSFpUblV3SFlrdFZ6ZXk0cGJIWVI5Y0M1TDBtWTh1dU5DRUJUbmN2aGJqWWZDZlE0MW1jNU1QTnVXVjFJMXYwdG0vZURWbXFrVWdEckdlNjhOdE1ncVYwWE1tRGZBMWFjTUxaQnBoQnJyWE1xQlUwMnhmQWhIZ1ArU3pxNGJwaThOYjBSdmp0REg1YlNXVi9yNTFCb1JaYXJKdmxNQ0lKYlpETVBGWmVVUnBBQ1NqVG9kR21rMnk2NkhMUGhJNnJmeEVJSDNGd1BUVHA3WXVEZ2lraU1nQU1ZVXpHS3BmcWthTmo4N0JVc2FnaGd1NVBnNVF2MFdOaEdLUmV4eklEY0FKdGYrSVp6aTl3ckpHQ3NYcTdTTVZla2RyYlZvK052Z3FxSENDZjdOSG44M2tEZXQ1TGRyZUtlUEt6cDdZaXV0VFRwS3hPMlF3RURTRUdvdzBWN0lHTGZNZmhVNElTc0prbDFsL3JXMFlqRVc0b05MdGo2R1NRYjNZeHJZdURZVDA0dzhOcFAzZGdOM3FyOGFCVXZYOEJyaEw2RVlBZlp4N0VjRDlGUmk2MUJXaStqNFBGRXRrcjVHSGRWQWZhTkowUG9MQXQ1NGZCUzJDNXF6QStVRjZnTmNvM0pVVW9jNVVCa0Q1V0dZZE9obElxaU1WeE5TY21HR3NmTnpIc3pwa2dNOVNMcFZscnVRNVFScDUvRTUxR1lLWEQxRVFZb3FQYWdZc0hmTUhJZSsrOUxQT2NGZnRsQ09xMm9kZDY1RnltMC9Yd1dHelhwZHhkNGw5TlBZdE9WbXhQUkwrdDB4NnFwV29jelVnTVFJUmlPb1VIbmU0ZGZuTEpFUVVMRjhsWit1QzZPZWhBdUpuK1Z3S1M0RnhqdHVSS2FNTkRjVjI4WHpRMkFLcW8rVjVGMGZWQnhEWWhzUGErbHZvNHVFV1FwTk42SFhSSFdpenQrVGU1Z01Tb0dCNGZxcE1mR0FKNE9TeHVVL25sY2k1VVNCK0ZQcjJod1BENExQK3NqTXlNQUNFeFV0M09HNWxLb0hzSk9BMDh2a2c0MzA2bEFhSHdvb1F3ZEJqbUR1WDdxOW5KNW1LYTVLNUN5eHFub3I4YTVONVFMbHgwdnkyV3F5Y2Fua2Z4MWY1S1VORjhsM3dXd2xtMTRQcEJtSXhxRDl3bmd3RG1mMzZhK3RzS0JDUTBEakhTZzBRSjlCTUFiTFo1NDdZYWM1SGF3cjNuYklIc0o4TzNyOExOMG1VanNuSlI5bW9BUW11WGhyUUFiNStIS21MU3ZwRHNlakFYTlNFSnFHdjZGeGpUdEtUR2Zpd1ZFZU9lQm93SzZMbE1Sc2QxM3ZBZlNla21aSi9EL1lZakdVdEVQREJ2ejZDLzR3WVU2T1Z5V0pYMmU3Wjd4eW0ra1JiT08wWWFack0rbHpMU1VCV1N2VGxpS1RtVUtTRFNjL01DUUZEWUdrRDhIcGI1VkN0MURPRVhNWTY1dmtCVksxbEI2bWFEeVY3c1d3VVFyL2NpeGpJbTEvaDA2VFdDYTRqSVdjOEcvMjg2U00zNExKb1F4aEF3ZHJTbTRJTjg3aXl3MU5jMFc4eUVkOXBieVd1SmdhQTBWN0UrV2VqMWFuNmN0clJTYnp6SVl5bUVtVHR3bUhzV1dEMllhY2N3S0RZR21BblF3WTR2RDYxREF6UEZoWGxMM1l6UlA5QXVvL2NpOVF2QnpqdCtibzRERFpLNmpPQmJENjVFZDlyelVGbjkzVmEzVzBuT09UcVZBTkFSdnFxeHkvWS9PaXEwdzNRQk16MkRVSXhLa3FkZ3Z4dFVodVBwRmttS0llRkRYZ3F6QjVWMVNuaWlKSlVSTE5yRUNYOGRWWDFzczQ3QjM2Qy9jTS96YXlNbkYreW40SlVZbzRXUXg0WlM1VE5KdlJIMzVuVVJmMkk1QXU0ZFk4L3IyUkFQdEp5MmJxV2Q1SUlXaXBvcTlHQm5Ra3V1SkxkOExwWVNYNzVrNk0vNnJ5WDVTNllKYkRRWmsyc2lselplMHlVUmtZM0ZMdHE5R0ZEV0laMkRVNHlFWHJkZDdIMHFWSmYrOHJEaFB4UW1YeUhmbXRucGM1SG41Nk5wNW50TnRWQUF3SVJxQm5DeHpDVFMvOVpCcTBOYjZjNkZnQzcwNkdEK2ZXdUJ2K29KajY2emI4WGVOWkRYcUwvR2FGVDMvZ2hRU21BdWFlS0prcWhpN3VRRFd5ZVNPRVF3WG9yMkJHaHl3cnFsZEVkeEdlVWdEMzFlcWY4K1Z2UXFtWEhxbzQzU0QyQUZneGpEM3dlbGxWTUNxTjRNcnJ4RTN3Y3BwYzdHamY4Tm1HcVlsSElGZUVLZ1Z5SFdJZlBacjV0YkZhbjRxcGphR0IwdzZuTGpnS3hPcEd1cUU0and0b2xvY0ZMSThEc1htT3RRaUhPVWxXMENsT1Z4aGVPWjhPdjVHZnQ0WlVyMW9HR2ZuNitzRGU3SVJuR1Exc29Na3RiMWFpUDF5bXNXcE1POGc3OS8wQmJRQVo5MkxKd0syQVp5eFNjZFB6RnZBK0M4aFloMnFaaUFtb0hNQllreEpGMVA2STdBWndWbkVhVExwR1JNc2s4elkwUnYvL2d1QXJ4dExzUUF6elNmLzU4Mzl6cWx0MUs4Zk8zZFBkRXpua2NFa3V0ZHBkYVNFSWttRjU5ZVFuKzJVQkF3SnNXSThHL0dZLzZjbUFEUmxlWUFITDFGSzdTM0xKNFF3bmRaanVydTdxQ2wyNTZ1WjgvNXpPT2Y0K1NqaUlxbEpKSXVwMm1FeWtoQ1RoSGdPclJQd3dCd1R1ZGdJM3lFZ0F0UE1vYzhnM1dDcHRTSDNGMzJoUTBoSVRnMC83V25HQ0lKYTdsdFM3NTFJR3JJR3VuU2p0RTlGK2poNDYyUEZqRWlYdFh3aDVoNnhHOUcwbHNvY2tWNUhBZlRBekdHa1RXa3I5VTNWNW5rVmpvSlVWUFFiSFVBN2VBNnpIc2hndlNRejhDTHNWWDNKbzVORkNOd3BsNldreGsvUEYvY05jbWtYOUNxY1dWN3JTUmlkOHEwaStsb0FHaTBOczVXSUxNTHFKMVNIbVorTGlseEFaZEYyRHpSWFE5OFF0VDg3UHBmc3FuQmFEK1JPanRnY3VNdEpERXEzZVZ2N2FENVBYaWRjMEdVdExHWWlxWWphZmRLbzI3ZWtiRE0vVUFINW8xKzhZVDRaNG9XdHVqcUtEZGUxQ2lKSk1aUUY3SDZ2eVFzaHREZjgzZi9MdnMyZXgvMkxXZDhGaER0ZFg0QXFMM25EVW1vVHJPV21weGZaVDRnMzVRd21EVm5SNEVhWU9tTHNKM0xvWVpXRitSTE9MM0ZzT0xTamIxM0s2THdwMXBLbTh0d3lHQzVEZDlrV2dwOGRFdklrTEhpbnVKSEplT2xnTDJabkJnRnc4bzZ2SDRtQUNXM3I4MEpIV1FQQm15a2FQVVhsWlNXdENUVkRQRjBURDk0NmpDeGY3MzhUckdMNW8wYlFFVmdCM1ZIUnYwZXZjcGVlckVDZG84UXpLQ3V4QVJQcm8zYmQrNVlvdXBraDluM2VvYkQreUYwOGtyWUozejcxa0hUN3VRWE9RREdYNWVJSExXYng2TGJjZE1JaWd3Y2phU0JUMjR1R3I4Y0FOTzh2cVhBTmtkZ1YrR2MxbTRucUJtQUxWaHpJS3hLaUcwanpjdU9FT0h3ZHZhbW5aeksrZXhLS1ZrcXRneEkyTFBncDhXZTVJaFpDRVUxa05pTEUyc1ZPdFFwRFI0V2M1TENsd0RzQjlJOFZUMmdCaVRERCtOUHJ2SmpIeXR6SzVuK0d1RExRK0tUM3puYWNoZStNMUQrQWRUOFNLZG9hVFJ4aytXNVVab0xSQ1hwM3lOWmxzSG9NdXdydVgvTXhSSDAyaFdxQUxNMENlVG9kZlQ2Uzk1RFVGNkozK1VWczQ3K0loNVdSQjlsd2xyNlhkS2RVa3RQV1ZoOXJwRVZDNi84VEJxK0ZuK1ZpeTBiY01TamF5S1dpNDJJUzhIU0ZIOE50Sk11MkFVeTJ0cjhuRG1wQTFzZFZQcDFQU0trbkdHTWZWRkQwbGpVM1F1dVE1RmExMDdXTkpHdU8wNEJKbXlta0hqczV4OVpyVkZ0a3JFM0FiYkZ4eU9RTXU4blNXQ2pGQnFROFRXZFFGcnZmVHdRQmxDMkorUzkxZlZ6dGpiMU5TNm1sMFZ0WGpXR1I2d3IySStYa1lFeHdXWU41RGxOTFRpNXlIeUgxQVRRM1pkUlhMOUxBS1ZzZWc4Q2JhNzltZjdkbjJ0ZmpkUlpRRzVZMHovUDdMOXJBTGZvVThyeUh1TjRTWFNJa0wwRHM0YUNOUy9Vc0xhZXpMK2ZISlZGcEZtZzdGK0wrU3FqSk9EdlBUcDM1TGw4TUJOd0Vhak5EVkl6Yi9nMVI2SVlkSC90a3BYc1k4VXpZdVFGcVpxdE5Od1Nqai96U0lKaFl2cXFpblJBTzN1c2Zucy82dnQxVWp3ZFpKRWpmZG9LWU9qSkMrcDlHUGlaMkRrRExjMHZMZkFvbTZyb25wUXppK2luY3VDQ1hwS0NkbFkwRjlvSU9JTCtxREplZklsS0hDTjE5SlhaZTZLcXlNb1hxWk9CTkZMVUk2NzhtZW5pUHNPcHVoWmpwM2lac1V0STdZNm1ONE5ZWHBSN3lUd0ljakxUcUx6N3gwN2dQcG1xVjVodWtVVHUrSFhpSktIVHBKc2IwTnErdHVzeHlDcmxvL05xTjNnaTNENmxMNHdnV2JYK0FNQndPSzJ4blI2ZGsvSFNQdnRYZ3JncHV5NXZOMFVLZnl3MFRaWUtVcitYcFpyR1MxalhQY1ZwTVpRbUNkT3FkUmJZN25KZnM0VTFiT2VvK095ZmNrNlJmanJZZW1LV0E1UXJnNDl6ODNML0IxQitwOTlWT1NqQ3prMkhROVNjWloyTFBRS3NLam9jQXlTbFY4ZWhVdld0S0NGSkdHY1Z3bDdJZVM5UVBIemFpZUM5d0xuQjNqQmNUWVhIalNHR2x6cnBTVjlHV3Mxa0YzSGxoRlJHMnBQQytmSzJSZ3NLcVE5WVVVem5tRGpoWWVRak9DNkNkb2VEc3VWaE9zcUFCSWxvRlpDS3dFdUI0UGRCV3BxTjFoMHZlOHVvYzBpcHh0VkpDRTdhTlppZlRuNDYwOFY0L0pDWVRGN2VocXh5blU0bVVGbnhqY3dOTGphLzlzWDdRdXNSUFIwaEtiSzRQZWtuemVCeFVkMVlUd1J2QjZQK0ZuNEs0RTNGVTRkWkY4clFUUHJJeXZXUm9rR1BkVTBneFF0WjVVSGptamgwQmFsdXN2Z0gvbXl5bFZOSHhWVll4T3pJcnlYaUhOcG5TamwweFBZS2ZHYXp1SmVaL2hEM24vSGdvcTdPYXBOQXV4OVNuR1A0bWViMElGRmRTSzZpNmhSWmZvU014OFNGUU9WeXprTWJsTGd2aE1SZ21henRpRm9XMkxwRmFtcHdPZ05YQXFnYmM1MzRna2Y0YTdkVlNhNzZKWWFVSitkMDlQQ0g2SkdOeEVnY3AzWTFYZDFjaDNXVUhnUnBreGc1MlpvaktsRmNpOUhlNnQyMDRNRjdvYWVDYStQQWQvR2lxZm1PN3ZBczMra1hqRjRVSkE4Ni9sOHdEYzlFQzE2ZnlXVVZxankzY3h6ckx1RUpFeVZJb2FZNmdZaGVoTDhiMkt5c3N5ZWpSUnhuTGpRRnpORkFQQzB5bDlOMllmMWVGYTZod01DMk9jb21uaWwyV0hKMFZHYzRpcEtkQTBVWHppOVNIY2g3ejhNRU1VU1U1Z2FJbDNFMVJQWVhFUUhZV2swQmNxQktNNjJ1b21OaU43ZTJEalZxYW9JQWZDN1ZKNG5SaEhHdHA2S0NWMW0veGNLanBzdEM5MVR4SmpXVm4rTkhnYXN1ZDkrbSt6L2hlU0JRN3BvNUd3UzZnRTJOT3EyZ2ZKWjNjY2E3TjFNVEc4QWVpK2xlYm1FN0tGU1BaZkJPNnA3ajBKV1o0MWMvSThpY2txaVh4MG9xRzJrYTdjUzJJOUZSTzUwVmRxYmVpTzJjdHI4QytMK1ovdlI3ODY4YjZEaWY2aldyb1lTeFJ2UGsvU1VmSkVvcjRrS2pxOXZoU2tLc2tsYVd1U2hpRStTS0UxeS9wRzhwTXBHQkJ3Q2Rpb29TbTVVQStsaTkrNXFzMlpwbFJ5NGNNQnZJRFlqSUcxSmg5bGcweU9ycDJEK1Q2L3hLZ29RSmdWeDVmb2RqQ2JET254dWMxK0Q3WjdNek1YZkZ1cSs4dlN6bHZGRTZsMGxaWFZzRDRHaVF1ekN5bmJUbnJwN0dkbnl2a3ZXQzFKbFNVSjNUYXpFanhtL25wR0ZCUFNpdU5UUjk0Y3BpVWNSNk8wcEJLWGliNEdCZUVtU3lXR1I3SDc4cVIway9JYzVmaFd1dkFKUGp6QmwzMUlqelIwQzdPWG9ENU9Ua3h4bm1DVjRIbGJHVWJKNlhWK203QitueUdmVlFsd0F2SDZmNCtVckZwUGFnR0U4alRjNGFLV0MzdGZoOE9NVEt6L0RUZ2JFTjBuaGc2a2tVZ0pkQnhrdGRrY2lEdEFlbklUL1BOclpSaVF3LzFaMFExYXF0S3FoeE5SV3E3eFFxSHVMQU9qSlVnWHV4MXVwdUZZNEdzcEtxM3FJZ2ZTQUZFSjRDSEVTT1NkS0REb1lNRHFEalZRd0JBa0J2RURPTllwSy9GTVRwNUt5Y2FWTUR2QlJRZjBGdzMreDFvd1o2TTJWcHVrQU4xcFJYYzdrVHhHdm9mamU3UlVENis0RmIxUWw2ZElXY3J5VmJjdlFHRTl6ZlJFd2RhbXIrUHBxbExLc21ZQjd3ZDVaei9XZGFQdUJ1N0hlbGNUU2lVdVpEd09TQnlFL0dzMVArR1hsSTBXZWEwT2ZJYTFNV3BNeGE4eVFNb0J6V1RlZ3pSRFdUNlFsZzZnYjZPMlFXNk1VenhUQ2dtY2VzeE9ZK1VMcWxSdzQ3YjRudkJ1ei9uaGQvUklBYUhLWUprVVRnTlR3N3RkK01VTy9sTkNic0xDM3cwSE4wUitNdzVlVnkxNDVnZDJMT3d3UHczSTVMK1dwd1hib2drNnlqZ3p1Tjd4NDVDZUZHVGlrNUNsNWYvSGtVVE1GSU9WWk9ObnFxTmdwWVdJQmsvdmtOeDhWeHdYTHE2aFA0NlhLa2FkdXVOcXFZbjdaVjNpQWtlQzN6OGkwNk8wYVpGR0FYdkxTVHFGRFJkRUFXYSsyT2JTcmgvYzZoTnptMHhqYURHeVB4WmJkNHp0ajRMelJIcDFHYXoyelRsVkpBQzRPVkxub1Y2VlVrQTl5SktFYWJ1aVVLTDlqNmVvekQwcDNhZXhOY09wSzlkSDhpMlhwbkY0WnF2eWpPOVVlU2NsdnVHWFhDV1lZeU5Gd0dya3ZsRkRYV1lwckdiVjdhTG5qZEhmY2R2YUJldmwrRHM1UzIvRzh4a0hCMUprNDN3c0p4MVZIMklhSisyeDJJR3BIVXQ5SUZORnlHV3dKS05KRVo0RzhNRjgwRXRRWlZjeG9Ycldqd2VicVFra0gwQ3hnR0lkK3graU9TTVdjY3cwa0duVDBZSzczQk5leGpkbWRBTUdYMWttVkZPUzZLbjByY1dPUWhyRytTV0VFb1lSSUNlZXNTVHJSQm84eVBSdWthbkIxYW9ycnFoMUltTWZIbzJoRyt2VkorYWpNTGlzS044TitSQ3hFNzA0U1VsaldKVGU0V3NFNm9Db2N1SmxwWDRlNXcyWXNjRVY4RE9VQUFLR1N5U1J4TDFJOFdib1haS3NCQklmcDNVRGpFM1VYQUlaUDZ3MkZYaVdTaHlBTlh3SjVFSTJ6aEVBQTZIYUpIWkV5dkY0TEh4Ym12UFZTNHFwejFjc2RKcUdsMlhwc2VSMGw5VC9ET0xOWmVVSGlUTU9MUGthMUNiODFad3k4ZEk3SnUzUFdERktYUWI4cHROWk4wT2RhQ1VsNU5EcmdabWNwbHhhWGxCdUhDamY4ZUE4RFJiWE5Temcrek5KTFlGelNzZUZkSW5FbmlCdkRmK1cwRW9RalMxZmJxbVN5dTVQdUIyQWd4TFN1cUlRQWVmelNmdUR6SGc5a1RJaDJqZkZCVk5jeE9mRHlaVTZYSW9MZ2ltNUNMaGlKcmpRUE1LZnE3VVUyTnVxT1JaOUZhcWY2VmJONlJDVWN3aVZraDBPcFNBNWlZUjVxZnNSdk10WktUYkhMVjk2N1NHSjdON09jUmRDQStudmt2UW02aEowcnlQSHFuamh6cGJ6MldWLy9JN1VucHUyc3FiSUxscDB0TTJYclZtZm4zbFNycEk5V0phVE5YYXZTUXpDTGlIOHZNcXlyL0RkcmdXS1lPdGhsSGZwODNiY09va0xIeXBLSmI1N3FpblhnRCtkT012bWNNMEVqU1JxcGc3Q0U1M3BkWmp4QUFRQWxCSzd3WmpoRk1acW9nUUR3dk5rbHVsTGQvOEFkbWZwa2VyOE9TWkQwNHltTE9hUUcvU0tTb3RaM2hDR3JTWmFEblpMdkNlN2Y5UWptK1hvMVRWVUF4UmVndDR0bnR0T0hJL01IUW9hazExTTh2TnBvMnRSVFV4R0lPTVppcDEyRTdwV2lGUkUvbE4xOXRndTFoR1lNS3MvZzYrZW9qVWpjOGRNZ2pzaUdhR2lMTVdIUE9PQnl5dXBOVTl1K0xhQjlJdnprRmlMUEsvRkhaMW5ybFREQlljT3ZTVnJTM251S3F4K3BnMDk5UFZKV0tzcWpZdkV2a3N5MVJRdVFBeTBaWXNrTGUvd2ZJWUt5dUlIc3A4SFZ4ZlFpMEYxVXhBQjFwNFo1ZDNCdTRDOXJjOUlEQlNiUWlFYVY0bmlPTjlMOVZlUHdqOVh0R1VuL2Z2dkEwclV5bkQyRzR4TnphaVU4R0FnV2dOZUhXdTV1eTc4R1BGTG9zMXc5QXR0ZWV4TWlOeGVOL3cxMFFkSzZZS3FVNXAxWWk5aHd5MUYxVGxXT2ZnTnljcmkwc2dCamF1WDNHY29wM0U0TDFHRHBUTHhvd1JsaUR3RjNwL1Rjc2h6UmZINlcrRk9rSnd5VmhTSDgzb0dnS3h0MldwNmVTT3AzMEpnUUY4ZnBzWTVmc0NoTTBVVXMxa1RERE5pVGtJM1hzZGZTMktDZ2g4WHJCa2hOQkpKQVE3cm1BQkFGMUtWSnUyZlJLVWowNSttRWFONUVwOE4xZmwrc3UrQmk0eXZkN2loRzd1eFAzMU1NcGlUTllOYy9QVzBtMU5OU2RyTStzT3o1TUNOUm01OFhEZEx1bm9YMnhjRkU3OEhTM3FxWUhKNkpIaGUybDcwbi84VVRmT0JoVVJ2RWpZaStmN2ZCVzg5MGhPaXAwS3JDR3N1TFAwWWtZdWN2QnhIWmhTRVNmbmJGRjBuTTVXRWYybE4zdXR0aDJpNUR6ci9JVnZxUllIckhuMVNtMjVNTXoyRUo2Sng1Y1FPZU5wS0Z1NWxOcXZpYzVIUTU1R2NzSEJlbmQ0aDZkYXdNRGFtQ1JKdG9SWkZkRUtTaFBlYjhYMGttUzJVZ1BRcHRFWVpzQWtSdlFmM0kvSlQyNnZOeU1uN2ZBNUZCZ1RqYzltNEY1MW5rcENBV3dPWVc0YmpjcENUWUNKSGRwZHFNZFRiMExIdzRDdXBNYzlEQXErMjA4bzVQWG91R09BL3V1OSt0Nm1GTkZsK0NxY04ybGNpM2dCTEhlOGx5MXlYdURRdmVscXdQVFpwaHd4UFVkbFM2ME9uUHNYSFlGektabkl5a3lWR1V5SU1RVDdnQlNVVko2alpVYUVocWpzZVVkY3pYaFVZZ3N6cUhLN0pqeU5MUDRqYVZxUVFVcmdadFNleVl5ZjNobWE0RTVHYklHSndlS25NOGdsc0c5bjF3YXFRM2NTM2R1VFZDZjUvMVZpamhMK2lCVGNzWmVIUmgybW5PcTJPOVoxT0dWbGNyMUs3UVA0MnFiNTlPLzNrcWpEM2RoVGV4YmxTL3JJU1VNbHBKUGlPQjA5OWdYK3E1elJtWENxdEErRit6ejdpa00vUnMzbVkzUFNLdTFqNVEvWnFhdDlleWFVTjROZWpVc1BmRU1yK2E1emZEYlRyNFRlR3BXSnRxSXFaQ1Q3V1VqUFBPeVNWZy9BY3BRc2RmVFZyTlZWSlptbjk5MFpJNFhndXpXNDZIWkFHVFd0blQyME5rdXcwYVd6TDM0L2dPSjhzWHhQRkZWWk04bTZVS09pOGdjK1FZZmhJNmttV043N2NwcDNwOUNmWDg4bmw5QnduNmdQVXRPWGFNZEk5ZU9vbTd4V0ljUkc2Rm0zRVRBYnkzc1Qvd1pvR2JqQzdqMEFDSnBkNlpFaUxEdWdQaFhmbDMveGJRS0kvOWNTNVdqL25zMU02dWNGdXlmYm9KcDY5RGtuSjhBN1ZuSkNTUWR3dUFrdVhwV0xLWmU3Y0NIaUVRaUJhYnlxRkpya2JNTU9hbmp6RTA1bFRDL08xSVRldXB0ZmZKVSsrZzJBbjgzN2RYRDRKR0FmVE9mVjQwZmVuL09QUGN3L203ZXQ2eG5uZ0Z6bTYxTnlrcmUxMHJQVzIyd24wWkE5SnE1RFIyUDRoMFFKYWNmbXdCOXZYWVp1UWY1dUdxeFg5YUpIWU9jdzA0WjFUWDhlcmUwSnJNV1U4Njd5L2NHQzVOd1VseDBraUF4bEF6NWRaVnNrVjBXdlp2eEZDeDFGVVg0UlRLZFRod2pSOTVzRHlyNnl5QVkzak9LL0Vsd3VVTDlGSVkya2U1b29RQVJaNFdMT2xwQ0RvRE1vOTBUM2tHVGRxVjJoVXB2MFpZU0hmbUthWlRGdzhvNzIvQ1NjSTFBQXNaT1FUekx1UHljWVNDdVpDVHdGYjErcXZMOW5lQUQ2WTBnekNpVVJuTHRGaS9oNFVyL01FMkxUdUJDVCtHN294U0VpR3Z4MUhsVFBGbWRQYkg0aUg4NHJwNDJOcTNDbUFieXBxcXhVSEhVay93OHVKU0xqTVIwbVdBMlZzWDFhMW1VVXFrZ3ErVjlmR1pMR2JSaUpoTjZ6b0x5VFh0YXV2U1dVdm5KWG95VjNPcXZZbVIxY3paTlpSRDJqUkRDWC94ZndHaFIrY1dKR00zMUYvN3M5SVl2bU5YWTM4eHNtYWtyT0pSb3ZKQnlSb3dXd1grQi8xOCtxNmExSXBTZUxaT2N3YzhTdVV1QUdhWCtKSlVlNCt5SGF0V1MwN0xic0pPYzI4NjhSRFdWa0k0RGlGZzZuWWt2UVVpY0VrTFJhSlNvWGFpSFNYMndrZ3FueFQ1MkdPRURreGo0RzN4RS9icUZRQXpUZkFtWUN0YkdEM3BkMDVzSnloNVMwK1dwT3FDbDV2NDdFbTVHZHhLV2U0Q2JqWXlOcGJxRGJXWnBkc2tmaS80ZkxwM0xqT2RDMFFzN2ZHVEFNM1MvNUcxcmhhQ0hwSDZ2SU8wMytEV1ExY25BSDZRN2o0Z3VmbklXeFRjcTM0amZjTCtVVnZLaU1EZ0l0QzRBNlVUVms0eCtqc1RuZ25GSnNEaGI5enh6QjZXeEozWkdwZTJqTWlaUUdkbjFPT0VJZ3FBbFlZR0FKbW9ZYWI3cFpWcGNhWHFGc2FHZFZtTkI1NlFWT3B2WWJmbXV5YzgxdG1SdG5tcnhmUUl5OHFSdURyYTZUZFZxNFlHT2srbXBMOFFKNHZ1bWQvYWx6T1BDdUtpMjNLQzZHKzdoZGo3TXRpMERTRHNiVGpacXZ0cWUrbklvdWFlWE9PZ3p5SWp3N1ZyMlB2dHQzSWE2QWR3WHBOenB5bERpRjh4bElJdEhab3BHblBpRE9WWWwwVnpRaHNCM3dacWs0Q3dUVUdPdlQ3aEtaQS8wTjh0a3B1dkdCRkxnNFoxN0dVWFpUQ2FUQS9FRnBUWEh1Z3V5MExEcWlDMStiWjZVajdMZlovbnRVMlZ4eXBRdlRBL0oxcE5Hdk9SZzNTbDZEWHA5VGxUZzVjRUwxUkRkdDZYR3RMeVM0NFplbVkwTms5VmkrRy9DZkNuREdsRFBEZGYvM3Y0UndYWTBXb1lPTkVlam5HNkVTNnk5TzBCZnRENGx4TEgzWm11WVR2TlNkdE5WNWFLZFEvamwrOGo2WEgrT0dTZisxWnA2Y2pHdVhNQmJaUUV0NGFIdWxnU0FWK0pXODd3TG1oalg4dTg0OHdNVXh6aUdzaFFuM3ZGU0VURGo0clQ2NU1yV21UTyt2UkxnWFJVbEQ2WGh1M3hLMlJuMmZzYlUreWVaSnRRaTJuSExhb0ZjdnJJOEJVMUxuSmFsbEpmb2pzaHRtN0o4dzgzV29Gc3g1OGV1RXJRSG5jNHZGNWlOdHhkQkpmQXd3SzBnMHJ2S1owTGhCemN2bzU5a2VqZUE2Wk4xNmwybEY0K2p6dWhueTFtUm8yOTF2cG9zdzZFZHFOWjNjcVJySkEzandJUDg0QjFHRFBlWnFkMStLVU1KM0VZMTZ5VUVsTzFXcmlhTnBVY09rVnVIZ0tzMmV5dmlaYUcxN0FST0V5OCtCYlZ3THdPQ1hPWnFJM0pWV0NCK2ZnTXpNa050aGRsM0NEOHhpNWh4UkVkTEV5YTY4bHBPWXFWMDZ3MENUbWl0eThaSTk3OFlEeTUwTnBheDdjZSs3OG9nd2ZGR1RybjQvUitYeWNqcDRIYWFXUm1nRXhSekkvWmZvQ1VPcWFJL09GVURRMU9NN0dkMXpKRDVGZlF1aWVEK09VeDFDTmNlR2owZWd4NmJwb3FaWDMvVGdkcE5GTU1ZZHc3U2IvZzAwcEVZOE9DakFENG8vREV3dUxBQzNHcUhPdFJDVVVNYWdwUUFBNHpZR2RNQjdzS2NPQ3FIckFyeVhlakEzTkpQa3N5YUI0WjVZNy9TSTVYSkpoVHRZWDJQb0xuR0t3NzZYNWJWa2xYSHpJYkFMd1dDcGRaL2hSR2ljaXFTb29TOHM1bEJUQU1JTXFDZXRra0Z0T3QzdUZrUUdVR01Ra25XZ0s2Y0ZxVElvcmNackZaTjFPM2xyK0NJeGV3anpoMFpJWUZVT3duQ2x6Q1N3RUlJTGhrUWFQWWgwQStZN1VNYVcyRXVlbWRERmg3YytaQ3RKOHhyRngvcDAvTHJ3cDM1NGtieUp3ZHMzcXRDRHhBUC9sWC8wUE45NHF2QjJmSGM1cWk3cFlvdnR6b0VTbFVpVXBGTUUzRlpFc0txVjh4TmI5SVVDZUI2cWpiR1pmWGp0SnhreStYRXZaaHIxK2JwSUQ1bHpBVXc1KzJuUktmK2orY3QrL2JtbkZsbEo2eHZwZk9NNmhzWFV0RjJ6bHNCeERERzYxWmJxWDdESlZVVWd5UnZVMm5ya2lIYlBjUHJ3ZWFVWkZxUFBPRkJGZ01Ba1FKQU56aEVRRTY4TndlcHA2NzZKSkd3OENTYktKQXZHOVlRSUM2YXVaWks1aGRaN25TcXdzeEdTUkgxcWNKbVNkODZzeHptU0ZOaVlqSUZ0ZFd1Z2t4cHhVd0hHcnJKNmR6WEJEQ1JaVDg0NFRydGs0cHRzQmVQZVU3WVhSN2JkYW51T3VpOU5iNmRrWktpWEVlcWZ5SWZyd2V1cE14SXQ1d3l1eTdGWktpMGtXUTdpckRIK1Y1Szk0UWttL0x0YXFnaXNnYkZMVUZMNkZhNHV3bjVOcVZCWVpmS2hnbU9ER1F4R1ZKUmxLNHlQeGJrWkplOWU0dzBQbGh2UnV5dk0xOENQbzdjcjB0QmdaQldHdE9aK2NscjhlZThiejByMmwwUCtEZUt0SDd4eDNidHRVbHNCWkNSN1BvdmUrS3orMmU3ODJ5d2RTbEUycFAwKzFEelRGVXFZdHNZSmp3c1Y1a2cwaWNPNFRCRUI4Z2o2NEFoYUszc1hFM1lBenhCZGtWTlpaejBNTE9UUzlqRnVuZm1tZlJObHNVZ0ptQ1NzQTVhZk05amh2aGZZR2RmNE11YVZnYzRRS0EvaWR3N0tuNk5SVnhBcGQzV0dpNHZkM0xmc01naEVuZDZYRldzb2ZlNmRkbFlkY2YwMnVFYTQya3h0UzhuWlJidGFFa2NnMysxRnZ3ZkF2MGtrc1NxZTUwaXc1amJIc0JhVU4zZStob0lCZnFtQkZCcHNuMG9zcGp3dHdrT2VxQ2lxbDhMbWFPYW1PeXhyeFhaUjdZYXk1d1NCTlMrdlNJQzhkMEVsWlVjM2RkRGFCWk9UTXFmaUpSTnlTOUY2VmpTa1lLOXdRNmZZMThUcGdpUG1uS1AxSEMxMUZMdW0vOWN2M292WVdaSEd3ZHMwdmpwV3hISDRVYTVDQW5wKy82Y3orb0lvbk9XKzFodXYvVkc1SGxEV1JXaGRIQlN3d3EzTWw3ektsd2tleEVLc0MyR0QvSHR2UzNXSmg1b0hDek5mTkFONW00b2tMMVltbzVmbkJNQm1YTkZyQ3VVYjYzZFNwSmRxYUdSMHM0dERtRFJIbmMvSTNCQTU3MmtyQ1drUG1qUm56SVRmZ3pKU3FkNVdFOHY0UXJqcTY3YU4rajk4ZG9tdkFCM2NVYVNtYURhVzVYNmpXMkxuWU5Qa2lHUWZpNlB2b1ZzTzQ1OFp2RlBtb0lCNkJjR0RSSndrbVM3RXFDYnMrTGRoSUdOdzl6TW9NSlcyUVUxSnRIZmZtVUo0SDNGTnhKMzJPb214Ty8reEY1N3RZK1ZibkgyOFZxMm5heTV2VGFnVEdkUDMzZXJjVDRUUW9TSk45cmZ5MGdlYm4yTTdiekdRV254dTY4WWh0VStYYWw4N2NRWVVWSXhlckNGUXU0WktyWEdGR0FGemxzTUVtTXpVelZGM2lZUDUvUjFiakRNMWxTWnpBK2EzSVRDVzdEMWZlZVQ1RWcvZXNuSktHWnRJS1pPTmVYK1VRN1NoZ0x6TzhKRHZOMUZhd1dJWGRkVVc2UUZsYjlzL2p0OVJRTythOGlnd0IyVHhEMTZLUVMyZUptRzNBNGhUVXQxUXptL1k1MG1la010QVRsL2ZyOG5RRzFsVWVRaWhTOE9uSWpGcnhaWWJNS0t2NldFYWdOVWR6TXc1SzRuY1Q4UDRlSys1ZC9RRW84RWJaZnlCRk9CMG1BcjlWYnJZalBBY1A3MlJHTk1sUGtka1hOVWR5cHFtYjhEeVBEaGZCdWtyRlpueGpUejc5VHVyMWZLdFFmdUJkUHo2Vy8xNGYwNncydUNtWlNoeWZLcGVuMG1lWFhxa0kvZ2FtVGhCdFRSQzVwWXdNQ1JoQ3ZoRFJWRnhJV3ZvVVBKN1F1T21OVmJDOW9JL3orWGNsbnF2eHNvZkRKZUwwU1lHaytpQjVFbW5qQmpmbWlUU0d1QWx5blFCNGFkTmgvSDVtZlJ1WFc1ejFNR2hHaGs2SUF0RjBIRzhmNFlhcDlnMVlzZ2lUdWJmQWl3L1NvNUpvSlVrK2hlZ3JZM0FRbnYwMnM2aFRVY1NoSjBvWUpBVGFrQ2QxVVNMUytnMTNlR3E4bWdkOHlITVdzRVBBUm9CMVJJQUUxVkdValZDRmgvTjh5WlhTdDRwekVwc1ZNc2xGTitiVXZnMmxNeTRyK0hsWis4SG1UQjRxdnl6akJzSVBpL1JOeXZJK0RjMDBPaU9GNDBSak1IZFRHQitXWmdQTkk2dytoZ1lqdkpVU0luZ2RzNVUwY1hrTW1aRWhTbGEwVGxENU12SW9SSndQeDhIK1hHR2JnL0hOdUg1T3RWZzFyL3pyYkZhYUozR2RPVjZ5cGNBaFV0YmRCSFJBZjhGY1ZNTjZVVzlQL0tta1ZCcEJnbU1sa2ZJcWt6WHhkUVpvSFZoYjVhOStURW5CcTE5SEpHUzhpVTg4VmorUjF1N3dTWVFPQU01TThNcFdPdkZ3WTg5WWFUblBNVndvNGJtbFVHUEY3N1VPUGFuOG1Ud2FydWxXS2xjdUlmNkwvL1hmdVJOWjh0R1VzVzZCUHdyaWNhS21GenlYME9hbDNuTlJwcTkrNW9lQm9weE1YSXVUVXROM09mUWdsRzRpWllSR1BURjVqc3BGeVhKQUp5UGlvZGhTb0hBaEI4am53THVGeHpVUmNtUWRxOFhmOHNZTHIzTVM5MnBVbWlOak01VXBxZ2RRbmdtUHczYk1yU1d4Z3V6ZUxmWmFjVmNrYVc1STJ5bm9PZXoySFY5RnFPbVFpZ3huYXluZkNDdkg1dGw1Z0d5K1krRlJ3Q05LMm80ME53TDZKVDVLbVdiaS9NTUlyY2l6VDFPNlRXWU5KUFVsZWtwV0FoNHQ4RmdsS3hRYy9Kand2K2pyNy9uWEZsQkdXblUrcFF1Si9UNUxxd0F2eHkvVVdLcUF6ekIvQVkwanovOU15bVF3VDFSNEZjRnlGYkRGK0FYM1YyZm0rbVY2MGRMNFphcjNJVmVJTm9iamdDOXF5UHM0dW1yNDJBUXJybnh2T296UHd0ZFVtNjVrcDNjQzI0V1pRRjdlWW9QVlJMd1hWVzlUL0svKzJmOUlEU3pXR2Q5aU9pRnpzdGhqS01tQmNoKzJDWmozeU5KQk5KUHBzSWlEUjJEQmxJc1lYcWlrYTNJRkU1d0hZUVJ2amVQT09Rekc0TDJENE0zQUg3bDA3Z1lDZDZPa2dydFdJbmxrclUwbUxyREd5ZndkOGV5bU5mcGtlbk1rdXhjWWZSODJodkc0b1J3YWlWeUFvS2xBVFlwY0pSekw3Ny9qOGxIeXZjODlOeTFVNWF5YTVGZVM3ekM2VHRHalZHUkxTV3NMU2p0Q3Z4dUU4NFJrWUtpS2pYSUVmSElFRXlySStnQmx4K0w1TWJFWGsrSlVMU0RFenRJUmwvQTV2T1Y0MHdyOWF6RFNSUFlITDQzVHZvNG5xREVtQW1BNGtMVnpmSlhLbzB4bzVYZ0Q0bndMbllSNDZRa2dFZDdEUkt3a2o5dnA0RnR5OHN5NXM0ZlZ2TlMrRGJRLzhxT1NNcXF4aWtxV1pkQzg1Z2ZmK1pVVFN4bkx0eXNlYUVoUGJ4VnhqVTVrb1ZDb3h3cU9FR3hwMVRkQTdodXR0a0xxNThDcmdCZHh1dGhYNXc5NVc1WjVodDlxOEhZVmxYcjQxcGY5ZHRQN3JtNU5QMUR1WkJDUGVWVkVxMWY0OWN4WlBGRzNzdUtkU2ZZZmFVc0RNVTFocFQ5YnM1WFp1N1BrdGV5bnZHVnA3VHlPeXRuU3VyeVRNdlJqc290bGQzbktPcktoc0krWitKMkZQWStIZ1poYThjT3Uzblg1UzBGWHMySzloOFRaVkdOOFVJQ0VRL3E1Y3BBM2F2ZkNPVXRjUkdJNFUrY1dSK1YrL2lTSjhjUlliemdMVjNUL2EvUWlRNVM3TUo5RjRKV3dYdmVHUGd4aG9uMmpnRG1pTHNqK1J4aElmSDQvSFpiVUx5MWVBK2JLN3pUSFM1UVNBa3M4YnBLcEwyV3VVbU9kWHcyUjcwdDNUcXlrSnB3WUYyVVVsN0JYQjJFMWdRa2tsYlFTU0ZVdDcyQTZIS2JtNzBFMGxxY05rRXF3b2lmK09aOFdKR2JJc1k3a1hocDJnWFpUTE96NGIzSHN0bWl1cjFRNHprV2dOVWhYeDZGODZOc09JOE1TOGwzY21PajFBWFBYY0wrU1lEbk92RkhsTWJoMlV2eUJVVnJSb2haeG1ELzlwWmwvWHd5V2tiRVdyaC9ub0FIZkJzSXJSUFZ5cXMrbFlrYkZBeTNDaHNOVjhxVlNIRVJuRXZiTTRENmlzd0QyTWlTZmlhOFlXOWpQMFZQaFdLQlFTK3J2NHlPR21NOEtyaHhHc0V4RTZ6UkJGN05NUlQvYXlONWN0bS91RzJlZFNYUTFwQmkvZWdKcnFyekplTjl4SEZYQlZhQmtxQXNGZVc0U05UQTIxT01DdnowQ1ROQ3pVbnpqeC81emRmR0lkLzQ0S1pOcmNScXphcHVVeGlrRFloTGk4K0xrNXJUUUlOSEFnNWJMaCtjeGxnWDJhSCtKbEdFUTVqbHNnWndLK2pPOG9DUTVYYnE0NVZVVkVMbnc0ZWV5dEFDNEJlNnB0SG1hK2c1Yllla2c0RkU3TlhOcU84UTdWYzloOUcwbXlpTzVlQVA3bHZTV0tsZHU5QU5IUDRSNHlxRkpnTWdEdWdYRENnZ056bFJHN0grQW83eUlGL2xPanRjT3d1Zy9SVjBXbml6SmVRMHRiY0RXQ3V3dHU0OUk3c3RuOG5qbTczeWh0SmQwc0pPOE54OHJBZjQ4aTJ3OVpGOWJlanU0TXZHMy8xSXZaWU5pZlJEZVJVVDF3RGhmM3MrSEwrQkp5MTE2ckFtYlpBVllmeE9OZSttZWhzdjNWQWtrckJndVhobnlBTTVDa2UyRm0wN2NabUFNb2JNWjNvekJaZ1VjQzVyZUsrU0g3THFYS0UyL0ROTkR6c2VBV1RMU0lSaXd1SStVd2gyQU4zdk1rZmlUQXJnQ3NBNmE5L0Yxdm45bnBOM29CNStITkpMNFFvdnJpUHRMcEptQ1hGT3ZUd0FxQXI1RnRXdmhvTEJabEtVYTk4MFVYWUdjSWpFRktLdU12QU9kbUVTdjQzRVAzVGdGT1lKR1h1Z2luVWhncVI3YUVnM2ZKOERFNllOaGNLeXUyNWg3OE5rR1VxTTRPNVlLcDJnbDVnZVF6bnZDSk5xekVTOUE5TjQ3ZDVjQm1LUDNGUkJHMmtWQllYZGpZaDhPRTBOT3hrWnJYYTJWQWM3cTJpU1pVeEJTNEpzcEtQNjloS2FaTlN0NjNWQ0RCV1FPMkpNM2RybXAzZGY5dG13NDErNkdEUmZHMS91RlFsTVQ5S1VjUjFJSlpOVXNXSmdMTEVKdURiRzl4WWtqdFl3dzdpay9hWG1JOElOVnk1bFBRU2JaZUV0U1ZlOEplR2NwdWVENFlWRUFKTDJ0R0YwNW5FeFRycExpM2RFY0pBRndMQWNZQmtBdEt4UEdIQ3FkZ2swT2NSYkFqcGZNTnZoYnBpWXY5VDkrbCtTTHp2OGg2REFLbmVNeTErV01rcWJYMG5ZV3oyd2lSNmszUjc2MG9qK3hSZU1BL1VhTU0xTnJjODNwcVZab0NtWE0xWXUwTXdvSE8vcFlTL0VDaDAyU0k2bXdKRS9DTWdTU0NrSVZiMHJKTG9IVG1HMVlTV2xlZmlFeHQwdm9icWtTZ3FJSHZzWHg4cFRXNjdNRzFHZ0lUbG9vbkFJbEVMT0ptRThGMElWejM4Z3dPT0NNWHlYTmduTEprc3diaVhqL1UxRStsTU9MSkh6bGs1OGo1OTRFbWs3NGV0NmJTdk10dEMzN1gyT3lSelNpQVZwRitoeTNxSGt5aUFZTnRXQTQ5K2J5THdaUmUybEIzSjRNUS92RE4zT2VTODdHY1FiUjZLV2tVd2tzcDAyRFNibGs5WWsrSTRBYldLK25zZ1BIVVZUL0I1eERJVzg3dmNjRng1UWVJT1lheE5aUnYrU0NGRFFHUmkvSCtpTzV6c0g2NzlQZGd1S1h4T3JHcElOa1gzS3lrT2UyNHZJWVAwdGo3YVdNSkpqYnQ4a1M2UjF6dUFIeGxYZzUwdUdFYmR5VXJ4dHBKV1ZaVjdxc2tFZ0htU2IxRFNoOUJoVmRuZ2xvbkVWYUVZcnp4TFVnaEhCSEo2Y3hqTDFrM3RET1UvVERtaHNORUltaGo0WDRJUUdLOEZvcTZvT09uc3d1RmJqTThCQk5sOEtWMXdvdFFGc1I3MTlKNzE2blgvbkt6UVZsSjdUL1FUZmZ5ZDdQTmhKdHF2K0RnRHNPWVJ2aE9BUVZqczA4NUN0aElNSnlySkZzUHJBMkJKdktaelArLzMwUmFVK3RScjVVVzRtdlREYThIV2Zkb0NaeVZ5R016MWw1UW5rWUR2SUpyWUJtbFZ0TUxqOGNMRERhMFdkaHkxenhMSjBMTWhKbWlvNnU0dndLVmhKeGhpQWZraTJackYvYjMvbjRTVm5adnNFRHphLzE2TjFsRVZiVTZaRElDdlIrNWVadzJpeWJyVlZDRlhubHRWTHN4K09UMmFXS1A1UVJtbFBlcHE3RmFlV3BhQXI5T0dQLzZZbTFHTGovZVFKUmdTMUZ3Zk1VM3NyU2pCYTVISENmejdpdldEbVFJZS9HZk9FSTV6SnBqd05qaTAwNmFLSWwweFY0eHdseXZ0NTlCZGs4S2d6VFd6T2Q5ZjNlc2pyNVo2bDlJbGJQVlBCcm13c3dyYUdURE5iS01EOUMzU2Q4YXFJUEd1UHJSbkVpQmJHcTkrclJtcXhjSWR5WjQ4WmlBbDB5ajRWZWs2WWpvSlFCR09IWTVXdmZBdmZ6K0dsT0ZlOFJWbVRuVTNUL0RhcUc0UzgxSlRtRm0zcE9heWY0ajI3L0x3V1VMb3VnKzU1OG9FWFpWYms0d1lvRDJaNXdPUlYxaUtxK2hsSHVuVlI4T2U2T3hDdnN3U3JPVC9WQ0FpZ0d4eDUxcnRYR2lXcU5NVGVGV2VBYUliekxTOGNSSGZMdno3ejhpVkI2S0ZQQndhYjJ1aGd0SjdLY1QyRlBxV3dGcDc3aXZtOUxUTjZveU51VzkzMmd0WGhLVCtCY0JFQUt1amRNZDR0bUg4dmtZZGlhRTVsQVh1YmdJRXY3TmY5amlzazg3RVBkU3FTVk5Oa3pjUGdES2kwajhXZE9pcXpyYXJEUjBZVUJvNm1venhJUGtLR0tIUUtORktvNWREQmhjNzVzVG9tWFJlWFZXQzV5K3o0NUtzTmdnYjBYWU1NaENvRFhaZUl0eXh1THNMOE9nNVV3clFEU2dJWWdxM0U0dkpJN0p3bEpqZE0rM0xSQTlpdm9UYUgwSFJzNWVDVXZDakhZeTZiZ0xTcDlFbk9pRktCa2pNTm5EV3FMNUM2VXdsMlVsRWpWajRSRDBGWG85VU9mQ2J3Mi9XL1p1YVE5eGkrSW9JdngxbGlYVTNRbHdVWElleWw2YWZQN0NPTjhHTlhSOGtjTTZ0WlgxYWw2S3QwT2xTdWI1SitDeWt0eDBSVENJdVVsZHU1Q2JjdHJjRGFlbDNBWFJXWEtFeXhWWlUrQ082dFJSNWJlRWUvREwrTTNieWk3VGtzTi9MM0M3amVOM0NXT0NwQXZRWnlsdlFBd2oyM2N3ZEVPR0gwOHhEbGdsY1B6bnA0TDZNWXU2QzFKM1Z3cVEzeVhKNHFhUEp2SHVJeVdJT29BUW5ZVHJVM095N0ttQ0pBb29ZdHpERzU0c1dyQXY4L3k0R0d3VkdaNVNWd09ZUDN6cUZGRDV4UE1QL0M3VFhNN1A4bUY2T3VzTDBub3dWY2duS0ZMQXBNUHdoMk5SQmg5T1FzMUtIMWd3eFNoQXorOW00bDlTWEVzcFRPSkVpanVaRVIvSFUwMjRzVlFMWHJpWWpjS21hVDNFYXFUbms5dmdHaXpQUHYyY2ZaTlpWSkg1dGFiWkJvSXIwem10bEtZSjJkVnlzdXk5UkVtUjB1SVlHbTVqWWR4ZkRzdGtDRzd5dkQ2RnEvYi9ndlBHblY4L1ZweXVUNjVJN0ZOWi9yRGliNUhHOFJnbDdGRElTN2pFa2pNVmpwcHV1d0xIQzNxNzc3QkM1K2liSjdELzM3SVU2eUYwdGErOGMwVmZMYW5TaXJJWTZXKzRQaklHTlRqT3o3bUJpTTJrRGsvTzRXS0ppdnY5Y3VwNUR0VWUwRjJQZHo2U3ZzVEcxKzRxSnVKM2x2VFZ6WDNxNWNhUExJM0VQb3ZPWG50aHZtdnNmMUx3M3E5Q1g0NFMvOWVKdjVaTlB0Vytsa01EWXQra1hvL2NuSHRzdnNmU2JHMTVIM2NMUWZuc0FyVHJBOXJkWFg2Kzlrc1lzR0pFdDlLWWFDTUZDMTErSTJlT1Y4YmZxZW9rL21ndW1jRVBTNG5MRy9SZUlUYUtjNzA0NCttaVpNais2dkkyb2xoWHhxZEo1UGZpT0NHSkdvUS9YVEdyM1Jsb2hkaWNVRUFOMk5sU0hKT1pNL0o0ejc2MEttbVYrblJ2QnB2Sm5ZY254TjU5Y2F3bElHZ2E5Vytsa24wTDJKdElpVy9qNVNCQzlMNGZNdEFOZFR2NDh3Z1dPcXJleXlKUXpoTTBkdTNrVHdwM2R5ZVBVeHpSWW84QTlwSkRFcEV5VUQreUJ4MGcxS1BuaVp3akdObmwvZ0FEUzhySmtiejFVUWFBcldHYWdvSUZaQTdoRkltbmJqUkJFVGptZVViYVhZNUpWVjJLVFB6d3RocFpya25CNHVwNVBHc0xnMTB5V3lnekpBWUVldVB4QVlHbGd5blpVM1ZTWGVSYXpmaTlSQ1lYUmdkNE5rR2YzU1BYendtK3dmdXFKZ3JYYkhOZ1R3ZUJNcjl5bXdaQUNHazE4Q0lPVkY0aVNObEZlcWhVc2lxWDg0RzVRR1JlV0lUakJZNTFrQ1loVFpMNUQ0dGRWbXdpTStyTERhRCtWUExzdGhLR2g0WnhtODlyZ1h3NWxmZzdOZy9LOGVIQ3prM201Z25lUDBRcHhQL3QxdlcrWlJ2NWZEcG9RZ3NucXlDSzBtR1Vsb2dxSy9nNlVLMDNaRU9PYmdlUXczbWMxOUtac3pISFVZK2ZkZFl1azdZTU5xUzlKTTY3RXJPbkRBMm1oQ1ZCQkJrSWN6cXJ0ZHNxTzE4OTNaQnZlNmFLMU5vWnRuWE90UldrWDJJYVFPWERNN0tTSjJtL3BWTWlUb2Q0V2JNS3NjUU1lYWVvc3FOZEtlTnh4VEZ6OE5OQW81cGRpS0g1YXJtVlVnV2dXdUFxY0NmdG1IcThUZHZVM1dKZHE4NHVSZEpITVU3Zm1FRXIycld0TVBMZlR4ZWxvTzVwTGc5Z2wwcmJjTHEvd21WSmQ3aWNhMUcyME1LQVZDWG8vV3VLV1dBTnhiVmh0VGVsZ1kvN2xSdFJYdFhjQ2pZTW5tekxQVjcwS2dsK1N3VGMrR2s3Ly8wb3BKZU95KzVIeWNpdTVYYWZhM2tVVG9SQlJiM0QzaC9ONHFxRWxzVS9BcnhQQ0x6ekRENXhCYlhBM214am82NElsSlFQTUYweXM1NmJMWm9hbGRpUTRIcEY4NVZPVjA1bzdFa25Zekp2WklJcURpWnQzV0NoVXcyeCtnNkJVZDdwSkVIbGR0MnZ5cnd2L21ydjFvdUJxMzMxZTQvOGN0WnZSOEovQ2Jkc1loRjJWRlJGUTFRbXNNSEFtWlBxZmswYlkvQWd6Qk1jdmhGTzdwNUxaTUorOWJBUVF6blFpb3pCTE9vRnBBSVFKQkRjUlVKaUxKYzlNYzRJTkFvQzdDRnlRL0QwUWUrdTVtVWFoeE9sSjE5emw5NHAyK0MxYXRBNzRmN0cwWnJLOVpNck16VWNJcWhTemQyazJHaXpHVHd3T1R2c0hRUUpsdURUUFVBRDE5TGF4aTgwWTFwQmZ3czV6OTl3d0hDYTI5WXQwRkdiOUk3ZVJiWDBUL1UrNFdMOGdlZncrUTVPNmRzTGlMRlhuSnA0VFlDMmszUFpQQkNvRWFOYkJXOE56ZDFweXRNWDh0SVFOTkFrSUhDeElONTFDMHpLNWFzQ01zYVZPNTZma0JMQjRSOHc2NjJBTDNycm5YVjR4ZnVzR3YvUklmS3N2TE5MWTRhWUVFVk5UdlpGemhRd001cnArM2g2Q0JvTVNrOFlObWVXc3FpTkNQTUZBWXpNTWxCcU9IekFCUHBjMjNTU00vbVFoYVFoVncwbVdnWGl6NUFVSGFTcE1jVkJVa0ZBS2JDVlJuYjFPMXk0aFh4T0lIeXZOaDhFcnhkMCsxT2VLc3Vpd25zRlFCSGdpOG02aVVacWlMZlJYQ1p1ejZPVEs3TSs0Q21Qb1NyYitsM3pKaU8zWHNqYlpvd1FlSDR4MmJ1U2l3V1o2ODdacThSa3d0WVFVUWVwbDBNdUE3TGVlOFBzWFdzekg1ZVVhMXJ5WTFUZTBvL0RacjhXTnF0RnI5Wm5aZzN3OElWM0Z5Yit4cjZkeWY0NFVCOENkaHBXVDJEVERrejdwM0hpWUxvdGlMQnhLWkVEc0JZUzdNbm1JZjV2bzlNS2lVV3BUamRmaTIzVDkxZU1qTzJNenZaNEV4VkZBbFVsLzFqRU1pUmxod1RBTUhvVlhZZ28zdFZkMWpWWm1lcC9TYnoyZXpTaUhML1YrSzlOSXVUTFRieG9nOWlGV1NUNmI5SlAzbVcvOGZFR3hkSytRYWVZTEZ3Q1dkVURnOG00Mk81UUFDcnFYMFRoRVArL3ROUUd5ZmsyVXQ3MGM4cVUyVThUSElOWGtLSU5aVEJKWjdsdGFxQmRpZnArWkErQXVMSkJyMU13MFVpbndTRVdhdzBGNk0vaTkwRWhJTzAyS1dUbmxEMjRxbUdCN2ZRL2NVb0NxVFJSQlRIeUZYRnpFeEVYekk5TmV0RDBnbWtWR1JjbEsrQW5vYkZkaWhaQVhyQTdBNGtHeWs2Z1NrUXBSbkhqT2RzTVpneXQwTG51aUdrOGF0SjNycVZMdGdxclNBZUtPUlIvZ1dJMUN2cGoxNWJCNFQzUGs0eTFZRGVST2FSNGxhZzB1WkJEa1JwcXQyRk1CYTJ6bzB6TER0OHNJQnROY2cxcVBRdHltT3cwY2VET0xpazFud21YTnpPWDNMZml2bFlsaEtkQVFLdVQ5WEY1K1JPRUw5MFo1ZXE5SGpteHJYc0Z4OW85UjE3TGF0M1RvV3h5SGhlYmZjbnFveG1EaUJaQWNhUTdpRjNrTlZNVmtSU2Q0dkZlalN6dk5xQzhla0ovVjRydkkyaVB3bFJiNVY0ZHJSYWtvTVFUUmNJNGY4T1hzUnVycSt0Tk9EUmtDNTNtZEVTendyQnloYXVaYWZIV1BJRHFaU3dxMGxRdWRRZkRQMWZTRWpXeUUwMXA3b3p3Nlh6U0RJZGQ2K2czaU5pR3ZGdlh2WjNHalc1QXRXSzBQcGc3SUxpRTRIdGlJWnh6MVRkVHluSWlkaEl2WkJIZ3I5MXlmcXZKYjBLMzVuSVd2Y2ZWWlU5bWJXcjZNZFIzQXpNN3RnbVNPQkZHa0xnZDVMNk15UUxjSkxqNzkwbWZLdWxrK2pHcjNkRU0vNTFBVlNKTUgxRmVNQmNjalFxdCtla3dnU3JBOHUvVEVVck1SVHdMaHV2QmVtclo3UW5UOWJ2ellOUHdqRVRhbGZLRE9sRXAyUWhYcDJDczc3b3NIaUpTcGxUYkJvODZ2R2RQQ0d0aUxxeERsQ3ZhRjBRY05SME5sK29TM2ZUUFFPYzNsYldwNzBiRGVQTlY1RUxra0pIcWFOd2o2bURydmpadkgvdW1NK0cvckttTGl1cVhJeDFMU25lSlFNWFJCays4bmpqVXFxLzlVODJOUElqai9EL3FFMnlYTkd3dXNYcVhWWVkrNk1aY3JUMEh3ZkdUd09Zcll1b1JmT3lsK3RvY2gwcnV1QUFPVEVyWHlVamxhYXpSRjVVcmcxamJoSHBFb2V1ckxRMTcxMlVOSWt1UWFCQ3VaY2tGRTJxQ2xteEtnTjJQY1BTazNCcHllcnR1UlZUU2thaFJzVGhWQmx2U3U4N0pLbEU4NWhXTG9GMjRYc1ZZMWFMaHpkaEluc1Z5a3FubVA0K0ZrNUtmZm5NS1l5K0xkVTYwWWZ6N3R2M2pBdTFwN1dLVzg5eG9vaWpsV0pCaHBYMThJMHIwQWJQZmVtYk9IemQ1dGNsTDd5UnlVaEUzbGRITDZOK1QxdXB4RDdnZ0lIUkFCMDQ4dnV5dUowYVRUdThlczVMZ0dmQ01FblJLZzR1TjNKNzc4TTdLeEkzazd3QXVaYlV1TEF2L2w2Nm1wdE56TXJDYnVmdXZ2UU5HdGlmcU1ZU1VwejBSaEk4SDZwZkRreUVRS1VtRFMvVFI3MTBMOFJnbmE0UDJMZEpNbTFiV2s0czVWZ3EwYjIrdmZTM0JzbTk3dmRLdUZmTktMRzJOQjFuclBnZmswS2lKWjFMZjFJeWxBaHFBUUF6SkNLaE85alhoSlhpS1V3S0ZyTzNaVzlLeGExd0pLQ2FvQ0FFRmNoS0RRMXdNdXRHZVJuREJGb21jZFpJWjhuUmwrek5EbWwxTGExSm9NMURBcXRwZXNpWW5LY1RFNzZMeHpldXkxTEFUUUNXdlVEbjRmNTBGcWd4OUxVVFc5RWd1dWY0V2lQNS9VeHp3dURESnBpRVNIRWp2Nmg5ZnhFWm1yclNCWmJnU1NDZTlkUEZHTWVCT3A1Nm56eWdsZVVnZ0RUQ2lnZUdyM09GaDhaa1U4cGNIUHEwaDNaR3ljeVh6SkV2eWFTZFRmbW10VXI1MVJBa2JxclhaTXB4eWducytlOVM1RmcrTGNpWEViOFRxUGY2YXIzUXV3aUtJenc1M20vOFJPcmV5eHYvWVdtb1EvT09aZ0FXcDVkb29SVWRxR1JTQjVZRXJSQVgxR0NxU0ZFS1B4RnBXYWduSWN0aXVKa2Z2MWpMdVdkaWJnaitmNjhXeTF5Z1Y1R0VBQUFBQUVsRlRrU3VRbUNDXCJcclxuXHJcbnZhciBPUFRJT05fU1NBT19TQ0FMRSA9IFwicmVuZGVyZXItc3Nhby1zY2FsZVwiO1xyXG52YXIgT1BUSU9OX1NTQU9fSU5URU5TSVRZID0gXCJyZW5kZXJlci1zc2FvLWludGVuc2l0eVwiO1xyXG52YXIgT1BUSU9OX1NTQU9fQklBUyA9IFwicmVuZGVyZXItc3Nhby1iaWFzXCI7XHJcbnZhciBPUFRJT05fU1NBT19SQURJVVMgPSBcInJlbmRlcmVyLXNzYW8tcmFkaXVzXCI7XHJcbnZhciBGTEFHUyA9IHt9O1xyXG5GTEFHU1tPUFRJT05fU1NBT19TQ0FMRV0gPSB7ZGVmYXVsdFZhbHVlOiAxfTtcclxuRkxBR1NbT1BUSU9OX1NTQU9fSU5URU5TSVRZXSA9IHtkZWZhdWx0VmFsdWU6IDV9O1xyXG5GTEFHU1tPUFRJT05fU1NBT19CSUFTXSA9IHtkZWZhdWx0VmFsdWU6IDAuMn07XHJcbkZMQUdTW09QVElPTl9TU0FPX1JBRElVU10gPSB7ZGVmYXVsdFZhbHVlOiAxfTtcclxuZm9yICh2YXIgZmxhZyBpbiBGTEFHUykge1xyXG4gICAgT3B0aW9ucy5yZWdpc3RlcihmbGFnLCBGTEFHU1tmbGFnXS5kZWZhdWx0VmFsdWUpO1xyXG59XHJcblxyXG52YXIgU1NBT1Bhc3MgPSBmdW5jdGlvbiAocmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCkge1xyXG4gICAgQmFzZVJlbmRlclBhc3MuY2FsbCh0aGlzLCByZW5kZXJJbnRlcmZhY2UsIG91dHB1dCwgb3B0KTtcclxuICAgIHZhciBjb250ZXh0ID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dDtcclxuICAgIHRoaXMuX3Byb2dyYW0gPSBjb250ZXh0LnByb2dyYW1GYWN0b3J5LmdldFByb2dyYW1CeU5hbWUoXCJzc2FvXCIpO1xyXG4gICAgdGhpcy5yYW5kb21WZWN0b3JUZXh0dXJlID0gdGhpcy5jcmVhdGVSYW5kb21WZWN0b3JUZXh0dXJlKGNvbnRleHQpO1xyXG4gICAgdGhpcy5sb2FkUmFuZG9tVmVjdG9ySW1hZ2UoKTtcclxuICAgIHRoaXMuX3NjcmVlblF1YWQgPSBuZXcgRnVsbHNjcmVlblF1YWQoY29udGV4dCk7XHJcbiAgICB0aGlzLl91bmlmb3Jtc0RpcnR5ID0gdHJ1ZTtcclxuLy9cdFx0aWYgKCF0aGlzLmlucHV0cy5wb3NpdGlvbkJ1ZmZlcilcclxuLy9cdFx0XHR0aGlzLl9wb3NpdGlvblBhc3MgPSB0aGlzLmNyZWF0ZVZlcnRleEF0dHJpYnV0ZVBhc3MoXCJyZW5kZXItcG9zaXRpb25cIik7XHJcbi8vXHRcdGlmICghdGhpcy5pbnB1dHMubm9ybWFsQnVmZmVyKVxyXG4vL1x0XHRcdHRoaXMuX25vcm1hbFBhc3MgPSB0aGlzLmNyZWF0ZVZlcnRleEF0dHJpYnV0ZVBhc3MoXCJyZW5kZXItbm9ybWFsXCIpO1xyXG59O1xyXG5cclxuWE1MM0QuY3JlYXRlQ2xhc3MoU1NBT1Bhc3MsIEJhc2VSZW5kZXJQYXNzKTtcclxuXHJcblhNTDNELmV4dGVuZChTU0FPUGFzcy5wcm90b3R5cGUsIHtcclxuICAgIGNyZWF0ZVJhbmRvbVZlY3RvclRleHR1cmU6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGdsID0gY29udGV4dC5nbDtcclxuICAgICAgICB2YXIgdGV4ID0gY29udGV4dC5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICAgICAgdGV4LmNyZWF0ZVRleDJERnJvbURhdGEoZ2wuUkdCQSwgNjQsIDY0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB7XHJcbiAgICAgICAgICAgIHdyYXBTOiBnbC5SRVBFQVQsIHdyYXBUOiBnbC5SRVBFQVQsIG1pbkZpbHRlcjogZ2wuTElORUFSLCBtYWdGaWx0ZXI6IGdsLkxJTkVBUlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRleC5pc1RleHR1cmUgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiB0ZXg7XHJcbiAgICB9LFxyXG5cclxuICAgIGxvYWRSYW5kb21WZWN0b3JJbWFnZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICBpbWcuc3JjID0gYmFzZTY0UmFuZG9tTm9ybWFscztcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlckludGVyZmFjZS5jb250ZXh0LmdsO1xyXG4gICAgICAgIHZhciB0ZXhoYW5kbGUgPSB0aGlzLnJhbmRvbVZlY3RvclRleHR1cmUuaGFuZGxlO1xyXG5cclxuICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXhoYW5kbGUpO1xyXG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGltZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjcmVhdGVWZXJ0ZXhBdHRyaWJ1dGVQYXNzOiBmdW5jdGlvbiAocHJvZ3JhbU5hbWUpIHtcclxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmNvbnRleHQ7XHJcbiAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBHTFJlbmRlclRhcmdldChjb250ZXh0LCB7XHJcbiAgICAgICAgICAgIHdpZHRoOiBjb250ZXh0LmNhbnZhc1RhcmdldC53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBjb250ZXh0LmNhbnZhc1RhcmdldC5oZWlnaHQsXHJcbiAgICAgICAgICAgIGNvbG9yRm9ybWF0OiBjb250ZXh0LmdsLlJHQkEsXHJcbiAgICAgICAgICAgIGNvbG9yVHlwZTogY29udGV4dC5nbC5GTE9BVCxcclxuICAgICAgICAgICAgZGVwdGhGb3JtYXQ6IGNvbnRleHQuZ2wuREVQVEhfQ09NUE9ORU5UMTYsXHJcbiAgICAgICAgICAgIHN0ZW5jaWxGb3JtYXQ6IG51bGwsXHJcbiAgICAgICAgICAgIGRlcHRoQXNSZW5kZXJidWZmZXI6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IFZlcnRleEF0dHJpYnV0ZVBhc3ModGhpcy5yZW5kZXJJbnRlcmZhY2UsIGJ1ZmZlciwge1xyXG4gICAgICAgICAgICBwcm9ncmFtTmFtZTogcHJvZ3JhbU5hbWVcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVuZGVyOiAoZnVuY3Rpb24gKCkge1xyXG4vL1x0XHRcdGlmICh0aGlzLl9wb3NpdGlvblBhc3MpXHJcbi8vXHRcdFx0XHR0aGlzLl9wb3NpdGlvblBhc3Muc2V0UHJvY2Vzc2VkKGZhbHNlKTtcclxuXHJcbiAgICAgICAgdmFyIHZpZXdNYXRyaXggPSBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIHVuaWZvcm1OYW1lcyA9IFtcInZpZXdNYXRyaXhcIl07XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzY2VuZSkge1xyXG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlckludGVyZmFjZS5jb250ZXh0LmdsO1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5vdXRwdXQ7XHJcblxyXG4gICAgICAgICAgICB0YXJnZXQuYmluZCgpO1xyXG4gICAgICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmFtLmJpbmQoKTtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Tm9uVm9sYXRpbGVTaGFkZXJVbmlmb3JtcygpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHVuaWZvcm1zID0ge307XHJcbiAgICAgICAgICAgIHNjZW5lLmdldEFjdGl2ZVZpZXcoKS5nZXRXb3JsZFRvVmlld01hdHJpeCh2aWV3TWF0cml4KTtcclxuICAgICAgICAgICAgdW5pZm9ybXNbXCJ2aWV3TWF0cml4XCJdID0gdmlld01hdHJpeDtcclxuICAgICAgICAgICAgdGhpcy5fcHJvZ3JhbS5zZXRTeXN0ZW1Vbmlmb3JtVmFyaWFibGVzKHVuaWZvcm1OYW1lcywgdW5pZm9ybXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9zY3JlZW5RdWFkLmRyYXcodGhpcy5fcHJvZ3JhbSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmFtLnVuYmluZCgpO1xyXG4gICAgICAgICAgICB0YXJnZXQudW5iaW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSgpKSxcclxuXHJcbiAgICBfc2V0Tm9uVm9sYXRpbGVTaGFkZXJVbmlmb3JtczogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdW5pZm9ybU5hbWVzID0gW1wiY2FudmFzU2l6ZVwiLCBcInNQb3NpdGlvblRleFwiLCBcInNOb3JtYWxUZXhcIiwgXCJzUmFuZG9tTm9ybWFsc1wiLCBcInVSYW5kb21UZXhTaXplXCIsIFwidVNjYWxlXCIsIFwidUJpYXNcIiwgXCJ1SW50ZW5zaXR5XCIsIFwidVNhbXBsZVJhZGl1c1wiLCBcInVDb25zdFZlY3RvcnNcIl07XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fdW5pZm9ybXNEaXJ0eSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIHZhciB1bmlmb3JtcyA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgcHJvZ3JhbSA9IHRoaXMuX3Byb2dyYW07XHJcbiAgICAgICAgICAgIHByb2dyYW0uYmluZCgpO1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5vdXRwdXQ7XHJcblxyXG4gICAgICAgICAgICB1bmlmb3Jtc1tcImNhbnZhc1NpemVcIl0gPSBbdGFyZ2V0LndpZHRoLCB0YXJnZXQuaGVpZ2h0XTtcclxuICAgICAgICAgICAgdW5pZm9ybXNbXCJzUG9zaXRpb25UZXhcIl0gPSBbdGhpcy5pbnB1dHMucG9zaXRpb25CdWZmZXIuY29sb3JUYXJnZXQuaGFuZGxlXTtcclxuICAgICAgICAgICAgdW5pZm9ybXNbXCJzTm9ybWFsVGV4XCJdID0gW3RoaXMuaW5wdXRzLm5vcm1hbEJ1ZmZlci5jb2xvclRhcmdldC5oYW5kbGVdO1xyXG4gICAgICAgICAgICB1bmlmb3Jtc1tcInNSYW5kb21Ob3JtYWxzXCJdID0gW3RoaXMucmFuZG9tVmVjdG9yVGV4dHVyZV07XHJcbiAgICAgICAgICAgIHVuaWZvcm1zW1widVJhbmRvbVRleFNpemVcIl0gPSBbNjQsIDY0XTtcclxuICAgICAgICAgICAgdW5pZm9ybXNbXCJ1U2NhbGVcIl0gPSBPcHRpb25zLmdldFZhbHVlKE9QVElPTl9TU0FPX1NDQUxFKTtcclxuICAgICAgICAgICAgdW5pZm9ybXNbXCJ1Qmlhc1wiXSA9IE9wdGlvbnMuZ2V0VmFsdWUoT1BUSU9OX1NTQU9fQklBUyk7XHJcbiAgICAgICAgICAgIHVuaWZvcm1zW1widUludGVuc2l0eVwiXSA9IE9wdGlvbnMuZ2V0VmFsdWUoT1BUSU9OX1NTQU9fSU5URU5TSVRZKTtcclxuICAgICAgICAgICAgdW5pZm9ybXNbXCJ1U2FtcGxlUmFkaXVzXCJdID0gT3B0aW9ucy5nZXRWYWx1ZShPUFRJT05fU1NBT19SQURJVVMpO1xyXG4gICAgICAgICAgICB1bmlmb3Jtc1tcInVDb25zdFZlY3RvcnNcIl0gPSBbMSwgMCwgLTEsIDAsIDAsIDEsIDAsIC0xXTtcclxuXHJcbiAgICAgICAgICAgIHByb2dyYW0uc2V0U3lzdGVtVW5pZm9ybVZhcmlhYmxlcyh1bmlmb3JtTmFtZXMsIHVuaWZvcm1zKTtcclxuICAgICAgICAgICAgcHJvZ3JhbS51bmJpbmQoKTtcclxuXHJcbi8vICAgICAgICAgICAgICAgIHRoaXMuX3VuaWZvcm1zRGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9KSgpXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTU0FPUGFzcztcclxuXHJcbiIsInZhciBTY2VuZVJlbmRlclBhc3MgPSByZXF1aXJlKFwiLi9zY2VuZS1wYXNzLmpzXCIpO1xyXG5cclxudmFyIFZlcnRleEF0dHJpYnV0ZVBhc3MgPSBmdW5jdGlvbiAocmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCkge1xyXG4gICAgU2NlbmVSZW5kZXJQYXNzLmNhbGwodGhpcywgcmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCk7XHJcbiAgICB0aGlzLl9wcm9ncmFtID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5wcm9ncmFtRmFjdG9yeS5nZXRQcm9ncmFtQnlOYW1lKG9wdC5wcm9ncmFtTmFtZSk7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhWZXJ0ZXhBdHRyaWJ1dGVQYXNzLCBTY2VuZVJlbmRlclBhc3MpO1xyXG5cclxuWE1MM0QuZXh0ZW5kKFZlcnRleEF0dHJpYnV0ZVBhc3MucHJvdG90eXBlLCB7XHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChzY2VuZSkge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmNvbnRleHQuZ2w7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMub3V0cHV0O1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHRhcmdldC5nZXRXaWR0aCgpO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0YXJnZXQuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgdmFyIGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xyXG5cclxuICAgICAgICB0YXJnZXQuYmluZCgpO1xyXG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUKTtcclxuICAgICAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XHJcblxyXG4gICAgICAgIHNjZW5lLnVwZGF0ZVJlYWR5T2JqZWN0c0Zyb21BY3RpdmVWaWV3KGFzcGVjdCk7XHJcblxyXG4gICAgICAgIHRoaXMucmVuZGVyT2JqZWN0c1RvQWN0aXZlQnVmZmVyKHNjZW5lLnJlYWR5LCBzY2VuZSwgdGFyZ2V0LCBzY2VuZS5zeXN0ZW1Vbmlmb3JtcywgW10sIHtcclxuICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBwcm9ncmFtOiB0aGlzLl9wcm9ncmFtXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRhcmdldC51bmJpbmQoKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFZlcnRleEF0dHJpYnV0ZVBhc3M7XHJcblxyXG4iLCJ2YXIgQmFzZVJlbmRlclRyZWUgPSBmdW5jdGlvbiAocmVuZGVySW50ZXJmYWNlKSB7XHJcbiAgICB0aGlzLm1haW5SZW5kZXJQYXNzID0gbnVsbDtcclxuICAgIHRoaXMucmVuZGVySW50ZXJmYWNlID0gcmVuZGVySW50ZXJmYWNlO1xyXG59O1xyXG5cclxuWE1MM0QuZXh0ZW5kKEJhc2VSZW5kZXJUcmVlLnByb3RvdHlwZSwge1xyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoc2NlbmUpIHtcclxuICAgICAgICB0aGlzLm1haW5SZW5kZXJQYXNzLnJlbmRlclRyZWUoc2NlbmUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRSZW5kZXJTdGF0czogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFzZVJlbmRlclRyZWU7XHJcblxyXG4iLCJ2YXIgQmFzZVJlbmRlclRyZWUgPSByZXF1aXJlKFwiLi9iYXNlLmpzXCIpO1xyXG52YXIgR0xSZW5kZXJUYXJnZXQgPSByZXF1aXJlKFwiLi4vYmFzZS9yZW5kZXJ0YXJnZXQuanNcIikuR0xSZW5kZXJUYXJnZXQ7XHJcbnZhciBGb3J3YXJkUmVuZGVyUGFzcyA9IHJlcXVpcmUoXCIuLi9yZW5kZXItcGFzc2VzL2ZvcndhcmQuanNcIik7XHJcbnZhciBCb3hCbHVyUGFzcz0gcmVxdWlyZShcIi4uL3JlbmRlci1wYXNzZXMvYm94Ymx1ci5qc1wiKTtcclxudmFyIFZlcnRleEF0dHJpYnV0ZVBhc3MgPSByZXF1aXJlKFwiLi4vcmVuZGVyLXBhc3Nlcy92ZXJ0ZXhhdHRyaWJ1dGUtcGFzcy5qc1wiKTtcclxudmFyIFNTQU9QYXNzID0gcmVxdWlyZShcIi4uL3JlbmRlci1wYXNzZXMvc3Nhby1wYXNzLmpzXCIpO1xyXG52YXIgRVZFTlRfVFlQRSA9IHJlcXVpcmUoXCIuLi8uLi9yZW5kZXJlci9zY2VuZS9jb25zdGFudHMuanNcIikuRVZFTlRfVFlQRTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ge0dMUmVuZGVySW50ZXJmYWNlfSByZW5kZXJJbnRlcmZhY2VcclxuICogQHBhcmFtIHtib29sZWFufSBlbmFibGVTU0FPXHJcbiAqIEBwYXJhbSB7R0xSZW5kZXJUYXJnZXR9IHRhcmdldFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBGb3J3YXJkUmVuZGVyVHJlZSA9IGZ1bmN0aW9uIChyZW5kZXJJbnRlcmZhY2UsIGVuYWJsZVNTQU8sIHRhcmdldCkge1xyXG4gICAgQmFzZVJlbmRlclRyZWUuY2FsbCh0aGlzLCByZW5kZXJJbnRlcmZhY2UpO1xyXG4gICAgdmFyIHNjZW5lID0gcmVuZGVySW50ZXJmYWNlLnNjZW5lO1xyXG4gICAgdGhpcy5fZW5hYmxlU1NBTyA9IGVuYWJsZVNTQU87XHJcbiAgICB0aGlzLm1haW5QYXNzID0gbnVsbDtcclxuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0IHx8IHJlbmRlckludGVyZmFjZS5jb250ZXh0LmNhbnZhc1RhcmdldDtcclxuICAgIHRoaXMuY3JlYXRlTWFpblBhc3MoKTtcclxufTtcclxuXHJcblhNTDNELmNyZWF0ZUNsYXNzKEZvcndhcmRSZW5kZXJUcmVlLCBCYXNlUmVuZGVyVHJlZSk7XHJcblxyXG5YTUwzRC5leHRlbmQoRm9yd2FyZFJlbmRlclRyZWUucHJvdG90eXBlLCB7XHJcblxyXG4gICAgY3JlYXRlTWFpblBhc3M6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZW5hYmxlU1NBTykge1xyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25QYXNzID0gdGhpcy5jcmVhdGVWZXJ0ZXhBdHRyaWJ1dGVQYXNzKFwicmVuZGVyLXBvc2l0aW9uXCIpO1xyXG4gICAgICAgICAgICB2YXIgbm9ybWFsUGFzcyA9IHRoaXMuY3JlYXRlVmVydGV4QXR0cmlidXRlUGFzcyhcInJlbmRlci1ub3JtYWxcIik7XHJcbiAgICAgICAgICAgIHZhciBzc2FvUGFzcyA9IHRoaXMuY3JlYXRlU1NBT1Bhc3MocG9zaXRpb25QYXNzLm91dHB1dCwgbm9ybWFsUGFzcy5vdXRwdXQpO1xyXG4gICAgICAgICAgICBzc2FvUGFzcy5hZGRQcmVQYXNzKHBvc2l0aW9uUGFzcyk7XHJcbiAgICAgICAgICAgIHNzYW9QYXNzLmFkZFByZVBhc3Mobm9ybWFsUGFzcyk7XHJcbiAgICAgICAgICAgIHZhciBibHVyUGFzcyA9IHRoaXMuY3JlYXRlQmx1clBhc3Moc3Nhb1Bhc3Mub3V0cHV0KTtcclxuICAgICAgICAgICAgYmx1clBhc3MuYWRkUHJlUGFzcyhzc2FvUGFzcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2JsdXJQYXNzID0gYmx1clBhc3M7XHJcbiAgICAgICAgICAgIHRoaXMuX3NzYW9QYXNzID0gc3Nhb1Bhc3M7XHJcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uUGFzcyA9IHBvc2l0aW9uUGFzcztcclxuICAgICAgICAgICAgdGhpcy5fbm9ybWFsUGFzcyA9IG5vcm1hbFBhc3M7XHJcbiAgICAgICAgICAgIHRoaXMubWFpblBhc3MgPSBuZXcgRm9yd2FyZFJlbmRlclBhc3ModGhpcy5yZW5kZXJJbnRlcmZhY2UsIHRoaXMudGFyZ2V0LCB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHtcclxuICAgICAgICAgICAgICAgICAgICBzc2FvTWFwOiBibHVyUGFzcy5vdXRwdXRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMubWFpblBhc3MuYWRkUHJlUGFzcyhibHVyUGFzcyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5tYWluUGFzcyA9IG5ldyBGb3J3YXJkUmVuZGVyUGFzcyh0aGlzLnJlbmRlckludGVyZmFjZSwgdGhpcy50YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1haW5SZW5kZXJQYXNzID0gdGhpcy5tYWluUGFzcztcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlVmVydGV4QXR0cmlidXRlUGFzczogZnVuY3Rpb24gKHByb2dyYW1OYW1lKSB7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLnJlbmRlckludGVyZmFjZS5jb250ZXh0O1xyXG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgR0xSZW5kZXJUYXJnZXQoY29udGV4dCwge1xyXG4gICAgICAgICAgICB3aWR0aDogY29udGV4dC5jYW52YXNUYXJnZXQud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogY29udGV4dC5jYW52YXNUYXJnZXQuaGVpZ2h0LFxyXG4gICAgICAgICAgICBjb2xvckZvcm1hdDogY29udGV4dC5nbC5SR0JBLFxyXG4gICAgICAgICAgICBjb2xvclR5cGU6IGNvbnRleHQuZ2wuRkxPQVQsXHJcbiAgICAgICAgICAgIGRlcHRoRm9ybWF0OiBjb250ZXh0LmdsLkRFUFRIX0NPTVBPTkVOVDE2LFxyXG4gICAgICAgICAgICBzdGVuY2lsRm9ybWF0OiBudWxsLFxyXG4gICAgICAgICAgICBkZXB0aEFzUmVuZGVyYnVmZmVyOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZXJ0ZXhBdHRyaWJ1dGVQYXNzKHRoaXMucmVuZGVySW50ZXJmYWNlLCBidWZmZXIsIHtcclxuICAgICAgICAgICAgcHJvZ3JhbU5hbWU6IHByb2dyYW1OYW1lXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZVNTQU9QYXNzOiBmdW5jdGlvbiAocG9zaXRpb25CdWZmZXIsIG5vcm1hbEJ1ZmZlcikge1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dDtcclxuICAgICAgICB2YXIgc3Nhb0J1ZmZlciA9IG5ldyBHTFJlbmRlclRhcmdldChjb250ZXh0LCB7XHJcbiAgICAgICAgICAgIHdpZHRoOiBjb250ZXh0LmNhbnZhc1RhcmdldC53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBjb250ZXh0LmNhbnZhc1RhcmdldC5oZWlnaHQsXHJcbiAgICAgICAgICAgIGNvbG9yRm9ybWF0OiBjb250ZXh0LmdsLlJHQkEsXHJcbiAgICAgICAgICAgIGRlcHRoRm9ybWF0OiBjb250ZXh0LmdsLkRFUFRIX0NPTVBPTkVOVDE2LFxyXG4gICAgICAgICAgICBzdGVuY2lsRm9ybWF0OiBudWxsLFxyXG4gICAgICAgICAgICBkZXB0aEFzUmVuZGVyYnVmZmVyOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgU1NBT1Bhc3ModGhpcy5yZW5kZXJJbnRlcmZhY2UsIHNzYW9CdWZmZXIsIHtcclxuICAgICAgICAgICAgaW5wdXRzOiB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkJ1ZmZlcjogcG9zaXRpb25CdWZmZXIsIG5vcm1hbEJ1ZmZlcjogbm9ybWFsQnVmZmVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlQmx1clBhc3M6IGZ1bmN0aW9uIChpbnB1dEJ1ZmZlcikge1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dDtcclxuICAgICAgICB2YXIgYmx1ckJ1ZmZlciA9IG5ldyBHTFJlbmRlclRhcmdldChjb250ZXh0LCB7XHJcbiAgICAgICAgICAgIHdpZHRoOiBpbnB1dEJ1ZmZlci53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBpbnB1dEJ1ZmZlci5oZWlnaHQsXHJcbiAgICAgICAgICAgIGNvbG9yRm9ybWF0OiBjb250ZXh0LmdsLlJHQkEsXHJcbiAgICAgICAgICAgIGRlcHRoRm9ybWF0OiBjb250ZXh0LmdsLkRFUFRIX0NPTVBPTkVOVDE2LFxyXG4gICAgICAgICAgICBzdGVuY2lsRm9ybWF0OiBudWxsLFxyXG4gICAgICAgICAgICBkZXB0aEFzUmVuZGVyYnVmZmVyOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgQm94Qmx1clBhc3ModGhpcy5yZW5kZXJJbnRlcmZhY2UsIGJsdXJCdWZmZXIsIHtcclxuICAgICAgICAgICAgaW5wdXRzOiB7XHJcbiAgICAgICAgICAgICAgICBidWZmZXI6IGlucHV0QnVmZmVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoc2NlbmUpIHtcclxuICAgICAgICBpZiAodGhpcy5fZW5hYmxlU1NBTykge1xyXG4gICAgICAgICAgICB0aGlzLl9wb3NpdGlvblBhc3Muc2V0UHJvY2Vzc2VkKGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5fbm9ybWFsUGFzcy5zZXRQcm9jZXNzZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLl9zc2FvUGFzcy5zZXRQcm9jZXNzZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLl9ibHVyUGFzcy5zZXRQcm9jZXNzZWQoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1haW5SZW5kZXJQYXNzLnNldFByb2Nlc3NlZChmYWxzZSk7XHJcbiAgICAgICAgQmFzZVJlbmRlclRyZWUucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMsIHNjZW5lKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UmVuZGVyU3RhdHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYWluUGFzcy5nZXRSZW5kZXJTdGF0cygpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRm9yd2FyZFJlbmRlclRyZWU7XHJcblxyXG4iLCJ2YXIgR0xDb250ZXh0ID0gcmVxdWlyZShcIi4vYmFzZS9jb250ZXh0LmpzXCIpO1xyXG52YXIgR0xTY2VuZSA9IHJlcXVpcmUoXCIuL3NjZW5lL2dsc2NlbmUuanNcIik7XHJcbnZhciBHTFNjYWxlZFJlbmRlclRhcmdldCA9IHJlcXVpcmUoXCIuL2Jhc2UvcmVuZGVydGFyZ2V0LmpzXCIpLkdMU2NhbGVkUmVuZGVyVGFyZ2V0O1xyXG52YXIgRGF0YUNoYW5nZUxpc3RlbmVyID0gcmVxdWlyZShcIi4uL3JlbmRlcmVyL3Rvb2xzL2RhdGFjaGFuZ2VsaXN0ZW5lci5qc1wiKTtcclxudmFyIFJlbmRlckludGVyZmFjZSA9IHJlcXVpcmUoXCIuL3JlbmRlci1pbnRlcmZhY2UuanNcIik7XHJcbnZhciBQaWNrT2JqZWN0UmVuZGVyUGFzcz0gcmVxdWlyZShcIi4vcmVuZGVyLXBhc3Nlcy9waWNrLW9iamVjdC5qc1wiKTtcclxudmFyIFBpY2tQb3NpdGlvblJlbmRlclBhc3MgPSByZXF1aXJlKFwiLi9yZW5kZXItcGFzc2VzL3BpY2stcG9zaXRpb24uanNcIik7XHJcbnZhciBQaWNrTm9ybWFsUmVuZGVyUGFzcyA9IHJlcXVpcmUoXCIuL3JlbmRlci1wYXNzZXMvcGljay1ub3JtYWwuanNcIik7XHJcbnZhciBGb3J3YXJkUmVuZGVyVHJlZSA9IHJlcXVpcmUoXCIuL3JlbmRlci10cmVlcy9mb3J3YXJkLmpzXCIpO1xyXG52YXIgR0xVID0gcmVxdWlyZShcIi4uLy4uL2NvbnRyaWIvZ2x1LmpzXCIpO1xyXG52YXIgT3B0aW9ucyA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9vcHRpb25zLmpzXCIpO1xyXG52YXIgTUFYX1BJQ0tfQlVGRkVSX0RJTUVOU0lPTiA9IDUxMjtcclxudmFyIHZlYzMgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLnZlYzM7XHJcbnZhciBxdWF0ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS5xdWF0O1xyXG52YXIgbWF0NCA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikubWF0NDtcclxuXHJcbnZhciBPUFRJT05fU1NBTyA9IFwicmVuZGVyZXItc3Nhb1wiO1xyXG52YXIgRkxBR1MgPSB7fTtcclxuRkxBR1NbT1BUSU9OX1NTQU9dID0ge2RlZmF1bHRWYWx1ZTogZmFsc2UsIHJlY29tcGlsZU9uQ2hhbmdlOiB0cnVlfTtcclxuZm9yICh2YXIgZmxhZyBpbiBGTEFHUykge1xyXG4gICAgT3B0aW9ucy5yZWdpc3RlcihmbGFnLCBGTEFHU1tmbGFnXS5kZWZhdWx0VmFsdWUpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydCB0aGUgZ2l2ZW4geS1jb29yZGluYXRlIG9uIHRoZSBjYW52YXMgdG8gYSB5LWNvb3JkaW5hdGUgYXBwcm9wcmlhdGUgaW5cclxuICogdGhlIEdMIGNvbnRleHQuIFRoZSB5LWNvb3JkaW5hdGUgZ2V0cyB0dXJuZWQgdXBzaWRlLWRvd24uIFRoZSBsb3dlc3QgcG9zc2libGVcclxuICogY2FudmFzIGNvb3JkaW5hdGUgaXMgMCwgc28gd2UgbmVlZCB0byBzdWJ0cmFjdCAxIGZyb20gdGhlIGhlaWdodCwgdG9vLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcclxuICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgY29udmVydGVkIHktY29vcmRpbmF0ZVxyXG4gKi9cclxudmFyIGNhbnZhc1RvR2xZID0gZnVuY3Rpb24gKGNhbnZhcywgeSkge1xyXG4gICAgcmV0dXJuIGNhbnZhcy5oZWlnaHQgLSB5IC0gMTtcclxufTtcclxuLyoqXHJcbiAqIEBpbnRlcmZhY2VcclxuICovXHJcbnZhciBJUmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XHJcbn07XHJcblxyXG5JUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclRvQ2FudmFzID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5JUmVuZGVyZXIucHJvdG90eXBlLmhhbmRsZVJlc2l6ZUV2ZW50ID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcclxufTtcclxuSVJlbmRlcmVyLnByb3RvdHlwZS5yZXF1ZXN0UmVkcmF3ID0gZnVuY3Rpb24gKHJlYXNvbikge1xyXG59O1xyXG5JUmVuZGVyZXIucHJvdG90eXBlLm5lZWRzUmVkcmF3ID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5JUmVuZGVyZXIucHJvdG90eXBlLmdldFdvcmxkU3BhY2VOb3JtYWxCeVBvaW50ID0gZnVuY3Rpb24gKG9iaiwgeCwgeSkge1xyXG59O1xyXG5JUmVuZGVyZXIucHJvdG90eXBlLmdldFdvcmxkU3BhY2VQb3NpdGlvbkJ5UG9pbnQgPSBmdW5jdGlvbiAob2JqLCB4LCB5KSB7XHJcbn07XHJcbklSZW5kZXJlci5wcm90b3R5cGUuZ2V0UmVuZGVyT2JqZWN0RnJvbVBpY2tpbmdCdWZmZXIgPSBmdW5jdGlvbiAoeCwgeSkge1xyXG59O1xyXG5JUmVuZGVyZXIucHJvdG90eXBlLmdlbmVyYXRlUmF5ID0gZnVuY3Rpb24gKHgsIHkpIHtcclxufTtcclxuSVJlbmRlcmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgPHhtbDNkPiBFbGVtZW50XHJcbiAqIEBpbXBsZW1lbnRzIHtJUmVuZGVyZXJ9XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIEdMUmVuZGVyZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2FudmFzSGFuZGxlcikge1xyXG5cclxuICAgIHRoaXMuX2NhbnZhc0hhbmRsZXIgPSBjYW52YXNIYW5kbGVyO1xyXG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhc0hhbmRsZXIuZ2V0Q2FudmFzKCk7XHJcbiAgICB0aGlzLmNvbnRleHQgPSBuZXcgR0xDb250ZXh0KGNhbnZhcywgdGhpcy5fY2FudmFzSGFuZGxlci5pZCk7XHJcbiAgICB0aGlzLnNjZW5lID0gbmV3IEdMU2NlbmUodGhpcy5jb250ZXh0KTtcclxuXHJcbiAgICB2YXIgZmFjdG9yeSA9IFhNTDNELnhtbDNkRm9ybWF0SGFuZGxlci5nZXRGYWN0b3J5KFwic2NlbmVcIiwgdGhpcy5fY2FudmFzSGFuZGxlci5pZCk7XHJcbiAgICBmYWN0b3J5LnNldFNjZW5lKHRoaXMuc2NlbmUpO1xyXG4gICAgZmFjdG9yeS5zZXRSZW5kZXJlcih0aGlzKTtcclxuXHJcbiAgICB2YXIgeG1sM2RBZGFwdGVyID0gZmFjdG9yeS5nZXRBZGFwdGVyKGVsZW1lbnQpO1xyXG4gICAgeG1sM2RBZGFwdGVyLnRyYXZlcnNlKGZ1bmN0aW9uICgpIHtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7UmVuZGVyT2JqZWN0fSAqL1xyXG4gICAgdGhpcy5waWNrZWRPYmplY3QgPSBudWxsO1xyXG5cclxuICAgIHRoaXMubmVlZHNEcmF3ID0gdHJ1ZTtcclxuICAgIHRoaXMubmVlZHNQaWNraW5nRHJhdyA9IHRydWU7XHJcbiAgICB0aGlzLmNvbnRleHQucmVxdWVzdFJlZHJhdyA9IHRoaXMucmVxdWVzdFJlZHJhdy5iaW5kKHRoaXMpO1xyXG5cclxuICAgIC8vQ3VycmVudGx5IHVzZWQgYXMgYSBoZWxwZXIgdG8gY2FsY3VsYXRlIHZpZXcgYW5kIHByb2plY3Rpb24gbWF0cmljZXMgZm9yIHJheSBjYXN0aW5nLCBzaW5jZSB0aGUgc2NlbmVcclxuICAgIC8vbXVzdCBiZSByZW5kZXJlZCBmcm9tIHRoZSBwb2ludCBvZiB2aWV3IG9mIHRoZSByYXlcclxuICAgIHRoaXMucmF5Q2FtZXJhID0gdGhpcy5zY2VuZS5jcmVhdGVSZW5kZXJWaWV3KCk7XHJcblxyXG4gICAgdGhpcy5pbml0R0woKTtcclxuICAgIHRoaXMuY2hhbmdlTGlzdGVuZXIgPSBuZXcgRGF0YUNoYW5nZUxpc3RlbmVyKHRoaXMpO1xyXG5cclxuICAgIHRoaXMucmVuZGVySW50ZXJmYWNlID0gdGhpcy5jcmVhdGVSZW5kZXJJbnRlcmZhY2UoKTtcclxuXHJcbiAgICB0aGlzLmhhbmRsZVJlc2l6ZUV2ZW50KGNhbnZhcy5jbGllbnRXaWR0aCwgY2FudmFzLmNsaWVudEhlaWdodCk7XHJcblxyXG4gICAgT3B0aW9ucy5hZGRPYnNlcnZlcih0aGlzLm9uRmxhZ3NDaGFuZ2UuYmluZCh0aGlzKSk7XHJcbn07XHJcblxyXG4vLyBKdXN0IHRvIHNhdGlzZnkganNsaW50XHJcbkdMUmVuZGVyZXIucHJvdG90eXBlLmdlbmVyYXRlUmF5ID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG5cclxuWE1MM0QuZXh0ZW5kKEdMUmVuZGVyZXIucHJvdG90eXBlLCB7XHJcbiAgICBpbml0R0w6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XHJcblxyXG4gICAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgZ2wuY2xlYXJEZXB0aCgxKTtcclxuICAgICAgICBnbC5jbGVhclN0ZW5jaWwoMCk7XHJcblxyXG4gICAgICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcclxuICAgICAgICBnbC5kZXB0aEZ1bmMoZ2wuTEVRVUFMKTtcclxuXHJcbiAgICAgICAgZ2wuZnJvbnRGYWNlKGdsLkNDVyk7XHJcbiAgICAgICAgZ2wuY3VsbEZhY2UoZ2wuQkFDSyk7XHJcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xyXG5cclxuICAgICAgICBnbC5ibGVuZEVxdWF0aW9uKGdsLkZVTkNfQUREKTtcclxuICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcclxuXHJcbiAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG5cclxuICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5QQUNLX0FMSUdOTUVOVCwgMSk7XHJcbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0FMSUdOTUVOVCwgMSk7XHJcbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XHJcbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBmYWxzZSk7XHJcbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCwgZ2wuQlJPV1NFUl9ERUZBVUxUX1dFQkdMKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGhhbmRsZVJlc2l6ZUV2ZW50OiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJ4bWwzZCBlbGVtZW50IGhhcyBpbnZhbGlkIHdpZHRoIG9yIGhlaWdodCEgRW5zdXJlIHlvdSdyZSBub3QgdXNpbmcgJ2Rpc3BsYXk6IG5vbmUnIGFuZCB0aGF0IHdpZHRoIGFuZCBoZWlnaHQgYXJlIGdyZWF0ZXIgdGhhbiAwLlwiKTtcclxuICAgICAgICAgICAgd2lkdGggPSA4MDA7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IDYwMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5oYW5kbGVSZXNpemVFdmVudCh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmNyZWF0ZURlZmF1bHRUcmVlKCk7XHJcbiAgICAgICAgdGhpcy5zY2VuZS5oYW5kbGVSZXNpemVFdmVudCh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLm5lZWRzRHJhdyA9IHRoaXMubmVlZHNQaWNraW5nRHJhdyA9IHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZURlZmF1bHRUcmVlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRyZWUgPSBuZXcgRm9yd2FyZFJlbmRlclRyZWUodGhpcy5yZW5kZXJJbnRlcmZhY2UsIE9wdGlvbnMuZ2V0VmFsdWUoT1BUSU9OX1NTQU8pKTtcclxuICAgICAgICB0aGlzLnJlbmRlckludGVyZmFjZS5zZXRSZW5kZXJUcmVlKHRyZWUpO1xyXG5cclxuICAgICAgICB2YXIgcGlja1RhcmdldCA9IG5ldyBHTFNjYWxlZFJlbmRlclRhcmdldCh0aGlzLmNvbnRleHQsIE1BWF9QSUNLX0JVRkZFUl9ESU1FTlNJT04sIHtcclxuICAgICAgICAgICAgd2lkdGg6IHRoaXMuY29udGV4dC5jYW52YXNUYXJnZXQud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5jb250ZXh0LmNhbnZhc1RhcmdldC5oZWlnaHQsXHJcbiAgICAgICAgICAgIGNvbG9yRm9ybWF0OiB0aGlzLmNvbnRleHQuZ2wuUkdCQSxcclxuICAgICAgICAgICAgZGVwdGhGb3JtYXQ6IHRoaXMuY29udGV4dC5nbC5ERVBUSF9DT01QT05FTlQxNixcclxuICAgICAgICAgICAgc3RlbmNpbEZvcm1hdDogbnVsbCxcclxuICAgICAgICAgICAgZGVwdGhBc1JlbmRlcmJ1ZmZlcjogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucGlja09iamVjdFBhc3MgPSBuZXcgUGlja09iamVjdFJlbmRlclBhc3ModGhpcy5yZW5kZXJJbnRlcmZhY2UsIHBpY2tUYXJnZXQpO1xyXG4gICAgICAgIHRoaXMucGlja1Bvc2l0aW9uUGFzcyA9IG5ldyBQaWNrUG9zaXRpb25SZW5kZXJQYXNzKHRoaXMucmVuZGVySW50ZXJmYWNlLCBwaWNrVGFyZ2V0KTtcclxuICAgICAgICB0aGlzLnBpY2tOb3JtYWxQYXNzID0gbmV3IFBpY2tOb3JtYWxSZW5kZXJQYXNzKHRoaXMucmVuZGVySW50ZXJmYWNlLCBwaWNrVGFyZ2V0KTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlUmVuZGVySW50ZXJmYWNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZW5kZXJJbnRlcmZhY2UodGhpcy5jb250ZXh0LCB0aGlzLnNjZW5lKTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVxdWVzdFJlZHJhdzogZnVuY3Rpb24gKHJlYXNvbikge1xyXG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKFwiUmVxdWVzdCByZWRyYXcgYmVjYXVzZTpcIiwgcmVhc29uKTtcclxuICAgICAgICB0aGlzLm5lZWRzRHJhdyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5uZWVkc1BpY2tpbmdEcmF3ID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0V29ybGRTcGFjZU5vcm1hbEJ5UG9pbnQ6IGZ1bmN0aW9uICh4LCB5LCBvYmplY3QpIHtcclxuICAgICAgICB2YXIgb2JqID0gb2JqZWN0IHx8IHRoaXMucGlja2VkT2JqZWN0O1xyXG4gICAgICAgIGlmICghb2JqKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB5ID0gY2FudmFzVG9HbFkodGhpcy5fY2FudmFzSGFuZGxlci5nZXRDYW52YXMoKSwgeSk7XHJcbiAgICAgICAgdGhpcy5waWNrTm9ybWFsUGFzcy5yZW5kZXIob2JqKTtcclxuICAgICAgICB0aGlzLm5lZWRzUGlja2luZ0RyYXcgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBpY2tOb3JtYWxQYXNzLnJlYWROb3JtYWxGcm9tUGlja2luZ0J1ZmZlcih4LCB5KTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0V29ybGRTcGFjZVBvc2l0aW9uQnlQb2ludDogZnVuY3Rpb24gKHgsIHksIG9iamVjdCkge1xyXG4gICAgICAgIHZhciBvYmogPSBvYmplY3QgfHwgdGhpcy5waWNrZWRPYmplY3Q7XHJcbiAgICAgICAgaWYgKCFvYmopXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIHkgPSBjYW52YXNUb0dsWSh0aGlzLl9jYW52YXNIYW5kbGVyLmdldENhbnZhcygpLCB5KTtcclxuICAgICAgICB0aGlzLnBpY2tQb3NpdGlvblBhc3MucmVuZGVyKG9iaik7XHJcbiAgICAgICAgdGhpcy5uZWVkc1BpY2tpbmdEcmF3ID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5waWNrUG9zaXRpb25QYXNzLnJlYWRQb3NpdGlvbkZyb21QaWNraW5nQnVmZmVyKHgsIHkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRSZW5kZXJPYmplY3RCeVJheTogZnVuY3Rpb24gKHhtbDNkUmF5LCB2aWV3TWF0LCBwcm9qTWF0KSB7XHJcbiAgICAgICAgdmFyIGludGVyc2VjdGVkT2JqZWN0cyA9IHRoaXMuc2NlbmUuZmluZFJheUludGVyc2VjdGlvbnMoeG1sM2RSYXkpO1xyXG4gICAgICAgIHRoaXMucGlja09iamVjdFBhc3MucmVuZGVyKGludGVyc2VjdGVkT2JqZWN0cywgdmlld01hdCwgcHJvak1hdCk7XHJcbiAgICAgICAgLy9UYXJnZXQgdGhlIG1pZGRsZSBvZiB0aGUgYnVmZmVyXHJcbiAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKHRoaXMucGlja09iamVjdFBhc3Mub3V0cHV0LmdldFdpZHRoKCkgLyAyIC8gdGhpcy5waWNrT2JqZWN0UGFzcy5vdXRwdXQuZ2V0U2NhbGUoKSk7XHJcbiAgICAgICAgdmFyIHkgPSBNYXRoLmZsb29yKHRoaXMucGlja09iamVjdFBhc3Mub3V0cHV0LmdldEhlaWdodCgpIC8gMiAvIHRoaXMucGlja09iamVjdFBhc3Mub3V0cHV0LmdldFNjYWxlKCkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBpY2tPYmplY3RQYXNzLmdldFJlbmRlck9iamVjdEZyb21QaWNraW5nQnVmZmVyKHgsIHksIGludGVyc2VjdGVkT2JqZWN0cyk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRXb3JsZFNwYWNlTm9ybWFsQnlSYXk6IGZ1bmN0aW9uIChyYXksIGludGVyc2VjdGVkT2JqZWN0LCB2aWV3TWF0LCBwcm9qTWF0KSB7XHJcbiAgICAgICAgaWYgKCFpbnRlcnNlY3RlZE9iamVjdClcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgdGhpcy5waWNrTm9ybWFsUGFzcy5yZW5kZXIoaW50ZXJzZWN0ZWRPYmplY3QsIHZpZXdNYXQsIHByb2pNYXQpO1xyXG4gICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcih0aGlzLnBpY2tOb3JtYWxQYXNzLm91dHB1dC5nZXRXaWR0aCgpIC8gMiAvIHRoaXMucGlja05vcm1hbFBhc3Mub3V0cHV0LmdldFNjYWxlKCkpO1xyXG4gICAgICAgIHZhciB5ID0gTWF0aC5mbG9vcih0aGlzLnBpY2tOb3JtYWxQYXNzLm91dHB1dC5nZXRIZWlnaHQoKSAvIDIgLyB0aGlzLnBpY2tOb3JtYWxQYXNzLm91dHB1dC5nZXRTY2FsZSgpKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5waWNrTm9ybWFsUGFzcy5yZWFkTm9ybWFsRnJvbVBpY2tpbmdCdWZmZXIoeCwgeSk7XHJcblxyXG4gICAgfSwgZ2V0V29ybGRTcGFjZVBvc2l0aW9uQnlSYXk6IGZ1bmN0aW9uIChyYXksIGludGVyc2VjdGVkT2JqZWN0LCB2aWV3TWF0LCBwcm9qTWF0KSB7XHJcbiAgICAgICAgaWYgKCFpbnRlcnNlY3RlZE9iamVjdClcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgdGhpcy5waWNrUG9zaXRpb25QYXNzLnJlbmRlcihpbnRlcnNlY3RlZE9iamVjdCwgdmlld01hdCwgcHJvak1hdCk7XHJcbiAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKHRoaXMucGlja1Bvc2l0aW9uUGFzcy5vdXRwdXQuZ2V0V2lkdGgoKSAvIDIgLyB0aGlzLnBpY2tQb3NpdGlvblBhc3Mub3V0cHV0LmdldFNjYWxlKCkpO1xyXG4gICAgICAgIHZhciB5ID0gTWF0aC5mbG9vcih0aGlzLnBpY2tQb3NpdGlvblBhc3Mub3V0cHV0LmdldEhlaWdodCgpIC8gMiAvIHRoaXMucGlja1Bvc2l0aW9uUGFzcy5vdXRwdXQuZ2V0U2NhbGUoKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGlja1Bvc2l0aW9uUGFzcy5yZWFkUG9zaXRpb25Gcm9tUGlja2luZ0J1ZmZlcih4LCB5KTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGNhbGN1bGF0ZU1hdHJpY2VzRm9yUmF5OiBmdW5jdGlvbiAocmF5LCB2aWV3TWF0LCBwcm9qTWF0KSB7XHJcbiAgICAgICAgbWF0NC5tdWx0aXBseSh2aWV3TWF0LCBtYXQ0LmZyb21UcmFuc2xhdGlvbih2aWV3TWF0LCByYXkub3JpZ2luLmRhdGEpLCB0aGlzLmNhbGN1bGF0ZU9yaWVudGF0aW9uRm9yUmF5RGlyZWN0aW9uKHJheSkpO1xyXG4gICAgICAgIHRoaXMucmF5Q2FtZXJhLnNldExvY2FsTWF0cml4KHZpZXdNYXQpO1xyXG4gICAgICAgIHRoaXMucmF5Q2FtZXJhLmdldFdvcmxkVG9WaWV3TWF0cml4KHZpZXdNYXQpO1xyXG4gICAgICAgIHZhciBhc3BlY3QgPSB0aGlzLnBpY2tPYmplY3RQYXNzLm91dHB1dC5nZXRXaWR0aCgpIC8gdGhpcy5waWNrT2JqZWN0UGFzcy5vdXRwdXQuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgdGhpcy5yYXlDYW1lcmEuZ2V0UHJvamVjdGlvbk1hdHJpeChwcm9qTWF0LCBhc3BlY3QpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjYWxjdWxhdGVPcmllbnRhdGlvbkZvclJheURpcmVjdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdG1wWCA9IHZlYzMuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIHRtcFkgPSB2ZWMzLmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciB0bXBaID0gdmVjMy5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgdXAgPSB2ZWMzLmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBxID0gcXVhdC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgbSA9IG1hdDQuY3JlYXRlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocmF5KSB7XHJcbiAgICAgICAgICAgIHZlYzMuc2V0KHVwLCAwLCAxLCAwKTtcclxuICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXBYLCByYXkuZGlyZWN0aW9uLmRhdGEsIHVwKTtcclxuICAgICAgICAgICAgaWYgKCF2ZWMzLmxlbmd0aCh0bXBYKSkge1xyXG4gICAgICAgICAgICAgICAgdmVjMy5zZXQodG1wWCwgMSwgMCwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXBZLCB0bXBYLCByYXkuZGlyZWN0aW9uLmRhdGEpO1xyXG4gICAgICAgICAgICB2ZWMzLm5lZ2F0ZSh0bXBaLCByYXkuZGlyZWN0aW9uLmRhdGEpO1xyXG5cclxuICAgICAgICAgICAgWE1MM0QubWF0aC5xdWF0LnNldEZyb21CYXNpcyhxLCB0bXBYLCB0bXBZLCB0bXBaKTtcclxuICAgICAgICAgICAgbWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvbihtLCBxLCBbMCwwLDBdKTtcclxuICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgfVxyXG4gICAgfSkoKSxcclxuXHJcbiAgICBuZWVkc1JlZHJhdzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5lZWRzRHJhdztcclxuICAgIH0sXHJcblxyXG4gICAgcmVuZGVyVG9DYW52YXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnByZXBhcmVSZW5kZXJpbmcoKTtcclxuICAgICAgICB0aGlzLnJlbmRlckludGVyZmFjZS5nZXRSZW5kZXJUcmVlKCkucmVuZGVyKHRoaXMuc2NlbmUpO1xyXG4gICAgICAgIHZhciBzdGF0cyA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmdldFJlbmRlclRyZWUoKS5nZXRSZW5kZXJTdGF0cygpO1xyXG4gICAgICAgIHRoaXMubmVlZHNEcmF3ID0gZmFsc2U7IC8vU2V0IHRoaXMgbGF0ZSwgYmVjYXVzZSByZWRyYXcgbWlnaHQgYmUgdHJpZ2dlcmVkIGR1cmluZyByZW5kZXJpbmcgKFRPRE86IGF2b2lkIHRoYXQhKVxyXG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKFwiUmVuZGVyZWQgdG8gQ2FudmFzXCIpO1xyXG4gICAgICAgIHJldHVybiBzdGF0cztcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UmVuZGVyT2JqZWN0RnJvbVBpY2tpbmdCdWZmZXI6IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgeSA9IGNhbnZhc1RvR2xZKHRoaXMuX2NhbnZhc0hhbmRsZXIuZ2V0Q2FudmFzKCksIHkpO1xyXG4gICAgICAgIHZhciB3b3JsZFRvVmlld01hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XHJcbiAgICAgICAgaWYgKHRoaXMubmVlZHNQaWNraW5nRHJhdykge1xyXG4gICAgICAgICAgICB0aGlzLm5lZWRzUGlja2luZ0RyYXcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5wcmVwYXJlUmVuZGVyaW5nKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmUudXBkYXRlUmVhZHlPYmplY3RzRnJvbUFjdGl2ZVZpZXcodGhpcy5waWNrT2JqZWN0UGFzcy5vdXRwdXQuZ2V0V2lkdGgoKSAvIHRoaXMucGlja09iamVjdFBhc3Mub3V0cHV0LmdldEhlaWdodCgpKTtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZS5nZXRBY3RpdmVWaWV3KCkuZ2V0V29ybGRUb1ZpZXdNYXRyaXgod29ybGRUb1ZpZXdNYXRyaXgpO1xyXG4gICAgICAgICAgICB0aGlzLnBpY2tPYmplY3RQYXNzLnJlbmRlcih0aGlzLnNjZW5lLnJlYWR5LCB3b3JsZFRvVmlld01hdHJpeCk7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKFwiUmVuZGVyZWQgUGlja2luZyBCdWZmZXJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGlja2VkT2JqZWN0ID0gdGhpcy5waWNrT2JqZWN0UGFzcy5nZXRSZW5kZXJPYmplY3RGcm9tUGlja2luZ0J1ZmZlcih4LCB5LCB0aGlzLnNjZW5lLnJlYWR5KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5waWNrZWRPYmplY3Q7XHJcbiAgICB9LFxyXG5cclxuICAgIHByZXBhcmVSZW5kZXJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnNjZW5lLnVwZGF0ZSgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZXMgZ2x1VW5Qcm9qZWN0KCkgdG8gdHJhbnNmb3JtIHRoZSAyRCBzY3JlZW4gcG9pbnQgdG8gYSAzRCByYXkuXHJcbiAgICAgKiBOb3QgdGVzdGVkISFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2FudmFzWFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNhbnZhc1lcclxuICAgICAqL1xyXG4gICAgZ2VuZXJhdGVSYXk6IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBjX3ZpZXdNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBjX3Byb2plY3Rpb25NYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNhbnZhc1gsIGNhbnZhc1kpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBnbFkgPSBjYW52YXNUb0dsWSh0aGlzLl9jYW52YXNIYW5kbGVyLmdldENhbnZhcygpLCBjYW52YXNZKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHNldHVwIGlucHV0IHRvIHVucHJvamVjdFxyXG4gICAgICAgICAgICB2YXIgdmlld3BvcnQgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xyXG4gICAgICAgICAgICB2aWV3cG9ydFswXSA9IDA7XHJcbiAgICAgICAgICAgIHZpZXdwb3J0WzFdID0gMDtcclxuICAgICAgICAgICAgdmlld3BvcnRbMl0gPSB0aGlzLndpZHRoO1xyXG4gICAgICAgICAgICB2aWV3cG9ydFszXSA9IHRoaXMuaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgLy8gZ2V0IHZpZXcgYW5kIHByb2plY3Rpb24gbWF0cml4IGFycmF5c1xyXG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMuc2NlbmUuZ2V0QWN0aXZlVmlldygpO1xyXG4gICAgICAgICAgICB2aWV3LmdldFdvcmxkVG9WaWV3TWF0cml4KGNfdmlld01hdHJpeCk7XHJcbiAgICAgICAgICAgIHZpZXcuZ2V0UHJvamVjdGlvbk1hdHJpeChjX3Byb2plY3Rpb25NYXRyaXgsIHZpZXdwb3J0WzJdIC8gdmlld3BvcnRbM10pO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJheSA9IG5ldyBYTUwzRC5SYXkoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBuZWFySGl0ID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcclxuICAgICAgICAgICAgdmFyIGZhckhpdCA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XHJcblxyXG4gICAgICAgICAgICAvLyBkbyB1bnByb2plY3Rpb25zXHJcbiAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gR0xVLnVuUHJvamVjdChjYW52YXNYLCBnbFksIDAsIGNfdmlld01hdHJpeCwgY19wcm9qZWN0aW9uTWF0cml4LCB2aWV3cG9ydCwgbmVhckhpdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByYXk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gR0xVLnVuUHJvamVjdChjYW52YXNYLCBnbFksIDEsIGNfdmlld01hdHJpeCwgY19wcm9qZWN0aW9uTWF0cml4LCB2aWV3cG9ydCwgZmFySGl0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJheTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHJheVxyXG4gICAgICAgICAgICBtYXQ0LmludmVydChjX3ZpZXdNYXRyaXgsIGNfdmlld01hdHJpeCk7XHJcbiAgICAgICAgICAgIHJheS5vcmlnaW4gPSB2ZWMzLmZyb21WYWx1ZXMoY192aWV3TWF0cml4WzEyXSwgY192aWV3TWF0cml4WzEzXSwgY192aWV3TWF0cml4WzE0XSk7XHJcbiAgICAgICAgICAgIHJheS5kaXJlY3Rpb24gPSB2ZWMzLmZyb21WYWx1ZXMoZmFySGl0WzBdIC0gbmVhckhpdFswXSwgZmFySGl0WzFdIC0gbmVhckhpdFsxXSwgZmFySGl0WzJdIC0gbmVhckhpdFsyXSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmF5O1xyXG4gICAgICAgIH1cclxuICAgIH0oKSksXHJcblxyXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2NlbmUuY2xlYXIoKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UmVuZGVySW50ZXJmYWNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVySW50ZXJmYWNlO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbkZsYWdzQ2hhbmdlOiBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgaWYgKGtleSA9PSBPUFRJT05fU1NBTykge1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lLnNoYWRlckZhY3Rvcnkuc2V0U2hhZGVyUmVjb21waWxlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRGVmYXVsdFRyZWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVkcmF3KFwiZ2xvYmFsIG9wdGlvbiBjaGFuZ2VkXCIpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR0xSZW5kZXJlcjtcclxuIiwidmFyIFhmbG93TWVzaCA9IHJlcXVpcmUoXCIuLi94Zmxvdy94Zmxvdy1tZXNoLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIERyYXdhYmxlRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuWE1MM0QuZXh0ZW5kKERyYXdhYmxlRmFjdG9yeS5wcm90b3R5cGUsIHtcclxuICAgIGNyZWF0ZURyYXdhYmxlOiBmdW5jdGlvbiAob2JqLCBjb250ZXh0KSB7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJEcmF3YWJsZUZhY3Rvcnk6OmNyZWF0ZURyYXdhYmxlXCIsIG9iaik7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBYZmxvd01lc2goY29udGV4dCwgb2JqLmNvbmZpZ3VyYXRpb24sIHtib3VuZGluZ0JveENoYW5nZWQ6IG9iai5zZXRPYmplY3RTcGFjZUJvdW5kaW5nQm94LmJpbmQob2JqKX0pO1xyXG4gICAgICAgICAgICBvYmoubWVzaCA9IHJlc3VsdC5nZXRNZXNoKCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihlLCBvYmoubm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERyYXdhYmxlRmFjdG9yeTtcclxuXHJcblxyXG4iLCJ2YXIgbGlnaHRNb2RlbHMgPSB7XHJcbiAgICBwb2ludDoge1xyXG4gICAgICAgIHBhcmFtZXRlcnM6IFsgXCJwb2ludExpZ2h0UG9zaXRpb25cIiwgXCJwb2ludExpZ2h0QXR0ZW51YXRpb25cIiwgXCJwb2ludExpZ2h0SW50ZW5zaXR5XCIsIFwicG9pbnRMaWdodE9uXCIsIFwicG9pbnRMaWdodENhc3RTaGFkb3dcIiwgXCJwb2ludExpZ2h0TWF0cml4XCIsIFwicG9pbnRMaWdodFNoYWRvd0JpYXNcIiwgXCJwb2ludExpZ2h0TmVhckZhclwiLCBcInBvaW50TGlnaHRTaGFkb3dNYXBcIl1cclxuICAgIH0sXHJcbiAgICBkaXJlY3Rpb25hbDoge1xyXG4gICAgICAgIHBhcmFtZXRlcnM6IFtcImRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25cIiwgXCJkaXJlY3Rpb25hbExpZ2h0SW50ZW5zaXR5XCIsIFwiZGlyZWN0aW9uYWxMaWdodE9uXCIsIFwiZGlyZWN0aW9uYWxMaWdodENhc3RTaGFkb3dcIiwgXCJkaXJlY3Rpb25hbExpZ2h0TWF0cml4XCIsIFwiZGlyZWN0aW9uYWxMaWdodFNoYWRvd0JpYXNcIiwgXCJkaXJlY3Rpb25hbExpZ2h0U2hhZG93TWFwXCJdXHJcbiAgICB9LFxyXG4gICAgc3BvdDoge1xyXG4gICAgICAgIHBhcmFtZXRlcnM6IFtcInNwb3RMaWdodEF0dGVudWF0aW9uXCIsIFwic3BvdExpZ2h0UG9zaXRpb25cIiwgXCJzcG90TGlnaHRJbnRlbnNpdHlcIiwgXCJzcG90TGlnaHREaXJlY3Rpb25cIiwgXCJzcG90TGlnaHRPblwiLCBcInNwb3RMaWdodFNvZnRuZXNzXCIsIFwic3BvdExpZ2h0Q29zQ3V0b2ZmQW5nbGVcIiwgXCJzcG90TGlnaHRDb3NTb2Z0Q3V0b2ZmQW5nbGVcIiwgXCJzcG90TGlnaHRDYXN0U2hhZG93XCIsIFwic3BvdExpZ2h0TWF0cml4XCIsIFwic3BvdExpZ2h0U2hhZG93Qmlhc1wiLCBcInNwb3RMaWdodFNoYWRvd01hcFwiXVxyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIEFMTF9QQVJBTUVURVJTID0gbGlnaHRNb2RlbHMucG9pbnQucGFyYW1ldGVycy5jb25jYXQobGlnaHRNb2RlbHMuZGlyZWN0aW9uYWwucGFyYW1ldGVycykuY29uY2F0KGxpZ2h0TW9kZWxzLnNwb3QucGFyYW1ldGVycyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIEFMTF9QQVJBTUVURVJTOiBBTExfUEFSQU1FVEVSU1xyXG59O1xyXG4iLCJ2YXIgU2NlbmUgPSByZXF1aXJlKFwiLi8uLi8uLi9yZW5kZXJlci9zY2VuZS9zY2VuZS5qc1wiKTtcclxudmFyIERyYXdhYmxlRmFjdG9yeSA9IHJlcXVpcmUoXCIuL2RyYXdhYmxlLWZhY3RvcnkuanNcIik7XHJcbnZhciBDID0gcmVxdWlyZShcIi4vLi4vLi4vcmVuZGVyZXIvc2NlbmUvY29uc3RhbnRzLmpzXCIpO1xyXG52YXIgRnJ1c3R1bVRlc3QgPSByZXF1aXJlKFwiLi8uLi8uLi9yZW5kZXJlci90b29scy9mcnVzdHVtLmpzXCIpLkZydXN0dW1UZXN0O1xyXG52YXIgU2hhZGVyQ29tcG9zZXJGYWN0b3J5ID0gcmVxdWlyZShcIi4uL21hdGVyaWFscy9zaGFkZXJjb21wb3NlcmZhY3RvcnkuanNcIik7XHJcbnZhciBPcHRpb25zID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL29wdGlvbnMuanNcIik7XHJcbnZhciBTaGFkb3dNYXBTZXJ2aWNlID0gcmVxdWlyZShcIi4uL21hdGVyaWFscy9zaGFkb3dtYXAtc2VydmljZVwiKTtcclxudmFyIG1hdDQgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLm1hdDQ7XHJcblxyXG52YXIgT1BUSU9OX0ZSVVNUVU1fQ1VMTElORyA9IFwicmVuZGVyZXItZnJ1c3R1bS1jdWxsaW5nXCI7XHJcbnZhciBPUFRJT05fU0hBREVKU19FWFRSQUNUX1VOSUZPUk1TID0gXCJzaGFkZWpzLWV4dHJhY3RVbmlmb3JtRXhwcmVzc2lvbnNcIjtcclxudmFyIE9QVElPTl9TSEFERUpTX1RSQU5TRk9STV9TUEFDRVMgPSBcInNoYWRlanMtdHJhbnNmb3JtU3BhY2VzXCI7XHJcbnZhciBPUFRJT05fU0hBREVKU19DQUNIRSA9IFwic2hhZGVqcy1jYWNoZVwiO1xyXG5cclxuXHJcbi8vIEFsbCB0aGUgc2hhZGVyIGZsYWdzXHJcbnZhciBGTEFHUyA9IHt9O1xyXG5GTEFHU1tPUFRJT05fU0hBREVKU19FWFRSQUNUX1VOSUZPUk1TXSA9IHtkZWZhdWx0VmFsdWU6IGZhbHNlLCByZWNvbXBpbGVPbkNoYW5nZTogdHJ1ZX07XHJcbkZMQUdTW09QVElPTl9TSEFERUpTX1RSQU5TRk9STV9TUEFDRVNdID0ge2RlZmF1bHRWYWx1ZTogdHJ1ZSwgcmVjb21waWxlT25DaGFuZ2U6IHRydWV9O1xyXG5GTEFHU1tPUFRJT05fRlJVU1RVTV9DVUxMSU5HXSA9IHtkZWZhdWx0VmFsdWU6IHRydWUsIHJlY29tcGlsZU9uQ2hhbmdlOiBmYWxzZX07XHJcbkZMQUdTW09QVElPTl9TSEFERUpTX0NBQ0hFXSA9IHtkZWZhdWx0VmFsdWU6IHRydWUsIHJlY29tcGlsZU9uQ2hhbmdlOiBmYWxzZX07XHJcblxyXG5mb3IgKHZhciBmbGFnIGluIEZMQUdTKSB7XHJcbiAgICBPcHRpb25zLnJlZ2lzdGVyKGZsYWcsIEZMQUdTW2ZsYWddLmRlZmF1bHRWYWx1ZSk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHtHTENvbnRleHR9IGNvbnRleHRcclxuICogQGV4dGVuZHMge1NjZW5lfVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBHTFNjZW5lID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgIFNjZW5lLmNhbGwodGhpcyk7XHJcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgdGhpcy5zaGFkZXJGYWN0b3J5ID0gbmV3IFNoYWRlckNvbXBvc2VyRmFjdG9yeShjb250ZXh0KTtcclxuICAgIHRoaXMuZHJhd2FibGVGYWN0b3J5ID0gbmV3IERyYXdhYmxlRmFjdG9yeSgpO1xyXG5cclxuICAgIHRoaXMuc2hhZG93TWFwU2VydmljZSA9IG5ldyBTaGFkb3dNYXBTZXJ2aWNlKGNvbnRleHQsIHRoaXMpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7QXJyYXkuPFJlbmRlck9iamVjdD59XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVhZHkgPSBbXTtcclxuICAgIHRoaXMucXVldWUgPSBbXTtcclxuICAgIHRoaXMubGlnaHRzTmVlZFVwZGF0ZSA9IHRydWU7XHJcbiAgICB0aGlzLnN5c3RlbVVuaWZvcm1zID0ge307XHJcbiAgICB0aGlzLmRlZmVycmVkID0gd2luZG93WydYTUwzRF9ERUZFUlJFRCddIHx8IGZhbHNlO1xyXG4gICAgdGhpcy5jb2xvckNsb3N1cmVTaWduYXR1cmVzID0gW107XHJcbiAgICB0aGlzLmRvRnJ1c3R1bUN1bGxpbmcgPSAhIU9wdGlvbnMuZ2V0VmFsdWUoT1BUSU9OX0ZSVVNUVU1fQ1VMTElORyk7XHJcbiAgICB0aGlzLmFkZExpc3RlbmVycygpO1xyXG59O1xyXG5cclxuWE1MM0QuY3JlYXRlQ2xhc3MoR0xTY2VuZSwgU2NlbmUpO1xyXG5cclxuZnVuY3Rpb24gcmVtb3ZlU2FmZShhcnIsIG9iaikge1xyXG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2Yob2JqKTtcclxuICAgIGlmIChpbmRleCAhPSAtMSkge1xyXG4gICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5YTUwzRC5leHRlbmQoR0xTY2VuZS5wcm90b3R5cGUsIHtcclxuICAgIHJlbW92ZTogZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHJlbW92ZVNhZmUodGhpcy5xdWV1ZSwgb2JqKTtcclxuICAgICAgICByZW1vdmVTYWZlKHRoaXMucmVhZHksIG9iaik7XHJcbiAgICB9LFxyXG5cclxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5yZWFkeSA9IFtdO1xyXG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcclxuICAgICAgICB0aGlzLmFjdGl2ZVZpZXcucmVtb3ZlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIG1vdmVGcm9tUXVldWVUb1JlYWR5OiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgaWYgKHJlbW92ZVNhZmUodGhpcy5xdWV1ZSwgb2JqKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlYWR5LnB1c2gob2JqKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG1vdmVGcm9tUmVhZHlUb1F1ZXVlOiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgaWYgKHJlbW92ZVNhZmUodGhpcy5yZWFkeSwgb2JqKSkge1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gob2JqKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxpZ2h0c05lZWRVcGRhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5saWdodHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGlnaHRQYXJhbWV0ZXJzKCk7XHJcbiAgICAgICAgICAgIHRoaXMubGlnaHRzLmxpZ2h0VmFsdWVDaGFuZ2VkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlT2JqZWN0c0ZvclJlbmRlcmluZygpO1xyXG5cclxuICAgICAgICAvLyBSZW5kZXIgc2hhZG93IG1hcHMgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgdGhpcy5zaGFkb3dNYXBTZXJ2aWNlLnVwZGF0ZUZvclJlbmRlcmluZygpO1xyXG5cclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBzaGFkZXJzIGFyZSB1cGRhdGVzIEFGVEVSIG9iamVjdHNcclxuICAgICAgICAvLyBCZWNhdXNlIHVudXNlZCBzaGFkZXIgY2xvc3VyZXMgYXJlIGNsZWFyZWQgb24gdXBkYXRlXHJcbiAgICAgICAgdGhpcy51cGRhdGVTaGFkZXJzKCk7XHJcbiAgICB9LCB1cGRhdGVMaWdodFBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGFyYW1ldGVycyA9IHRoaXMuc3lzdGVtVW5pZm9ybXM7XHJcblxyXG4gICAgICAgIHRoaXMubGlnaHRzLmZpbGxHbG9iYWxQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuc2hhZG93TWFwU2VydmljZS5maWxsR2xvYmFsUGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcclxuXHJcbiAgICAgICAgLy8gRGVyaXZlZCBwYXJhbWV0ZXJzIHRoYXQgYXJlIGltcGxlbWVudGF0aW9uIHNwZWNpZmljLlxyXG4gICAgICAgIC8vIFRPRE86IFB1dCB0aG9zZSB0byBhbiBhcHByb3ByaWF0ZSBwbGFjZVxyXG4gICAgICAgIHZhciBzcG90TGlnaHRDdXRvZmZBbmdsZSA9IHBhcmFtZXRlcnNbXCJzcG90TGlnaHRDdXRvZmZBbmdsZVwiXTtcclxuICAgICAgICB2YXIgc3BvdExpZ2h0U29mdG5lc3MgPSBwYXJhbWV0ZXJzW1wic3BvdExpZ2h0U29mdG5lc3NcIl07XHJcbiAgICAgICAgaWYoc3BvdExpZ2h0Q3V0b2ZmQW5nbGUpIHtcclxuICAgICAgICAgICAgLy8gTWFwIGJvdGggcGFyYW1ldGVycyBpbnRvIGNvc2ludXMgc3BhY2VcclxuICAgICAgICAgICAgdmFyIHNwb3RMaWdodENvc1NvZnRDdXRvZmZBbmdsZSA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgc3BvdExpZ2h0Q29zQ3V0b2ZmQW5nbGUgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcG90TGlnaHRDdXRvZmZBbmdsZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc3BvdExpZ2h0Q29zQ3V0b2ZmQW5nbGVbaV0gPSBNYXRoLmNvcyhzcG90TGlnaHRDdXRvZmZBbmdsZVtpXSk7XHJcbiAgICAgICAgICAgICAgICBzcG90TGlnaHRDb3NTb2Z0Q3V0b2ZmQW5nbGVbaV0gPSBNYXRoLmNvcyhzcG90TGlnaHRDdXRvZmZBbmdsZVtpXSAqICgxLjAgLSBzcG90TGlnaHRTb2Z0bmVzc1tpXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcmFtZXRlcnNbXCJzcG90TGlnaHRDb3NDdXRvZmZBbmdsZVwiXSA9IHNwb3RMaWdodENvc0N1dG9mZkFuZ2xlO1xyXG4gICAgICAgICAgICBwYXJhbWV0ZXJzW1wic3BvdExpZ2h0Q29zU29mdEN1dG9mZkFuZ2xlXCJdID0gc3BvdExpZ2h0Q29zU29mdEN1dG9mZkFuZ2xlO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVTeXN0ZW1Vbmlmb3JtczogZnVuY3Rpb24gKG5hbWVzKSB7XHJcbiAgICAgICAgdGhpcy5zaGFkZXJGYWN0b3J5LnVwZGF0ZVN5c3RlbVVuaWZvcm1zKG5hbWVzLCB0aGlzKTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlU2hhZGVyczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2hhZGVyRmFjdG9yeS51cGRhdGUodGhpcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZU9iamVjdHNGb3JSZW5kZXJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICBvYmoudXBkYXRlRm9yUmVuZGVyaW5nKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZvckVhY2g6IGZ1bmN0aW9uIChmdW5jLCB0aGF0KSB7XHJcbiAgICAgICAgdGhpcy5xdWV1ZS5zbGljZSgpLmZvckVhY2goZnVuYywgdGhhdCk7XHJcbiAgICAgICAgdGhpcy5yZWFkeS5zbGljZSgpLmZvckVhY2goZnVuYywgdGhhdCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZVJlYWR5T2JqZWN0c0Zyb21BY3RpdmVWaWV3OiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjX3dvcmxkVG9WaWV3TWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgY192aWV3VG9Xb3JsZE1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIGNfcHJvak1hdF90bXAgPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBjX2Jib3ggPSBuZXcgWE1MM0QuQm94KCk7XHJcbiAgICAgICAgdmFyIGNfZnJ1c3R1bVRlc3QgPSBuZXcgRnJ1c3R1bVRlc3QoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhc3BlY3RSYXRpbykge1xyXG4gICAgICAgICAgICB2YXIgYWN0aXZlVmlldyA9IHRoaXMuZ2V0QWN0aXZlVmlldygpLCByZWFkeU9iamVjdHMgPSB0aGlzLnJlYWR5LCBpLCBsLCBvYmo7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWxsIE1WIG1hdHJpY2VzXHJcbiAgICAgICAgICAgIGFjdGl2ZVZpZXcuZ2V0V29ybGRUb1ZpZXdNYXRyaXgoY193b3JsZFRvVmlld01hdHJpeCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gcmVhZHlPYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgb2JqID0gcmVhZHlPYmplY3RzW2ldO1xyXG4gICAgICAgICAgICAgICAgb2JqLnVwZGF0ZU1vZGVsVmlld01hdHJpeChjX3dvcmxkVG9WaWV3TWF0cml4KTtcclxuICAgICAgICAgICAgICAgIG9iai51cGRhdGVNb2RlbE1hdHJpeE4oKTtcclxuICAgICAgICAgICAgICAgIG9iai51cGRhdGVNb2RlbFZpZXdNYXRyaXhOKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCgpO1xyXG5cclxuICAgICAgICAgICAgYWN0aXZlVmlldy5nZXRQcm9qZWN0aW9uTWF0cml4KGNfcHJvak1hdF90bXAsIGFzcGVjdFJhdGlvKTtcclxuICAgICAgICAgICAgYWN0aXZlVmlldy5nZXRWaWV3VG9Xb3JsZE1hdHJpeChjX3ZpZXdUb1dvcmxkTWF0cml4KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBmcnVzdHVtID0gYWN0aXZlVmlldy5nZXRGcnVzdHVtKCk7XHJcbiAgICAgICAgICAgIHZhciBkb0ZydXN0dW1DdWxsaW5nID0gdGhpcy5kb0ZydXN0dW1DdWxsaW5nICYmIGZydXN0dW07XHJcblxyXG4gICAgICAgICAgICBpZihkb0ZydXN0dW1DdWxsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBjX2ZydXN0dW1UZXN0LnNldChmcnVzdHVtLCBjX3ZpZXdUb1dvcmxkTWF0cml4KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHJlYWR5T2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG9iaiA9IHJlYWR5T2JqZWN0c1tpXTtcclxuICAgICAgICAgICAgICAgIG9iai51cGRhdGVNb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4KGNfcHJvak1hdF90bXApO1xyXG4gICAgICAgICAgICAgICAgb2JqLmdldFdvcmxkU3BhY2VCb3VuZGluZ0JveChjX2Jib3gpO1xyXG4gICAgICAgICAgICAgICAgb2JqLmluRnJ1c3R1bSA9IGRvRnJ1c3R1bUN1bGxpbmcgPyBjX2ZydXN0dW1UZXN0LmlzQm94VmlzaWJsZShjX2Jib3gpIDogdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0oKSksXHJcbiAgICB1cGRhdGVSZWFkeU9iamVjdHNGcm9tTWF0cmljZXM6IGZ1bmN0aW9uICh3b3JsZFRvVmlld01hdHJpeCwgcHJvamVjdGlvbk1hdHJpeCkge1xyXG4gICAgICAgIHZhciByZWFkeU9iamVjdHMgPSB0aGlzLnJlYWR5O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcmVhZHlPYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gcmVhZHlPYmplY3RzW2ldO1xyXG4gICAgICAgICAgICBvYmoudXBkYXRlTW9kZWxWaWV3TWF0cml4KHdvcmxkVG9WaWV3TWF0cml4KTtcclxuICAgICAgICAgICAgb2JqLnVwZGF0ZU1vZGVsTWF0cml4TigpO1xyXG4gICAgICAgICAgICBvYmoudXBkYXRlTW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeChwcm9qZWN0aW9uTWF0cml4KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgYWRkTGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5vbihDLkVWRU5UX1RZUEUuU0NFTkVfU1RSVUNUVVJFX0NIQU5HRUQsIGZ1bmN0aW9uIChjaGlsZCwgcmVtb3ZlZCkge1xyXG4gICAgICAgICAgICBpZiAocmVtb3ZlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZEV2ZW50KGNoaWxkKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGRFdmVudChjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm9uKEMuRVZFTlRfVFlQRS5WSUVXX0NIQU5HRUQsIGZ1bmN0aW9uICgvKm5ld1ZpZXcqLykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucmVxdWVzdFJlZHJhdyhcIkFjdGl2ZSB2aWV3IGNoYW5nZWQuXCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMub24oQy5FVkVOVF9UWVBFLkxJR0hUX1NUUlVDVFVSRV9DSEFOR0VELCBmdW5jdGlvbiAoLypldmVudCovKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlnaHRzTmVlZFVwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyRmFjdG9yeS5zZXRMaWdodFN0cnVjdHVyZURpcnR5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZXF1ZXN0UmVkcmF3KFwiTGlnaHQgc3RydWN0dXJlIGNoYW5nZWQuXCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMub24oQy5FVkVOVF9UWVBFLkxJR0hUX1ZBTFVFX0NIQU5HRUQsIGZ1bmN0aW9uIChsaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLmxpZ2h0c05lZWRVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRlckZhY3Rvcnkuc2V0TGlnaHRWYWx1ZUNoYW5nZWQoKTtcclxuICAgICAgICAgICAgdGhpcy5saWdodHMubGlnaHRWYWx1ZUNoYW5nZWQobGlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucmVxdWVzdFJlZHJhdyhcIkxpZ2h0IHZhbHVlIGNoYW5nZWQuXCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICB0aGlzLm9uKEMuRVZFTlRfVFlQRS5TQ0VORV9TSEFQRV9DSEFOR0VELCBmdW5jdGlvbiAoLyogZXZlbnQgKi8pIHtcclxuICAgICAgICAgICAgLy8gTmVlZCB0byB1cGRhdGUgbGlnaHQgZnJ1c3R1bS4gRGVmZXIgdGhpcyB1bnRpbCB0aGUgbmV4dCByZW5kZXIgcGhhc2VcclxuICAgICAgICAgICAgLy8gVE9ETyhrc29ucykgT25seSBsaWdodCBmcnVzdHVtIGFuZCBzaGFkb3cgbWFwcyBuZWVkIHVwZGF0ZSwgbm90IHRoZSB3aG9sZSBzY2VuZVxyXG4gICAgICAgICAgICAgdGhpcy5saWdodHNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgT3B0aW9ucy5hZGRPYnNlcnZlcih0aGlzLm9uRmxhZ3NDaGFuZ2UuYmluZCh0aGlzKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZENoaWxkRXZlbnQ6IGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgIGlmIChjaGlsZC50eXBlID09IEMuTk9ERV9UWVBFLk9CSkVDVCkge1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucmVxdWVzdFJlZHJhdyhcIk9iamVjdCB3YXMgYWRkZWQgdG8gc2NlbmUuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlQ2hpbGRFdmVudDogZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT0gQy5OT0RFX1RZUEUuT0JKRUNUKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGNoaWxkKTtcclxuICAgICAgICAgICAgY2hpbGQuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucmVxdWVzdFJlZHJhdyhcIk9iamVjdCB3YXMgcmVtb3ZlZCBmcm9tIHNjZW5lLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICBjcmVhdGVEcmF3YWJsZTogZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdhYmxlRmFjdG9yeS5jcmVhdGVEcmF3YWJsZShvYmosIHRoaXMuY29udGV4dCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlcXVlc3RSZWRyYXc6IGZ1bmN0aW9uIChyZWFzb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnJlcXVlc3RSZWRyYXcocmVhc29uKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25GbGFnc0NoYW5nZTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAoRkxBR1Nba2V5XSAmJiBGTEFHU1trZXldLnJlY29tcGlsZU9uQ2hhbmdlKVxyXG4gICAgICAgICAgICB0aGlzLnNoYWRlckZhY3Rvcnkuc2V0U2hhZGVyUmVjb21waWxlKCk7XHJcbiAgICAgICAgaWYgKGtleSA9PSBPUFRJT05fRlJVU1RVTV9DVUxMSU5HKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9GcnVzdHVtQ3VsbGluZyA9ICEhdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxubW9kdWxlLmV4cG9ydHMgPSBHTFNjZW5lO1xyXG5cclxuIiwidmFyIFNoYWRlclV0aWxzID0gcmVxdWlyZShcIi4vc2hhZGVyLXV0aWxzLmpzXCIpO1xyXG52YXIgU2hhZGVyRGVzY3JpcHRvciA9IHJlcXVpcmUoXCIuLi9tYXRlcmlhbHMvdXJuL3NoYWRlci1kZXNjcmlwdG9yLmpzXCIpO1xyXG52YXIgVVJOU2hhZGVyQ2xvc3VyZSA9IHJlcXVpcmUoXCIuLi9tYXRlcmlhbHMvdXJuL3VybnNoYWRlcmNsb3N1cmUuanNcIik7XHJcblxyXG52YXIgUHJvZ3JhbUZhY3RvcnkgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgIHRoaXMucHJvZ3JhbXMgPSB7XHJcbiAgICAgICAgZmFsbGJhY2s6IG51bGwsIHBpY2tpbmc6IHtcclxuICAgICAgICAgICAgaWQ6IG51bGwsIG5vcm1hbDogbnVsbCwgcG9zaXRpb246IG51bGxcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcblhNTDNELmV4dGVuZChQcm9ncmFtRmFjdG9yeS5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBnZXRQcm9ncmFtQnlOYW1lOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciBzY3JpcHREZXNjcmlwdG9yID0gWE1MM0QubWF0ZXJpYWxzLmdldFNjcmlwdChuYW1lKTtcclxuICAgICAgICBpZiAoIXNjcmlwdERlc2NyaXB0b3IgfHwgIXNjcmlwdERlc2NyaXB0b3IudmVydGV4KSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiVW5rbm93biBzaGFkZXI6IFwiLCBuYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gbmV3IFNoYWRlckRlc2NyaXB0b3IoKTtcclxuICAgICAgICBYTUwzRC5leHRlbmQoZGVzY3JpcHRvciwgc2NyaXB0RGVzY3JpcHRvcik7XHJcbiAgICAgICAgZGVzY3JpcHRvci5mcmFnbWVudCA9IFNoYWRlclV0aWxzLmFkZEZyYWdtZW50U2hhZGVySGVhZGVyKGRlc2NyaXB0b3IuZnJhZ21lbnQpO1xyXG4gICAgICAgIHZhciBzaGFkZXIgPSBuZXcgVVJOU2hhZGVyQ2xvc3VyZSh0aGlzLmNvbnRleHQsIGRlc2NyaXB0b3IpO1xyXG4gICAgICAgIHNoYWRlci5jcmVhdGVTb3VyY2VzKHt9LCBudWxsLCBudWxsKTtcclxuICAgICAgICBzaGFkZXIuY29tcGlsZSgpO1xyXG4gICAgICAgIHJldHVybiBzaGFkZXI7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEZhbGxiYWNrUHJvZ3JhbTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5wcm9ncmFtcy5mYWxsYmFjaykge1xyXG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IG5ldyBTaGFkZXJEZXNjcmlwdG9yKCk7XHJcbiAgICAgICAgICAgIFhNTDNELmV4dGVuZChkZXNjcmlwdG9yLCBYTUwzRC5tYXRlcmlhbHMuZ2V0U2NyaXB0KFwibWF0dGVcIikpO1xyXG4gICAgICAgICAgICBkZXNjcmlwdG9yLmZyYWdtZW50ID0gU2hhZGVyVXRpbHMuYWRkRnJhZ21lbnRTaGFkZXJIZWFkZXIoZGVzY3JpcHRvci5mcmFnbWVudCk7XHJcbiAgICAgICAgICAgIHZhciBzaGFkZXIgPSBuZXcgVVJOU2hhZGVyQ2xvc3VyZSh0aGlzLmNvbnRleHQsIGRlc2NyaXB0b3IpO1xyXG4gICAgICAgICAgICBzaGFkZXIudW5pZm9ybUNvbGxlY3Rpb24uZW52QmFzZS5kaWZmdXNlQ29sb3IgPSBbMSwgMCwgMF07XHJcbiAgICAgICAgICAgIHNoYWRlci5jcmVhdGVTb3VyY2VzKHt9LCBudWxsLCBudWxsKTtcclxuICAgICAgICAgICAgc2hhZGVyLmNvbXBpbGUoKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9ncmFtcy5mYWxsYmFjayA9IHNoYWRlcjtcclxuICAgICAgICAgICAgdGhpcy5wcm9ncmFtcy5mYWxsYmFjay5iaW5kKCk7XHJcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbXMuZmFsbGJhY2suc2V0VW5pZm9ybVZhcmlhYmxlcyhbXCJkaWZmdXNlQ29sb3JcIl0sIG51bGwsIHtlbnZCYXNlOiB7ZGlmZnVzZUNvbG9yOiBbMSwgMCwgMF19fSk7XHJcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbXMuZmFsbGJhY2sudW5iaW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnByb2dyYW1zLmZhbGxiYWNrO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRQaWNraW5nT2JqZWN0SWRQcm9ncmFtOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBpY2tpbmcgPSB0aGlzLnByb2dyYW1zLnBpY2tpbmc7XHJcbiAgICAgICAgaWYgKCFwaWNraW5nLmlkKSB7XHJcbiAgICAgICAgICAgIHBpY2tpbmcuaWQgPSB0aGlzLmdldFByb2dyYW1CeU5hbWUoXCJwaWNrb2JqZWN0aWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwaWNraW5nLmlkO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRQaWNraW5nUG9zaXRpb25Qcm9ncmFtOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBpY2tpbmcgPSB0aGlzLnByb2dyYW1zLnBpY2tpbmc7XHJcbiAgICAgICAgaWYgKCFwaWNraW5nLnBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHBpY2tpbmcucG9zaXRpb24gPSB0aGlzLmdldFByb2dyYW1CeU5hbWUoXCJwaWNrZWRwb3NpdGlvblwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBpY2tpbmcucG9zaXRpb247XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFBpY2tpbmdOb3JtYWxQcm9ncmFtOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBpY2tpbmcgPSB0aGlzLnByb2dyYW1zLnBpY2tpbmc7XHJcbiAgICAgICAgaWYgKCFwaWNraW5nLm5vcm1hbCkge1xyXG4gICAgICAgICAgICBwaWNraW5nLm5vcm1hbCA9IHRoaXMuZ2V0UHJvZ3JhbUJ5TmFtZShcInBpY2tlZE5vcm1hbHNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwaWNraW5nLm5vcm1hbDtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQcm9ncmFtRmFjdG9yeTtcclxuXHJcbiIsInZhciBGUkFHTUVOVF9IRUFERVIgPSBbXCIjaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcIiwgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XCIsIFwiI2Vsc2VcIiwgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcIiwgXCIjZW5kaWYgLy8gR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcIiwgXCJcXG5cIl0uam9pbihcIlxcblwiKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgYWRkRnJhZ21lbnRTaGFkZXJIZWFkZXI6IGZ1bmN0aW9uIChmcmFnbWVudFNoYWRlclNvdXJjZSkge1xyXG4gICAgICAgIHJldHVybiBGUkFHTUVOVF9IRUFERVIgKyBmcmFnbWVudFNoYWRlclNvdXJjZTtcclxuICAgIH1cclxufTtcclxuIiwidmFyIFN5c3RlbU5vdGlmaWVyID0ge1xyXG4gICAgbm9kZTogbnVsbCxcclxuXHJcbiAgICBzZXROb2RlOiBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XHJcbiAgICB9LFxyXG5cclxuICAgIHNlbmRFdmVudDogZnVuY3Rpb24gKHR5cGUsIGRhdGEpIHtcclxuICAgICAgICBpZiAodGhpcy5ub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xyXG4gICAgICAgICAgICBkYXRhLnN5c3RlbXR5cGUgPSB0eXBlO1xyXG4gICAgICAgICAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQoJ3htbDNkc3lzdGVtJywgdHJ1ZSwgdHJ1ZSwgZGF0YSk7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN5c3RlbU5vdGlmaWVyO1xyXG4iLCJ2YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIEdMID0gcmVxdWlyZShcIi4uL2NvbnN0YW50cy5qc1wiKTtcclxuXHJcbmZ1bmN0aW9uIGNvbnZlcnRUb0pTQXJyYXkodmFsdWUpIHtcclxuICAgIHZhciBqc0FycmF5ID0gW3ZhbHVlLmxlbmd0aF07XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAganNBcnJheVtpXSA9IHZhbHVlW2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGpzQXJyYXk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0dMQ29udGV4dH0gY29udGV4dFxyXG4gKiBAcGFyYW0ge1VpbnQzMkFycmF5fSBkYXRhXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhJbmRleFxyXG4gKi9cclxudmFyIGNyZWF0ZUVsZW1lbnRCdWZmZXIgPSBmdW5jdGlvbiAoY29udGV4dCwgZGF0YSwgbWF4SW5kZXgpIHtcclxuICAgIHZhciBnbCA9IGNvbnRleHQuZ2w7XHJcbiAgICB2YXIgYnVmZmVyRGF0YSA9IGRhdGE7XHJcbiAgICB2YXIgZ2xUeXBlID0gZ2wuVU5TSUdORURfSU5UO1xyXG5cclxuICAgIGlmIChtYXhJbmRleCA8ICgxIDw8IDgpKSB7XHJcbiAgICAgICAgZ2xUeXBlID0gZ2wuVU5TSUdORURfQllURTtcclxuICAgICAgICBidWZmZXJEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XHJcbiAgICB9IGVsc2UgaWYgKG1heEluZGV4IDwgKDEgPDwgMTYpKSB7XHJcbiAgICAgICAgZ2xUeXBlID0gZ2wuVU5TSUdORURfU0hPUlQ7XHJcbiAgICAgICAgYnVmZmVyRGF0YSA9IG5ldyBVaW50MTZBcnJheShkYXRhKTtcclxuICAgIH0gZWxzZSBpZiAoIWNvbnRleHQuZXh0ZW5zaW9uc1tcIk9FU19lbGVtZW50X2luZGV4X3VpbnRcIl0pIHtcclxuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIlRyeWluZyB0byB1c2UgaW5kZXggZGF0YSB3aXRoIGluZGljZXMgbGFyZ2VyIHRoYW4gNjU1MzUsIGJ1dCB0aGlzIGlzIG5vdCBzdXBwb3J0ZWQgb24geW91ciBwbGF0Zm9ybS4gSW5kZXhpbmcgZXJyb3JzIHdpbGwgb2NjdXIuXCIpO1xyXG4gICAgICAgIGdsVHlwZSA9IGdsLlVOU0lHTkVEX1NIT1JUO1xyXG4gICAgICAgIGJ1ZmZlckRhdGEgPSBuZXcgVWludDE2QXJyYXkoZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgYnVmZmVyKTtcclxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGJ1ZmZlckRhdGEsIGdsLlNUQVRJQ19EUkFXKTtcclxuICAgIGJ1ZmZlci5ieXRlc1BlckVsZW1lbnQgPSBidWZmZXJEYXRhLkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgYnVmZmVyLmxlbmd0aCA9IGRhdGEubGVuZ3RoO1xyXG4gICAgYnVmZmVyLmdsVHlwZSA9IGdsVHlwZTtcclxuICAgIHJldHVybiBidWZmZXI7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtHTENvbnRleHR9IGNvbnRleHRcclxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuICovXHJcbnZhciBjcmVhdGVBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIChjb250ZXh0LCBkYXRhKSB7XHJcbiAgICB2YXIgZ2wgPSBjb250ZXh0LmdsO1xyXG5cclxuICAgIHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xyXG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIGdsLlNUQVRJQ19EUkFXKTtcclxuICAgIGJ1ZmZlci5sZW5ndGggPSBkYXRhLmxlbmd0aDtcclxuICAgIGJ1ZmZlci5nbFR5cGUgPSBnZXRHTFR5cGVGcm9tQXJyYXkoZGF0YSk7XHJcbiAgICByZXR1cm4gYnVmZmVyO1xyXG59O1xyXG5cclxudmFyIGdldEdMVHlwZUZyb21BcnJheSA9IGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgaWYgKGFycmF5IGluc3RhbmNlb2YgSW50OEFycmF5KVxyXG4gICAgICAgIHJldHVybiBHTC5CWVRFO1xyXG4gICAgaWYgKGFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSlcclxuICAgICAgICByZXR1cm4gR0wuVU5TSUdORURfQllURTtcclxuICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXkpXHJcbiAgICAgICAgcmV0dXJuIEdMLlNIT1JUO1xyXG4gICAgaWYgKGFycmF5IGluc3RhbmNlb2YgVWludDE2QXJyYXkpXHJcbiAgICAgICAgcmV0dXJuIEdMLlVOU0lHTkVEX1NIT1JUO1xyXG4gICAgaWYgKGFycmF5IGluc3RhbmNlb2YgSW50MzJBcnJheSlcclxuICAgICAgICByZXR1cm4gR0wuSU5UO1xyXG4gICAgaWYgKGFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkpXHJcbiAgICAgICAgcmV0dXJuIEdMLlVOU0lHTkVEX0lOVDtcclxuICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSlcclxuICAgICAgICByZXR1cm4gR0wuRkxPQVQ7XHJcbiAgICByZXR1cm4gR0wuRkxPQVQ7XHJcbn07XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBnZXRHTFVuaWZvcm1WYWx1ZUZyb21YZmxvd0RhdGFFbnRyeTogZnVuY3Rpb24gKHhmbG93RGF0YUVudHJ5LCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgIGlmICgheGZsb3dEYXRhRW50cnkpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIGlmICh4Zmxvd0RhdGFFbnRyeS50eXBlID09IFhDLkRBVEFfVFlQRS5URVhUVVJFKSB7XHJcbiAgICAgICAgICAgIHZhciB3ZWJnbERhdGEgPSBjb250ZXh0LmdldFhmbG93RW50cnlXZWJHbERhdGEoeGZsb3dEYXRhRW50cnkpO1xyXG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IHdlYmdsRGF0YS50ZXh0dXJlIHx8IGNvbnRleHQuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICAgICAgICBpZiAod2ViZ2xEYXRhLmNoYW5nZWQpXHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLnVwZGF0ZUZyb21UZXh0dXJlRW50cnkoeGZsb3dEYXRhRW50cnkpO1xyXG5cclxuICAgICAgICAgICAgd2ViZ2xEYXRhLnRleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgICAgICAgICB3ZWJnbERhdGEuY2hhbmdlZCA9IDA7XHJcbiAgICAgICAgICAgIHZhbHVlID0gW3RleHR1cmVdO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoeGZsb3dEYXRhRW50cnkudHlwZSA9PSBYQy5EQVRBX1RZUEUuQk9PTCkge1xyXG4gICAgICAgICAgICAvL1RPRE8gQ2FuIHdlIGdldCBYZmxvdyB0byByZXR1cm4gYm9vbGVhbiBhcnJheXMgYXMgbm9ybWFsIEpTIGFycmF5cz8gV2ViR0wgZG9lc24ndCBhY2NlcHQgVWludDhBcnJheXMgaGVyZS4uLlxyXG4gICAgICAgICAgICAvL1RPRE8gQWx0ZXJuYXRpdmVseSB3ZSBjb3VsZCBzZXQgYm9vbGVhbiB1bmlmb3JtcyB1c2luZyB1bmlmb3JtMWZ2IHRvZ2V0aGVyIHdpdGggRmxvYXQzMkFycmF5cywgd2hpY2ggYXBwYXJlbnRseSB3b3JrcyB0b29cclxuICAgICAgICAgICAgdmFsdWUgPSBjb252ZXJ0VG9KU0FycmF5KHhmbG93RGF0YUVudHJ5LmdldFZhbHVlKCkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0geGZsb3dEYXRhRW50cnkuZ2V0VmFsdWUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0R0xCdWZmZXJGcm9tWGZsb3dEYXRhRW50cnk6IGZ1bmN0aW9uICh4Zmxvd0RhdGFFbnRyeSwgY29udGV4dCwgZWxlbWVudEJ1ZmZlcikge1xyXG4gICAgICAgIHZhciB3ZWJnbERhdGEgPSBjb250ZXh0LmdldFhmbG93RW50cnlXZWJHbERhdGEoeGZsb3dEYXRhRW50cnkpO1xyXG4gICAgICAgIHZhciBidWZmZXIgPSB3ZWJnbERhdGEuYnVmZmVyO1xyXG4gICAgICAgIHZhciBnbCA9IGNvbnRleHQuZ2w7XHJcblxyXG4gICAgICAgIC8vIEFsc28gd3JpdGUgbWluIGFuZCBtYXggdmFsdWVzIGZvciBlbGVtZW50QnVmZmVyc1xyXG4gICAgICAgIGlmICh3ZWJnbERhdGEuY2hhbmdlZCAmJiBlbGVtZW50QnVmZmVyKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleFZhbHVlID0geGZsb3dEYXRhRW50cnkuZ2V0VmFsdWUoKTtcclxuICAgICAgICAgICAgdmFyIG1pbkluZGV4ID0gMTAwMDAwMDAwLCBtYXhJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBpID0gaW5kZXhWYWx1ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgICAgIG1pbkluZGV4ID0gTWF0aC5taW4obWluSW5kZXgsIGluZGV4VmFsdWVbaV0pO1xyXG4gICAgICAgICAgICAgICAgbWF4SW5kZXggPSBNYXRoLm1heChtYXhJbmRleCwgaW5kZXhWYWx1ZVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2ViZ2xEYXRhLm1heEluZGV4ID0gbWF4SW5kZXg7XHJcbiAgICAgICAgICAgIHdlYmdsRGF0YS5taW5JbmRleCA9IG1pbkluZGV4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXHJcbiAgICAgICAgc3dpdGNoICh3ZWJnbERhdGEuY2hhbmdlZCkge1xyXG4gICAgICAgICAgICBjYXNlIFhDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9WQUxVRTpcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50QnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZlckRhdGEgPSB4Zmxvd0RhdGFFbnRyeS5nZXRWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYnVmZmVyLmdsVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGdsLlVOU0lHTkVEX0JZVEU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJEYXRhID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBnbC5VTlNJR05FRF9TSE9SVDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckRhdGEgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBnbC5VTlNJR05FRF9JTlQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHdoYXQgd2UgZXhwZWN0IGFueXdheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIlVua25vd24gR0wgdHlwZSBmb3IgZWxlbWVudCBidWZmZXI6IFwiLCBidWZmZXIuZ2xUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIDAsIGJ1ZmZlckRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgeGZsb3dEYXRhRW50cnkuZ2V0VmFsdWUoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBYQy5EQVRBX0VOVFJZX1NUQVRFLkNIQU5HRURfTkVXOlxyXG4gICAgICAgICAgICBjYXNlIFhDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9TSVpFOlxyXG4gICAgICAgICAgICBjYXNlIFhDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9TSVpFX1RZUEU6XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudEJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGNyZWF0ZUVsZW1lbnRCdWZmZXIoY29udGV4dCwgeGZsb3dEYXRhRW50cnkuZ2V0VmFsdWUoKSwgd2ViZ2xEYXRhLm1heEluZGV4KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gY3JlYXRlQXJyYXlCdWZmZXIoY29udGV4dCwgeGZsb3dEYXRhRW50cnkuZ2V0VmFsdWUoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBidWZmZXIudHVwbGVTaXplID0geGZsb3dEYXRhRW50cnkuZ2V0VHVwbGVTaXplKCk7XHJcbiAgICAgICAgICAgICAgICB3ZWJnbERhdGEuYnVmZmVyID0gYnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3ZWJnbERhdGEuY2hhbmdlZCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgYm91bmRpbmcgYm94IGZyb20gcG9zaXRpb25zIGFuZCBvcHRpb25hbCBpbmRpY2VzXHJcbiAgICAgKiBUT0RPOiBSZW1vdmUgRmxvYXRBcnJheSBjcmVhdGlvblxyXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IHBvc2l0aW9uc1xyXG4gICAgICogQHBhcmFtIHtJbnQxNkFycmF5fG51bGx9IGluZGV4XHJcbiAgICAgKiBAcmV0dXJucyB7RmxvYXQzMkFycmF5fVxyXG4gICAgICovXHJcbiAgICBjYWxjdWxhdGVCb3VuZGluZ0JveDogZnVuY3Rpb24gKHBvc2l0aW9ucywgaW5kZXgpIHtcclxuICAgICAgICB2YXIgYm94ID0gbmV3IFhNTDNELkJveCgpLCBpO1xyXG5cclxuICAgICAgICBpZiAoIXBvc2l0aW9ucyB8fCBwb3NpdGlvbnMubGVuZ3RoIDwgMylcclxuICAgICAgICAgICAgcmV0dXJuIGJveDtcclxuXHJcbiAgICAgICAgdmFyIGJib3ggPSBib3guZGF0YTtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBpMCA9IGluZGV4WzBdICogMztcclxuICAgICAgICAgICAgYmJveFswXSA9IHBvc2l0aW9uc1tpMF07XHJcbiAgICAgICAgICAgIGJib3hbMV0gPSBwb3NpdGlvbnNbaTAgKyAxXTtcclxuICAgICAgICAgICAgYmJveFsyXSA9IHBvc2l0aW9uc1tpMCArIDJdO1xyXG4gICAgICAgICAgICBiYm94WzNdID0gcG9zaXRpb25zW2kwXTtcclxuICAgICAgICAgICAgYmJveFs0XSA9IHBvc2l0aW9uc1tpMCArIDFdO1xyXG4gICAgICAgICAgICBiYm94WzVdID0gcG9zaXRpb25zW2kwICsgMl07XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgaW5kZXgubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBpMSA9IGluZGV4W2ldICogMztcclxuICAgICAgICAgICAgICAgIHZhciBwMSA9IHBvc2l0aW9uc1tpMV07XHJcbiAgICAgICAgICAgICAgICB2YXIgcDIgPSBwb3NpdGlvbnNbaTEgKyAxXTtcclxuICAgICAgICAgICAgICAgIHZhciBwMyA9IHBvc2l0aW9uc1tpMSArIDJdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwMSA8IGJib3hbMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgYmJveFswXSA9IHAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKHAyIDwgYmJveFsxXSlcclxuICAgICAgICAgICAgICAgICAgICBiYm94WzFdID0gcDI7XHJcbiAgICAgICAgICAgICAgICBpZiAocDMgPCBiYm94WzJdKVxyXG4gICAgICAgICAgICAgICAgICAgIGJib3hbMl0gPSBwMztcclxuICAgICAgICAgICAgICAgIGlmIChwMSA+IGJib3hbM10pXHJcbiAgICAgICAgICAgICAgICAgICAgYmJveFszXSA9IHAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKHAyID4gYmJveFs0XSlcclxuICAgICAgICAgICAgICAgICAgICBiYm94WzRdID0gcDI7XHJcbiAgICAgICAgICAgICAgICBpZiAocDMgPiBiYm94WzVdKVxyXG4gICAgICAgICAgICAgICAgICAgIGJib3hbNV0gPSBwMztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJib3hbMF0gPSBwb3NpdGlvbnNbMF07XHJcbiAgICAgICAgICAgIGJib3hbMV0gPSBwb3NpdGlvbnNbMV07XHJcbiAgICAgICAgICAgIGJib3hbMl0gPSBwb3NpdGlvbnNbMl07XHJcbiAgICAgICAgICAgIGJib3hbM10gPSBwb3NpdGlvbnNbMF07XHJcbiAgICAgICAgICAgIGJib3hbNF0gPSBwb3NpdGlvbnNbMV07XHJcbiAgICAgICAgICAgIGJib3hbNV0gPSBwb3NpdGlvbnNbMl07XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAzOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25zW2ldIDwgYmJveFswXSlcclxuICAgICAgICAgICAgICAgICAgICBiYm94WzBdID0gcG9zaXRpb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1tpICsgMV0gPCBiYm94WzFdKVxyXG4gICAgICAgICAgICAgICAgICAgIGJib3hbMV0gPSBwb3NpdGlvbnNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1tpICsgMl0gPCBiYm94WzJdKVxyXG4gICAgICAgICAgICAgICAgICAgIGJib3hbMl0gPSBwb3NpdGlvbnNbaSArIDJdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1tpXSA+IGJib3hbM10pXHJcbiAgICAgICAgICAgICAgICAgICAgYmJveFszXSA9IHBvc2l0aW9uc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbnNbaSArIDFdID4gYmJveFs0XSlcclxuICAgICAgICAgICAgICAgICAgICBiYm94WzRdID0gcG9zaXRpb25zW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbnNbaSArIDJdID4gYmJveFs1XSlcclxuICAgICAgICAgICAgICAgICAgICBiYm94WzVdID0gcG9zaXRpb25zW2kgKyAyXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYm94O1xyXG4gICAgfVxyXG59O1xyXG4iLCJ2YXIgRHJhd2FibGVDbG9zdXJlID0gcmVxdWlyZShcIi4uLy4uL3JlbmRlcmVyL3NjZW5lL2RyYXdhYmxlY2xvc3VyZS5qc1wiKTtcclxudmFyIEdMTWVzaCA9IHJlcXVpcmUoXCIuLi9iYXNlL21lc2guanNcIik7XHJcbnZhciBYZmxvd1V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XHJcbnZhciBFVkVOVF9UWVBFID0gcmVxdWlyZShcIi4uLy4uL3JlbmRlcmVyL3NjZW5lL2NvbnN0YW50cy5qc1wiKS5FVkVOVF9UWVBFO1xyXG52YXIgTWF0ZXJpYWxFdmVudHMgPSByZXF1aXJlKFwiLi4vbWF0ZXJpYWxzL2V2ZW50cy5qc1wiKTtcclxudmFyIFhDID0gcmVxdWlyZShcIi4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XHJcbnZhciBDb21wdXRlUmVxdWVzdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvcmVxdWVzdC5qc1wiKS5Db21wdXRlUmVxdWVzdDtcclxudmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XHJcbnZhciBHTCA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHMuanNcIik7XHJcblxyXG52YXIgQ0hBTkdFX1NUQVRFID0ge1xyXG4gICAgTk9USElOR19DSEFOR0VEOiAwLFxyXG4gICAgU1RSVUNUVVJFX0NIQU5HRUQ6IDEsXHJcbiAgICBUWVBFX0RBVEFfQ0hBTkdFRDogMixcclxuICAgIFZTX0RBVEFfQ0hBTkdFRDogNCxcclxuICAgIFRZUEVfQ0hBTkdFRDogMiArIDEsXHJcbiAgICBWU19DSEFOR0VEOiA0ICsgMSxcclxuICAgIFNIQURFUl9DSEFOR0VEOiAzMlxyXG59O1xyXG52YXIgU0hBREVSX0NMT1NVUkVfTkVFRFNfVVBEQVRFID0gQ0hBTkdFX1NUQVRFLlNUUlVDVFVSRV9DSEFOR0VEIHwgQ0hBTkdFX1NUQVRFLlNIQURFUl9DSEFOR0VEO1xyXG5cclxudmFyIFJFQURZX1NUQVRFID0gRHJhd2FibGVDbG9zdXJlLlJFQURZX1NUQVRFO1xyXG5cclxuXHJcbnZhciBNRVNIX1BBUkFNRVRFUlMgPSB7XHJcbiAgICBhdHRyaWJ1dGVEYXRhOiB7XCJwb3NpdGlvblwiOiBYQy5EQVRBX1RZUEUuRkxPQVQzfSxcclxuICAgIHR5cGVEYXRhOiB7XHJcbiAgICAgICAgXCJpbmRleFwiOiBYQy5EQVRBX1RZUEUuSU5ULCBcInNvbGlkXCI6IFhDLkRBVEFfVFlQRS5CT09MLCBcInZlcnRleENvdW50XCI6IFhDLkRBVEFfVFlQRS5JTlQsIFwidHlwZVwiOiBYQy5EQVRBX1RZUEUuU1RSSU5HXHJcbiAgICB9LCBiYm94Rml4OiB7XHJcbiAgICAgICAgXCJib3VuZGluZ0JveFwiOiBYQy5EQVRBX1RZUEUuRkxPQVQzXHJcbiAgICB9LCBiYm94Q29tcHV0ZToge1xyXG4gICAgICAgIFwicG9zaXRpb25cIjogWEMuREFUQV9UWVBFLkZMT0FUM1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDbGFzcyB0aGF0IHN5bmNocm9uaXplcyBkYXRhIGNoYW5nZXMgZnJvbSBYZmxvdyB3aXRoIGEgR0xNZXNoIGluc3RhbmNlXHJcbiAqXHJcbiAqIEBwYXJhbSB7R0xDb250ZXh0fSBjb250ZXh0XHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBtZXNoQ29uZmlnXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRcclxuICogQGV4dGVuZHMge0RyYXdhYmxlQ2xvc3VyZX1cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgWGZsb3dNZXNoID0gZnVuY3Rpb24gKGNvbnRleHQsIG1lc2hDb25maWcsIG9wdCkge1xyXG4gICAgRHJhd2FibGVDbG9zdXJlLmNhbGwodGhpcywgY29udGV4dCwgRHJhd2FibGVDbG9zdXJlLlRZUEVTLk1FU0gpO1xyXG4gICAgYXNzZXJ0KG1lc2hDb25maWcuZGF0YSk7XHJcbiAgICBhc3NlcnQobWVzaENvbmZpZy50eXBlKTtcclxuICAgIG9wdCA9IG9wdCB8fCB7fTtcclxuXHJcbiAgICB0aGlzLm1lc2ggPSBuZXcgR0xNZXNoKGNvbnRleHQpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGF0YSBOb2RlIG9mIHRoZSByZW5kZXJPYmplY3RcclxuICAgICAqIEB0eXBlIHtYZmxvdy5EYXRhTm9kZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kYXRhTm9kZSA9IG1lc2hDb25maWcuZGF0YTtcclxuXHJcbiAgICB0aGlzLnByaW1pdGl2ZVR5cGUgPSBtZXNoQ29uZmlnLnR5cGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaGFkZXIgQ29tcG9zZXIgdGhhdCB3aWxsIHByb3ZpZGUgU2hhZGVyQ2xvc3VyZSBhbmQgUHJvZ3JhbVxyXG4gICAgICogQHR5cGUge0Fic3RyYWN0U2hhZGVyQ29tcG9zZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2hhZGVyQ29tcG9zZXIgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hhZGVyIENsb3N1cmUgdXNlZCBieSB0aGlzIG1lc2hcclxuICAgICAqIEB0eXBlIHtBYnN0cmFjdFNoYWRlckNsb3N1cmV9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2hhZGVyQ2xvc3VyZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRyaWJ1dGVzIHJlcXVpcmVkIHRvIGNyZWF0ZSB0aGUgR0xNZXNoXHJcbiAgICAgKiBAdHlwZSB7Q29tcHV0ZVJlcXVlc3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudHlwZVJlcXVlc3QgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJlIGFsbCBhdHRyaWJ1dGVzIHJlcXVpcmVkIGJ5IGRyYXdhYmxlIGF2YWlsYWJsZT9cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLnR5cGVEYXRhVmFsaWQgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXR0cmlidXRlcyBhbmQgdW5pZm9ybXMgdmFsdWVzIGZvciB0aGUgc2hhZGVyXHJcbiAgICAgKiBAdHlwZSB7WGZsb3cuUmVxdWVzdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vYmplY3RTaGFkZXJSZXF1ZXN0ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJpdGZpZWxkIHRoYXQgcmVjb3JkcyB0aGUgY2hhbmdlcyByZXBvcnRlZCBieSBYZmxvd1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2hhbmdlU3RhdGUgPSBDSEFOR0VfU1RBVEUuU1RSVUNUVVJFX0NIQU5HRUQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayBpZiBib3VuZGluZyBib3ggaGFzIGNoYW5nZWQuIEdldHMgb25seSBjYWxsZWQgaWZcclxuICAgICAqIHRoaXMuYm91bmRpbmdCb3hSZXF1aXJlZCBpcyB0cnVlLlxyXG4gICAgICogQHR5cGUgeyp8ZnVuY3Rpb24oRmxvYXQzMkFycmF5KX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5ib3VuZGluZ0JveENoYW5nZWQgPSBvcHQuYm91bmRpbmdCb3hDaGFuZ2VkIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5pbml0aWFsaXplKCk7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhYZmxvd01lc2gsIERyYXdhYmxlQ2xvc3VyZSwge1xyXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudHlwZURhdGFDaGFuZ2VkKHRoaXMudHlwZVJlcXVlc3QsIFhDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XHJcbiAgICAgICAgdGhpcy5zaGFkZXJDaGFuZ2VkKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFNoYWRlckNvbXBvc2VyOiBmdW5jdGlvbiAoc2hhZGVyQ29tcG9zZXIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYmluZGVkU2hhZGVyQ2hhbmdlZCkgdGhpcy5iaW5kZWRTaGFkZXJDaGFuZ2VkID0gdGhpcy5zaGFkZXJDaGFuZ2VkLmJpbmQodGhpcyk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNoYWRlckNvbXBvc2VyKVxyXG4gICAgICAgICAgICB0aGlzLnNoYWRlckNvbXBvc2VyLnJlbW92ZUxpc3RlbmVyKE1hdGVyaWFsRXZlbnRzLk1BVEVSSUFMX1NUUlVDVFVSRV9DSEFOR0VELCB0aGlzLmJpbmRlZFNoYWRlckNoYW5nZWQpO1xyXG5cclxuICAgICAgICB0aGlzLnNoYWRlckNvbXBvc2VyID0gc2hhZGVyQ29tcG9zZXI7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hhZGVyQ29tcG9zZXIpXHJcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyQ29tcG9zZXIub24oTWF0ZXJpYWxFdmVudHMuTUFURVJJQUxfU1RSVUNUVVJFX0NIQU5HRUQsIHRoaXMuYmluZGVkU2hhZGVyQ2hhbmdlZCk7XHJcblxyXG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUgfD0gQ0hBTkdFX1NUQVRFLlNIQURFUl9DSEFOR0VEO1xyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChzY2VuZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNoYW5nZVN0YXRlID09PSBDSEFOR0VfU1RBVEUuTk9USElOR19DSEFOR0VEKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJVcGRhdGUgbWVzaCBjbG9zdXJlXCIsIHRoaXMuY2hhbmdlU3RhdGUpO1xyXG5cclxuICAgICAgICB2YXIgb2xkVmFsaWQgPSAhIXRoaXMuc2hhZGVyQ2xvc3VyZSAmJiB0aGlzLnR5cGVEYXRhVmFsaWQsIHNvbWVFcnJvciA9IG51bGwsIHR5cGVEYXRhUmVzb2x2ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbmdlU3RhdGUgJiBTSEFERVJfQ0xPU1VSRV9ORUVEU19VUERBVEUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWVzaC5jbGVhcigpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5jaGFuZ2VTdGF0ZSAmIENIQU5HRV9TVEFURS5UWVBFX0NIQU5HRUQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVHlwZURhdGEoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdHlwZURhdGFSZXNvbHZlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5jaGFuZ2VTdGF0ZSAmIChTSEFERVJfQ0xPU1VSRV9ORUVEU19VUERBVEUgfCBDSEFOR0VfU1RBVEUuVFlQRV9DSEFOR0VEKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJbmRleEJ1ZmZlcigpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5jaGFuZ2VTdGF0ZSAmIFNIQURFUl9DTE9TVVJFX05FRURTX1VQREFURSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVPYmplY3RTaGFkZXJSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNoYWRlckNsb3N1cmUoc2NlbmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVPYmplY3RTaGFkZXJEYXRhKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jaGFuZ2VTdGF0ZSAmIENIQU5HRV9TVEFURS5WU19DSEFOR0VEKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU9iamVjdFNoYWRlckRhdGEoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YU5vZGUuaXNTdWJ0cmVlTG9hZGluZygpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRlckNsb3N1cmUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlRGF0YVZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHNvbWVFcnJvciA9IGU7XHJcbiAgICAgICAgICAgIGlmICghdHlwZURhdGFSZXNvbHZlZClcclxuICAgICAgICAgICAgICAgIHRoaXMudHlwZURhdGFWYWxpZCA9IGZhbHNlOyBlbHNlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRlckNsb3N1cmUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHZhciBuZXdWYWxpZCA9ICEhdGhpcy5zaGFkZXJDbG9zdXJlICYmIHRoaXMudHlwZURhdGFWYWxpZDtcclxuXHJcbiAgICAgICAgaWYgKG9sZFZhbGlkICE9IG5ld1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdChFVkVOVF9UWVBFLkRSQVdBQkxFX1NUQVRFX0NIQU5HRUQsXHJcbiAgICAgICAgICAgICAgICBuZXdWYWxpZCA/IFJFQURZX1NUQVRFLkNPTVBMRVRFIDogUkVBRFlfU1RBVEUuSU5DT01QTEVURSxcclxuICAgICAgICAgICAgICAgIG9sZFZhbGlkID8gUkVBRFlfU1RBVEUuQ09NUExFVEUgOiBSRUFEWV9TVEFURS5JTkNPTVBMRVRFXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUgPSBDSEFOR0VfU1RBVEUuTk9USElOR19DSEFOR0VEO1xyXG5cclxuICAgICAgICBpZiAoc29tZUVycm9yKSB0aHJvdyBzb21lRXJyb3I7XHJcbiAgICB9LFxyXG5cclxuICAgIGNhbGN1bGF0ZUJvdW5kaW5nQm94OiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjX2VtcHR5ID0gbmV3IFhNTDNELkJveCgpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBjb21wdXRlIGJvdW5kaW5nIGJveCBmcm9tIHBvc2l0aW9ucyBhbmQgaW5kaWNlcywgaWYgcHJlc2VudFxyXG4gICAgICAgICAgICB2YXIgZGF0YVJlc3VsdCA9IHRoaXMudHlwZVJlcXVlc3QuZ2V0UmVzdWx0KCk7XHJcbiAgICAgICAgICAgIHZhciBib3VuZGluZ0JveEVudHJ5ID0gZGF0YVJlc3VsdC5nZXRPdXRwdXREYXRhKFwiYm91bmRpbmdCb3hcIik7XHJcbiAgICAgICAgICAgIGlmIChib3VuZGluZ0JveEVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94Q2hhbmdlZChYZmxvd1V0aWxzLmNhbGN1bGF0ZUJvdW5kaW5nQm94KGJvdW5kaW5nQm94RW50cnkuZ2V0VmFsdWUoKSwgbnVsbCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkVudHJ5ID0gZGF0YVJlc3VsdC5nZXRPdXRwdXREYXRhKFwicG9zaXRpb25cIik7XHJcbiAgICAgICAgICAgIGlmICghcG9zaXRpb25FbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveENoYW5nZWQoY19lbXB0eSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGluZGV4RW50cnkgPSBkYXRhUmVzdWx0LmdldE91dHB1dERhdGEoXCJpbmRleFwiKTtcclxuICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveENoYW5nZWQoWGZsb3dVdGlscy5jYWxjdWxhdGVCb3VuZGluZ0JveChwb3NpdGlvbkVudHJ5LmdldFZhbHVlKCksIGluZGV4RW50cnkgPyBpbmRleEVudHJ5LmdldFZhbHVlKCkgOiBudWxsKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSgpKSwgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtDb21wdXRlUmVxdWVzdH0gcmVxdWVzdFxyXG4gICAgICogQHBhcmFtIHtYQy5SRVNVTFRfU1RBVEV9IHN0YXRlXHJcbiAgICAgKi9cclxuICAgIHR5cGVEYXRhQ2hhbmdlZDogZnVuY3Rpb24gKHJlcXVlc3QsIHN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSB8PSBzdGF0ZSA9PSBYQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUgPyBDSEFOR0VfU1RBVEUuU1RSVUNUVVJFX0NIQU5HRUQgOiBDSEFOR0VfU1RBVEUuVFlQRV9EQVRBX0NIQU5HRUQ7XHJcbiAgICAgICAgdGhpcy5lbWl0KEVWRU5UX1RZUEUuU0NFTkVfU0hBUEVfQ0hBTkdFRCk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlcXVlc3RSZWRyYXcoXCJNZXNoIFR5cGUgRGF0YSBDaGFuZ2VcIik7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJYZmxvd01lc2g6IFR5cGUgZGF0YSBjaGFuZ2VkXCIsIHJlcXVlc3QsIHN0YXRlLCB0aGlzLmNoYW5nZVN0YXRlKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0TWVzaDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lc2g7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZU9iamVjdFNoYWRlclJlcXVlc3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5vYmplY3RTaGFkZXJSZXF1ZXN0KSB0aGlzLm9iamVjdFNoYWRlclJlcXVlc3QuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLm9iamVjdFNoYWRlclJlcXVlc3QgPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGFOb2RlLmlzU3VidHJlZUxvYWRpbmcoKSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB0aGlzLm9iamVjdFNoYWRlclJlcXVlc3QgPSB0aGlzLnNoYWRlckNvbXBvc2VyLmNyZWF0ZU9iamVjdERhdGFSZXF1ZXN0KHRoaXMuZGF0YU5vZGUsIHRoaXMuc2hhZGVySW5wdXREYXRhQ2hhbmdlZC5iaW5kKHRoaXMpKTtcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlU2hhZGVyQ2xvc3VyZTogZnVuY3Rpb24gKHNjZW5lKSB7XHJcbiAgICAgICAgdGhpcy5zaGFkZXJDbG9zdXJlID0gbnVsbDtcclxuICAgICAgICBpZiAoIXRoaXMuZGF0YU5vZGUuaXNTdWJ0cmVlTG9hZGluZygpICYmICF0aGlzLmRhdGFOb2RlLmdldE91dHB1dENoYW5uZWxJbmZvKFwicG9zaXRpb25cIikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWVzaCBkb2VzIG5vdCBoYXZlICdwb3NpdGlvbicgYXR0cmlidXRlLlwiKTtcclxuICAgICAgICAgICAgLy9YTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIk1lc2ggZG9lcyBub3QgaGF2ZSAncG9zaXRpb24nIGF0dHJpYnV0ZS5cIiwgdGhpcy5tZXNoLCB0aGlzLmdldE1lc2hUeXBlKCkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuZGF0YU5vZGUuaXNTdWJ0cmVlTG9hZGluZygpKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmplY3RTaGFkZXJSZXN1bHQgPSB0aGlzLm9iamVjdFNoYWRlclJlcXVlc3QuZ2V0UmVzdWx0KCk7XHJcbiAgICAgICAgICAgIGlmICghb2JqZWN0U2hhZGVyUmVzdWx0LmxvYWRpbmcpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRlckNsb3N1cmUgPSB0aGlzLnNoYWRlckNvbXBvc2VyLmdldFNoYWRlckNsb3N1cmUoc2NlbmUsIHRoaXMub2JqZWN0U2hhZGVyUmVxdWVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVJbmRleEJ1ZmZlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIEFkZCBJbmRleCBidWZmZXIsIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgIHZhciBkYXRhUmVzdWx0ID0gdGhpcy50eXBlUmVxdWVzdC5nZXRSZXN1bHQoKTtcclxuICAgICAgICB2YXIgZW50cnkgPSBkYXRhUmVzdWx0LmdldE91dHB1dERhdGEoXCJpbmRleFwiKTtcclxuICAgICAgICBpZiAoZW50cnkgJiYgZW50cnkuZ2V0VmFsdWUoKSlcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVCdWZmZXIoXCJpbmRleFwiLCBlbnRyeSwgdHJ1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZU9iamVjdFNoYWRlckRhdGE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2hhZGVyQ2xvc3VyZSkge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIGlmIG9ubHkgdGhlIGRhdGEgaGFzIGNoYW5nZWQsIGl0IGNhbid0IGdldCB2YWxpZCBhZnRlciB1cGRhdGVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5iaW5kZWRIYW5kbGVCdWZmZXIpIHRoaXMuYmluZGVkSGFuZGxlQnVmZmVyID0gdGhpcy5oYW5kbGVCdWZmZXIuYmluZCh0aGlzKTtcclxuICAgICAgICBpZiAoIXRoaXMuYmluZGVkSGFuZGxlVW5pZm9ybSkgdGhpcy5iaW5kZWRIYW5kbGVVbmlmb3JtID0gdGhpcy5oYW5kbGVVbmlmb3JtLmJpbmQodGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMuc2hhZGVyQ29tcG9zZXIuZGlzdHJpYnV0ZU9iamVjdFNoYWRlckRhdGEodGhpcy5vYmplY3RTaGFkZXJSZXF1ZXN0LCB0aGlzLmJpbmRlZEhhbmRsZUJ1ZmZlciwgdGhpcy5iaW5kZWRIYW5kbGVVbmlmb3JtKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLm1lc2guaXNSZWFkeVRvUmVuZGVyKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWVzaCBoYXMgZW1wdHkgdmVydGV4IGF0dHJpYnV0ZXMuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlVHlwZURhdGE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMudHlwZURhdGFWYWxpZCAmJiAhKHRoaXMuY2hhbmdlU3RhdGUgJiBDSEFOR0VfU1RBVEUuU1RSVUNUVVJFX0NIQU5HRUQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gb25seSBpZiBzdHJ1Y3R1cmUgaGFzIGNoYW5nZWQsIGl0IGNhbid0IGdldCB2YWxpZCBhZnRlciB1cGRhdGVcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQmUgcGVzc2ltaXN0aWMuIFdlIHNldCB0aGlzIHRvIHRydWUgaWYgbWVzaCBwYXNzZXMgYWxsIGNoZWNrcztcclxuICAgICAgICB0aGlzLnR5cGVEYXRhVmFsaWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVUeXBlUmVxdWVzdCgpO1xyXG5cclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZUJvdW5kaW5nQm94KCk7XHJcblxyXG4gICAgICAgIHZhciBkYXRhUmVzdWx0ID0gdGhpcy50eXBlUmVxdWVzdC5nZXRSZXN1bHQoKTtcclxuXHJcbiAgICAgICAgdmFyIGVudHJ5ID0gZGF0YVJlc3VsdC5nZXRPdXRwdXREYXRhKFwidmVydGV4Q291bnRcIik7XHJcbiAgICAgICAgdGhpcy5tZXNoLnNldFZlcnRleENvdW50KGVudHJ5ICYmIGVudHJ5LmdldFZhbHVlKCkgPyBlbnRyeS5nZXRWYWx1ZSgpIDogbnVsbCk7XHJcblxyXG4gICAgICAgIHZhciBwcmltaXRpdmVUeXBlID0gdGhpcy5wcmltaXRpdmVUeXBlO1xyXG4gICAgICAgIGlmKHByaW1pdGl2ZVR5cGUgPT0gXCJkZXJpdmVkXCIpIHtcclxuICAgICAgICAgICAgZW50cnkgPSBkYXRhUmVzdWx0LmdldE91dHB1dERhdGEoXCJ0eXBlXCIpO1xyXG4gICAgICAgICAgICBwcmltaXRpdmVUeXBlID0gIGVudHJ5ID8gZW50cnkuZ2V0VmFsdWUoKVswXSA6IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZ2xUeXBlID0gZ2V0R0xUeXBlRnJvbVN0cmluZyhwcmltaXRpdmVUeXBlKTtcclxuICAgICAgICBpZihnbFR5cGUgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByaW1pdGl2ZVR5cGUgPT0gXCJkZXJpdmVkXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFOb2RlLmlzU3VidHJlZUxvYWRpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gVGhlcmUgbWlnaHQgYmUgYSB0eXBlIGNvbWluZ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHByaW1pdGl2ZVR5cGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBkZXJpdmUgcHJpbWl0aXZlIHR5cGVcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBwcmltaXRpdmUgdHlwZTogXCIgKyBwcmltaXRpdmVUeXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tZXNoLnNldFByaW1pdGl2ZVR5cGUoZ2xUeXBlKTtcclxuICAgICAgICB0aGlzLnR5cGVEYXRhVmFsaWQgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAgICAgKiBAcGFyYW0ge1hmbG93LkJ1ZmZlckVudHJ5fSB4Zmxvd0RhdGFFbnRyeVxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gaXNJbmRleFxyXG4gICAgICovXHJcbiAgICBoYW5kbGVCdWZmZXI6IGZ1bmN0aW9uIChuYW1lLCB4Zmxvd0RhdGFFbnRyeSwgaXNJbmRleCkge1xyXG4gICAgICAgIGlzSW5kZXggPSBpc0luZGV4IHx8IGZhbHNlO1xyXG4gICAgICAgIHZhciBtZXNoID0gdGhpcy5tZXNoO1xyXG5cclxuICAgICAgICBpZiAobmFtZSA9PSBcInBvc2l0aW9uXCIgJiYgIXhmbG93RGF0YUVudHJ5KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidwb3NpdGlvbicgYXR0cmlidXRlIG9mIG1lc2ggaXMgZW1wdHkuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF4Zmxvd0RhdGFFbnRyeSkge1xyXG4gICAgICAgICAgICB0aGlzLm1lc2gucmVtb3ZlQnVmZmVyKG5hbWUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoeGZsb3dEYXRhRW50cnkudHlwZSA9PSBYQy5EQVRBX1RZUEUuVEVYVFVSRSkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIlRleHR1cmUgYXMgbWVzaCBwYXJhbWV0ZXIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBidWZmZXIgPSBYZmxvd1V0aWxzLmdldEdMQnVmZmVyRnJvbVhmbG93RGF0YUVudHJ5KHhmbG93RGF0YUVudHJ5LCB0aGlzLmNvbnRleHQsIG5hbWUgPT0gXCJpbmRleFwiKTtcclxuICAgICAgICBpZiAoaXNJbmRleCkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUluZGV4UmFuZ2UoeGZsb3dEYXRhRW50cnkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubWVzaC5jaGVja0J1ZmZlckNvbXBhdGlibGUobmFtZSwgeGZsb3dEYXRhRW50cnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJbiBldmVyeSBjYXNlLCBzZXQgdGhlIGJ1ZmZlciwgYmVjYXVzZSBvdGhlciBtZXNoZXMgbWlnaHQgaGF2ZSBhbHJlYWR5XHJcbiAgICAgICAgLy8gcGVyZm9ybWVkIG9uZSBvciBtb3JlIG9mIHRoZSB0YXNrcyBhYm92ZVxyXG4gICAgICAgIG1lc2guc2V0QnVmZmVyKG5hbWUsIGJ1ZmZlcik7XHJcbiAgICB9LFxyXG5cclxuICAgIHVwZGF0ZUluZGV4UmFuZ2U6IGZ1bmN0aW9uICh4Zmxvd0RhdGFFbnRyeSkge1xyXG4gICAgICAgIHZhciB3ZWJnbERhdGEgPSB0aGlzLmNvbnRleHQuZ2V0WGZsb3dFbnRyeVdlYkdsRGF0YSh4Zmxvd0RhdGFFbnRyeSk7XHJcbiAgICAgICAgdGhpcy5tZXNoLnNldEluZGV4UmFuZ2Uod2ViZ2xEYXRhLm1pbkluZGV4LCB3ZWJnbERhdGEubWF4SW5kZXgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKmNoZWNrQnVmZmVyU2l6ZTogZnVuY3Rpb24obmFtZSwgeGZsb3dEYXRhRW50cnkpe1xyXG4gICAgIGlmKHhmbG93RGF0YUVudHJ5LmdldEl0ZXJhdGVDb3VudCl7XHJcbiAgICAgdmFyIGNudCA9IHhmbG93RGF0YUVudHJ5LmdldEl0ZXJhdGVDb3VudCgpO1xyXG4gICAgIGlmKGNudCA+PSB0aGlzLm1lc2gubWF4SW5kZXgpXHJcbiAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggcmFuZ2Ugb2YgW1wiICsgdGhpcy5tZXNoLm1pbkluZGV4ICsgXCIsIFwiICsgdGhpcy5tZXNoLm1heEluZGV4ICsgXCJdIFwiICtcclxuICAgICBcIiBnb2VzIGJleW9uZCBlbGVtZW50IGNvdW50IFwiICsgY250ICsgXCIgb2YgYXR0cmlidXRlICdcIiArIG5hbWUgKyBcIidcIik7XHJcbiAgICAgfVxyXG4gICAgIH0sKi9cclxuXHJcbiAgICBoYW5kbGVVbmlmb3JtOiBmdW5jdGlvbiAobmFtZSwgeGZsb3dEYXRhRW50cnkpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBYZmxvd1V0aWxzLmdldEdMVW5pZm9ybVZhbHVlRnJvbVhmbG93RGF0YUVudHJ5KHhmbG93RGF0YUVudHJ5LCB0aGlzLmNvbnRleHQpO1xyXG4gICAgICAgIHRoaXMubWVzaC5zZXRVbmlmb3JtT3ZlcnJpZGUobmFtZSwgdmFsdWUpO1xyXG4gICAgfSwgLyoqXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICB1cGRhdGVUeXBlUmVxdWVzdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXF1ZXN0TmFtZXMgPSB0aGlzLmdldFR5cGVSZXF1ZXN0TmFtZXMoTUVTSF9QQVJBTUVURVJTKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLnR5cGVSZXF1ZXN0IHx8IHRoaXMudHlwZVJlcXVlc3QuZmlsdGVyICE9IHJlcXVlc3ROYW1lcykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50eXBlUmVxdWVzdCkgdGhpcy50eXBlUmVxdWVzdC5jbGVhcigpO1xyXG4gICAgICAgICAgICB0aGlzLnR5cGVSZXF1ZXN0ID0gbmV3IENvbXB1dGVSZXF1ZXN0KHRoaXMuZGF0YU5vZGUsIHJlcXVlc3ROYW1lcywgdGhpcy50eXBlRGF0YUNoYW5nZWQuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUeXBlUmVxdWVzdE5hbWVzOiBmdW5jdGlvbiAobWVzaENvbmZpZykge1xyXG4gICAgICAgIHZhciByZXF1ZXN0TmFtZXMgPSBbXTtcclxuICAgICAgICByZXF1ZXN0TmFtZXMucHVzaC5hcHBseShyZXF1ZXN0TmFtZXMsIE9iamVjdC5rZXlzKG1lc2hDb25maWcudHlwZURhdGEpKTtcclxuICAgICAgICAvLyBXZSBhbHdheXMgcmVxdWVzdCBmaXhlZCBib3VuZGluZyBib3ggdmFsdWVzOiB0aGF0IHdheSB3ZSBjYW4gcmVhY3QsIHdoZW4gdGhvc2UgdmFsdWVzIGdldCBhdmFpbGFibGVcclxuICAgICAgICByZXF1ZXN0TmFtZXMucHVzaC5hcHBseShyZXF1ZXN0TmFtZXMsIE9iamVjdC5rZXlzKG1lc2hDb25maWcuYmJveEZpeCkpO1xyXG4gICAgICAgIHZhciBjb21wdXRlQkJveCA9ICF0aGlzLmNoZWNrWGZsb3dUeXBlcyh0aGlzLmRhdGFOb2RlLCBtZXNoQ29uZmlnLmJib3hGaXgpO1xyXG5cclxuICAgICAgICBpZiAoY29tcHV0ZUJCb3gpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrWGZsb3dUeXBlcyh0aGlzLmRhdGFOb2RlLCBtZXNoQ29uZmlnLmJib3hDb21wdXRlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlRGF0YVZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVxdWVzdE5hbWVzLnB1c2guYXBwbHkocmVxdWVzdE5hbWVzLCBPYmplY3Qua2V5cyhtZXNoQ29uZmlnLmJib3hDb21wdXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXF1ZXN0TmFtZXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGNoZWNrWGZsb3dUeXBlczogZnVuY3Rpb24gKGRhdGFOb2RlLCByZXF1aXJlbWVudHMpIHtcclxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHJlcXVpcmVtZW50cykge1xyXG4gICAgICAgICAgICB2YXIgaW5mbyA9IGRhdGFOb2RlLmdldE91dHB1dENoYW5uZWxJbmZvKG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoIWluZm8pIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKGluZm8udHlwZSAhPSByZXF1aXJlbWVudHNbbmFtZV0pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7Q29tcHV0ZVJlcXVlc3R9IHJlcXVlc3RcclxuICAgICAqIEBwYXJhbSB7WEMuUkVTVUxUX1NUQVRFfSBzdGF0ZVxyXG4gICAgICovXHJcbiAgICBzaGFkZXJJbnB1dERhdGFDaGFuZ2VkOiBmdW5jdGlvbiAocmVxdWVzdCwgc3RhdGUpIHtcclxuICAgICAgICB0aGlzLmNoYW5nZVN0YXRlIHw9IHN0YXRlICE9IFhDLlJFU1VMVF9TVEFURS5DSEFOR0VEX0RBVEFfVkFMVUUgPyBDSEFOR0VfU1RBVEUuU1RSVUNUVVJFX0NIQU5HRUQgOiBDSEFOR0VfU1RBVEUuVlNfREFUQV9DSEFOR0VEO1xyXG4gICAgICAgIC8vIFRPRE86IFdlIGRvbid0IGtub3cgaWYgdGhlIGNoYW5nZSBvZiBkYXRhIG9ubHkgaW5mbHVlbmNlcyB0aGUgc3VyZmFjZSBzaGFkaW5nIG9yIHRoZSBhY3R1YWwgbWVzaCBzaGFwZVxyXG4gICAgICAgIHRoaXMuZW1pdChFVkVOVF9UWVBFLlNDRU5FX1NIQVBFX0NIQU5HRUQpO1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5yZXF1ZXN0UmVkcmF3KFwiTWVzaCBBdHRyaWJ1dGUgRGF0YSBDaGFuZ2VkXCIpO1xyXG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKFwiWGZsb3dNZXNoOiBBdHRyaWJ1dGUgZGF0YSBjaGFuZ2VkXCIsIHJlcXVlc3QsIHN0YXRlLCB0aGlzLmNoYW5nZVN0YXRlKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2hhZGVyQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUgfD0gQ0hBTkdFX1NUQVRFLlNIQURFUl9DSEFOR0VEO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRQcm9ncmFtOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhZGVyQ2xvc3VyZTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5tZXNoICYmIHRoaXMubWVzaC5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMub2JqZWN0U2hhZGVyUmVxdWVzdCAmJiB0aGlzLm9iamVjdFNoYWRlclJlcXVlc3QuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLnR5cGVSZXF1ZXN0ICYmIHRoaXMudHlwZVJlcXVlc3QuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLnNldFNoYWRlckNvbXBvc2VyKG51bGwpO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLmRhdGFOb2RlO1xyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVOYW1lXHJcbiAqL1xyXG52YXIgZ2V0R0xUeXBlRnJvbVN0cmluZyA9IGZ1bmN0aW9uICh0eXBlTmFtZSkge1xyXG4gICAgaWYgKHR5cGVOYW1lICYmIHR5cGVOYW1lLnRvTG93ZXJDYXNlKVxyXG4gICAgICAgIHR5cGVOYW1lID0gdHlwZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgIHN3aXRjaCAodHlwZU5hbWUpIHtcclxuICAgICAgICBjYXNlIFwidHJpYW5nbGVzXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBHTC5UUklBTkdMRVM7XHJcbiAgICAgICAgY2FzZSBcInRyaXN0cmlwc1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gR0wuVFJJQU5HTEVfU1RSSVA7XHJcbiAgICAgICAgY2FzZSBcInBvaW50c1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gR0wuUE9JTlRTO1xyXG4gICAgICAgIGNhc2UgXCJsaW5lc1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gR0wuTElORVM7XHJcbiAgICAgICAgY2FzZSBcImxpbmVzdHJpcHNcIjpcclxuICAgICAgICAgICAgcmV0dXJuIEdMLkxJTkVfU1RSSVA7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWGZsb3dNZXNoO1xyXG5cclxuIiwiXHJcbnZhciBBZGFwdGVySGFuZGxlID0gcmVxdWlyZShcIi4uL2Jhc2UvYWRhcHRlcmhhbmRsZS5qc1wiKTtcclxudmFyIFVSSSA9IHJlcXVpcmUoXCIuLi91dGlscy91cmkuanNcIikuVVJJO1xyXG52YXIgVVJJUmVzb2x2ZXIgPSByZXF1aXJlKFwiLi4vdXRpbHMvdXJpLmpzXCIpLlVSSVJlc29sdmVyO1xyXG52YXIgT3B0aW9ucyA9IHJlcXVpcmUoXCIuLi91dGlscy9vcHRpb25zLmpzXCIpO1xyXG52YXIgUmVzb3VyY2VDb3VudGVyID0gcmVxdWlyZShcIi4vY291bnRlci5qc1wiKTtcclxudmFyIGdldERvY3VtZW50Q2FjaGUgPSByZXF1aXJlKFwiLi9mZXRjaGVyLmpzXCIpLmdldERvY3VtZW50Q2FjaGU7XHJcblxyXG52YXIgT1BUSU9OX1JFU09VUkNFX0NPUlMgPSBcInJlc291cmNlLWNyb3Nzb3JpZ2luLWF0dHJpYnV0ZVwiO1xyXG5PcHRpb25zLnJlZ2lzdGVyKE9QVElPTl9SRVNPVVJDRV9DT1JTLCBcImFub255bW91c1wiKTtcclxuXHJcbi8vIFByb3h5IGFkYXB0ZXJzIHRoYXQgcHJvdmlkZSB0aGUgY29ubmVjdGlvbnMgYmV0d2VlbiBlbGVtZW50cyAoZWcuIFwic3JjXCIgLT4gXCJpZFwiKVxyXG52YXIgY19jYWNoZWRBZGFwdGVySGFuZGxlcyA9IHt9O1xyXG5cclxudmFyIFJlc291cmNlID0ge307XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBhbiBpZCBvZiBhbiBlbGVtZW50IGNoYW5nZXMgb3IgaWYgdGhhdCBlbGVtZW50IGlzIG5vdyByZWFjaGFibGVcclxuICogb3Igbm90IHJlYWNoYWJsZSBhbnltb3JlLiBJdCB3aWxsIHVwZGF0ZSBhbGwgQWRhcHRlckhhbmRsZXMgY29ubmVjdGVkIHRvIHRoZSBlbGVtZW50LlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgRWxlbWVudCBvZiB3aGljaCBpZCBoYXMgY2hhbmdlZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJldmlvdXNJZCBQcmV2aW91cyBpZCBvZiBlbGVtZW50XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdJZCBOZXcgaWQgb2YgZWxlbWVudFxyXG4gKi9cclxuUmVzb3VyY2Uubm90aWZ5Tm9kZUlkQ2hhbmdlID0gZnVuY3Rpb24obm9kZSwgcHJldmlvdXNJZCwgbmV3SWQpIHtcclxuICAgIHZhciB1cmkgPSBuZXcgVVJJKCk7XHJcbiAgICBpZiAocHJldmlvdXNJZCkge1xyXG4gICAgICAgIHVyaS5mcmFnbWVudCA9IHByZXZpb3VzSWQ7XHJcbiAgICAgICAgY2xlYXJIYW5kbGVzKHVyaSk7XHJcbiAgICB9XHJcbiAgICBpZiAobmV3SWQpIHtcclxuICAgICAgICB1cmkuZnJhZ21lbnQgPSBuZXdJZDtcclxuICAgICAgICB1cGRhdGVNaXNzaW5nSGFuZGxlcyh1cmksIFhNTDNELnhtbDNkRm9ybWF0SGFuZGxlciwgbm9kZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgdG8gbm90aWZ5IGFuIEFkYXB0ZXJIYW5kbGVyIGFib3V0IGEgY2hhbmdlIChjYW4gYmUgdHJpZ2dlcmVkIHRocm91Z2ggYWRhcHRlcnMpXHJcbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG9ubHkgd29ya3Mgd2l0aCBub2RlcyBpbnNpZGUgd2luZG93LmRvY3VtZW50XHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IG9mIEFkYXB0ZXJIYW5kbGVyLiBNdXN0IGJlIGZyb20gd2luZG93LmRvY3VtZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBhZGFwdGVyVHlwZSBUeXBlL0FzcGVjdCBvZiBBZGFwdGVySGFuZGxlciAoZS5nLiBYTUwzRC5kYXRhIG9yIFhNTDNELndlYmdsKVxyXG4gKiBAcGFyYW0ge251bWJlcn0gY2FudmFzSWQgR0xDYW52YXNIYW5kbGVyIGlkIG9mIEFkYXB0ZXJIYW5kbGVyLCAwIGlmIG5vdCBkZXBlbmRpbmcgb24gR0xDYW52YXNIYW5kbGVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFR5cGUgb2YgTm90aWZpY2F0aW9uLiBVc3VhbGx5IEV2ZW50cy5BREFQVEVSX0hBTkRMRV9DSEFOR0VEXHJcbiAqL1xyXG5SZXNvdXJjZS5ub3RpZnlOb2RlQWRhcHRlckNoYW5nZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGFkYXB0ZXJUeXBlLCBjYW52YXNJZCwgdHlwZSkge1xyXG4gICAgY2FudmFzSWQgPSBjYW52YXNJZCB8fCAwO1xyXG4gICAgdmFyIHVyaSA9IFwiI1wiICsgZWxlbWVudC5pZDtcclxuICAgIGlmIChjX2NhY2hlZEFkYXB0ZXJIYW5kbGVzW3VyaV0gJiYgY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmldW2FkYXB0ZXJUeXBlXSAmJlxyXG4gICAgICAgIGNfY2FjaGVkQWRhcHRlckhhbmRsZXNbdXJpXVthZGFwdGVyVHlwZV1bY2FudmFzSWRdKSB7XHJcbiAgICAgICAgY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmldW2FkYXB0ZXJUeXBlXVtjYW52YXNJZF0ubm90aWZ5TGlzdGVuZXJzKHR5cGUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgYWRhcHRlciBvZiBhbGwgQWRhcHRlckhhbmRsZXMgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gVVJMLlxyXG4gKiBUaGlzIGlzIGNhbGxlZCBlLmcuIHdoZW4gYSBub2RlIGlzIHJlbW92ZSBmcm9tIHRoZSBkb2N1bWVudCwgb3IgYW4gaWQgY2hhbmdlc1xyXG4gKiBAcGFyYW0ge1VSSX0gdXJpIFRoZSBVUkwgb2YgYWxsIEFkYXB0ZXJIYW5kbGVzIHRvIGJlIGNsZWFyZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBjbGVhckhhbmRsZXModXJpKSB7XHJcbiAgICB2YXIgdXJsID0gdXJpLnRvU3RyaW5nKCk7XHJcbiAgICBmb3IgKHZhciBhZGFwdGVyVHlwZSBpbiBjX2NhY2hlZEFkYXB0ZXJIYW5kbGVzW3VybF0pIHtcclxuICAgICAgICBmb3IgKHZhciBjYW52YXNJZCBpbiBjX2NhY2hlZEFkYXB0ZXJIYW5kbGVzW3VybF1bYWRhcHRlclR5cGVdKSB7XHJcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBjX2NhY2hlZEFkYXB0ZXJIYW5kbGVzW3VybF1bYWRhcHRlclR5cGVdW2NhbnZhc0lkXTtcclxuICAgICAgICAgICAgaWYgKGhhbmRsZS5oYXNBZGFwdGVyKCkpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZS5zZXRBZGFwdGVyKG51bGwsIEFkYXB0ZXJIYW5kbGUuU1RBVFVTLk5PVF9GT1VORCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIChvciBjcmVhdGVzKSB0aGUgcmVxdWVzdGVkIGFkYXB0ZXIgZm9yIHRoZSBnaXZlbiBlbGVtZW50IGFuZCBjYW52YXNJZC5cclxuICpcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSAtIFRoZSBlbGVtZW50IHRoZSBhZGFwdGVyIGlzIGZvclxyXG4gKiBAcGFyYW0ge1N0cmluZ30gYXNwZWN0IC0gVGhlIGFzcGVjdCBvZiB0aGUgYWRhcHRlciwgdXN1YWxseSAnc2NlbmUnIG9yICdkYXRhJ1xyXG4gKiBAcGFyYW0gez9OdW1iZXJ9IGNhbnZhc0lkIC0gVGhlIGNhbnZhc0lkIG9mIHRoZSBYTUwzRCBlbGVtZW50IHRoYXQgdGhpcyBhZGFwdGVyIHdpbGwgYmVsb25nIHRvXHJcbiAqIEByZXR1cm5zIHtBZGFwdGVyfD9YTUwzRC5iYXNlLkFkYXB0ZXJ9XHJcbiAqL1xyXG5SZXNvdXJjZS5nZXRBZGFwdGVyID0gZnVuY3Rpb24obm9kZSwgYXNwZWN0LCBjYW52YXNJZCkge1xyXG4gICAgcmV0dXJuIFhNTDNELnhtbDNkRm9ybWF0SGFuZGxlci5nZXRBZGFwdGVyKG5vZGUsIGFzcGVjdCwgY2FudmFzSWQpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBHZXQgYW55IGFkYXB0ZXIsIGludGVybmFsIG9yIGV4dGVybmFsLlxyXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdHJpZ2dlciB0aGUgbG9hZGluZyBvZiBkb2N1bWVudHMsIGlmIHJlcXVpcmVkLlxyXG4gKiBBbiBBZGFwdGVySGFuZGxlIHdpbGwgYmUgYWx3YXlzIGJlIHJldHVybmVkLCBleHBlY3Qgd2hlbiBhbiBpbnZhbGlkIChlbXB0eSkgdXJpIGlzIHBhc3NlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2VVUkkgLSB0aGUgYmFzZSBVUkkgZnJvbSB3aGljaCB0byBsb29rIHVwIHRoZSByZWZlcmVuY2VcclxuICogQHBhcmFtIHtVUkl9IHVyaSAtIFRoZSBVUkkgdXNlZCB0byBmaW5kIHRoZSByZWZlcnJlZCBBZGFwdGVySGFuZGxlLiBDYW4gYmUgcmVsYXRpdmVcclxuICogQHBhcmFtIHtPYmplY3R9IGFzcGVjdCBUaGUgdHlwZSBvZiBhZGFwdGVyIHJlcXVpcmVkIChlLmcuIFhNTDNELmRhdGEgb3IgWE1MM0Qud2ViZ2wpXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gY2FudmFzSWQgSWQgb2YgR0xDYW52YXNIYW5kbGVyIGhhbmRsZXIgdGhpcyBhZGFwdGVyIGRlcGVuZHMgb24sIDAgaWYgbm90IGRlcGVuZGluZyBvbiBhbnkgR0xDYW52YXNIYW5kbGVyXHJcbiAqIEByZXR1cm5zIHs/QWRhcHRlckhhbmRsZX0gVGhlIHJlcXVlc3RlZCBBZGFwdGVySGFuZGxlci4gTm90ZTogbWlnaHQgYmUgbnVsbFxyXG4gKi9cclxuUmVzb3VyY2UuZ2V0QWRhcHRlckhhbmRsZSA9IGZ1bmN0aW9uKGJhc2VVUkksIHVyaSwgYXNwZWN0LCBjYW52YXNJZCkge1xyXG4gICAgY2FudmFzSWQgPSBjYW52YXNJZCB8fCAwO1xyXG4gICAgdXJpID0gWE1MM0QucmVzb3VyY2UuZ2V0QWJzb2x1dGVVUkkoYmFzZVVSSSwgdXJpKTtcclxuXHJcbiAgICBpZiAoIXVyaSlcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBpZiAoIWNfY2FjaGVkQWRhcHRlckhhbmRsZXNbdXJpXSlcclxuICAgICAgICBjX2NhY2hlZEFkYXB0ZXJIYW5kbGVzW3VyaV0gPSB7fTtcclxuXHJcbiAgICBpZiAoIWNfY2FjaGVkQWRhcHRlckhhbmRsZXNbdXJpXVthc3BlY3RdKSB7XHJcbiAgICAgICAgY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmldW2FzcGVjdF0gPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaGFuZGxlID0gY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmldW2FzcGVjdF1bY2FudmFzSWRdO1xyXG4gICAgaWYgKGhhbmRsZSlcclxuICAgICAgICByZXR1cm4gaGFuZGxlO1xyXG5cclxuICAgIHJldHVybiBjcmVhdGVBZGFwdGVySGFuZGxlKHVyaSwgYXNwZWN0LCBjYW52YXNJZCk7XHJcbn07XHJcblxyXG52YXIgY3JlYXRlQWRhcHRlckhhbmRsZSA9IGZ1bmN0aW9uKHVyaSwgYXNwZWN0LCBjYW52YXNJZCkge1xyXG4gICAgdmFyIHVybCA9IHVyaS50b1N0cmluZygpO1xyXG4gICAgdmFyIGhhbmRsZSA9IG5ldyBBZGFwdGVySGFuZGxlKHVybCk7XHJcbiAgICBjX2NhY2hlZEFkYXB0ZXJIYW5kbGVzW3VybF1bYXNwZWN0XVtjYW52YXNJZF0gPSBoYW5kbGU7XHJcblxyXG4gICAgaWYgKHVyaS5pc0xvY2FsKCkpIHtcclxuICAgICAgICB2YXIgbm9kZSA9IFVSSVJlc29sdmVyLnJlc29sdmVMb2NhbCh1cmkpO1xyXG4gICAgICAgIGlmIChub2RlKVxyXG4gICAgICAgICAgICB1cGRhdGVIYW5kbGUoaGFuZGxlLCBhc3BlY3QsIGNhbnZhc0lkLCBYTUwzRC54bWwzZEZvcm1hdEhhbmRsZXIsIG5vZGUpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgaGFuZGxlLnNldEFkYXB0ZXIobnVsbCwgQWRhcHRlckhhbmRsZS5TVEFUVVMuTk9UX0ZPVU5EKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIFJlc291cmNlQ291bnRlci5hZGRQZW5kaW5nUmVzb3VyY2UodXJpLCBjYW52YXNJZCk7XHJcblxyXG4gICAgICAgIHZhciBkb2NVUkkgPSB1cmkudG9TdHJpbmdXaXRob3V0RnJhZ21lbnQoKTtcclxuICAgICAgICB2YXIgZG9jRGF0YSA9IGdldERvY3VtZW50Q2FjaGUoZG9jVVJJKTtcclxuICAgICAgICBpZiAoZG9jRGF0YSAmJiBkb2NEYXRhLmRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUV4dGVybmFsSGFuZGxlcyh1cmksIGRvY0RhdGEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBwcmlvcml0eSA9IGFzcGVjdCA9PT0gXCJzY2VuZVwiID8gMSA6IDA7IC8vR2l2ZSBtYXRlcmlhbHMgYSBoaWdoZXIgcHJpb3JpdHlcclxuICAgICAgICAgICAgWE1MM0QucmVzb3VyY2UuZ2V0RG9jdW1lbnQoZG9jVVJJLCB7cHJpb3JpdHkgOiBwcmlvcml0eX0pLnRoZW4oZnVuY3Rpb24oZG9jKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jRGF0YSA9IGdldERvY3VtZW50Q2FjaGUoZG9jVVJJKTtcclxuICAgICAgICAgICAgICAgICAgICBkb2NEYXRhLmZyYWdtZW50cy5wdXNoKHVyaS5mcmFnbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlRG9jdW1lbnRIYW5kbGVzKGRvY1VSSSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRhdGVEb2N1bWVudEhhbmRsZXModXJpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICBpbnZhbGlkYXRlRG9jdW1lbnRIYW5kbGVzKHVyaSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBoYW5kbGU7XHJcbn07XHJcblxyXG4vKipcclxuICogVXBkYXRlIGEgc3BlY2lmaWMgQWRhcHRlckhhbmRsZSB3aXRoIHRoZSBwcm92aWRlZCBkYXRhLlxyXG4gKiBJbnRlcm5hbGx5IGFuIGFkYXB0ZXIgd2lsbCBiZSBjcmVhdGVkIHdpdGggJ2RhdGEnIGFuZCBhZGRlZCB0byAnaGFuZGxlJ1xyXG4gKiBBbGwgb3RoZXIgYXJndW1lbnQgYXJlIHJlcXVpcmVkIHRvIGZpbmQgdGhlIGNvcnJlY3QgZmFjdG9yeVxyXG4gKiBAcGFyYW0ge0FkYXB0ZXJIYW5kbGV9IGhhbmRsZSBUaGUgQWRhcHRlckhhbmRsZSB0byBiZSB1cGRhdGVkXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBhZGFwdGVyVHlwZSBUaGUgdHlwZSAvIGFzcGVjdCBvZiB0aGUgYWRhcHRlciAoZS5nLiBYTUwzRC5kYXRhIG9yIFhNTDNELndlYmdsKVxyXG4gKiBAcGFyYW0ge251bWJlcn0gY2FudmFzSWQgSWQgb2YgY29ycmVzcG9uZGluZyBjYW52YXMgaGFuZGxlci4gMCBpZiBub3QgZGVwZW5kZW50IG9mIGNhbnZhcyBoYW5kbGVyXHJcbiAqIEBwYXJhbSB7Rm9ybWF0SGFuZGxlcn0gZm9ybWF0IEZvcm1hdCBoYW5kbGVyIG9mIHRoZSBjb3JyZXNwb25kaW5nIGRvY3VtZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIERhdGEgZm9yIHRoaXMgaGFuZGxlLiBQb3NzaWJseSBhIERPTSBlbGVtZW50XHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGVIYW5kbGUoaGFuZGxlLCBhZGFwdGVyVHlwZSwgY2FudmFzSWQsIGZvcm1hdCwgZGF0YSkge1xyXG4gICAgdmFyIGFkYXB0ZXIgPSBmb3JtYXQuZ2V0QWRhcHRlcihkYXRhLCBhZGFwdGVyVHlwZSwgY2FudmFzSWQpO1xyXG4gICAgaWYgKGFkYXB0ZXIpIHtcclxuICAgICAgICBoYW5kbGUuc2V0QWRhcHRlcihhZGFwdGVyLCBBZGFwdGVySGFuZGxlLlNUQVRVUy5SRUFEWSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVcGRhdGUgYWxsIGhhbmRsZXMgb2YgYSBwYXJ0IGZyb20gYW4gZXh0ZXJuYWwgZG9jdW1lbnRcclxuICogQHBhcmFtIHtVUkl9IHVyaSBUaGUgVVJJIG9mIHRoZSBkb2N1bWVudFxyXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jQ2FjaGUgVGhlIGVudHJ5IGluIHRoZSBjX2RvY3VtZW50Q2FjaGUgZm9yIHRoZSBleHRlcm5hbCBkb2N1bWVudFxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlRXh0ZXJuYWxIYW5kbGVzKHVyaSwgZG9jQ2FjaGUpIHtcclxuICAgIC8vIGdldCBwYXJ0IG9mIHRoZSByZXNvdXJjZSByZXByZXNlbnRlZCBieSB0aGUgZnJhZ21lbnRcclxuICAgIHZhciBkYXRhID0gZG9jQ2FjaGUuaGFuZGxlci5nZXRGcmFnbWVudERhdGEoZG9jQ2FjaGUuZG9jdW1lbnQsIHVyaS5mcmFnbWVudCk7XHJcbiAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgIHVwZGF0ZU1pc3NpbmdIYW5kbGVzKHVyaSwgZG9jQ2FjaGUuaGFuZGxlciwgZGF0YSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGludmFsaWRhdGVIYW5kbGVzKHVyaSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVcGRhdGUgYWxsIEFkYXB0ZXJIYW5kbGVzIHdpdGhvdXQgYWRhcHRlcnMgb2YgYSBjZXJ0YWluIHVybFxyXG4gKiBAcGFyYW0ge1VSSX0gdXJpIFRoZSBjb21wbGV0ZSB1cmwgKyBmcmFnbWVudFxyXG4gKiBAcGFyYW0ge0Zvcm1hdEhhbmRsZXJ9IGZvcm1hdEhhbmRsZXIgRm9ybWF0IGhhbmRsZXJcclxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgRGF0YSBvZiB0aGUgZG9jdW1lbnQgY29ycmVzcG9uZGluZyB0byB0aGUgdXJsLiBQb3NzaWJseSBhIERPTSBlbGVtZW50XHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGVNaXNzaW5nSGFuZGxlcyh1cmksIGZvcm1hdEhhbmRsZXIsIGRhdGEpIHtcclxuICAgIHZhciB1cmwgPSB1cmkudG9TdHJpbmcoKTtcclxuICAgIGZvciAodmFyIGFkYXB0ZXJUeXBlIGluIGNfY2FjaGVkQWRhcHRlckhhbmRsZXNbdXJsXSkge1xyXG4gICAgICAgIGZvciAodmFyIGNhbnZhc0lkIGluIGNfY2FjaGVkQWRhcHRlckhhbmRsZXNbdXJsXVthZGFwdGVyVHlwZV0pIHtcclxuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGNfY2FjaGVkQWRhcHRlckhhbmRsZXNbdXJsXVthZGFwdGVyVHlwZV1bY2FudmFzSWRdO1xyXG4gICAgICAgICAgICBpZiAoIWhhbmRsZS5oYXNBZGFwdGVyKCkpIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUhhbmRsZShoYW5kbGUsIGFkYXB0ZXJUeXBlLCArY2FudmFzSWQsIGZvcm1hdEhhbmRsZXIsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYoIXVyaS5pc0xvY2FsKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgUmVzb3VyY2VDb3VudGVyLnJlc29sdmVQZW5kaW5nUmVzb3VyY2UodXJpLCBjYW52YXNJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbnZhbGlkYXRlIGFsbCBBZGFwdGVySGFuZGxlcyB3aXRob3V0IGFkYXB0ZXJzIG9mIGEgY2VydGFpbiB1cmxcclxuICogQHBhcmFtIHtVUkl9IHVyaSBUaGUgY29tcGxldGUgdXJsICsgZnJhZ21lbnRcclxuICovXHJcbmZ1bmN0aW9uIGludmFsaWRhdGVIYW5kbGVzKHVyaSkge1xyXG4gICAgdmFyIHVybCA9IHVyaS50b1N0cmluZygpO1xyXG4gICAgZm9yICh2YXIgYWRhcHRlclR5cGUgaW4gY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmxdKSB7XHJcbiAgICAgICAgZm9yICh2YXIgY2FudmFzSWQgaW4gY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmxdW2FkYXB0ZXJUeXBlXSkge1xyXG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmxdW2FkYXB0ZXJUeXBlXVtjYW52YXNJZF07XHJcbiAgICAgICAgICAgIGhhbmRsZS5zZXRBZGFwdGVyKG51bGwsIEFkYXB0ZXJIYW5kbGUuU1RBVFVTLk5PVF9GT1VORCk7XHJcbiAgICAgICAgICAgIFJlc291cmNlQ291bnRlci5yZXNvbHZlUGVuZGluZ1Jlc291cmNlKHVyaSwgY2FudmFzSWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEludmFsaWRhdGUgYWxsIGhhbmRsZXMgb2YgYSBkb2N1bWVudCwgdGhhdCBjb3VsZCBub3QgYmUgbG9hZGVkLlxyXG4gKiBAcGFyYW0ge1VSSX0gdXJpIFRoZSBVUkkgb2YgdGhlIGRvY3VtZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBpbnZhbGlkYXRlRG9jdW1lbnRIYW5kbGVzKHVyaSkge1xyXG4gICAgdmFyIHVybCA9IHVyaS50b1N0cmluZ1dpdGhvdXRGcmFnbWVudCgpO1xyXG4gICAgdmFyIGRvY0NhY2hlID0gZ2V0RG9jdW1lbnRDYWNoZSh1cmwpO1xyXG4gICAgaWYgKCFkb2NDYWNoZSkge1xyXG4gICAgICAgIC8vIFRoZSBkb2N1bWVudCB3YXMgbmV2ZXIgbG9hZGVkXHJcbiAgICAgICAgaW52YWxpZGF0ZUhhbmRsZXModXJpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgZnJhZ21lbnRzID0gZG9jQ2FjaGUuZnJhZ21lbnRzO1xyXG4gICAgZG9jQ2FjaGUuZnJhZ21lbnRzID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYWdtZW50cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGludmFsaWRhdGVIYW5kbGVzKHVyaSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVcGRhdGUgYWxsIGV4aXN0aW5nIGhhbmRsZXMgb2YgYSByZWNlaXZlZCBkb2N1bWVudFxyXG4gKiBAcGFyYW0ge1VSSX0gdXJpIFRoZSBVUkkgb2YgdGhlIGRvY3VtZW50XHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGVEb2N1bWVudEhhbmRsZXModXJpKSB7XHJcbiAgICB2YXIgdXJsID0gdXJpLnRvU3RyaW5nKCk7XHJcbiAgICB2YXIgZG9jQ2FjaGUgPSBnZXREb2N1bWVudENhY2hlKHVybCk7XHJcbiAgICB2YXIgZnJhZ21lbnRzID0gZG9jQ2FjaGUuZnJhZ21lbnRzO1xyXG4gICAgZG9jQ2FjaGUuZnJhZ21lbnRzID0gW107XHJcbiAgICB2YXIgdGVtcFVyaSA9IG5ldyBVUkkodXJpKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhZ21lbnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdGVtcFVyaS5mcmFnbWVudCA9IGZyYWdtZW50c1tpXTtcclxuICAgICAgICB1cGRhdGVFeHRlcm5hbEhhbmRsZXModGVtcFVyaSwgZG9jQ2FjaGUpO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIGxvYWQgYW4gSW1hZ2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB7VVJJfSB1cmkgSW1hZ2UgVVJJXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXZlbnQsIEhUTUxJbWFnZUVsZW1lbnQpfSBsb2FkTGlzdGVuZXIgRnVuY3Rpb24gY2FsbGVkIHdoZW4gaW1hZ2Ugd2FzIHN1Y2Nlc3NmdWxseSBsb2FkZWQuXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGV2ZW50IGFzIHRoZSBmaXJzdCBhbmQgaW1hZ2UgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXZlbnQsIEhUTUxJbWFnZUVsZW1lbnQpfSBlcnJvckxpc3RlbmVyIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIGltYWdlIGNvdWxkIG5vdCBiZSBsb2FkZWQuXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBldmVudCBhcyB0aGUgZmlyc3QgYW5kIGltYWdlIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLlxyXG4gKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fVxyXG4gKi9cclxuUmVzb3VyY2UuZ2V0SW1hZ2UgPSBmdW5jdGlvbih1cmksIGxvYWRMaXN0ZW5lciwgZXJyb3JMaXN0ZW5lcikge1xyXG4gICAgLy8gd2UgdXNlIGNhbnZhc0lkIDAgdG8gcmVwcmVzZW50IGltYWdlcyBsb2FkZWQgaW4gYSBkb2N1bWVudFxyXG4gICAgUmVzb3VyY2VDb3VudGVyLmFkZFBlbmRpbmdSZXNvdXJjZSh1cmksIDApO1xyXG5cclxuICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgaWYoIXVyaS5oYXNTYW1lT3JpZ2luKGRvY3VtZW50LmxvY2F0aW9uLmhyZWYpKSB7XHJcbiAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBPcHRpb25zLmdldFZhbHVlKE9QVElPTl9SRVNPVVJDRV9DT1JTKTtcclxuICAgIH1cclxuXHJcbiAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgbG9hZExpc3RlbmVyKGUsIGltYWdlKTtcclxuICAgICAgICBSZXNvdXJjZUNvdW50ZXIucmVzb2x2ZVBlbmRpbmdSZXNvdXJjZSh1cmksIDApO1xyXG4gICAgfTtcclxuICAgIGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgaWYgKGltYWdlLmNyb3NzT3JpZ2luKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0lzc3VlKFwiTWF5IGhhdmUgYXR0ZW1wdGVkIHRvIHVzZSBhIGNyb3NzLW9yaWdpbiB0ZXh0dXJlIHdpdGhvdXQgcHJvcGVyIGNyb3NzLW9yaWdpbiBoYW5kbGluZy5cIiwgMTY0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXJyb3JMaXN0ZW5lcihlLCBpbWFnZSk7XHJcbiAgICAgICAgUmVzb3VyY2VDb3VudGVyLnJlc29sdmVQZW5kaW5nUmVzb3VyY2UodXJpLCAwKTtcclxuICAgIH07XHJcblxyXG4gICAgaW1hZ2Uuc3JjID0gdXJpLnRvU3RyaW5nKCk7IC8vIGhlcmUgbG9hZGluZyBzdGFydHNcclxuICAgIHJldHVybiBpbWFnZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB0byBsb2FkIGEgVmlkZW8uXHJcbiAqXHJcbiAqIEBwYXJhbSB7VVJJfSB1cmkgVmlkZW8gVVJJXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXV0b3BsYXlcclxuICogQHBhcmFtIHtib29sZWFufSBsb29wXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBsaXN0ZW5lcnMgIERpY3Rpb25hcnkgb2YgYWxsIGxpc3RlbmVycyB0byByZWdpc3RlciB3aXRoIHZpZGVvIGVsZW1lbnQuXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpc3RlbmVycyB3aWxsIGJlIGNhbGxlZCB3aXRoIGV2ZW50IGFzIHRoZSBmaXJzdCBhbmQgdmlkZW8gYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIuXHJcbiAqIEByZXR1cm4ge0hUTUxWaWRlb0VsZW1lbnR9XHJcbiAqL1xyXG5SZXNvdXJjZS5nZXRWaWRlbyA9IGZ1bmN0aW9uKHVyaSwgYXV0b3BsYXksIGxvb3AsIG11dGVkLCBsaXN0ZW5lcnMpIHtcclxuICAgIC8vIHdlIHVzZSBjYW52YXNJZCAwIHRvIHJlcHJlc2VudCB2aWRlb3MgbG9hZGVkIGluIGEgZG9jdW1lbnRcclxuICAgIFJlc291cmNlQ291bnRlci5hZGRQZW5kaW5nUmVzb3VyY2UodXJpLCAwKTtcclxuXHJcbiAgICAvLyBGSVhNRTogSW4gSFRNTCwgd2UgY3JlYXRlIGEgY29uZmlndXJlZCB2aWRlbywgcGxheS9wYXVzZSB3b24ndCB3b3JrXHJcbiAgICB2YXIgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XHJcbiAgICBpZiAoIXVyaS5oYXNTYW1lT3JpZ2luKGRvY3VtZW50LmxvY2F0aW9uLmhyZWYpKSB7XHJcbiAgICAgICAgdmlkZW8uY3Jvc3NPcmlnaW4gPSBPcHRpb25zLmdldFZhbHVlKE9QVElPTl9SRVNPVVJDRV9DT1JTKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbG9hZENvbXBsZXRlQ2FsbGJhY2sgPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgIGlmICh2aWRlby5jcm9zc09yaWdpbiAmJiBldmVudC50eXBlID09PSBcImVycm9yXCIpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nSXNzdWUoXCJNYXkgaGF2ZSBhdHRlbXB0ZWQgdG8gdXNlIGEgY3Jvc3Mtb3JpZ2luIHRleHR1cmUgd2l0aG91dCBwcm9wZXIgY3Jvc3Mtb3JpZ2luIGhhbmRsaW5nLlwiLCAxNjQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBSZXNvdXJjZUNvdW50ZXIucmVzb2x2ZVBlbmRpbmdSZXNvdXJjZSh1cmksIDApO1xyXG4gICAgICAgIHZpZGVvLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIGxvYWRDb21wbGV0ZUNhbGxiYWNrLCB0cnVlKTtcclxuICAgICAgICB2aWRlby5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgbG9hZENvbXBsZXRlQ2FsbGJhY2ssIHRydWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgdmlkZW8uYXV0b3BsYXkgPSBhdXRvcGxheTtcclxuICAgIHZpZGVvLmxvb3AgPSBsb29wO1xyXG4gICAgdmlkZW8ubXV0ZWQgPSBtdXRlZDtcclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVDYWxsYmFjayhsaXN0ZW5lcikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcihldmVudCwgdmlkZW8pO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGxpc3RlbmVycykge1xyXG4gICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjcmVhdGVDYWxsYmFjayhsaXN0ZW5lcnNbZXZlbnROYW1lXSksIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIGxvYWRDb21wbGV0ZUNhbGxiYWNrLCB0cnVlKTtcclxuICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBsb2FkQ29tcGxldGVDYWxsYmFjaywgdHJ1ZSk7XHJcblxyXG4gICAgdmlkZW8uc3JjID0gdXJpLnRvU3RyaW5nKCk7IC8vIGhlcmUgbG9hZGluZyBzdGFydHNcclxuICAgIHJldHVybiB2aWRlbztcclxufTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlc291cmNlO1xyXG4iLCJcclxuLy8gRXh0ZXJuYWwgcmVzb3VyY2VzIHRoYXQgaGF2ZW4ndCBiZWVuIGZldGNoZWQgeWV0LCBwZXIgY2FudmFzSWQuIFdoZW4gdGhpcyByZWFjaGVzIDAgdGhlIFwibG9hZFwiIGV2ZW50IGlzIGRpc3BhdGNoZWRcclxudmFyIGNfcGVuZGluZ1Jlc291cmNlcyA9IHt9O1xyXG5cclxudmFyIFJlc291cmNlQ291bnRlciA9IHt9O1xyXG5cclxuUmVzb3VyY2VDb3VudGVyLmFkZFBlbmRpbmdSZXNvdXJjZSA9IGZ1bmN0aW9uKHVyaSwgY2FudmFzSWQpIHtcclxuICAgIFJlc291cmNlQ291bnRlci5nZXRPckNyZWF0ZVBlbmRpbmdSZXNvdXJjZXMoY2FudmFzSWQpLmVudHJpZXMucHVzaCh1cmkudG9TdHJpbmcoKSk7XHJcbn07XHJcblxyXG5SZXNvdXJjZUNvdW50ZXIucmVzb2x2ZVBlbmRpbmdSZXNvdXJjZSA9IGZ1bmN0aW9uKHVyaSwgY2FudmFzSWQpIHtcclxuICAgIC8vIG5vdGlmeSBhbGwgbG9hZCBjb21wbGV0ZSBsaXN0ZW5lcnNcclxuICAgIHZhciB1cmwgPSB1cmkudG9TdHJpbmcoKTtcclxuICAgIHZhciBwZW5kaW5nUmVzb3VyY2VzID0gY19wZW5kaW5nUmVzb3VyY2VzW2NhbnZhc0lkXTtcclxuICAgIGlmIChwZW5kaW5nUmVzb3VyY2VzKSB7XHJcbiAgICAgICAgQXJyYXkuZXJhc2UocGVuZGluZ1Jlc291cmNlcy5lbnRyaWVzLCB1cmwpO1xyXG4gICAgICAgIGlmIChwZW5kaW5nUmVzb3VyY2VzLmVudHJpZXMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgUmVzb3VyY2VDb3VudGVyLm5vdGlmeUxvYWRDb21wbGV0ZUxpc3RlbmVycyhwZW5kaW5nUmVzb3VyY2VzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5SZXNvdXJjZUNvdW50ZXIuZ2V0T3JDcmVhdGVQZW5kaW5nUmVzb3VyY2VzID0gZnVuY3Rpb24oY2FudmFzSWQpIHtcclxuICAgIHZhciBwZW5kaW5nUmVzb3VyY2VzID0gY19wZW5kaW5nUmVzb3VyY2VzW2NhbnZhc0lkXTtcclxuICAgIGlmICghcGVuZGluZ1Jlc291cmNlcykge1xyXG4gICAgICAgIHBlbmRpbmdSZXNvdXJjZXMgPSB7ZW50cmllczogW10sIGxpc3RlbmVyczogW119O1xyXG4gICAgICAgIGNfcGVuZGluZ1Jlc291cmNlc1tjYW52YXNJZF0gPSBwZW5kaW5nUmVzb3VyY2VzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBlbmRpbmdSZXNvdXJjZXM7XHJcbn07XHJcblxyXG5SZXNvdXJjZUNvdW50ZXIubm90aWZ5TG9hZENvbXBsZXRlTGlzdGVuZXJzID0gZnVuY3Rpb24ocGVuZGluZ1Jlc291cmNlcykge1xyXG4gICAgdmFyIGxpc3RlbmVycyA9IHBlbmRpbmdSZXNvdXJjZXMubGlzdGVuZXJzO1xyXG4gICAgdmFyIGkgPSBsaXN0ZW5lcnMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGxpc3RlbmVyc1tpXSh0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblJlc291cmNlQ291bnRlci5pc0xvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uKGNhbnZhc0lkKSB7XHJcbiAgICByZXR1cm4gIWNfcGVuZGluZ1Jlc291cmNlc1tjYW52YXNJZF0gfHwgY19wZW5kaW5nUmVzb3VyY2VzW2NhbnZhc0lkXS5lbnRyaWVzLmxlbmd0aCA9PSAwO1xyXG59O1xyXG5cclxuLypcclxuICogUmVnaXN0ZXIgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYWxsIHJlc291cmNlcyBmb3Igc3BlY2lmaWVkIGNhbnZhc0lkIGFyZSBsb2FkZWQuXHJcbiAqIExpc3RlbmVyIGlzIGZpcmVkIG9ubHkgb25jZS5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IGNhbnZhc0lkXHJcbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcn0gbGlzdGVuZXJcclxuICovXHJcblJlc291cmNlQ291bnRlci5hZGRMb2FkQ29tcGxldGVMaXN0ZW5lciA9IGZ1bmN0aW9uKGNhbnZhc0lkLCBsaXN0ZW5lcikge1xyXG4gICAgdmFyIHBlbmRpbmdSZXNvdXJjZXMgPSBSZXNvdXJjZUNvdW50ZXIuZ2V0T3JDcmVhdGVQZW5kaW5nUmVzb3VyY2VzKGNhbnZhc0lkKTtcclxuICAgIHZhciBpZHggPSBwZW5kaW5nUmVzb3VyY2VzLmxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcclxuICAgIGlmIChpZHggPT0gLTEpIHtcclxuICAgICAgICBwZW5kaW5nUmVzb3VyY2VzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gY2FudmFzSWRcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXJcclxuICovXHJcblJlc291cmNlQ291bnRlci5yZW1vdmVMb2FkQ29tcGxldGVMaXN0ZW5lciA9IGZ1bmN0aW9uKGNhbnZhc0lkLCBsaXN0ZW5lcikge1xyXG4gICAgdmFyIHBlbmRpbmdSZXNvdXJjZXMgPSBjX3BlbmRpbmdSZXNvdXJjZXNbY2FudmFzSWRdO1xyXG4gICAgaWYgKHBlbmRpbmdSZXNvdXJjZXMpIHtcclxuICAgICAgICB2YXIgaWR4ID0gcGVuZGluZ1Jlc291cmNlcy5saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XHJcbiAgICAgICAgaWYgKGlkeCAhPSAtMSlcclxuICAgICAgICAgICAgcGVuZGluZ1Jlc291cmNlcy5saXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlc291cmNlQ291bnRlcjtcclxuXHJcbiIsIlxyXG5yZXF1aXJlKFwid2hhdHdnLWZldGNoXCIpO1xyXG52YXIgVVJJID0gcmVxdWlyZShcIi4uL3V0aWxzL3VyaS5qc1wiKS5VUkk7XHJcbnZhciBPcHRpb25zID0gcmVxdWlyZShcIi4uL3V0aWxzL29wdGlvbnMuanNcIik7XHJcblxyXG52YXIgTUFYX0NPTkNVUlJFTlRfUkVRVUVTVFMgPSAxMDA7ICAvLyBNYXhpbXVtIG51bWJlciBvZiByZXF1ZXN0cyBhd2FpdGluZyBhIHJlc3BvbnNlXHJcblxyXG52YXIgY19yZXF1ZXN0SG9va3MgPSBbXTsgICAgLy8gUmVxdWVzdCBob29rcyBjYWxsZWQgZm9yIGVhY2ggb3V0Z29pbmcgcmVxdWVzdFxyXG52YXIgY19mb3JtYXRIYW5kbGVycyA9IFtdOyAgLy8gQWxsIHJlZ2lzdGVyZWQgRm9ybWF0SGFuZGxlciBwbHVnaW5zXHJcbnZhciBjX3JlcXVlc3RRdWV1ZSA9IFtdOyAgICAvLyBSZXF1ZXN0cyB0aGF0IGhhdmVuJ3QgYmVlbiBzZW50IG91dCB5ZXRcclxudmFyIGNfb3BlblJlcXVlc3RzID0gMDsgICAgIC8vIE51bWJlciBvZiByZXF1ZXN0cyB0aGF0IGFyZSBjdXJyZW50bHkgd2FpdGluZyBvbiBhIHJlc3BvbnNlXHJcbnZhciBjX2NhY2hlZERvY3VtZW50cyA9IG5ldyBNYXAoKTsgLy8gQWxyZWFkeSByZWNlaXZlZCBhbmQgcHJvY2Vzc2VkIHJlc291cmNlcywgaW5kZXhlZCBieSBVUkwgd2l0aG91dCB0aGUgZnJhZ21lbnRcclxuXHJcbnZhciBSZXNvdXJjZSA9IHt9O1xyXG5cclxuUmVzb3VyY2UucmVnaXN0ZXJGb3JtYXRIYW5kbGVyID0gZnVuY3Rpb24oZm9ybWF0SGFuZGxlcikge1xyXG4gICAgaWYgKGZvcm1hdEhhbmRsZXIpXHJcbiAgICAgICAgY19mb3JtYXRIYW5kbGVycy5wdXNoKGZvcm1hdEhhbmRsZXIpO1xyXG59O1xyXG5cclxuUmVzb3VyY2UuZmV0Y2ggPSBmdW5jdGlvbih1cmlTdHJpbmcsIG9wdCkge1xyXG4gICAgb3B0ID0gaW5pdE9wdGlvbnMob3B0KTtcclxuICAgIHZhciB1cmkgPSBuZXcgVVJJKHVyaVN0cmluZyk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZvciAodmFyIGk9MDsgaSA8IGNfcmVxdWVzdEhvb2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNfcmVxdWVzdEhvb2tzW2ldKHVyaSwgb3B0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdC5hYm9ydCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWVzdEFib3J0ZWRFeGNlcHRpb24odXJpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2NoZWR1bGVSZXF1ZXN0KHtcclxuICAgICAgICAgICAgb3B0IDogb3B0LFxyXG4gICAgICAgICAgICB1cmkgOiB1cmksXHJcbiAgICAgICAgICAgIHJlc29sdmUgOiByZXNvbHZlLFxyXG4gICAgICAgICAgICByZWplY3QgOiByZWplY3RcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxudmFyIHBvcFJlcXVlc3RRdWV1ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHJlcXVlc3QgPSBjX3JlcXVlc3RRdWV1ZS5zaGlmdCgpO1xyXG4gICAgY19vcGVuUmVxdWVzdHMrKztcclxuXHJcbiAgICBmZXRjaChyZXF1ZXN0LnVyaS50b1N0cmluZygpLCByZXF1ZXN0Lm9wdClcclxuICAgICAgICAudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgICAgICBjX29wZW5SZXF1ZXN0cy0tO1xyXG4gICAgICAgICAgICByZXF1ZXN0LnJlc29sdmUocmVzcG9uc2UpO1xyXG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChleGNlcHRpb24pIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJDb3VsZCBub3QgcmV0cmlldmUgZG9jdW1lbnQgYXQgJ1wiK3JlcXVlc3QudXJpLnRvU3RyaW5nKCkrXCInLiBSZWFzb246IFwiK2V4Y2VwdGlvbik7XHJcbiAgICAgICAgICAgIGNfb3BlblJlcXVlc3RzLS07XHJcbiAgICAgICAgICAgIHJlcXVlc3QucmVqZWN0KGV4Y2VwdGlvbik7XHJcbiAgICAgICAgfSk7XHJcbn07XHJcblxyXG5SZXNvdXJjZS5nZXREb2N1bWVudCA9IGZ1bmN0aW9uKHVybFN0cmluZywgb3B0KSB7XHJcbiAgICByZXR1cm4gUmVzb3VyY2UuZmV0Y2godXJsU3RyaW5nLCBvcHQpXHJcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVlc3RGYWlsZWRFeGNlcHRpb24ocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3BvbnNlLm9yaWdpbmFsVVJMID0gdXJsU3RyaW5nO1xyXG4gICAgICAgICAgICB2YXIgY2FjaGU7XHJcbiAgICAgICAgICAgIGlmIChjYWNoZSA9IGNfY2FjaGVkRG9jdW1lbnRzLmdldCh1cmxTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUucGVuZGluZyA/IGNhY2hlLnBlbmRpbmcgOiBjYWNoZS5kb2N1bWVudDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlID0geyBmcmFnbWVudHMgOiBbXSB9O1xyXG4gICAgICAgICAgICAgICAgY19jYWNoZWREb2N1bWVudHMuc2V0KHVybFN0cmluZywgY2FjaGUpOyAvLyBSZXNvdXJjZS5wYXJzZVJlc3BvbnNlIGV4cGVjdHMgdGhpcyBlbnRyeSB0byBleGlzdCBhbHJlYWR5XHJcbiAgICAgICAgICAgICAgICBjYWNoZS5wZW5kaW5nID0gUmVzb3VyY2UucGFyc2VSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUucGVuZGluZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oZG9jKSB7XHJcbiAgICAgICAgICAgIGRvYy5fZG9jdW1lbnRVUkwgPSB1cmxTdHJpbmc7XHJcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IGNfY2FjaGVkRG9jdW1lbnRzLmdldCh1cmxTdHJpbmcpO1xyXG4gICAgICAgICAgICBjYWNoZS5kb2N1bWVudCA9IGRvYztcclxuICAgICAgICAgICAgZGVsZXRlIGNhY2hlLnBlbmRpbmc7XHJcbiAgICAgICAgICAgIHJldHVybiBkb2M7XHJcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgICAgIGNfY2FjaGVkRG9jdW1lbnRzLmhhcyh1cmxTdHJpbmcpICYmIGRlbGV0ZSBjX2NhY2hlZERvY3VtZW50cy5nZXQodXJsU3RyaW5nKS5wZW5kaW5nO1xyXG4gICAgICAgICAgICB0aHJvdyBleGNlcHRpb247XHJcbiAgICAgICAgfSk7XHJcbn07XHJcblxyXG5SZXNvdXJjZS5wYXJzZVJlc3BvbnNlID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICB2YXIgaGFuZGxlckNhbmRpZGF0ZXMgPSBjX2Zvcm1hdEhhbmRsZXJzLmZpbHRlcihmdW5jdGlvbihoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmlzRm9ybWF0U3VwcG9ydGVkKHJlc3BvbnNlKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLmJvZHlVc2VkKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiRm9ybWF0SGFuZGxlcnMgc2hvdWxkIG5vdCBhY2Nlc3MgdGhlIHJlc3BvbnNlIGJvZHkgaW4gdGhlIGlzRm9ybWF0U3VwcG9ydGVkIGZ1bmN0aW9uIHdpdGhvdXQgZmlyc3QgY2xvbmluZyB0aGUgcmVzcG9uc2Ugb2JqZWN0IVwiKTtcclxuICAgICAgICAgICAgcmVqZWN0KG5ldyBSZXNwb25zZUJvZHlVc2VkRXhjZXB0aW9uKHJlc3BvbnNlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaGFuZGxlckNhbmRpZGF0ZXMubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgLy9TcGVjaWFsIGNhc2UgdG8gYXZvaWQgdW5uZWNlc3NhcnkgY2xvbmluZyBvZiB0aGUgcmVzcG9uc2VcclxuICAgICAgICAgICAgaGFuZGxlckNhbmRpZGF0ZXNbMF0uZ2V0Rm9ybWF0RGF0YShyZXNwb25zZSkudGhlbihmdW5jdGlvbihkb2MpIHtcclxuICAgICAgICAgICAgICAgIGNfY2FjaGVkRG9jdW1lbnRzLmdldChyZXNwb25zZS5vcmlnaW5hbFVSTCkuaGFuZGxlciA9IGhhbmRsZXJDYW5kaWRhdGVzWzBdO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkb2MpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0cnlGb3JtYXRIYW5kbGVycyhoYW5kbGVyQ2FuZGlkYXRlcywgcmVzcG9uc2UsIGZ1bmN0aW9uKGZoLCBkb2MpIHtcclxuICAgICAgICAgICAgICAgIGNfY2FjaGVkRG9jdW1lbnRzLmdldChyZXNwb25zZS5vcmlnaW5hbFVSTCkuaGFuZGxlciA9IGZoO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkb2MpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJ5Rm9ybWF0SGFuZGxlcnMoY2FuZGlkYXRlcywgcmVzcG9uc2UsIGNhbGxiYWNrKSB7XHJcbiAgICAoZnVuY3Rpb24gdHJ5TmV4dEhhbmRsZXIoaW5kZXgpIHtcclxuICAgICAgICBpZiAoaW5kZXggPj0gY2FuZGlkYXRlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gUmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBhcnJheVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm8gRm9ybWF0SGFuZGxlciBjb3VsZCBiZSBmb3VuZCBmb3IgdGhlIGRvY3VtZW50IFwiK3Jlc3BvbnNlLnVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmaCA9IGNhbmRpZGF0ZXNbaW5kZXhdO1xyXG4gICAgICAgIGZoLmdldEZvcm1hdERhdGEocmVzcG9uc2UuY2xvbmUoKSkudGhlbihmdW5jdGlvbihkb2MpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soZmgsIGRvYyk7XHJcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB0cnlOZXh0SGFuZGxlcigrK2luZGV4KTtcclxuICAgICAgICB9KVxyXG4gICAgfSkoMCk7XHJcbn1cclxuXHJcblJlc291cmNlLm9uUmVxdWVzdCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICBjX3JlcXVlc3RIb29rcy5wdXNoKGNhbGxiYWNrKTtcclxufTtcclxuXHJcbnZhciBzY2hlZHVsZVJlcXVlc3QgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIGlmICghY19yZXF1ZXN0UXVldWUubGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgcXVldWUgd2FzIGVtcHR5IGJlZm9yZSBzbyB3ZSdyZSB3YWtpbmcgdXAgZnJvbSBhbiBpZGxlIHN0YXRlXHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrV29ya1dpbmRvdyk7XHJcbiAgICB9XHJcbiAgICBjX3JlcXVlc3RRdWV1ZS5wdXNoKG9iaik7XHJcbiAgICBpZiAob2JqLm9wdC5wcmlvcml0eSA+IDApIHtcclxuICAgICAgICAvLyAwIGlzIGxvd2VzdCBwcmlvcml0eSBzbyBwdXNoaW5nIGl0IHRvIHRoZSBiYWNrIGlzIGVub3VnaCwgZm9yIGFsbCBvdGhlciBwcmlvcml0aWVzIHdlIHNob3VsZCB0byByZXNvcnQgdGhlIGFycmF5XHJcbiAgICAgICAgY19yZXF1ZXN0UXVldWUuc29ydChwcmlvcml0eVNvcnQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIHByaW9yaXR5U29ydCA9IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgIHJldHVybiBiLm9wdC5wcmlvcml0eSAtIGEub3B0LnByaW9yaXR5OyAvL1NvcnQgZGVzY2VuZGluZywgaGlnaGVyIHByaW9yaXR5IGZpcnN0XHJcbn07XHJcblxyXG52YXIgdGlja1dvcmtXaW5kb3cgPSBmdW5jdGlvbigpIHtcclxuICAgIC8vIEJvdGggb2YgdGhlc2UgbG9vcHMgdHJpZ2dlciBhc3luY2hyb25vdXMgd29yayB0aHJvdWdoIFByb21pc2VzIHNvIHdvcmtpbmcgdGhyb3VnaCBhbGwgcXVldWUgaXRlbXMgc2hvdWxkbid0IGJsb2NrIHRoZSB0aHJlYWQgZm9yIHRvbyBsb25nXHJcbiAgICB3aGlsZSAoY19yZXF1ZXN0UXVldWUubGVuZ3RoID4gMCAmJiBjX29wZW5SZXF1ZXN0cyA8IE1BWF9DT05DVVJSRU5UX1JFUVVFU1RTKSB7XHJcbiAgICAgICAgcG9wUmVxdWVzdFF1ZXVlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNfcmVxdWVzdFF1ZXVlLmxlbmd0aCkge1xyXG4gICAgICAgIC8vIElmIHRoZXJlJ3MgbW9yZSB3b3JrIHRvIGRvIHNjaGVkdWxlIGFub3RoZXIgY2FsbCwgb3RoZXJ3aXNlIGlkbGUgdW50aWwgbW9yZSB3b3JrIGFycml2ZXMgaW4gdGhlIHNjaGVkdWxlV29yayBmdW5jdGlvblxyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGlja1dvcmtXaW5kb3cpO1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIGluaXRPcHRpb25zID0gZnVuY3Rpb24ob3B0KSB7XHJcbiAgICBvcHQgPSBvcHQgfHwge307XHJcbiAgICBvcHQuaGVhZGVycyA9IG9wdC5oZWFkZXJzIHx8IHt9O1xyXG4gICAgb3B0LnByaW9yaXR5ID0gb3B0LnByaW9yaXR5IHx8IDA7XHJcbiAgICBvcHQuYWJvcnQgPSBvcHQuYWJvcnQgfHwgZmFsc2U7XHJcbiAgICByZXR1cm4gb3B0O1xyXG59O1xyXG5cclxuLy8gQWRkIGEgaG9vayB0byBjaGVjayBmb3IgZmlsZTovLyByZXF1ZXN0cyB0byB3YXJuIHRoZSB1c2VyIHRoYXQgYSBzZXJ2ZXIgaXMgbmVlZGVkIHRvIHVzZSBYTUwzRFxyXG5SZXNvdXJjZS5vblJlcXVlc3QoZnVuY3Rpb24odXJpLCBvcHQpIHtcclxuICAgIGlmICh1cmkudG9TdHJpbmcoKS5tYXRjaCgvKGZpbGU6KVxcLysoW0Etel06XFwvKS8pKSB7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nSXNzdWUoXCJFbmNvdW50ZXJlZCBhIGZpbGVzeXN0ZW0gcmVxdWVzdDogJ1wiICsgdXJpICsgXCInLiBBIGxvY2FsIHNlcnZlciBpcyBuZWVkZWQgdG8gdXNlIFhNTDNELlwiLCAxNjIpO1xyXG4gICAgICAgIG9wdC5hYm9ydCA9IHRydWU7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZHMgcmV0dXJucyBhbiBhYnNvbHV0ZSBVUkkgY29tcGF0aWJsZSB3aXRoIHRoZSByZXNvdXJjZSBtYW5hZ2VyLlxyXG4gKiBUaGlzIG1lYW5zOiBBbnkgcmVmZXJlbmNlIGZyb20gYW4gZXh0ZXJuYWwgZG9jdW1lbnQgd2lsbCBiZSBhYnNvbHV0ZSBhbmQgYW55IGlkIHJlZmVyZW5jZSBmcm9tIHRoZSBjdXJyZW50XHJcbiAqIGRvY3VtZW50IHdpbGwgcmVtYWluIGFuIGlkIHJlZmVyZW5jZS5cclxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2VVUkkgLSB0aGUgYmFzZSBVUkkgdGhhdCB0aGUgdXJpIGlzIHJlbGF0aXZlIHRvXHJcbiAqIEBwYXJhbSB7VVJJfSB1cmkgLSBUaGUgVVJJIHVzZWQgdG8gZmluZCB0aGUgcmVmZXJyZWQgQWRhcHRlckhhbmRsZS4gQ2FuIGJlIHJlbGF0aXZlXHJcbiAqIEByZXR1cm5zIHtVUkl9IFRoZSAoc29tZXRpbWVzKSBhYnNvbHV0ZSBVUklcclxuICovXHJcblJlc291cmNlLmdldEFic29sdXRlVVJJID0gZnVuY3Rpb24oYmFzZVVSSSwgdXJpKXtcclxuICAgIGlmICghdXJpKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIGlmICh0eXBlb2YgdXJpID09IFwic3RyaW5nXCIpIHVyaSA9IG5ldyBVUkkodXJpKTtcclxuICAgIGlmIChiYXNlVVJJICE9IGRvY3VtZW50LlVSTCB8fCAhdXJpLmlzTG9jYWwoKSkge1xyXG4gICAgICAgIHVyaSA9IHVyaS5nZXRBYnNvbHV0ZVVSSShiYXNlVVJJKTtcclxuICAgIH1cclxuICAgIHJldHVybiB1cmk7XHJcbn07XHJcblxyXG5SZXNvdXJjZS5nZXREb2N1bWVudENhY2hlID0gZnVuY3Rpb24odXJsU3RyaW5nKSB7XHJcbiAgICByZXR1cm4gY19jYWNoZWREb2N1bWVudHMuZ2V0KHVybFN0cmluZyk7XHJcbn07XHJcblxyXG5cclxuZnVuY3Rpb24gUmVxdWVzdEFib3J0ZWRFeGNlcHRpb24odXJsKSB7XHJcbiAgICB0aGlzLm5hbWUgPSBcIlJlcXVlc3RBYm9ydGVkRXhjZXB0aW9uXCI7XHJcbiAgICB0aGlzLm1lc3NhZ2UgPSBcIlJlcXVlc3Qgd2FzIGFib3J0ZWQgYnkgYW4gb25SZXF1ZXN0IGxpc3RlbmVyOiBcIit1cmw7XHJcbiAgICB0aGlzLnVybCA9IHVybDtcclxuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xyXG59XHJcblJlcXVlc3RBYm9ydGVkRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcclxuUmVxdWVzdEFib3J0ZWRFeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVxdWVzdEFib3J0ZWRFeGNlcHRpb247XHJcblxyXG5mdW5jdGlvbiBSZXNwb25zZUJvZHlVc2VkRXhjZXB0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICB0aGlzLm5hbWUgPSBcIlJlc3BvbnNlQm9keVVzZWRFeGNlcHRpb25cIjtcclxuICAgIHRoaXMubWVzc2FnZSA9IFwiVGhlIGJvZHkgb2YgdGhlIFJlc3BvbnNlIHdhcyByZWFkIHByZW1hdHVyZWx5LlwiO1xyXG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xyXG4gICAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XHJcbn1cclxuUmVzcG9uc2VCb2R5VXNlZEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XHJcblJlc3BvbnNlQm9keVVzZWRFeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVzcG9uc2VCb2R5VXNlZEV4Y2VwdGlvbjtcclxuXHJcbmZ1bmN0aW9uIFJlcXVlc3RGYWlsZWRFeGNlcHRpb24ocmVzcG9uc2UpIHtcclxuICAgIHRoaXMubmFtZSA9IFwiUmVxdWVzdEZhaWxlZEV4Y2VwdGlvblwiO1xyXG4gICAgdGhpcy5tZXNzYWdlID0gXCJUaGUgcmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSBcIityZXNwb25zZS5zdGF0dXM7XHJcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XHJcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcclxufVxyXG5SZXF1ZXN0RmFpbGVkRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcclxuUmVxdWVzdEZhaWxlZEV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXF1ZXN0RmFpbGVkRXhjZXB0aW9uO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVzb3VyY2U7XHJcblxyXG4iLCJcclxuLyoqXHJcbiAqIEEgZm9ybWF0IGhhbmRsZXIgaXMgcHJvdmlkZSBmdW5jdGlvbmFsaXR5IGZvciBkZXRlY3RpbmcgZm9ybWF0IG9mIHJlc291cmNlc1xyXG4gKiBhbmQgcHJvdmlkaW5nIGZvcm1hdC1zcGVjaWZpYyBzZXJ2aWNlcy5cclxuICogRm9ybWF0SGFuZGxlcnMgYXJlIHJlZ2lzdGVyZWQgd2l0aCBYTUwzRC5yZXNvdXJjZS5yZWdpc3RlckZvcm1hdEhhbmRsZXIoKSBmdW5jdGlvbi5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgRm9ybWF0SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xyXG59O1xyXG5cclxuLy9ub2luc3BlY3Rpb24gSlNVbnVzZWRMb2NhbFN5bWJvbHNcclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiByZXNwb25zZSBkYXRhIGZvcm1hdCBpcyBzdXBwb3J0ZWQuXHJcbiAqIHJlc3BvbnNlIGlzIGEgUmVzcG9uc2Ugb2JqZWN0IGFzIGRlZmluZWQgYnkgdGhlIEZldGNoIEFQSS5cclxuICogVGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IHJlYWQgdGhlIGJvZHkgb2YgdGhlIHJlc3BvbnNlIHdpdGhvdXQgY2xvbmluZyBpdCBmaXJzdC5cclxuICpcclxuICogQG92ZXJyaWRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuRm9ybWF0SGFuZGxlci5wcm90b3R5cGUuaXNGb3JtYXRTdXBwb3J0ZWQgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyByZXNwb25zZSBkYXRhIHRvIGZvcm1hdCBkYXRhLlxyXG4gKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgdmFsdWUgb2YgcmVzcG9uc2UuXHJcbiAqXHJcbiAqIEBvdmVycmlkZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2VcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKi9cclxuRm9ybWF0SGFuZGxlci5wcm90b3R5cGUuZ2V0Rm9ybWF0RGF0YSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogRXh0cmFjdHMgZGF0YSBmb3IgYSBmcmFnbWVudCBmcm9tIGRvY3VtZW50IGRhdGEgYW5kIGZyYWdtZW50IHJlZmVyZW5jZS5cclxuICpcclxuICogQG92ZXJyaWRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2N1bWVudERhdGFcclxuICogQHBhcmFtIHtzdHJpbmd9IGZyYWdtZW50IEZyYWdtZW50IHdpdGhvdXQgcG91bmQga2V5IHdoaWNoIGRlZmluZXMgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50XHJcbiAqIEByZXR1cm4geyp9XHJcbiAqL1xyXG5Gb3JtYXRIYW5kbGVyLnByb3RvdHlwZS5nZXRGcmFnbWVudERhdGEgPSBmdW5jdGlvbiAoZG9jdW1lbnREYXRhLCBmcmFnbWVudCkge1xyXG4gICAgaWYgKCFmcmFnbWVudClcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnREYXRhO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBBZGFwdGVyIGZvciB0aGUgZ2l2ZW4gYXNwZWN0LiBTaG91bGQgYmUgb3ZlcnJpZGRlbi5cclxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuICogQHBhcmFtIHtTdHJpbmd9IGFzcGVjdFxyXG4gKiBAcGFyYW0gez9OdW1iZXJ9IGNhbnZhc0lkXHJcbiAqIEByZXR1cm5zIHtBZGFwdGVyfVxyXG4gKi9cclxuRm9ybWF0SGFuZGxlci5wcm90b3R5cGUuZ2V0QWRhcHRlciA9IGZ1bmN0aW9uKGRhdGEsIGFzcGVjdCwgY2FudmFzSWQpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGb3JtYXRIYW5kbGVyO1xyXG4iLCJ2YXIgUmVzb3VyY2UgPSB7fTtcclxuWE1MM0QuZXh0ZW5kKFJlc291cmNlLCByZXF1aXJlKFwiLi9jb29yZGluYXRvci5qc1wiKSk7XHJcblhNTDNELmV4dGVuZChSZXNvdXJjZSwgcmVxdWlyZShcIi4vZmV0Y2hlci5qc1wiKSk7XHJcblJlc291cmNlLkZvcm1hdEhhbmRsZXIgPSByZXF1aXJlKFwiLi9mb3JtYXRoYW5kbGVyLmpzXCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZXNvdXJjZTtcclxuIiwidmFyIFhNTDNERGF0YUFkYXB0ZXJGYWN0b3J5ID0gcmVxdWlyZShcIi4uL2RhdGEvYWRhcHRlci9mYWN0b3J5LmpzXCIpO1xyXG52YXIgUmVuZGVyQWRhcHRlckZhY3RvcnkgPSByZXF1aXJlKFwiLi4vcmVuZGVyZXIvcmVuZGVyZXIvYWRhcHRlci9mYWN0b3J5LmpzXCIpO1xyXG52YXIgY29uZmlnID0gcmVxdWlyZShcIi4uL2ludGVyZmFjZS9lbGVtZW50cy5qc1wiKS5jb25maWc7XHJcblxyXG4vKipcclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIEZvcm1hdEhhbmRsZXJcclxuICovXHJcbnZhciBYTUwzREZvcm1hdEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBYTUwzRC5yZXNvdXJjZS5Gb3JtYXRIYW5kbGVyLmNhbGwodGhpcyk7XHJcbiAgICB0aGlzLnJlbmRlckFkYXB0ZXJGYWN0b3JpZXMgPSB7fTtcclxuICAgIHRoaXMuZGF0YUFkYXB0ZXJGYWN0b3J5ID0gbmV3IFhNTDNERGF0YUFkYXB0ZXJGYWN0b3J5KCk7XHJcbn07XHJcblhNTDNELmNyZWF0ZUNsYXNzKFhNTDNERm9ybWF0SGFuZGxlciwgWE1MM0QucmVzb3VyY2UuRm9ybWF0SGFuZGxlcik7XHJcblxyXG5YTUwzREZvcm1hdEhhbmRsZXIucHJvdG90eXBlLmlzRm9ybWF0U3VwcG9ydGVkID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICBpZiAocmVzcG9uc2UuaGVhZGVycy5oYXMoXCJDb250ZW50LVR5cGVcIikpIHtcclxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIikgPT09IFwiYXBwbGljYXRpb24veG1sXCI7XHJcbiAgICB9XHJcbiAgICBpZiAocmVzcG9uc2UudXJsLm1hdGNoKC9cXC54bWwvKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuWE1MM0RGb3JtYXRIYW5kbGVyLnByb3RvdHlwZS5nZXRGb3JtYXREYXRhID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2VUZXh0KSB7XHJcbiAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcclxuICAgICAgICB2YXIgZG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhyZXNwb25zZVRleHQsIFwidGV4dC94bWxcIik7XHJcblxyXG4gICAgICAgIHZhciB4bWwzZEVsZW1lbnRzID0gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoXCJ4bWwzZFwiKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhtbDNkRWxlbWVudHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgY29uZmlnLmVsZW1lbnQoeG1sM2RFbGVtZW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb2M7XHJcbiAgICB9KTtcclxufTtcclxuXHJcblhNTDNERm9ybWF0SGFuZGxlci5wcm90b3R5cGUuZ2V0RnJhZ21lbnREYXRhID0gZnVuY3Rpb24gKGRvY3VtZW50RGF0YSwgZnJhZ21lbnQpIHtcclxuICAgIHJldHVybiBkb2N1bWVudERhdGEucXVlcnlTZWxlY3RvcihcIipbaWQ9J1wiICsgZnJhZ21lbnQgKyBcIiddXCIpO1xyXG59O1xyXG5cclxuWE1MM0RGb3JtYXRIYW5kbGVyLnByb3RvdHlwZS5nZXRBZGFwdGVyID0gZnVuY3Rpb24obm9kZSwgYXNwZWN0LCBjYW52YXNJZCkge1xyXG4gICAgaWYgKGFzcGVjdCA9PT0gXCJzY2VuZVwiKSB7XHJcbiAgICAgICAgaWYgKGNhbnZhc0lkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBjYW52YXMgSUQgY29ycmVzcG9uZGluZyB0byBhbiBYTUwzRCBlbGVtZW50IG11c3QgYmUgcHJvdmlkZWQgd2hlbiBjcmVhdGluZyBhbiBhZGFwdGVyIHdpdGggdGhlICdzY2VuZScgYXNwZWN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMucmVuZGVyQWRhcHRlckZhY3Rvcmllc1tjYW52YXNJZF0pIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJBZGFwdGVyRmFjdG9yaWVzW2NhbnZhc0lkXSA9IG5ldyBSZW5kZXJBZGFwdGVyRmFjdG9yeShjYW52YXNJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckFkYXB0ZXJGYWN0b3JpZXNbY2FudmFzSWRdLmdldEFkYXB0ZXIobm9kZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoYXNwZWN0ID09PSBcImRhdGFcIikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFBZGFwdGVyRmFjdG9yeS5nZXRBZGFwdGVyKG5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHRocm93IG5ldyBFcnJvcihcIkVuY291bnRlcmVkIGFuIHVua25vd24gYXNwZWN0ICdcIithc3BlY3QrXCInXCIpO1xyXG59O1xyXG5cclxuWE1MM0RGb3JtYXRIYW5kbGVyLnByb3RvdHlwZS5nZXRGYWN0b3J5ID0gZnVuY3Rpb24oYXNwZWN0LCBjYW52YXNJZCkge1xyXG4gICAgaWYgKGFzcGVjdCA9PT0gXCJzY2VuZVwiKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlckFkYXB0ZXJGYWN0b3JpZXNbY2FudmFzSWRdKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQWRhcHRlckZhY3Rvcmllc1tjYW52YXNJZF0gPSBuZXcgUmVuZGVyQWRhcHRlckZhY3RvcnkoY2FudmFzSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJBZGFwdGVyRmFjdG9yaWVzW2NhbnZhc0lkXTtcclxuICAgIH1cclxufTtcclxuXHJcbnZhciB4bWwzZEZvcm1hdEhhbmRsZXIgPSBuZXcgWE1MM0RGb3JtYXRIYW5kbGVyKCk7XHJcblhNTDNELnJlc291cmNlLnJlZ2lzdGVyRm9ybWF0SGFuZGxlcih4bWwzZEZvcm1hdEhhbmRsZXIpO1xyXG5YTUwzRC54bWwzZEZvcm1hdEhhbmRsZXIgPSB4bWwzZEZvcm1hdEhhbmRsZXI7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIFhNTDNERm9ybWF0SGFuZGxlciA6IFhNTDNERm9ybWF0SGFuZGxlclxyXG59OyIsInZhciB2ZWM0ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS52ZWM0O1xyXG52YXIgVmVjMyA9IHJlcXVpcmUoXCIuL3ZlYzMuanNcIik7XHJcbnZhciBRdWF0ID0gcmVxdWlyZShcIi4vcXVhdC5qc1wiKTtcclxuXHJcbnZhciBBeGlzQW5nbGUgPSBmdW5jdGlvbih2ZWMsIHksIHosIGFuZ2xlKSB7XHJcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEF4aXNBbmdsZSkge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IHZlYzQuY3JlYXRlKCk7XHJcbiAgICAgICAgaWYgKGFuZ2xlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhWzBdID0gdmVjO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFbMV0gPSB5O1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFbMl0gPSB6O1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFbM10gPSBhbmdsZTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICBpZiAodmVjKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5zZXQodmVjLmRhdGEgPyB2ZWMuZGF0YSA6IHZlYyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhWzJdID0gMTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgcmV0dXJuIG5ldyBBeGlzQW5nbGUodmVjLCB5LCB6LCBhbmdsZSk7XHJcbn07XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEF4aXNBbmdsZS5wcm90b3R5cGUsIFwiYXhpc1wiLCB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHZlYyl7XHJcbiAgICAgICAgdGhpcy5kYXRhWzBdID0gdmVjLmRhdGEgPyB2ZWMuZGF0YVswXSA6IHZlY1swXTtcclxuICAgICAgICB0aGlzLmRhdGFbMV0gPSB2ZWMuZGF0YSA/IHZlYy5kYXRhWzFdIDogdmVjWzFdO1xyXG4gICAgICAgIHRoaXMuZGF0YVsyXSA9IHZlYy5kYXRhID8gdmVjLmRhdGFbMl0gOiB2ZWNbMl07XHJcbiAgICB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gVmVjMy53cmFwKHRoaXMuZGF0YSkgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEF4aXNBbmdsZS5wcm90b3R5cGUsIFwiYW5nbGVcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbihhKXtcclxuICAgICAgICB0aGlzLmRhdGFbM10gPSBhO1xyXG4gICAgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVszXTsgfVxyXG59KTtcclxuXHJcbkF4aXNBbmdsZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuICAgcmV0dXJuIG5ldyBBeGlzQW5nbGUodGhpcyk7XHJcbn07XHJcblxyXG5BeGlzQW5nbGUuZnJvbVF1YXQgPSBmdW5jdGlvbihxKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IEF4aXNBbmdsZSgpO1xyXG4gICAgb3V0LmRhdGEuc2V0KFhNTDNELm1hdGgudmVjNC5mcm9tUXVhdChxLmRhdGEgPyBxLmRhdGEgOiBxKSk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuQXhpc0FuZ2xlLnByb3RvdHlwZS50b0RPTVN0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHZlYzQudG9ET01TdHJpbmcodGhpcy5kYXRhKTtcclxufTtcclxuXHJcbkF4aXNBbmdsZS5mcm9tRE9NU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IEF4aXNBbmdsZSgpO1xyXG4gICAgb3V0LmRhdGEuc2V0KCB2ZWM0LmZyb21ET01TdHJpbmcoc3RyKSApO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbkF4aXNBbmdsZS5wcm90b3R5cGUudG9RdWF0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IFF1YXQoKTtcclxuICAgIHF1YXQuc2V0QXhpc0FuZ2xlKG91dC5kYXRhLCB0aGlzLmRhdGEsIHRoaXMuZGF0YVszXSk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuQXhpc0FuZ2xlLndyYXAgPSBmdW5jdGlvbih2ZWMpIHtcclxuICAgIHZhciB2ID0gQXhpc0FuZ2xlKCk7XHJcbiAgICB2LmRhdGEgPSB2ZWMuZGF0YSA/IHZlYy5kYXRhIDogdmVjO1xyXG4gICAgcmV0dXJuIHY7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEF4aXNBbmdsZTtcclxuIiwidmFyIFZlYzMgPSByZXF1aXJlKFwiLi92ZWMzLmpzXCIpO1xyXG52YXIgdmVjMyA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikudmVjMztcclxuXHJcbnZhciBCb3ggPSBmdW5jdGlvbihib3gpIHtcclxuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQm94KSB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheSg2KTtcclxuICAgICAgICBpZiAoYm94KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5zZXQoYm94LmRhdGEgPyBib3guZGF0YSA6IGJveCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRFbXB0eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSByZXR1cm4gbmV3IEJveChib3gpO1xyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJveC5wcm90b3R5cGUsIFwibWluXCIsIHtcclxuICAgIHNldDogZnVuY3Rpb24odil7XHJcbiAgICAgICAgdmFyIHZhbCA9IHYuZGF0YSA/IHYuZGF0YSA6IHY7XHJcbiAgICAgICAgdGhpcy5kYXRhWzBdID0gdmFsWzBdO1xyXG4gICAgICAgIHRoaXMuZGF0YVsxXSA9IHZhbFsxXTtcclxuICAgICAgICB0aGlzLmRhdGFbMl0gPSB2YWxbMl07XHJcbiAgICB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiBWZWMzLndyYXAodGhpcy5kYXRhLnN1YmFycmF5KDAsMykpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCb3gucHJvdG90eXBlLCBcIm1heFwiLCB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpe1xyXG4gICAgICAgIHZhciB2YWwgPSB2LmRhdGEgPyB2LmRhdGEgOiB2O1xyXG4gICAgICAgIHRoaXMuZGF0YVszXSA9IHZhbFswXTtcclxuICAgICAgICB0aGlzLmRhdGFbNF0gPSB2YWxbMV07XHJcbiAgICAgICAgdGhpcy5kYXRhWzVdID0gdmFsWzJdO1xyXG4gICAgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gVmVjMy53cmFwKHRoaXMuZGF0YS5zdWJhcnJheSgzLDYpKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5Cb3gucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gbmV3IEJveCh0aGlzKTtcclxufTtcclxuXHJcbkJveC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICB0aGlzLmNvcHlNaW4ob3RoZXIpO1xyXG4gICAgdGhpcy5jb3B5TWF4KG90aGVyKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuQm94LnByb3RvdHlwZS5jb3B5TWluID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgIHZlYzMuY29weSh0aGlzLmRhdGEsIG90aGVyLmRhdGEgPyBvdGhlci5kYXRhIDogb3RoZXIpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5Cb3gucHJvdG90eXBlLmNvcHlNYXggPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgdmVjMy5jb3B5KHRoaXMuZGF0YS5zdWJhcnJheSgzLDYpLCBvdGhlci5kYXRhID8gb3RoZXIuZGF0YS5zdWJhcnJheSgzLDYpIDogb3RoZXIuc3ViYXJyYXkoMyw2KSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkJveC5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgIHZhciBib3ggPSBvdGhlci5kYXRhID8gb3RoZXIuZGF0YSA6IG90aGVyO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcclxuICAgICAgICB0aGlzLmRhdGFbaV0gPSBNYXRoLm1pbihib3hbaV0sIHRoaXMuZGF0YVtpXSk7XHJcbiAgICAgICAgdGhpcy5kYXRhW2kgKyAzXSA9IE1hdGgubWF4KGJveFtpICsgM10sIHRoaXMuZGF0YVtpICsgM10pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5Cb3gucHJvdG90eXBlLnNldEVtcHR5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmRhdGFbMF0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgdGhpcy5kYXRhWzFdID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIHRoaXMuZGF0YVsyXSA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICB0aGlzLmRhdGFbM10gPSAtTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIHRoaXMuZGF0YVs0XSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgdGhpcy5kYXRhWzVdID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkJveC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuICh0aGlzLmRhdGFbMF0gPiB0aGlzLmRhdGFbM10gfHwgdGhpcy5kYXRhWzFdID4gdGhpcy5kYXRhWzRdIHx8IHRoaXMuZGF0YVsyXSA+IHRoaXMuZGF0YVs1XSk7XHJcbn07XHJcblxyXG5Cb3gucHJvdG90eXBlLmNlbnRlciA9IGZ1bmN0aW9uKHRhcmdldCkge1xyXG4gICAgdmFyIGNlbiA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xyXG4gICAgY2VuLnggPSAodGhpcy5kYXRhWzBdICsgdGhpcy5kYXRhWzNdKSAqIDAuNTtcclxuICAgIGNlbi55ID0gKHRoaXMuZGF0YVsxXSArIHRoaXMuZGF0YVs0XSkgKiAwLjU7XHJcbiAgICBjZW4ueiA9ICh0aGlzLmRhdGFbMl0gKyB0aGlzLmRhdGFbNV0pICogMC41O1xyXG4gICAgcmV0dXJuIGNlbjtcclxufTtcclxuXHJcbkJveC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKHRhcmdldCkge1xyXG4gICAgdmFyIHNpemUgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcclxuICAgIHNpemUueCA9IE1hdGgubWF4KHRoaXMuZGF0YVszXSAtIHRoaXMuZGF0YVswXSwgMCk7XHJcbiAgICBzaXplLnkgPSBNYXRoLm1heCh0aGlzLmRhdGFbNF0gLSB0aGlzLmRhdGFbMV0sIDApO1xyXG4gICAgc2l6ZS56ID0gTWF0aC5tYXgodGhpcy5kYXRhWzVdIC0gdGhpcy5kYXRhWzJdLCAwKTtcclxuICAgIHJldHVybiBzaXplO1xyXG59O1xyXG5cclxuQm94LnByb3RvdHlwZS5leHRlbnQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnNpemUoKS5zY2FsZSgwLjUpO1xyXG59O1xyXG5cclxuQm94LnByb3RvdHlwZS50cmFuc2Zvcm1BeGlzQWxpZ25lZCA9IGZ1bmN0aW9uKG1hdCkge1xyXG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSg2KTtcclxuICAgIHZhciBtID0gbWF0LmRhdGEgPyBtYXQuZGF0YSA6IG1hdDtcclxuICAgIGlmIChtWzNdID09IDAgJiYgbVs3XSA9PSAwICYmIG1bMTFdID09IDAgJiYgbVsxNV0gPT0gMSkge1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xyXG4gICAgICAgICAgICBvdXRbaV0gPSBvdXRbaSArIDNdID0gbVsxMiArIGldO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAzOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBhLCBiO1xyXG5cclxuICAgICAgICAgICAgICAgIGEgPSBtW2ogKiA0ICsgaV0gKiB0aGlzLmRhdGFbal07XHJcbiAgICAgICAgICAgICAgICBiID0gbVtqICogNCArIGldICogdGhpcy5kYXRhW2ogKyAzXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYSA8IGIpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRbaV0gKz0gYTtcclxuICAgICAgICAgICAgICAgICAgICBvdXRbaSArIDNdICs9IGI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRbaV0gKz0gYjtcclxuICAgICAgICAgICAgICAgICAgICBvdXRbaSArIDNdICs9IGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kYXRhLnNldChvdXQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWF0cml4IGlzIG5vdCBhZmZpbmVcIik7XHJcbn07XHJcblxyXG5Cb3gucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKG1hdCkge1xyXG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB2ZWMzLnRyYW5zZm9ybU1hdDQodGhpcy5taW4uZGF0YSwgdGhpcy5taW4uZGF0YSwgbWF0LmRhdGEgPyBtYXQuZGF0YSA6IG1hdCk7XHJcbiAgICB2ZWMzLnRyYW5zZm9ybU1hdDQodGhpcy5tYXguZGF0YSwgdGhpcy5tYXguZGF0YSwgbWF0LmRhdGEgPyBtYXQuZGF0YSA6IG1hdCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkJveC5wcm90b3R5cGUubG9uZ2VzdFNpZGUgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgdmFyIHggPSBNYXRoLmFicyh0aGlzLmRhdGFbM10gLSB0aGlzLmRhdGFbMF0pO1xyXG4gICAgdmFyIHkgPSBNYXRoLmFicyh0aGlzLmRhdGFbNF0gLSB0aGlzLmRhdGFbMV0pO1xyXG4gICAgdmFyIHogPSBNYXRoLmFicyh0aGlzLmRhdGFbNV0gLSB0aGlzLmRhdGFbMl0pO1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KHgsIE1hdGgubWF4KHksIHopKTtcclxufTtcclxuXHJcbkJveC5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKHJheSwgb3B0KSB7XHJcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcclxuICAgICAgICBpZiAob3B0ICE9PSB1bmRlZmluZWQgJiYgb3B0LmRpc3QgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvcHQuZGlzdCA9IEluZmluaXR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YXIgb3JpZ2luID0gcmF5Lm9yaWdpbjtcclxuICAgIHZhciBkaXJlY3Rpb24gPSByYXkuZGlyZWN0aW9uO1xyXG4gICAgdmFyIGludmVyc2VEaXJYID0gMSAvIGRpcmVjdGlvbi54O1xyXG4gICAgdmFyIGludmVyc2VEaXJZID0gMSAvIGRpcmVjdGlvbi55O1xyXG4gICAgdmFyIGludmVyc2VEaXJaID0gMSAvIGRpcmVjdGlvbi56O1xyXG5cclxuICAgIHZhciB0MSA9ICh0aGlzLmRhdGFbMF0gLSBvcmlnaW4ueCkgKiBpbnZlcnNlRGlyWDtcclxuICAgIHZhciB0MiA9ICh0aGlzLmRhdGFbM10gLSBvcmlnaW4ueCkgKiBpbnZlcnNlRGlyWDtcclxuICAgIHZhciB0MyA9ICh0aGlzLmRhdGFbMV0gLSBvcmlnaW4ueSkgKiBpbnZlcnNlRGlyWTtcclxuICAgIHZhciB0NCA9ICh0aGlzLmRhdGFbNF0gLSBvcmlnaW4ueSkgKiBpbnZlcnNlRGlyWTtcclxuICAgIHZhciB0NSA9ICh0aGlzLmRhdGFbMl0gLSBvcmlnaW4ueikgKiBpbnZlcnNlRGlyWjtcclxuICAgIHZhciB0NiA9ICh0aGlzLmRhdGFbNV0gLSBvcmlnaW4ueikgKiBpbnZlcnNlRGlyWjtcclxuXHJcbiAgICB2YXIgdG1pbiA9IE1hdGgubWF4KE1hdGgubWF4KE1hdGgubWluKHQxLCB0MiksIE1hdGgubWluKHQzLCB0NCkpLCBNYXRoLm1pbih0NSwgdDYpKTtcclxuICAgIHZhciB0bWF4ID0gTWF0aC5taW4oTWF0aC5taW4oTWF0aC5tYXgodDEsIHQyKSwgTWF0aC5tYXgodDMsIHQ0KSksIE1hdGgubWF4KHQ1LCB0NikpO1xyXG5cclxuICAgIGlmIChvcHQgPT09IHVuZGVmaW5lZCB8fCBvcHQuZGlzdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRtYXggPiAwICYmIHRtaW4gPD0gdG1heDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodG1heCA8IDAgfHwgdG1pbiA+IHRtYXgpIHtcclxuICAgICAgICBvcHQuZGlzdCA9IEluZmluaXR5O1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBvcHQuZGlzdCA9IHRtaW47XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbkJveC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbihwb2ludCkge1xyXG4gICAgdmFyIHAgPSBwb2ludC5kYXRhID8gcG9pbnQuZGF0YSA6IHBvaW50O1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YVswXSA8PSBwWzBdICYmIHBbMF0gPD0gdGhpcy5kYXRhWzNdICYmXHJcbiAgICAgICAgICAgdGhpcy5kYXRhWzFdIDw9IHBbMV0gJiYgcFsxXSA8PSB0aGlzLmRhdGFbNF0gJiZcclxuICAgICAgICAgICB0aGlzLmRhdGFbMl0gPD0gcFsyXSAmJiBwWzJdIDw9IHRoaXMuZGF0YVs1XTtcclxufTtcclxuXHJcbkJveC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiAnWE1MM0QuQm94KCcgKyB0aGlzLmRhdGFbMF0gKyAnLCAnICsgdGhpcy5kYXRhWzFdICsgJywgJyArIHRoaXMuZGF0YVsyXSArICcsICcgKyB0aGlzLmRhdGFbM10gKyAnLCAnICtcclxuICAgICAgICB0aGlzLmRhdGFbNF0gKyAnLCAnICsgdGhpcy5kYXRhWzVdICsgJyknO1xyXG59O1xyXG5cclxuQm94LkVNUFRZX0JPWCA9IG5ldyBCb3goKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQm94O1xyXG4iLCJ2YXIgWEMgPSByZXF1aXJlKFwiLi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIFJlc291cmNlID0gcmVxdWlyZShcIi4uL3Jlc291cmNlXCIpO1xyXG5cclxudmFyIGNfWGZsb3dPYnNlcnZlckxpc3QgPSBbXTtcclxuXHJcbnZhciBYTUwzRERhdGFPYnNlcnZlciA9IGZ1bmN0aW9uKGNhbGxiYWNrKXtcclxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgIHRoaXMub2JzZXJ2ZWQgPSBbXTtcclxufTtcclxuXHJcblhNTDNERGF0YU9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24obm9kZSwgb3B0aW9ucyl7XHJcbiAgICBpZighbm9kZSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbm9kZSB0byBvYnNlcnZlIGlzIG51bGwuXCIpO1xyXG5cclxuXHJcbiAgICBpZighbm9kZS5fY29uZmlndXJlZClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3RlIHRvIG9ic2VydmUgaXMgbm90ICAgKHlldCkuIE1ha2Ugc3VyZSB0byBwYXNzIGFuIFhNTDNEIG5vZGUgYW5kIHRvIGV4ZWN1dGUgXCIgK1xyXG4gICAgICAgICAgICBcInRoaXMgZnVuY3Rpb24gYWZ0ZXIgWE1MM0QgaGFzIGJlZW4gY29uZmlndXJlZCBlLmcuIGluc2lkZSBhIERPTUNvbnRlbnRMb2FkZWQgbGlzdGVuZXIuXCIpO1xyXG5cclxuXHJcbiAgICB2YXIgZGF0YUFkYXB0ZXIgPSBSZXNvdXJjZS5nZXRBZGFwdGVyKG5vZGUsIFwiZGF0YVwiKTtcclxuICAgIGlmKCFkYXRhQWRhcHRlcilcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBvYnNlcnZlIG5vZGUuIFhNTDNEYXRhT2JzZXJ2ZXIgY2FuIG9ubHkgb2JzZXJ2ZSBkYXRhIGNvbnRhaW5lcnMgc3VjaCBhcyA8ZGF0YT4sIDxtZXNoPiBvciA8c2hhZGVyPlwiKTtcclxuXHJcbiAgICBpZih0aGlzLm9ic2VydmVkLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgIGNfWGZsb3dPYnNlcnZlckxpc3QucHVzaCh0aGlzKTtcclxuXHJcbiAgICB2YXIgZW50cnkgPSB7XHJcbiAgICAgICAgbm9kZTogbm9kZSxcclxuICAgICAgICBjaGFuZ2VkOiBmYWxzZSxcclxuICAgICAgICByZXF1ZXN0OiBudWxsXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBuYW1lcyA9IG9wdGlvbnMgJiYgb3B0aW9uc1snbmFtZXMnXTtcclxuICAgIHZhciB0eXBlT2ZOYW1lcyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuYW1lcykuc2xpY2UoOCwgLTEpO1xyXG4gICAgaWYgKHR5cGVPZk5hbWVzID09PSBcIlN0cmluZ1wiKSB7XHJcbiAgICAgICAgbmFtZXMgPSBbbmFtZXNdO1xyXG4gICAgfVxyXG5cclxuICAgIGVudHJ5LnJlcXVlc3QgPSBkYXRhQWRhcHRlci5nZXRDb21wdXRlUmVxdWVzdChuYW1lcywgZnVuY3Rpb24ocmVxdWVzdCwgY2hhbmdlVHlwZSl7XHJcbiAgICAgICAgZW50cnkuY2hhbmdlZCA9IHRydWU7XHJcbiAgICB9KTtcclxuICAgIC8vIEZldGNoIHJlc3VsdCB0byBzeW5jaHJvbml6ZSBYZmxvdyBzdHJ1Y3R1cmVzIGFuZCBjb25uZWN0IHRvIGNhbGxiYWNrc1xyXG4gICAgLy8gVE9ETzogRmluZCBhbiBvcHRpb24gdG8gY29ubmVjdCByZXF1ZXN0IHRvIGNhbGxiYWNrIHN0cnVjdHVyZSB3aXRob3V0IGNvbXB1dGluZyByZXN1bHRcclxuICAgIGVudHJ5LnJlcXVlc3QuZ2V0UmVzdWx0KCk7XHJcblxyXG4gICAgdGhpcy5vYnNlcnZlZC5wdXNoKGVudHJ5KTtcclxufTtcclxuXHJcblhNTDNERGF0YU9ic2VydmVyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLm9ic2VydmVkLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB0aGlzLm9ic2VydmVkW2ldLnJlcXVlc3QuY2xlYXIoKTtcclxuICAgIH1cclxuICAgIHRoaXMub2JzZXJ2ZWQgPSBbXTtcclxuICAgIHZhciBpID0gY19YZmxvd09ic2VydmVyTGlzdC5sZW5ndGg7XHJcbiAgICB3aGlsZShpLS0pe1xyXG4gICAgICAgIGlmKGNfWGZsb3dPYnNlcnZlckxpc3RbaV0gPT0gdGhpcylcclxuICAgICAgICAgICAgY19YZmxvd09ic2VydmVyTGlzdC5zcGxpY2UoaSwgMSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuWE1MM0QudXBkYXRlWGZsb3dPYnNlcnZlciA9IGZ1bmN0aW9uKCl7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgY19YZmxvd09ic2VydmVyTGlzdC5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdmFyIG9ic2VydmVyID0gY19YZmxvd09ic2VydmVyTGlzdFtpXTtcclxuICAgICAgICB2YXIgcmVjb3JkcyA9IFtdO1xyXG4gICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBvYnNlcnZlci5vYnNlcnZlZC5sZW5ndGg7ICsrail7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IG9ic2VydmVyLm9ic2VydmVkW2pdO1xyXG4gICAgICAgICAgICBpZihlbnRyeS5jaGFuZ2VkKXtcclxuICAgICAgICAgICAgICAgIGVudHJ5LmNoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBlbnRyeS5yZXF1ZXN0LmdldFJlc3VsdCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFSZXN1bHQgPSBuZXcgWE1MM0REYXRhUmVzdWx0KHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICByZWNvcmRzLnB1c2goIG5ldyBYTUwzRERhdGFSZWNvcmQoZW50cnkubm9kZSwgZGF0YVJlc3VsdCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHJlY29yZHMubGVuZ3RoID4gMCAmJiBvYnNlcnZlci5jYWxsYmFjayl7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLmNhbGxiYWNrKHJlY29yZHMsIG9ic2VydmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgWE1MM0REYXRhUmVjb3JkID0gZnVuY3Rpb24odGFyZ2V0LCByZXN1bHQpe1xyXG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcclxufTtcclxuXHJcblxyXG52YXIgWE1MM0REYXRhUmVzdWx0ID0gZnVuY3Rpb24ocmVzdWx0KXtcclxuICAgIHRoaXMuX2VudHJpZXMgPSB7fTtcclxuICAgIGNvbnN0cnVjdERhdGFSZXN1bHQodGhpcywgcmVzdWx0KTtcclxufTtcclxuXHJcblhNTDNERGF0YVJlc3VsdC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICBpZiAodGhpcy5fZW50cmllc1tuYW1lXSlcclxuICAgICAgICByZXR1cm4gdGhpcy5fZW50cmllc1tuYW1lXS52YWx1ZTtcclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuWE1MM0REYXRhUmVzdWx0LnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24obmFtZSkge1xyXG4gICAgaWYgKHRoaXMuX2VudHJpZXNbbmFtZV0pXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VudHJpZXNbbmFtZV0udHlwZTtcclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuWE1MM0REYXRhUmVzdWx0LnByb3RvdHlwZS5nZXROYW1lcyA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICBmb3IodmFyIG5hbWUgaW4gdGhpcy5fZW50cmllcyl7XHJcbiAgICAgICAgcmVzdWx0LnB1c2gobmFtZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuWE1MM0REYXRhUmVzdWx0LkZMT0FUICA9IDA7XHJcblhNTDNERGF0YVJlc3VsdC5GTE9BVDIgPSAxO1xyXG5YTUwzRERhdGFSZXN1bHQuRkxPQVQzID0gMjtcclxuWE1MM0REYXRhUmVzdWx0LkZMT0FUNCA9IDM7XHJcblhNTDNERGF0YVJlc3VsdC5GTE9BVDRYNCA9IDQ7XHJcblhNTDNERGF0YVJlc3VsdC5JTlQgPSAxMDtcclxuWE1MM0REYXRhUmVzdWx0LklOVDQgPSAxMTtcclxuWE1MM0REYXRhUmVzdWx0LkJPT0wgPSAyMDtcclxuWE1MM0REYXRhUmVzdWx0LlRFWFRVUkUgPSAzMDtcclxuWE1MM0REYXRhUmVzdWx0LkJZVEUgPSA0MDtcclxuWE1MM0REYXRhUmVzdWx0LlVCWVRFID0gNTA7XHJcblxyXG5cclxuZnVuY3Rpb24gY29uc3RydWN0RGF0YVJlc3VsdChkYXRhUmVzdWx0LCByZXN1bHQpe1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHJlc3VsdC5vdXRwdXROYW1lcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdmFyIG5hbWUgPSByZXN1bHQub3V0cHV0TmFtZXNbaV07XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gcmVzdWx0LmdldE91dHB1dERhdGEobmFtZSk7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gZW50cnkgJiYgZW50cnkuZ2V0VmFsdWUoKTtcclxuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIHR5cGUgPSBnZXRYTUwzRERhdGFUeXBlKGVudHJ5LnR5cGUpO1xyXG4gICAgICAgICAgICBkYXRhUmVzdWx0Ll9lbnRyaWVzW25hbWVdID0geyB0eXBlOiB0eXBlLCB2YWx1ZTogdmFsdWV9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0WE1MM0REYXRhVHlwZSh0eXBlKXtcclxuICAgIHN3aXRjaCh0eXBlKXtcclxuICAgICAgICBjYXNlIFhDLkRBVEFfVFlQRS5GTE9BVCA6IHJldHVybiBYTUwzRERhdGFSZXN1bHQuRkxPQVQ7XHJcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuRkxPQVQyIDogcmV0dXJuIFhNTDNERGF0YVJlc3VsdC5GTE9BVDI7XHJcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuRkxPQVQzIDogcmV0dXJuIFhNTDNERGF0YVJlc3VsdC5GTE9BVDM7XHJcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuRkxPQVQ0IDogcmV0dXJuIFhNTDNERGF0YVJlc3VsdC5GTE9BVDQ7XHJcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuRkxPQVQ0WDQgOiByZXR1cm4gWE1MM0REYXRhUmVzdWx0LkZMT0FUNFg0O1xyXG4gICAgICAgIGNhc2UgWEMuREFUQV9UWVBFLklOVCA6IHJldHVybiBYTUwzRERhdGFSZXN1bHQuSU5UO1xyXG4gICAgICAgIGNhc2UgWEMuREFUQV9UWVBFLklOVDQgOiByZXR1cm4gWE1MM0REYXRhUmVzdWx0LklOVDQ7XHJcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuQk9PTCA6IHJldHVybiBYTUwzRERhdGFSZXN1bHQuQk9PTDtcclxuICAgICAgICBjYXNlIFhDLkRBVEFfVFlQRS5URVhUVVJFIDogcmV0dXJuIFhNTDNERGF0YVJlc3VsdC5URVhUVVJFO1xyXG4gICAgICAgIGNhc2UgWEMuREFUQV9UWVBFLkJZVEUgOiByZXR1cm4gWE1MM0REYXRhUmVzdWx0LkJZVEU7XHJcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuVUJZVEUgOiByZXR1cm4gWE1MM0REYXRhUmVzdWx0LlVCWVRFO1xyXG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihcIldIQVQgSVMgVEhJUyBJIERPTidUIEVWRU4uLi5cIik7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBYTUwzRERhdGFDaGFubmVsSW5mbyA9IGZ1bmN0aW9uKHR5cGUsIG9yaWdpbiwgb3JpZ2luYWxOYW1lLCBzZXFMZW5ndGgsIHNlcU1pbktleSwgc2VxTWF4S2V5KXtcclxuICAgIHRoaXMudHlwZSA9IGdldFhNTDNERGF0YVR5cGUodHlwZSk7XHJcbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcclxuICAgIHRoaXMub3JpZ2luYWxOYW1lID0gb3JpZ2luYWxOYW1lO1xyXG4gICAgdGhpcy5zZXFMZW5ndGggPSBzZXFMZW5ndGg7XHJcbiAgICB0aGlzLnNlcU1pbktleSA9IHNlcU1pbktleTtcclxuICAgIHRoaXMuc2VxTWF4S2V5ID0gc2VxTWF4S2V5O1xyXG59O1xyXG5cclxuWE1MM0REYXRhQ2hhbm5lbEluZm8uT1JJR0lOX0NISUxEID0gMTtcclxuWE1MM0REYXRhQ2hhbm5lbEluZm8uT1JJR0lOX0NPTVBVVEUgPSAyO1xyXG5YTUwzRERhdGFDaGFubmVsSW5mby5PUklHSU5fUFJPVE8gPSAzO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBYTUwzRERhdGFDaGFubmVsSW5mbzogWE1MM0REYXRhQ2hhbm5lbEluZm8sXHJcbiAgICBYTUwzRERhdGFSZXN1bHQ6IFhNTDNERGF0YVJlc3VsdCxcclxuICAgIFhNTDNERGF0YU9ic2VydmVyOiBYTUwzRERhdGFPYnNlcnZlclxyXG59O1xyXG4iLCJ2YXIgbWF0MiA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikubWF0MjtcclxuXHJcbnZhciBNYXQyID0gZnVuY3Rpb24obWF0KSB7XHJcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIE1hdDIpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBtYXQyLmNyZWF0ZSgpO1xyXG4gICAgICAgIGlmIChtYXQpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLnNldChtYXQuZGF0YSA/IG1hdC5kYXRhIDogbWF0KTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgcmV0dXJuIG5ldyBNYXQyKG1hdCk7XHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0Mi5wcm90b3R5cGUsIFwibTExXCIsIHtcclxuICAgIHNldDogZnVuY3Rpb24oeCl7IHRoaXMuZGF0YVswXSA9IHg7IH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbMF07IH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXQyLnByb3RvdHlwZSwgXCJtMTJcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbih4KXsgdGhpcy5kYXRhWzFdID0geDsgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVsxXTsgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdDIucHJvdG90eXBlLCBcIm0yMVwiLCB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpeyB0aGlzLmRhdGFbMl0gPSB4OyB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzJdOyB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0Mi5wcm90b3R5cGUsIFwibTIyXCIsIHtcclxuICAgIHNldDogZnVuY3Rpb24oeCl7IHRoaXMuZGF0YVszXSA9IHg7IH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbM107IH1cclxufSk7XHJcblxyXG5NYXQyLnByb3RvdHlwZS5hZGpvaW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDIoKTtcclxuICAgIG1hdDIuYWRqb2ludChvdXQuZGF0YSwgdGhpcy5kYXRhKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5NYXQyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG4gICByZXR1cm4gbmV3IE1hdDIodGhpcyk7XHJcbn07XHJcblxyXG5NYXQyLnByb3RvdHlwZS5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIG1hdDIuZGV0ZXJtaW5hbnQodGhpcy5kYXRhKTtcclxufTtcclxuXHJcbk1hdDIucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBNYXQyKCk7XHJcbiAgICBtYXQyLmludmVydChvdXQuZGF0YSwgdGhpcy5kYXRhKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5NYXQyLnByb3RvdHlwZS5tdWwgPSBNYXQyLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uKGIpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgTWF0MigpO1xyXG4gICAgbWF0Mi5tdWx0aXBseShvdXQuZGF0YSwgdGhpcy5kYXRhLCBiLmRhdGEgPyBiLmRhdGEgOiBiKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5NYXQyLnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbihyYWQpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgTWF0MigpO1xyXG4gICAgbWF0Mi5yb3RhdGUob3V0LmRhdGEsIHRoaXMuZGF0YSwgcmFkKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5NYXQyLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uKHZlYykge1xyXG4gICAgdmFyIG91dCA9IG5ldyBNYXQyKCk7XHJcbiAgICBtYXQyLnNjYWxlKG91dC5kYXRhLCB0aGlzLmRhdGEsIHZlYy5kYXRhID8gdmVjLmRhdGEgOiB2ZWMpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbk1hdDIucHJvdG90eXBlLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBNYXQyKCk7XHJcbiAgICBtYXQyLnRyYW5zcG9zZShvdXQuZGF0YSwgdGhpcy5kYXRhKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5NYXQyLndyYXAgPSBmdW5jdGlvbihtYXQpIHtcclxuICAgIHZhciBtID0gTWF0MigpO1xyXG4gICAgbS5kYXRhID0gbWF0LmRhdGEgPyBtYXQuZGF0YSA6IG1hdDtcclxuICAgIHJldHVybiBtO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNYXQyO1xyXG4iLCJ2YXIgbWF0MyA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikubWF0MztcclxuXHJcbnZhciBNYXQzID0gZnVuY3Rpb24obWF0KSB7XHJcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIE1hdDMpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBtYXQzLmNyZWF0ZSgpO1xyXG4gICAgICAgIGlmIChtYXQpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLnNldChtYXQuZGF0YSA/IG1hdC5kYXRhIDogbWF0KTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgcmV0dXJuIG5ldyBNYXQzKG1hdCk7XHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0My5wcm90b3R5cGUsIFwibTExXCIsIHtcclxuICAgIHNldDogZnVuY3Rpb24oeCl7IHRoaXMuZGF0YVswXSA9IHg7IH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbMF07IH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXQzLnByb3RvdHlwZSwgXCJtMTJcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbih4KXsgdGhpcy5kYXRhWzFdID0geDsgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVsxXTsgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdDMucHJvdG90eXBlLCBcIm0xM1wiLCB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpeyB0aGlzLmRhdGFbMl0gPSB4OyB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzJdOyB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0My5wcm90b3R5cGUsIFwibTIxXCIsIHtcclxuICAgIHNldDogZnVuY3Rpb24oeCl7IHRoaXMuZGF0YVszXSA9IHg7IH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbM107IH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXQzLnByb3RvdHlwZSwgXCJtMjJcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbih4KXsgdGhpcy5kYXRhWzRdID0geDsgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVs0XTsgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdDMucHJvdG90eXBlLCBcIm0yM1wiLCB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpeyB0aGlzLmRhdGFbNV0gPSB4OyB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzVdOyB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0My5wcm90b3R5cGUsIFwibTMxXCIsIHtcclxuICAgIHNldDogZnVuY3Rpb24oeCl7IHRoaXMuZGF0YVs2XSA9IHg7IH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbNl07IH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXQzLnByb3RvdHlwZSwgXCJtMzJcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbih4KXsgdGhpcy5kYXRhWzddID0geDsgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVs3XTsgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdDMucHJvdG90eXBlLCBcIm0zM1wiLCB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpeyB0aGlzLmRhdGFbOF0gPSB4OyB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzhdOyB9XHJcbn0pO1xyXG5cclxuXHJcbk1hdDMucHJvdG90eXBlLmFkam9pbnQgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgTWF0MygpO1xyXG4gICAgbWF0My5hZGpvaW50KG91dC5kYXRhLCB0aGlzLmRhdGEpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbk1hdDMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcbiAgIHJldHVybiBuZXcgTWF0Myh0aGlzKTtcclxufTtcclxuXHJcbk1hdDMucHJvdG90eXBlLmRldGVybWluYW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gbWF0My5kZXRlcm1pbmFudCh0aGlzLmRhdGEpO1xyXG59O1xyXG5cclxuTWF0My5mcm9tTWF0NCA9IGZ1bmN0aW9uKG0pIHtcclxuICAgIHZhciBvdXQgPSBuZXcgTWF0MygpO1xyXG4gICAgbWF0My5mcm9tTWF0NChvdXQuZGF0YSwgbS5kYXRhID8gbS5kYXRhIDogbSk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuTWF0My5mcm9tUXVhdCA9IGZ1bmN0aW9uKHEpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgTWF0MygpO1xyXG4gICAgbWF0My5mcm9tUXVhdChvdXQuZGF0YSwgcS5kYXRhID8gcS5kYXRhIDogcSk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuTWF0My5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDMoKTtcclxuICAgIG1hdDMuaW52ZXJ0KG91dC5kYXRhLCB0aGlzLmRhdGEpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbk1hdDMucHJvdG90eXBlLm11bCA9IE1hdDMucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24oYikge1xyXG4gICAgdmFyIG91dCA9IG5ldyBNYXQzKCk7XHJcbiAgICBtYXQzLm11bHRpcGx5KG91dC5kYXRhLCB0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbk1hdDMubm9ybWFsRnJvbU1hdDQgPSBmdW5jdGlvbihtKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDMoKTtcclxuICAgIG1hdDMubm9ybWFsRnJvbU1hdDQob3V0LmRhdGEsIG0uZGF0YSA/IG0uZGF0YSA6IG0pO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbk1hdDMucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uKHJhZCkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBNYXQzKCk7XHJcbiAgICBtYXQzLnJvdGF0ZShvdXQuZGF0YSwgdGhpcy5kYXRhLCByYWQpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbk1hdDMucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24odmVjKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDMoKTtcclxuICAgIG1hdDMuc2NhbGUob3V0LmRhdGEsIHRoaXMuZGF0YSwgdmVjLmRhdGEgPyB2ZWMuZGF0YSA6IHZlYyk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuTWF0My5wcm90b3R5cGUudHJhbnNwb3NlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDMoKTtcclxuICAgIG1hdDMudHJhbnNwb3NlKG91dC5kYXRhLCB0aGlzLmRhdGEpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbk1hdDMucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKHZlYykge1xyXG4gICAgdmFyIG91dCA9IG5ldyBNYXQzKCk7XHJcbiAgICBtYXQzLnRyYW5zbGF0ZShvdXQuZGF0YSwgdGhpcy5kYXRhLCB2ZWMuZGF0YSA/IHZlYy5kYXRhIDogdmVjKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5NYXQzLndyYXAgPSBmdW5jdGlvbihtYXQpIHtcclxuICAgIHZhciBtID0gTWF0MygpO1xyXG4gICAgbS5kYXRhID0gbWF0LmRhdGEgPyBtYXQuZGF0YSA6IG1hdDtcclxuICAgIHJldHVybiBtO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNYXQzO1xyXG4iLCJ2YXIgbWF0NCA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikubWF0NDtcclxuXHJcbnZhciBNYXQ0ID0gZnVuY3Rpb24obWF0KSB7XHJcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIE1hdDQpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gICAgICAgIGlmIChtYXQpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLnNldChtYXQuZGF0YSA/IG1hdC5kYXRhIDogbWF0KTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgcmV0dXJuIG5ldyBNYXQ0KG1hdCk7XHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0NC5wcm90b3R5cGUsIFwibTExXCIsIHtcclxuICAgIHNldDogZnVuY3Rpb24oeCl7IHRoaXMuZGF0YVswXSA9IHg7IH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbMF07IH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXQ0LnByb3RvdHlwZSwgXCJtMTJcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbih4KXsgdGhpcy5kYXRhWzFdID0geDsgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVsxXTsgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdDQucHJvdG90eXBlLCBcIm0xM1wiLCB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpeyB0aGlzLmRhdGFbMl0gPSB4OyB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzJdOyB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0NC5wcm90b3R5cGUsIFwibTE0XCIsIHtcclxuICAgIHNldDogZnVuY3Rpb24oeCl7IHRoaXMuZGF0YVszXSA9IHg7IH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbM107IH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXQ0LnByb3RvdHlwZSwgXCJtMjFcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbih4KXsgdGhpcy5kYXRhWzRdID0geDsgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVs0XTsgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdDQucHJvdG90eXBlLCBcIm0yMlwiLCB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpeyB0aGlzLmRhdGFbNV0gPSB4OyB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzVdOyB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0NC5wcm90b3R5cGUsIFwibTIzXCIsIHtcclxuICAgIHNldDogZnVuY3Rpb24oeCl7IHRoaXMuZGF0YVs2XSA9IHg7IH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbNl07IH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXQ0LnByb3RvdHlwZSwgXCJtMjRcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbih4KXsgdGhpcy5kYXRhWzddID0geDsgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVs3XTsgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdDQucHJvdG90eXBlLCBcIm0zMVwiLCB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpeyB0aGlzLmRhdGFbOF0gPSB4OyB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzhdOyB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0NC5wcm90b3R5cGUsIFwibTMyXCIsIHtcclxuICAgIHNldDogZnVuY3Rpb24oeCl7IHRoaXMuZGF0YVs5XSA9IHg7IH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbOV07IH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXQ0LnByb3RvdHlwZSwgXCJtMzNcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbih4KXsgdGhpcy5kYXRhWzEwXSA9IHg7IH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbMTBdOyB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0NC5wcm90b3R5cGUsIFwibTM0XCIsIHtcclxuICAgIHNldDogZnVuY3Rpb24oeCl7IHRoaXMuZGF0YVsxMV0gPSB4OyB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzExXTsgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdDQucHJvdG90eXBlLCBcIm00MVwiLCB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpeyB0aGlzLmRhdGFbMTJdID0geDsgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVsxMl07IH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXQ0LnByb3RvdHlwZSwgXCJtNDJcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbih4KXsgdGhpcy5kYXRhWzEzXSA9IHg7IH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbMTNdOyB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0NC5wcm90b3R5cGUsIFwibTQzXCIsIHtcclxuICAgIHNldDogZnVuY3Rpb24oeCl7IHRoaXMuZGF0YVsxNF0gPSB4OyB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzE0XTsgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdDQucHJvdG90eXBlLCBcIm00NFwiLCB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpeyB0aGlzLmRhdGFbMTVdID0geDsgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVsxNV07IH1cclxufSk7XHJcblxyXG5NYXQ0LnByb3RvdHlwZS5hZGpvaW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDQoKTtcclxuICAgIG1hdDQuYWRqb2ludChvdXQuZGF0YSwgdGhpcy5kYXRhKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5NYXQ0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG4gICByZXR1cm4gbmV3IE1hdDQodGhpcyk7XHJcbn07XHJcblxyXG5NYXQ0LnByb3RvdHlwZS5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIG1hdDQuZGV0ZXJtaW5hbnQodGhpcy5kYXRhKTtcclxufTtcclxuXHJcbk1hdDQuZnJ1c3R1bSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDQoKTtcclxuICAgIG1hdDQuZnJ1c3R1bShvdXQuZGF0YSwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbk1hdDQucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBNYXQ0KCk7XHJcbiAgICBtYXQ0LmludmVydChvdXQuZGF0YSwgdGhpcy5kYXRhKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5NYXQ0Lmxvb2tBdCA9IGZ1bmN0aW9uKGV5ZSwgY2VudGVyLCB1cCkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBNYXQ0KCk7XHJcbiAgICBtYXQ0Lmxvb2tBdChvdXQuZGF0YSwgZXllLmRhdGEgPyBleWUuZGF0YSA6IGV5ZSwgY2VudGVyLmRhdGEgPyBjZW50ZXIuZGF0YSA6IGNlbnRlciwgdXAuZGF0YSA/IHVwLmRhdGEgOiB1cCk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuTWF0NC5wcm90b3R5cGUubXVsID0gTWF0NC5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbihiKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDQoKTtcclxuICAgIG1hdDQubXVsdGlwbHkob3V0LmRhdGEsIHRoaXMuZGF0YSwgYi5kYXRhID8gYi5kYXRhIDogYik7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuTWF0NC5vcnRobyA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDQoKTtcclxuICAgIG1hdDQub3J0aG8ob3V0LmRhdGEsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5NYXQ0LnBlcnNwZWN0aXZlID0gZnVuY3Rpb24oZm92LCBhc3BlY3QsIG5lYXIsIGZhcikge1xyXG4gICAgdmFyIG91dCA9IG5ldyBNYXQ0KCk7XHJcbiAgICBtYXQ0LnBlcnNwZWN0aXZlKG91dC5kYXRhLCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5NYXQ0LnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbihyYWQsIGF4aXMpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgTWF0NCgpO1xyXG4gICAgbWF0NC5yb3RhdGUob3V0LmRhdGEsIHRoaXMuZGF0YSwgcmFkLCBheGlzLmRhdGEgPyBheGlzLmRhdGEgOiBheGlzKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5NYXQ0LnByb3RvdHlwZS5yb3RhdGVYID0gZnVuY3Rpb24ocmFkKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDQoKTtcclxuICAgIG1hdDQucm90YXRlWChvdXQuZGF0YSwgdGhpcy5kYXRhLCByYWQpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbk1hdDQucHJvdG90eXBlLnJvdGF0ZVkgPSBmdW5jdGlvbihyYWQpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgTWF0NCgpO1xyXG4gICAgbWF0NC5yb3RhdGVZKG91dC5kYXRhLCB0aGlzLmRhdGEsIHJhZCk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuTWF0NC5wcm90b3R5cGUucm90YXRlWiA9IGZ1bmN0aW9uKHJhZCkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBNYXQ0KCk7XHJcbiAgICBtYXQ0LnJvdGF0ZVoob3V0LmRhdGEsIHRoaXMuZGF0YSwgcmFkKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5NYXQ0LnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uKHZlYykge1xyXG4gICAgdmFyIG91dCA9IG5ldyBNYXQ0KCk7XHJcbiAgICBtYXQ0LnNjYWxlKG91dC5kYXRhLCB0aGlzLmRhdGEsIHZlYy5kYXRhID8gdmVjLmRhdGEgOiB2ZWMpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbk1hdDQuZnJvbVF1YXQgPSBmdW5jdGlvbihxKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDQoKTtcclxuICAgIG1hdDQuZnJvbVF1YXQob3V0LmRhdGEsIHEuZGF0YSA/IHEuZGF0YSA6IHEpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbk1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24gPSBmdW5jdGlvbihxLCB2KSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDQoKTtcclxuICAgIG1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LmRhdGEsIHEuZGF0YSA/IHEuZGF0YSA6IHEsIHYuZGF0YSA/IHYuZGF0YSA6IHYpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbk1hdDQucHJvdG90eXBlLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBNYXQ0KCk7XHJcbiAgICBtYXQ0LnRyYW5zcG9zZShvdXQuZGF0YSwgdGhpcy5kYXRhKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5NYXQ0LnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbih2ZWMpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgTWF0NCgpO1xyXG4gICAgbWF0NC50cmFuc2xhdGUob3V0LmRhdGEsIHRoaXMuZGF0YSwgdmVjLmRhdGEgPyB2ZWMuZGF0YSA6IHZlYyk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuTWF0NC53cmFwID0gZnVuY3Rpb24obWF0KSB7XHJcbiAgICB2YXIgbSA9IE1hdDQoKTtcclxuICAgIG0uZGF0YSA9IG1hdC5kYXRhID8gbWF0LmRhdGEgOiBtYXQ7XHJcbiAgICByZXR1cm4gbTtcclxufTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1hdDQ7XHJcbiIsInZhciBxdWF0ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS5xdWF0O1xyXG5cclxudmFyIFF1YXQgPSBmdW5jdGlvbih2ZWMsIHksIHosIHcpIHtcclxuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgUXVhdCkge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IHF1YXQuY3JlYXRlKCk7XHJcbiAgICAgICAgaWYgKHcgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB2ZWM7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgICAgIHRoaXMueiA9IHo7XHJcbiAgICAgICAgICAgIHRoaXMudyA9IHc7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgaWYgKHZlYykge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEuc2V0KHZlYy5kYXRhID8gdmVjLmRhdGEgOiB2ZWMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudyA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHJldHVybiBuZXcgUXVhdCh2ZWMsIHksIHosIHcpO1xyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1YXQucHJvdG90eXBlLCBcInhcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbih4KXtcclxuICAgICAgICB0aGlzLmRhdGFbMF0gPSB4O1xyXG4gICAgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVswXTsgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1YXQucHJvdG90eXBlLCBcInlcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbih5KXtcclxuICAgICAgICB0aGlzLmRhdGFbMV0gPSB5O1xyXG4gICAgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVsxXTsgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1YXQucHJvdG90eXBlLCBcInpcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbih6KXtcclxuICAgICAgICB0aGlzLmRhdGFbMl0gPSB6O1xyXG4gICAgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVsyXTsgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1YXQucHJvdG90eXBlLCBcIndcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbih3KXtcclxuICAgICAgICB0aGlzLmRhdGFbM10gPSB3O1xyXG4gICAgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVszXTsgfVxyXG59KTtcclxuXHJcblF1YXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGIpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgUXVhdCgpO1xyXG4gICAgcXVhdC5hZGQob3V0LmRhdGEsIHRoaXMuZGF0YSwgYi5kYXRhID8gYi5kYXRhIDogYik7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuUXVhdC5wcm90b3R5cGUuY2FsY3VsYXRlVyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBRdWF0KCk7XHJcbiAgICBxdWF0LmNhbGN1bGF0ZVcob3V0LmRhdGEsIHRoaXMuZGF0YSk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuUXVhdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuICAgcmV0dXJuIG5ldyBRdWF0KHRoaXMpO1xyXG59O1xyXG5cclxuUXVhdC5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IFF1YXQoKTtcclxuICAgIHF1YXQuY29uanVnYXRlKG91dC5kYXRhLCB0aGlzLmRhdGEpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcblF1YXQucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uKGIpIHtcclxuICAgIHJldHVybiBxdWF0LmRvdCh0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIpO1xyXG59O1xyXG5cclxuUXVhdC5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IFF1YXQoKTtcclxuICAgIHF1YXQuaW52ZXJ0KG91dC5kYXRhLCB0aGlzLmRhdGEpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcblF1YXQucHJvdG90eXBlLmxlbiA9IFF1YXQucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHF1YXQubGVuZ3RoKHRoaXMuZGF0YSk7XHJcbn07XHJcblxyXG5RdWF0LnByb3RvdHlwZS5sZXJwID0gZnVuY3Rpb24oYiwgdCkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBRdWF0KCk7XHJcbiAgICBxdWF0LmxlcnAob3V0LmRhdGEsIHRoaXMuZGF0YSwgYi5kYXRhID8gYi5kYXRhIDogYiwgdCk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuUXVhdC5wcm90b3R5cGUubXVsID0gUXVhdC5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbihiKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IFF1YXQoKTtcclxuICAgIHF1YXQubXVsKG91dC5kYXRhLCB0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcblF1YXQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBRdWF0KCk7XHJcbiAgICBxdWF0Lm5vcm1hbGl6ZShvdXQuZGF0YSwgdGhpcy5kYXRhKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5RdWF0LnByb3RvdHlwZS5yb3RhdGVYID0gZnVuY3Rpb24ocmFkKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IFF1YXQoKTtcclxuICAgIHF1YXQucm90YXRlWChvdXQuZGF0YSwgdGhpcy5kYXRhLCByYWQpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcblF1YXQucHJvdG90eXBlLnJvdGF0ZVkgPSBmdW5jdGlvbihyYWQpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgUXVhdCgpO1xyXG4gICAgcXVhdC5yb3RhdGVZKG91dC5kYXRhLCB0aGlzLmRhdGEsIHJhZCk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuUXVhdC5wcm90b3R5cGUucm90YXRlWiA9IGZ1bmN0aW9uKHJhZCkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBRdWF0KCk7XHJcbiAgICBxdWF0LnJvdGF0ZVoob3V0LmRhdGEsIHRoaXMuZGF0YSwgcmFkKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5RdWF0LnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uKHMpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgUXVhdCgpO1xyXG4gICAgcXVhdC5zY2FsZShvdXQuZGF0YSwgdGhpcy5kYXRhLCBzKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5RdWF0LmZyb21BeGlzQW5nbGUgPSBmdW5jdGlvbihheGlzLCByYWQpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgUXVhdCgpO1xyXG4gICAgaWYgKHJhZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcXVhdC5zZXRBeGlzQW5nbGUob3V0LmRhdGEsIGF4aXMuZGF0YSA/IGF4aXMuZGF0YSA6IGF4aXMsIGF4aXMuZGF0YSA/IGF4aXMuZGF0YVszXSA6IGF4aXNbM10pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBxdWF0LnNldEF4aXNBbmdsZShvdXQuZGF0YSwgYXhpcy5kYXRhID8gYXhpcy5kYXRhIDogYXhpcywgcmFkKTtcclxuICAgIH1cclxuICAgIHF1YXQubm9ybWFsaXplKG91dC5kYXRhLCBvdXQuZGF0YSk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuUXVhdC5mcm9tQmFzaXMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IFF1YXQoKTtcclxuICAgIFhNTDNELm1hdGgucXVhdC5zZXRGcm9tQmFzaXMob3V0LmRhdGEsIHguZGF0YSA/IHguZGF0YSA6IHgsIHkuZGF0YSA/IHkuZGF0YSA6IHksIHouZGF0YSA/IHouZGF0YSA6IHopO1xyXG4gICAgcXVhdC5ub3JtYWxpemUob3V0LmRhdGEsIG91dC5kYXRhKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5RdWF0LmZyb21NYXQzID0gZnVuY3Rpb24obSkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBRdWF0KCk7XHJcbiAgICBxdWF0LmZyb21NYXQzKG91dC5kYXRhLCBtLmRhdGEgPyBtLmRhdGEgOiBtKTtcclxuICAgIHF1YXQubm9ybWFsaXplKG91dC5kYXRhLCBvdXQuZGF0YSk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuUXVhdC5mcm9tUm90YXRpb25UbyA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IFF1YXQoKTtcclxuICAgIHF1YXQucm90YXRpb25UbyhvdXQuZGF0YSwgZnJvbS5kYXRhID8gZnJvbS5kYXRhIDogZnJvbSwgdG8uZGF0YSA/IHRvLmRhdGEgOiB0byk7XHJcbiAgICBxdWF0Lm5vcm1hbGl6ZShvdXQuZGF0YSwgb3V0LmRhdGEpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcblF1YXQucHJvdG90eXBlLnNsZXJwID0gZnVuY3Rpb24oYiwgdCkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBRdWF0KCk7XHJcbiAgICBxdWF0LnNsZXJwKG91dC5kYXRhLCB0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIsIHQpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcblF1YXQucHJvdG90eXBlLnRvRE9NU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gcXVhdC50b0RPTVN0cmluZyh0aGlzLmRhdGEpO1xyXG59O1xyXG5cclxuUXVhdC5mcm9tRE9NU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IFF1YXQoKTtcclxuICAgIG91dC5kYXRhLnNldCggcXVhdC5mcm9tRE9NU3RyaW5nKHN0cikgKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5RdWF0LndyYXAgPSBmdW5jdGlvbih2ZWMpIHtcclxuICAgIHZhciB2ID0gUXVhdCgpO1xyXG4gICAgdi5kYXRhID0gdmVjLmRhdGEgPyB2ZWMuZGF0YSA6IHZlYztcclxuICAgIHJldHVybiB2O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBRdWF0O1xyXG4iLCJ2YXIgVmVjMyA9IHJlcXVpcmUoXCIuL3ZlYzMuanNcIik7XHJcbnZhciB2ZWMzID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS52ZWMzO1xyXG5cclxudmFyIFJheSA9IGZ1bmN0aW9uKHJheSkge1xyXG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBSYXkpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDYpO1xyXG4gICAgICAgIHRoaXMuZGF0YVs1XSA9IC0xO1xyXG4gICAgICAgIGlmIChyYXkpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLnNldCggcmF5LmRhdGEgPyByYXkuZGF0YSA6IHJheSApO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSYXkocmF5KTtcclxuICAgIH1cclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSYXkucHJvdG90eXBlLCBcIm9yaWdpblwiLCB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpe1xyXG4gICAgICAgIHZhciB2YWwgPSB2LmRhdGEgPyB2LmRhdGEgOiB2O1xyXG4gICAgICAgIHRoaXMuZGF0YVswXSA9IHZhbFswXTtcclxuICAgICAgICB0aGlzLmRhdGFbMV0gPSB2YWxbMV07XHJcbiAgICAgICAgdGhpcy5kYXRhWzJdID0gdmFsWzJdO1xyXG4gICAgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gVmVjMy53cmFwKHRoaXMuZGF0YS5zdWJhcnJheSgwLDMpKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmF5LnByb3RvdHlwZSwgXCJkaXJlY3Rpb25cIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbih2KXtcclxuICAgICAgICB2YXIgdmFsID0gdi5kYXRhID8gdi5kYXRhIDogdjtcclxuICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh2YWwsIHZhbCk7XHJcbiAgICAgICAgdGhpcy5kYXRhWzNdID0gdmFsWzBdO1xyXG4gICAgICAgIHRoaXMuZGF0YVs0XSA9IHZhbFsxXTtcclxuICAgICAgICB0aGlzLmRhdGFbNV0gPSB2YWxbMl07XHJcbiAgICB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiBWZWMzLndyYXAodGhpcy5kYXRhLnN1YmFycmF5KDMsNikpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcblJheS5wcm90b3R5cGUuc2V0RnJvbU9yaWdpbkRpcmVjdGlvbiA9IGZ1bmN0aW9uKG9yaWdpbiwgZGlyZWN0aW9uKSB7XHJcbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcclxuICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5SYXkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gbmV3IFJheSgpLmNvcHkodGhpcyk7XHJcbn07XHJcblxyXG5SYXkucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgdGhpcy5jb3B5T3JpZ2luKG90aGVyKTtcclxuICAgIHRoaXMuY29weURpcmVjdGlvbihvdGhlcik7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblJheS5wcm90b3R5cGUuY29weU9yaWdpbiA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICB2ZWMzLmNvcHkodGhpcy5kYXRhLCBvdGhlci5kYXRhID8gb3RoZXIuZGF0YSA6IG90aGVyKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuUmF5LnByb3RvdHlwZS5jb3B5RGlyZWN0aW9uID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgIHZlYzMuY29weSh0aGlzLmRhdGEuc3ViYXJyYXkoMyw2KSwgb3RoZXIuZGF0YSA/IG90aGVyLmRhdGEuc3ViYXJyYXkoMyw2KSA6IG90aGVyLnN1YmFycmF5KDMsNikpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5SYXkucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbihib3gsIG9wdCkge1xyXG4gICAgcmV0dXJuIGJveC5pbnRlcnNlY3RzKHRoaXMsIG9wdCk7XHJcbn07XHJcblxyXG5SYXkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gJ1hNTDNELlJheShvcmlnaW46ICcgKyB0aGlzLmRhdGFbMF0gKyAnLCAnICsgdGhpcy5kYXRhWzFdICsgJywgJyArIHRoaXMuZGF0YVsyXSArICcsIGRpcmVjdGlvbjogJyArIHRoaXMuZGF0YVszXSArICcsICcgK1xyXG4gICAgICAgIHRoaXMuZGF0YVs0XSArICcsICcgKyB0aGlzLmRhdGFbNV0gKyAnKSc7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJheTtcclxuIiwidmFyIHZlYzIgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLnZlYzI7XHJcblxyXG52YXIgVmVjMiA9IGZ1bmN0aW9uKHZlYywgeSkge1xyXG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBWZWMyKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gdmVjMi5jcmVhdGUoKTtcclxuICAgICAgICBpZiAoeSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHZlYztcclxuICAgICAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICBpZiAodmVjKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5zZXQodmVjLmRhdGEgPyB2ZWMuZGF0YSA6IHZlYyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHJldHVybiBuZXcgVmVjMih2ZWMsIHkpO1xyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlYzIucHJvdG90eXBlLCBcInhcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbih4KXtcclxuICAgICAgICB0aGlzLmRhdGFbMF0gPSB4O1xyXG4gICAgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVswXTsgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlYzIucHJvdG90eXBlLCBcInlcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbih5KXtcclxuICAgICAgICB0aGlzLmRhdGFbMV0gPSB5O1xyXG4gICAgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVsxXTsgfVxyXG59KTtcclxuXHJcblZlYzIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGIpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgVmVjMigpO1xyXG4gICAgdmVjMi5hZGQob3V0LmRhdGEsIHRoaXMuZGF0YSwgYi5kYXRhID8gYi5kYXRhIDogYik7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuVmVjMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBuZXcgVmVjMih0aGlzKTtcclxufTtcclxuXHJcblZlYzIucHJvdG90eXBlLmRpc3QgPSBWZWMyLnByb3RvdHlwZS5kaXN0YW5jZSA9IGZ1bmN0aW9uKGIpIHtcclxuICAgIHJldHVybiB2ZWMyLmRpc3QodGhpcy5kYXRhLCBiLmRhdGEgPyBiLmRhdGEgOiBiKTtcclxufTtcclxuXHJcblZlYzIucHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uKGIpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgVmVjMigpO1xyXG4gICAgdmVjMi5kaXZpZGUob3V0LmRhdGEsIHRoaXMuZGF0YSwgYi5kYXRhID8gYi5kYXRhIDogYik7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuVmVjMi5wcm90b3R5cGUuZG90ID0gZnVuY3Rpb24oYikge1xyXG4gICAgcmV0dXJuIHZlYzIuZG90KHRoaXMuZGF0YSwgYi5kYXRhID8gYi5kYXRhIDogYik7XHJcbn07XHJcblxyXG5WZWMyLnByb3RvdHlwZS5sZW4gPSBWZWMyLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB2ZWMyLmxlbmd0aCh0aGlzLmRhdGEpO1xyXG59O1xyXG5cclxuVmVjMi5wcm90b3R5cGUubGVycCA9IGZ1bmN0aW9uKGIsIHQpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgVmVjMigpO1xyXG4gICAgdmVjMi5sZXJwKG91dC5kYXRhLCB0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIsIHQpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcblZlYzIucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKGIpIHtcclxuICAgIHZhciBtID0gbmV3IFZlYzIoKTtcclxuICAgIHZlYzIubWF4KG0uZGF0YSwgdGhpcy5kYXRhLCBiLmRhdGEgPyBiLmRhdGEgOiBiKTtcclxuICAgIHJldHVybiBtO1xyXG59O1xyXG5cclxuVmVjMi5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oYikge1xyXG4gICAgdmFyIG0gPSBuZXcgVmVjMigpO1xyXG4gICAgdmVjMi5tYXgobS5kYXRhLCB0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIpO1xyXG4gICAgcmV0dXJuIG07XHJcbn07XHJcblxyXG5WZWMyLnByb3RvdHlwZS5tdWwgPSBWZWMyLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uKGIpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgVmVjMigpO1xyXG4gICAgdmFyIGMgPSBiLmRhdGEgPyBiLmRhdGEgOiBiO1xyXG5cclxuICAgIHN3aXRjaCAoYy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIHZlYzIubXVsKG91dC5kYXRhLCB0aGlzLmRhdGEsIGMpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgIHZlYzIudHJhbnNmb3JtTWF0MihvdXQuZGF0YSwgdGhpcy5kYXRhLCBjKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA5OlxyXG4gICAgICAgICAgICB2ZWMyLnRyYW5zZm9ybU1hdDMob3V0LmRhdGEsIHRoaXMuZGF0YSwgYyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTY6XHJcbiAgICAgICAgICAgIHZlYzIudHJhbnNmb3JtTWF0NChvdXQuZGF0YSwgdGhpcy5kYXRhLCBjKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgaW5wdXQgdG8gVmVjMi5tdWx0aXBseSBcIitiKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuVmVjMi5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IFZlYzIoKTtcclxuICAgIHZlYzIubmVnYXRlKG91dC5kYXRhLCB0aGlzLmRhdGEpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcblZlYzIucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBWZWMyKCk7XHJcbiAgICB2ZWMyLm5vcm1hbGl6ZShvdXQuZGF0YSwgdGhpcy5kYXRhKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5WZWMyLnJhbmRvbSA9IGZ1bmN0aW9uKHNjYWxlKSB7XHJcbiAgICB2YXIgbSA9IG5ldyBWZWMyKCk7XHJcbiAgICB2ZWMyLnJhbmRvbShtLmRhdGEsIHNjYWxlKTtcclxuICAgIHJldHVybiBtO1xyXG59O1xyXG5cclxuVmVjMi5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbihzKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IFZlYzIoKTtcclxuICAgIHZlYzIuc2NhbGUob3V0LmRhdGEsIHRoaXMuZGF0YSwgcyk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuVmVjMi5wcm90b3R5cGUuc3ViID0gVmVjMi5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbihiKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IFZlYzIoKTtcclxuICAgIHZlYzIuc3ViKG91dC5kYXRhLCB0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcblZlYzIucHJvdG90eXBlLnRvRE9NU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdmVjMi50b0RPTVN0cmluZyh0aGlzLmRhdGEpO1xyXG59O1xyXG5cclxuVmVjMi5mcm9tRE9NU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IFZlYzIoKTtcclxuICAgIG91dC5kYXRhLnNldCggdmVjMi5mcm9tRE9NU3RyaW5nKHN0cikgKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5WZWMyLndyYXAgPSBmdW5jdGlvbih2ZWMpIHtcclxuICAgIHZhciB2ID0gVmVjMigpO1xyXG4gICAgdi5kYXRhID0gdmVjLmRhdGEgPyB2ZWMuZGF0YSA6IHZlYztcclxuICAgIHJldHVybiB2O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBWZWMyO1xyXG4iLCJ2YXIgdmVjMyA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikudmVjMztcclxuXHJcbnZhciBWZWMzID0gZnVuY3Rpb24odmVjLCB5LCB6KSB7XHJcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFZlYzMpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSB2ZWMzLmNyZWF0ZSgpO1xyXG4gICAgICAgIGlmICh6ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gdmVjO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgICAgICB0aGlzLnogPSB6O1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgIGlmICh2ZWMpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhLnNldCh2ZWMuZGF0YSA/IHZlYy5kYXRhIDogdmVjKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgcmV0dXJuIG5ldyBWZWMzKHZlYywgeSwgeik7XHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmVjMy5wcm90b3R5cGUsIFwieFwiLCB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICAgIHRoaXMuZGF0YVswXSA9IHg7XHJcbiAgICB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzBdOyB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmVjMy5wcm90b3R5cGUsIFwieVwiLCB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHkpe1xyXG4gICAgICAgIHRoaXMuZGF0YVsxXSA9IHk7XHJcbiAgICB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzFdOyB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmVjMy5wcm90b3R5cGUsIFwielwiLCB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHope1xyXG4gICAgICAgIHRoaXMuZGF0YVsyXSA9IHo7XHJcbiAgICB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzJdOyB9XHJcbn0pO1xyXG5cclxuVmVjMy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oYikge1xyXG4gICAgdmFyIG91dCA9IG5ldyBWZWMzKCk7XHJcbiAgICB2ZWMzLmFkZChvdXQuZGF0YSwgdGhpcy5kYXRhLCBiLmRhdGEgPyBiLmRhdGEgOiBiKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5WZWMzLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG4gICByZXR1cm4gbmV3IFZlYzModGhpcyk7XHJcbn07XHJcblxyXG5WZWMzLnByb3RvdHlwZS5jcm9zcyA9IGZ1bmN0aW9uKGIpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgVmVjMygpO1xyXG4gICAgdmVjMy5jcm9zcyhvdXQuZGF0YSwgdGhpcy5kYXRhLCBiLmRhdGEgPyBiLmRhdGEgOiBiKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5WZWMzLnByb3RvdHlwZS5kaXN0ID0gVmVjMy5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbihiKSB7XHJcbiAgICByZXR1cm4gdmVjMy5kaXN0KHRoaXMuZGF0YSwgYi5kYXRhID8gYi5kYXRhIDogYik7XHJcbn07XHJcblxyXG5WZWMzLnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbihiKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IFZlYzMoKTtcclxuICAgIHZlYzMuZGl2aWRlKG91dC5kYXRhLCB0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcblZlYzMucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uKGIpIHtcclxuICAgIHJldHVybiB2ZWMzLmRvdCh0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIpO1xyXG59O1xyXG5cclxuVmVjMy5wcm90b3R5cGUubGVuID0gVmVjMy5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdmVjMy5sZW5ndGgodGhpcy5kYXRhKTtcclxufTtcclxuXHJcblZlYzMucHJvdG90eXBlLmxlcnAgPSBmdW5jdGlvbihiLCB0KSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IFZlYzMoKTtcclxuICAgIHZlYzMubGVycChvdXQuZGF0YSwgdGhpcy5kYXRhLCBiLmRhdGEgPyBiLmRhdGEgOiBiLCB0KTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5WZWMzLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbihiKSB7XHJcbiAgICB2YXIgbSA9IG5ldyBWZWMzKCk7XHJcbiAgICB2ZWMzLm1heChtLmRhdGEsIHRoaXMuZGF0YSwgYi5kYXRhID8gYi5kYXRhIDogYik7XHJcbiAgICByZXR1cm4gbTtcclxufTtcclxuXHJcblZlYzMucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKGIpIHtcclxuICAgIHZhciBtID0gbmV3IFZlYzMoKTtcclxuICAgIHZlYzMubWF4KG0uZGF0YSwgdGhpcy5kYXRhLCBiLmRhdGEgPyBiLmRhdGEgOiBiKTtcclxuICAgIHJldHVybiBtO1xyXG59O1xyXG5cclxuVmVjMy5wcm90b3R5cGUubXVsID0gVmVjMy5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbihiKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IFZlYzMoKTtcclxuICAgIHZhciBjID0gYi5kYXRhID8gYi5kYXRhIDogYjtcclxuXHJcbiAgICBzd2l0Y2ggKGMubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICB2ZWMzLm11bChvdXQuZGF0YSwgdGhpcy5kYXRhLCBjKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICB2ZWMzLnRyYW5zZm9ybVF1YXQob3V0LmRhdGEsIHRoaXMuZGF0YSwgYyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgOTpcclxuICAgICAgICAgICAgdmVjMy50cmFuc2Zvcm1NYXQzKG91dC5kYXRhLCB0aGlzLmRhdGEsIGMpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE2OlxyXG4gICAgICAgICAgICB2ZWMzLnRyYW5zZm9ybU1hdDQob3V0LmRhdGEsIHRoaXMuZGF0YSwgYyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIGlucHV0IHRvIFZlYzMubXVsdGlwbHkgXCIrYik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcblZlYzMucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBWZWMzKCk7XHJcbiAgICB2ZWMzLm5lZ2F0ZShvdXQuZGF0YSwgdGhpcy5kYXRhKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5WZWMzLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgVmVjMygpO1xyXG4gICAgdmVjMy5ub3JtYWxpemUob3V0LmRhdGEsIHRoaXMuZGF0YSk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuVmVjMy5wcm90b3R5cGUucmFuZG9tID0gZnVuY3Rpb24oc2NhbGUpIHtcclxuICAgIHZhciBtID0gbmV3IFZlYzMoKTtcclxuICAgIHZlYzMucmFuZG9tKG0uZGF0YSwgc2NhbGUpO1xyXG4gICAgcmV0dXJuIG07XHJcbn07XHJcblxyXG5WZWMzLnByb3RvdHlwZS5yZWNpcHJvY2FsID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IFZlYzMoKTtcclxuICAgIFhNTDNELm1hdGgudmVjMy5yZWNpcHJvY2FsKG91dC5kYXRhLCB0aGlzLmRhdGEpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcblZlYzMucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24ocykge1xyXG4gICAgdmFyIG91dCA9IG5ldyBWZWMzKCk7XHJcbiAgICB2ZWMzLnNjYWxlKG91dC5kYXRhLCB0aGlzLmRhdGEsIHMpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcblZlYzMucHJvdG90eXBlLnN1YiA9IFZlYzMucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24oYikge1xyXG4gICAgdmFyIG91dCA9IG5ldyBWZWMzKCk7XHJcbiAgICB2ZWMzLnN1YihvdXQuZGF0YSwgdGhpcy5kYXRhLCBiLmRhdGEgPyBiLmRhdGEgOiBiKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5WZWMzLnByb3RvdHlwZS50cmFuc2Zvcm1EaXJlY3Rpb24gPSBmdW5jdGlvbihtKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IFZlYzMoKTtcclxuICAgIFhNTDNELm1hdGgudmVjMy50cmFuc2Zvcm1EaXJlY3Rpb24ob3V0LmRhdGEsIHRoaXMuZGF0YSwgbS5kYXRhID8gbS5kYXRhIDogbSk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuVmVjMy5wcm90b3R5cGUudG9ET01TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB2ZWMzLnRvRE9NU3RyaW5nKHRoaXMuZGF0YSk7XHJcbn07XHJcblxyXG5WZWMzLmZyb21ET01TdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgVmVjMygpO1xyXG4gICAgb3V0LmRhdGEuc2V0KCB2ZWMzLmZyb21ET01TdHJpbmcoc3RyKSApO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcblZlYzMud3JhcCA9IGZ1bmN0aW9uKHZlYykge1xyXG4gICAgdmFyIHYgPSBWZWMzKCk7XHJcbiAgICB2LmRhdGEgPSB2ZWMuZGF0YSA/IHZlYy5kYXRhIDogdmVjO1xyXG4gICAgcmV0dXJuIHY7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFZlYzM7XHJcbiIsInZhciB2ZWM0ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS52ZWM0O1xyXG52YXIgVmVjMyA9IHJlcXVpcmUoXCIuL3ZlYzMuanNcIik7XHJcblxyXG52YXIgVmVjNCA9IGZ1bmN0aW9uKHZlYywgeSwgeiwgdykge1xyXG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBWZWM0KSB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gdmVjNC5jcmVhdGUoKTtcclxuICAgICAgICBpZiAodyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHZlYztcclxuICAgICAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICAgICAgdGhpcy56ID0gejtcclxuICAgICAgICAgICAgdGhpcy53ID0gdztcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICBpZiAodmVjKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5zZXQodmVjLmRhdGEgPyB2ZWMuZGF0YSA6IHZlYyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHJldHVybiBuZXcgVmVjNCh2ZWMsIHksIHosIHcpO1xyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlYzQucHJvdG90eXBlLCBcInhcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbih4KXtcclxuICAgICAgICB0aGlzLmRhdGFbMF0gPSB4O1xyXG4gICAgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVswXTsgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlYzQucHJvdG90eXBlLCBcInlcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbih5KXtcclxuICAgICAgICB0aGlzLmRhdGFbMV0gPSB5O1xyXG4gICAgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVsxXTsgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlYzQucHJvdG90eXBlLCBcInpcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbih6KXtcclxuICAgICAgICB0aGlzLmRhdGFbMl0gPSB6O1xyXG4gICAgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVsyXTsgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlYzQucHJvdG90eXBlLCBcIndcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbih3KXtcclxuICAgICAgICB0aGlzLmRhdGFbM10gPSB3O1xyXG4gICAgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVszXTsgfVxyXG59KTtcclxuXHJcblZlYzQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGIpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgVmVjNCgpO1xyXG4gICAgdmVjNC5hZGQob3V0LmRhdGEsIHRoaXMuZGF0YSwgYi5kYXRhID8gYi5kYXRhIDogYik7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuVmVjNC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuICAgcmV0dXJuIG5ldyBWZWM0KHRoaXMpO1xyXG59O1xyXG5cclxuVmVjNC5wcm90b3R5cGUuZGlzdCA9IFZlYzQucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24oYikge1xyXG4gICAgcmV0dXJuIHZlYzQuZGlzdCh0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIpO1xyXG59O1xyXG5cclxuVmVjNC5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24oYikge1xyXG4gICAgdmFyIG91dCA9IG5ldyBWZWM0KCk7XHJcbiAgICB2ZWM0LmRpdmlkZShvdXQuZGF0YSwgdGhpcy5kYXRhLCBiLmRhdGEgPyBiLmRhdGEgOiBiKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5WZWM0LnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbihiKSB7XHJcbiAgICByZXR1cm4gdmVjNC5kb3QodGhpcy5kYXRhLCBiLmRhdGEgPyBiLmRhdGEgOiBiKTtcclxufTtcclxuXHJcblZlYzQucHJvdG90eXBlLmxlbiA9IFZlYzQucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHZlYzQubGVuZ3RoKHRoaXMuZGF0YSk7XHJcbn07XHJcblxyXG5WZWM0LnByb3RvdHlwZS5sZXJwID0gZnVuY3Rpb24oYiwgdCkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBWZWM0KCk7XHJcbiAgICB2ZWM0LmxlcnAob3V0LmRhdGEsIHRoaXMuZGF0YSwgYi5kYXRhID8gYi5kYXRhIDogYiwgdCk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuVmVjNC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oYikge1xyXG4gICAgdmFyIG0gPSBuZXcgVmVjNCgpO1xyXG4gICAgdmVjNC5tYXgobS5kYXRhLCB0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIpO1xyXG4gICAgcmV0dXJuIG07XHJcbn07XHJcblxyXG5WZWM0LnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbihiKSB7XHJcbiAgICB2YXIgbSA9IG5ldyBWZWM0KCk7XHJcbiAgICB2ZWM0Lm1heChtLmRhdGEsIHRoaXMuZGF0YSwgYi5kYXRhID8gYi5kYXRhIDogYik7XHJcbiAgICByZXR1cm4gbTtcclxufTtcclxuXHJcblZlYzQucHJvdG90eXBlLm11bCA9IFZlYzQucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24oYikge1xyXG4gICAgdmFyIG91dCA9IG5ldyBWZWM0KCk7XHJcbiAgICB2YXIgYyA9IGIuZGF0YSA/IGIuZGF0YSA6IGI7XHJcblxyXG4gICAgc3dpdGNoIChjLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgdmVjNC5tdWwob3V0LmRhdGEsIHRoaXMuZGF0YSwgYyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTY6XHJcbiAgICAgICAgICAgIHZlYzQudHJhbnNmb3JtTWF0NChvdXQuZGF0YSwgdGhpcy5kYXRhLCBjKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgaW5wdXQgdG8gVmVjNC5tdWx0aXBseSBcIitiKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuVmVjNC5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IFZlYzQoKTtcclxuICAgIHZlYzQubmVnYXRlKG91dC5kYXRhLCB0aGlzLmRhdGEpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcblZlYzQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBWZWM0KCk7XHJcbiAgICB2ZWM0Lm5vcm1hbGl6ZShvdXQuZGF0YSwgdGhpcy5kYXRhKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5WZWM0LnByb3RvdHlwZS5yYW5kb20gPSBmdW5jdGlvbihzY2FsZSkge1xyXG4gICAgdmFyIG0gPSBuZXcgVmVjNCgpO1xyXG4gICAgdmVjNC5yYW5kb20obS5kYXRhLCBzY2FsZSk7XHJcbiAgICByZXR1cm4gbTtcclxufTtcclxuXHJcblZlYzQucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24ocykge1xyXG4gICAgdmFyIG91dCA9IG5ldyBWZWM0KCk7XHJcbiAgICB2ZWM0LnNjYWxlKG91dC5kYXRhLCB0aGlzLmRhdGEsIHMpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcblZlYzQucHJvdG90eXBlLnN1YiA9IFZlYzQucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24oYikge1xyXG4gICAgdmFyIG91dCA9IG5ldyBWZWM0KCk7XHJcbiAgICB2ZWM0LnN1YihvdXQuZGF0YSwgdGhpcy5kYXRhLCBiLmRhdGEgPyBiLmRhdGEgOiBiKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5WZWM0LnByb3RvdHlwZS50cmFuc2Zvcm1RdWF0ID0gZnVuY3Rpb24ocSkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBWZWM0KCk7XHJcbiAgICB2ZWM0LnRyYW5zZm9ybVF1YXQob3V0LmRhdGEsIHRoaXMuZGF0YSwgcS5kYXRhID8gcS5kYXRhIDogcSk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuVmVjNC5wcm90b3R5cGUudG9ET01TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB2ZWM0LnRvRE9NU3RyaW5nKHRoaXMuZGF0YSk7XHJcbn07XHJcblxyXG5WZWM0LmZyb21ET01TdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgVmVjNCgpO1xyXG4gICAgb3V0LmRhdGEuc2V0KCB2ZWM0LmZyb21ET01TdHJpbmcoc3RyKSApO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcblZlYzQud3JhcCA9IGZ1bmN0aW9uKHZlYykge1xyXG4gICAgdmFyIHYgPSBWZWM0KCk7XHJcbiAgICB2LmRhdGEgPSB2ZWMuZGF0YSA/IHZlYy5kYXRhIDogdmVjO1xyXG4gICAgcmV0dXJuIHY7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFZlYzQ7XHJcbiIsIi8vIEFkZCBjb252aWVuZW50IGFycmF5IG1ldGhvZHMgaWYgbm9uLWV4aXN0YW50XHJcbmlmICghQXJyYXkuZm9yRWFjaCkge1xyXG4gICAgQXJyYXkuZm9yRWFjaCA9IGZ1bmN0aW9uKGFycmF5LCBmdW4sIHRoaXNwKSB7XHJcbiAgICAgICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSBpbiBhcnJheSkge1xyXG4gICAgICAgICAgICAgICAgZnVuLmNhbGwodGhpc3AsIGFycmF5W2ldLCBpLCBhcnJheSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmlmICghQXJyYXkubWFwKSB7XHJcbiAgICBBcnJheS5tYXAgPSBmdW5jdGlvbihhcnJheSwgZnVuLCB0aGlzcCkge1xyXG4gICAgICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpIGluIGFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICByZXNbaV0gPSBmdW4uY2FsbCh0aGlzcCwgYXJyYXlbaV0sIGksIGFycmF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxufVxyXG5pZiAoIUFycmF5LmZpbHRlcikge1xyXG4gICAgQXJyYXkuZmlsdGVyID0gZnVuY3Rpb24oYXJyYXksIGZ1biwgdGhpc3ApIHtcclxuICAgICAgICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoO1xyXG4gICAgICAgIHZhciByZXMgPSBbXTtcclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSBpbiBhcnJheSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IGFycmF5W2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZ1bi5jYWxsKHRoaXNwLCB2YWwsIGksIGFycmF5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHZhbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbn1cclxuXHJcbmlmICghQXJyYXkuZXJhc2UpIHtcclxuICAgIEFycmF5LmVyYXNlID0gZnVuY3Rpb24oYXJyYXksIG9iamVjdCkge1xyXG4gICAgICAgIHZhciBlcmFzZWQgPSBmYWxzZTtcclxuICAgICAgICB2YXIgaWR4ID0gLTE7XHJcbiAgICAgICAgd2hpbGUoIChpZHggPSBhcnJheS5pbmRleE9mKG9iamVjdCkgKSAhPSAtMSl7XHJcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgICAgICBlcmFzZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXJhc2VkO1xyXG4gICAgfTtcclxufVxyXG5cclxuaWYgKCFBcnJheS5zZXQpIHtcclxuICAgIEFycmF5LnNldCA9IGZ1bmN0aW9uKGFycmF5LCBvZmZzZXQsIHZhbHVlKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGFycmF5W29mZnNldCtpXSA9IHZhbHVlW2ldO1xyXG4gICAgfTtcclxufVxyXG5cclxuaWYgKCFBcnJheS5pc0FycmF5KSB7XHJcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24oYXJnKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09ICdbb2JqZWN0IEFycmF5XSc7XHJcbiAgICB9O1xyXG59XHJcbiIsInZhciBDU1NNYXRyaXggPSByZXF1aXJlKFwiLi9jc3NNYXRyaXguanNcIik7XHJcblxyXG52YXIgY3NzID0ge307XHJcblxyXG5jc3MuVFJBTlNGT1JNX1BST1BFUlRZID0gbnVsbDtcclxuXHJcbmNzcy5pbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCd0cmFuc2Zvcm0nIGluIGRvY3VtZW50LmJvZHkuc3R5bGUpIHtcclxuICAgICAgICBjc3MuVFJBTlNGT1JNX1BST1BFUlRZID0gJ3RyYW5zZm9ybSdcclxuICAgIH0gZWxzZSBpZiAoJ1dlYmtpdFRyYW5zZm9ybScgaW4gZG9jdW1lbnQuYm9keS5zdHlsZSkge1xyXG4gICAgICAgIGNzcy5UUkFOU0ZPUk1fUFJPUEVSVFkgPSAnLXdlYmtpdC10cmFuc2Zvcm0nXHJcbiAgICB9IGVsc2UgaWYgKCdNb3pUcmFuc2Zvcm0nIGluIGRvY3VtZW50LmJvZHkuc3R5bGUpIHtcclxuICAgICAgICBjc3MuVFJBTlNGT1JNX1BST1BFUlRZID0gJy1tb3otdHJhbnNmb3JtJ1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiTm8gc3VwcG9ydGVkIHRyYW5zZm9ybSBjc3MgcHJvcGVydHkgZm91bmRcIik7XHJcbiAgICB9XHJcbn07XHJcblxyXG5jc3MuZ2V0SW5saW5lUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uIChub2RlLCBwcm9wZXJ0eSkge1xyXG4gICAgdmFyIHN0eWxlVmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcclxuICAgIGlmIChzdHlsZVZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHByb3BlcnR5ICsgXCJcXHMqOihbXjtdKylcIiwgXCJpXCIpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBwYXR0ZXJuLmV4ZWMoc3R5bGVWYWx1ZSk7XHJcbiAgICAgICAgaWYgKHJlc3VsdClcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFsxXS50cmltKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbmNzcy5nZXRQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24gKG5vZGUsIHByb3BlcnR5KSB7XHJcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldElubGluZVByb3BlcnR5VmFsdWUobm9kZSwgcHJvcGVydHkpO1xyXG4gICAgaWYgKHZhbHVlKVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcclxuICAgIHJldHVybiBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcclxufTtcclxuXHJcbmNzcy5nZXRDU1NNYXRyaXggPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgaWYgKCFjc3MuVFJBTlNGT1JNX1BST1BFUlRZIHx8ICFDU1NNYXRyaXgpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgdmFyIHN0eWxlID0gbnVsbDtcclxuXHJcbiAgICBpZiAoY3NzLlRSQU5TRk9STV9QUk9QRVJUWSAhPSBcInRyYW5zZm9ybVwiKVxyXG4gICAgICAgIHN0eWxlID0gY3NzLmdldElubGluZVByb3BlcnR5VmFsdWUobm9kZSwgXCJ0cmFuc2Zvcm1cIik7XHJcblxyXG4gICAgaWYgKCFzdHlsZSlcclxuICAgICAgICBzdHlsZSA9IGNzcy5nZXRQcm9wZXJ0eVZhbHVlKG5vZGUsIGNzcy5UUkFOU0ZPUk1fUFJPUEVSVFkpO1xyXG5cclxuICAgIGlmICghc3R5bGUgfHwgc3R5bGUgPT0gXCJub25lXCIpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJlc3VsdCA9IG5ldyBDU1NNYXRyaXgoc3R5bGUpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiRXJyb3IgcGFyc2luZyB0cmFuc2Zvcm0gcHJvcGVydHk6IFwiICsgc3R5bGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuXHJcbn07XHJcblxyXG5cclxuY3NzLmNvbnZlcnRDc3NUb01hdDQgPSBmdW5jdGlvbiAoY3NzTWF0cml4LCBtKSB7XHJcbiAgICB2YXIgbWF0cml4ID0gbSB8fCBuZXcgWE1MM0QuTWF0NCgpO1xyXG4gICAgbWF0cml4Lm0xMSA9IGNzc01hdHJpeC5tMTE7XHJcbiAgICBtYXRyaXgubTEyID0gY3NzTWF0cml4Lm0xMjtcclxuICAgIG1hdHJpeC5tMTMgPSBjc3NNYXRyaXgubTEzO1xyXG4gICAgbWF0cml4Lm0xNCA9IGNzc01hdHJpeC5tMTQ7XHJcbiAgICBtYXRyaXgubTIxID0gY3NzTWF0cml4Lm0yMTtcclxuICAgIG1hdHJpeC5tMjIgPSBjc3NNYXRyaXgubTIyO1xyXG4gICAgbWF0cml4Lm0yMyA9IGNzc01hdHJpeC5tMjM7XHJcbiAgICBtYXRyaXgubTI0ID0gY3NzTWF0cml4Lm0yNDtcclxuICAgIG1hdHJpeC5tMzEgPSBjc3NNYXRyaXgubTMxO1xyXG4gICAgbWF0cml4Lm0zMiA9IGNzc01hdHJpeC5tMzI7XHJcbiAgICBtYXRyaXgubTMzID0gY3NzTWF0cml4Lm0zMztcclxuICAgIG1hdHJpeC5tMzQgPSBjc3NNYXRyaXgubTM0O1xyXG4gICAgbWF0cml4Lm00MSA9IGNzc01hdHJpeC5tNDE7XHJcbiAgICBtYXRyaXgubTQyID0gY3NzTWF0cml4Lm00MjtcclxuICAgIG1hdHJpeC5tNDMgPSBjc3NNYXRyaXgubTQzO1xyXG4gICAgbWF0cml4Lm00NCA9IGNzc01hdHJpeC5tNDQ7XHJcbiAgICByZXR1cm4gbWF0cml4O1xyXG59O1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XHJcbiAgICBzdHlsZUVsZW1lbnQudGV4dENvbnRlbnQgPSBcInhtbDNkICogeyBkaXNwbGF5OiBpbmhlcml0OyB9XCIgK1xyXG4gICAgICAgIFwiZmxvYXQsZmxvYXQyLGZsb2F0MyxmbG9hdDQsZmxvYXQ0eDQsaW50LGludDQsYm9vbCx0ZXh0dXJlLHN0cmluZyxjb21wdXRlIHsgZGlzcGxheTogbm9uZTsgfSBcIiArXHJcbiAgICAgICAgXCJtZXNoLG1vZGVsLGdyb3VwIHsgcG9zaXRpb246IGFic29sdXRlOyB9XCI7XHJcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcbn0oKSk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjc3M7XHJcblxyXG4iLCJcclxuLyoqXHJcbiAqICBjbGFzcyBGaXJtaW5DU1NNYXRyaXhcclxuICpcclxuICogIFRoZSBbW0Zpcm1pbkNTU01hdHJpeF1dIGNsYXNzIGlzIGEgY29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlXHJcbiAqICBgQ1NTTWF0cml4YCBpbnRlcmZhY2UgZGVmaW5lZCBpbiB0aGUgW0NTUyAyRCBUcmFuc2Zvcm1zXVsyZF0gYW5kXHJcbiAqICBbQ1NTIDNEIFRyYW5zZm9ybXNdWzNkXSBNb2R1bGUgc3BlY2lmaWNhdGlvbnMuXHJcbiAqXHJcbiAqICBbMmRdOiBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLTJkLXRyYW5zZm9ybXMvXHJcbiAqICBbM2RdOiBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLTNkLXRyYW5zZm9ybXMvXHJcbiAqXHJcbiAqICBUaGUgaW1wbGVtZW50YXRpb24gd2FzIGxhcmdlbHkgY29waWVkIGZyb20gdGhlIGBXZWJLaXRDU1NNYXRyaXhgIGNsYXNzLCBhbmRcclxuICogIHRoZSBzdXBwYXJ0aW5nIG1hdGhzIGxpYnJhcmllcyBpbiB0aGUgW1dlYktpdF1bd2Via2l0XSBwcm9qZWN0LiBUaGlzIGlzIG9uZVxyXG4gKiAgcmVhc29uIHdoeSBtdWNoIG9mIHRoZSBjb2RlIGxvb2tzIG1vcmUgbGlrZSBDKysgdGhhbiBKYXZhU2NyaXB0LlxyXG4gKlxyXG4gKiAgW3dlYmtpdF06IGh0dHA6Ly93ZWJraXQub3JnL1xyXG4gKlxyXG4gKiAgSXRzIEFQSSBpcyBhIHN1cGVyc2V0IG9mIHRoYXQgcHJvdmlkZWQgYnkgYFdlYktpdENTU01hdHJpeGAsIGxhcmdlbHlcclxuICogIGJlY2F1c2UgdmFyaW91cyBwaWVjZXMgb2Ygc3VwcG9ydGluZyBjb2RlIGhhdmUgYmVlbiBhZGRlZCBhcyBpbnN0YW5jZVxyXG4gKiAgbWV0aG9kcyByYXRoZXIgdGhhbiBwb2xsdXRlIHRoZSBnbG9iYWwgbmFtZXNwYWNlLiBFeGFtcGxlcyBvZiB0aGVzZSBpbmNsdWRlXHJcbiAqICBbW0Zpcm1pbkNTU01hdHJpeCNpc0FmZmluZV1dLCBbW0Zpcm1pbkNTU01hdHJpeCNpc0lkZW50aXR5T3JUcmFuc2xhdGlvbl1dXHJcbiAqICBhbmQgW1tGaXJtaW5DU1NNYXRyaXgjYWRqb2ludF1dLlxyXG4gKiovXHJcblxyXG4vKipcclxuICogIG5ldyBGaXJtaW5DU1NNYXRyaXgoZG9tc3RyKVxyXG4gKiAgLSBkb21zdHIgKFN0cmluZyk6IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgMkQgb3IgM0QgdHJhbnNmb3JtIG1hdHJpeFxyXG4gKiAgICBpbiB0aGUgZm9ybSBnaXZlbiBieSB0aGUgQ1NTIHRyYW5zZm9ybSBwcm9wZXJ0eSwgaS5lLiBqdXN0IGxpa2UgdGhlXHJcbiAqICAgIG91dHB1dCBmcm9tIFtbRmlybWluQ1NTTWF0cml4I3RvU3RyaW5nXV0uXHJcbiAqXHJcbiAqICBAY29uc3RydWN0b3JcclxuICoqL1xyXG52YXIgRmlybWluQ1NTTWF0cml4ID0gZnVuY3Rpb24oZG9tc3RyKSB7XHJcbiAgICB0aGlzLm0xMSA9IHRoaXMubTIyID0gdGhpcy5tMzMgPSB0aGlzLm00NCA9IDE7XHJcblxyXG4gICAgdGhpcy5tMTIgPSB0aGlzLm0xMyA9IHRoaXMubTE0ID1cclxuICAgIHRoaXMubTIxID0gICAgICAgICAgICB0aGlzLm0yMyA9IHRoaXMubTI0ID1cclxuICAgIHRoaXMubTMxID0gdGhpcy5tMzIgPSAgICAgICAgICAgIHRoaXMubTM0ID1cclxuICAgIHRoaXMubTQxID0gdGhpcy5tNDIgPSB0aGlzLm00MyAgICAgICAgICAgID0gMDtcclxuXHJcbiAgICBpZiAodHlwZW9mIGRvbXN0ciA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgdGhpcy5zZXRNYXRyaXhWYWx1ZShkb21zdHIpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXguZGlzcGxheU5hbWUgPSBcIkZpcm1pbkNTU01hdHJpeFwiXHJcbiAqKi9cclxuRmlybWluQ1NTTWF0cml4LmRpc3BsYXlOYW1lID0gXCJGaXJtaW5DU1NNYXRyaXhcIjtcclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4LmRlZ3JlZXNUb1JhZGlhbnMoYW5nbGUpIC0+IE51bWJlclxyXG4gKiAgLSBhbmdsZSAoTnVtYmVyKTogYW4gYW5nbGUgaW4gZGVncmVlcy5cclxuICpcclxuICogIENvbnZlcnRzIGFuZ2xlcyBpbiBkZWdyZWVzLCB3aGljaCBhcmUgdXNlZCBieSB0aGUgZXh0ZXJuYWwgQVBJLCB0byBhbmdsZXNcclxuICogIGluIHJhZGlhbnMgdXNlZCBpbiBpbnRlcm5hbCBjYWxjdWxhdGlvbnMuXHJcbiAqKi9cclxuRmlybWluQ1NTTWF0cml4LmRlZ3JlZXNUb1JhZGlhbnMgPSBmdW5jdGlvbihhbmdsZSkge1xyXG4gICAgcmV0dXJuIGFuZ2xlICogTWF0aC5QSSAvIDE4MDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4LmRldGVybWluYW50MngyKGEsIGIsIGMsIGQpIC0+IE51bWJlclxyXG4gKiAgLSBhIChOdW1iZXIpOiB0b3AtbGVmdCB2YWx1ZSBvZiB0aGUgbWF0cml4LlxyXG4gKiAgLSBiIChOdW1iZXIpOiB0b3AtcmlnaHQgdmFsdWUgb2YgdGhlIG1hdHJpeC5cclxuICogIC0gYyAoTnVtYmVyKTogYm90dG9tLWxlZnQgdmFsdWUgb2YgdGhlIG1hdHJpeC5cclxuICogIC0gZCAoTnVtYmVyKTogYm90dG9tLXJpZ2h0IHZhbHVlIG9mIHRoZSBtYXRyaXguXHJcbiAqXHJcbiAqICBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIDJ4MiBtYXRyaXguXHJcbiAqKi9cclxuRmlybWluQ1NTTWF0cml4LmRldGVybWluYW50MngyID0gZnVuY3Rpb24oYSwgYiwgYywgZCkge1xyXG4gICAgcmV0dXJuIGEgKiBkIC0gYiAqIGM7XHJcbn07XHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeC5kZXRlcm1pbmFudDN4MyhtYXRyaXgpIC0+IE51bWJlclxyXG4gKiAgLSBhMSAoTnVtYmVyKTogbWF0cml4IHZhbHVlIGluIHBvc2l0aW9uIFsxLCAxXS5cclxuICogIC0gYTIgKE51bWJlcik6IG1hdHJpeCB2YWx1ZSBpbiBwb3NpdGlvbiBbMSwgMl0uXHJcbiAqICAtIGEzIChOdW1iZXIpOiBtYXRyaXggdmFsdWUgaW4gcG9zaXRpb24gWzEsIDNdLlxyXG4gKiAgLSBiMSAoTnVtYmVyKTogbWF0cml4IHZhbHVlIGluIHBvc2l0aW9uIFsyLCAxXS5cclxuICogIC0gYjIgKE51bWJlcik6IG1hdHJpeCB2YWx1ZSBpbiBwb3NpdGlvbiBbMiwgMl0uXHJcbiAqICAtIGIzIChOdW1iZXIpOiBtYXRyaXggdmFsdWUgaW4gcG9zaXRpb24gWzIsIDNdLlxyXG4gKiAgLSBjMSAoTnVtYmVyKTogbWF0cml4IHZhbHVlIGluIHBvc2l0aW9uIFszLCAxXS5cclxuICogIC0gYzIgKE51bWJlcik6IG1hdHJpeCB2YWx1ZSBpbiBwb3NpdGlvbiBbMywgMl0uXHJcbiAqICAtIGMzIChOdW1iZXIpOiBtYXRyaXggdmFsdWUgaW4gcG9zaXRpb24gWzMsIDNdLlxyXG4gKlxyXG4gKiAgQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSAzeDMgbWF0cml4LlxyXG4gKiovXHJcbkZpcm1pbkNTU01hdHJpeC5kZXRlcm1pbmFudDN4MyA9IGZ1bmN0aW9uKGExLCBhMiwgYTMsIGIxLCBiMiwgYjMsIGMxLCBjMiwgYzMpIHtcclxuICAgIHZhciBkZXRlcm1pbmFudDJ4MiA9IEZpcm1pbkNTU01hdHJpeC5kZXRlcm1pbmFudDJ4MjtcclxuICAgIHJldHVybiBhMSAqIGRldGVybWluYW50MngyKGIyLCBiMywgYzIsIGMzKSAtXHJcbiAgICBiMSAqIGRldGVybWluYW50MngyKGEyLCBhMywgYzIsIGMzKSArXHJcbiAgICBjMSAqIGRldGVybWluYW50MngyKGEyLCBhMywgYjIsIGIzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4LmRldGVybWluYW50NHg0KG1hdHJpeCkgLT4gTnVtYmVyXHJcbiAqICAtIG1hdHJpeCAoRmlybWluQ1NTTWF0cml4KTogdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgdGhlIGRldGVybWluYW50IG9mLlxyXG4gKlxyXG4gKiAgQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSA0eDQgbWF0cml4LlxyXG4gKiovXHJcbkZpcm1pbkNTU01hdHJpeC5kZXRlcm1pbmFudDR4NCA9IGZ1bmN0aW9uKG0pIHtcclxuICAgIHZhciBkZXRlcm1pbmFudDN4MyA9IEZpcm1pbkNTU01hdHJpeC5kZXRlcm1pbmFudDN4MyxcclxuXHJcbiAgICAgICAgLy8gQXNzaWduIHRvIGluZGl2aWR1YWwgdmFyaWFibGUgbmFtZXMgdG8gYWlkIHNlbGVjdGluZyBjb3JyZWN0IGVsZW1lbnRzXHJcbiAgICBhMSA9IG0ubTExLCBiMSA9IG0ubTIxLCBjMSA9IG0ubTMxLCBkMSA9IG0ubTQxLFxyXG4gICAgYTIgPSBtLm0xMiwgYjIgPSBtLm0yMiwgYzIgPSBtLm0zMiwgZDIgPSBtLm00MixcclxuICAgIGEzID0gbS5tMTMsIGIzID0gbS5tMjMsIGMzID0gbS5tMzMsIGQzID0gbS5tNDMsXHJcbiAgICBhNCA9IG0ubTE0LCBiNCA9IG0ubTI0LCBjNCA9IG0ubTM0LCBkNCA9IG0ubTQ0O1xyXG5cclxuICAgIHJldHVybiBhMSAqIGRldGVybWluYW50M3gzKGIyLCBiMywgYjQsIGMyLCBjMywgYzQsIGQyLCBkMywgZDQpIC1cclxuICAgIGIxICogZGV0ZXJtaW5hbnQzeDMoYTIsIGEzLCBhNCwgYzIsIGMzLCBjNCwgZDIsIGQzLCBkNCkgK1xyXG4gICAgYzEgKiBkZXRlcm1pbmFudDN4MyhhMiwgYTMsIGE0LCBiMiwgYjMsIGI0LCBkMiwgZDMsIGQ0KSAtXHJcbiAgICBkMSAqIGRldGVybWluYW50M3gzKGEyLCBhMywgYTQsIGIyLCBiMywgYjQsIGMyLCBjMywgYzQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZpcm1pbkNTU01hdHJpeC50b01hdHJpeFN0cmluZyh0cmFuc2Zvcm1WYWx1ZSkgLT4gU3RyaW5nXHJcbiAqIC0gdHJhbnNmb3JtVmFsdWUgKFN0cmluZyk6IGBlbC5zdHlsZS5XZWJraXRUcmFuc2Zvcm1gLXN0eWxlIHN0cmluZyAobGlrZSBgcm90YXRlKDE4cmFkKSB0cmFuc2xhdGUzZCg1MHB4LCAxMDBweCwgMTBweClgKVxyXG4gKlxyXG4gKiBUcmFuZm9ybXMgYSBgZWwuc3R5bGUuV2Via2l0VHJhbnNmb3JtYC1zdHlsZSBzdHJpbmdcclxuICogKGxpa2UgYHJvdGF0ZSgxOHJhZCkgdHJhbnNsYXRlM2QoNTBweCwgMTAwcHgsIDEwcHgpYClcclxuICogaW50byBhIGBnZXRDb21wdXRlZFN0eWxlKGVsKWAtc3R5bGUgbWF0cml4IHN0cmluZ1xyXG4gKiAobGlrZSBgbWF0cml4M2QoMC42NjAzMTY3MDgyNDQwODI4LCAtMC43NTA5ODcyNDY3NzE2NzM3LCAwLCAwLCAwLjc1MDk4NzI0Njc3MTY3MzcsIDAuNjYwMzE2NzA4MjQ0MDgyOCwgMCwgMCwgMCwgMCwgMSwgMCwgMTA4LjExNDU2MDA4OTM3MTUxLCAyOC40ODIzMDg0ODU4MjQ1OTYsIDEwLCAxKWApXHJcbiAqKi9cclxuRmlybWluQ1NTTWF0cml4LnRvTWF0cml4U3RyaW5nID0gZnVuY3Rpb24gKHRyYW5zZm9ybVZhbHVlKSB7XHJcbiAgICB2YXIgcmd4ID0ge1xyXG4gICAgICAgIGZ1bmN0aW9uU2lnbmF0dXJlOiAvKFxcdyspXFwoW15cXCldK1xcKS9pZyxcclxuICAgICAgICBuYW1lQW5kQXJndW1lbnRzOiAvKFxcdyspXFwoKFteXFwpXSspXFwpL2ksXHJcbiAgICAgICAgdW5pdHM6IC8oWy1cXCtdP1swLTldK1tcXC4wLTldKikoZGVnfHJhZHxncmFkfHB4fCUpKi9cclxuICAgIH07XHJcbiAgICB2YXIgdHJhbnNmb3JtU3RhdGVtZW50cyA9IHRyYW5zZm9ybVZhbHVlLm1hdGNoKC8oXFx3KylcXChbXlxcKV0rXFwpL2lnKTtcclxuICAgIHZhciBvbmx5TWF0cmljZXMgPSB0cmFuc2Zvcm1TdGF0ZW1lbnRzICYmIHRyYW5zZm9ybVN0YXRlbWVudHMuZXZlcnkoZnVuY3Rpb24gKHQpIHsgcmV0dXJuICgvXm1hdHJpeC8pLnRlc3QodCkgfSk7XHJcbiAgICBpZiAoIXRyYW5zZm9ybVN0YXRlbWVudHMgfHwgb25seU1hdHJpY2VzKSByZXR1cm4gdHJhbnNmb3JtVmFsdWU7XHJcblxyXG4gICAgdmFyIHZhbHVlcyA9IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvLnZhbHVlIH07XHJcbiAgICB2YXIgY3NzRnVuY3Rpb25Ub0pzRnVuY3Rpb24gPSB7XHJcbiAgICAgICAgbWF0cml4OiBmdW5jdGlvbiAobSwgbykge1xyXG4gICAgICAgICAgICB2YXIgbTIgPSBuZXcgRmlybWluQ1NTTWF0cml4KG8udW5wYXJzZWQpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG0ubXVsdGlwbHkobTIpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBtYXRyaXgzZDogZnVuY3Rpb24gKG0sIG8pIHtcclxuICAgICAgICAgICAgdmFyIG0yID0gbmV3IEZpcm1pbkNTU01hdHJpeChvLnVucGFyc2VkKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBtLm11bHRpcGx5KG0yKVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHBlcnNwZWN0aXZlOiBmdW5jdGlvbiAobSwgbykge1xyXG4gICAgICAgICAgICB2YXIgbTIgPSBuZXcgRmlybWluQ1NTTWF0cml4KCk7XHJcbiAgICAgICAgICAgIG0yLm0zNCAtPSAxIC8gby52YWx1ZVswXS52YWx1ZTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBtLm11bHRpcGx5KG0yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByb3RhdGU6IGZ1bmN0aW9uIChtLCBvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtLnJvdGF0ZS5hcHBseShtLCBvLnZhbHVlLm1hcCh2YWx1ZXMpKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcm90YXRlM2Q6IGZ1bmN0aW9uIChtLCBvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtLnJvdGF0ZUF4aXNBbmdsZS5hcHBseShtLCBvLnZhbHVlLm1hcCh2YWx1ZXMpKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcm90YXRlWDogZnVuY3Rpb24gKG0sIG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0ucm90YXRlLmFwcGx5KG0sIFtvLnZhbHVlWzBdLnZhbHVlLCAwLCAwXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByb3RhdGVZOiBmdW5jdGlvbiAobSwgbykge1xyXG4gICAgICAgICAgICByZXR1cm4gbS5yb3RhdGUuYXBwbHkobSwgWzAsIG8udmFsdWVbMF0udmFsdWUsIDBdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvdGF0ZVo6IGZ1bmN0aW9uIChtLCBvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtLnJvdGF0ZS5hcHBseShtLCBbMCwgMCwgby52YWx1ZVswXS52YWx1ZV0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNjYWxlOiBmdW5jdGlvbiAobSwgbykge1xyXG4gICAgICAgICAgICByZXR1cm4gbS5zY2FsZS5hcHBseShtLCBvLnZhbHVlLm1hcCh2YWx1ZXMpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNjYWxlM2Q6IGZ1bmN0aW9uIChtLCBvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtLnNjYWxlLmFwcGx5KG0sIG8udmFsdWUubWFwKHZhbHVlcykpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2NhbGVYOiBmdW5jdGlvbiAobSwgbykge1xyXG4gICAgICAgICAgICByZXR1cm4gbS5zY2FsZS5hcHBseShtLCBvLnZhbHVlLm1hcCh2YWx1ZXMpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNjYWxlWTogZnVuY3Rpb24gKG0sIG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0uc2NhbGUuYXBwbHkobSwgWzAsIG8udmFsdWVbMF0udmFsdWUsIDBdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNjYWxlWjogZnVuY3Rpb24gKG0sIG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0uc2NhbGUuYXBwbHkobSwgWzAsIDAsIG8udmFsdWVbMF0udmFsdWVdKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBza2V3OiBmdW5jdGlvbiAobSwgbykge1xyXG4gICAgICAgICAgICB2YXIgbVggPSBuZXcgRmlybWluQ1NTTWF0cml4KCdza2V3WCgnICsgby52YWx1ZVswXS51bnBhcnNlZCArICcpJyk7XHJcbiAgICAgICAgICAgIHZhciBtWSA9IG5ldyBGaXJtaW5DU1NNYXRyaXgoJ3NrZXdZKCcgKyBvLnZhbHVlWzFdLnVucGFyc2VkICsgJyknKTtcclxuICAgICAgICAgICAgdmFyIHNNID0gJ21hdHJpeCgxLjAwMDAwLCAnKyBtWS5iICsnLCAnKyBtWC5jICsnLCAxLjAwMDAwMCwgMC4wMDAwMDAsIDAuMDAwMDAwKSc7XHJcbiAgICAgICAgICAgIHZhciBtMiA9IG5ldyBGaXJtaW5DU1NNYXRyaXgoc00pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG0ubXVsdGlwbHkobTIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2tld1g6IGZ1bmN0aW9uIChtLCBvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtLnNrZXdYLmFwcGx5KG0sIFtvLnZhbHVlWzBdLnZhbHVlXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBza2V3WTogZnVuY3Rpb24gKG0sIG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0uc2tld1kuYXBwbHkobSwgW28udmFsdWVbMF0udmFsdWVdKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uIChtLCBvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtLnRyYW5zbGF0ZS5hcHBseShtLCBvLnZhbHVlLm1hcCh2YWx1ZXMpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRyYW5zbGF0ZTNkOiBmdW5jdGlvbiAobSwgbykge1xyXG4gICAgICAgICAgICByZXR1cm4gbS50cmFuc2xhdGUuYXBwbHkobSwgby52YWx1ZS5tYXAodmFsdWVzKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0cmFuc2xhdGVYOiBmdW5jdGlvbiAobSwgbykge1xyXG4gICAgICAgICAgICByZXR1cm4gbS50cmFuc2xhdGUuYXBwbHkobSwgW28udmFsdWVbMF0udmFsdWUsIDAsIDBdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRyYW5zbGF0ZVk6IGZ1bmN0aW9uIChtLCBvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtLnRyYW5zbGF0ZS5hcHBseShtLCBbMCwgby52YWx1ZVswXS52YWx1ZSwgMF0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHJhbnNsYXRlWjogZnVuY3Rpb24gKG0sIG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0udHJhbnNsYXRlLmFwcGx5KG0sIFswLCAwLCBvLnZhbHVlWzBdLnZhbHVlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBwYXJzZVRyYW5zZm9ybVN0YXRlbWVudCA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICB2YXIgcGFpciA9IHN0ci5tYXRjaChyZ3gubmFtZUFuZEFyZ3VtZW50cykuc2xpY2UoMSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGtleTogcGFpclswXSxcclxuICAgICAgICAgICAgdmFsdWU6IHBhaXJbMV0uc3BsaXQoLywgPy8pLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IHZhbHVlLm1hdGNoKC8oWy1cXCtdP1swLTldK1tcXC4wLTldKikoZGVnfHJhZHxncmFkfHB4fCUpKi8pIHx8IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQocGFydHNbMV0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHVuaXRzOiBwYXJ0c1syXSxcclxuICAgICAgICAgICAgICAgICAgICB1bnBhcnNlZDogdmFsdWVcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICB1bnBhcnNlZDogc3RyXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHRyYW5zZm9ybU9wZXJhdGlvbnMgPSB0cmFuc2Zvcm1TdGF0ZW1lbnRzLm1hcChwYXJzZVRyYW5zZm9ybVN0YXRlbWVudCk7XHJcbiAgICB2YXIgc3RhcnRpbmdNYXRyaXggPSBuZXcgRmlybWluQ1NTTWF0cml4KCk7XHJcbiAgICB2YXIgdHJhbnNmb3JtZWRNYXRyaXggPSB0cmFuc2Zvcm1PcGVyYXRpb25zLnJlZHVjZShmdW5jdGlvbiAobWF0cml4LCBvcGVyYXRpb24pIHtcclxuICAgICAgICAvLyBjb252ZXJ0IHRvIGRlZ3JlZXMgYi9jIGFsbCBDU1NNYXRyaXggbWV0aG9kcyBleHBlY3QgZGVncmVlc1xyXG4gICAgICAgIG9wZXJhdGlvbi52YWx1ZSA9IG9wZXJhdGlvbi52YWx1ZS5tYXAoZnVuY3Rpb24gKG9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLnVuaXRzID09ICdyYWQnKSB7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24udmFsdWUgPSBvcGVyYXRpb24udmFsdWUgKiAoMTgwIC8gTWF0aC5QSSk7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24udW5pdHMgPSAnZGVnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24udW5pdHMgPT0gJ2dyYWQnKSB7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24udmFsdWUgPSBvcGVyYXRpb24udmFsdWUgLyAoNDAwIC8gMzYwKTsgLy8gNDAwIGdyYWRpYW5zIGluIDM2MCBkZWdyZWVzXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24udW5pdHMgPSAnZGVnJ1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2YXIganNGdW5jdGlvbiA9IGNzc0Z1bmN0aW9uVG9Kc0Z1bmN0aW9uW29wZXJhdGlvbi5rZXldO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBqc0Z1bmN0aW9uKG1hdHJpeCwgb3BlcmF0aW9uKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBtYXRyaXg7XHJcbiAgICB9LCBzdGFydGluZ01hdHJpeCk7XHJcblxyXG4gICAgcmV0dXJuIHRyYW5zZm9ybWVkTWF0cml4LnRvU3RyaW5nKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCNhIC0+IE51bWJlclxyXG4gKiAgVGhlIGZpcnN0IDJEIHZlY3RvciB2YWx1ZS5cclxuICoqL1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjYiAtPiBOdW1iZXJcclxuICogIFRoZSBzZWNvbmQgMkQgdmVjdG9yIHZhbHVlLlxyXG4gKiovXHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCNjIC0+IE51bWJlclxyXG4gKiAgVGhlIHRoaXJkIDJEIHZlY3RvciB2YWx1ZS5cclxuICoqL1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjZCAtPiBOdW1iZXJcclxuICogIFRoZSBmb3VydGggMkQgdmVjdG9yIHZhbHVlLlxyXG4gKiovXHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCNlIC0+IE51bWJlclxyXG4gKiAgVGhlIGZpZnRoIDJEIHZlY3RvciB2YWx1ZS5cclxuICoqL1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjZiAtPiBOdW1iZXJcclxuICogIFRoZSBzaXh0aCAyRCB2ZWN0b3IgdmFsdWUuXHJcbiAqKi9cclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4I20xMSAtPiBOdW1iZXJcclxuICogIFRoZSAzRCBtYXRyaXggdmFsdWUgaW4gdGhlIGZpcnN0IHJvdyBhbmQgZmlyc3QgY29sdW1uLlxyXG4gKiovXHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCNtMTIgLT4gTnVtYmVyXHJcbiAqICBUaGUgM0QgbWF0cml4IHZhbHVlIGluIHRoZSBmaXJzdCByb3cgYW5kIHNlY29uZCBjb2x1bW4uXHJcbiAqKi9cclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4I20xMyAtPiBOdW1iZXJcclxuICogIFRoZSAzRCBtYXRyaXggdmFsdWUgaW4gdGhlIGZpcnN0IHJvdyBhbmQgdGhpcmQgY29sdW1uLlxyXG4gKiovXHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCNtMTQgLT4gTnVtYmVyXHJcbiAqICBUaGUgM0QgbWF0cml4IHZhbHVlIGluIHRoZSBmaXJzdCByb3cgYW5kIGZvdXJ0aCBjb2x1bW4uXHJcbiAqKi9cclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4I20yMSAtPiBOdW1iZXJcclxuICogIFRoZSAzRCBtYXRyaXggdmFsdWUgaW4gdGhlIHNlY29uZCByb3cgYW5kIGZpcnN0IGNvbHVtbi5cclxuICoqL1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjbTIyIC0+IE51bWJlclxyXG4gKiAgVGhlIDNEIG1hdHJpeCB2YWx1ZSBpbiB0aGUgc2Vjb25kIHJvdyBhbmQgc2Vjb25kIGNvbHVtbi5cclxuICoqL1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjbTIzIC0+IE51bWJlclxyXG4gKiAgVGhlIDNEIG1hdHJpeCB2YWx1ZSBpbiB0aGUgc2Vjb25kIHJvdyBhbmQgdGhpcmQgY29sdW1uLlxyXG4gKiovXHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCNtMjQgLT4gTnVtYmVyXHJcbiAqICBUaGUgM0QgbWF0cml4IHZhbHVlIGluIHRoZSBzZWNvbmQgcm93IGFuZCBmb3VydGggY29sdW1uLlxyXG4gKiovXHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCNtMzEgLT4gTnVtYmVyXHJcbiAqICBUaGUgM0QgbWF0cml4IHZhbHVlIGluIHRoZSB0aGlyZCByb3cgYW5kIGZpcnN0IGNvbHVtbi5cclxuICoqL1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjbTMyIC0+IE51bWJlclxyXG4gKiAgVGhlIDNEIG1hdHJpeCB2YWx1ZSBpbiB0aGUgdGhpcmQgcm93IGFuZCBzZWNvbmQgY29sdW1uLlxyXG4gKiovXHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCNtMzMgLT4gTnVtYmVyXHJcbiAqICBUaGUgM0QgbWF0cml4IHZhbHVlIGluIHRoZSB0aGlyZCByb3cgYW5kIHRoaXJkIGNvbHVtbi5cclxuICoqL1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjbTM0IC0+IE51bWJlclxyXG4gKiAgVGhlIDNEIG1hdHJpeCB2YWx1ZSBpbiB0aGUgdGhpcmQgcm93IGFuZCBmb3VydGggY29sdW1uLlxyXG4gKiovXHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCNtNDEgLT4gTnVtYmVyXHJcbiAqICBUaGUgM0QgbWF0cml4IHZhbHVlIGluIHRoZSBmb3VydGggcm93IGFuZCBmaXJzdCBjb2x1bW4uXHJcbiAqKi9cclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4I200MiAtPiBOdW1iZXJcclxuICogIFRoZSAzRCBtYXRyaXggdmFsdWUgaW4gdGhlIGZvdXJ0aCByb3cgYW5kIHNlY29uZCBjb2x1bW4uXHJcbiAqKi9cclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4I200MyAtPiBOdW1iZXJcclxuICogIFRoZSAzRCBtYXRyaXggdmFsdWUgaW4gdGhlIGZvdXJ0aCByb3cgYW5kIHRoaXJkIGNvbHVtbi5cclxuICoqL1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjbTQ0IC0+IE51bWJlclxyXG4gKiAgVGhlIDNEIG1hdHJpeCB2YWx1ZSBpbiB0aGUgZm91cnRoIHJvdyBhbmQgZm91cnRoIGNvbHVtbi5cclxuICoqL1xyXG5cclxuW1tcIm0xMVwiLCBcImFcIl0sXHJcbiAgICBbXCJtMTJcIiwgXCJiXCJdLFxyXG4gICAgW1wibTIxXCIsIFwiY1wiXSxcclxuICAgIFtcIm0yMlwiLCBcImRcIl0sXHJcbiAgICBbXCJtNDFcIiwgXCJlXCJdLFxyXG4gICAgW1wibTQyXCIsIFwiZlwiXV0uZm9yRWFjaChmdW5jdGlvbihwYWlyKSB7XHJcbiAgICB2YXIga2V5M2QgPSBwYWlyWzBdLCBrZXkyZCA9IHBhaXJbMV07XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZpcm1pbkNTU01hdHJpeC5wcm90b3R5cGUsIGtleTJkLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcclxuICAgICAgICAgICAgdGhpc1trZXkzZF0gPSB2YWw7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNba2V5M2RdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZSA6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlIDogdHJ1ZVxyXG4gICAgfSk7XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjaXNBZmZpbmUoKSAtPiBCb29sZWFuXHJcbiAqXHJcbiAqICBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG1hdHJpeCBpcyBhZmZpbmUuXHJcbiAqKi9cclxuRmlybWluQ1NTTWF0cml4LnByb3RvdHlwZS5pc0FmZmluZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubTEzID09PSAwICYmIHRoaXMubTE0ID09PSAwICYmXHJcbiAgICB0aGlzLm0yMyA9PT0gMCAmJiB0aGlzLm0yNCA9PT0gMCAmJlxyXG4gICAgdGhpcy5tMzEgPT09IDAgJiYgdGhpcy5tMzIgPT09IDAgJiZcclxuICAgIHRoaXMubTMzID09PSAxICYmIHRoaXMubTM0ID09PSAwICYmXHJcbiAgICB0aGlzLm00MyA9PT0gMCAmJiB0aGlzLm00NCA9PT0gMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4I211bHRpcGx5KG90aGVyTWF0cml4KSAtPiBGaXJtaW5DU1NNYXRyaXhcclxuICogIC0gb3RoZXJNYXRyaXggKEZpcm1pbkNTU01hdHJpeCk6IHRoZSBtYXRyaXggdG8gbXVsdGlwbHkgdGhpcyBvbmUgYnkuXHJcbiAqXHJcbiAqICBNdWx0aXBsaWVzIHRoZSBtYXRyaXggYnkgYSBnaXZlbiBtYXRyaXggYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cclxuICoqL1xyXG5GaXJtaW5DU1NNYXRyaXgucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24ob3RoZXJNYXRyaXgpIHtcclxuICAgIGlmICghb3RoZXJNYXRyaXgpIHJldHVybiBudWxsO1xyXG5cclxuICAgIHZhciBhID0gb3RoZXJNYXRyaXgsXHJcbiAgICBiID0gdGhpcyxcclxuICAgIGMgPSBuZXcgRmlybWluQ1NTTWF0cml4KCk7XHJcblxyXG4gICAgYy5tMTEgPSBhLm0xMSAqIGIubTExICsgYS5tMTIgKiBiLm0yMSArIGEubTEzICogYi5tMzEgKyBhLm0xNCAqIGIubTQxO1xyXG4gICAgYy5tMTIgPSBhLm0xMSAqIGIubTEyICsgYS5tMTIgKiBiLm0yMiArIGEubTEzICogYi5tMzIgKyBhLm0xNCAqIGIubTQyO1xyXG4gICAgYy5tMTMgPSBhLm0xMSAqIGIubTEzICsgYS5tMTIgKiBiLm0yMyArIGEubTEzICogYi5tMzMgKyBhLm0xNCAqIGIubTQzO1xyXG4gICAgYy5tMTQgPSBhLm0xMSAqIGIubTE0ICsgYS5tMTIgKiBiLm0yNCArIGEubTEzICogYi5tMzQgKyBhLm0xNCAqIGIubTQ0O1xyXG5cclxuICAgIGMubTIxID0gYS5tMjEgKiBiLm0xMSArIGEubTIyICogYi5tMjEgKyBhLm0yMyAqIGIubTMxICsgYS5tMjQgKiBiLm00MTtcclxuICAgIGMubTIyID0gYS5tMjEgKiBiLm0xMiArIGEubTIyICogYi5tMjIgKyBhLm0yMyAqIGIubTMyICsgYS5tMjQgKiBiLm00MjtcclxuICAgIGMubTIzID0gYS5tMjEgKiBiLm0xMyArIGEubTIyICogYi5tMjMgKyBhLm0yMyAqIGIubTMzICsgYS5tMjQgKiBiLm00MztcclxuICAgIGMubTI0ID0gYS5tMjEgKiBiLm0xNCArIGEubTIyICogYi5tMjQgKyBhLm0yMyAqIGIubTM0ICsgYS5tMjQgKiBiLm00NDtcclxuXHJcbiAgICBjLm0zMSA9IGEubTMxICogYi5tMTEgKyBhLm0zMiAqIGIubTIxICsgYS5tMzMgKiBiLm0zMSArIGEubTM0ICogYi5tNDE7XHJcbiAgICBjLm0zMiA9IGEubTMxICogYi5tMTIgKyBhLm0zMiAqIGIubTIyICsgYS5tMzMgKiBiLm0zMiArIGEubTM0ICogYi5tNDI7XHJcbiAgICBjLm0zMyA9IGEubTMxICogYi5tMTMgKyBhLm0zMiAqIGIubTIzICsgYS5tMzMgKiBiLm0zMyArIGEubTM0ICogYi5tNDM7XHJcbiAgICBjLm0zNCA9IGEubTMxICogYi5tMTQgKyBhLm0zMiAqIGIubTI0ICsgYS5tMzMgKiBiLm0zNCArIGEubTM0ICogYi5tNDQ7XHJcblxyXG4gICAgYy5tNDEgPSBhLm00MSAqIGIubTExICsgYS5tNDIgKiBiLm0yMSArIGEubTQzICogYi5tMzEgKyBhLm00NCAqIGIubTQxO1xyXG4gICAgYy5tNDIgPSBhLm00MSAqIGIubTEyICsgYS5tNDIgKiBiLm0yMiArIGEubTQzICogYi5tMzIgKyBhLm00NCAqIGIubTQyO1xyXG4gICAgYy5tNDMgPSBhLm00MSAqIGIubTEzICsgYS5tNDIgKiBiLm0yMyArIGEubTQzICogYi5tMzMgKyBhLm00NCAqIGIubTQzO1xyXG4gICAgYy5tNDQgPSBhLm00MSAqIGIubTE0ICsgYS5tNDIgKiBiLm0yNCArIGEubTQzICogYi5tMzQgKyBhLm00NCAqIGIubTQ0O1xyXG5cclxuICAgIHJldHVybiBjO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjaXNJZGVudGl0eU9yVHJhbnNsYXRpb24oKSAtPiBCb29sZWFuXHJcbiAqXHJcbiAqICBSZXR1cm5zIHdoZXRoZXIgdGhlIG1hdHJpeCBpcyB0aGUgaWRlbnRpdHkgbWF0cml4IG9yIGEgdHJhbnNsYXRpb24gbWF0cml4LlxyXG4gKiovXHJcbkZpcm1pbkNTU01hdHJpeC5wcm90b3R5cGUuaXNJZGVudGl0eU9yVHJhbnNsYXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciB0ID0gdGhpcztcclxuICAgIHJldHVybiB0Lm0xMSA9PT0gMSAmJiB0Lm0xMiA9PT0gMCAmJiB0Lm0xMyA9PT0gMCAmJiB0Lm0xNCA9PT0gMCAmJlxyXG4gICAgdC5tMjEgPT09IDAgJiYgdC5tMjIgPT09IDEgJiYgdC5tMjMgPT09IDAgJiYgdC5tMjQgPT09IDAgJiZcclxuICAgIHQubTMxID09PSAwICYmIHQubTMxID09PSAwICYmIHQubTMzID09PSAxICYmIHQubTM0ID09PSAwICYmXHJcbiAgICAgICAgLyogbTQxLCBtNDIgYW5kIG00MyBhcmUgdGhlIHRyYW5zbGF0aW9uIHBvaW50cyAqLyAgIHQubTQ0ID09PSAxO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjYWRqb2ludCgpIC0+IEZpcm1pbkNTU01hdHJpeFxyXG4gKlxyXG4gKiAgUmV0dXJucyB0aGUgYWRqb2ludCBtYXRyaXguXHJcbiAqKi9cclxuRmlybWluQ1NTTWF0cml4LnByb3RvdHlwZS5hZGpvaW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEZpcm1pbkNTU01hdHJpeCgpLCB0ID0gdGhpcyxcclxuICAgIGRldGVybWluYW50M3gzID0gRmlybWluQ1NTTWF0cml4LmRldGVybWluYW50M3gzLFxyXG5cclxuICAgIGExID0gdC5tMTEsIGIxID0gdC5tMTIsIGMxID0gdC5tMTMsIGQxID0gdC5tMTQsXHJcbiAgICBhMiA9IHQubTIxLCBiMiA9IHQubTIyLCBjMiA9IHQubTIzLCBkMiA9IHQubTI0LFxyXG4gICAgYTMgPSB0Lm0zMSwgYjMgPSB0Lm0zMiwgYzMgPSB0Lm0zMywgZDMgPSB0Lm0zNCxcclxuICAgIGE0ID0gdC5tNDEsIGI0ID0gdC5tNDIsIGM0ID0gdC5tNDMsIGQ0ID0gdC5tNDQ7XHJcblxyXG4gICAgLy8gUm93IGNvbHVtbiBsYWJlbGluZyByZXZlcnNlZCBzaW5jZSB3ZSB0cmFuc3Bvc2Ugcm93cyAmIGNvbHVtbnNcclxuICAgIHJlc3VsdC5tMTEgPSAgZGV0ZXJtaW5hbnQzeDMoYjIsIGIzLCBiNCwgYzIsIGMzLCBjNCwgZDIsIGQzLCBkNCk7XHJcbiAgICByZXN1bHQubTIxID0gLWRldGVybWluYW50M3gzKGEyLCBhMywgYTQsIGMyLCBjMywgYzQsIGQyLCBkMywgZDQpO1xyXG4gICAgcmVzdWx0Lm0zMSA9ICBkZXRlcm1pbmFudDN4MyhhMiwgYTMsIGE0LCBiMiwgYjMsIGI0LCBkMiwgZDMsIGQ0KTtcclxuICAgIHJlc3VsdC5tNDEgPSAtZGV0ZXJtaW5hbnQzeDMoYTIsIGEzLCBhNCwgYjIsIGIzLCBiNCwgYzIsIGMzLCBjNCk7XHJcblxyXG4gICAgcmVzdWx0Lm0xMiA9IC1kZXRlcm1pbmFudDN4MyhiMSwgYjMsIGI0LCBjMSwgYzMsIGM0LCBkMSwgZDMsIGQ0KTtcclxuICAgIHJlc3VsdC5tMjIgPSAgZGV0ZXJtaW5hbnQzeDMoYTEsIGEzLCBhNCwgYzEsIGMzLCBjNCwgZDEsIGQzLCBkNCk7XHJcbiAgICByZXN1bHQubTMyID0gLWRldGVybWluYW50M3gzKGExLCBhMywgYTQsIGIxLCBiMywgYjQsIGQxLCBkMywgZDQpO1xyXG4gICAgcmVzdWx0Lm00MiA9ICBkZXRlcm1pbmFudDN4MyhhMSwgYTMsIGE0LCBiMSwgYjMsIGI0LCBjMSwgYzMsIGM0KTtcclxuXHJcbiAgICByZXN1bHQubTEzID0gIGRldGVybWluYW50M3gzKGIxLCBiMiwgYjQsIGMxLCBjMiwgYzQsIGQxLCBkMiwgZDQpO1xyXG4gICAgcmVzdWx0Lm0yMyA9IC1kZXRlcm1pbmFudDN4MyhhMSwgYTIsIGE0LCBjMSwgYzIsIGM0LCBkMSwgZDIsIGQ0KTtcclxuICAgIHJlc3VsdC5tMzMgPSAgZGV0ZXJtaW5hbnQzeDMoYTEsIGEyLCBhNCwgYjEsIGIyLCBiNCwgZDEsIGQyLCBkNCk7XHJcbiAgICByZXN1bHQubTQzID0gLWRldGVybWluYW50M3gzKGExLCBhMiwgYTQsIGIxLCBiMiwgYjQsIGMxLCBjMiwgYzQpO1xyXG5cclxuICAgIHJlc3VsdC5tMTQgPSAtZGV0ZXJtaW5hbnQzeDMoYjEsIGIyLCBiMywgYzEsIGMyLCBjMywgZDEsIGQyLCBkMyk7XHJcbiAgICByZXN1bHQubTI0ID0gIGRldGVybWluYW50M3gzKGExLCBhMiwgYTMsIGMxLCBjMiwgYzMsIGQxLCBkMiwgZDMpO1xyXG4gICAgcmVzdWx0Lm0zNCA9IC1kZXRlcm1pbmFudDN4MyhhMSwgYTIsIGEzLCBiMSwgYjIsIGIzLCBkMSwgZDIsIGQzKTtcclxuICAgIHJlc3VsdC5tNDQgPSAgZGV0ZXJtaW5hbnQzeDMoYTEsIGEyLCBhMywgYjEsIGIyLCBiMywgYzEsIGMyLCBjMyk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4I2ludmVyc2UoKSAtPiBGaXJtaW5DU1NNYXRyaXggfCBudWxsXHJcbiAqXHJcbiAqICBJZiB0aGUgbWF0cml4IGlzIGludmVydGlibGUsIHJldHVybnMgaXRzIGludmVyc2UsIG90aGVyd2lzZSByZXR1cm5zIG51bGwuXHJcbiAqKi9cclxuRmlybWluQ1NTTWF0cml4LnByb3RvdHlwZS5pbnZlcnNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgaW52LCBkZXQsIHJlc3VsdCwgaSwgajtcclxuXHJcbiAgICBpZiAodGhpcy5pc0lkZW50aXR5T3JUcmFuc2xhdGlvbigpKSB7XHJcbiAgICAgICAgaW52ID0gbmV3IEZpcm1pbkNTU01hdHJpeCgpO1xyXG5cclxuICAgICAgICBpZiAoISh0aGlzLm00MSA9PT0gMCAmJiB0aGlzLm00MiA9PT0gMCAmJiB0aGlzLm00MyA9PT0gMCkpIHtcclxuICAgICAgICAgICAgaW52Lm00MSA9IC10aGlzLm00MTtcclxuICAgICAgICAgICAgaW52Lm00MiA9IC10aGlzLm00MjtcclxuICAgICAgICAgICAgaW52Lm00MyA9IC10aGlzLm00MztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBpbnY7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBhZGpvaW50IG1hdHJpeFxyXG4gICAgcmVzdWx0ID0gdGhpcy5hZGpvaW50KCk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSA0eDQgZGV0ZXJtaW5hbnRcclxuICAgIGRldCA9IEZpcm1pbkNTU01hdHJpeC5kZXRlcm1pbmFudDR4NCh0aGlzKTtcclxuXHJcbiAgICAvLyBJZiB0aGUgZGV0ZXJtaW5hbnQgaXMgemVybywgdGhlbiB0aGUgaW52ZXJzZSBtYXRyaXggaXMgbm90IHVuaXF1ZVxyXG4gICAgaWYgKE1hdGguYWJzKGRldCkgPCAxZS04KSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAvLyBTY2FsZSB0aGUgYWRqb2ludCBtYXRyaXggdG8gZ2V0IHRoZSBpbnZlcnNlXHJcbiAgICBmb3IgKGkgPSAxOyBpIDwgNTsgaSsrKSB7XHJcbiAgICAgICAgZm9yIChqID0gMTsgaiA8IDU7IGorKykge1xyXG4gICAgICAgICAgICByZXN1bHRbKFwibVwiICsgaSkgKyBqXSAvPSBkZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCNyb3RhdGUocm90WCwgcm90WSwgcm90WikgLT4gRmlybWluQ1NTTWF0cml4XHJcbiAqICAtIHJvdFggKE51bWJlcik6IHRoZSByb3RhdGlvbiBhcm91bmQgdGhlIHggYXhpcy5cclxuICogIC0gcm90WSAoTnVtYmVyKTogdGhlIHJvdGF0aW9uIGFyb3VuZCB0aGUgeSBheGlzLiBJZiB1bmRlZmluZWQsIHRoZSB4XHJcbiAqICAgIGNvbXBvbmVudCBpcyB1c2VkLlxyXG4gKiAgLSByb3RaIChOdW1iZXIpOiB0aGUgcm90YXRpb24gYXJvdW5kIHRoZSB6IGF4aXMuIElmIHVuZGVmaW5lZCwgdGhlIHhcclxuICogICAgY29tcG9uZW50IGlzIHVzZWQuXHJcbiAqXHJcbiAqICBSZXR1cm5zIHRoZSByZXN1bHQgb2Ygcm90YXRpbmcgdGhlIG1hdHJpeCBieSBhIGdpdmVuIHZlY3Rvci5cclxuICpcclxuICogIElmIG9ubHkgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIHByb3ZpZGVkLCB0aGUgbWF0cml4IGlzIG9ubHkgcm90YXRlZCBhYm91dFxyXG4gKiAgdGhlIHogYXhpcy5cclxuICoqL1xyXG5GaXJtaW5DU1NNYXRyaXgucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uKHJ4LCByeSwgcnopIHtcclxuICAgIHZhciBkZWdyZWVzVG9SYWRpYW5zID0gRmlybWluQ1NTTWF0cml4LmRlZ3JlZXNUb1JhZGlhbnM7XHJcblxyXG4gICAgaWYgKHR5cGVvZiByeCAhPSBcIm51bWJlclwiIHx8IGlzTmFOKHJ4KSkgcnggPSAwO1xyXG5cclxuICAgIGlmICgodHlwZW9mIHJ5ICE9IFwibnVtYmVyXCIgfHwgaXNOYU4ocnkpKSAmJlxyXG4gICAgKHR5cGVvZiByeiAhPSBcIm51bWJlclwiIHx8IGlzTmFOKHJ6KSkpIHtcclxuICAgICAgICByeiA9IHJ4O1xyXG4gICAgICAgIHJ4ID0gMDtcclxuICAgICAgICByeSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiByeSAhPSBcIm51bWJlclwiIHx8IGlzTmFOKHJ5KSkgcnkgPSAwO1xyXG4gICAgaWYgKHR5cGVvZiByeiAhPSBcIm51bWJlclwiIHx8IGlzTmFOKHJ6KSkgcnogPSAwO1xyXG5cclxuICAgIHJ4ID0gZGVncmVlc1RvUmFkaWFucyhyeCk7XHJcbiAgICByeSA9IGRlZ3JlZXNUb1JhZGlhbnMocnkpO1xyXG4gICAgcnogPSBkZWdyZWVzVG9SYWRpYW5zKHJ6KTtcclxuXHJcbiAgICB2YXIgdHggPSBuZXcgRmlybWluQ1NTTWF0cml4KCksXHJcbiAgICB0eSA9IG5ldyBGaXJtaW5DU1NNYXRyaXgoKSxcclxuICAgIHR6ID0gbmV3IEZpcm1pbkNTU01hdHJpeCgpLFxyXG4gICAgc2luQSwgY29zQSwgc2luQTI7XHJcblxyXG4gICAgcnogLz0gMjtcclxuICAgIHNpbkEgPSBNYXRoLnNpbihyeik7XHJcbiAgICBjb3NBID0gTWF0aC5jb3MocnopO1xyXG4gICAgc2luQTIgPSBzaW5BICogc2luQTtcclxuXHJcbiAgICAvLyBNYXRyaWNlcyBhcmUgaWRlbnRpdHkgb3V0c2lkZSB0aGUgYXNzaWduZWQgdmFsdWVzXHJcbiAgICB0ei5tMTEgPSB0ei5tMjIgPSAxIC0gMiAqIHNpbkEyO1xyXG4gICAgdHoubTEyID0gdHoubTIxID0gMiAqIHNpbkEgKiBjb3NBO1xyXG4gICAgdHoubTIxICo9IC0xO1xyXG5cclxuICAgIHJ5IC89IDI7XHJcbiAgICBzaW5BICA9IE1hdGguc2luKHJ5KTtcclxuICAgIGNvc0EgID0gTWF0aC5jb3MocnkpO1xyXG4gICAgc2luQTIgPSBzaW5BICogc2luQTtcclxuXHJcbiAgICB0eS5tMTEgPSB0eS5tMzMgPSAxIC0gMiAqIHNpbkEyO1xyXG4gICAgdHkubTEzID0gdHkubTMxID0gMiAqIHNpbkEgKiBjb3NBO1xyXG4gICAgdHkubTEzICo9IC0xO1xyXG5cclxuICAgIHJ4IC89IDI7XHJcbiAgICBzaW5BID0gTWF0aC5zaW4ocngpO1xyXG4gICAgY29zQSA9IE1hdGguY29zKHJ4KTtcclxuICAgIHNpbkEyID0gc2luQSAqIHNpbkE7XHJcblxyXG4gICAgdHgubTIyID0gdHgubTMzID0gMSAtIDIgKiBzaW5BMjtcclxuICAgIHR4Lm0yMyA9IHR4Lm0zMiA9IDIgKiBzaW5BICogY29zQTtcclxuICAgIHR4Lm0zMiAqPSAtMTtcclxuXHJcbiAgICB2YXIgaXNJZGVudGl0eSA9ICh0aGlzLnRvU3RyaW5nKCkgPT09IChuZXcgRmlybWluQ1NTTWF0cml4KS50b1N0cmluZygpKTtcclxuXHJcbiAgICByZXR1cm4gKGlzSWRlbnRpdHkpXHJcbiAgICA/IHR6Lm11bHRpcGx5KHR5KS5tdWx0aXBseSh0eClcclxuICAgIDogdGhpcy5tdWx0aXBseSh0eCkubXVsdGlwbHkodHkpLm11bHRpcGx5KHR6KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4I3JvdGF0ZUF4aXNBbmdsZShyb3RYLCByb3RZLCByb3RaLCBhbmdsZSkgLT4gRmlybWluQ1NTTWF0cml4XHJcbiAqICAtIHJvdFggKE51bWJlcik6IHRoZSByb3RhdGlvbiBhcm91bmQgdGhlIHggYXhpcy5cclxuICogIC0gcm90WSAoTnVtYmVyKTogdGhlIHJvdGF0aW9uIGFyb3VuZCB0aGUgeSBheGlzLiBJZiB1bmRlZmluZWQsIHRoZSB4XHJcbiAqICAgIGNvbXBvbmVudCBpcyB1c2VkLlxyXG4gKiAgLSByb3RaIChOdW1iZXIpOiB0aGUgcm90YXRpb24gYXJvdW5kIHRoZSB6IGF4aXMuIElmIHVuZGVmaW5lZCwgdGhlIHhcclxuICogICAgY29tcG9uZW50IGlzIHVzZWQuXHJcbiAqICAtIGFuZ2xlIChOdW1iZXIpOiB0aGUgYW5nbGUgb2Ygcm90YXRpb24gYWJvdXQgdGhlIGF4aXMgdmVjdG9yLCBpbiBkZWdyZWVzLlxyXG4gKlxyXG4gKiAgUmV0dXJucyB0aGUgcmVzdWx0IG9mIHJvdGF0aW5nIHRoZSBtYXRyaXggYXJvdW5kIGEgZ2l2ZW4gdmVjdG9yIGJ5IGEgZ2l2ZW5cclxuICogIGFuZ2xlLlxyXG4gKlxyXG4gKiAgSWYgdGhlIGdpdmVuIHZlY3RvciBpcyB0aGUgb3JpZ2luIHZlY3RvciB0aGVuIHRoZSBtYXRyaXggaXMgcm90YXRlZCBieSB0aGVcclxuICogIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgeiBheGlzLlxyXG4gKiovXHJcbkZpcm1pbkNTU01hdHJpeC5wcm90b3R5cGUucm90YXRlQXhpc0FuZ2xlID0gZnVuY3Rpb24oeCwgeSwgeiwgYSkge1xyXG4gICAgaWYgKHR5cGVvZiB4ICE9IFwibnVtYmVyXCIgfHwgaXNOYU4oeCkpIHggPSAwO1xyXG4gICAgaWYgKHR5cGVvZiB5ICE9IFwibnVtYmVyXCIgfHwgaXNOYU4oeSkpIHkgPSAwO1xyXG4gICAgaWYgKHR5cGVvZiB6ICE9IFwibnVtYmVyXCIgfHwgaXNOYU4oeikpIHogPSAwO1xyXG4gICAgaWYgKHR5cGVvZiBhICE9IFwibnVtYmVyXCIgfHwgaXNOYU4oYSkpIGEgPSAwO1xyXG4gICAgaWYgKHggPT09IDAgJiYgeSA9PT0gMCAmJiB6ID09PSAwKSB6ID0gMTtcclxuXHJcbiAgICB2YXIgdCAgID0gbmV3IEZpcm1pbkNTU01hdHJpeCgpLFxyXG4gICAgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeiksXHJcbiAgICBjb3NBLCBzaW5BLCBzaW5BMiwgY3NBLCB4MiwgeTIsIHoyO1xyXG5cclxuICAgIGEgICAgID0gKEZpcm1pbkNTU01hdHJpeC5kZWdyZWVzVG9SYWRpYW5zKGEpIHx8IDApIC8gMjtcclxuICAgIGNvc0EgID0gTWF0aC5jb3MoYSk7XHJcbiAgICBzaW5BICA9IE1hdGguc2luKGEpO1xyXG4gICAgc2luQTIgPSBzaW5BICogc2luQTtcclxuXHJcbiAgICAvLyBCYWQgdmVjdG9yLCB1c2Ugc29tZXRoaW5nIHNlbnNpYmxlXHJcbiAgICBpZiAobGVuID09PSAwKSB7XHJcbiAgICAgICAgeCA9IDA7XHJcbiAgICAgICAgeSA9IDA7XHJcbiAgICAgICAgeiA9IDE7XHJcbiAgICB9IGVsc2UgaWYgKGxlbiAhPT0gMSkge1xyXG4gICAgICAgIHggLz0gbGVuO1xyXG4gICAgICAgIHkgLz0gbGVuO1xyXG4gICAgICAgIHogLz0gbGVuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE9wdGltaXNlIGNhc2VzIHdoZXJlIGF4aXMgaXMgYWxvbmcgbWFqb3IgYXhpc1xyXG4gICAgaWYgKHggPT09IDEgJiYgeSA9PT0gMCAmJiB6ID09PSAwKSB7XHJcbiAgICAgICAgdC5tMjIgPSB0Lm0zMyA9IDEgLSAyICogc2luQTI7XHJcbiAgICAgICAgdC5tMjMgPSB0Lm0zMiA9IDIgKiBjb3NBICogc2luQTtcclxuICAgICAgICB0Lm0zMiAqPSAtMTtcclxuICAgIH0gZWxzZSBpZiAoeCA9PT0gMCAmJiB5ID09PSAxICYmIHogPT09IDApIHtcclxuICAgICAgICB0Lm0xMSA9IHQubTMzID0gMSAtIDIgKiBzaW5BMjtcclxuICAgICAgICB0Lm0xMyA9IHQubTMxID0gMiAqIGNvc0EgKiBzaW5BO1xyXG4gICAgICAgIHQubTEzICo9IC0xO1xyXG4gICAgfSBlbHNlIGlmICh4ID09PSAwICYmIHkgPT09IDAgJiYgeiA9PT0gMSkge1xyXG4gICAgICAgIHQubTExID0gdC5tMjIgPSAxIC0gMiAqIHNpbkEyO1xyXG4gICAgICAgIHQubTEyID0gdC5tMjEgPSAyICogY29zQSAqIHNpbkE7XHJcbiAgICAgICAgdC5tMjEgKj0gLTE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNzQSA9IHNpbkEgKiBjb3NBO1xyXG4gICAgICAgIHgyICA9IHggKiB4O1xyXG4gICAgICAgIHkyICA9IHkgKiB5O1xyXG4gICAgICAgIHoyICA9IHogKiB6O1xyXG5cclxuICAgICAgICB0Lm0xMSA9IDEgLSAyICogKHkyICsgejIpICogc2luQTI7XHJcbiAgICAgICAgdC5tMTIgPSAyICogKHggKiB5ICogc2luQTIgKyB6ICogY3NBKTtcclxuICAgICAgICB0Lm0xMyA9IDIgKiAoeCAqIHogKiBzaW5BMiAtIHkgKiBjc0EpO1xyXG4gICAgICAgIHQubTIxID0gMiAqICh5ICogeCAqIHNpbkEyIC0geiAqIGNzQSk7XHJcbiAgICAgICAgdC5tMjIgPSAxIC0gMiAqICh6MiArIHgyKSAqIHNpbkEyO1xyXG4gICAgICAgIHQubTIzID0gMiAqICh5ICogeiAqIHNpbkEyICsgeCAqIGNzQSk7XHJcbiAgICAgICAgdC5tMzEgPSAyICogKHogKiB4ICogc2luQTIgKyB5ICogY3NBKTtcclxuICAgICAgICB0Lm0zMiA9IDIgKiAoeiAqIHkgKiBzaW5BMiAtIHggKiBjc0EpO1xyXG4gICAgICAgIHQubTMzID0gMSAtIDIgKiAoeDIgKyB5MikgKiBzaW5BMjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseSh0KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4I3NjYWxlKHNjYWxlWCwgc2NhbGVZLCBzY2FsZVopIC0+IEZpcm1pbkNTU01hdHJpeFxyXG4gKiAgLSBzY2FsZVggKE51bWJlcik6IHRoZSBzY2FsaW5nIGZhY3RvciBpbiB0aGUgeCBheGlzLlxyXG4gKiAgLSBzY2FsZVkgKE51bWJlcik6IHRoZSBzY2FsaW5nIGZhY3RvciBpbiB0aGUgeSBheGlzLiBJZiB1bmRlZmluZWQsIHRoZSB4XHJcbiAqICAgIGNvbXBvbmVudCBpcyB1c2VkLlxyXG4gKiAgLSBzY2FsZVogKE51bWJlcik6IHRoZSBzY2FsaW5nIGZhY3RvciBpbiB0aGUgeiBheGlzLiBJZiB1bmRlZmluZWQsIDEgaXNcclxuICogICAgdXNlZC5cclxuICpcclxuICogIFJldHVybnMgdGhlIHJlc3VsdCBvZiBzY2FsaW5nIHRoZSBtYXRyaXggYnkgYSBnaXZlbiB2ZWN0b3IuXHJcbiAqKi9cclxuRmlybWluQ1NTTWF0cml4LnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uKHNjYWxlWCwgc2NhbGVZLCBzY2FsZVopIHtcclxuICAgIHZhciB0cmFuc2Zvcm0gPSBuZXcgRmlybWluQ1NTTWF0cml4KCk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBzY2FsZVggIT0gXCJudW1iZXJcIiB8fCBpc05hTihzY2FsZVgpKSBzY2FsZVggPSAxO1xyXG4gICAgaWYgKHR5cGVvZiBzY2FsZVkgIT0gXCJudW1iZXJcIiB8fCBpc05hTihzY2FsZVkpKSBzY2FsZVkgPSBzY2FsZVg7XHJcbiAgICBpZiAodHlwZW9mIHNjYWxlWiAhPSBcIm51bWJlclwiIHx8IGlzTmFOKHNjYWxlWikpIHNjYWxlWiA9IDE7XHJcblxyXG4gICAgdHJhbnNmb3JtLm0xMSA9IHNjYWxlWDtcclxuICAgIHRyYW5zZm9ybS5tMjIgPSBzY2FsZVk7XHJcbiAgICB0cmFuc2Zvcm0ubTMzID0gc2NhbGVaO1xyXG5cclxuICAgIHJldHVybiB0aGlzLm11bHRpcGx5KHRyYW5zZm9ybSk7XHJcbn07XHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCNza2V3WChza2V3WCkgLT4gRmlybWluQ1NTTWF0cml4XHJcbiAqICAtIHNrZXdYIChOdW1iZXIpOiB0aGUgc2NhbGluZyBmYWN0b3IgaW4gdGhlIHggYXhpcy5cclxuICpcclxuICogIFJldHVybnMgdGhlIHJlc3VsdCBvZiBza2V3aW5nIHRoZSBtYXRyaXggYnkgYSBnaXZlbiB2ZWN0b3IuXHJcbiAqKi9cclxuRmlybWluQ1NTTWF0cml4LnByb3RvdHlwZS5za2V3WCA9IGZ1bmN0aW9uKGRlZ3JlZXMpIHtcclxuICAgIHZhciByYWRpYW5zID0gRmlybWluQ1NTTWF0cml4LmRlZ3JlZXNUb1JhZGlhbnMoZGVncmVlcyk7XHJcbiAgICB2YXIgdHJhbnNmb3JtID0gbmV3IEZpcm1pbkNTU01hdHJpeCgpO1xyXG5cclxuICAgIHRyYW5zZm9ybS5jID0gTWF0aC50YW4ocmFkaWFucyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbHkodHJhbnNmb3JtKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4I3NrZXdZKHNrZXdZKSAtPiBGaXJtaW5DU1NNYXRyaXhcclxuICogIC0gc2tld1kgKE51bWJlcik6IHRoZSBzY2FsaW5nIGZhY3RvciBpbiB0aGUgeCBheGlzLlxyXG4gKlxyXG4gKiAgUmV0dXJucyB0aGUgcmVzdWx0IG9mIHNrZXdpbmcgdGhlIG1hdHJpeCBieSBhIGdpdmVuIHZlY3Rvci5cclxuICoqL1xyXG5GaXJtaW5DU1NNYXRyaXgucHJvdG90eXBlLnNrZXdZID0gZnVuY3Rpb24oZGVncmVlcykge1xyXG4gICAgdmFyIHJhZGlhbnMgPSBGaXJtaW5DU1NNYXRyaXguZGVncmVlc1RvUmFkaWFucyhkZWdyZWVzKTtcclxuICAgIHZhciB0cmFuc2Zvcm0gPSBuZXcgRmlybWluQ1NTTWF0cml4KCk7XHJcblxyXG4gICAgdHJhbnNmb3JtLmIgPSBNYXRoLnRhbihyYWRpYW5zKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseSh0cmFuc2Zvcm0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqICBGaXJtaW5DU1NNYXRyaXgjdHJhbnNsYXRlKHgsIHksIHopIC0+IEZpcm1pbkNTU01hdHJpeFxyXG4gKiAgLSB4IChOdW1iZXIpOiB0aGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvci5cclxuICogIC0geSAoTnVtYmVyKTogdGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IuXHJcbiAqICAtIHogKE51bWJlcik6IHRoZSB6IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLiBJZiB1bmRlZmluZWQsIDAgaXMgdXNlZC5cclxuICpcclxuICogIFJldHVybnMgdGhlIHJlc3VsdCBvZiB0cmFuc2xhdGluZyB0aGUgbWF0cml4IGJ5IGEgZ2l2ZW4gdmVjdG9yLlxyXG4gKiovXHJcbkZpcm1pbkNTU01hdHJpeC5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24oeCwgeSwgeikge1xyXG4gICAgdmFyIHQgPSBuZXcgRmlybWluQ1NTTWF0cml4KCk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiB4ICE9IFwibnVtYmVyXCIgfHwgaXNOYU4oeCkpIHggPSAwO1xyXG4gICAgaWYgKHR5cGVvZiB5ICE9IFwibnVtYmVyXCIgfHwgaXNOYU4oeSkpIHkgPSAwO1xyXG4gICAgaWYgKHR5cGVvZiB6ICE9IFwibnVtYmVyXCIgfHwgaXNOYU4oeikpIHogPSAwO1xyXG5cclxuICAgIHQubTQxID0geDtcclxuICAgIHQubTQyID0geTtcclxuICAgIHQubTQzID0gejtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseSh0KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiAgRmlybWluQ1NTTWF0cml4I3NldE1hdHJpeFZhbHVlKGRvbXN0cikgLT4gdW5kZWZpbmVkXHJcbiAqICAtIGRvbXN0ciAoU3RyaW5nKTogYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSAyRCBvciAzRCB0cmFuc2Zvcm0gbWF0cml4XHJcbiAqICAgIGluIHRoZSBmb3JtIGdpdmVuIGJ5IHRoZSBDU1MgdHJhbnNmb3JtIHByb3BlcnR5LCBpLmUuIGp1c3QgbGlrZSB0aGVcclxuICogICAgb3V0cHV0IGZyb20gW1tGaXJtaW5DU1NNYXRyaXgjdG9TdHJpbmddXS5cclxuICpcclxuICogIFNldHMgdGhlIG1hdHJpeCB2YWx1ZXMgdXNpbmcgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgdGhhdCBwcm9kdWNlZFxyXG4gKiAgYnkgdGhlIFtbRmlybWluQ1NTTWF0cml4I3RvU3RyaW5nXV0gbWV0aG9kLlxyXG4gKiovXHJcbkZpcm1pbkNTU01hdHJpeC5wcm90b3R5cGUuc2V0TWF0cml4VmFsdWUgPSBmdW5jdGlvbihkb21zdHIpIHtcclxuICAgIGRvbXN0ciA9IEZpcm1pbkNTU01hdHJpeC50b01hdHJpeFN0cmluZyhkb21zdHIudHJpbSgpKTtcclxuICAgIHZhciBtc3RyICAgPSBkb21zdHIubWF0Y2goL15tYXRyaXgoM2QpP1xcKFxccyooLispXFxzKlxcKSQvKSxcclxuICAgIGlzM2QsIGNodW5rcywgbGVuLCBwb2ludHMsIGksIGNodW5rO1xyXG5cclxuICAgIGlmICghbXN0cikgcmV0dXJuO1xyXG5cclxuICAgIGlzM2QgICA9ICEhbXN0clsxXTtcclxuICAgIGNodW5rcyA9IG1zdHJbMl0uc3BsaXQoL1xccyosXFxzKi8pO1xyXG4gICAgbGVuICAgID0gY2h1bmtzLmxlbmd0aDtcclxuICAgIHBvaW50cyA9IG5ldyBBcnJheShsZW4pO1xyXG5cclxuICAgIGlmICgoaXMzZCAmJiBsZW4gIT09IDE2KSB8fCAhKGlzM2QgfHwgbGVuID09PSA2KSkge1xyXG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiSW52YWxpZCBDU1MgTWF0cml4OiBcIiwgZG9tc3RyKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBjaHVuayA9IGNodW5rc1tpXTtcclxuICAgICAgICAgICAgcG9pbnRzW2ldID0gcGFyc2VGbG9hdChjaHVuayk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJJbnZhbGlkIENTUyBNYXRyaXg6IFwiLCBkb21zdHIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIHZhciBwb2ludCA9IGlzM2QgP1xyXG4gICAgICAgIChcIm1cIiArIChNYXRoLmZsb29yKGkgLyA0KSArIDEpKSArIChpICUgNCArIDEpIDpcclxuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgKyA5Nyk7IC8vIEFTQ0lJIGNoYXIgOTcgPT0gJ2EnXHJcbiAgICAgICAgdGhpc1twb2ludF0gPSBwb2ludHNbaV07XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogIEZpcm1pbkNTU01hdHJpeCN0b1N0cmluZygpIC0+IFN0cmluZ1xyXG4gKlxyXG4gKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4LlxyXG4gKiovXHJcbkZpcm1pbkNTU01hdHJpeC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcywgcG9pbnRzLCBwcmVmaXg7XHJcblxyXG4gICAgaWYgKHRoaXMuaXNBZmZpbmUoKSkge1xyXG4gICAgICAgIHByZWZpeCA9IFwibWF0cml4KFwiO1xyXG4gICAgICAgIHBvaW50cyA9IFtcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIiwgXCJlXCIsIFwiZlwiXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcHJlZml4ID0gXCJtYXRyaXgzZChcIjtcclxuICAgICAgICBwb2ludHMgPSBbXCJtMTFcIiwgXCJtMTJcIiwgXCJtMTNcIiwgXCJtMTRcIixcclxuICAgICAgICAgICAgXCJtMjFcIiwgXCJtMjJcIiwgXCJtMjNcIiwgXCJtMjRcIixcclxuICAgICAgICAgICAgXCJtMzFcIiwgXCJtMzJcIiwgXCJtMzNcIiwgXCJtMzRcIixcclxuICAgICAgICAgICAgXCJtNDFcIiwgXCJtNDJcIiwgXCJtNDNcIiwgXCJtNDRcIl07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHByZWZpeCArIHBvaW50cy5tYXAoZnVuY3Rpb24ocCkge1xyXG4gICAgICAgIHJldHVybiBzZWxmW3BdLnRvRml4ZWQoNik7XHJcbiAgICB9KS5qb2luKFwiLCBcIikgKyBcIilcIjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmlybWluQ1NTTWF0cml4O1xyXG5cclxuIiwidmFyIHByaW50U3RhY2tUcmFjZSA9IHJlcXVpcmUoXCIuLi9jb250cmliL3N0YWNrdHJhY2UtMC40LmpzXCIpO1xyXG52YXIgT3B0aW9ucyA9IHJlcXVpcmUoXCIuL29wdGlvbnMuanNcIik7XHJcbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xyXG5cclxuKGZ1bmN0aW9uIChucykge1xyXG5cclxuICAgIHZhciBPUFRJT05fTE9HTEVWRUwgPSBcImxvZ2xldmVsXCI7XHJcbiAgICBPcHRpb25zLnJlZ2lzdGVyKE9QVElPTl9MT0dMRVZFTCwgXCJ3YXJuaW5nXCIpO1xyXG5cclxuICAgIG5zLmV4cG9ydHMgPSB7XHJcbiAgICAgICAgQUxMOiAwLFxyXG4gICAgICAgIERFQlVHOiAxLFxyXG4gICAgICAgIElORk86IDIsXHJcbiAgICAgICAgV0FSTklORzogMyxcclxuICAgICAgICBJU1NVRTogNCxcclxuICAgICAgICBFUlJPUjogNSxcclxuICAgICAgICBFWENFUFRJT046IDYsXHJcbiAgICAgICAgcGFyYW1zOiB7fSxcclxuICAgICAgICBpc1NldHVwOiBmYWxzZSxcclxuICAgICAgICBsb2dsZXZlbDogNSxcclxuICAgICAgICBsb2dsZXZlbHM6IHtcclxuICAgICAgICAgICAgYWxsOiAwLFxyXG4gICAgICAgICAgICBkZWJ1ZzogMSxcclxuICAgICAgICAgICAgaW5mbzogMixcclxuICAgICAgICAgICAgd2FybmluZzogMyxcclxuICAgICAgICAgICAgaXNzdWU6IDQsXHJcbiAgICAgICAgICAgIGVycm9yOiA1LFxyXG4gICAgICAgICAgICBleGNlcHRpb246IDZcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXR1cDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZGVidWcgPSBYTUwzRC5kZWJ1ZztcclxuICAgICAgICAgICAgaWYgKCFkZWJ1Zy5pc1NldHVwKSB7XHJcbiAgICAgICAgICAgICAgICBkZWJ1Zy5pc1NldHVwID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGRlYnVnLmxvZ2xldmVsID0gZGVidWcubG9nbGV2ZWxzW09wdGlvbnMuZ2V0VmFsdWUoT1BUSU9OX0xPR0xFVkVMKV0gfHwgMztcclxuICAgICAgICAgICAgICAgIE9wdGlvbnMuYWRkT2JzZXJ2ZXIoZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGtleSA9PSBPUFRJT05fTE9HTEVWRUwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcubG9nbGV2ZWwgPSBkZWJ1Zy5sb2dsZXZlbHNbdmFsdWVdIHx8IDM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9zZXRMb2dMZXZlbDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkb0xvZzogZnVuY3Rpb24gKGxvZ1R5cGUsIGFyZ3MpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFhNTDNELmRlYnVnLnBhcmFtcztcclxuICAgICAgICAgICAgaWYgKHBhcmFtcy54bWwzZF9ub2xvZyB8fCBsb2dUeXBlIDwgWE1MM0QuZGVidWcubG9nbGV2ZWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cuY29uc29sZSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChsb2dUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBYTUwzRC5kZWJ1Zy5JTkZPOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS5pbmZvLmFwcGx5KHdpbmRvdy5jb25zb2xlLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBYTUwzRC5kZWJ1Zy5XQVJOSU5HOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS53YXJuLmFwcGx5KHdpbmRvdy5jb25zb2xlLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBYTUwzRC5kZWJ1Zy5FUlJPUjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUuZXJyb3IuYXBwbHkod2luZG93LmNvbnNvbGUsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFhNTDNELmRlYnVnLkVYQ0VQVElPTjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUuZXJyb3IocHJpbnRTdGFja1RyYWNlKHtlOiBhcmdzWzBdLCBndWVzczogdHJ1ZX0pLmpvaW4oJ1xcbicpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBYTUwzRC5kZWJ1Zy5ERUJVRzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUuZGVidWcuYXBwbHkod2luZG93LmNvbnNvbGUsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFhNTDNELmRlYnVnLklTU1VFOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQoYXJnc1sxXSAhPT0gdW5kZWZpbmVkLCBcIkdpdGh1YiBpc3N1ZSBudW1iZXIgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNzdWUgPSBhcmdzWzBdICsgXCJcXG5Nb3JlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBhdCBodHRwczovL2dpdGh1Yi5jb20veG1sM2QveG1sM2QuanMvaXNzdWVzL1wiICsgYXJnc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUuZXJyb3IoaXNzdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbG9nRGVidWc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcuZG9Mb2coWE1MM0QuZGVidWcuREVCVUcsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsb2dJbmZvOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmRvTG9nKFhNTDNELmRlYnVnLklORk8sIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsb2dXYXJuaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmRvTG9nKFhNTDNELmRlYnVnLldBUk5JTkcsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsb2dFcnJvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5kb0xvZyhYTUwzRC5kZWJ1Zy5FUlJPUiwgYXJndW1lbnRzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxvZ0lzc3VlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcuZG9Mb2coWE1MM0QuZGVidWcuSVNTVUUsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsb2dFeGNlcHRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcuZG9Mb2coWE1MM0QuZGVidWcuRVhDRVBUSU9OLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYXNzZXJ0OiBhc3NlcnQsXHJcbiAgICAgICAgdHJhY2U6IGZ1bmN0aW9uIChtc2csIGxvZ1R5cGUpIHtcclxuICAgICAgICAgICAgbG9nVHlwZSA9IGxvZ1R5cGUgIT09IHVuZGVmaW5lZCA/IGxvZ1R5cGUgOiBYTUwzRC5kZWJ1Zy5FUlJPUjtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlLnRyYWNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobXNnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcuZG9Mb2cobG9nVHlwZSwgW21zZ10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUudHJhY2UoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFjayA9IHByaW50U3RhY2tUcmFjZSgpO1xyXG4gICAgICAgICAgICAgICAgbXNnICYmIHN0YWNrLnNwbGljZSgwLCAwLCBtc2cpO1xyXG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcuZG9Mb2cobG9nVHlwZSwgc3RhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXROdW1iZXJXaXRoUGFkZGluZzogZnVuY3Rpb24gKG51bWJlciwgd2lkdGgpIHtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IFwiXCIgKyBudW1iZXI7XHJcbiAgICAgICAgICAgIHdoaWxlIChyZXMubGVuZ3RoIDwgd2lkdGgpIHJlcyA9IFwiIFwiICsgcmVzO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZm9ybWF0U291cmNlQ29kZTogZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICAgICAgdmFyIHNvdXJjZUxpbmVzID0gc291cmNlLnNwbGl0KFwiXFxuXCIpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZUxpbmVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5nZXROdW1iZXJXaXRoUGFkZGluZyhpICsgMSwgMykgKyBcIiAgXCIgKyBzb3VyY2VMaW5lc1tpXSArIFwiXFxuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxufShtb2R1bGUpKTtcclxuIiwiLy8gdXRpbHMvbWlzYy5qc1xyXG5cclxuKGZ1bmN0aW9uKGV4cG9ydHMpIHtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNlbmRzIHNpbmdsZSBvciBtdWx0aXBsZSBhZGFwdGVyIGZ1bmN0aW9ucyBieSBjYWxsaW5nIGZ1bmN0aW9uc1xyXG4gICAgICogc3BlY2lmaWVkIGluIGZ1bmNzIHBhcmFtZXRlciBmb3IgZWFjaCBhZGFwdGVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgbm9kZS5cclxuICAgICAqXHJcbiAgICAgKiBmdW5jcyBwYXJhbWV0ZXIgaXMgdXNlZCBhcyBhIGRpY3Rpb25hcnkgd2hlcmUgZWFjaCBrZXkgaXMgdXNlZCBhcyBuYW1lIG9mIGFcclxuICAgICAqIGFkYXB0ZXIgZnVuY3Rpb24gdG8gY2FsbCwgYW5kIGNvcnJlc3BvbmRpbmcgdmFsdWUgaXMgYSBsaXN0IG9mIGFyZ3VtZW50c1xyXG4gICAgICogKGkuZS4gbXVzdCBiZSBhbiBhcnJheSkuIEZvciBleGFtcGxlIHNlbmRBZGFwdGVyRXZlbnQobm9kZSwge21ldGhvZCA6IFsxLDIsM119KVxyXG4gICAgICogd2lsbCBjYWxsIGZ1bmN0aW9uICdtZXRob2QnIHdpdGggYXJndW1lbnRzIDEsMiwzIGZvciBlYWNoIGFkYXB0ZXIgb2YgdGhlIG5vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmdW5jc1xyXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9mIGFsbCByZXR1cm5lZCB2YWx1ZXNcclxuICAgICAqL1xyXG4gICAgZXhwb3J0cy5jYWxsQWRhcHRlckZ1bmMgPSBmdW5jdGlvbihub2RlLCBmdW5jcykge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5fY29uZmlndXJlZCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIHZhciBhZGFwdGVycyA9IG5vZGUuX2NvbmZpZ3VyZWQuYWRhcHRlcnM7XHJcbiAgICAgICAgZm9yICh2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBmdW5jIGluIGZ1bmNzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWRhcHRlck9iamVjdCA9IGFkYXB0ZXJzW2FkYXB0ZXJdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50SGFuZGxlciA9IGFkYXB0ZXJPYmplY3RbZnVuY107XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZXZlbnRIYW5kbGVyLmFwcGx5KGFkYXB0ZXJPYmplY3QsIGZ1bmNzW2Z1bmNdKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNlbmRzIHNpbmdsZSBvciBtdWx0aXBsZSBhZGFwdGVyIGV2ZW50cyBieSBjYWxsaW5nIGZ1bmN0aW9uc1xyXG4gICAgICogc3BlY2lmaWVkIGluIGV2ZW50cyBwYXJhbWV0ZXIgZm9yIGVhY2ggYWRhcHRlciBhc3NvY2lhdGVkIHdpdGggdGhlIG5vZGUuXHJcbiAgICAgKlxyXG4gICAgICogZXZlbnRzIHBhcmFtZXRlciBpcyB1c2VkIGFzIGEgZGljdGlvbmFyeSB3aGVyZSBlYWNoIGtleSBpcyB1c2VkIGFzIG5hbWUgb2YgYVxyXG4gICAgICogYWRhcHRlciBmdW5jdGlvbiB0byBjYWxsLCBhbmQgY29ycmVzcG9uZGluZyB2YWx1ZSBpcyBhIGxpc3Qgb2YgYXJndW1lbnRzXHJcbiAgICAgKiAoaS5lLiBtdXN0IGJlIGFuIGFycmF5KS4gRm9yIGV4YW1wbGUgc2VuZEFkYXB0ZXJFdmVudChub2RlLCB7bWV0aG9kIDogWzEsMiwzXX0pXHJcbiAgICAgKiB3aWxsIGNhbGwgZnVuY3Rpb24gJ21ldGhvZCcgd2l0aCBhcmd1bWVudHMgMSwyLDMgZm9yIGVhY2ggYWRhcHRlciBvZiB0aGUgbm9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50c1xyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gZmFsc2UgaWYgbm9kZSBpcyBub3QgY29uZmlndXJlZC5cclxuICAgICAqL1xyXG4gICAgZXhwb3J0cy5zZW5kQWRhcHRlckV2ZW50ID0gZnVuY3Rpb24obm9kZSwgZXZlbnRzKSB7XHJcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUuX2NvbmZpZ3VyZWQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHZhciBhZGFwdGVycyA9IG5vZGUuX2NvbmZpZ3VyZWQuYWRhcHRlcnM7XHJcbiAgICAgICAgZm9yICh2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBldmVudCBpbiBldmVudHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudEhhbmRsZXIgPSBhZGFwdGVyc1thZGFwdGVyXVtldmVudF07XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyLmFwcGx5KGFkYXB0ZXJzW2FkYXB0ZXJdLCBldmVudHNbZXZlbnRdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogRGlzcGF0Y2ggY3VzdG9tIEhUTUwgZXZlbnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IGVsZW1lbnQgb3IgZG9jdW1lbnQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIGN1c3RvbSBldmVudCB0eXBlLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjYW5CdWJibGUgV2hldGhlciB0aGUgZXZlbnQgcHJvcGFnYXRlcyB1cHdhcmQuIFNldHMgdGhlIHZhbHVlIGZvciB0aGUgYnViYmxlcyBwcm9wZXJ0eS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FuY2VsYWJsZSBXaGV0aGVyIHRoZSBldmVudCBpcyBjYW5jZWxhYmxlIGFuZCBzbyBwcmV2ZW50RGVmYXVsdCBjYW4gYmUgY2FsbGVkLiBTZXRzIHRoZSB2YWx1ZVxyXG4gICAgICogICAgICAgICAgICAgICAgICBmb3IgdGhlIGNhbmNlbGFibGUgcHJvcGVydHkuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGV0YWlsIEEgdXNlci1kZWZpbmVkIG9iamVjdCB0aGF0IGNhbiBjb250YWluIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGV2ZW50LlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICBUaGlzIHBhcmFtZXRlciBjYW4gYmUgb2YgYW55IHR5cGUsIG9yIG51bGwuIFRoaXMgdmFsdWUgaXMgcmV0dXJuZWQgaW4gdGhlIGRldGFpbCBwcm9wZXJ0eSBvZiB0aGUgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydHMuZGlzcGF0Y2hDdXN0b21FdmVudCA9IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnRUeXBlLCBjYW5CdWJibGUsIGNhbmNlbGFibGUsIGRldGFpbCkge1xyXG4gICAgICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xyXG4gICAgICAgIGV2ZW50LmluaXRDdXN0b21FdmVudChldmVudFR5cGUsIGNhbkJ1YmJsZSwgY2FuY2VsYWJsZSwgZGV0YWlsKTtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKiogRGlzcGF0Y2ggSFRNTCBldmVudFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgICAgZWxlbWVudCBvciBkb2N1bWVudFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBzdGFuZGFyZCBldmVudCB0eXBlIGUuZy4gbG9hZCwgY2xpY2tcclxuICAgICAqL1xyXG4gICAgZXhwb3J0cy5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24odGFyZ2V0LCBldmVudFR5cGUpIHtcclxuICAgICAgICB2YXIgZXZ0ID0gbnVsbDtcclxuICAgICAgICBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRzXCIpO1xyXG4gICAgICAgICAgICAgICAgZXZ0LmluaXRFdmVudChldmVudFR5cGUsIHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2dCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmZpcmVFdmVudCgnb24nICsgZXZlbnRUeXBlLCBldnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB2YXIgdG1wQ2FudmFzLCB0bXBDb250ZXh0O1xyXG5cclxuICAgIGV4cG9ydHMudG9JbWFnZURhdGEgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcclxuICAgICAgICBpZihpbWFnZURhdGEgaW5zdGFuY2VvZiBJbWFnZURhdGEpXHJcbiAgICAgICAgICAgIHJldHVybiBpbWFnZURhdGE7XHJcbiAgICAgICAgaWYoIWltYWdlRGF0YS5kYXRhKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBkYXRhIHByb3BlcnR5XCIpO1xyXG4gICAgICAgIGlmKCFpbWFnZURhdGEud2lkdGgpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIHdpZHRoIHByb3BlcnR5XCIpO1xyXG4gICAgICAgIGlmKCFpbWFnZURhdGEuaGVpZ2h0KVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBoZWlnaHQgcHJvcGVydHlcIik7XHJcbiAgICAgICAgaWYoIXRtcENvbnRleHQpIHtcclxuICAgICAgICAgICAgdG1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgIHRtcENvbnRleHQgPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5ld0ltYWdlRGF0YSA9IHRtcENvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKGltYWdlRGF0YS53aWR0aCwgaW1hZ2VEYXRhLmhlaWdodCk7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGltYWdlRGF0YS5kYXRhLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciB2ID0gaW1hZ2VEYXRhLmRhdGFbaV07XHJcbiAgICAgICAgICAgIGlmKHYgPiAyNTUpXHJcbiAgICAgICAgICAgICAgICB2ID0gMjU1O1xyXG4gICAgICAgICAgICBpZih2IDwgMClcclxuICAgICAgICAgICAgICAgIHYgPSAwO1xyXG4gICAgICAgICAgICBuZXdJbWFnZURhdGEuZGF0YVtpXSA9IHY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdJbWFnZURhdGE7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMuZWxlbWVudElzID0gZnVuY3Rpb24oZWxlbSwgbmFtZSkge1xyXG4gICAgICAgIHJldHVybiBlbGVtICYmIGVsZW0udGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLmVuY29kZVpJbmRleCA9IGZ1bmN0aW9uKHpJbmRleCwgaXNMZWFmTm9kZSkge1xyXG4gICAgICAgIGlmICh6SW5kZXggPT09IFwiYXV0b1wiIHx8IHpJbmRleCA9PT0gXCJcIiB8fCB6SW5kZXggPT09IFwiMFwiKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0xlYWZOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB6SW5kZXggPSBcIjBcIjsgLy8gQWx3YXlzIGdpdmUgbGVhZiBub2RlcyBhbiBpbXBsaWNpdCBzdGFja2luZyBjb250ZXh0IHdpdGggei1pbmRleCBvZiAwIHRvIGVuc3VyZSB0aGV5IGNvbXBhcmUgcHJvcGVybHkgd2l0aCBuZWdhdGl2ZSB6LWluZGV4IGxlYWYgbm9kZXNcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiOyAvLyBPdGhlcndpc2UgdGhpcyBncm91cCBub2RlIGRvZXMgbm90IGNyZWF0ZSBhIG5ldyBzdGFja2luZyBjb250ZXh0LCBzbyB3ZSBjYW4gcmV0dXJuIGFuIGVtcHR5IHN0cmluZ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFBhZCB3aXRoIGVub3VnaCB6ZXJvcyB0byBjb3ZlciB0aGUgbWF4aW11bS9taW5pbXVtIHZhbHVlcyAoMjE0NzQ4MzY0NykgZm9yIGNvcnJlY3Qgc3RyaW5nIGNvbXBhcmUgcmVzdWx0cyBpbiB0aGUgc29ydGluZyBzdGVwXHJcbiAgICAgICAgekluZGV4ID0gXCIwMDAwMDAwMDAwXCIgKyB6SW5kZXg7XHJcbiAgICAgICAgekluZGV4ID0gekluZGV4LnNsaWNlKHpJbmRleC5sZW5ndGggLSAxMCk7IC8vIDEwIGlzIHRoZSBudW1iZXIgb2YgZGlnaXRzIGluIHRoZSBtYXggdmFsdWVcclxuICAgICAgICByZXR1cm4gekluZGV4O1xyXG4gICAgfVxyXG5cclxufShtb2R1bGUuZXhwb3J0cykpO1xyXG4iLCIoZnVuY3Rpb24gKG5zKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGFzcyB0byBoYW5kbGUgb3B0aW9ucy4gQ3VycmVudGx5IG9ubHkgdXNlZCBmb3IgZ2xvYmFsIG9wdGlvbnMsIGNvdWxkXHJcbiAgICAgKiBiZSBleHRlbmRlZCB0byB3b3JrIGhpZXJhcmNoaWNhbGx5IHRvIGNvbmZpZ3VyZSBvdGhlciBlbGVtZW50cy5cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICB2YXIgT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9vcHRpb25zID0ge307XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0geyBcIipcIjogW10gfTtcclxuICAgIH07XHJcblxyXG4gICAgT3B0aW9ucy5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChrZXksIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3B0aW9uIGFscmVhZHkgcmVnaXN0ZXJlZCAnXCIgKyBrZXkgKyBcIidcIik7XHJcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnNba2V5XSA9IHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZTogZGVmYXVsdFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlc2V0VmFsdWU6IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvbmZpZ3VyYXRpb24ga2V5ICdcIiArIGtleSArIFwiJ1wiKTtcclxuICAgICAgICAgICAgdGhpcy5fb3B0aW9uc1trZXldLmN1cnJlbnRWYWx1ZSA9IHRoaXMuX29wdGlvbnNba2V5XS5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMubm90aWZ5T2JzZXJ2ZXJzKGtleSwgdGhpcy5fb3B0aW9uc1trZXldLmN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvbmZpZ3VyYXRpb24ga2V5ICdcIiArIGtleSArIFwiJ1wiKTtcclxuICAgICAgICAgICAgdGhpcy5fb3B0aW9uc1trZXldLmN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLm5vdGlmeU9ic2VydmVycyhrZXksIHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvbmZpZ3VyYXRpb24ga2V5ICdcIiArIGtleSArIFwiJ1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9uc1trZXldLmN1cnJlbnRWYWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldEtleXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX29wdGlvbnMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbm90aWZ5T2JzZXJ2ZXJzOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAvLyBOb3RpZnkgc3BlY2lmaWMgb2JzZXJ2ZXJzXHJcbiAgICAgICAgICAgIGlmKHRoaXMuX2xpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNba2V5XS5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcclxuICAgICAgICAgICAgICAgICAgIGwoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBOb3RpZnkgZ2VuZXJpYyBvYnNlcnZlcnNcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW1wiKlwiXS5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcclxuICAgICAgICAgICAgICAgbChrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRPYnNlcnZlcjogZnVuY3Rpb24gKGtleSwgb2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgaWYodHlwZW9mIGtleSA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBvYnNlcnZlciA9IGtleTtcclxuICAgICAgICAgICAgICAgIGtleSA9IFwiKlwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIXRoaXMuX29wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBrZXkgIT09IFwiKlwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCByZWdpc3RlciB0byB1bmtub3duIG9wdGlvbiAnXCIgKyBrZXkgKyBcIidcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIXRoaXMuX2xpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNba2V5XSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1trZXldLnB1c2gob2JzZXJ2ZXIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlT2JzZXJ2ZXI6IGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgICAgICBmb3IodmFyIGZpbHRlciBpbiB0aGlzLl9saXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZmlsdGVyXTtcclxuICAgICAgICAgICAgICAgIHZhciBpZHggPSBsaXN0ZW5lcnMuaW5kZXhPZihvYnNlcnZlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWR4ICE9IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBHbG9iYWxPcHRpb25zID0gbmV3IE9wdGlvbnMoKTtcclxuXHJcbiAgICBHbG9iYWxPcHRpb25zLnNldE9wdGlvbnNGcm9tUXVlcnkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHAgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cigxKS5zcGxpdCgnJicpO1xyXG5cclxuICAgICAgICBwLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdmFyIGtleVZhbCA9IGUuc3BsaXQoJz0nKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlWYWxbMF0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZihcInhtbDNkLVwiKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChrZXlWYWxbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gSlNPTi5wYXJzZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIFhNTDNELm9wdGlvbnMuc2V0VmFsdWUoa2V5LnN1YnN0cig2KSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1ZyAmJiBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBucy5leHBvcnRzID0gR2xvYmFsT3B0aW9ucztcclxuXHJcbn0obW9kdWxlKSk7XHJcbiIsIihmdW5jdGlvbihleHBvcnRzKSB7XHJcbiAgICAvKipcclxuICAgICAqIENsYXNzIFVSSVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBVUkkgYXMgc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIHZhciBVUkkgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgc3RyID0gc3RyIHx8IFwiXCI7XHJcbiAgICAgICAgaWYgKHN0ci5pbmRleE9mKFwiYmxvYjpcIikgPT0gMCkge1xyXG4gICAgICAgICAgICAvLyBCYXNlZCBvbiBodHRwOi8vd3d3LnczLm9yZy9UUi9GaWxlQVBJLyN1cmxcclxuICAgICAgICAgICAgdmFyIHBhcnNlciA9IC9eKD86KFteOlxcLz9cXCNdKyk6KT8oW15cXCNdKikoPzpcXCMoLiopKT8vO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gc3RyLm1hdGNoKHBhcnNlcik7XHJcbiAgICAgICAgICAgIC8qKiAgQHR5cGUge2Jvb2xlYW59ICovXHJcbiAgICAgICAgICAgIHRoaXMudmFsaWQgPSByZXN1bHQgIT0gbnVsbDtcclxuICAgICAgICAgICAgLyoqICBAdHlwZSB7P3N0cmluZ30gKi9cclxuICAgICAgICAgICAgdGhpcy5zY2hlbWUgPSByZXN1bHRbMV0gfHwgbnVsbDtcclxuICAgICAgICAgICAgLyoqICBAdHlwZSB7P3N0cmluZ30gKi9cclxuICAgICAgICAgICAgdGhpcy5hdXRob3JpdHkgPSBudWxsO1xyXG4gICAgICAgICAgICAvKiogIEB0eXBlIHs/c3RyaW5nfSAqL1xyXG4gICAgICAgICAgICB0aGlzLnBhdGggPSBudWxsO1xyXG4gICAgICAgICAgICAvKiogIEB0eXBlIHs/c3RyaW5nfSAqL1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqICBAdHlwZSB7P3N0cmluZ30gKi9cclxuICAgICAgICAgICAgdGhpcy5vcGFxdWVTdHJpbmcgPSByZXN1bHRbMl0gfHwgbnVsbDtcclxuICAgICAgICAgICAgLyoqICBAdHlwZSB7P3N0cmluZ30gKi9cclxuICAgICAgICAgICAgdGhpcy5mcmFnbWVudCA9IHJlc3VsdFszXSB8fCBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEJhc2VkIG9uIHRoZSByZWdleCBpbiBSRkMyMzk2IEFwcGVuZGl4IEIuXHJcbiAgICAgICAgICAgIHZhciBwYXJzZXIgPSAvXig/OihbXjpcXC8/XFwjXSspOik/KD86XFwvXFwvKFteXFwvP1xcI10qKSk/KFteP1xcI10qKSg/OlxcPyhbXlxcI10qKSk/KD86XFwjKC4qKSk/LztcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHN0ci5tYXRjaChwYXJzZXIpO1xyXG4gICAgICAgICAgICAvKiogIEB0eXBlIHtib29sZWFufSAqL1xyXG4gICAgICAgICAgICB0aGlzLnZhbGlkID0gcmVzdWx0ICE9IG51bGw7XHJcbiAgICAgICAgICAgIC8qKiAgQHR5cGUgez9zdHJpbmd9ICovXHJcbiAgICAgICAgICAgIHRoaXMuc2NoZW1lID0gcmVzdWx0WzFdIHx8IG51bGw7XHJcbiAgICAgICAgICAgIC8qKiAgQHR5cGUgez9zdHJpbmd9ICovXHJcbiAgICAgICAgICAgIHRoaXMuYXV0aG9yaXR5ID0gcmVzdWx0WzJdIHx8IG51bGw7XHJcbiAgICAgICAgICAgIC8qKiAgQHR5cGUgez9zdHJpbmd9ICovXHJcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IHJlc3VsdFszXSB8fCBudWxsO1xyXG4gICAgICAgICAgICAvKiogIEB0eXBlIHs/c3RyaW5nfSAqL1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcmVzdWx0WzRdIHx8IG51bGw7XHJcbiAgICAgICAgICAgIC8qKiAgQHR5cGUgez9zdHJpbmd9ICovXHJcbiAgICAgICAgICAgIHRoaXMub3BhcXVlU3RyaW5nID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqICBAdHlwZSB7P3N0cmluZ30gKi9cclxuICAgICAgICAgICAgdGhpcy5mcmFnbWVudCA9IHJlc3VsdFs1XSB8fCBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIFVSSSBpcyByZWxhdGl2ZSB0byBjdXJyZW50IGRvY3VtZW50XHJcbiAgICAgKi9cclxuICAgIFVSSS5wcm90b3R5cGUuaXNMb2NhbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWUgIT0gXCJibG9iXCIgJiYgIXRoaXMuYXV0aG9yaXR5ICYmICF0aGlzLnBhdGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIFVSSSBpcyBhYnNvbHV0ZVxyXG4gICAgICovXHJcbiAgICBVUkkucHJvdG90eXBlLmlzQWJzb2x1dGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1lICE9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWJzb2x1dGUgVVJJIHJlbGF0aXZlIHRvIHRoZSBwcm92aWRlZCBkb2N1bWVudCB1cmlcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkb2NVcmkgdXJpIG9mIGRvY3VtZW50IGZyb20gd2hpY2ggdGhpcyB1cmkgb3JpZ2luYXRlc1xyXG4gICAgICogQHJldHVybnMge1VSSX1cclxuICAgICAqL1xyXG4gICAgVVJJLnByb3RvdHlwZS5nZXRBYnNvbHV0ZVVSSSA9IGZ1bmN0aW9uIChkb2NVcmkpIHtcclxuICAgICAgICBpZiAoIXRoaXMudmFsaWQgfHwgdGhpcy5pc0Fic29sdXRlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZG9jVXJpT2JqID0gbmV3IFVSSShkb2NVcmkpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5wYXRoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhdGguaW5kZXhPZihcIi9cIikgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgZG9jVXJpT2JqLnBhdGggPSB0aGlzLnBhdGg7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb2NVcmlPYmoucGF0aCA9IGRvY1VyaU9iai5wYXRoLnN1YnN0cigwLCBkb2NVcmlPYmoucGF0aC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKSArIHRoaXMucGF0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkb2NVcmlPYmoucXVlcnkgPSB0aGlzLnF1ZXJ5O1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5xdWVyeSkge1xyXG4gICAgICAgICAgICBkb2NVcmlPYmoucXVlcnkgPSB0aGlzLnF1ZXJ5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBkb2NVcmlPYmouZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50O1xyXG5cclxuICAgICAgICByZXR1cm4gZG9jVXJpT2JqO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpZiB0aGlzIFVSSSBoYXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBwcm92aWRlZCByZWZlcmVuY2VcclxuICAgICAqIEBwYXJhbSB7VVJJfHN0cmluZ30gb3RoZXJcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBVUkkucHJvdG90eXBlLmhhc1NhbWVPcmlnaW4gPSBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG90aGVyID09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICBvdGhlciA9IG5ldyBVUkkob3RoZXIpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5zY2hlbWUgPT0gXCJibG9iXCIgfHwgdGhpcy5zY2hlbWUgPT0gXCJkYXRhXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWUgPT0gb3RoZXIuc2NoZW1lICYmIHRoaXMuYXV0aG9yaXR5ID09IG90aGVyLmF1dGhvcml0eTtcclxuICAgIH07XHJcblxyXG5cclxuLy8gUmVzdG9yZSB0aGUgVVJJIHRvIGl0J3Mgc3RyaW5neSBnbG9yeS5cclxuICAgIFVSSS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHN0ciA9IFwiXCI7XHJcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1lID09IFwiYmxvYlwiKSB7XHJcbiAgICAgICAgICAgIHN0ciA9IFwiYmxvYjpcIiArIHRoaXMub3BhcXVlU3RyaW5nO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5mcmFnbWVudCkge1xyXG4gICAgICAgICAgICAgICAgc3RyICs9IFwiI1wiICsgdGhpcy5mcmFnbWVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zY2hlbWUpIHtcclxuICAgICAgICAgICAgc3RyICs9IHRoaXMuc2NoZW1lICsgXCI6XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmF1dGhvcml0eSkge1xyXG4gICAgICAgICAgICBzdHIgKz0gXCIvL1wiICsgdGhpcy5hdXRob3JpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBhdGgpIHtcclxuICAgICAgICAgICAgc3RyICs9IHRoaXMucGF0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucXVlcnkpIHtcclxuICAgICAgICAgICAgc3RyICs9IFwiP1wiICsgdGhpcy5xdWVyeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgc3RyICs9IFwiI1wiICsgdGhpcy5mcmFnbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH07XHJcblxyXG4vLyBSZXN0b3JlIHRoZSBVUkkgdG8gaXQncyBzdHJpbmd5IGdsb3J5IG1pbnVzIHRoZSBmcmFnbWVudFxyXG4gICAgVVJJLnByb3RvdHlwZS50b1N0cmluZ1dpdGhvdXRGcmFnbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3RyID0gXCJcIjtcclxuICAgICAgICBpZiAodGhpcy5zY2hlbWUgPT0gXCJibG9iXCIpIHtcclxuICAgICAgICAgICAgc3RyID0gXCJibG9iOlwiICsgdGhpcy5vcGFxdWVTdHJpbmc7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNjaGVtZSkge1xyXG4gICAgICAgICAgICBzdHIgKz0gdGhpcy5zY2hlbWUgKyBcIjpcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuYXV0aG9yaXR5KSB7XHJcbiAgICAgICAgICAgIHN0ciArPSBcIi8vXCIgKyB0aGlzLmF1dGhvcml0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucGF0aCkge1xyXG4gICAgICAgICAgICBzdHIgKz0gdGhpcy5wYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5xdWVyeSkge1xyXG4gICAgICAgICAgICBzdHIgKz0gXCI/XCIgKyB0aGlzLnF1ZXJ5O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsYXNzIFVSSVJlc29sdmVyXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgdmFyIFVSSVJlc29sdmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc29sdmUgYSBsb2NhbCBVUkkgdG8gYW4gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfFVSSSl9IHVyaSBFbGVtZW50IHRvIHJlc29sdmVcclxuICAgICAqIEBwYXJhbSB7RG9jdW1lbnQ9fSBkb2N1bWVudCBCYXNlIGRvY3VtZW50IHRvIHVzZVxyXG4gICAgICogQHJldHVybiB7RWxlbWVudH0gVGhlIHJlc29sdmVkIGVsZW1lbnQgb3IgbnVsbCBpZiBpdCBjb3VsZCBub3QgYmUgcmVzb2x2ZWRcclxuICAgICAqL1xyXG4gICAgVVJJUmVzb2x2ZXIucmVzb2x2ZUxvY2FsID0gZnVuY3Rpb24gKHVyaSwgZG9jdW1lbnQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHVyaSA9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgdXJpID0gbmV3IFVSSSh1cmkpO1xyXG4gICAgICAgIGRvY3VtZW50ID0gZG9jdW1lbnQgfHwgd2luZG93LmRvY3VtZW50O1xyXG5cclxuICAgICAgICBpZiAodXJpLnNjaGVtZSA9PSAndXJuJyB8fCB1cmkuc2NoZW1lID09IFwiYmxvYlwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF1cmkucGF0aCAmJiB1cmkuZnJhZ21lbnQpIHsgLy8gbG9jYWwgdXJpXHJcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh1cmkuZnJhZ21lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgVVJJUmVzb2x2ZXIucmVzb2x2ZSA9IGZ1bmN0aW9uICh1cmksIGRvY3VtZW50KSB7XHJcbiAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIllvdSBhcmUgdXNpbmcgZGVwcmVjYXRlZCBYTUwzRC5VUklSZXNvbHZlci5yZXNvbHZlLiBVc2UgWE1MM0QuVVJJUmVzb2x2ZXIucmVzb2x2ZUxvY2FsIGluc3RlYWQuXCIpO1xyXG4gICAgICAgIHJldHVybiBVUklSZXNvbHZlci5yZXNvbHZlTG9jYWwodXJpLCBkb2N1bWVudCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMuVVJJID0gVVJJO1xyXG4gICAgZXhwb3J0cy5VUklSZXNvbHZlciA9IFVSSVJlc29sdmVyO1xyXG5cclxufShtb2R1bGUuZXhwb3J0cykpO1xyXG4iLCIvL1RPRE86IEhlbHBmdWwgQVBJIG1ldGhvZHMgY29uY2VybmluZyBXZWJDTCB3aWxsIGJlIGFkZGVkIHdoZW4gbmVlZGVkLiBQbGVhc2UgcHJvdmlkZSBmZWVkYmFjayFcclxuXHJcbi8qKlxyXG4gKiBAZmlsZSBXZWJDTCBBUEkuIFByb3ZpZGVzIHVzZWZ1bCBtZXRob2RzIGZvciBpbml0aWFsaXNpbmcgYW5kIHV0aWxpc2luZyB0aGUgV2ViQ0wgcGxhdGZvcm0uXHJcbiAqIEB2ZXJzaW9uIDAuMlxyXG4gKiBAYXV0aG9yIFRvbmkgRGFobFxyXG4gKi9cclxuXHJcbihmdW5jdGlvbiAobmFtZXNwYWNlLCB1bmRlZmluZWQpIHtcclxuXHJcbiAgICB2YXIgcGxhdGZvcm1zID0gW10sXHJcbiAgICAgICAgZGV2aWNlcyA9IFtdLFxyXG4gICAgICAgIGN0eCA9IG51bGwsXHJcblxyXG4gICAgICAgIFdlYkNMTmFtZXNwYWNlQXZhaWxhYmxlID0gZmFsc2UsXHJcbiAgICAgICAgT3BlbkNMRHJpdmVyc0F2YWlsYWJsZSA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogICAgIEBjb25zdGFudCB7c3RyaW5nfSBERUZBVUxUX0RFVklDRVxyXG4gICAgICogICAgIEBkZWZhdWx0IFwiQ1BVXCJcclxuICAgICAqL1xyXG4gICAgdmFyIERFRkFVTFRfREVWSUNFID0gXCJDUFVcIixcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogICAgIEByZWFkb25seVxyXG4gICAgICAgICAqICAgICBAbmFtZSBDTF9FUlJPUl9DT0RFU1xyXG4gICAgICAgICAqICAgICBAZW51bSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgICAgICBDTF9FUlJPUl9DT0RFUyA9IHtcclxuICAgICAgICAgICAgXCJTVUNDRVNTXCI6IDAsXHJcbiAgICAgICAgICAgIFwiREVWSUNFX05PVF9GT1VORFwiOiAtMSxcclxuICAgICAgICAgICAgXCJERVZJQ0VfTk9UX0FWQUlMQUJMRVwiOiAtMixcclxuICAgICAgICAgICAgXCJDT01QSUxFUl9OT1RfQVZBSUxBQkxFXCI6IC0zLFxyXG4gICAgICAgICAgICBcIk1FTV9PQkpFQ1RfQUxMT0NBVElPTl9GQUlMVVJFXCI6IC00LFxyXG4gICAgICAgICAgICBcIk9VVF9PRl9SRVNPVVJDRVNcIjogLTUsXHJcbiAgICAgICAgICAgIFwiT1VUX09GX0hPU1RfTUVNT1JZXCI6IC02LFxyXG4gICAgICAgICAgICBcIlBST0ZJTElOR19JTkZPX05PVF9BVkFJTEFCTEVcIjogLTcsXHJcbiAgICAgICAgICAgIFwiTUVNX0NPUFlfT1ZFUkxBUFwiOiAtOCxcclxuICAgICAgICAgICAgXCJJTUFHRV9GT1JNQVRfTUlTTUFUQ0hcIjogLTksXHJcbiAgICAgICAgICAgIFwiSU1BR0VfRk9STUFUX05PVF9TVVBQT1JURURcIjogLTEwLFxyXG4gICAgICAgICAgICBcIkJVSUxEX1BST0dSQU1fRkFJTFVSRVwiOiAtMTEsXHJcbiAgICAgICAgICAgIFwiTUFQX0ZBSUxVUkVcIjogLTEyLFxyXG4gICAgICAgICAgICBcIklOVkFMSURfVkFMVUVcIjogLTMwLFxyXG4gICAgICAgICAgICBcIklOVkFMSURfREVWSUNFX1RZUEVcIjogLTMxLFxyXG4gICAgICAgICAgICBcIklOVkFMSURfUExBVEZPUk1cIjogLTMyLFxyXG4gICAgICAgICAgICBcIklOVkFMSURfREVWSUNFXCI6IC0zMyxcclxuICAgICAgICAgICAgXCJJTlZBTElEX0NPTlRFWFRcIjogLTM0LFxyXG4gICAgICAgICAgICBcIklOVkFMSURfUVVFVUVfUFJPUEVSVElFU1wiOiAtMzUsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9DT01NQU5EX1FVRVVFXCI6IC0zNixcclxuICAgICAgICAgICAgXCJJTlZBTElEX0hPU1RfUFRSXCI6IC0zNyxcclxuICAgICAgICAgICAgXCJJTlZBTElEX01FTV9PQkpFQ1RcIjogLTM4LFxyXG4gICAgICAgICAgICBcIklOVkFMSURfSU1BR0VfRk9STUFUX0RFU0NSSVBUT1JcIjogLTM5LFxyXG4gICAgICAgICAgICBcIklOVkFMSURfSU1BR0VfU0laRVwiOiAtNDAsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9TQU1QTEVSXCI6IC00MSxcclxuICAgICAgICAgICAgXCJJTlZBTElEX0JJTkFSWVwiOiAtNDIsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9CVUlMRF9PUFRJT05TXCI6IC00MyxcclxuICAgICAgICAgICAgXCJJTlZBTElEX1BST0dSQU1cIjogLTQ0LFxyXG4gICAgICAgICAgICBcIklOVkFMSURfUFJPR1JBTV9FWEVDVVRBQkxFXCI6IC00NSxcclxuICAgICAgICAgICAgXCJJTlZBTElEX0tFUk5FTF9OQU1FXCI6IC00NixcclxuICAgICAgICAgICAgXCJJTlZBTElEX0tFUk5FTF9ERUZJTklUSU9OXCI6IC00NyxcclxuICAgICAgICAgICAgXCJJTlZBTElEX0tFUk5FTFwiOiAtNDgsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9BUkdfSU5ERVhcIjogLTQ5LFxyXG4gICAgICAgICAgICBcIklOVkFMSURfQVJHX1ZBTFVFXCI6IC01MCxcclxuICAgICAgICAgICAgXCJJTlZBTElEX0FSR19TSVpFXCI6IC01MSxcclxuICAgICAgICAgICAgXCJJTlZBTElEX0tFUk5FTF9BUkdTXCI6IC01MixcclxuICAgICAgICAgICAgXCJJTlZBTElEX1dPUktfRElNRU5TSU9OXCI6IC01MyxcclxuICAgICAgICAgICAgXCJJTlZBTElEX1dPUktfR1JPVVBfU0laRVwiOiAtNTQsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9XT1JLX0lURU1fU0laRVwiOiAtNTUsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9HTE9CQUxfT0ZGU0VUXCI6IC01NixcclxuICAgICAgICAgICAgXCJJTlZBTElEX0VWRU5UX1dBSVRfTElTVFwiOiAtNTcsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9FVkVOVFwiOiAtNTgsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9PUEVSQVRJT05cIjogLTU5LFxyXG4gICAgICAgICAgICBcIklOVkFMSURfR0xfT0JKRUNUXCI6IC02MCxcclxuICAgICAgICAgICAgXCJJTlZBTElEX0JVRkZFUl9TSVpFXCI6IC02MSxcclxuICAgICAgICAgICAgXCJJTlZBTElEX01JUF9MRVZFTFwiOiAtNjIsXHJcbiAgICAgICAgICAgIFwiSU5WQUxJRF9HTE9CQUxfV09SS19TSVpFXCI6IC02M1xyXG4gICAgICAgIH07XHJcbiAgICBPYmplY3QuZnJlZXplKENMX0VSUk9SX0NPREVTKTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIobikge1xyXG4gICAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgQ0wgZXJyb3IgbmFtZSBjb3JyZXNwb25kaW5nIHRvIGEgQ0wgZXJyb3IgY29kZVxyXG4gICAgICpcclxuICAgICAqIEBmdW5jdGlvbiBYTUwzRC53ZWJjbH5nZXRDTEVycm9yTmFtZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVycm9yQ29kZVxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqL1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldENMRXJyb3JOYW1lKGVycm9yQ29kZSkge1xyXG4gICAgICAgIHZhciBwcm9wO1xyXG5cclxuICAgICAgICBpZiAoaXNOdW1iZXIoZXJyb3JDb2RlKSkge1xyXG4gICAgICAgICAgICBmb3IgKHByb3AgaW4gQ0xfRVJST1JfQ09ERVMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChDTF9FUlJPUl9DT0RFU1twcm9wXSA9PT0gZXJyb3JDb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJHb3QgdW5rbm93biBPcGVuQ0wgRXJyb3IgQ29kZTpcIiwgZXJyb3JDb2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBcIlVOS05PV05fRVJST1JcIjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYW4gZXJyb3IgY29kZSBmcm9tIGEgQ0wgZXJyb3IgbWVzc2FnZSAodGhyb3duIGJ5IE5va2lhIFdlYkNMIFBsdWdpbilcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZVxyXG4gICAgICogQHJldHVybnMge0ludGVnZXJ8Qm9vbGVhbn1cclxuICAgICAqL1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldEVycm9yQ29kZUZyb21DTEVycm9yKGUpIHtcclxuICAgICAgICB2YXIgY29kZSA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChlLm5hbWUgJiYgdHlwZW9mIGUubmFtZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBpZiAoQ0xfRVJST1JfQ09ERVNbZS5uYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENMX0VSUk9SX0NPREVTW2UubmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGUubWVzc2FnZSAmJiB0eXBlb2YgZS5tZXNzYWdlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIGNvZGUgPSBlLm1lc3NhZ2UubWF0Y2goLy0/XFxkKy9nKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb2RlIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChjb2RlW2NvZGUubGVuZ3RoIC0gMV0sIDEwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBpbnN0YW5jZSBvZiBXZWJDTEVycm9yXHJcbiAgICAgKlxyXG4gICAgICogQGNvbnN0cnVjdG9yIFhNTDNELndlYmNsfldlYkNMRXJyb3JcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZT1cIldlYkNMRXJyb3JcIl0gRXJyb3IgbmFtZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttc2c9XCJHZW5lcmljIFdlYkNMIGVycm9yLlwiXSBUaGUgZGVzaXJlZCBlcnJvciBtZXNzYWdlXHJcbiAgICAgKi9cclxuXHJcbiAgICBmdW5jdGlvbiBXZWJDTEVycm9yKG5hbWUsIG1zZykge1xyXG4gICAgICAgIGlmIChuYW1lICYmIHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKFwiV2ViQ0wgQVBJOiBXZWJDTEVycm9yOiBFcnJvciBuYW1lIG5vdCB0eXBlIG9mIFN0cmluZ1wiKTtcclxuICAgICAgICAgICAgbmFtZSA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobXNnICYmIHR5cGVvZiBtc2cgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJXZWJDTCBBUEk6IFdlYkNMRXJyb3I6IEVycm9yIG1lc3NhZ2Ugbm90IHR5cGUgb2YgU3RyaW5nXCIpO1xyXG4gICAgICAgICAgICBtc2cgPSBcIlwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZSB8fCBcIldlYkNMRXJyb3JcIjtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtc2cgfHwgXCJHZW5lcmljIFdlYkNMIGVycm9yLlwiO1xyXG4gICAgICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xyXG4gICAgfVxyXG5cclxuICAgIFdlYkNMRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xyXG4gICAgV2ViQ0xFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXZWJDTEVycm9yO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBXZWJDTCBuYW1lc3BhY2UgaXMgYXZhaWxhYmxlLiBUaGUgbmFtZXNwYWNlIGNhbiBiZSBwcm92aWRlZCBieSBhIFdlYkNMIHBsdWdpbiBvciBuYXRpdmUgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQGZ1bmN0aW9uIFhNTDNELndlYmNsfmhhc1dlYkNMTmFtZXNwYWNlXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG5cclxuICAgIGZ1bmN0aW9uIGhhc1dlYkNMTmFtZXNwYWNlKCkge1xyXG4gICAgICAgIFdlYkNMTmFtZXNwYWNlQXZhaWxhYmxlID0gd2luZG93LndlYmNsICYmIHdlYmNsLmdldFBsYXRmb3JtcztcclxuXHJcbiAgICAgICAgcmV0dXJuIFdlYkNMTmFtZXNwYWNlQXZhaWxhYmxlO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGEgYmFzaWMgV2ViQ0wgbWV0aG9kIHRvIHNlZSBpZiB0aGUgT3BlbkNMIGRyaXZlcnMgYXJlIHdvcmtpbmcgb24gdXNlcnMgZGV2aWNlLlxyXG4gICAgICpcclxuICAgICAqIEBmdW5jdGlvbiBYTUwzRC53ZWJjbH5oYXNPcGVuQ0xEcml2ZXJzXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG5cclxuICAgIGZ1bmN0aW9uIGhhc09wZW5DTERyaXZlcnMoKSB7XHJcbiAgICAgICAgdmFyIHBsYXRBcnI7XHJcbiAgICAgICAgT3BlbkNMRHJpdmVyc0F2YWlsYWJsZSA9IHRydWU7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHBsYXRBcnIgPSB3ZWJjbC5nZXRQbGF0Zm9ybXMoKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIE9wZW5DTERyaXZlcnNBdmFpbGFibGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghcGxhdEFyciB8fCBwbGF0QXJyLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBPcGVuQ0xEcml2ZXJzQXZhaWxhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gT3BlbkNMRHJpdmVyc0F2YWlsYWJsZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21iaW5lcyBXZWJDTCBuYW1lc3BhY2UgYW5kIGRyaXZlciB0ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEBmdW5jdGlvbiBYTUwzRC53ZWJjbH5pc0F2YWlsYWJsZVxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuXHJcbiAgICBmdW5jdGlvbiBpc0F2YWlsYWJsZSgpIHtcclxuICAgICAgICByZXR1cm4gaGFzV2ViQ0xOYW1lc3BhY2UoKSAmJiBoYXNPcGVuQ0xEcml2ZXJzKCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGlzZXMgdGhlIFdlYkNMIEFQSSB3aXRoIGRlZmF1bHQgdmFsdWVzIHVzaW5nIGEgcHJlZGVmaW5lZCBkZXZpY2UgdHlwZSBvciBhIGRlZmF1bHQgZGV2aWNlIHR5cGUuXHJcbiAgICAgKlxyXG4gICAgICogQGZ1bmN0aW9uIFhNTDNELndlYmNsfmluaXRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZT1cIkNQVVwiXSBEZXZpY2UgdHlwZVxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG5cclxuICAgIGZ1bmN0aW9uIGluaXQodHlwZSkge1xyXG4gICAgICAgIC8vIENoZWNraW5nIGlmIFdlYkNMIGlzIGF2YWlsYWJsZSBpbiB0aGUgdXNlcnMgc3lzdGVtXHJcbiAgICAgICAgaWYgKCFoYXNXZWJDTE5hbWVzcGFjZSgpKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJXZWJDTCBBUEk6IFVuZm9ydHVuYXRlbHkgeW91ciBzeXN0ZW0gZG9lcyBub3Qgc3VwcG9ydCBXZWJDTC4gXCIgK1xyXG4gICAgICAgICAgICAgICAgXCJXZWJDTCBuYW1lc3BhY2UgaXMgbm90IGF2YWlsYWJsZS5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaGFzT3BlbkNMRHJpdmVycygpKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJXZWJDTCBBUEk6IFVuZm9ydHVuYXRlbHkgeW91ciBzeXN0ZW0gZG9lcyBub3Qgc3VwcG9ydCBXZWJDTC4gXCIgK1xyXG4gICAgICAgICAgICAgICAgXCJPcGVuQ0wgZHJpdmVycyBhcmUgbm90IHdvcmtpbmcgcHJvcGVybHkuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnZXRQbGF0Zm9ybXMoKTtcclxuXHJcbiAgICAgICAgZGV2aWNlcyA9IGdldERldmljZXNCeVR5cGUodHlwZSB8fCBERUZBVUxUX0RFVklDRSk7XHJcblxyXG4gICAgICAgIC8vIENyZWF0aW5nIGRlZmF1bHQgY29udGV4dFxyXG4gICAgICAgIGN0eCA9IGNyZWF0ZUNvbnRleHQoZGV2aWNlcyk7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgYXZhaWxhYmxlIFdlYkNMIGRldmljZSBwbGF0Zm9ybXMuXHJcbiAgICAgKlxyXG4gICAgICogQGZ1bmN0aW9uIFhNTDNELndlYmNsfmdldFBsYXRmb3Jtc1xyXG4gICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICovXHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0UGxhdGZvcm1zKCkge1xyXG4gICAgICAgIGlmKHBsYXRmb3Jtcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcGxhdGZvcm1zID0gd2ViY2wuZ2V0UGxhdGZvcm1zKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcGxhdGZvcm1zO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgZGV2aWNlcyBvZiBhIGNob3NlbiB0eXBlIGZyb20gYSBzZWxlY3RlZCBwbGF0Zm9ybS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGU9XCJDUFVcIl0gRGV2aWNlIHR5cGVcclxuICAgICAqIEBwYXJhbSB7SVdlYkNMUGxhdGZvcm19IHBsYXRmb3JtXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8Qm9vbGVhbn1cclxuICAgICAqL1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldFBsYXRmb3JtRGV2aWNlc0J5VHlwZSh0eXBlLCBwbGF0Zm9ybSkge1xyXG4gICAgICAgIHZhciBkZXZpY2VBcnIgPSBbXSwgZXJyQ29kZTtcclxuXHJcbiAgICAgICAgaWYgKCFwbGF0Zm9ybSkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIldlYkNMIEFQSTogZ2V0UGxhdGZvcm1EZXZpY2VzQnlUeXBlKCk6IHBsYXRmb3JtIHdhcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHR5cGUgPSB0eXBlIHx8IERFRkFVTFRfREVWSUNFO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJDUFVcIikge1xyXG4gICAgICAgICAgICAgICAgZGV2aWNlQXJyID0gcGxhdGZvcm0uZ2V0RGV2aWNlcyh3ZWJjbC5ERVZJQ0VfVFlQRV9DUFUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiR1BVXCIpIHtcclxuICAgICAgICAgICAgICAgIGRldmljZUFyciA9IHBsYXRmb3JtLmdldERldmljZXMod2ViY2wuREVWSUNFX1RZUEVfR1BVKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIkFMTFwiKSB7XHJcbiAgICAgICAgICAgICAgICBkZXZpY2VBcnIgPSBwbGF0Zm9ybS5nZXREZXZpY2VzKHdlYmNsLkRFVklDRV9UWVBFX0FMTCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBlcnJDb2RlID0gZ2V0RXJyb3JDb2RlRnJvbUNMRXJyb3IoZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWVyckNvZGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyQ29kZSAhPT0gQ0xfRVJST1JfQ09ERVMuREVWSUNFX05PVF9GT1VORCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdlYkNMRXJyb3IoZ2V0Q0xFcnJvck5hbWUoZXJyQ29kZSksIFwiQ291bGQgbm90IGdldCBkZXZpY2VzLlwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRldmljZUFycjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYWxsIGRldmljZXMgb2YgYSBzZWxlY3RlZCB0eXBlIGZyb20gYWxsIGF2YWlsYWJsZSBwbGF0Zm9ybXMuXHJcbiAgICAgKlxyXG4gICAgICogQGZ1bmN0aW9uIFhNTDNELndlYmNsfmdldERldmljZXNCeVR5cGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIERldmljZSB0eXBlXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8Qm9vbGVhbn1cclxuICAgICAqL1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldERldmljZXNCeVR5cGUodHlwZSkge1xyXG4gICAgICAgIHZhciByZXN1bHRBcnIgPSBbXSwgZGV2aWNlQXJyLCBpO1xyXG5cclxuICAgICAgICBnZXRQbGF0Zm9ybXMoKTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gcGxhdGZvcm1zLmxlbmd0aDsgaS0tOykge1xyXG4gICAgICAgICAgICBkZXZpY2VBcnIgPSBnZXRQbGF0Zm9ybURldmljZXNCeVR5cGUodHlwZSwgcGxhdGZvcm1zW2ldKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkZXZpY2VBcnIpIHtcclxuICAgICAgICAgICAgICAgIGRldmljZUFyci5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0QXJyLnB1c2godik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0QXJyLmxlbmd0aCA9PT0gMCA/IGZhbHNlIDogcmVzdWx0QXJyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHBsYXRmb3JtIG9uIHdoZXJlIHRoZSBkZXZpY2UgaXMuXHJcbiAgICAgKlxyXG4gICAgICogQGZ1bmN0aW9uIFhNTDNELndlYmNsfmdldERldmljZVBsYXRmb3JtXHJcbiAgICAgKiBAcGFyYW0ge0lXZWJDTERldmljZX0gZGV2aWNlXHJcbiAgICAgKiBAcmV0dXJucyB7SVdlYkNMUGxhdGZvcm18Qm9vbGVhbn1cclxuICAgICAqL1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldERldmljZVBsYXRmb3JtKGRldmljZSkge1xyXG4gICAgICAgIHZhciBwbGF0Zm9ybTtcclxuXHJcbiAgICAgICAgaWYgKCFkZXZpY2UpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJXZWJDTCBBUEk6IGdldERldmljZVBsYXRmb3JtKCk6IGRldmljZSB3YXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBwbGF0Zm9ybSA9IGRldmljZS5nZXRJbmZvKHdlYmNsLkRFVklDRV9QTEFURk9STSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB2YXIgZXJyQ29kZSA9IGdldEVycm9yQ29kZUZyb21DTEVycm9yKGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFlcnJDb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2ViQ0xFcnJvcihnZXRDTEVycm9yTmFtZShlcnJDb2RlKSwgXCJDb3VsZCBub3QgZ2V0IHRoZSBwbGF0Zm9ybSBvZiB0aGUgZGV2aWNlLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwbGF0Zm9ybTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2xDdHhcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q29udGV4dERldmljZXMoY2xDdHgpIHtcclxuICAgICAgICB2YXIgZGV2aWNlQXJyID0gW10sIGVyckNvZGU7XHJcblxyXG4gICAgICAgIGlmKCFjbEN0eCkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIldlYkNMIEFQSTogZ2V0Q29udGV4dERldmljZXMoKTogY2xDdHggd2FzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZGV2aWNlQXJyID0gY2xDdHguZ2V0SW5mbyh3ZWJjbC5DT05URVhUX0RFVklDRVMpO1xyXG4gICAgICAgIH1jYXRjaChlKSB7XHJcbiAgICAgICAgICAgIGVyckNvZGUgPSBnZXRFcnJvckNvZGVGcm9tQ0xFcnJvcihlKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghZXJyQ29kZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXZWJDTEVycm9yKGdldENMRXJyb3JOYW1lKGVyckNvZGUpLCBcIkNvdWxkIG5vdCBnZXQgZGV2aWNlcy5cIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGV2aWNlQXJyLmxlbmd0aCA9PT0gMCA/IGZhbHNlIDogZGV2aWNlQXJyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIFdlYkNMIGNvbnRleHRcclxuICAgICAqXHJcbiAgICAgKiBAZnVuY3Rpb24gWE1MM0Qud2ViY2x+Y3JlYXRlQ29udGV4dFxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtwcm9wZXJ0aWVzXVxyXG4gICAgICogQHJldHVybnMge0lXZWJDTENvbnRleHR9XHJcbiAgICAgKi9cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KHByb3BlcnRpZXMpIHtcclxuICAgICAgLypcclxuICAgICAgICB2YXIgcHJvcHMgPSB7XHJcbiAgICAgICAgICAgIGRldmljZXM6IGdldERldmljZXNCeVR5cGUoREVGQVVMVF9ERVZJQ0UpXHJcbiAgICAgICAgICAgIH0sIGNvbnRleHQ7XHJcblxyXG4gICAgICAgIFhNTDNELmV4dGVuZChwcm9wcywgcHJvcGVydGllcyk7Ki9cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB3ZWJjbC5jcmVhdGVDb250ZXh0KHByb3BlcnRpZXMpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdmFyIGVyckNvZGUgPSBnZXRFcnJvckNvZGVGcm9tQ0xFcnJvcihlKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghZXJyQ29kZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2ViQ0xFcnJvcihnZXRDTEVycm9yTmFtZShlcnJDb2RlKSwgXCJGYWlsZWQgdG8gY3JlYXRlIGEgV2ViQ0wgY29udGV4dC5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY29udGV4dDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGRlZmF1bHQgV2ViQ0wgY29udGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAZnVuY3Rpb24gWE1MM0Qud2ViY2x+Z2V0RGVmYXVsdENvbnRleHRcclxuICAgICAqIEByZXR1cm5zIHtJV2ViQ0xDb250ZXh0fVxyXG4gICAgICovXHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0RGVmYXVsdENvbnRleHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIGN0eDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgV2ViQ0wgcHJvZ3JhbSBmcm9tIGEgc3RyaW5nIG9mIFdlYkNMIGNvZGUuXHJcbiAgICAgKlxyXG4gICAgICogQGZ1bmN0aW9uIFhNTDNELndlYmNsfmNyZWF0ZVByb2dyYW1cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlU3RyXHJcbiAgICAgKiBAcGFyYW0ge0lXZWJDTENvbnRleHR9IGNsQ3R4XHJcbiAgICAgKiBAcmV0dXJucyB7SVdlYkNMUHJvZ3JhbSB8IEJvb2xlYW59XHJcbiAgICAgKi9cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9ncmFtKGNvZGVTdHIsIGNsQ3R4KSB7XHJcbiAgICAgICAgdmFyIHByb2dyYW07XHJcblxyXG4gICAgICAgIGNsQ3R4ID0gY2xDdHggfHwgY3R4O1xyXG5cclxuICAgICAgICBpZiAoIWNvZGVTdHIpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJXZWJDTCBBUEk6IGNyZWF0ZVByb2dyYW0oKTogY29kZVN0ciB3YXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWNsQ3R4KSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiV2ViQ0wgQVBJOiBjcmVhdGVQcm9ncmFtKCk6IGNsQ3R4IHdhcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHByb2dyYW0gPSBjbEN0eC5jcmVhdGVQcm9ncmFtKGNvZGVTdHIpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdmFyIGVyckNvZGUgPSBnZXRFcnJvckNvZGVGcm9tQ0xFcnJvcihlKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghZXJyQ29kZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhyb3cgbmV3IFdlYkNMRXJyb3IoZ2V0Q0xFcnJvck5hbWUoZXJyQ29kZSksIFwiRmFpbGVkIHRvIGNyZWF0ZSBhIFdlYkNMIHByb2dyYW0uXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHByb2dyYW07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgYSBXZWJDTCBwcm9ncmFtLlxyXG4gICAgICpcclxuICAgICAqIEBmdW5jdGlvbiBYTUwzRC53ZWJjbH5idWlsZFByb2dyYW1cclxuICAgICAqIEBwYXJhbSB7SVdlYkNMUHJvZ3JhbX0gcHJvZ3JhbVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGV2aWNlQXJyXHJcbiAgICAgKiBAcmV0dXJucyB7SVdlYkNMUHJvZ3JhbXxCb29sZWFufVxyXG4gICAgICovXHJcblxyXG4gICAgZnVuY3Rpb24gYnVpbGRQcm9ncmFtKHByb2dyYW0sIGRldmljZUFycikge1xyXG4gICAgICAgIGRldmljZUFyciA9IGRldmljZUFyciB8fCBkZXZpY2VzO1xyXG5cclxuICAgICAgICBpZiAoIXByb2dyYW0pIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJXZWJDTCBBUEk6IGJ1aWxkUHJvZ3JhbSgpOiBwcm9ncmFtIHdhcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHByb2dyYW0uYnVpbGQoZGV2aWNlQXJyLCBcIlwiKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHZhciBlcnJDb2RlID0gZ2V0RXJyb3JDb2RlRnJvbUNMRXJyb3IoZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWVyckNvZGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IFdlYkNMRXJyb3IoZ2V0Q0xFcnJvck5hbWUoZXJyQ29kZSksXHJcbiAgICAgICAgICAgICAgICBwcm9ncmFtLmdldEJ1aWxkSW5mbyhkZXZpY2VBcnJbMF0sIFdlYkNMLlBST0dSQU1fQlVJTERfTE9HKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBXZWJDTCBLZXJuZWwgdXNpbmcgYSBkZWZpbmVkIHByb2dyYW0uXHJcbiAgICAgKlxyXG4gICAgICogQGZ1bmN0aW9uIFhNTDNELndlYmNsfmNyZWF0ZUtlcm5lbFxyXG4gICAgICogQHBhcmFtIHtJV2ViQ0xQcm9ncmFtfSBwcm9ncmFtXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gICAgICogQHJldHVybnMge0lXZWJDTEtlcm5lbHxCb29sZWFufVxyXG4gICAgICovXHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlS2VybmVsKHByb2dyYW0sIG5hbWUpIHtcclxuICAgICAgICB2YXIga2VybmVsO1xyXG5cclxuICAgICAgICBpZiAoIXByb2dyYW0pIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJXZWJDTCBBUEk6IGNyZWF0ZUtlcm5lbCgpOiBwcm9ncmFtIHdhcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghbmFtZSkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIldlYkNMIEFQSTogY3JlYXRlS2VybmVsKCk6IG5hbWUgd2FzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAga2VybmVsID0gcHJvZ3JhbS5jcmVhdGVLZXJuZWwobmFtZSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB2YXIgZXJyQ29kZSA9IGdldEVycm9yQ29kZUZyb21DTEVycm9yKGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFlcnJDb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBXZWJDTEVycm9yKGdldENMRXJyb3JOYW1lKGVyckNvZGUpLCBcIkZhaWxlZCB0byBjcmVhdGUgYSBXZWJDTCBrZXJuZWwuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGtlcm5lbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBXZWJDTCBDb21tYW5kIFF1ZXVlIGZvciBxdWV1ZWluZyBrZXJuZWxzIGZvciBleGVjdXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQGZ1bmN0aW9uIFhNTDNELndlYmNsfmNyZWF0ZUNvbW1hbmRRdWV1ZVxyXG4gICAgICogQHBhcmFtIHtJV2ViQ0xEZXZpY2V9IGRldmljZVxyXG4gICAgICogQHBhcmFtIHtJV2ViQ0xDb250ZXh0fSBjbEN0eFxyXG4gICAgICogQHJldHVybnMge0lXZWJDTENvbW1hbmRRdWV1ZXxCb29sZWFufVxyXG4gICAgICovXHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tbWFuZFF1ZXVlKGRldmljZSwgY2xDdHgpIHtcclxuICAgICAgICB2YXIgY21kUXVldWU7XHJcblxyXG4gICAgICAgIGNsQ3R4ID0gY2xDdHggfHwgY3R4O1xyXG5cclxuICAgICAgICBpZighY2xDdHgpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJXZWJDTCBBUEk6IGNyZWF0ZUNvbW1hbmRRdWV1ZTogY2xDdHggd2FzIG5vdCBkZWZpbmVkXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjbWRRdWV1ZSA9IGNsQ3R4LmNyZWF0ZUNvbW1hbmRRdWV1ZShkZXZpY2UgfHwgZGV2aWNlc1swXSwgMCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB2YXIgZXJyQ29kZSA9IGdldEVycm9yQ29kZUZyb21DTEVycm9yKGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFlcnJDb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBXZWJDTEVycm9yKGdldENMRXJyb3JOYW1lKGdldEVycm9yQ29kZUZyb21DTEVycm9yKGUpKSwgXCJDb3VsZCBub3QgY3JlYXRlIENvbW1hbmRRdWV1ZS5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY21kUXVldWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGlucHV0L291dHB1dCBidWZmZXIgdG8gYmUgdXNlZCB3aXRoIGEgV2ViQ0wga2VybmVsXHJcbiAgICAgKlxyXG4gICAgICogQGZ1bmN0aW9uIFhNTDNELndlYmNsfmNyZWF0ZUJ1ZmZlclxyXG4gICAgICogQHBhcmFtIHtpbnR9IHNpemVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXHJcbiAgICAgKiBAcGFyYW0ge0lXZWJDTENvbnRleHR9IGNsQ3R4XHJcbiAgICAgKiBAcmV0dXJucyB7SVdlYkNMTWVtb3J5T2JqZWN0fEJvb2xlYW59XHJcbiAgICAgKi9cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVCdWZmZXIoc2l6ZSwgdHlwZSwgY2xDdHgpIHtcclxuICAgICAgICBjbEN0eCA9IGNsQ3R4IHx8IGN0eDtcclxuXHJcbiAgICAgICAgaWYgKCFzaXplKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiV2ViQ0wgQVBJOiBjcmVhdGVCdWZmZXIoKTogQnVmZmVyIHNpemUgd2FzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1lbHNlIGlmICghaXNOdW1iZXIoc2l6ZSkgfHwgc2l6ZSA8IDApIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJXZWJDTCBBUEk6IGNyZWF0ZUJ1ZmZlcigpOiBCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiV2ViQ0wgQVBJOiBjcmVhdGVCdWZmZXIoKTogQnVmZmVyIHR5cGUgd2FzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoIWNsQ3R4KSB7XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiV2ViQ0wgQVBJOiBjcmVhdGVCdWZmZXIoKTogY2xDdHggd2FzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiclwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xDdHguY3JlYXRlQnVmZmVyKHdlYmNsLk1FTV9SRUFEX09OTFksIHNpemUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwid1wiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xDdHguY3JlYXRlQnVmZmVyKHdlYmNsLk1FTV9XUklURV9PTkxZLCBzaXplKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInJ3XCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjbEN0eC5jcmVhdGVCdWZmZXIod2ViY2wuTUVNX1JFQURfV1JJVEUsIHNpemUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJXZWJDTCBBUEk6IGNyZWF0ZUJ1ZmZlcigpOiBVbmtub3duIGJ1ZmZlciB0eXBlOlwiLCB0eXBlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdmFyIGVyckNvZGUgPSBnZXRFcnJvckNvZGVGcm9tQ0xFcnJvcihlKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghZXJyQ29kZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2ViQ0xFcnJvcihnZXRDTEVycm9yTmFtZShlcnJDb2RlKSwgXCJDb3VsZCBub3QgY3JlYXRlIGEgV2ViQ0wgYnVmZmVyLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEtlcm5lbE1hbmFnZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG5hbWUgS2VybmVsTWFuYWdlclxyXG4gICAgICogQGNvbnN0cnVjdG9yIFhNTDNELndlYmNsfktlcm5lbE1hbmFnZXJcclxuICAgICAqL1xyXG5cclxuICAgIHZhciBLZXJuZWxNYW5hZ2VyID0gZnVuY3Rpb24gKGNsQ3R4LCBkZXZpY2VBcnIpIHtcclxuICAgICAgICB2YXIga2VybmVscyA9IHt9O1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYW5kIGJ1aWxkcyBhIFdlYkNMIHByb2dyYW0gZnJvbSBhIGNvZGUgc3RyaW5nIGFuZCBjcmVhdGVzIGEgV2ViQ0wga2VybmVsIGZyb20gdGhlIHByb2dyYW0uXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBLZXJuZWxNYW5hZ2VyfnJlZ2lzdGVyXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlU3RyXHJcbiAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChuYW1lLCBjb2RlU3RyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2VybmVscy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJXZWJDTCBBUEk6IGtlcm5lbHMucmVnaXN0ZXIoKTogS2VybmVsIHdpdGggYSBzYW1lIG5hbWUgaXMgYWxyZWFkeSBkZWZpbmVkLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJXZWJDTCBBUEk6IGtlcm5lbHMucmVnaXN0ZXIoKTogS2VybmVsIG5hbWUgd2FzIG5vdCBkZWZpbmVkIG9yIHdhcyBub3QgdHlwZSBvZiBTdHJpbmcuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvZGVTdHIgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIldlYkNMIEFQSToga2VybmVscy5yZWdpc3RlcigpOiBLZXJuZWwgY29kZSB3YXMgbm90IGRlZmluZWQgb3Igd2FzIG5vdCB0eXBlIG9mIFN0cmluZy5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwcm9ncmFtLCBrZXJuZWw7XHJcblxyXG4gICAgICAgICAgICAgICAgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oY29kZVN0ciwgY2xDdHgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGJ1aWxkUHJvZ3JhbShwcm9ncmFtLCBkZXZpY2VBcnIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwcm9ncmFtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2VybmVsID0gY3JlYXRlS2VybmVsKHByb2dyYW0sIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChrZXJuZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXJuZWxzW25hbWVdID0ga2VybmVsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERlYWxsb2NhdGVzIGFuZCB1bnJlZ2lzdGVycyBhIGtlcm5lbC5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIEtlcm5lbE1hbmFnZXJ+dW5SZWdpc3RlclxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgIHVuUmVnaXN0ZXI6IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2VybmVscy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtlcm5lbHNbbmFtZV0ucmVsZWFzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyckNvZGUgPSBnZXRFcnJvckNvZGVGcm9tQ0xFcnJvcihlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyQ29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdlYkNMRXJyb3IoZ2V0Q0xFcnJvck5hbWUoZXJyQ29kZSksIFwiQ291bGQgbm90IHJlbGVhc2Uga2VybmVsIHJlc291cmNlcy5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBrZXJuZWxzW25hbWVdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBhIGtlcm5lbCBvZiBhIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gS2VybmVsTWFuYWdlcn5nZXRLZXJuZWxcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgICAgICAgICAgICogQHJldHVybnMge0lXZWJDTEtlcm5lbCB8IEJvb2xlYW59XHJcbiAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgZ2V0S2VybmVsOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChrZXJuZWxzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtlcm5lbHNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgYXJndW1lbnRzIG9mIGEgc3BlY2lmaWVkIGtlcm5lbC5cclxuICAgICAgICAgICAgICogVGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoaXMgZnVuY3Rpb24gaXMgYSByZWdpc3RlcmVkIGtlcm5lbCBuYW1lLCBvdGhlciBhcmd1bWVudHMgYXJlIHRoZSBrZXJuZWwgYXJndW1lbnRzIHJlc3BlY3RpdmVseS5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIEtlcm5lbE1hbmFnZXJ+c2V0QXJnc1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0lXZWJDTEtlcm5lbH0ga2VybmVsIFdlYkNMIGtlcm5lbFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgS2VybmVsIGFyZ3VtZW50cyBpbiB0aGUgc2FtZSBvcmRlciBhcyBkZWZpbmVkIGluIHRoZSBrZXJuZWwgY29kZVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICBzZXRBcmdzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXHJcbiAgICAgICAgICAgICAgICAgICAga2VybmVsLCBpbnB1dEFyZ3MsIG5LZXJuZWxBcmdzLCBpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiV2ViQ0wgQVBJOiBzZXRBcmdzKCk6IE5vIGtlcm5lbCBhcmd1bWVudHMgd2VyZSBkZWZpbmVkLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAga2VybmVsID0gYXJnc1swXTtcclxuICAgICAgICAgICAgICAgIGlucHV0QXJncyA9IGFyZ3Muc2xpY2UoMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFrZXJuZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiV2ViQ0wgQVBJOiBzZXRBcmdzKCk6IFdlYkNMIGtlcm5lbCB3YXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBuS2VybmVsQXJncyA9IGtlcm5lbC5nZXRJbmZvKHdlYmNsLktFUk5FTF9OVU1fQVJHUyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0QXJncy5sZW5ndGggPiBuS2VybmVsQXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJXZWJDTDogc2V0QXJnczogSW5wdXQgYXJncyBhbW91bnQgPiBrZXJuZWwgcHJvZ3JhbSBhcmdzIGFtb3VudCEgSWdub3JpbmcgZXh0cmEgYXJndW1lbnRzLlwiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXRBcmdzLmxlbmd0aCA8IG5LZXJuZWxBcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJXZWJDTDogc2V0QXJnczogTm90IGVub3VnaCBhcmd1bWVudHMgd2VyZSBnaXZlbiB0byBXZWJDTCBrZXJuZWwuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dEZWJ1ZyhcIkFyZ3MgZm9yIGtlcm5lbDpcIiwga2VybmVsLmdldEluZm8od2ViY2wuS0VSTkVMX0ZVTkNUSU9OX05BTUUpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpID0gbktlcm5lbEFyZ3M7XHJcblxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKFwiQXJnOlwiLCBpLCBpbnB1dEFyZ3NbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXJuZWwuc2V0QXJnKGksIGlucHV0QXJnc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJDb2RlID0gZ2V0RXJyb3JDb2RlRnJvbUNMRXJyb3IoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyQ29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2ViQ0xFcnJvcihnZXRDTEVycm9yTmFtZShlcnJDb2RlKSwgXCJDb3VsZCBub3Qgc2V0IGtlcm5lbCBhcmd1bWVudHMuXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIFdlYkNMIGlzIGF2YWlsYWJsZSBhbmQgYXR0YWNoZXMgYSBjb250ZXh0IHRvIHRoZSBnaXZlbiBvYmplY3RcclxuICAgICAqIEBwYXJhbSB3ZWJjbE9iamVjdCB0aGUgb2JqZWN0IHRoYXQgdGhlIGNvbnRleHQgd2lsbCBiZSBhdHRhY2hlZCB0b1xyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGluaXRXZWJDTFBsYXRmb3JtKHdlYmNsT2JqZWN0KSB7XHJcbiAgICAgICAgaWYgKCFpc0F2YWlsYWJsZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjbFBsYXRmb3JtcyA9IGdldFBsYXRmb3JtcygpO1xyXG4gICAgICAgIGlmICghY2xQbGF0Zm9ybXMgfHwgY2xQbGF0Zm9ybXMubGVuZ3RoIDw9IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gVHJ5aW5nIGluaXRpYWxseSB0byB1c2UgR1BVIChmb3IgdGhlIGJlc3QgcGVyZm9ybWFuY2UpLiBVc2luZyBDUFUgYXMgYSBmYWxsYmFjay5cclxuICAgICAgICAgICAgdmFyIGNsRGV2aWNlcyA9IGdldERldmljZXNCeVR5cGUoXCJHUFVcIikgfHwgZ2V0RGV2aWNlc0J5VHlwZShcIkNQVVwiKTtcclxuICAgICAgICAgICAgaWYgKCFjbERldmljZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY2xDdHggPSBjcmVhdGVDb250ZXh0KGNsRGV2aWNlcyk7XHJcbiAgICAgICAgICAgIHZhciBjbWRRdWV1ZSA9IGNyZWF0ZUNvbW1hbmRRdWV1ZShjbERldmljZXNbMF0sIGNsQ3R4KTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiAgVE9ETzogTWF5YmUgd2Ugc2hvdWxkIGp1c3Qgc3RvcmUgdGhlIGNsLXBsYXRmb3JtIG9iamVjdHMgaW4gQy5jbCBzbyB0aGV5IGFyZSBtb3JlIGVhc2lseSBhdmFpbGFibGUgYW5kXHJcbiAgICAgICAgICAgICAqICB0byBhdm9pZCBsb25nIHByb3RvdHlwZSBjaGFpbnMuIE9yIHdlIGNvdWxkIHBhc3MgdGhlIGdyYXBoIGNvbnRleHQgdG8gZWFjaCBub2RlIG9mIHRoZSBncmFwaC5cclxuICAgICAgICAgICAgICogIEhvd2V2ZXIsIGl0IHdvdWxkIGJlIGdvb2QgdG8gYWxsb3cgZWFjaCBHcmFwaCBvYmplY3QgdG8gaGF2ZSBhdCBsZWFzdCBvd24gY29udGV4dCwgY21kUXVldWUgYW5kIGtlcm5lbE1hbmFnZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB3ZWJjbE9iamVjdC5jbCA9IHtcclxuICAgICAgICAgICAgICAgIEFQSTogd2ViY2wsXHJcbiAgICAgICAgICAgICAgICBrZXJuZWxNYW5hZ2VyOiBuZXcgS2VybmVsTWFuYWdlcihjbEN0eCwgY2xEZXZpY2VzKSxcclxuICAgICAgICAgICAgICAgIHBsYXRmb3JtczogY2xQbGF0Zm9ybXMsXHJcbiAgICAgICAgICAgICAgICBkZXZpY2VzOiBjbERldmljZXMsXHJcbiAgICAgICAgICAgICAgICBjdHg6IGNsQ3R4LFxyXG4gICAgICAgICAgICAgICAgY21kUXVldWU6IGNtZFF1ZXVlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKFwiU3VjY2Vzc2Z1bGx5IGluaXRpYWxpemVkIFdlYkNMIHBsYXRmb3JtLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQVBJXHJcbiAgICAgKlxyXG4gICAgICogQG5hbWVzcGFjZSB3ZWJjbFxyXG4gICAgICogQG1lbWJlck9mIFhNTDNEXHJcbiAgICAgKi9cclxuXHJcbiAgICBuYW1lc3BhY2VbJ3dlYmNsJ10gPSB7XHJcbiAgICAgICAgXCJpbml0XCI6IGluaXQsXHJcbiAgICAgICAgXCJjcmVhdGVDb250ZXh0XCI6IGNyZWF0ZUNvbnRleHQsXHJcbiAgICAgICAgXCJjcmVhdGVQcm9ncmFtXCI6IGNyZWF0ZVByb2dyYW0sXHJcbiAgICAgICAgXCJidWlsZFByb2dyYW1cIjogYnVpbGRQcm9ncmFtLFxyXG4gICAgICAgIFwiY3JlYXRlS2VybmVsXCI6IGNyZWF0ZUtlcm5lbCxcclxuICAgICAgICBcImNyZWF0ZUNvbW1hbmRRdWV1ZVwiOiBjcmVhdGVDb21tYW5kUXVldWUsXHJcbiAgICAgICAgXCJjcmVhdGVCdWZmZXJcIjogY3JlYXRlQnVmZmVyLFxyXG4gICAgICAgIFwiZ2V0RGVmYXVsdENvbnRleHRcIjogZ2V0RGVmYXVsdENvbnRleHQsXHJcbiAgICAgICAgXCJnZXRQbGF0Zm9ybXNcIjogZ2V0UGxhdGZvcm1zLFxyXG4gICAgICAgIFwiZ2V0RGV2aWNlc0J5VHlwZVwiOiBnZXREZXZpY2VzQnlUeXBlLFxyXG4gICAgICAgIFwiZ2V0Q29udGV4dERldmljZXNcIjogZ2V0Q29udGV4dERldmljZXMsXHJcbiAgICAgICAgXCJnZXREZXZpY2VQbGF0Zm9ybVwiOiBnZXREZXZpY2VQbGF0Zm9ybSxcclxuXHJcbiAgICAgICAgLyoqIEBuYW1lIFhNTDNELndlYmNsfmtlcm5lbHMgKi9cclxuICAgICAgICBcImtlcm5lbHNcIjogbmV3IEtlcm5lbE1hbmFnZXIoKSxcclxuICAgICAgICBcIktlcm5lbE1hbmFnZXJcIjogS2VybmVsTWFuYWdlcixcclxuXHJcbiAgICAgICAgXCJoYXNXZWJDTE5hbWVzcGFjZVwiOiBoYXNXZWJDTE5hbWVzcGFjZSxcclxuICAgICAgICBcImhhc09wZW5DTERyaXZlcnNcIjogaGFzT3BlbkNMRHJpdmVycyxcclxuICAgICAgICBcImlzQXZhaWxhYmxlXCI6IGlzQXZhaWxhYmxlLFxyXG4gICAgICAgIFwiV2ViQ0xFcnJvclwiOiBXZWJDTEVycm9yLFxyXG4gICAgICAgIFwiZ2V0Q0xFcnJvck5hbWVcIjogZ2V0Q0xFcnJvck5hbWVcclxuICAgIH07XHJcblxyXG4gICAgaW5pdFdlYkNMUGxhdGZvcm0obmFtZXNwYWNlLndlYmNsKTtcclxuICAgIHdpbmRvdy5YTUwzRC53ZWJjbCA9IG5hbWVzcGFjZS53ZWJjbDtcclxuXHJcbn0obW9kdWxlLmV4cG9ydHMpKTtcclxuIiwidmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XHJcblxyXG4vLyBFcnJvciBDYWxsYmFja3M6XHJcbnZhciBjX2Vycm9yQ2FsbGJhY2tzID0gW107XHJcblxyXG52YXIgY19saXN0ZWRDYWxsYmFja3MgPSBbXTtcclxudmFyIGNfbGlzdGVkQ2FsbGJhY2tzRGF0YSA9IFtdO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgcmVnaXN0ZXJFcnJvckNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICBjX2Vycm9yQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgfSxcclxuXHJcbiAgICBub3RpZnlFcnJvcjogZnVuY3Rpb24gKG1lc3NhZ2UsIG5vZGUpIHtcclxuICAgICAgICBpZiAoY19lcnJvckNhbGxiYWNrcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY19lcnJvckNhbGxiYWNrcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgY19lcnJvckNhbGxiYWNrc1tpXShtZXNzYWdlLCBub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IERvIERlZmF1bHQgZXJyb3IgcHJpbnRpbmdcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjdG9yIENvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50IFBhcmVudCBjbGFzc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBtZXRob2RzIE1ldGhvZHMgdG8gYWRkIHRvIHRoZSBjbGFzc1xyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgY3JlYXRlQ2xhc3M6IGZ1bmN0aW9uIChjdG9yLCBwYXJlbnQsIG1ldGhvZHMpIHtcclxuICAgICAgICBtZXRob2RzID0gbWV0aG9kcyB8fCB7fTtcclxuICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIC8qKiBAY29uc3RydWN0b3IgKi9cclxuICAgICAgICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEYucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcclxuICAgICAgICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgRigpO1xyXG4gICAgICAgICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XHJcbiAgICAgICAgICAgIGN0b3Iuc3VwZXJjbGFzcyA9IHBhcmVudC5wcm90b3R5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIG0gaW4gbWV0aG9kcykge1xyXG4gICAgICAgICAgICBjdG9yLnByb3RvdHlwZVttXSA9IG1ldGhvZHNbbV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjdG9yO1xyXG4gICAgfSxcclxuXHJcbiAgICBleHRlbmQ6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSBpbiBiKSB7XHJcbiAgICAgICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KGkpKSB7XHJcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbHVzdGVyIGludGVybmFsIG5vdGlmaWNhdGlvbnMgdG8gYXZvaWQgbXVsdGlwbGUgbm90aWZpY2F0aW9uc1xyXG4gICAgICogb2Ygc2FtZSB0eXBlLiBNYWlubHkgZm9yIFJlcXVlc3RzIGFuZCBSZXN1bHRzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJlcXVlc3RPclJlc3VsdCBSZXF1ZXN0IG9yIFJlc3VsdFxyXG4gICAgICogQHBhcmFtIHtSRVNVTFRfU1RBVEV9IHJlc3VsdFN0YXRlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfcXVldWVSZXN1bHRDYWxsYmFjazogZnVuY3Rpb24gKHJlcXVlc3RPclJlc3VsdCwgcmVzdWx0U3RhdGUpIHtcclxuICAgICAgICBhc3NlcnQocmVzdWx0U3RhdGUgIT09IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgdmFyIGluZGV4O1xyXG4gICAgICAgIGlmICgoIGluZGV4ID0gY19saXN0ZWRDYWxsYmFja3MuaW5kZXhPZihyZXF1ZXN0T3JSZXN1bHQpKSA9PSAtMSkge1xyXG4gICAgICAgICAgICBpbmRleCA9IGNfbGlzdGVkQ2FsbGJhY2tzLmxlbmd0aDtcclxuICAgICAgICAgICAgY19saXN0ZWRDYWxsYmFja3MucHVzaChyZXF1ZXN0T3JSZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHJldkRhdGEgPSBjX2xpc3RlZENhbGxiYWNrc0RhdGFbaW5kZXhdO1xyXG5cclxuICAgICAgICBpZiAoIXByZXZEYXRhIHx8IHByZXZEYXRhIDwgcmVzdWx0U3RhdGUpIHtcclxuICAgICAgICAgICAgY19saXN0ZWRDYWxsYmFja3NEYXRhW2luZGV4XSA9IHJlc3VsdFN0YXRlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGNfbGlzdGVkQ2FsbGJhY2tzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNfbGlzdGVkQ2FsbGJhY2tzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBjX2xpc3RlZENhbGxiYWNrc1tpXS5fb25Qb3N0cG9uZWRSZXN1bHRDaGFuZ2VkKGNfbGlzdGVkQ2FsbGJhY2tzRGF0YVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY19saXN0ZWRDYWxsYmFja3MgPSBbXTtcclxuICAgICAgICAgICAgY19saXN0ZWRDYWxsYmFja3NEYXRhID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4iLCJ2YXIgQyA9IHt9O1xyXG5cclxuQy5FUFNJTE9OID0gMC4wMDAwMDE7XHJcblxyXG4vKipcclxuICogVHlwZSBvZiBEYXRhRW50cnlcclxuICogQGVudW1cclxuICovXHJcbkMuREFUQV9UWVBFID0ge1xyXG4gICAgVU5LTk9XTjogMCxcclxuICAgIEZMT0FUOiAxLFxyXG4gICAgRkxPQVQyOiAyLFxyXG4gICAgRkxPQVQzOiAzLFxyXG4gICAgRkxPQVQ0OiA0LFxyXG4gICAgRkxPQVQzWDM6IDUsXHJcbiAgICBGTE9BVDRYNDogMTAsXHJcbiAgICBJTlQ6IDIwLFxyXG4gICAgSU5UNDogMjEsXHJcbiAgICBCT09MOiAzMCxcclxuICAgIFRFWFRVUkU6IDQwLFxyXG4gICAgU1RSSU5HOiA0NSxcclxuICAgIEJZVEU6IDUwLFxyXG4gICAgVUJZVEU6IDYwLFxyXG4gICAgZnJvbVN0cmluZzogZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgaWYgKCFzdHIgfHwgIXN0ci50b1VwcGVyQ2FzZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzW3N0ci50b1VwcGVyQ2FzZSgpXTtcclxuICAgIH1cclxufTtcclxuXHJcbkMuREFUQV9UWVBFX01BUCA9IHtcclxuICAgICdmbG9hdCc6IEMuREFUQV9UWVBFLkZMT0FULFxyXG4gICAgJ2Zsb2F0Mic6IEMuREFUQV9UWVBFLkZMT0FUMixcclxuICAgICdmbG9hdDMnOiBDLkRBVEFfVFlQRS5GTE9BVDMsXHJcbiAgICAnZmxvYXQ0JzogQy5EQVRBX1RZUEUuRkxPQVQ0LFxyXG4gICAgJ2Zsb2F0M3gzJzogQy5EQVRBX1RZUEUuRkxPQVQzWDMsXHJcbiAgICAnZmxvYXQ0eDQnOiBDLkRBVEFfVFlQRS5GTE9BVDRYNCxcclxuICAgICdpbnQnOiBDLkRBVEFfVFlQRS5JTlQsXHJcbiAgICAnaW50NCc6IEMuREFUQV9UWVBFLklOVDQsXHJcbiAgICAnYm9vbCc6IEMuREFUQV9UWVBFLkJPT0wsXHJcbiAgICAndGV4dHVyZSc6IEMuREFUQV9UWVBFLlRFWFRVUkUsXHJcbiAgICAnc3RyaW5nJyA6IEMuREFUQV9UWVBFLlNUUklORyxcclxuICAgICdieXRlJzogQy5EQVRBX1RZUEUuQllURSxcclxuICAgICd1Ynl0ZSc6IEMuREFUQV9UWVBFLlVCWVRFXHJcbn07XHJcblxyXG4vLyBWYWx1ZXMgYXJlIGNob3NlbiB0byBiZSBpbiBsaW5lIHdpdGggREFUQV9UWVBFXHJcbkMuVEVYVFVSRV9UWVBFID0ge1xyXG4gICAgVU5LTk9XTjogMCwgRkxPQVQ6IDEsIFVCWVRFOiA2MCwgVVNIT1JUXzVfNl81OiA3MCwgVVNIT1JUXzRfNF80XzQ6IDcxLCBVU0hPUlRfNV81XzVfMTogNzJcclxufTtcclxuXHJcbkMuVEVYVFVSRV9GT1JNQVQgPSB7XHJcbiAgICBVTktOT1dOOiAwLCBBTFBIQTogMTAwLCBSR0I6IDEwMSwgUkdCQTogMTAyLCBMVU1JTkFOQ0U6IDEwMywgTFVNSU5BTkNFX0FMUEhBOiAxMDRcclxufTtcclxuXHJcbkMuREFUQV9UWVBFX1RVUExFX1NJWkUgPSB7fTtcclxuQy5EQVRBX1RZUEVfVFVQTEVfU0laRVtDLkRBVEFfVFlQRS5GTE9BVF0gPSAxO1xyXG5DLkRBVEFfVFlQRV9UVVBMRV9TSVpFW0MuREFUQV9UWVBFLkZMT0FUMl0gPSAyO1xyXG5DLkRBVEFfVFlQRV9UVVBMRV9TSVpFW0MuREFUQV9UWVBFLkZMT0FUM10gPSAzO1xyXG5DLkRBVEFfVFlQRV9UVVBMRV9TSVpFW0MuREFUQV9UWVBFLkZMT0FUNF0gPSA0O1xyXG5DLkRBVEFfVFlQRV9UVVBMRV9TSVpFW0MuREFUQV9UWVBFLkZMT0FUM1gzXSA9IDk7XHJcbkMuREFUQV9UWVBFX1RVUExFX1NJWkVbQy5EQVRBX1RZUEUuRkxPQVQ0WDRdID0gMTY7XHJcbkMuREFUQV9UWVBFX1RVUExFX1NJWkVbQy5EQVRBX1RZUEUuSU5UXSA9IDE7XHJcbkMuREFUQV9UWVBFX1RVUExFX1NJWkVbQy5EQVRBX1RZUEUuSU5UNF0gPSA0O1xyXG5DLkRBVEFfVFlQRV9UVVBMRV9TSVpFW0MuREFUQV9UWVBFLkJPT0xdID0gMTtcclxuQy5EQVRBX1RZUEVfVFVQTEVfU0laRVtDLkRBVEFfVFlQRS5URVhUVVJFXSA9IDE7XHJcbkMuREFUQV9UWVBFX1RVUExFX1NJWkVbQy5EQVRBX1RZUEUuU1RSSU5HXSA9IDE7XHJcbkMuREFUQV9UWVBFX1RVUExFX1NJWkVbQy5EQVRBX1RZUEUuQllURV0gPSAxO1xyXG5DLkRBVEFfVFlQRV9UVVBMRV9TSVpFW0MuREFUQV9UWVBFLlVCWVRFXSA9IDE7XHJcblxyXG5DLlRZUEVEX0FSUkFZX01BUCA9IHt9O1xyXG5DLlRZUEVEX0FSUkFZX01BUFtDLkRBVEFfVFlQRS5GTE9BVF0gPSBGbG9hdDMyQXJyYXk7XHJcbkMuVFlQRURfQVJSQVlfTUFQW0MuREFUQV9UWVBFLkZMT0FUMl0gPSBGbG9hdDMyQXJyYXk7XHJcbkMuVFlQRURfQVJSQVlfTUFQW0MuREFUQV9UWVBFLkZMT0FUM10gPSBGbG9hdDMyQXJyYXk7XHJcbkMuVFlQRURfQVJSQVlfTUFQW0MuREFUQV9UWVBFLkZMT0FUNF0gPSBGbG9hdDMyQXJyYXk7XHJcbkMuVFlQRURfQVJSQVlfTUFQW0MuREFUQV9UWVBFLkZMT0FUNFg0XSA9IEZsb2F0MzJBcnJheTtcclxuQy5UWVBFRF9BUlJBWV9NQVBbQy5EQVRBX1RZUEUuSU5UXSA9IEludDMyQXJyYXk7XHJcbkMuVFlQRURfQVJSQVlfTUFQW0MuREFUQV9UWVBFLklOVDRdID0gSW50MzJBcnJheTtcclxuQy5UWVBFRF9BUlJBWV9NQVBbQy5EQVRBX1RZUEUuQk9PTF0gPSBJbnQ4QXJyYXk7XHJcbkMuVFlQRURfQVJSQVlfTUFQW0MuREFUQV9UWVBFLkJZVEVdID0gSW50OEFycmF5O1xyXG5DLlRZUEVEX0FSUkFZX01BUFtDLkRBVEFfVFlQRS5VQllURV0gPSBVaW50OEFycmF5O1xyXG5DLlRZUEVEX0FSUkFZX01BUFtDLkRBVEFfVFlQRS5TVFJJTkddID0gQXJyYXk7XHJcblxyXG4vLyB0ZXh0dXJlIGZvcm1hdHNcclxuLy8gZmxvYXQgYW5kIHVieXRlIGFyZSBtYXBwZWQgdG8gREFUQV9UWVBFIHZhbHVlcyBhYm92ZVxyXG5DLlRZUEVEX0FSUkFZX01BUFtDLlRFWFRVUkVfVFlQRS5VU0hPUlRfNF80XzRfNF0gPSBVaW50MTZBcnJheTtcclxuQy5UWVBFRF9BUlJBWV9NQVBbQy5URVhUVVJFX1RZUEUuVVNIT1JUXzVfNl81XSA9IFVpbnQxNkFycmF5O1xyXG5DLlRZUEVEX0FSUkFZX01BUFtDLlRFWFRVUkVfVFlQRS5VU0hPUlRfNV81XzVfMV0gPSBVaW50MTZBcnJheTtcclxuXHJcbkMuVEVYVFVSRV9GT1JNQVRfVFVQTEVfU0laRSA9IHt9O1xyXG5DLlRFWFRVUkVfRk9STUFUX1RVUExFX1NJWkVbQy5URVhUVVJFX0ZPUk1BVC5BTFBIQV0gPSAxO1xyXG5DLlRFWFRVUkVfRk9STUFUX1RVUExFX1NJWkVbQy5URVhUVVJFX0ZPUk1BVC5SR0JdID0gMztcclxuQy5URVhUVVJFX0ZPUk1BVF9UVVBMRV9TSVpFW0MuVEVYVFVSRV9GT1JNQVQuUkdCQV0gPSA0O1xyXG5DLlRFWFRVUkVfRk9STUFUX1RVUExFX1NJWkVbQy5URVhUVVJFX0ZPUk1BVC5MVU1JTkFOQ0VdID0gMTtcclxuQy5URVhUVVJFX0ZPUk1BVF9UVVBMRV9TSVpFW0MuVEVYVFVSRV9GT1JNQVQuTFVNSU5BTkNFX0FMUEhBXSA9IDI7XHJcblxyXG5DLmdldFR5cGVOYW1lID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgIHZhciBpO1xyXG4gICAgZm9yIChpIGluIEMuREFUQV9UWVBFX01BUCkge1xyXG4gICAgICAgIGlmIChDLkRBVEFfVFlQRV9NQVBbaV0gPT09IHR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBlbnVtIHtudW1iZXJ9XHJcbiAqL1xyXG5DLlRFWF9GSUxURVJfVFlQRSA9IHtcclxuICAgIE5FQVJFU1Q6IDB4MjYwMCwgTElORUFSOiAweDI2MDEsIE1JUE1BUF9ORUFSRVNUOiAweDI3MDAsIE1JUE1BUF9MSU5FQVI6IDB4MjcwMVxyXG5cclxufTtcclxuLyoqXHJcbiAqIEBlbnVtIHtudW1iZXJ9XHJcbiAqL1xyXG5DLlRFWF9XUkFQX1RZUEUgPSB7XHJcbiAgICBDTEFNUDogMHg4MTJGLCBSRVBFQVQ6IDB4MjkwMVxyXG59O1xyXG4vKipcclxuICogQGVudW0ge251bWJlcn1cclxuICovXHJcbkMuVEVYX1RZUEUgPSB7XHJcbiAgICBURVhUVVJFXzJEOiAweDBERTFcclxufTtcclxuXHJcbkMuU0hBREVSX0NPTlNUQU5UX0tFWSA9IHtcclxuICAgIFdPUkxEX1RSQU5TRk9STTogMSxcclxuICAgIFZJRVdfVFJBTlNGT1JNOiAyLFxyXG4gICAgU0NSRUVOX1RSQU5TRk9STTogMyxcclxuICAgIFdPUkxEX1RSQU5TRk9STV9OT1JNQUw6IDQsXHJcbiAgICBWSUVXX1RSQU5TRk9STV9OT1JNQUw6IDUsXHJcbiAgICBTQ1JFRU5fVFJBTlNGT1JNX05PUk1BTDogNixcclxuICAgIE9CSkVDVF9JRDogN1xyXG59O1xyXG5cclxuQy5WU19BVFRSSUJfVFJBTlNGT1JNID0ge1xyXG4gICAgTk9ORTogMCwgVklFV19QT0lOVDogMSwgV09STERfUE9JTlQ6IDIsIFZJRVdfTk9STUFMOiAzLCBXT1JMRF9OT1JNQUw6IDRcclxufTtcclxuXHJcblxyXG4vKipcclxuICogRmlsdGVyIFR5cGUgb2YgRGF0YU5vZGVcclxuICogS0VFUCAtIEtlZXAgb25seSB0aGUgcHJvdmlkZWQgbmFtZXNcclxuICogUkVNT1ZFIC0gUmVtb3ZlIHByb3ZpZGVkIG5hbWVzIChpZ25vcmVzIG5hbWUgbWFwcGluZylcclxuICogUkVOQU1FIC0gT25seSBhcHBseSBuYW1lIG1hcHBpbmdcclxuICogQGVudW1cclxuICovXHJcbkMuREFUQV9GSUxURVJfVFlQRSA9IHtcclxuICAgIE5PTkU6IDAsIFJFTkFNRTogMSwgS0VFUDogMiwgUkVNT1ZFOiAzXHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFRPRE86IE1heWJlIG1lcmdlIHRoaXMgc3RydWN0dXJlIHdpdGggUkVTVUxUX1NUQVRFIHRvIGF2b2lkIGJhY2sgYW5kIGZvcnRoIGNvbnZlcnNpb24gd2l0aGluIG5vdGlmaWNhdGlvbiBjaGFpblxyXG4gKiBAZW51bSB7bnVtYmVyfVxyXG4gKi9cclxuQy5EQVRBX0VOVFJZX1NUQVRFID0ge1xyXG4gICAgQ0hBTkdFRF9WQUxVRTogMSxcclxuICAgIENIQU5HRURfTkVXOiAyLFxyXG4gICAgTE9BRF9TVEFSVDogMyxcclxuICAgIExPQURfRU5EOiA0LFxyXG4gICAgQ0hBTkdFRF9TSVpFOiA1LFxyXG4gICAgQ0hBTkdFRF9SRU1PVkVEOiA2LCAvLyBOb3QganVzdCB0aGUgc2l6ZSBjaGFuZ2VkLCBidXQgYWxzbyBxdWFsaWZpZXJcclxuICAgIC8vIGlmIHdlIGhhdmUgMCwgMSBvciBtYW55IHR1cGxlcyBpbiB2YWx1ZVxyXG4gICAgQ0hBTkdFRF9TSVpFX1RZUEU6IDdcclxufTtcclxuXHJcbi8qKiBUT0RPOiBNZXJnZSB3aXRoIEMuUExBVEZPUk0/ICoqL1xyXG5DLlJFU1VMVF9UWVBFID0ge1xyXG4gICAgQ09NUFVURTogMCwgVlM6IDFcclxufTtcclxuXHJcblxyXG4vKipcclxuICogVHlwZSBvZiBNb2RpZmljYXRpb24sIHVzZWQgaW50ZXJuYWxseSBvbmx5XHJcbiAqIE9yZGVyZWQgYnkgaW1wb3J0YW5jZS5cclxuICogQGVudW1cclxuICovXHJcbkMuUkVTVUxUX1NUQVRFID0ge1xyXG4gICAgTk9ORTogMCwgQ0hBTkdFRF9EQVRBX1ZBTFVFOiAxLCBDSEFOR0VEX0RBVEFfU0laRTogMiwgQ0hBTkdFRF9TVFJVQ1RVUkU6IDMsIC8vIFRPRE86IEZlbGl4OiBTdGlsbCByZXF1aXJlZD9cclxuICAgIElNQUdFX0xPQURfU1RBUlQ6IDQsIElNQUdFX0xPQURfRU5EOiA1XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFR5cGUgb2YgU2VxdWVuY2UgYWNjZXNzIC0gdXNlZCBieSBvcGVyYXRvcnNcclxuICogQGVudW1cclxuICovXHJcbkMuU0VRVUVOQ0UgPSB7XHJcbiAgICBOT19BQ0NFU1M6IDAsIFBSRVZfQlVGRkVSOiAxLCBORVhUX0JVRkZFUjogMiwgTElORUFSX1dFSUdIVDogM1xyXG59O1xyXG5cclxuXHJcbkMuSVRFUkFUSU9OX1RZUEUgPSB7XHJcbiAgICBOVUxMOiAwLCBPTkU6IDEsIE1BTlk6IDJcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUeXBlIG9mIEluZm9ybWF0aW9uIEV4dHJhY3Rpb24gLSB1c2VkIGJ5IG9wZXJhdG9yc1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZW51bVxyXG4gKi9cclxuLy9UT0RPOiBUaGlzIHNlZW1zIHRvIGJlIHVudXNlZCwgaXMgaXQgc3RpbGwgbmVlZGVkP1xyXG5DLkVYVFJBQ1QgPSB7XHJcbiAgICBOT19FWFRSQUM6IDAsIFRFWF9XSURUSDogMSwgVEVYX0hFSUdIVDogMlxyXG59O1xyXG5cclxuQy5PUklHSU4gPSB7XHJcbiAgICBDSElMRDogMSwgQ09NUFVURTogMiwgUFJPVE86IDNcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUeXBlcyBvZiBwbGF0Zm9ybXMgdG8gcGVyZm9ybSBjb21wdXRhdGlvbiBvblxyXG4gKiBAdHlwZSB7ZW51bX1cclxuICovXHJcbkMuUExBVEZPUk0gPSB7XHJcbiAgICBKQVZBU0NSSVBUOiAwLCBHTFNMOiAxLCBDTDogMiwgQVNZTkM6IDNcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQb3NzaWJsZSBzdGF0ZXMgb2YgYSBQcm9jZXNzTm9kZVxyXG4gKiBAdHlwZSB7ZW51bX1cclxuICovXHJcbkMuUFJPQ0VTU19TVEFURSA9IHtcclxuICAgIE1PRElGSUVEOiAwLCAvLyBXZSBkb24ndCBrbm93IChUT0RPIEZlbGl4OiBGaW5kIG91dCEpXHJcbiAgICBMT0FESU5HOiAxLCAvLyBTb21ldGhpbmcgc3RpbGwgbG9hZGluZyAoYmxvY2tlZClcclxuICAgIElOVkFMSUQ6IDMsIC8vIElucHV0IGlzIGludmFsaWQgKG1pZ2h0IGhhcHBlbiBldmVuIGFmdGVyIG9wZXJhdG9yIHNlbGVjdGlvbiAtIGUuZy4gYmVjYXVzZSBvZiBlbXB0eSBhcnJheSBvdXRwdXQgZXRjLilcclxuICAgIFVOUFJPQ0VTU0VEOiA0LCAvLyBQcm9jZXNzIG5vZGUgaXMgZGlydHlcclxuICAgIFBST0NFU1NFRDogNSAvLyBBbGwgZGF0YSBpcyB1cC10by1kYXRlXHJcbn07XHJcblxyXG4vL3dpbmRvdy5YZmxvdy5QTEFURk9STSA9IEMuUExBVEZPUk07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEM7XHJcbiIsInZhciBCYXNlID0gcmVxdWlyZShcIi4uL2Jhc2UuanNcIik7XHJcbnZhciBDID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xyXG52YXIgYXNzaWduID0gcmVxdWlyZSgnbG9kYXNoLmFzc2lnbicpO1xyXG5yZXF1aXJlKFwiLi4vLi4vdXRpbHMvYXJyYXkuanNcIik7XHJcblxyXG4vKipcclxuICogQ29udGVudCBvZiB0aGlzIGZpbGU6XHJcbiAqIEFsbCBDb2RlIGZvciBoYW5kbGluZyBkYXRhIGVudHJpZXMgY29ubmVjdGVkIHRvIFhmbG93IGluY2x1ZGluZzpcclxuICogIC0gQnVmZmVyRW50cmllczogVHlwZWQgdmFsdWUgYnVmZmVycyAoZS5nIGZsb2F0MyBidWZmZXIsIHdpdGhvdXQgbmFtZSlcclxuICogIC0gVGV4dHVyZUVudHJpZXM6IGUuZy4gaW1hZ2VzXHJcbiAqXHJcbiAqICBUaGlzIGZpbGUgYWxzbyBpbmNsdWRlcyB0aGUgRGF0YUNoYW5nZU5vdGlmaWVyIHVzZWQgdG8gcmVhY3QgdG8gY2hhbmdlcyBvbiBYZmxvdyBkYXRhIHN0cnVjdHVyZXNcclxuICovXHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gU2FtcGxlckNvbmZpZ1xyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbnZhciBTQU1QTEVSX0RFRkFVTFRTID0ge1xyXG4gICAgbWluRmlsdGVyIDogQy5URVhfRklMVEVSX1RZUEUuTElORUFSLFxyXG4gICAgbWFnRmlsdGVyIDogQy5URVhfRklMVEVSX1RZUEUuTElORUFSLFxyXG4gICAgd3JhcFMgOiBDLlRFWF9XUkFQX1RZUEUuQ0xBTVAsXHJcbiAgICB3cmFwVCA6IEMuVEVYX1dSQVBfVFlQRS5DTEFNUCxcclxuICAgIHRleHR1cmVUeXBlIDogQy5URVhfVFlQRS5URVhUVVJFXzJELFxyXG4gICAgZmxpcFk6IHRydWUsXHJcbiAgICBhbmlzb3Ryb3B5IDogMSwgLy8gbnVtYmVyIG9mIG1heCBzYW1wbGVzIGZvciBhbmlzb3Ryb3BpYyBmaWx0ZXJpbmdcclxuICAgIGdlbmVyYXRlTWlwTWFwIDogMFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNhbXBsZXJDb25maWcgaXMgdXNlZCB0byBkZWZpbmUgc2FtcGxlciBwcm9wZXJ0aWVzIG9mIGEgVGV4dHVyZUVudHJ5IG9yIEltYWdlRGF0YVRleHR1cmVFbnRyeVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBTYW1wbGVyQ29uZmlnID0gZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuc2V0RGVmYXVsdHMoKTtcclxufTtcclxuXHJcblNhbXBsZXJDb25maWcucHJvdG90eXBlLnNldERlZmF1bHRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICBhc3NpZ24odGhpcywgU0FNUExFUl9ERUZBVUxUUyk7XHJcbn07XHJcblxyXG5TYW1wbGVyQ29uZmlnLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgYXNzaWduKHRoaXMsIG90aGVyKTtcclxufTtcclxuXHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gRGF0YUVudHJ5XHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgYWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYWxsIERhdGFFbnRyaWVzIGNvbm5lY3RlZCB0byBhbiB4ZmxvdyBncmFwaC5cclxuICogQGFic3RyYWN0XHJcbiAqIEBwYXJhbSB7Qy5EQVRBX1RZUEV9IHR5cGUgVHlwZSBvZiBEYXRhRW50cnlcclxuICovXHJcbnZhciBEYXRhRW50cnkgPSBmdW5jdGlvbih0eXBlKXtcclxuICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xyXG4gICAgLyoqIEB0eXBlIHtBcnJheS48RnVuY3Rpb24oRGF0YUVudHJ5LCBDLkRBVEFfRU5UUllfU1RBVEUpPn0gKiovXHJcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcclxuICAgIC8qKiBBZGQgcmVsYXRlZCBjdXN0b20gZGF0YSAoZS5nLiBXZWJHTCBidWZmZXJzKSAqKi9cclxuICAgIHRoaXMudXNlckRhdGEgPSB7fTtcclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhRW50cnkucHJvdG90eXBlLCBcInR5cGVcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInR5cGUgaXMgcmVhZC1vbmx5XCIpO1xyXG4gICAgfSxcclxuICAgIC8qKiBAcmV0dXJuIHtDLkRBVEFfVFlQRX0gKi9cclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX3R5cGU7IH1cclxufSk7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtmdW5jdGlvbihEYXRhRW50cnksIEMuREFUQV9FTlRSWV9TVEFURSl9IGNhbGxiYWNrXHJcbiAqL1xyXG5EYXRhRW50cnkucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24oY2FsbGJhY2spe1xyXG4gICAgdGhpcy5fbGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRGF0YUVudHJ5LCBDLkRBVEFfRU5UUllfU1RBVEUpfSBjYWxsYmFja1xyXG4gKi9cclxuRGF0YUVudHJ5LnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGNhbGxiYWNrKXtcclxuICAgIEFycmF5LmVyYXNlKHRoaXMuX2xpc3RlbmVycywgY2FsbGJhY2spO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqL1xyXG5EYXRhRW50cnkucHJvdG90eXBlLl9ub3RpZnlDaGFuZ2VkID0gZnVuY3Rpb24oKXtcclxuICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9WQUxVRSk7XHJcbn07XHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gQnVmZmVyRW50cnlcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vKipcclxuICogQSB0eXBlZCB2YWx1ZSBidWZmZXIgYmFzaWNhbGx5IGxpbmtpbmcgdG8gYSB0eXBlZCBhcnJheS5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIHtEYXRhRW50cnl9XHJcbiAqIEBwYXJhbSB7Qy5EQVRBX1RZUEV9IHR5cGVcclxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIEEgdHlwZWQgYXJyYXlcclxuICovXHJcbnZhciBCdWZmZXJFbnRyeSA9IGZ1bmN0aW9uKHR5cGUsIHZhbHVlKXtcclxuICAgIERhdGFFbnRyeS5jYWxsKHRoaXMsIHR5cGUpO1xyXG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcclxuICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9ORVcpO1xyXG59O1xyXG5CYXNlLmNyZWF0ZUNsYXNzKEJ1ZmZlckVudHJ5LCBEYXRhRW50cnkpO1xyXG5cclxuXHJcbi8qKlxyXG4gKiAgU2V0IHZhbHVlIG9mIGVudHJ5LiBUcmlnZ2VycyBub3RpZmljYXRpb24gY2hhaW5cclxuICogIEBwYXJhbSB7T2JqZWN0fSB2IFZhbHVlIHRvIHNldCAoaGFzIHRvIGJlIGEgVHlwZWRBcnJheSlcclxuICovXHJcbkJ1ZmZlckVudHJ5LnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uKHYpe1xyXG4gICAgdGhpcy5fc2V0VmFsdWUodik7XHJcbiAgICBCYXNlLl9mbHVzaFJlc3VsdENhbGxiYWNrcygpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFyZSB0aGVyZSBubywgb25lIG9yIG1hbnkgdmFsdWVzP1xyXG4gKiBAcGFyYW0gc2l6ZVxyXG4gKiBAcGFyYW0gdHVwbGVTaXplXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTaXplVHlwZShzaXplLCB0dXBsZVNpemUpe1xyXG4gICAgaWYoc2l6ZSA+PSB0dXBsZVNpemUqMilcclxuICAgICAgICByZXR1cm4gMjtcclxuICAgIGVsc2UgaWYoc2l6ZSA+PSB0dXBsZVNpemUpXHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbn1cclxuXHJcbkJ1ZmZlckVudHJ5LnByb3RvdHlwZS5fc2V0VmFsdWUgPSBmdW5jdGlvbih2KXtcclxuICAgIHZhciBvbGRTaXplID0gKHRoaXMuX3ZhbHVlID8gdGhpcy5fdmFsdWUubGVuZ3RoIDogMCksIG5ld1NpemUgPSAodiA/IHYubGVuZ3RoIDogMCksIHR1cGxlU2l6ZSA9IHRoaXMuZ2V0VHVwbGVTaXplKCk7XHJcbiAgICB2YXIgbm90aWZpY2F0aW9uO1xyXG4gICAgaWYoZ2V0U2l6ZVR5cGUob2xkU2l6ZSwgdHVwbGVTaXplKSAhPSBnZXRTaXplVHlwZShuZXdTaXplLCB0dXBsZVNpemUpKVxyXG4gICAgICAgIG5vdGlmaWNhdGlvbiA9IEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX1NJWkVfVFlQRTtcclxuICAgIGVsc2UgaWYob2xkU2l6ZSAhPSBuZXdTaXplKXtcclxuICAgICAgICBub3RpZmljYXRpb24gPSBDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9TSVpFO1xyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgICBub3RpZmljYXRpb24gPSBDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9WQUxVRTtcclxuICAgIH1cclxuICAgIHRoaXMuX3ZhbHVlID0gdjtcclxuICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBub3RpZmljYXRpb24pO1xyXG59O1xyXG5cclxuLyoqIEByZXR1cm4ge09iamVjdH0gKi9cclxuQnVmZmVyRW50cnkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBidWZmZXIgbGVuZ3RoXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICovXHJcbkJ1ZmZlckVudHJ5LnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlID8gdGhpcy5fdmFsdWUubGVuZ3RoIDogMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHR1cGxlIHNpemUgKGUuZyAxLCAyLCAzLCA0LCAxNilcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkJ1ZmZlckVudHJ5LnByb3RvdHlwZS5nZXRUdXBsZVNpemUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBDLkRBVEFfVFlQRV9UVVBMRV9TSVpFW3RoaXMuX3R5cGVdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiB0dXBsZSBjb3VudFxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAqL1xyXG5CdWZmZXJFbnRyeS5wcm90b3R5cGUuZ2V0SXRlcmF0ZUNvdW50ID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLmdldExlbmd0aCgpIC8gdGhpcy5nZXRUdXBsZVNpemUoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJcyB2YWx1ZSBub3Qgc2V0IG9yIHRoZSBsZW5ndGggb2YgdGhlIGJ1ZmZlciAwXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuQnVmZmVyRW50cnkucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuICF0aGlzLl92YWx1ZSB8fCAhdGhpcy5nZXRMZW5ndGgoKTtcclxufTtcclxuXHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gVGV4dHVyZUVudHJ5XHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuZnVuY3Rpb24gVGV4ZWxTb3VyY2Uoc291cmNlT3JXaWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUpIHtcclxuICAgIGlmICh0eXBlb2Ygc291cmNlT3JXaWR0aCA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIGlmIChzb3VyY2VPcldpZHRoLm5vZGVOYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlTmFtZSA9IHNvdXJjZU9yV2lkdGgubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSBcInZpZGVvXCIgJiYgKHR5cGVvZiBzb3VyY2VPcldpZHRoLmNvbXBsZXRlID09PSBcInVuZGVmaW5lZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc291cmNlT3JXaWR0aCwge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9XaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9IZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEodGhpcy5yZWFkeVN0YXRlID09IDAgfHwgdGhpcy52aWRlb1dpZHRoIDw9IDAgfHwgdGhpcy52aWRlb0hlaWdodCA8PSAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNvdXJjZU9yV2lkdGgudGV4ZWxGb3JtYXQgPSBDLlRFWFRVUkVfRk9STUFULlJHQkE7XHJcbiAgICAgICAgICAgIHNvdXJjZU9yV2lkdGgudGV4ZWxUeXBlID0gQy5URVhUVVJFX1RZUEUuVUJZVEU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vYXNzdW1lIHNvdXJjZSBpcyBhIGltYWdlIGRhdGEgbGlrZSBvYmplY3RcclxuICAgICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2VPcldpZHRoO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgQy5URVhUVVJFX0ZPUk1BVC5SR0JBO1xyXG4gICAgICAgIHR5cGUgPSAgdHlwZSB8fCBDLlRFWFRVUkVfVFlQRS5VQllURTtcclxuICAgICAgICAvL2NyZWF0ZSBhIG5ldyB0ZXhlbCBzb3VyY2UgYmFja2VkIGJ5IHR5cGUgYXJyYXlcclxuICAgICAgICB0aGlzLl9zb3VyY2UgPSB7XHJcbiAgICAgICAgICAgIHdpZHRoOiBzb3VyY2VPcldpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgICAgdGV4ZWxGb3JtYXQ6IGZvcm1hdCxcclxuICAgICAgICAgICAgdGV4ZWxUeXBlOiB0eXBlLFxyXG4gICAgICAgICAgICBkYXRhOiBuZXcgQy5UWVBFRF9BUlJBWV9NQVBbdHlwZV0oc291cmNlT3JXaWR0aCAqIGhlaWdodCAqIEMuVEVYVFVSRV9GT1JNQVRfVFVQTEVfU0laRVtmb3JtYXRdKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGV4ZWxTb3VyY2UucHJvdG90eXBlLCB7XHJcbiAgICBpbWFnZURhdGE6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuX3NvdXJjZS53aWR0aDtcclxuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLl9zb3VyY2UuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuX3NvdXJjZSwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLl9zb3VyY2Uud2lkdGgsIHRoaXMuX3NvdXJjZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgc291cmNlLnRleGVsRm9ybWF0ID0gdGhpcy5fc291cmNlLnRleGVsRm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgc291cmNlLnRleGVsVHlwZSA9IHRoaXMuX3NvdXJjZS50ZXhlbFR5cGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgLy8gVE9ETyB0aGlzIGlzIHZlcnkgY29uZnVzaW5nLiBhc0dMVGV4dHVyZURhdGEgaXMgdGV4ZWxzb3VyY2Uuc291cmNlXHJcbiAgICBnbFRleHR1cmVEYXRhOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNvbXBsZXRlOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fc291cmNlLmNvbXBsZXRlID09PSBcInVuZGVmaW5lZFwiID8gdHJ1ZSA6IHRoaXMuX3NvdXJjZS5jb21wbGV0ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgd2lkdGg6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZSA/IHRoaXMuX3NvdXJjZS53aWR0aCA6IC0xO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBoZWlnaHQ6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZSA/IHRoaXMuX3NvdXJjZS5oZWlnaHQgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgdGV4ZWxGb3JtYXQ6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZSA/IHRoaXMuX3NvdXJjZS50ZXhlbEZvcm1hdDogQy5URVhUVVJFX0ZPUk1BVC5VTktOT1dOO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB0ZXhlbFR5cGU6IHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZSA/IHRoaXMuX3NvdXJjZS50ZXhlbFR5cGU6IEMuVEVYVFVSRV9UWVBFLlVOS05PV047XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBBIGRhdGEgZW50cnkgZm9yIGEgdGV4dHVyZS5cclxuICogTm90ZTogZWFjaCBUZXh0dXJlRW50cnkgaW5jbHVkZXMgYSBzYW1wbGVyQ29uZmlnLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMge0RhdGFFbnRyeX1cclxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IHNvdXJjZSAvL1RPRE86IFdoaWNoIGtpbmRzIGFyZSBzdXBwb3J0ZWQ/XHJcbiAqL1xyXG52YXIgVGV4dHVyZUVudHJ5ID0gZnVuY3Rpb24oc291cmNlKXtcclxuICAgIERhdGFFbnRyeS5jYWxsKHRoaXMsIEMuREFUQV9UWVBFLlRFWFRVUkUpO1xyXG4gICAgdGhpcy5fc2FtcGxlckNvbmZpZyA9IG5ldyBTYW1wbGVyQ29uZmlnKCk7XHJcbiAgICB0aGlzLl9sb2FkaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLnNldEltYWdlKHNvdXJjZSk7XHJcblxyXG4gICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX05FVyk7XHJcbn07XHJcblxyXG5CYXNlLmNyZWF0ZUNsYXNzKFRleHR1cmVFbnRyeSwgRGF0YUVudHJ5KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRleHR1cmVFbnRyeS5wcm90b3R5cGUsIHtcclxuICAgIHdpZHRoOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2UgPyB0aGlzLl9zb3VyY2Uud2lkdGggOiAtMTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgaGVpZ2h0OiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2UgPyB0aGlzLl9zb3VyY2UuaGVpZ2h0IDogLTE7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHRleGVsRm9ybWF0OiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2UgPyB0aGlzLl9zb3VyY2UudGV4ZWxGb3JtYXQ6IEMuVEVYVFVSRV9GT1JNQVQuVU5LTk9XTjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgdGV4ZWxUeXBlOiB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2UgPyB0aGlzLl9zb3VyY2UudGV4ZWxUeXBlOiBDLlRFWFRVUkVfVFlQRS5VTktOT1dOO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG5UZXh0dXJlRW50cnkucHJvdG90eXBlLmlzTG9hZGluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCF0aGlzLl9zb3VyY2UpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIHJldHVybiAhdGhpcy5fc291cmNlLmNvbXBsZXRlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5UZXh0dXJlRW50cnkucHJvdG90eXBlLl9jcmVhdGVJbWFnZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgc2FtcGxlckNvbmZpZykge1xyXG4gICAgaWYgKCF0aGlzLl9zb3VyY2UgfHwgdGhpcy53aWR0aCAhPSB3aWR0aCB8fCB0aGlzLmhlaWdodCAhPSBoZWlnaHQgfHwgdGhpcy5mb3JtYXQgIT0gZm9ybWF0IHx8IHRoaXMudHlwZSAhPSB0eXBlKSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IG5ldyBUZXhlbFNvdXJjZSh3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUpO1xyXG5cclxuICAgICAgICBpZiAoIXNhbXBsZXJDb25maWcpIHtcclxuICAgICAgICAgICAgc2FtcGxlckNvbmZpZyA9IG5ldyBTYW1wbGVyQ29uZmlnKCk7XHJcbiAgICAgICAgICAgIHNhbXBsZXJDb25maWcuc2V0RGVmYXVsdHMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3NhbXBsZXJDb25maWcuc2V0KHNhbXBsZXJDb25maWcpO1xyXG4gICAgICAgIHRoaXMuX3NldEltYWdlKHNvdXJjZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX25vdGlmeUNoYW5nZWQoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fc291cmNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldCBpbWFnZSBzb3VyY2Ugb2YgYSBUZXh0dXJlIEVudHJ5XHJcbiAqIFRPRE86IFRoaXMgaXMgY2FsbGVkIGV2ZW4gaWYgaW1hZ2UgaXMganVzdCBsb2FkZWQgKG9uIFhNTDNEIHNpZGUpLiBBZGQgYSBub3RpZnlJbWFnZUxvYWRlZCBtZXRob2QgY291bGRcclxuICogYmUgaGVscGZ1bFxyXG4gKlxyXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxUZXhlbFNvdXJjZXxudWxsfSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj99IGZvcmNlTG9hZENhbGxiYWNrIHRyaWdnZXIgbG9hZCBjYWxsYmFjayBpZiBkYXRhIGNoYW5nZXNcclxuICovXHJcblRleHR1cmVFbnRyeS5wcm90b3R5cGUuc2V0SW1hZ2UgPSBmdW5jdGlvbiAoZWxlbWVudCwgZm9yY2VMb2FkQ2FsbGJhY2spIHtcclxuICAgIHRoaXMuX3NldEltYWdlKGVsZW1lbnQsIGZvcmNlTG9hZENhbGxiYWNrKTtcclxuICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XHJcbn07XHJcblxyXG5UZXh0dXJlRW50cnkucHJvdG90eXBlLl9zZXRJbWFnZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBmb3JjZUxvYWRDYWxsYmFjaykge1xyXG4gICAgaWYgKCFlbGVtZW50KVxyXG4gICAgICAgIHRoaXMuX3NldFNvdXJjZShudWxsLCBmb3JjZUxvYWRDYWxsYmFjayk7XHJcbiAgICBlbHNlIGlmIChlbGVtZW50IGluc3RhbmNlb2YgVGV4ZWxTb3VyY2UpXHJcbiAgICAgICAgdGhpcy5fc2V0U291cmNlKGVsZW1lbnQsIGZvcmNlTG9hZENhbGxiYWNrKTtcclxuICAgIGVsc2VcclxuICAgICAgICB0aGlzLl9zZXRTb3VyY2UobmV3IFRleGVsU291cmNlKGVsZW1lbnQpLCBmb3JjZUxvYWRDYWxsYmFjayk7XHJcbn07XHJcblxyXG5UZXh0dXJlRW50cnkucHJvdG90eXBlLl9zZXRTb3VyY2UgPSBmdW5jdGlvbihzLCBmb3JjZUxvYWRDYWxsYmFjaykge1xyXG4gICAgdmFyIHByZXZMb2FkaW5nID0gdGhpcy5pc0xvYWRpbmcoKTtcclxuICAgIHRoaXMuX3NvdXJjZSA9IHM7XHJcbiAgICB2YXIgbG9hZGluZyA9IHRoaXMuaXNMb2FkaW5nKCk7XHJcbiAgICBpZihmb3JjZUxvYWRDYWxsYmFjayAmJiAhbG9hZGluZyAmJiAhcHJldkxvYWRpbmcpe1xyXG4gICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBDLkRBVEFfRU5UUllfU1RBVEUuTE9BRF9TVEFSVCk7XHJcbiAgICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIEMuREFUQV9FTlRSWV9TVEFURS5MT0FEX0VORCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmKGxvYWRpbmcpe1xyXG4gICAgICAgIHRoaXMuX2xvYWRpbmcgPSB0cnVlO1xyXG4gICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBDLkRBVEFfRU5UUllfU1RBVEUuTE9BRF9TVEFSVCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmKHRoaXMuX2xvYWRpbmcpe1xyXG4gICAgICAgIHRoaXMuX2xvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgQy5EQVRBX0VOVFJZX1NUQVRFLkxPQURfRU5EKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgQy5EQVRBX0VOVFJZX1NUQVRFLkNIQU5HRURfVkFMVUUpO1xyXG59O1xyXG5cclxuVGV4dHVyZUVudHJ5LnByb3RvdHlwZS5hc0dMVGV4dHVyZVZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UuZ2xUZXh0dXJlRGF0YTtcclxufTtcclxuXHJcbi8qKiBAcmV0dXJuIHtJbWFnZURhdGF9ICovXHJcblRleHR1cmVFbnRyeS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmICghdGhpcy5fc291cmNlKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgaWYgKCF0aGlzLmlzTG9hZGluZygpKVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2UuaW1hZ2VEYXRhO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuLyoqIEByZXR1cm4ge1NhbXBsZXJDb25maWd9ICovXHJcblRleHR1cmVFbnRyeS5wcm90b3R5cGUuZ2V0U2FtcGxlckNvbmZpZyA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpcy5fc2FtcGxlckNvbmZpZztcclxufTtcclxuXHJcbi8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXHJcblRleHR1cmVFbnRyeS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiAxO1xyXG59O1xyXG5UZXh0dXJlRW50cnkucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuLyoqIEByZXR1cm4ge251bWJlcn0gKi9cclxuVGV4dHVyZUVudHJ5LnByb3RvdHlwZS5nZXRJdGVyYXRlQ291bnQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiAxO1xyXG59O1xyXG5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIEltYWdlRGF0YVRleHR1cmVFbnRyeVxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8qKlxyXG4gKiBTYW1lIGFzIFRleHR1cmVFbnRyeSwgb25seSBiYXNlZCBvbiBpbWFnZURhdGEuXHJcbiAqIFRoaXMgY2xhc3MgaXMgdXNlZCBmb3IgeGZsb3cgcnVubmluZyBpbnNpZGUgV2ViIFdvcmtlcnMgKHdoaWNoIGRvbid0IHN1cHBvcnQgSFRNTCBpbWFnZXMpXHJcbiAqIEBwYXJhbSBpbWFnZURhdGFcclxuICogQGV4dGVuZHN7RGF0YUVudHJ5fVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBJbWFnZURhdGFUZXh0dXJlRW50cnkgPSBmdW5jdGlvbihpbWFnZURhdGEpe1xyXG4gICAgRGF0YUVudHJ5LmNhbGwodGhpcywgQy5EQVRBX1RZUEUuVEVYVFVSRSk7XHJcbiAgICB0aGlzLl9zYW1wbGVyQ29uZmlnID0gbmV3IFNhbXBsZXJDb25maWcoKTtcclxuICAgIHRoaXMuX2ltYWdlRGF0YSA9IG51bGw7XHJcbiAgICB0aGlzLl90ZXhlbEZvcm1hdCA9IEMuVEVYVFVSRV9GT1JNQVQuUkdCQTtcclxuICAgIHRoaXMuX3RleGVsVHlwZSA9IEMuVEVYVFVSRV9UWVBFLlVCWVRFO1xyXG5cclxuICAgIHRoaXMuX3VwZGF0ZUltYWdlRGF0YShpbWFnZURhdGEpO1xyXG5cclxuICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9ORVcpO1xyXG59O1xyXG5cclxuQmFzZS5jcmVhdGVDbGFzcyhJbWFnZURhdGFUZXh0dXJlRW50cnksIERhdGFFbnRyeSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhJbWFnZURhdGFUZXh0dXJlRW50cnkucHJvdG90eXBlLCB7XHJcbiAgICB3aWR0aDoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW1hZ2VEYXRhID8gdGhpcy5faW1hZ2VEYXRhLndpZHRoIDogLTE7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGhlaWdodDoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW1hZ2VEYXRhID8gdGhpcy5faW1hZ2VEYXRhLmhlaWdodCA6IC0xO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB0ZXhlbEZvcm1hdDoge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4ZWxGb3JtYXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHRleGVsVHlwZToge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4ZWxUeXBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG5cclxuXHJcbkltYWdlRGF0YVRleHR1cmVFbnRyeS5wcm90b3R5cGUuaXNMb2FkaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gIXRoaXMuX2ltYWdlRGF0YTtcclxufTtcclxuXHJcbkltYWdlRGF0YVRleHR1cmVFbnRyeS5wcm90b3R5cGUuX3VwZGF0ZUltYWdlRGF0YSA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xyXG4gICAgdGhpcy5fdGV4ZWxGb3JtYXQgPSBDLlRFWFRVUkVfRk9STUFULlJHQkE7XHJcbiAgICB0aGlzLl90ZXhlbFR5cGUgPSBDLlRFWFRVUkVfVFlQRS5VQllURTtcclxuICAgIHRoaXMuX2ltYWdlRGF0YSA9IGltYWdlRGF0YTtcclxufTtcclxuXHJcbi8qKiBDcmVhdGUgbmV3IGltYWdlXHJcbiAqIFRPRE86IEphbjogV3JpdGUgc291cmNlIGRvY3VtZW50YXRpb25cclxuICogQHBhcmFtIHdpZHRoXHJcbiAqIEBwYXJhbSBoZWlnaHRcclxuICogQHBhcmFtIGZvcm1hdFxyXG4gKiBAcGFyYW0gdHlwZVxyXG4gKiBAcGFyYW0gc2FtcGxlckNvbmZpZ1xyXG4gKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fVxyXG4gKi9cclxuSW1hZ2VEYXRhVGV4dHVyZUVudHJ5LnByb3RvdHlwZS5fY3JlYXRlSW1hZ2UgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIHNhbXBsZXJDb25maWcpIHtcclxuICAgIGlmICghdGhpcy5faW1hZ2VEYXRhIHx8IHRoaXMuZ2V0V2lkdGgoKSAhPSB3aWR0aCB8fCB0aGlzLmdldEhlaWdodCgpICE9IGhlaWdodCB8fCB0aGlzLl9mb3JtYXQgIT0gZm9ybWF0IHx8IHRoaXMuX3R5cGUgIT0gdHlwZSkge1xyXG4gICAgICAgIGlmICghd2lkdGggfHwgIWhlaWdodClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2lkdGggb3IgaGVpZ2h0IGlzIG5vdCBzcGVjaWZpZWRcIik7XHJcbiAgICAgICAgdGhpcy5fdGV4ZWxGb3JtYXQgPSBmb3JtYXQ7XHJcbiAgICAgICAgdGhpcy5fdGV4ZWxUeXBlID0gdHlwZTtcclxuICAgICAgICBpZiAoIXNhbXBsZXJDb25maWcpIHtcclxuICAgICAgICAgICAgc2FtcGxlckNvbmZpZyA9IG5ldyBTYW1wbGVyQ29uZmlnKCk7XHJcbiAgICAgICAgICAgIHNhbXBsZXJDb25maWcuc2V0RGVmYXVsdHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc2FtcGxlckNvbmZpZy5zZXQoc2FtcGxlckNvbmZpZyk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIHt7d2lkdGg6ICosIGhlaWdodDogKiwgZGF0YTogbnVsbHxBcnJheUJ1ZmZlclZpZXd9fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBpbWFnZURhdGEgPSB7XHJcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICAgIGRhdGE6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmKHR5cGUgPT0gQy5URVhUVVJFX1RZUEUuRkxPQVQpe1xyXG4gICAgICAgICAgICBpbWFnZURhdGEuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkod2lkdGgqaGVpZ2h0KjQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRklYTUU6IFdlIHNob3VsZCBhbGxvY2F0ZSBVaW50OENsYW1wZWRBcnJheSBoZXJlIGluc3RlYWRcclxuICAgICAgICAgICAgLy8gQnV0IFVpbnQ4Q2xhbXBlZEFycmF5IGNhbid0IGJlIGFsbG9jYXRlZCBpbiBDaHJvbWUgaW5zaWRlIGEgV2ViIFdvcmtlclxyXG4gICAgICAgICAgICAvLyBTZWUgYnVnOiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xNzY0NzlcclxuICAgICAgICAgICAgLy8gQXMgYSB3b3JrIGFyb3VuZCwgd2UgYWxsb2NhdGUgSW50MTZBcnJheSB3aGljaCByZXN1bHRzIGluIGNvcnJlY3QgY2xhbXBpbmcgb3V0c2lkZSBvZiB3ZWIgd29ya2VyXHJcbiAgICAgICAgICAgIGlmKFVpbnQ4QXJyYXkgPT0gVWludDhDbGFtcGVkQXJyYXkpXHJcbiAgICAgICAgICAgICAgICBpbWFnZURhdGEuZGF0YSA9IG5ldyBJbnQxNkFycmF5KHdpZHRoKmhlaWdodCo0KTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgaW1hZ2VEYXRhLmRhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGgqaGVpZ2h0KjQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pbWFnZURhdGEgPSBpbWFnZURhdGE7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9ub3RpZnlDaGFuZ2VkKCk7XHJcbn07XHJcblxyXG4vKiogQHBhcmFtIHtPYmplY3R9IHYgKi9cclxuSW1hZ2VEYXRhVGV4dHVyZUVudHJ5LnByb3RvdHlwZS5zZXRJbWFnZURhdGEgPSBmdW5jdGlvbih2KSB7XHJcbiAgICB0aGlzLl91cGRhdGVJbWFnZURhdGEodik7XHJcbiAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgQy5EQVRBX0VOVFJZX1NUQVRFLkNIQU5HRURfVkFMVUUpO1xyXG4gICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcclxufTtcclxuXHJcbkltYWdlRGF0YVRleHR1cmVFbnRyeS5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9pbWFnZURhdGEgJiYgdGhpcy5faW1hZ2VEYXRhLndpZHRoIHx8IDA7XHJcbn07XHJcblxyXG5JbWFnZURhdGFUZXh0dXJlRW50cnkucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ltYWdlRGF0YSAmJiB0aGlzLl9pbWFnZURhdGEuaGVpZ2h0IHx8IDA7XHJcbn07XHJcblxyXG4vKiogQHJldHVybiB7SW1hZ2VEYXRhfSAqL1xyXG5JbWFnZURhdGFUZXh0dXJlRW50cnkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faW1hZ2VEYXRhO1xyXG59O1xyXG5cclxuLyoqIEByZXR1cm4ge1NhbXBsZXJDb25maWd9ICovXHJcbkltYWdlRGF0YVRleHR1cmVFbnRyeS5wcm90b3R5cGUuZ2V0U2FtcGxlckNvbmZpZyA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpcy5fc2FtcGxlckNvbmZpZztcclxufTtcclxuXHJcbi8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXHJcbkltYWdlRGF0YVRleHR1cmVFbnRyeS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiAxO1xyXG59O1xyXG5JbWFnZURhdGFUZXh0dXJlRW50cnkucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuXHJcbi8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXHJcbkltYWdlRGF0YVRleHR1cmVFbnRyeS5wcm90b3R5cGUuZ2V0SXRlcmF0ZUNvdW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gMTtcclxufTtcclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBEYXRhQ2hhbmdlTm90aWZpZXJcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuLyoqXHJcbiAqIFVzZWQgdG8gbGlzdGVuIHRvIG1vZGlmaWNhdGlvbnMgb2YgYW55IERhdGFFbnRyeSBjb25uZWN0ZWQgdG8gYW4gWGZsb3cgZ3JhcGguXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIERhdGFDaGFuZ2VOb3RpZmllciA9IHtcclxuICAgIF9saXN0ZW5lcnM6IFtdXHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtmdW5jdGlvbihEYXRhRW50cnksIEMuREFUQV9FTlRSWV9TVEFURSl9IGNhbGxiYWNrXHJcbiAqL1xyXG5EYXRhQ2hhbmdlTm90aWZpZXIuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihjYWxsYmFjayl7XHJcbiAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtmdW5jdGlvbihEYXRhRW50cnksIEMuREFUQV9FTlRSWV9TVEFURSl9IGNhbGxiYWNrXHJcbiAqL1xyXG5EYXRhQ2hhbmdlTm90aWZpZXIucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihjYWxsYmFjayl7XHJcbiAgICBBcnJheS5lcmFzZSh0aGlzLl9saXN0ZW5lcnMsIGNhbGxiYWNrKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0RhdGFFbnRyeX0gZGF0YUVudHJ5XHJcbiAqIEBwYXJhbSB7Qy5EQVRBX0VOVFJZX1NUQVRFfSBub3RpZmljYXRpb25cclxuICovXHJcbmZ1bmN0aW9uIG5vdGlmeUxpc3RlbmVycyhkYXRhRW50cnksIG5vdGlmaWNhdGlvbil7XHJcbiAgICB2YXIgaTtcclxuICAgIC8vIEdsb2JhbCBub3RpZmljYXRpb25zXHJcbiAgICBmb3IoaSA9IDA7IGkgPCBEYXRhQ2hhbmdlTm90aWZpZXIuX2xpc3RlbmVycy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgRGF0YUNoYW5nZU5vdGlmaWVyLl9saXN0ZW5lcnNbaV0oZGF0YUVudHJ5LCBub3RpZmljYXRpb24pO1xyXG4gICAgfVxyXG4gICAgLy8gSW50ZXJuYWwgYW5kIGV4dGVybmFsIGxpc3RlbmVyc1xyXG4gICAgZm9yKGkgPSAwOyBpIDwgZGF0YUVudHJ5Ll9saXN0ZW5lcnMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIGRhdGFFbnRyeS5fbGlzdGVuZXJzW2ldKGRhdGFFbnRyeSwgbm90aWZpY2F0aW9uKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBEYXRhRW50cnk6IERhdGFFbnRyeSxcclxuICAgIEJ1ZmZlckVudHJ5OiBCdWZmZXJFbnRyeSxcclxuICAgIFRleHR1cmVFbnRyeTogVGV4dHVyZUVudHJ5LFxyXG4gICAgSW1hZ2VEYXRhVGV4dHVyZUVudHJ5OiBJbWFnZURhdGFUZXh0dXJlRW50cnksXHJcbiAgICBTYW1wbGVyQ29uZmlnOiBTYW1wbGVyQ29uZmlnLFxyXG4gICAgRGF0YUNoYW5nZU5vdGlmaWVyOiBEYXRhQ2hhbmdlTm90aWZpZXJcclxufTtcclxuIiwidmFyIEMgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XHJcbnZhciBNYXBwaW5nID0gcmVxdWlyZShcIi4vLi4vcHJvY2Vzc2luZy9tYXBwaW5nLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi4vLi4vdXRpbHMvYXJyYXkuanNcIik7XHJcblxyXG52YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi9iYXNlLmpzXCIpO1xyXG52YXIgQ2hhbm5lbE5vZGUgPSByZXF1aXJlKFwiLi4vcHJvY2Vzc2luZy9jaGFubmVsLW5vZGUuanNcIikuQ2hhbm5lbE5vZGU7XHJcbnZhciBVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy91dGlscy5qc1wiKTtcclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBHcmFwaE5vZGVcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3Igb3RoZXIgZ3JhcGggbm9kZXNcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBhYnN0cmFjdFxyXG4gKiBAcGFyYW0ge0dyYXBofSBncmFwaCBSZWZlcmVuY2UgdG8gcGFyZW50IGdyYXBoXHJcbiAqL1xyXG52YXIgR3JhcGhOb2RlID0gZnVuY3Rpb24oKXtcclxuICAgIC8qKlxyXG4gICAgICogQWxsIG5vZGVzIHRoYXQgYWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIG5vZGVcclxuICAgICAqIEB0eXBlIGFycmF5PEdyYXBoTm9kZT5cclxuICAgICAqKi9cclxuICAgIHRoaXMuX3BhcmVudHMgPSBbXTtcclxufTtcclxuXHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gSW5wdXROb2RlXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuLyoqXHJcbiAqIEFuIElucHV0Tm9kZSBpbmNsdWRlIGFuIERhdGFFbnRyeSwgYSBuYW1lIGFuZCBvdGhlciBpbmZvcm1hdGlvblxyXG4gKiBUaGlzIGNsYXNzIG1pcnJvcnMgWE1MM0QgZWxlbWVudHMgc3VjaCBhcyA8ZmxvYXQzPiwgPGludD4gb3IgPHRleHR1cmU+XHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0dyYXBofSBncmFwaFxyXG4gKiBAZXh0ZW5kcyB7R3JhcGhOb2RlfVxyXG4gKi9cclxudmFyIElucHV0Tm9kZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICBHcmFwaE5vZGUuY2FsbCh0aGlzKTtcclxuICAgIC8qKlxyXG4gICAgICogTmFtZSBvZiB0aGUgaW5wdXQgbm9kZVxyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX25hbWUgPSBcIlwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXF1ZW5jZSBrZXlcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9rZXkgPSAwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEYXRhRW50cnkgbm9kZSB0aGF0IGhvbGRzIHRoZSB2YWx1ZVxyXG4gICAgICogQHR5cGUge0RhdGFFbnRyeX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fZGF0YSA9IG51bGw7XHJcbiAgICAvKipcclxuICAgICAqIElmIHRoaXMgbm9kZXMgaXMgYSBwYXJhbWV0ZXIgd2l0aGluIGEgPGRhdGFmbG93PlxyXG4gICAgICogdGhpcyBpcyBzZXQgdG8gdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciwgb3RoZXJ3aXNlIG51bGxcclxuICAgICAqIEB0eXBlIHtudWxsfFN0cmluZ31cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3BhcmFtTmFtZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHBlcmltZW50YWwhIEFwcGx5IGRpZmZlcmVudCBvdmVycmlkZSBsb2dpYyBpbiBvcmRlclxyXG4gICAgICogdG8gcHJvcGFnYXRlIGdsb2JhbCBwYXJhbWV0ZXJzIHRvIHRoZSBzb3VyY2Ugb2YgdGhlIGdyYXBoXHJcbiAgICAgKiBDb3VsZCBiZSB1c2VkIGZvciBpbnN0YW5jZSBmb3IgTE9EIGNvbmNlcHRzLCB3aGVyZSB0aGVcclxuICAgICAqIHJlbmRlcmVyIHByb3BhZ2F0ZXMgdGhlIGRpc3RhbmNlIGFsb25nIHRoZSBncmFwaFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9wYXJhbUdsb2JhbCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogIENhY2hlIGxpc3RlbmVyIGZvciBEYXRhRW50cnlcclxuICAgICAqICBAc2VlIHtJbnB1dE5vZGUub25EYXRhQ2hhbmdlfVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9kYXRhTGlzdGVuZXIgPSB0aGlzLm9uRGF0YUNoYW5nZS5iaW5kKHRoaXMpO1xyXG59O1xyXG5CYXNlLmNyZWF0ZUNsYXNzKElucHV0Tm9kZSwgR3JhcGhOb2RlKTtcclxuXHJcbi8qKlxyXG4gKiBQcm9wYWdhdGUgZXZlbnRzIGZyb20gRGF0YUVudHJ5IHRvIHBhcmVudCBub2Rlc1xyXG4gKiBAcGFyYW0ge09iamVjdH0gbmV3VmFsdWVcclxuICogQHBhcmFtIHtDLkRBVEFfRU5UUllfU1RBVEV9IG5vdGlmaWNhdGlvblxyXG4gKi9cclxuSW5wdXROb2RlLnByb3RvdHlwZS5vbkRhdGFDaGFuZ2UgPSBmdW5jdGlvbihuZXdWYWx1ZSwgbm90aWZpY2F0aW9uKSB7XHJcbiAgICB2YXIgZG93bk5vdGU7XHJcbiAgICBzd2l0Y2gobm90aWZpY2F0aW9uKXtcclxuICAgICAgICBjYXNlIEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX1ZBTFVFOiBkb3duTm90ZSA9IEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfREFUQV9WQUxVRTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDLkRBVEFfRU5UUllfU1RBVEUuTE9BRF9TVEFSVDogZG93bk5vdGUgPSBDLlJFU1VMVF9TVEFURS5JTUFHRV9MT0FEX1NUQVJUOyBicmVhaztcclxuICAgICAgICBjYXNlIEMuREFUQV9FTlRSWV9TVEFURS5MT0FEX0VORDogZG93bk5vdGUgPSBDLlJFU1VMVF9TVEFURS5JTUFHRV9MT0FEX0VORDsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9TSVpFX1RZUEU6IGRvd25Ob3RlID0gQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkU7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQy5EQVRBX0VOVFJZX1NUQVRFLkNIQU5HRURfU0laRTogZG93bk5vdGUgPSBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX0RBVEFfU0laRTsgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDogZG93bk5vdGUgPSBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX0RBVEFfU0laRTsgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBub3RpZnlQYXJlbnRzT25DaGFuZ2VkKHRoaXMsZG93bk5vdGUpO1xyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KElucHV0Tm9kZS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XHJcbiAgICAvKiogQHBhcmFtIHtzdHJpbmd9IHYgKi9cclxuICAgIHNldDogZnVuY3Rpb24odil7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9IHY7XHJcbiAgICAgICAgbm90aWZ5UGFyZW50c09uQ2hhbmdlZCh0aGlzLCBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XHJcbiAgICAgICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcclxuICAgIH0sXHJcbiAgICAvKiogQHJldHVybiB7c3RyaW5nfSAqL1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fbmFtZTsgfVxyXG59KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnB1dE5vZGUucHJvdG90eXBlLCBcImtleVwiLCB7XHJcbiAgICAvKiogQHBhcmFtIHtudW1iZXJ9IHYgKi9cclxuICAgIHNldDogZnVuY3Rpb24odil7XHJcbiAgICAgICAgdGhpcy5fa2V5ID0gdjtcclxuICAgICAgICBub3RpZnlQYXJlbnRzT25DaGFuZ2VkKHRoaXMsIEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKTtcclxuICAgICAgICBCYXNlLl9mbHVzaFJlc3VsdENhbGxiYWNrcygpO1xyXG4gICAgfSxcclxuICAgIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9rZXk7IH1cclxufSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW5wdXROb2RlLnByb3RvdHlwZSwgXCJwYXJhbU5hbWVcIiwge1xyXG4gICAgLyoqIEBwYXJhbSB7c3RyaW5nfSB2ICovXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpe1xyXG4gICAgICAgIHRoaXMuX3BhcmFtTmFtZSA9IHY7XHJcbiAgICAgICAgbm90aWZ5UGFyZW50c09uQ2hhbmdlZCh0aGlzLCBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XHJcbiAgICAgICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcclxuICAgIH0sXHJcbiAgICAvKiogQHJldHVybiB7c3RyaW5nfSAqL1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fcGFyYW1OYW1lOyB9XHJcbn0pO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KElucHV0Tm9kZS5wcm90b3R5cGUsIFwicGFyYW1HbG9iYWxcIiwge1xyXG4gICAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gdiAqL1xyXG4gICAgc2V0OiBmdW5jdGlvbih2KXtcclxuICAgICAgICB0aGlzLl9wYXJhbUdsb2JhbCA9IHY7XHJcbiAgICAgICAgbm90aWZ5UGFyZW50c09uQ2hhbmdlZCh0aGlzLCBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XHJcbiAgICAgICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcclxuICAgIH0sXHJcbiAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX3BhcmFtR2xvYmFsOyB9XHJcbn0pO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KElucHV0Tm9kZS5wcm90b3R5cGUsIFwiZGF0YVwiLCB7XHJcbiAgICAvKiogQHBhcmFtIHtEYXRhRW50cnl9IGRhdGFFbnRyeSAqL1xyXG4gICAgc2V0OiBmdW5jdGlvbihkYXRhRW50cnkpe1xyXG4gICAgICAgIHZhciBwcmV2RGF0YUxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICBpZih0aGlzLl9kYXRhKSB7XHJcbiAgICAgICAgICAgIHByZXZEYXRhTG9hZGluZyA9IHRoaXMuX2RhdGEuX2xvYWRpbmc7XHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGEucmVtb3ZlTGlzdGVuZXIodGhpcy5fZGF0YUxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGFFbnRyeTtcclxuICAgICAgICBpZih0aGlzLl9kYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuYWRkTGlzdGVuZXIodGhpcy5fZGF0YUxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYocHJldkRhdGFMb2FkaW5nICE9IHRoaXMuX2RhdGEuX2xvYWRpbmcpe1xyXG4gICAgICAgICAgICBub3RpZnlQYXJlbnRzT25DaGFuZ2VkKHRoaXMsIHRoaXMuX2RhdGEuX2xvYWRpbmcgPyBDLlJFU1VMVF9TVEFURS5JTUFHRV9MT0FEX1NUQVJUIDpcclxuICAgICAgICAgICAgICAgIEMuUkVTVUxUX1NUQVRFLklNQUdFX0xPQURfRU5EKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcclxuICAgIH0sXHJcbiAgICAvKiogQHJldHVybiB7RGF0YUVudHJ5fSAqL1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fZGF0YTsgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBHZXR0ZXIgZm9yIGxvY2FsIHBhcmFtZXRlciBuYW1lLCByZXR1cm5zIG51bGwgaWYgdGhpcyBpcyBhIGdsb2JhbFxyXG4gKiBwYXJhbWV0ZXJcclxuICpcclxuICogQHJldHVybnMge251bGx8U3RyaW5nfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuSW5wdXROb2RlLnByb3RvdHlwZS5fZ2V0UGFyYW1OYW1lcyA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpcy5fcGFyYW1HbG9iYWwgPyBudWxsIDogdGhpcy5fcGFyYW1OYW1lO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHRlciBmb3IgZ2xvYmFsIHBhcmFtZXRlciBuYW1lLCByZXR1cm5zIG51bGwgaWYgdGhpcyBpcyBub3QgYSBnbG9iYWxcclxuICogcGFyYW1ldGVyXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtudWxsfFN0cmluZ31cclxuICogQHByaXZhdGVcclxuICovXHJcbklucHV0Tm9kZS5wcm90b3R5cGUuX2dldEdsb2JhbFBhcmFtTmFtZXMgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMuX3BhcmFtR2xvYmFsID8gdGhpcy5fcGFyYW1OYW1lIDogbnVsbDtcclxufTtcclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBEYXRhTm9kZVxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxudmFyIGNfeGZsb3dOb2RlSWQgPSAwO1xyXG5mdW5jdGlvbiBnZXRYZmxvd05vZGVJZCgpe1xyXG4gICAgcmV0dXJuICsrY194Zmxvd05vZGVJZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBEYXRhTm9kZSBpcyB0aGUgY2VudHJhbCBzdHJ1Y3R1cmUgb2YgYW4gWGZsb3cgR3JhcGguXHJcbiAqIEl0IGlzIHVzZWQgdG8gYnVpbGQgYSBkYXRhIGNvbXBvc2l0aW9uIGdyYXBoIGFzIHdlbGwgYXMgYSBkYXRhIGZsb3cuXHJcbiAqIEl0IG1pcnJvciB0aGUgPGRhdGE+IGVsZW1lbnQgb2YgWE1MM0RcclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7R3JhcGh9IGdyYXBoIENvbnRleHQgZ3JhcGhcclxuICogQHBhcmFtIHtib29sZWFufSBpc0RhdGFGbG93IGlzIHRoaXMgbm9kZSBhIGRhdGFmbG93XHJcbiAqIEBleHRlbmRzIHtHcmFwaE5vZGV9XHJcbiAqL1xyXG52YXIgRGF0YU5vZGUgPSBmdW5jdGlvbihpc0RhdGFGbG93KXtcclxuICAgIEdyYXBoTm9kZS5jYWxsKHRoaXMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFya2VyLCBpZiB0aGlzIGRhdGEgbm9kZSBpcyBleHBlY3RpbmcgZGF0YS4gWGZsb3dcclxuICAgICAqIGlzIG5vdCBtb25pdG9yaW5nIGFueSBsb2FkIGV2ZW50cy4gVGhpcyBtdXN0IGJlIHNldFxyXG4gICAgICogZnJvbSBleHRlcm5hbFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2xvYWRpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4cGVyaW1lbnRhbCEgUHJpb3JpdHkuIEhvdyBpbXBvcnRhbnQgaXMgdGhpcyBkYXRhP1xyXG4gICAgICogMDogVmVyeSBpbXBvcnRhbnRcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2xvYWRMZXZlbCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIGZvciBsb2FkaW5nIGV2ZW50czogSWYgcHJvZ3Jlc3MgbGV2ZWxcclxuICAgICAqIHJlYWNoZXMgaW5maW5pdHksIGxvYWRpbmcgZXZlbnRzIGFyZSB0cmlnZ2VyZWRcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3Byb2dyZXNzTGV2ZWwgPSBJbmZpbml0eTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdsb2JhbGx5IHVuaXF1ZSBpZFxyXG4gICAgICovXHJcbiAgICB0aGlzLmlkID0gZ2V0WGZsb3dOb2RlSWQoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElzIHRoaXMgbm9kZSBhIHByb3RvIG5vZGVcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9pc1Byb3RvTm9kZSA9IGlzRGF0YUZsb3c7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGlsZHJlbi4gSW5wdXROb2RlcyBhbmQgRGF0YU5vZGVzIChhcyBmb3VuZCBpbiBET00pXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2NoaWxkcmVuID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgRGF0YU5vZGUgdGhhdCBoYXMgYmVlbiByZWZlcmVuY2UgdmlhIHNyY1xyXG4gICAgICogQHR5cGUge0RhdGFOb2RlfVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9zb3VyY2VOb2RlID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpZWxkIHRvIGF0dGFjaCBjdXN0b20gZGF0YVxyXG4gICAgICogQHR5cGUge251bGx8T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLl91c2VyRGF0YSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmlsdGVyIHR5cGUgb2YgdGhpcyBub2RlIChrZWVwLCByZW5hbWUsIHJlbW92ZSAuLi4pXHJcbiAgICAgKiBAdHlwZSB7REFUQV9GSUxURVJfVFlQRX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fZmlsdGVyVHlwZSA9IEMuREFUQV9GSUxURVJfVFlQRS5OT05FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lIHRoZSBtYXBwaW5nXHJcbiAgICAgKiBAdHlwZSB7TWFwcGluZy5NYXBwaW5nfVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9maWx0ZXJNYXBwaW5nID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0cmluZyBpZGVudGlmaWVyIGZvciBvcGVyYXRvclxyXG4gICAgICogVE9ETzogT3BlcmF0b3IgY2xhc3NcclxuICAgICAqIEB0eXBlIHtzdHJpbmd8T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9jb21wdXRlT3BlcmF0b3IgPSBcIlwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJ1ZSwgaWYgY29tcHV0ZSBpcyBhIGRhdGFmbG93IHJlZmVyZW5jZVxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2NvbXB1dGVVc2VzRGF0YWZsb3cgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHBpbmcgZm9yIGlucHV0IG9mIG9wZXJhdG9yLFxyXG4gICAgICogZS5nLiAocG9zaXRpb24sIHRleGNvb3JkKSBvciAoe3Bvc2l0aW9uOiBwb3MsIHRleGNvb3JkOiB1dn0pXHJcbiAgICAgKiBAdHlwZSB7TWFwcGluZ31cclxuICAgICAqL1xyXG4gICAgdGhpcy5fY29tcHV0ZUlucHV0TWFwcGluZyA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBwaW5nIGZvciBvdXRwdXQgb2Ygb3BlcmF0b3IsXHJcbiAgICAgKiBlLmcuIChwb3NpdGlvbiwgdGV4Y29vcmQpID0gLi4uIG9yIHtwb3NpdGlvbjogcG9zLCB0ZXhjb29yZDogdXZ9ID0gLi4uXHJcbiAgICAgKiBAdHlwZSB7TWFwcGluZ31cclxuICAgICAqL1xyXG4gICAgdGhpcy5fY29tcHV0ZU91dHB1dE1hcHBpbmcgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgZGF0YWZsb3cgbm9kZSBoYXMgYmVlbiByZXNvbHZlZCwgdGhpc1xyXG4gICAgICogZW50cnkgaXMgc2V0XHJcbiAgICAgKiBAdHlwZSB7RGF0YU5vZGV9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2RhdGFmbG93Tm9kZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCAob3B0aW1pemVkKSB2ZXJzaW9uIG9mIHRoaXMgZGF0YSBub2RlXHJcbiAgICAgKiBAdHlwZSB7Q2hhbm5lbE5vZGV9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2NoYW5uZWxOb2RlID0gbmV3IENoYW5uZWxOb2RlKHRoaXMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIG9mIGNhY2hlZCBjaGFubmVsIG5vZGVzIGZvciBkYXRhZmxvdyBpbnN0YW5jZXMgd2l0aCB2YXJ5aW5nXHJcbiAgICAgKiBpbnB1dCBhcmd1bWVudHMgKHNwZWNpYWxpemVkIG5vZGVzKVxyXG4gICAgICogVE9ETzogVXNlIFdlYWtNYXA/XHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIENoYW5uZWxOb2RlPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fc3Vic3RpdHV0aW9uTm9kZXMgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhY2hlZCB2ZXJzaW9uIG9mIGxvY2FsIHBhcmFtIG5hbWVzIGNvbGxlY3RlZCBmcm9tXHJcbiAgICAgKiBjaGlsZHJlblxyXG4gICAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9wYXJhbU5hbWVzID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhY2hlZCB2ZXJzaW9uIG9mIGdsb2JhbCBwYXJhbSBuYW1lcyBjb2xsZWN0ZWQgZnJvbVxyXG4gICAgICogY2hpbGRyZW5cclxuICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fZ2xvYmFsUGFyYW1OYW1lcyA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQbGF0Zm9ybSwgdGhpcyBkYXRhIG5vZGUgc2hvdWxkIGJlIGV4ZWN1dGVkIG9uXHJcbiAgICAgKiBUT0RPOiBUaGlzIHNob3VsZCBiZSBpbXBsaWNpdCwgbm90IGV4cGxpY2l0XHJcbiAgICAgKiBAdHlwZSB7bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fcGxhdGZvcm0gPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2JzZXJ2ZXJzIG9mIHRoZSBub2RlJ3MgQy5SRVNVTFRfU1RBVEVcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fbGlzdGVuZXJzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnNlcnZlcnMgb2YgdGhlIG5vZGUncyBwcm9ncmVzcyBsZXZlbFxyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9sb2FkTGlzdGVuZXJzID0gW107XHJcblxyXG59O1xyXG5CYXNlLmNyZWF0ZUNsYXNzKERhdGFOb2RlLCBHcmFwaE5vZGUpO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhTm9kZS5wcm90b3R5cGUsIFwic291cmNlTm9kZVwiLCB7XHJcbiAgICAvKiogQHBhcmFtIHs/RGF0YU5vZGV9IG5ld1NvdXJjZU5vZGUgKi9cclxuICAgIHNldDogZnVuY3Rpb24obmV3U291cmNlTm9kZSl7XHJcbiAgICAgICAgcmVwbGFjZU5vZGVJbkhpZXJhcmNoeSh0aGlzLCBcIl9zb3VyY2VOb2RlXCIsIG5ld1NvdXJjZU5vZGUpO1xyXG4gICAgICAgIHVwZGF0ZVByb2dyZXNzTGV2ZWwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5ub3RpZnkoQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xyXG4gICAgICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XHJcbiAgICB9LFxyXG4gICAgLyoqIEByZXR1cm4gez9EYXRhTm9kZX0gKi9cclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX3NvdXJjZU5vZGU7IH1cclxufSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YU5vZGUucHJvdG90eXBlLCBcImRhdGFmbG93Tm9kZVwiLCB7XHJcbiAgICAvKiogQHBhcmFtIHs/RGF0YU5vZGV9IG5ld0RhdGFmbG93Tm9kZSAqL1xyXG4gICAgc2V0OiBmdW5jdGlvbihuZXdEYXRhZmxvd05vZGUpe1xyXG4gICAgICAgIGlmKG5ld0RhdGFmbG93Tm9kZSAmJiAhdGhpcy5fY29tcHV0ZVVzZXNEYXRhZmxvdykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IGRhdGFmbG93Tm9kZSB3aGVuIGNvbXB1dGUgZG9lc24ndCB1c2UgZGF0YWZsb3cuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXBsYWNlTm9kZUluSGllcmFyY2h5KHRoaXMsIFwiX2RhdGFmbG93Tm9kZVwiLCBuZXdEYXRhZmxvd05vZGUpO1xyXG4gICAgICAgIHVwZGF0ZVByb2dyZXNzTGV2ZWwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5ub3RpZnkoQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xyXG4gICAgICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XHJcbiAgICB9LFxyXG4gICAgLyoqIEByZXR1cm4gez9EYXRhTm9kZX0gKi9cclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX2RhdGFmbG93Tm9kZTsgfVxyXG59KTtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YU5vZGUucHJvdG90eXBlLCBcInVzZXJEYXRhXCIsIHtcclxuICAgIC8qKiBAcGFyYW0gez9EYXRhTm9kZX0gdiAqL1xyXG4gICAgc2V0OiBmdW5jdGlvbih2KXtcclxuICAgICAgICB0aGlzLl91c2VyRGF0YSA9IHY7XHJcbiAgICB9LFxyXG4gICAgLyoqIEByZXR1cm4gez9EYXRhTm9kZX0gKi9cclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX3VzZXJEYXRhOyB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFNldCAoZnJvbSBleHRlcm5hbCkgaWYgbW9yZSBkYXRhIGlzIGV4cGVjdGVkLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvYWRpbmdcclxuICovXHJcbkRhdGFOb2RlLnByb3RvdHlwZS5zZXRMb2FkaW5nID0gZnVuY3Rpb24obG9hZGluZyl7XHJcbiAgICBpZih0aGlzLl9sb2FkaW5nICE9IGxvYWRpbmcpe1xyXG4gICAgICAgIHRoaXMuX2xvYWRpbmcgPSBsb2FkaW5nO1xyXG4gICAgICAgIHRoaXMuX2NoYW5uZWxOb2RlLnNldFN0cnVjdHVyZU91dE9mU3luYygpO1xyXG4gICAgICAgIHRoaXMuX2NoYW5uZWxOb2RlLmxvYWRpbmcgPSBsb2FkaW5nO1xyXG4gICAgICAgIGZvciAodmFyIHN1YiBpbiB0aGlzLl9zdWJzdGl0dXRpb25Ob2Rlcykge1xyXG4gICAgICAgICAgICB2YXIgc3ViTm9kZSA9IHRoaXMuX3N1YnN0aXR1dGlvbk5vZGVzW3N1Yl07XHJcbiAgICAgICAgICAgIHN1Yk5vZGUuc2V0U3RydWN0dXJlT3V0T2ZTeW5jKCk7XHJcbiAgICAgICAgICAgIHN1Yk5vZGUubG9hZGluZyA9IGxvYWRpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVwZGF0ZVByb2dyZXNzTGV2ZWwodGhpcyk7XHJcbiAgICAgICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGlmIHRoaXMgb3IgYW55IGNoaWxkIG5vZGUgaXMgbG9hZGluZ1xyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkRhdGFOb2RlLnByb3RvdHlwZS5pc1N1YnRyZWVMb2FkaW5nID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLl9wcm9ncmVzc0xldmVsID09IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogQHJldHVybnMge051bWJlcn1cclxuICovXHJcbkRhdGFOb2RlLnByb3RvdHlwZS5nZXRQcm9ncmVzc0xldmVsID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLl9wcm9ncmVzc0xldmVsO1xyXG59O1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhTm9kZS5wcm90b3R5cGUsIFwiZmlsdGVyVHlwZVwiLCB7XHJcbiAgICAvKiogQHBhcmFtIHtDLkRBVEFfRklMVEVSX1RZUEV9IHYgKi9cclxuICAgIHNldDogZnVuY3Rpb24odil7XHJcbiAgICAgICAgdGhpcy5fZmlsdGVyVHlwZSA9IHY7XHJcbiAgICAgICAgdGhpcy5ub3RpZnkoIEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKTtcclxuICAgICAgICBCYXNlLl9mbHVzaFJlc3VsdENhbGxiYWNrcygpO1xyXG4gICAgfSxcclxuICAgIC8qKiBAcmV0dXJuIHtDLkRBVEFfRklMVEVSX1RZUEV9ICovXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9maWx0ZXJUeXBlOyB9XHJcbn0pO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFOb2RlLnByb3RvdHlwZSwgXCJmaWx0ZXJNYXBwaW5nXCIsIHtcclxuICAgIC8qKiBAcGFyYW0ge01hcHBpbmd9IHYgKi9cclxuICAgIHNldDogZnVuY3Rpb24odil7XHJcbiAgICAgICAgc3dhcE1hcHBpbmcodGhpcywgXCJfZmlsdGVyTWFwcGluZ1wiLCB2KTtcclxuICAgICAgICB0aGlzLm5vdGlmeSggQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xyXG4gICAgICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XHJcbiAgICB9LFxyXG4gICAgLyoqIEByZXR1cm4ge01hcHBpbmd9ICovXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9maWx0ZXJNYXBwaW5nOyB9XHJcbn0pO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFOb2RlLnByb3RvdHlwZSwgXCJjb21wdXRlT3BlcmF0b3JcIiwge1xyXG4gICAgLyoqIEBwYXJhbSB7c3RyaW5nfSB2ICovXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpe1xyXG4gICAgICAgIHRoaXMuX2NvbXB1dGVPcGVyYXRvciA9IHY7XHJcbiAgICAgICAgdGhpcy5fY29tcHV0ZVVzZXNEYXRhZmxvdyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubm90aWZ5KCBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XHJcbiAgICAgICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcclxuICAgIH0sXHJcbiAgICAvKiogQHJldHVybiB7c3RyaW5nfSAqL1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fY29tcHV0ZVVzZXNEYXRhZmxvdyA/IG51bGwgOiB0aGlzLl9jb21wdXRlT3BlcmF0b3I7IH1cclxufSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YU5vZGUucHJvdG90eXBlLCBcImNvbXB1dGVEYXRhZmxvd1VybFwiLCB7XHJcbiAgICAvKiogQHBhcmFtIHtzdHJpbmd9IHYgKi9cclxuICAgIHNldDogZnVuY3Rpb24odil7XHJcbiAgICAgICAgdGhpcy5fY29tcHV0ZU9wZXJhdG9yID0gdjtcclxuICAgICAgICB0aGlzLl9jb21wdXRlVXNlc0RhdGFmbG93ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm5vdGlmeSggQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xyXG4gICAgICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XHJcbiAgICB9LFxyXG4gICAgLyoqIEByZXR1cm4ge3N0cmluZ30gKi9cclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX2NvbXB1dGVVc2VzRGF0YWZsb3cgPyB0aGlzLl9jb21wdXRlT3BlcmF0b3IgOiBudWxsOyB9XHJcbn0pO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFOb2RlLnByb3RvdHlwZSwgXCJjb21wdXRlSW5wdXRNYXBwaW5nXCIsIHtcclxuICAgIC8qKiBAcGFyYW0ge01hcHBpbmd9IHYgKi9cclxuICAgIHNldDogZnVuY3Rpb24odil7XHJcbiAgICAgICAgc3dhcE1hcHBpbmcodGhpcywgXCJfY29tcHV0ZUlucHV0TWFwcGluZ1wiLCB2KTtcclxuICAgICAgICB0aGlzLm5vdGlmeSggQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xyXG4gICAgICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XHJcbiAgICB9LFxyXG4gICAgLyoqIEByZXR1cm4ge01hcHBpbmd9ICovXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9jb21wdXRlSW5wdXRNYXBwaW5nOyB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YU5vZGUucHJvdG90eXBlLCBcImNvbXB1dGVPdXRwdXRNYXBwaW5nXCIsIHtcclxuICAgIC8qKiBAcGFyYW0ge01hcHBpbmd9IHYgKi9cclxuICAgIHNldDogZnVuY3Rpb24odil7XHJcbiAgICAgICAgc3dhcE1hcHBpbmcodGhpcywgXCJfY29tcHV0ZU91dHB1dE1hcHBpbmdcIiwgdik7XHJcbiAgICAgICAgdGhpcy5ub3RpZnkoIEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKTtcclxuICAgICAgICBCYXNlLl9mbHVzaFJlc3VsdENhbGxiYWNrcygpO1xyXG4gICAgfSxcclxuICAgIC8qKiBAcmV0dXJuIHtNYXBwaW5nfSAqL1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fY29tcHV0ZU91dHB1dE1hcHBpbmc7IH1cclxufSk7XHJcblxyXG4vL25vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcclxuRGF0YU5vZGUucHJvdG90eXBlLmlzUHJvdG9Ob2RlID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLl9pc1Byb3RvTm9kZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0dyYXBoTm9kZX0gY2hpbGRcclxuICovXHJcbkRhdGFOb2RlLnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKXtcclxuICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGQpO1xyXG4gICAgYWRkUGFyZW50KHRoaXMsIGNoaWxkKTtcclxuICAgIHVwZGF0ZVByb2dyZXNzTGV2ZWwodGhpcyk7XHJcbiAgICB0aGlzLm5vdGlmeSggQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xyXG4gICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcclxufTtcclxuLyoqXHJcbiAqIEBwYXJhbSB7R3JhcGhOb2RlfSBjaGlsZFxyXG4gKi9cclxuRGF0YU5vZGUucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24oY2hpbGQpe1xyXG4gICAgQXJyYXkuZXJhc2UodGhpcy5fY2hpbGRyZW4sIGNoaWxkKTtcclxuICAgIHJlbW92ZVBhcmVudCh0aGlzLCBjaGlsZCk7XHJcbiAgICB1cGRhdGVQcm9ncmVzc0xldmVsKHRoaXMpO1xyXG4gICAgdGhpcy5ub3RpZnkoIEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKTtcclxuICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtHcmFwaE5vZGV9IGNoaWxkXHJcbiAqIEBwYXJhbSB7R3JhcGhOb2RlfSBiZWZvcmVOb2RlXHJcbiAqL1xyXG5EYXRhTm9kZS5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24oY2hpbGQsIGJlZm9yZU5vZGUpe1xyXG4gICAgdmFyIGlkeCA9IHRoaXMuX2NoaWxkcmVuLmluZGV4T2YoYmVmb3JlTm9kZSk7XHJcbiAgICBpZihpZHggPT0gLTEpXHJcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4uc3BsaWNlKGlkeCwgMCwgY2hpbGQpO1xyXG4gICAgYWRkUGFyZW50KHRoaXMsIGNoaWxkKTtcclxuICAgIC8vIFRPRE86IE5leHQgdGhyZWUgY2FsbHMgb24gYWxsIHN0cnVjdHVyYWwgY2hhbmdlcy4gQWRkIE1ldGhvZFxyXG4gICAgdXBkYXRlUHJvZ3Jlc3NMZXZlbCh0aGlzKTtcclxuICAgIHRoaXMubm90aWZ5KCBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XHJcbiAgICBCYXNlLl9mbHVzaFJlc3VsdENhbGxiYWNrcygpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIGNsZWFyIGFsbCByZWZlcmVuY2VzIGFuZCByZW1vdmUgY2hpbGRyZW5cclxuICovXHJcbkRhdGFOb2RlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCl7XHJcbiAgICBmb3IodmFyIGkgPTA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgcmVtb3ZlUGFyZW50KHRoaXMsIHRoaXMuX2NoaWxkcmVuW2ldKTtcclxuICAgIH1cclxuICAgIHRoaXMuX2NoaWxkcmVuID0gW107XHJcbiAgICB0aGlzLl9kYXRhZmxvd05vZGUgJiYgdGhpcy5fZGF0YWZsb3dOb2RlLnJlbW92ZVBhcmVudCh0aGlzKTtcclxuICAgIHRoaXMuX2RhdGFmbG93Tm9kZSA9IG51bGw7XHJcbiAgICB0aGlzLl9jaGFubmVsTm9kZS5kZWNyZWFzZVJlZigpO1xyXG4gICAgY2xlYXJTdWJzdGl0dXRpb25Ob2Rlcyh0aGlzKTtcclxuICAgIHVwZGF0ZVByb2dyZXNzTGV2ZWwodGhpcyk7XHJcbiAgICB0aGlzLm5vdGlmeSggQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xyXG4gICAgdGhpcy5fbGlzdGVuZXJzID0gW107XHJcbiAgICBkZWxldGUgdGhpcy5fdXNlckRhdGE7XHJcbiAgICBkZWxldGUgdGhpcy5fY2hhbm5lbE5vZGU7XHJcbiAgICBkZWxldGUgdGhpcy5fZGF0YWZsb3dOb2RlO1xyXG4gICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcclxufTtcclxuXHJcbkRhdGFOb2RlLnByb3RvdHlwZS5yZW1vdmVQYXJlbnQgPSBmdW5jdGlvbihwYXJlbnQpIHtcclxuICAgIEFycmF5LmVyYXNlKHRoaXMuX3BhcmVudHMsIHBhcmVudCk7XHJcbiAgICB1cGRhdGVQcm9ncmVzc0xldmVsKHRoaXMpO1xyXG4gICAgdGhpcy5ub3RpZnkoIEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKTtcclxuICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XHJcbn07XHJcblxyXG4vL25vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcclxuLyoqXHJcbiAqIERldGFjaCB0aGlzIERhdGFOb2RlIGZyb20gYWxsIGNvbm5lY3Rpb25zLCBpbmNsdWRpbmcgc291cmNlLSBhbmQgcHJvdG8tbm9kZSByZWZlcmVuY2VzXHJcbiAqL1xyXG5EYXRhTm9kZS5wcm90b3R5cGUuZGV0YWNoRnJvbVBhcmVudHMgPSBmdW5jdGlvbigpe1xyXG4gICAgZm9yKHZhciBpID0wOyBpIDwgdGhpcy5fcGFyZW50cy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudHNbaV07XHJcbiAgICAgICAgaWYocGFyZW50Ll9zb3VyY2VOb2RlID09IHRoaXMpXHJcbiAgICAgICAgICAgIHBhcmVudC5zb3VyY2VOb2RlID0gbnVsbDtcclxuICAgICAgICBlbHNlIGlmKHBhcmVudC5fZGF0YWZsb3dOb2RlID09IHRoaXMpe1xyXG4gICAgICAgICAgICBwYXJlbnQuZGF0YWZsb3dOb2RlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuX2NoaWxkcmVuID0gW107XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0cyBwbGF0Zm9ybSBvZiBhIERhdGFOb2RlLiBJZiBfcGxhdGZvcm0gaXMgZGVmaW5lZCwgaXQgd2lsbCBvdmVycmlkZSB0aGUgZGVmYXVsdCBwbGF0Zm9ybSBzZXR0aW5nIG9mXHJcbiAqIGFuIFhmbG93IGdyYXBoLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ3xDLlBMQVRGT1JNfG51bGx9IHBsYXRmb3JtU3JjXHJcbiAqL1xyXG5EYXRhTm9kZS5wcm90b3R5cGUuc2V0UGxhdGZvcm0gPSBmdW5jdGlvbihwbGF0Zm9ybVNyYykge1xyXG4gICAgaWYgKHR5cGVvZiBwbGF0Zm9ybVNyYyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBpZiAocGxhdGZvcm1TcmMgPT09IFwiY2xcIikge1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybSA9IEMuUExBVEZPUk0uQ0w7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBsYXRmb3JtU3JjID09PSBcImdsXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm0gPSBDLlBMQVRGT1JNLkdMU0w7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBsYXRmb3JtU3JjID09PSBcImpzXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm0gPSBDLlBMQVRGT1JNLkpBVkFTQ1JJUFQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICghaXNOYU4ocGFyc2VGbG9hdChwbGF0Zm9ybVNyYykpICYmIGlzRmluaXRlKHBsYXRmb3JtU3JjKSkge1xyXG4gICAgICAgIHRoaXMuX3BsYXRmb3JtID0gcGxhdGZvcm1TcmM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX3BsYXRmb3JtID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm5vdGlmeShDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XHJcbiAgICBCYXNlLl9mbHVzaFJlc3VsdENhbGxiYWNrcygpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdFxyXG4gKi9cclxudmFyIGZpbHRlclBhcnNlciA9IC9eKFtBLVphLXpcXHNdKilcXCgoW14oKV0rKVxcKSQvO1xyXG5cclxuLyoqXHJcbiAqIFNldCBmaWx0ZXIgYnkgc3RyaW5nXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWx0ZXJTdHJpbmdcclxuICovXHJcbkRhdGFOb2RlLnByb3RvdHlwZS5zZXRGaWx0ZXIgPSBmdW5jdGlvbihmaWx0ZXJTdHJpbmcpe1xyXG4gICAgZmlsdGVyU3RyaW5nID0gZmlsdGVyU3RyaW5nIHx8IFwiXCI7XHJcbiAgICB2YXIgbmV3VHlwZSA9IEMuREFUQV9GSUxURVJfVFlQRS5SRU5BTUU7XHJcbiAgICB2YXIgbmV3TWFwcGluZyA9IG51bGw7XHJcbiAgICBpZihmaWx0ZXJTdHJpbmcpe1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBmaWx0ZXJTdHJpbmcudHJpbSgpLm1hdGNoKGZpbHRlclBhcnNlcik7XHJcbiAgICAgICAgaWYocmVzdWx0KXtcclxuICAgICAgICAgICAgdmFyIHR5cGUgPSByZXN1bHRbMV0udHJpbSgpO1xyXG4gICAgICAgICAgICBzd2l0Y2godHlwZSl7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwia2VlcFwiOiBuZXdUeXBlID0gQy5EQVRBX0ZJTFRFUl9UWVBFLktFRVA7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInJlbW92ZVwiOiBuZXdUeXBlID0gQy5EQVRBX0ZJTFRFUl9UWVBFLlJFTU9WRTsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVuYW1lXCI6IG5ld1R5cGUgPSBDLkRBVEFfRklMVEVSX1RZUEUuUkVOQU1FOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgQmFzZS5ub3RpZnlFcnJvcihcIlVua25vd24gZmlsdGVyIHR5cGU6XCIgKyB0eXBlLCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXdNYXBwaW5nID0gTWFwcGluZy5NYXBwaW5nLnBhcnNlKHJlc3VsdFsyXSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIEJhc2Uubm90aWZ5RXJyb3IoXCJDb3VsZCBub3QgcGFyc2UgZmlsdGVyICdcIiArIGZpbHRlclN0cmluZyArIFwiJ1wiLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZighbmV3TWFwcGluZyl7XHJcbiAgICAgICAgLy8gVE9ETyBSZW1vdmUgdGhpcz8gKE1hcHBpbmcgY2FuIGJlIG51bGwgZnJvbSBub3cgb24pXHJcbiAgICAgICAgbmV3TWFwcGluZyA9IG5ldyBNYXBwaW5nLk9yZGVyTWFwcGluZygpO1xyXG4gICAgfVxyXG4gICAgc3dhcE1hcHBpbmcodGhpcywgXCJfZmlsdGVyTWFwcGluZ1wiLCBuZXdNYXBwaW5nKTtcclxuICAgIHRoaXMuX2ZpbHRlclR5cGUgPSBuZXdUeXBlO1xyXG4gICAgdGhpcy5ub3RpZnkoIEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKTtcclxuICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XHJcbn07XHJcblxyXG52YXIgY29tcHV0ZVBhcnNlciA9IC9eKChbXj1dKylcXD0pPyhbXicoXSsoJ1teJ10rJyk/W14nKF0rKShcXCgoW14oKV0qKT9cXCkpPyQvO1xyXG52YXIgYnJhY2tldHNQYXJzZXIgPSAvXlxcKChbXigpXSopXFwpJC87XHJcbnZhciBkYXRhZmxvd1BhcnNlciA9IC9eZGF0YWZsb3dcXFsnKFteJ10rKSdcXF0kLztcclxuXHJcbi8vbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xyXG4vKipcclxuICogSWYgdGhlIGNvbXB1dGUgc3RyaW5nIGNvbnRhaW5zIGEgcmVmZXJlbmNlIHRvIGFuIGV4dGVybmFsIGRhdGFmbG93LFxyXG4gKiB0aGUgcGFyc2VyIHJldHVybnMgaXRzIFVSTC4gTnVsbCwgb3RoZXJ3aXNlXHJcbiAqIEBwYXJhbSBjb21wdXRlU3RyaW5nXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH1cclxuICovXHJcbnZhciBnZXRDb21wdXRlRGF0YWZsb3dVcmwgPSBmdW5jdGlvbihjb21wdXRlU3RyaW5nKXtcclxuICAgIGNvbXB1dGVTdHJpbmcgPSBjb21wdXRlU3RyaW5nIHx8IFwiXCI7XHJcbiAgICB2YXIgcmVzdWx0ID0gY29tcHV0ZVN0cmluZy50cmltKCkubWF0Y2goY29tcHV0ZVBhcnNlcik7XHJcbiAgICBpZihyZXN1bHQpe1xyXG4gICAgICAgIGlmKHJlc3VsdCA9IHJlc3VsdFszXS50cmltKCkubWF0Y2goZGF0YWZsb3dQYXJzZXIpKXtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFsxXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgY29tcHV0ZSBieSBzdHJpbmdcclxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXB1dGVTdHJpbmdcclxuICovXHJcbkRhdGFOb2RlLnByb3RvdHlwZS5zZXRDb21wdXRlID0gZnVuY3Rpb24oY29tcHV0ZVN0cmluZyl7XHJcbiAgICBjb21wdXRlU3RyaW5nID0gY29tcHV0ZVN0cmluZyB8fCBcIlwiO1xyXG4gICAgdmFyIG5ld09wZXJhdG9yID0gXCJcIjtcclxuICAgIHZhciBpbnB1dE1hcHBpbmcgPSBudWxsLCBvdXRwdXRNYXBwaW5nID0gbnVsbDtcclxuICAgIHZhciByZXN1bHQgPSBjb21wdXRlU3RyaW5nLnRyaW0oKS5tYXRjaChjb21wdXRlUGFyc2VyKTtcclxuICAgIGlmKHJlc3VsdCl7XHJcbiAgICAgICAgdmFyIG91dHB1dCA9IHJlc3VsdFsyXSA/IHJlc3VsdFsyXS50cmltKCkgOiBcIlwiO1xyXG4gICAgICAgIG5ld09wZXJhdG9yID0gcmVzdWx0WzNdLnRyaW0oKTtcclxuICAgICAgICB2YXIgaW5wdXQgPSByZXN1bHRbNl0gPyByZXN1bHRbNl0udHJpbSgpIDogXCJcIjtcclxuICAgICAgICBpZihyZXN1bHQgPSBvdXRwdXQubWF0Y2goYnJhY2tldHNQYXJzZXIpKXtcclxuICAgICAgICAgICAgb3V0cHV0ID0gcmVzdWx0WzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihpbnB1dClcclxuICAgICAgICAgICAgaW5wdXRNYXBwaW5nID0gTWFwcGluZy5NYXBwaW5nLnBhcnNlKGlucHV0LCB0aGlzKTtcclxuICAgICAgICBpZihvdXRwdXQpXHJcbiAgICAgICAgICAgIG91dHB1dE1hcHBpbmcgPSBNYXBwaW5nLk1hcHBpbmcucGFyc2Uob3V0cHV0LCB0aGlzKTtcclxuXHJcbiAgICAgICAgaWYocmVzdWx0ID0gbmV3T3BlcmF0b3IubWF0Y2goZGF0YWZsb3dQYXJzZXIpKXtcclxuICAgICAgICAgICAgdGhpcy5fY29tcHV0ZVVzZXNEYXRhZmxvdyA9IHRydWU7XHJcbiAgICAgICAgICAgIG5ld09wZXJhdG9yID0gcmVzdWx0WzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICB0aGlzLl9jb21wdXRlVXNlc0RhdGFmbG93ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2RhdGFmbG93Tm9kZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmKGNvbXB1dGVTdHJpbmcpe1xyXG4gICAgICAgIEJhc2Uubm90aWZ5RXJyb3IoXCJFcnJvciBwYXJzaW5nIENvbXB1dGUgdmFsdWUgJ1wiICsgY29tcHV0ZVN0cmluZyArIFwiJ1wiLCB0aGlzKTtcclxuICAgIH1cclxuICAgIHN3YXBNYXBwaW5nKHRoaXMsIFwiX2NvbXB1dGVJbnB1dE1hcHBpbmdcIiwgaW5wdXRNYXBwaW5nKTtcclxuICAgIHN3YXBNYXBwaW5nKHRoaXMsIFwiX2NvbXB1dGVPdXRwdXRNYXBwaW5nXCIsIG91dHB1dE1hcHBpbmcpO1xyXG4gICAgdGhpcy5fY29tcHV0ZU9wZXJhdG9yID0gbmV3T3BlcmF0b3I7XHJcbiAgICB0aGlzLm5vdGlmeSggQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xyXG4gICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBOb3RpZmllcyBEYXRhTm9kZSBhYm91dCBhIGNoYW5nZS4gTm90aWZpY2F0aW9uIHdpbGwgYmUgZm9yd2FyZGVkIHRvIHBhcmVudHMsIGlmIG5lY2Vzc2FyeVxyXG4gKiBAcGFyYW0ge0MuUkVTVUxUX1NUQVRFfSBjaGFuZ2VUeXBlXHJcbiAqIEBwYXJhbSB7R3JhcGhOb2RlP30gc2VuZGVyTm9kZVxyXG4gKi9cclxuRGF0YU5vZGUucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uKGNoYW5nZVR5cGUsIHNlbmRlck5vZGUpe1xyXG4gICAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXHJcbiAgICBzd2l0Y2goY2hhbmdlVHlwZSkge1xyXG4gICAgICAgIGNhc2UgQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkU6XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcmFtTmFtZXMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9nbG9iYWxQYXJhbU5hbWVzID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fY2hhbm5lbE5vZGUuc2V0U3RydWN0dXJlT3V0T2ZTeW5jKCk7XHJcbiAgICAgICAgICAgIGNsZWFyU3Vic3RpdHV0aW9uTm9kZXModGhpcyk7XHJcbiAgICAgICAgICAgIG5vdGlmeVBhcmVudHNPbkNoYW5nZWQodGhpcywgY2hhbmdlVHlwZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIEMuUkVTVUxUX1NUQVRFLklNQUdFX0xPQURfU1RBUlQ6XHJcbiAgICAgICAgY2FzZSBDLlJFU1VMVF9TVEFURS5JTUFHRV9MT0FEX0VORDpcclxuICAgICAgICAgICAgdXBkYXRlUHJvZ3Jlc3NMZXZlbCh0aGlzKTtcclxuICAgICAgICAgICAgaWYoc2VuZGVyTm9kZSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFubmVsTm9kZS5ub3RpZnlEYXRhQ2hhbmdlKHNlbmRlck5vZGUsIGNoYW5nZVR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfREFUQV9WQUxVRTpcclxuICAgICAgICBjYXNlIEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfREFUQV9TSVpFOlxyXG4gICAgICAgICAgICBpZihzZW5kZXJOb2RlKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5uZWxOb2RlLm5vdGlmeURhdGFDaGFuZ2Uoc2VuZGVyTm9kZSwgY2hhbmdlVHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICAvLyBJbmZvcm0gbGlzdGVuZXJzIChlLmcuIFJlcXVlc3RzKVxyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2xpc3RlbmVycy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1tpXShjaGFuZ2VUeXBlKTtcclxuICAgIH1cclxufTtcclxuXHJcbkRhdGFOb2RlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKXtcclxuICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKVxyXG59O1xyXG5cclxuRGF0YU5vZGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcclxuICAgIEFycmF5LmVyYXNlKHRoaXMuX2xpc3RlbmVycywgbGlzdGVuZXIpO1xyXG59O1xyXG5cclxuRGF0YU5vZGUucHJvdG90eXBlLmFkZExvYWRMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKXtcclxuICAgIHRoaXMuX2xvYWRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XHJcbn07XHJcblxyXG4vL25vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcclxuRGF0YU5vZGUucHJvdG90eXBlLnJlbW92ZUxvYWRMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKXtcclxuICAgIEFycmF5LmVyYXNlKHRoaXMuX2xvYWRMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcclxufTtcclxuXHJcbkRhdGFOb2RlLnByb3RvdHlwZS5fY2FsbExvYWRMaXN0ZW5lcnMgPSBmdW5jdGlvbihuZXdMZXZlbCwgb2xkTGV2ZWwpe1xyXG4gICAgdmFyIGxlbiA9IHRoaXMuX2xvYWRMaXN0ZW5lcnMubGVuZ3RoO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKXtcclxuICAgICAgICB0aGlzLl9sb2FkTGlzdGVuZXJzW2ldKHRoaXMsIG5ld0xldmVsLCBvbGRMZXZlbCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5EYXRhTm9kZS5wcm90b3R5cGUuZ2V0T3V0cHV0TmFtZXMgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIGdldEZvcndhcmROb2RlKHRoaXMpLl9jaGFubmVsTm9kZS5nZXRPdXRwdXROYW1lcygpO1xyXG59O1xyXG5cclxuRGF0YU5vZGUucHJvdG90eXBlLmdldE91dHB1dENoYW5uZWxJbmZvID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgICByZXR1cm4gZ2V0Rm9yd2FyZE5vZGUodGhpcykuX2NoYW5uZWxOb2RlLmdldE91dHB1dENoYW5uZWxJbmZvKG5hbWUpO1xyXG59O1xyXG5cclxuLy9ub2luc3BlY3Rpb24gSlNVbnVzZWRHbG9iYWxTeW1ib2xzXHJcbkRhdGFOb2RlLnByb3RvdHlwZS5nZXRQYXJhbU5hbWVzID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLl9nZXRQYXJhbU5hbWVzKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogRGVsZWdhdGUgY29tcHV0YXRpb24gb2YgdGhlIHJlc3VsdCB0byB0aGUgY2hhbm5lbCBub2RlXHJcbiAqIG9mIHRoZSBmaXJzdCBjb250cmlidXRpbmcgRGF0YU5vZGUuXHJcbiAqIEBwYXJhbSB0eXBlXHJcbiAqIEBwYXJhbSBmaWx0ZXJcclxuICogQHJldHVybnMge1Jlc3VsdH1cclxuICovXHJcbkRhdGFOb2RlLnByb3RvdHlwZS5fZ2V0UmVzdWx0ID0gZnVuY3Rpb24odHlwZSwgZmlsdGVyKXtcclxuICAgIHJldHVybiBnZXRGb3J3YXJkTm9kZSh0aGlzLCBmaWx0ZXIpLl9jaGFubmVsTm9kZS5nZXRSZXN1bHQodHlwZSwgZmlsdGVyKTtcclxufTtcclxuXHJcbkRhdGFOb2RlLnByb3RvdHlwZS5fZ2V0Rm9yd2FyZE5vZGUgPSBmdW5jdGlvbihmaWx0ZXIpe1xyXG4gICAgcmV0dXJuIGdldEZvcndhcmROb2RlKHRoaXMsIGZpbHRlcik7XHJcbn07XHJcblxyXG5EYXRhTm9kZS5wcm90b3R5cGUuX2dldFBhcmFtTmFtZXMgPSBmdW5jdGlvbigpe1xyXG4gICAgaWYoIXRoaXMuX3BhcmFtTmFtZXMpe1xyXG4gICAgICAgIHRoaXMuX3BhcmFtTmFtZXMgPSBbXTtcclxuICAgICAgICBpZih0aGlzLl9zb3VyY2VOb2RlKVxyXG4gICAgICAgICAgICBVdGlscy5uYW1lc2V0LmFkZCh0aGlzLl9wYXJhbU5hbWVzLCB0aGlzLl9zb3VyY2VOb2RlLl9nZXRQYXJhbU5hbWVzKCkpO1xyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgICAgICBVdGlscy5uYW1lc2V0LmFkZCh0aGlzLl9wYXJhbU5hbWVzLCB0aGlzLl9jaGlsZHJlbltpXS5fZ2V0UGFyYW1OYW1lcygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9wYXJhbU5hbWVzO1xyXG59O1xyXG5cclxuRGF0YU5vZGUucHJvdG90eXBlLl9nZXRHbG9iYWxQYXJhbU5hbWVzID0gZnVuY3Rpb24oKXtcclxuICAgIGlmKCF0aGlzLl9nbG9iYWxQYXJhbU5hbWVzKXtcclxuICAgICAgICB0aGlzLl9nbG9iYWxQYXJhbU5hbWVzID0gW107XHJcbiAgICAgICAgaWYodGhpcy5fZGF0YWZsb3dOb2RlKVxyXG4gICAgICAgICAgICBVdGlscy5uYW1lc2V0LmFkZCh0aGlzLl9nbG9iYWxQYXJhbU5hbWVzLCB0aGlzLl9kYXRhZmxvd05vZGUuX2dldEdsb2JhbFBhcmFtTmFtZXMoKSk7XHJcblxyXG4gICAgICAgIGlmKHRoaXMuX3NvdXJjZU5vZGUpXHJcbiAgICAgICAgICAgIFV0aWxzLm5hbWVzZXQuYWRkKHRoaXMuX2dsb2JhbFBhcmFtTmFtZXMsIHRoaXMuX3NvdXJjZU5vZGUuX2dldEdsb2JhbFBhcmFtTmFtZXMoKSk7XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgIFV0aWxzLm5hbWVzZXQuYWRkKHRoaXMuX2dsb2JhbFBhcmFtTmFtZXMsIHRoaXMuX2NoaWxkcmVuW2ldLl9nZXRHbG9iYWxQYXJhbU5hbWVzKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX2dsb2JhbFBhcmFtTmFtZXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtTdWJzdGl0dXRpb259IHN1YnN0aXR1dGlvblxyXG4gKiBAcmV0dXJucyB7Q2hhbm5lbE5vZGV9XHJcbiAqL1xyXG5EYXRhTm9kZS5wcm90b3R5cGUuX2dldE9yQ3JlYXRlQ2hhbm5lbE5vZGUgPSBmdW5jdGlvbihzdWJzdGl0dXRpb24pe1xyXG4gICAgaWYoIXN1YnN0aXR1dGlvbilcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2hhbm5lbE5vZGU7XHJcbiAgICBlbHNle1xyXG4gICAgICAgIHZhciBrZXkgPSBzdWJzdGl0dXRpb24uZ2V0S2V5KHRoaXMpO1xyXG4gICAgICAgIGlmKCF0aGlzLl9zdWJzdGl0dXRpb25Ob2Rlc1trZXldKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N1YnN0aXR1dGlvbk5vZGVzW2tleV0gPSBuZXcgQ2hhbm5lbE5vZGUodGhpcywgc3Vic3RpdHV0aW9uKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9zdWJzdGl0dXRpb25Ob2Rlc1trZXldLmluY3JlYXNlUmVmKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJzdGl0dXRpb25Ob2Rlc1trZXldO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBDaGFubmVsTm9kZSBwYXNzZWQgYXMgYXJndW1lbnQgZnJvbSBpbnRlcm5hbCBzdWJzdGl0dXRpb24gbm9kZXNcclxuICogRGVjcmVhc2VzIHJlZmVyZW5jZSBjb3VudGVyIG9mIHN1YnN0aXR1dGlvbiBub2RlIGFuZCBkZWxldGVzIGl0IGlmIG5vdFxyXG4gKiB1c2VkIGJ5IGFueSBvdGhlciBub2RlLlxyXG4gKiBAcGFyYW0ge0NoYW5uZWxOb2RlfSBzdWJzdGl0dXRpb25Ob2RlXHJcbiAqL1xyXG5EYXRhTm9kZS5wcm90b3R5cGUuX3JlbW92ZVN1YnN0aXR1dGlvbk5vZGUgPSBmdW5jdGlvbihzdWJzdGl0dXRpb25Ob2RlKXtcclxuICAgIHZhciBrZXkgPSBzdWJzdGl0dXRpb25Ob2RlLnN1YnN0aXR1dGlvbi5nZXRLZXkodGhpcyk7XHJcbiAgICBpZih0aGlzLl9zdWJzdGl0dXRpb25Ob2Rlc1trZXldICYmIHRoaXMuX3N1YnN0aXR1dGlvbk5vZGVzW2tleV0uZGVjcmVhc2VSZWYoKSlcclxuICAgICAgICBkZWxldGUgdGhpcy5fc3Vic3RpdHV0aW9uTm9kZXNba2V5XTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDYWxscyBjbGVhciBvZiBhbGwgc3Vic3RpdHV0aW9uTm9kZXMgYW5kIGNsZWFycyB0aGUgbWFwXHJcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IGRhdGFOb2RlXHJcbiAqL1xyXG5mdW5jdGlvbiBjbGVhclN1YnN0aXR1dGlvbk5vZGVzKGRhdGFOb2RlKXtcclxuICAgIGlmICghZGF0YU5vZGUuX3N1YnN0aXR1dGlvbk5vZGVzKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZm9yKHZhciBuYW1lIGluIGRhdGFOb2RlLl9zdWJzdGl0dXRpb25Ob2Rlcykge1xyXG4gICAgICAgIGRhdGFOb2RlLl9zdWJzdGl0dXRpb25Ob2Rlc1tuYW1lXS5jbGVhcigpO1xyXG4gICAgfVxyXG4gICAgZGF0YU5vZGUuX3N1YnN0aXR1dGlvbk5vZGVzID0ge307XHJcbiAgICBmb3IgKHZhciBpIGluIGRhdGFOb2RlLl9jaGlsZHJlbikge1xyXG4gICAgICAgIGNsZWFyU3Vic3RpdHV0aW9uTm9kZXMoZGF0YU5vZGUuX2NoaWxkcmVuW2ldKTtcclxuICAgIH1cclxufVxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gSGVscGVyc1xyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFNraXBzIG5vZGVzLCBpZiBpdCBkb2VzIG5vdCBjb250cmlidXRlIHRvIHRoZSByZXN1bHQgKG9wdGltaXphdGlvbilcclxuICogQHBhcmFtIHtEYXRhTm9kZX0gZGF0YU5vZGVcclxuICogQHBhcmFtIHthcnJheS48c3RyaW5nPj99IGZpbHRlclxyXG4gKiBAcmV0dXJucyB7RGF0YU5vZGV9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRGb3J3YXJkTm9kZShkYXRhTm9kZSwgZmlsdGVyKXtcclxuICAgIHZhciBoYXNGaWx0ZXIgPSAoZGF0YU5vZGUuX2ZpbHRlck1hcHBpbmcgJiYgIWRhdGFOb2RlLl9maWx0ZXJNYXBwaW5nLmlzRW1wdHkoKSk7XHJcbiAgICBpZihoYXNGaWx0ZXIpXHJcbiAgICAgICAgcmV0dXJuIGRhdGFOb2RlO1xyXG5cclxuICAgIGlmKCFkYXRhTm9kZS5fY29tcHV0ZU9wZXJhdG9yICl7XHJcbiAgICAgICAgaWYoZGF0YU5vZGUuX3NvdXJjZU5vZGUgJiYgZGF0YU5vZGUuX2NoaWxkcmVuLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gZ2V0Rm9yd2FyZE5vZGUoZGF0YU5vZGUuX3NvdXJjZU5vZGUpO1xyXG4gICAgICAgIGlmKGRhdGFOb2RlLl9jaGlsZHJlbi5sZW5ndGggPT0gMSAmJiBkYXRhTm9kZS5fY2hpbGRyZW5bMF0gaW5zdGFuY2VvZiBEYXRhTm9kZSlcclxuICAgICAgICAgICAgcmV0dXJuIGdldEZvcndhcmROb2RlKGRhdGFOb2RlLl9jaGlsZHJlblswXSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGlkeCA9IGRhdGFOb2RlLl9jaGFubmVsTm9kZS5nZXRDaGlsZERhdGFJbmRleChmaWx0ZXIpO1xyXG4gICAgaWYoaWR4ICE9IC0xICYmIGlkeCAhPSB1bmRlZmluZWQpe1xyXG4gICAgICAgIGlmKGRhdGFOb2RlLl9zb3VyY2VOb2RlKVxyXG4gICAgICAgICAgICByZXR1cm4gZ2V0Rm9yd2FyZE5vZGUoZGF0YU5vZGUuX3NvdXJjZU5vZGUpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIGdldEZvcndhcmROb2RlKGRhdGFOb2RlLl9jaGlsZHJlbltpZHhdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkYXRhTm9kZTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgcHJvZ3Jlc3MgbGV2ZWxcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtEYXRhTm9kZX0gbm9kZVxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlUHJvZ3Jlc3NMZXZlbChub2RlKXtcclxuICAgIHZhciBwcm9ncmVzc0xldmVsID0gbm9kZS5fbG9hZGluZyA/IG5vZGUuX2xvYWRMZXZlbCA6IEluZmluaXR5O1xyXG4gICAgdmFyIGk7XHJcblxyXG4gICAgZm9yKGkgPSAwOyBwcm9ncmVzc0xldmVsICYmIGkgPCBub2RlLl9jaGlsZHJlbi5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5fY2hpbGRyZW5baV07XHJcbiAgICAgICAgaWYoY2hpbGQgaW5zdGFuY2VvZiBEYXRhTm9kZSl7XHJcbiAgICAgICAgICAgIHByb2dyZXNzTGV2ZWwgPSBNYXRoLm1pbihwcm9ncmVzc0xldmVsLCBNYXRoLm1heChjaGlsZC5fbG9hZExldmVsLCBjaGlsZC5fcHJvZ3Jlc3NMZXZlbCkgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihjaGlsZC5fZGF0YSAmJiBjaGlsZC5fZGF0YS5pc0xvYWRpbmcgJiYgY2hpbGQuX2RhdGEuaXNMb2FkaW5nKCkpe1xyXG4gICAgICAgICAgICBwcm9ncmVzc0xldmVsID0gTWF0aC5taW4ocHJvZ3Jlc3NMZXZlbCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYocHJvZ3Jlc3NMZXZlbCAmJiBub2RlLl9zb3VyY2VOb2RlKXtcclxuICAgICAgICBwcm9ncmVzc0xldmVsID0gTWF0aC5taW4ocHJvZ3Jlc3NMZXZlbCwgTWF0aC5tYXgobm9kZS5fc291cmNlTm9kZS5fbG9hZExldmVsLCBub2RlLl9zb3VyY2VOb2RlLl9wcm9ncmVzc0xldmVsKSk7XHJcbiAgICB9XHJcbiAgICBpZihwcm9ncmVzc0xldmVsICYmIG5vZGUuX2RhdGFmbG93Tm9kZSl7XHJcbiAgICAgICAgcHJvZ3Jlc3NMZXZlbCA9IE1hdGgubWluKHByb2dyZXNzTGV2ZWwsIE1hdGgubWF4KG5vZGUuX2RhdGFmbG93Tm9kZS5fbG9hZExldmVsLCBub2RlLl9kYXRhZmxvd05vZGUuX3Byb2dyZXNzTGV2ZWwpKTtcclxuICAgIH1cclxuICAgIHZhciBvbGRMZXZlbCA9IG5vZGUuX3Byb2dyZXNzTGV2ZWw7XHJcbiAgICBub2RlLl9wcm9ncmVzc0xldmVsID0gcHJvZ3Jlc3NMZXZlbDtcclxuXHJcbiAgICBpZihvbGRMZXZlbCAhPSBub2RlLl9wcm9ncmVzc0xldmVsKXtcclxuICAgICAgICBub2RlLl9jYWxsTG9hZExpc3RlbmVycyhub2RlLl9wcm9ncmVzc0xldmVsLCBvbGRMZXZlbCk7XHJcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgbm9kZS5fcGFyZW50cy5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgdXBkYXRlUHJvZ3Jlc3NMZXZlbChub2RlLl9wYXJlbnRzW2ldKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IHBhcmVudFxyXG4gKiBAcGFyYW0ge0dyYXBoTm9kZX0gY2hpbGRcclxuICovXHJcbmZ1bmN0aW9uIGFkZFBhcmVudChwYXJlbnQsIGNoaWxkKXtcclxuICAgIGNoaWxkLl9wYXJlbnRzLnB1c2gocGFyZW50KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IHBhcmVudFxyXG4gKiBAcGFyYW0ge0dyYXBoTm9kZX0gY2hpbGRcclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZVBhcmVudChwYXJlbnQsIGNoaWxkKXtcclxuICAgIEFycmF5LmVyYXNlKGNoaWxkLl9wYXJlbnRzLCBwYXJlbnQpO1xyXG59XHJcblxyXG4vKipcclxuICogTm90aWZ5IGFsbCBwYXJlbnQgbm9kZXMgYWJvdXQgYSBjaGFuZ2VcclxuICogQHBhcmFtIHtHcmFwaE5vZGV9IG5vZGVcclxuICogQHBhcmFtIHtleHBvcnRzLkMuUkVTVUxUX1NUQVRFfSBjaGFuZ2VUeXBlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBub3RpZnlQYXJlbnRzT25DaGFuZ2VkKG5vZGUsIGNoYW5nZVR5cGUpe1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG5vZGUuX3BhcmVudHMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIG5vZGUuX3BhcmVudHNbaV0ubm90aWZ5KGNoYW5nZVR5cGUsIG5vZGUpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogVXBkYXRlIHRoZSBvd25lcnMgb2YgdGhlIG1hcHBpbmdzXHJcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IGRhdGFOb2RlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcclxuICogQHBhcmFtIHtNYXBwaW5nfSBtYXBwaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBzd2FwTWFwcGluZyhkYXRhTm9kZSwga2V5LCBtYXBwaW5nKXtcclxuICAgIGRhdGFOb2RlW2tleV0gJiYgZGF0YU5vZGVba2V5XS5fcmVtb3ZlT3duZXIoZGF0YU5vZGUpO1xyXG4gICAgZGF0YU5vZGVba2V5XSA9IG1hcHBpbmc7XHJcbiAgICBkYXRhTm9kZVtrZXldICYmIGRhdGFOb2RlW2tleV0uX2FkZE93bmVyKGRhdGFOb2RlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVwbGFjZU5vZGVJbkhpZXJhcmNoeShub2RlLCBmaWVsZCwgbmV3Q2hpbGQpIHtcclxuICAgIHZhciBvbGRDaGlsZCA9IG5vZGVbZmllbGRdO1xyXG4gICAgaWYob2xkQ2hpbGQpIHtcclxuICAgICAgICByZW1vdmVQYXJlbnQobm9kZSwgb2xkQ2hpbGQpO1xyXG4gICAgfVxyXG4gICAgbm9kZVtmaWVsZF0gPSBuZXdDaGlsZDtcclxuICAgIGlmKG5ld0NoaWxkKSB7XHJcbiAgICAgICAgYWRkUGFyZW50KG5vZGUsIG5ld0NoaWxkKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBJbnB1dE5vZGU6IElucHV0Tm9kZSxcclxuICAgIERhdGFOb2RlOiBEYXRhTm9kZSxcclxuICAgIGdldENvbXB1dGVEYXRhZmxvd1VybDogZ2V0Q29tcHV0ZURhdGFmbG93VXJsXHJcbn07XHJcbiIsInZhciBCYXNlID0gcmVxdWlyZShcIi4uL2Jhc2UuanNcIik7XHJcbnZhciBDID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xyXG52YXIgRGF0YU5vZGUgPSByZXF1aXJlKFwiLi9ncmFwaC5qc1wiKS5EYXRhTm9kZTtcclxuXHJcbi8qKlxyXG4gKiBDb250ZW50IG9mIHRoaXMgZmlsZTpcclxuICogQ2xhc3NlcyB0byByZXF1ZXN0IHJlc3VsdHMgZnJvbSBhbiBYZmxvdyBncmFwaC5cclxuICovXHJcblxyXG4vKipcclxuICogQWJzdHJhY3QgUmVxdWVzdCBjbGFzcy5cclxuICogQW55IFJlcXVlc3QgaXMgY3JlYXRlZCBmcm9tIGEgRGF0YU5vZGUgdG8gcmVjZWl2ZSB0aGUgcmVzdWx0IG9mIHRoYXQgRGF0YU5vZGUuXHJcbiAqIFRvIGFsbG93IGVmZmVjdGl2ZSBvcHRpbWl6YXRpb24sIGl0IGlzIHJlY29tbWVuZGVkIHRvIGNyZWF0ZSBvbmx5IG9uZSBSZXF1ZXN0IHBlciBEYXRhTm9kZSBhbmQgcmVjZWl2ZSBhbGxcclxuICogcmVzdWx0cyB0aHJvdWdoIHRoYXQgUmVxdWVzdC5cclxuICogQGFic3RyYWN0XHJcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IGRhdGFOb2RlIFRoZSBEYXRhTm9kZSBmcm9tIHdoaWNoIHRvIHJlcXVlc3QgcmVzdWx0c1xyXG4gKiBAcGFyYW0gez9BcnJheS48c3RyaW5nPn0gZmlsdGVyIEEgbGlzdCBvZiBuYW1lcyBmaWx0ZXJpbmcgdGhlIHZhbHVlcyB0byBiZSByZWNlaXZlZCAob25seSByZXR1cm4gdmFsdWVzIHdpdGggbmFtZXMgaW5zaWRlIHRoZSBmaWx0ZXIpXHJcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHJlc3VsdCBvZiB0aGUgUmVxdWVzdCBjaGFuZ2VzXHJcbiAqL1xyXG52YXIgUmVxdWVzdCA9IGZ1bmN0aW9uKGRhdGFOb2RlLCBmaWx0ZXIsIGNhbGxiYWNrKXtcclxuICAgIHRoaXMuX2RhdGFOb2RlID0gZGF0YU5vZGU7XHJcbiAgICB0aGlzLl9maWx0ZXIgPSBmaWx0ZXIgPyBmaWx0ZXIuc2xpY2UoKS5zb3J0KCkgOiBudWxsO1xyXG4gICAgdGhpcy5fbGlzdGVuZXIgPSBjYWxsYmFjaztcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhY2hlZCByZXN1bHQgb2YgdGhpcyByZXF1ZXN0XHJcbiAgICAgKiBAdHlwZSB7UmVzdWx0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9yZXN1bHQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FjaGVkIGNhbGxiYWNrIGZ1bmN0aW9uIGF0dGFjaGVkIHRvIGRhdGEgbm9kZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fZGF0YU5vZGVMaXN0ZW5lciA9IHRoaXMuX29uRGF0YU5vZGVDaGFuZ2UuYmluZCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLl9kYXRhTm9kZS5hZGRMaXN0ZW5lcih0aGlzLl9kYXRhTm9kZUxpc3RlbmVyKTtcclxufTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXF1ZXN0LnByb3RvdHlwZSwgXCJkYXRhTm9kZVwiLCB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkYXRhTm9kZSBpcyByZWFkb25seVwiKTtcclxuICAgIH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9kYXRhTm9kZTsgfVxyXG59KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXF1ZXN0LnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZpbHRlciBpcyByZWFkLW9ubHlcIik7XHJcbiAgICB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fZmlsdGVyOyB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIENhbGwgdGhpcyBmdW5jdGlvbiwgd2hlbmV2ZXIgdGhlIHJlcXVlc3QgaXMgbm90IHJlcXVpcmVkIGFueW1vcmUuXHJcbiAqIENsZWFucyB1cCBjYWNoZWQgZGF0YSBhbmQgbGlzdGVuZXJzXHJcbiAqL1xyXG5SZXF1ZXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLl9saXN0ZW5lciA9IG51bGw7XHJcbiAgICBpZih0aGlzLl9yZXN1bHQpIHRoaXMuX3Jlc3VsdC5fcmVtb3ZlUmVxdWVzdCh0aGlzKTtcclxuICAgIHRoaXMuX2RhdGFOb2RlLnJlbW92ZUxpc3RlbmVyKHRoaXMuX2RhdGFOb2RlTGlzdGVuZXIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7Qy5SRVNVTFRfU1RBVEV9IGRhdGFcclxuICogQHByaXZhdGVcclxuICovXHJcblJlcXVlc3QucHJvdG90eXBlLl9vblBvc3Rwb25lZFJlc3VsdENoYW5nZWQgPSBmdW5jdGlvbihkYXRhKXtcclxuICAgIHRoaXMuX2xpc3RlbmVyICYmIHRoaXMuX2xpc3RlbmVyKHRoaXMsIGRhdGEpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoYW5nZSB0aGUgcmVzdWx0IG9mIHRoZSByZXF1ZXN0IGFuZCB1cGRhdGUgcmVxdWVzdCBsaXN0IG9mIG9sZCBhbmQgbmV3XHJcbiAqIHJlc3VsdC5cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0XHJcbiAqIEBwYXJhbSB7UmVzdWx0P30gbmV3UmVzdWx0XHJcbiAqIEByZXR1cm5zIHtSZXN1bHR9XHJcbiAqL1xyXG5mdW5jdGlvbiBzd2FwUmVzdWx0UmVxdWVzdChyZXF1ZXN0LCBuZXdSZXN1bHQpe1xyXG4gICAgaWYocmVxdWVzdC5fcmVzdWx0KSByZXF1ZXN0Ll9yZXN1bHQuX3JlbW92ZVJlcXVlc3QocmVxdWVzdCk7XHJcbiAgICByZXF1ZXN0Ll9yZXN1bHQgPSBuZXdSZXN1bHQ7XHJcbiAgICBpZihuZXdSZXN1bHQpIG5ld1Jlc3VsdC5fYWRkUmVxdWVzdChyZXF1ZXN0KTtcclxuICAgIHJldHVybiBuZXdSZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcclxuICogQHBhcmFtIHtDLlJFU1VMVF9TVEFURX0gbm90aWZpY2F0aW9uXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBub3RpZnlMaXN0ZW5lcnMocmVxdWVzdCwgbm90aWZpY2F0aW9uKXtcclxuICAgIEJhc2UuX3F1ZXVlUmVzdWx0Q2FsbGJhY2socmVxdWVzdCwgbm90aWZpY2F0aW9uKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7Qy5SRVNVTFRfU1RBVEV9IG5vdGlmaWNhdGlvblxyXG4gKi9cclxuUmVxdWVzdC5wcm90b3R5cGUuX29uRGF0YU5vZGVDaGFuZ2UgPSBmdW5jdGlvbihub3RpZmljYXRpb24pe1xyXG4gICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIG5vdGlmaWNhdGlvbik7XHJcbn07XHJcblxyXG4vKipcclxuICogQSBDb21wdXRlUmVxdWVzdCBpcyBhIFJlcXVlc3QgZm9yIGEgQ29tcHV0ZVJlc3VsdCwgd2hpY2ggY29udGFpbnMgYSBuYW1lZCBtYXAgb2YgdHlwZWQgdmFsdWVzLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMge1JlcXVlc3R9XHJcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IGRhdGFOb2RlIFRoZSBEYXRhTm9kZSBmcm9tIHdoaWNoIHRvIHJlcXVlc3QgcmVzdWx0c1xyXG4gKiBAcGFyYW0gez9BcnJheS48c3RyaW5nPn0gZmlsdGVyIEEgbGlzdCBvZiBuYW1lcyBmaWx0ZXJpbmcgdGhlIHZhbHVlcyB0byBiZSByZWNlaXZlZCAob25seSByZXR1cm4gdmFsdWVzIHdpdGggbmFtZXMgaW5zaWRlIHRoZSBmaWx0ZXIpXHJcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHJlc3VsdCBvZiB0aGUgUmVxdWVzdCBjaGFuZ2VzXHJcbiAqL1xyXG52YXIgQ29tcHV0ZVJlcXVlc3QgPSBmdW5jdGlvbihkYXRhTm9kZSwgZmlsdGVyLCBjYWxsYmFjayl7XHJcbiAgICBSZXF1ZXN0LmNhbGwodGhpcywgZGF0YU5vZGUsIGZpbHRlciwgY2FsbGJhY2spO1xyXG59O1xyXG5CYXNlLmNyZWF0ZUNsYXNzKENvbXB1dGVSZXF1ZXN0LCBSZXF1ZXN0KTtcclxuXHJcbi8qKlxyXG4gKiBAcmV0dXJucyB7UmVzdWx0fVxyXG4gKi9cclxuQ29tcHV0ZVJlcXVlc3QucHJvdG90eXBlLmdldFJlc3VsdCA9IGZ1bmN0aW9uKCl7XHJcbiAgICAvLyBzd2FwUmVzdWx0UmVxdWVzdCBpcyBjYWxsZWQgaGVyZSBiZWNhdXNlIHRoZSByZXN1bHQgb2JqZWN0IG9mIHRoZSByZXF1ZXN0IG1heSBjaGFuZ2UsIGUuZy5cclxuICAgIC8vIGRpZmZlcmVudCBmb3J3YXJkIG5vZGUuXHJcbiAgICByZXR1cm4gc3dhcFJlc3VsdFJlcXVlc3QodGhpcywgdGhpcy5fZGF0YU5vZGUuX2dldFJlc3VsdChDLlJFU1VMVF9UWVBFLkNPTVBVVEUsIHRoaXMuX2ZpbHRlcikpO1xyXG59O1xyXG5cclxuQ29tcHV0ZVJlcXVlc3QucHJvdG90eXBlLl9vblJlc3VsdENoYW5nZWQgPSBmdW5jdGlvbihub3RpZmljYXRpb24pe1xyXG4gICAgdGhpcy5fb25EYXRhTm9kZUNoYW5nZShub3RpZmljYXRpb24pO1xyXG59O1xyXG5cclxuXHJcbnZhciBjX3ZzQ29ubmVjdE5vZGVDb3VudCA9IHt9LFxyXG4gICAgY192c0Nvbm5lY3ROb2RlS2V5ID0ge30sXHJcbiAgICBjX3ZzQ29ubmVjdE5vZGVDYWNoZSA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEEgVmVydGV4U2hhZGVyUmVxdWVzdCBpcyBhIFJlcXVlc3QgZm9yIGEgVlNEYXRhUmVzdWx0LCB1c2VkIHRvIGdlbmVyYXRlIGEgVmVydGV4U2hhZGVyIHRoYXQgaW5jbHVkZXNcclxuICogZGF0YWZsb3cgcHJvY2Vzc2luZy5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIHtSZXF1ZXN0fVxyXG4gKiBAcGFyYW0ge0RhdGFOb2RlfSBkYXRhTm9kZVxyXG4gKiBAcGFyYW0ge1ZTQ29uZmlnfSB2c0NvbmZpZyBDb25maWd1cmF0aW9uIGZvciB0aGUgb3V0cHV0IG9mIHRoZSBnZW5lcmF0ZWQgdmVydGV4IHNoYWRlclxyXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW5ldmVyIHRoZSByZXN1bHQgb2YgdGhlIFJlcXVlc3QgY2hhbmdlc1xyXG4gKi9cclxudmFyIFZlcnRleFNoYWRlclJlcXVlc3QgPSBmdW5jdGlvbihkYXRhTm9kZSwgdnNDb25maWcsIGNhbGxiYWNrKXtcclxuICAgIHZhciBmaWx0ZXIgPSB2c0NvbmZpZy5nZXRGaWx0ZXIoKTtcclxuICAgIGlmKGZpbHRlci5sZW5ndGggPT0gMClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2c0NvbmZpZyByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXR0cmlidXRlIGVudHJ5LlwiKTtcclxuICAgIFJlcXVlc3QuY2FsbCh0aGlzLCBkYXRhTm9kZSwgZmlsdGVyLCBjYWxsYmFjayk7XHJcbiAgICB0aGlzLl92c0NvbmZpZyA9IHZzQ29uZmlnO1xyXG4gICAgdGhpcy5fdnNDb25uZWN0Tm9kZSA9IGdldFZzQ29ubmVjdE5vZGUoZGF0YU5vZGUsIHZzQ29uZmlnKTtcclxufTtcclxuQmFzZS5jcmVhdGVDbGFzcyhWZXJ0ZXhTaGFkZXJSZXF1ZXN0LCBSZXF1ZXN0KTtcclxuXHJcblZlcnRleFNoYWRlclJlcXVlc3QucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpcy5fdnNDb25maWc7XHJcbn07XHJcblxyXG4vKipcclxuICogQHNlZSBDb21wdXRlUmVxdWVzdC5nZXRSZXN1bHRcclxuICogQHJldHVybnMge1Jlc3VsdH1cclxuICovXHJcblZlcnRleFNoYWRlclJlcXVlc3QucHJvdG90eXBlLmdldFJlc3VsdCA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gc3dhcFJlc3VsdFJlcXVlc3QodGhpcywgdGhpcy5fdnNDb25uZWN0Tm9kZS5fZ2V0UmVzdWx0KEMuUkVTVUxUX1RZUEUuVlMsIHRoaXMuX2ZpbHRlcikpO1xyXG59O1xyXG5cclxuVmVydGV4U2hhZGVyUmVxdWVzdC5wcm90b3R5cGUuX29uRGF0YU5vZGVDaGFuZ2UgPSBmdW5jdGlvbihub3RpZmljYXRpb24pe1xyXG4gICAgaWYobm90aWZpY2F0aW9uID09IEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKXtcclxuICAgICAgICB2YXIgbmV3VlNDb25uZWN0ZWROb2RlID0gZ2V0VnNDb25uZWN0Tm9kZSh0aGlzLl9kYXRhTm9kZSwgdGhpcy5fdnNDb25maWcsIHRoaXMuX2ZpbHRlcik7XHJcbiAgICAgICAgaWYobmV3VlNDb25uZWN0ZWROb2RlICE9IHRoaXMuX3ZzQ29ubmVjdE5vZGUpe1xyXG4gICAgICAgICAgICBjbGVhclZzQ29ubmVjdE5vZGUodGhpcy5fdnNDb25uZWN0Tm9kZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZzQ29ubmVjdE5vZGUgPSBuZXdWU0Nvbm5lY3RlZE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgUmVxdWVzdC5wcm90b3R5cGUuX29uRGF0YU5vZGVDaGFuZ2UuY2FsbCh0aGlzLCBub3RpZmljYXRpb24pO1xyXG59O1xyXG5cclxuVmVydGV4U2hhZGVyUmVxdWVzdC5wcm90b3R5cGUuZ2V0VmVydGV4U2hhZGVyID0gZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuZ2V0UmVzdWx0KCk7IC8vIFVwZGF0ZSB0aGUgcmVzdWx0IGZpcnN0XHJcbiAgICBpZighdGhpcy5fdmVydGV4U2hhZGVyKXtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhTaGFkZXIgPSB0aGlzLl9yZXN1bHQuZ2V0VmVydGV4U2hhZGVyKHRoaXMuX3ZzQ29uZmlnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl92ZXJ0ZXhTaGFkZXI7XHJcbn07XHJcblxyXG5WZXJ0ZXhTaGFkZXJSZXF1ZXN0LnByb3RvdHlwZS5fb25SZXN1bHRDaGFuZ2VkID0gZnVuY3Rpb24obm90aWZpY2F0aW9uKXtcclxuICAgIHRoaXMuX29uRGF0YU5vZGVDaGFuZ2Uobm90aWZpY2F0aW9uKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGdldFZzQ29ubmVjdE5vZGUoZGF0YU5vZGUsIHZzQ29uZmlnLCBmaWx0ZXIpe1xyXG4gICAgdmFyIGZvcndhcmROb2RlID0gZGF0YU5vZGUuX2dldEZvcndhcmROb2RlKGZpbHRlcik7XHJcblxyXG4gICAgdmFyIGtleSA9IGdldERhdGFOb2RlU2hhZGVyS2V5KGZvcndhcmROb2RlLCB2c0NvbmZpZyk7XHJcbiAgICB2YXIgY29ubmVjdE5vZGU7XHJcbiAgICBpZighKGNvbm5lY3ROb2RlID0gY192c0Nvbm5lY3ROb2RlQ2FjaGVba2V5XSkpe1xyXG4gICAgICAgIGNvbm5lY3ROb2RlID0gbmV3IERhdGFOb2RlKGZhbHNlKTtcclxuICAgICAgICBjb25uZWN0Tm9kZS5hcHBlbmRDaGlsZChmb3J3YXJkTm9kZSk7XHJcblxyXG4gICAgICAgIGNvbm5lY3ROb2RlLmNvbXB1dGVPcGVyYXRvciA9IHZzQ29uZmlnLmdldE9wZXJhdG9yKCk7XHJcbiAgICAgICAgY29ubmVjdE5vZGUuY29tcHV0ZUlucHV0TWFwcGluZyA9IG51bGw7XHJcbiAgICAgICAgY29ubmVjdE5vZGUuY29tcHV0ZU91dHB1dE1hcHBpbmcgPSBudWxsO1xyXG5cclxuICAgICAgICBjX3ZzQ29ubmVjdE5vZGVDYWNoZVtrZXldID0gY29ubmVjdE5vZGU7XHJcbiAgICAgICAgY192c0Nvbm5lY3ROb2RlQ291bnRbY29ubmVjdE5vZGUuaWRdID0gMTtcclxuICAgICAgICBjX3ZzQ29ubmVjdE5vZGVLZXlbY29ubmVjdE5vZGUuaWRdID0ga2V5O1xyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgICBjX3ZzQ29ubmVjdE5vZGVDb3VudFtjb25uZWN0Tm9kZS5pZF0rKztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29ubmVjdE5vZGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsZWFyVnNDb25uZWN0Tm9kZShjb25uZWN0Tm9kZSl7XHJcbiAgICBjX3ZzQ29ubmVjdE5vZGVDb3VudFtjb25uZWN0Tm9kZS5pZF0tLTtcclxuICAgIGlmKCFjX3ZzQ29ubmVjdE5vZGVDb3VudFtjb25uZWN0Tm9kZS5pZF0pe1xyXG4gICAgICAgIHZhciBrZXkgPSBjX3ZzQ29ubmVjdE5vZGVLZXlbY29ubmVjdE5vZGUuaWRdO1xyXG4gICAgICAgIGNfdnNDb25uZWN0Tm9kZUNhY2hlW2tleV0gPSBudWxsO1xyXG4gICAgICAgIGNvbm5lY3ROb2RlLmNsZWFyKCk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBnZXREYXRhTm9kZVNoYWRlcktleShkYXRhTm9kZSwgdnNDb25maWcpe1xyXG4gICAgcmV0dXJuIGRhdGFOb2RlLmlkICsgXCJ8XCIgKyB2c0NvbmZpZy5nZXRLZXkoKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBDb21wdXRlUmVxdWVzdDogIENvbXB1dGVSZXF1ZXN0LFxyXG4gICAgVmVydGV4U2hhZGVyUmVxdWVzdDogVmVydGV4U2hhZGVyUmVxdWVzdFxyXG59O1xyXG4iLCJ2YXIgQyA9cmVxdWlyZShcIi4uL2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XHJcblxyXG4vKipcclxuICogQ0xQcm9ncmFtIGltcGxlbWVudHMgYXV0b21hdGljIFhmbG93IGlucHV0L291dHB1dCBhZGFwdGl2ZSBXZWJDTCBrZXJuZWwgYW5kIGFwcGxpY2F0aW9uIGNvZGUgZ2VuZXJhdGlvbi5cclxuICpcclxuICogQHBhcmFtIG9wZXJhdG9yTGlzdFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcblxyXG52YXIgQ0xQcm9ncmFtID0gZnVuY3Rpb24gKG9wZXJhdG9yTGlzdCkge1xyXG4gICAgdGhpcy5jbCA9IFhNTDNELndlYmNsLmNsOyAvLyBDTCB3cmFwcGVyXHJcblxyXG4gICAgaWYgKCF0aGlzLmNsKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubGlzdCA9IG9wZXJhdG9yTGlzdDtcclxuICAgIHRoaXMuZW50cnkgPSBvcGVyYXRvckxpc3QuZW50cmllc1swXTtcclxuICAgIHRoaXMub3BlcmF0b3IgPSB0aGlzLmVudHJ5Lm9wZXJhdG9yO1xyXG5cclxuICAgIHRoaXMua2VybmVsUGFyYW1NYXAgPSB7aW5wdXRzOiBbXSwgb3V0cHV0czogW119OyAvLyBTdG9yZXMgaW5pdGlhbGlzZWQgS2VybmVsUGFyYW0gb2JqZWN0c1xyXG4gICAgdGhpcy5rZXJuZWxGdW5jdGlvblBhcmFtcyA9IFtdOyAvLyBTdG9yZXMgZ2VuZXJhdGVkIGZ1bmN0aW9uIHBhcmFtZXRlcnMgZm9yIGtlcm5lbCBmdW5jdGlvbiBoZWFkZXIuXHJcbiAgICB0aGlzLmtlcm5lbENvZGUgPSBudWxsOyAvLyBHZW5lcmF0ZWQga2VybmVsIGNvZGVcclxuICAgIHRoaXMua2VybmVsUHJvZ3JhbSA9IG51bGw7IC8vIENvbXBpbGVkIGtlcm5lbCBwcm9ncmFtXHJcbiAgICB0aGlzLm1haW5Qcm9ncmFtID0gbnVsbDsgLy8gTWFpbiBXZWJDTCBhcHBsaWNhdGlvbiBjb2RlXHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1hcCBvZiBoZWxwZXIga2VybmVsIHBhcmFtZXRlcnMgcmVxdWlyZWQgZm9yIGNlcnRhaW4gaW5wdXQgZGF0YSB0eXBlcy5cclxuICpcclxuICogQHR5cGUgT2JqZWN0XHJcbiAqL1xyXG52YXIgaGVscGVyUGFyYW1NYXAgPSB7XHJcbiAgICAndGV4dHVyZSc6IHt0eXBlOiBcInVpbnRcIiwgcGFyYW1zOiBbXCJ3aWR0aFwiLCBcImhlaWdodFwiXX0sICdidWZmZXInOiB7dHlwZTogXCJ1aW50XCIsIHBhcmFtczogW1wibGVuZ3RoXCJdfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFV0aWxpdHkgcHJvdG90eXBlIG9iamVjdCBmb3IgbWFwcGluZyBYZmxvdyBpbnB1dHMgdG8ga2VybmVsIHBhcmFtZXRlcnMgYW5kIGZvciBnZW5lcmF0aW5nIGtlcm5lbCBjb2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvZ3JhbVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gKiBAcGFyYW0ge0MuREFUQV9UWVBFfSB4Zmxvd1R5cGVcclxuICogQHBhcmFtIHtTdHJpbmd9IGNsVHlwZVxyXG4gKiBAcGFyYW0gZW50cnlWYWx1ZVxyXG4gKiBAcGFyYW0ge0Jvb2xlYW4/fSBpc0lucHV0XHJcbiAqIEBuYW1lIEtlcm5lbFBhcmFtXHJcbiAqIEBjb25zdHJ1Y3RvciBLZXJuZWxQYXJhbVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEtlcm5lbFBhcmFtKHByb2dyYW0sIG5hbWUsIHhmbG93VHlwZSwgY2xUeXBlLCBlbnRyeVZhbHVlLCBpc0lucHV0KSB7XHJcbiAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xyXG4gICAgdGhpcy5jbCA9IHByb2dyYW0uY2w7XHJcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgdGhpcy50eXBlID0gY2xUeXBlIHx8IG51bGw7XHJcbiAgICB0aGlzLmlzSW5wdXQgPSAhIWlzSW5wdXQ7XHJcbiAgICB0aGlzLm5lZWRzTWVtT2JqZWN0ID0gZmFsc2U7XHJcbiAgICB0aGlzLmhhc01lbU9iamVjdCA9IGZhbHNlO1xyXG4gICAgdGhpcy5ieXRlU2l6ZSA9IG51bGw7XHJcbiAgICB0aGlzLm1lbU9iamVjdFNpemUgPSBudWxsO1xyXG4gICAgdGhpcy5hcmcgPSBudWxsO1xyXG4gICAgdGhpcy5jbEZ1bmN0aW9uUGFyYW0gPSBudWxsO1xyXG4gICAgdGhpcy54Zmxvd1R5cGUgPSB4Zmxvd1R5cGU7XHJcbiAgICB0aGlzLmhlbHBlck1hcCA9IG51bGw7XHJcbiAgICB0aGlzLmhlbHBlcnMgPSBbXTtcclxuICAgIHRoaXMuZW50cnlWYWx1ZSA9IGVudHJ5VmFsdWUgfHwgbnVsbDtcclxuICAgIHRoaXMudmFsID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLnByZXBhcmVQYXJhbSgpO1xyXG4gICAgdGhpcy5pbml0SGVscGVyUGFyYW1zKCk7XHJcbiAgICB0aGlzLmluaXRLZXJuZWxBcmcoKTtcclxuICAgIHRoaXMudXBkYXRlVmFsdWUodGhpcy5lbnRyeVZhbHVlKTtcclxuXHJcbn1cclxuXHJcbktlcm5lbFBhcmFtLnByb3RvdHlwZSA9IHtcclxuICAgIC8qKlxyXG4gICAgICogUHJlcGFyZXMgdGhlIGtlcm5lbCBwYXJhbWV0ZXIgZGF0YS5cclxuICAgICAqIE1hcHMgdGhlIGlucHV0IHhmbG93IGRhdGEgdHlwZSB0byB3ZWJjbCBkYXRhIHR5cGUgYW5kIGNyZWF0ZXMgYSBrZXJuZWwgZnVuY3Rpb24gaGVhZGVyIHBhcmFtZXRlciB3aXRoIHByb3BlclxyXG4gICAgICogZGVjbGFyYXRpb25zLlxyXG4gICAgICovXHJcbiAgICBwcmVwYXJlUGFyYW06IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaGVscGVyTWFwO1xyXG4gICAgICAgIHZhciB4Zmxvd0RhdGFUeXBlcyA9IEMuREFUQV9UWVBFO1xyXG4gICAgICAgIHZhciBrZXJuZWxGdW5jUGFyYW0gPSBbXTtcclxuICAgICAgICB2YXIgYWRkcmVzc1NwYWNlID0gJyc7XHJcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9ICcnO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMudHlwZSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMueGZsb3dUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIHhmbG93RGF0YVR5cGVzLlRFWFRVUkU6XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyTWFwID0gaGVscGVyUGFyYW1NYXAudGV4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcInVjaGFyNCpcIjtcclxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzU3BhY2UgPSBcIl9fZ2xvYmFsXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZWVkc01lbU9iamVjdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIHhmbG93RGF0YVR5cGVzLklOVDpcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcImludFwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSB4Zmxvd0RhdGFUeXBlcy5JTlQ0OlxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlck1hcCA9IGhlbHBlclBhcmFtTWFwLmJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcImludDQqXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1NwYWNlID0gXCJfX2dsb2JhbFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmVlZHNNZW1PYmplY3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSB4Zmxvd0RhdGFUeXBlcy5GTE9BVDpcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcImZsb2F0XCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIHhmbG93RGF0YVR5cGVzLkZMT0FUMjpcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWxwZXJNYXAgPSBoZWxwZXJQYXJhbU1hcC5idWZmZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJmbG9hdDIqXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1NwYWNlID0gXCJfX2dsb2JhbFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmVlZHNNZW1PYmplY3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSB4Zmxvd0RhdGFUeXBlcy5GTE9BVDM6XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyTWFwID0gaGVscGVyUGFyYW1NYXAuYnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiZmxvYXQqXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1NwYWNlID0gXCJfX2dsb2JhbFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmVlZHNNZW1PYmplY3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSB4Zmxvd0RhdGFUeXBlcy5GTE9BVDQ6XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyTWFwID0gaGVscGVyUGFyYW1NYXAuYnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiZmxvYXQ0KlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3NTcGFjZSA9IFwiX19nbG9iYWxcIjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5lZWRzTWVtT2JqZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgeGZsb3dEYXRhVHlwZXMuRkxPQVQ0WDQ6XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyTWFwID0gaGVscGVyUGFyYW1NYXAuYnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiZmxvYXQxNipcIjtcclxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzU3BhY2UgPSBcIl9fZ2xvYmFsXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZWVkc01lbU9iamVjdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5oZWxwZXJNYXAgPSBoZWxwZXJNYXA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcnJhbmdpbmcgcGFyYW1ldGVyIHBhcnRzXHJcbiAgICAgICAgaWYgKGFkZHJlc3NTcGFjZSkge1xyXG4gICAgICAgICAgICBrZXJuZWxGdW5jUGFyYW0ucHVzaChhZGRyZXNzU3BhY2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaXNJbnB1dCkge1xyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnMgPSAnY29uc3QnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRlY2xhcmF0aW9ucykge1xyXG4gICAgICAgICAgICBrZXJuZWxGdW5jUGFyYW0ucHVzaChkZWNsYXJhdGlvbnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAga2VybmVsRnVuY1BhcmFtLnB1c2godGhpcy50eXBlKTtcclxuICAgICAgICBrZXJuZWxGdW5jUGFyYW0ucHVzaCh0aGlzLm5hbWUpO1xyXG4gICAgICAgIHRoaXMuY2xGdW5jdGlvblBhcmFtID0ga2VybmVsRnVuY1BhcmFtLmpvaW4oJyAnKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXNlcyBoZWxwZXIgcGFyYW1ldGVycyBmb3IgYW4gaW5wdXQgcGFyYW1ldGVyIGlmIG5lZWRlZC5cclxuICAgICAqXHJcbiAgICAgKi9cclxuXHJcbiAgICBpbml0SGVscGVyUGFyYW1zOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGhlbHBlclZhbDtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGhlbHBlck1hcCA9IHRoaXMuaGVscGVyTWFwO1xyXG5cclxuICAgICAgICBpZiAoaGVscGVyTWFwICYmIHRoaXMuaXNJbnB1dCkge1xyXG4gICAgICAgICAgICBoZWxwZXJNYXAucGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgICAgIHZhciBwTmFtZSA9IHNlbGYubmFtZSArICdfJyArIHA7XHJcbiAgICAgICAgICAgICAgICBpZiAocCA9PT0gXCJ3aWR0aFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyVmFsID0gc2VsZi5lbnRyeVZhbHVlLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcImhlaWdodFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyVmFsID0gc2VsZi5lbnRyeVZhbHVlLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJsZW5ndGhcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlclZhbCA9IHNlbGYuZW50cnlWYWx1ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBzZWxmLnhmbG93VHlwZTtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5GTE9BVDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlclZhbCA9IGhlbHBlclZhbCAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyVmFsID0gaGVscGVyVmFsIC8gMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuRkxPQVQ0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLklOVDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlclZhbCA9IGhlbHBlclZhbCAvIDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUNFg0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXJWYWwgPSBoZWxwZXJWYWwgLyAxNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlbHBlcnMucHVzaChuZXcgS2VybmVsUGFyYW0oc2VsZi5wcm9ncmFtLCBwTmFtZSwgbnVsbCwgaGVscGVyTWFwLnR5cGUsIG5ldyBVaW50MzJBcnJheShbaGVscGVyVmFsXSkpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpc2VzIGtlcm5lbCBhcmd1bWVudCB0aGF0IHdpbGwgYmUgcGFzc2VkIGRpcmVjdGx5IGludG8gdGhlIGNvbXBpbGVkIGtlcm5lbC5cclxuICAgICAqIENyZWF0ZXMgYSBXZWJDTCBtZW1vcnkgb2JqZWN0IGlmIG5lZWRlZCAoZS5nLiBmb3IgdGV4dHVyZSkuXHJcbiAgICAgKi9cclxuXHJcbiAgICBpbml0S2VybmVsQXJnOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubmVlZHNNZW1PYmplY3QpIHtcclxuICAgICAgICAgICAgdGhpcy5hbGxvY2F0ZU1lbU9iamVjdCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXJnID0gdGhpcy5lbnRyeVZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgYWxsb2NhdGVNZW1PYmplY3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2xBUEkgPSB0aGlzLmNsLkFQSTtcclxuICAgICAgICB2YXIgY2xDdHggPSB0aGlzLmNsLmN0eDtcclxuICAgICAgICB2YXIgcGFyYW1UeXBlID0gdGhpcy50eXBlO1xyXG4gICAgICAgIHZhciBieXRlU2l6ZSA9IHBhcnNlSW50KHBhcmFtVHlwZS5zdWJzdHJpbmcocGFyYW1UeXBlLmxlbmd0aCAtIDIsIHBhcmFtVHlwZS5sZW5ndGggLSAxKSwgMTApO1xyXG4gICAgICAgIHZhciBtZW1PYmplY3RNb2RlID0gdGhpcy5pc0lucHV0ID8gJ3InIDogJ3cnO1xyXG4gICAgICAgIHZhciBlbnRyeVZhbHVlID0gdGhpcy5lbnRyeVZhbHVlO1xyXG4gICAgICAgIHZhciBtZW1PYmplY3RTaXplLCBtZW1PYmplY3Q7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmhhc01lbU9iamVjdCkge1xyXG4gICAgICAgICAgICB0aGlzLmFyZy5yZWxlYXNlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmJ5dGVTaXplID0gaXNOYU4oYnl0ZVNpemUpID8gMSA6IGJ5dGVTaXplO1xyXG5cclxuICAgICAgICBpZiAodGhpcy54Zmxvd1R5cGUgPT09IEMuREFUQV9UWVBFLlRFWFRVUkUpIHsgLy8gVGV4dHVyZSBpcyBhIHNwZWNpYWwgY2FzZVxyXG4gICAgICAgICAgICBtZW1PYmplY3RTaXplID0gZW50cnlWYWx1ZS53aWR0aCAqIGVudHJ5VmFsdWUuaGVpZ2h0ICogYnl0ZVNpemU7XHJcbiAgICAgICAgICAgIHRoaXMuYnl0ZVNpemUgPSA0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy54Zmxvd1R5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuSU5UNDpcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBtZW1PYmplY3RTaXplID0gZW50cnlWYWx1ZS5sZW5ndGggKiBJbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5GTE9BVDI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUMzpcclxuICAgICAgICAgICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuRkxPQVQ0OlxyXG4gICAgICAgICAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5GTE9BVDR4NDpcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBtZW1PYmplY3RTaXplID0gZW50cnlWYWx1ZS5sZW5ndGggKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIG1lbU9iamVjdFNpemUgPSBlbnRyeVZhbHVlLmxlbmd0aCAqIDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG1lbU9iamVjdCA9IGNsQVBJLmNyZWF0ZUJ1ZmZlcihtZW1PYmplY3RTaXplLCBtZW1PYmplY3RNb2RlLCBjbEN0eCk7XHJcblxyXG4gICAgICAgIHRoaXMubWVtT2JqZWN0U2l6ZSA9IG1lbU9iamVjdFNpemU7XHJcbiAgICAgICAgdGhpcy5hcmcgPSBtZW1PYmplY3Q7XHJcblxyXG4gICAgICAgIHRoaXMuaGFzTWVtT2JqZWN0ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm5lZWRzTWVtT2JqZWN0ID0gZmFsc2U7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVWYWx1ZTogZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzTWVtT2JqZWN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsID0gZW50cnkuZGF0YSA9PT0gdW5kZWZpbmVkID8gZW50cnkgOiBlbnRyeS5kYXRhO1xyXG4gICAgICAgICAgICB0aGlzLmVudHJ5VmFsdWUgPSBlbnRyeTtcclxuICAgICAgICAgICAgdGhpcy5jaGVja0VudHJ5U2l6ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXJnID0gdGhpcy5lbnRyeVZhbHVlID0gZW50cnk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgdXBkYXRlSGVscGVyczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBoZWxwZXJzID0gdGhpcy5oZWxwZXJzO1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgaGVscGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gcC5uYW1lO1xyXG4gICAgICAgICAgICBpZiAobmFtZS5pbmRleE9mKFwid2lkdGhcIikgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBwLnVwZGF0ZVZhbHVlKG5ldyBVaW50MzJBcnJheShbc2VsZi5lbnRyeVZhbHVlLndpZHRoXSkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUuaW5kZXhPZihcImhlaWdodFwiKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHAudXBkYXRlVmFsdWUobmV3IFVpbnQzMkFycmF5KFtzZWxmLmVudHJ5VmFsdWUuaGVpZ2h0XSkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUuaW5kZXhPZihcImxlbmd0aFwiKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBzZWxmLmVudHJ5VmFsdWUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYueGZsb3dUeXBlID09PSBDLkRBVEFfVFlQRS5GTE9BVDQgfHwgc2VsZi54Zmxvd1R5cGUgPT09IEMuREFUQV9UWVBFLklOVDQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZW4gPSBsZW4gLyA0O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLnhmbG93VHlwZSA9PT0gQy5EQVRBX1RZUEUuRkxPQVQ0WDQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZW4gPSBsZW4gLyAxNjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHAudXBkYXRlVmFsdWUobmV3IFVpbnQzMkFycmF5KFtsZW5dKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0sIGNoZWNrRW50cnlTaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5ld1NpemU7XHJcbiAgICAgICAgdmFyIGVudHJ5VmFsID0gdGhpcy5lbnRyeVZhbHVlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy54Zmxvd1R5cGUgPT09IEMuREFUQV9UWVBFLlRFWFRVUkUpIHtcclxuICAgICAgICAgICAgbmV3U2l6ZSA9IGVudHJ5VmFsLndpZHRoICogZW50cnlWYWwuaGVpZ2h0ICogdGhpcy5ieXRlU2l6ZTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMueGZsb3dUeXBlID09PSBDLkRBVEFfVFlQRS5GTE9BVDIgfHwgdGhpcy54Zmxvd1R5cGUgPT09IEMuREFUQV9UWVBFLkZMT0FUMyB8fCB0aGlzLnhmbG93VHlwZSA9PT0gQy5EQVRBX1RZUEUuRkxPQVQ0IHx8IHRoaXMueGZsb3dUeXBlID09PSBDLkRBVEFfVFlQRS5GTE9BVDRYNCkge1xyXG4gICAgICAgICAgICBuZXdTaXplID0gZW50cnlWYWwubGVuZ3RoICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy54Zmxvd1R5cGUgPT09IEMuREFUQV9UWVBFLklOVDQpIHtcclxuICAgICAgICAgICAgbmV3U2l6ZSA9IGVudHJ5VmFsLmxlbmd0aCAqIEludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmV3U2l6ZSA9IGVudHJ5VmFsLmxlbmd0aCAqIHRoaXMuYnl0ZVNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1lbU9iamVjdFNpemUgIT09IG5ld1NpemUpIHtcclxuICAgICAgICAgICAgdGhpcy5hbGxvY2F0ZU1lbU9iamVjdCgpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUhlbHBlcnMoKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9ncmFtLm1haW5Qcm9ncmFtID0gbnVsbDsgLy8gRm9yY2luZyBDTCBhcHBsaWNhdGlvbiBwcm9ncmFtIHVwZGF0ZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogUnVucyBDTFByb2dyYW0uIFdlYkNMIHJlbGF0ZWQgY29kZSBpbml0aWFsaXNlZCBpbiB0aGUgZmlyc3QgcnVuLlxyXG4gKlxyXG4gKiBAcGFyYW0gcHJvZ3JhbURhdGFcclxuICovXHJcblxyXG5DTFByb2dyYW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChwcm9ncmFtRGF0YSkge1xyXG4gICAgdmFyIG9wZXJhdG9yRGF0YSA9IHByZXBhcmVPcGVyYXRvckRhdGEodGhpcy5saXN0LCAwLCBwcm9ncmFtRGF0YSk7XHJcblxyXG4gICAgYXBwbHlEZWZhdWx0T3BlcmF0aW9uKHRoaXMuZW50cnksIHByb2dyYW1EYXRhLCBvcGVyYXRvckRhdGEsIHRoaXMpO1xyXG5cclxufTtcclxuXHJcbmZ1bmN0aW9uIHByZXBhcmVPcGVyYXRvckRhdGEobGlzdCwgaWR4LCBwcm9ncmFtRGF0YSkge1xyXG4gICAgdmFyIGRvSXRlcmF0ZSwgaTtcclxuICAgIHZhciBkYXRhID0gcHJvZ3JhbURhdGEub3BlcmF0b3JEYXRhWzBdO1xyXG4gICAgdmFyIGVudHJ5ID0gbGlzdC5lbnRyaWVzW2lkeF07XHJcbiAgICB2YXIgbWFwcGluZyA9IGVudHJ5Lm9wZXJhdG9yLm1hcHBpbmc7XHJcblxyXG4gICAgZGF0YS5pdGVyRmxhZyA9IHt9O1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBtYXBwaW5nLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgZG9JdGVyYXRlID0gKGVudHJ5LmlzVHJhbnNmZXJJbnB1dChpKSB8fCBsaXN0LmlzSW5wdXRJdGVyYXRlKGVudHJ5LmdldERpcmVjdElucHV0SW5kZXgoaSkpKTtcclxuICAgICAgICBkYXRhLml0ZXJGbGFnW2ldID0gZG9JdGVyYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIGRhdGEuaXRlcmF0ZUNvdW50ID0gbGlzdC5nZXRJdGVyYXRlQ291bnQocHJvZ3JhbURhdGEpO1xyXG5cclxuICAgIHJldHVybiBkYXRhO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseURlZmF1bHRPcGVyYXRpb24oZW50cnksIHByb2dyYW1EYXRhLCBvcGVyYXRvckRhdGEsIHByb2dyYW0pIHtcclxuICAgIGlmIChwcm9ncmFtLm9wZXJhdG9yLmV2YWx1YXRlICYmIHByb2dyYW0ub3BlcmF0b3IuZXZhbHVhdGUgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgIGFzc2VtYmxlRnVuY3Rpb25BcmdzKGVudHJ5LCBwcm9ncmFtRGF0YSwgcHJvZ3JhbSk7XHJcblxyXG4gICAgICAgIGlmIChwcm9ncmFtLmtlcm5lbENvZGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcHJlcGFyZVdlYkNMS2VybmVsKHByb2dyYW1EYXRhLCBwcm9ncmFtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9jb25zb2xlLnRpbWUoJ0NMUHJvZ3JhbSAoJyArIHByb2dyYW0ub3BlcmF0b3IubmFtZSArICcpJyk7XHJcbiAgICAgICAgaWYgKHByb2dyYW0ubWFpblByb2dyYW0gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcHJvZ3JhbS5tYWluUHJvZ3JhbSA9IGNyZWF0ZU1haW5XZWJDTFByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb2dyYW0ubWFpblByb2dyYW0oKTtcclxuICAgICAgICAvL2NvbnNvbGUudGltZUVuZCgnQ0xQcm9ncmFtICgnICsgcHJvZ3JhbS5vcGVyYXRvci5uYW1lICsgJyknKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIE1hcHMgWGZsb3cgaW5wdXRzIGFuZCBvdXRwdXRzIGludG8gV2ViQ0wga2VybmVsIGlucHV0cyBhbmQgb3V0cHV0cy5cclxuICpcclxuICogQGZ1bmN0aW9uIGFzc2VtYmxlRnVuY3Rpb25BcmdzXHJcbiAqIEBwYXJhbSBlbnRyeVxyXG4gKiBAcGFyYW0gcHJvZ3JhbURhdGFcclxuICogQHBhcmFtIHByb2dyYW1cclxuICovXHJcblxyXG5mdW5jdGlvbiBhc3NlbWJsZUZ1bmN0aW9uQXJncyhlbnRyeSwgcHJvZ3JhbURhdGEsIHByb2dyYW0pIHtcclxuICAgIHZhciBkLCBkYXRhRW50cnksIGk7XHJcbiAgICB2YXIga2VybmVsRnVuY3Rpb25QYXJhbXMgPSBwcm9ncmFtLmtlcm5lbEZ1bmN0aW9uUGFyYW1zO1xyXG4gICAgdmFyIG91dHB1dHMgPSBwcm9ncmFtLm9wZXJhdG9yLm91dHB1dHM7XHJcblxyXG4gICAga2VybmVsRnVuY3Rpb25QYXJhbXMubGVuZ3RoID0gMDtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3V0cHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGQgPSBvdXRwdXRzW2ldO1xyXG4gICAgICAgIGRhdGFFbnRyeSA9IHByb2dyYW1EYXRhLm91dHB1dHNbZW50cnkuZ2V0T3V0cHV0SW5kZXgoaSldLmRhdGFFbnRyeTtcclxuXHJcbiAgICAgICAgcHJlcGFyZUtlcm5lbFBhcmFtZXRlcihkLCAhIShkLnNvdXJjZSksIHByb2dyYW0sIGtlcm5lbEZ1bmN0aW9uUGFyYW1zLCBkYXRhRW50cnksIGkpO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZElucHV0VG9BcmdzKGVudHJ5LCBwcm9ncmFtRGF0YSwgcHJvZ3JhbSwga2VybmVsRnVuY3Rpb25QYXJhbXMpO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gYWRkSW5wdXRUb0FyZ3MoZW50cnksIHByb2dyYW1EYXRhLCBwcm9ncmFtLCBrZXJuZWxGdW5jdGlvblBhcmFtcykge1xyXG4gICAgdmFyIG1hcEVudHJ5LCBkYXRhRW50cnksIGk7XHJcbiAgICB2YXIgbWFwcGluZyA9IGVudHJ5Lm9wZXJhdG9yLm1hcHBpbmc7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IG1hcHBpbmcubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBtYXBFbnRyeSA9IG1hcHBpbmdbaV07XHJcbiAgICAgICAgZGF0YUVudHJ5ID0gcHJvZ3JhbURhdGEuZ2V0RGF0YUVudHJ5KGVudHJ5LmdldERpcmVjdElucHV0SW5kZXgoaSkpO1xyXG5cclxuICAgICAgICBwcmVwYXJlS2VybmVsUGFyYW1ldGVyKG1hcEVudHJ5LCAhIShtYXBFbnRyeS5zb3VyY2UpLCBwcm9ncmFtLCBrZXJuZWxGdW5jdGlvblBhcmFtcywgZGF0YUVudHJ5LCBpKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgS2VybmVsUGFyYW0gdXRpbGl0eSBvYmplY3Qgb3IgdXBkYXRlcyB0aGUgZXhpc3Rpbmcgb2JqZWN0IGlmIGlucHV0IHZhbHVlIGhhcyBiZWVuIGNoYW5nZWQuXHJcbiAqIEFkZGl0aW9uYWxseSwgdGhpcyBpcyB1c2VkIGZvciBnZW5lcmF0aW5nIHRoZSBXZWJDTCBrZXJuZWwgZnVuY3Rpb24gaGVhZGVyLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb24gcHJlcGFyZUtlcm5lbFBhcmFtZXRlclxyXG4gKiBAcGFyYW0gcGFyYW1cclxuICogQHBhcmFtIGlucHV0XHJcbiAqIEBwYXJhbSBwcm9ncmFtXHJcbiAqIEBwYXJhbSBmdW5jdGlvblBhcmFtc1xyXG4gKiBAcGFyYW0gYXJnXHJcbiAqIEBwYXJhbSBpXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gcHJlcGFyZUtlcm5lbFBhcmFtZXRlcihwYXJhbSwgaW5wdXQsIHByb2dyYW0sIGZ1bmN0aW9uUGFyYW1zLCBhcmcsIGkpIHtcclxuICAgIHZhciBrZXJuZWxQYXJhbXM7XHJcbiAgICB2YXIgZW50cnlWYWwgPSBhcmcgPyBhcmcuZ2V0VmFsdWUoKSA6IG51bGw7XHJcblxyXG4gICAgaWYgKGlucHV0KSB7XHJcbiAgICAgICAga2VybmVsUGFyYW1zID0gcHJvZ3JhbS5rZXJuZWxQYXJhbU1hcC5pbnB1dHM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGtlcm5lbFBhcmFtcyA9IHByb2dyYW0ua2VybmVsUGFyYW1NYXAub3V0cHV0cztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoa2VybmVsUGFyYW1zW2ldKSB7XHJcbiAgICAgICAga2VybmVsUGFyYW1zW2ldLnVwZGF0ZVZhbHVlKGVudHJ5VmFsKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAga2VybmVsUGFyYW1zW2ldID0gbmV3IEtlcm5lbFBhcmFtKHByb2dyYW0sIHBhcmFtLm5hbWUsIHBhcmFtLnR5cGUsIG51bGwsIGVudHJ5VmFsLCBpbnB1dCk7XHJcblxyXG4gICAgLy8gUHVzaGluZyBnZW5lcmF0ZWQga2VybmVsIGZ1bmN0aW9uIHBhcmFtcyBpbnRvIGFycmF5LlxyXG4gICAgLy8gVGhpcyBhcnJheSBpcyBsYXRlciB1c2VkIGluIGdlbmVyYXRpbmcgdGhlIFdlYkNMIGtlcm5lbCBmdW5jdGlvbiBoZWFkZXIuXHJcbiAgICBmdW5jdGlvblBhcmFtcy5wdXNoKGtlcm5lbFBhcmFtc1tpXS5jbEZ1bmN0aW9uUGFyYW0pO1xyXG5cclxuICAgIGtlcm5lbFBhcmFtc1tpXS5oZWxwZXJzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcclxuICAgICAgICBmdW5jdGlvblBhcmFtcy5wdXNoKHAuY2xGdW5jdGlvblBhcmFtKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5cclxuLyoqIEtFUk5FTCBDT0RFIFBSRVBBUkFUSU9OICoqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDb21waWxlcyBhbmQgcmVnaXN0ZXJzIHRoZSBwcmVwYXJlZCBXZWJDTCBrZXJuZWwgY29kZS5cclxuICpcclxuICogQGZ1bmN0aW9uIHByZXBhcmVXZWJDTEtlcm5lbFxyXG4gKiBAcGFyYW0gcHJvZ3JhbURhdGFcclxuICogQHBhcmFtIHByb2dyYW1cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gcHJlcGFyZVdlYkNMS2VybmVsKHByb2dyYW1EYXRhLCBwcm9ncmFtKSB7XHJcbiAgICB2YXIga2VybmVsQ29kZTtcclxuICAgIHZhciBrZXJuZWxNYW5hZ2VyID0gcHJvZ3JhbS5jbC5rZXJuZWxNYW5hZ2VyO1xyXG4gICAgdmFyIGlucHV0S2VybmVsID0gcHJvZ3JhbS5vcGVyYXRvci5ldmFsdWF0ZTtcclxuICAgIHZhciBrZXJuZWxOYW1lID0gcHJvZ3JhbS5rZXJuZWxOYW1lID0gcHJvZ3JhbS5vcGVyYXRvci5uYW1lLnNwbGl0KCd4Zmxvdy4nKVsxXTtcclxuXHJcbiAgICBpZiAoIWlucHV0S2VybmVsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGtlcm5lbENvZGUgPSBwcm9ncmFtLmtlcm5lbENvZGUgPSBwcmVwYXJlS2VybmVsQ29kZShrZXJuZWxOYW1lLCBpbnB1dEtlcm5lbCwgcHJvZ3JhbSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICBrZXJuZWxNYW5hZ2VyLnJlZ2lzdGVyKGtlcm5lbE5hbWUsIGtlcm5lbENvZGUpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwcm9ncmFtLmtlcm5lbFByb2dyYW0gPSBrZXJuZWxNYW5hZ2VyLmdldEtlcm5lbChwcm9ncmFtLmtlcm5lbE5hbWUpO1xyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICpcclxuICogR2VuZXJhdGVzIGtlcm5lbCBmdW5jdGlvbiBoZWFkZXIgYW5kIGhlbHBlciBrZXJuZWwgY29kZSBhbmQgY29tYmluZXMgaXQgd2l0aCB1c2VyJ3MgaW5wdXQga2VybmVsIGNvZGUuXHJcbiAqXHJcbiAqIEBmdW5jdGlvbiBwcmVwYXJlS2VybmVsQ29kZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30ga2VybmVsTmFtZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBpbnB1dEtlcm5lbFxyXG4gKiBAcGFyYW0gcHJvZ3JhbVxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHByZXBhcmVLZXJuZWxDb2RlKGtlcm5lbE5hbWUsIGlucHV0S2VybmVsLCBwcm9ncmFtKSB7XHJcbiAgICB2YXIgcmVzdWx0LCBpbm5lcktlcm5lbENvZGU7XHJcblxyXG4gICAgcmVzdWx0ID0gY3JlYXRlS2VybmVsSGVhZGVyKGtlcm5lbE5hbWUsIHByb2dyYW0pO1xyXG5cclxuICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc3VsdCArPSAne1xcbic7XHJcblxyXG4gICAgaW5uZXJLZXJuZWxDb2RlID0gY3JlYXRlSW5uZXJLZXJuZWxDb2RlKHByb2dyYW0pO1xyXG5cclxuICAgIGlmICghaW5uZXJLZXJuZWxDb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc3VsdCArPSBpbm5lcktlcm5lbENvZGU7XHJcbiAgICByZXN1bHQgKz0gaW5wdXRLZXJuZWwuam9pbignXFxuJyk7XHJcbiAgICByZXN1bHQgKz0gJ1xcbn0nO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBrZXJuZWwgZnVuY3Rpb24gaGVhZGVyIGZyb20gYXNzZW1ibGVkIGtlcm5lbCBwYXJhbWV0ZXJzLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb24gY3JlYXRlS2VybmVsSGVhZGVyXHJcbiAqIEBwYXJhbSBrZXJuZWxOYW1lXHJcbiAqIEBwYXJhbSBwcm9ncmFtXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlS2VybmVsSGVhZGVyKGtlcm5lbE5hbWUsIHByb2dyYW0pIHtcclxuICAgIHZhciBmdW5jdGlvbkhlYWRlciA9IFtdO1xyXG5cclxuICAgIGZ1bmN0aW9uSGVhZGVyLnB1c2goXCJfX2tlcm5lbCB2b2lkXCIpO1xyXG4gICAgZnVuY3Rpb25IZWFkZXIucHVzaChrZXJuZWxOYW1lICsgJygnKTtcclxuICAgIGZ1bmN0aW9uSGVhZGVyLnB1c2gocHJvZ3JhbS5rZXJuZWxGdW5jdGlvblBhcmFtcy5qb2luKCcsICcpKTtcclxuICAgIGZ1bmN0aW9uSGVhZGVyLnB1c2goJyknKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb25IZWFkZXIuam9pbignICcpO1xyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhdGVzIGhlbHBlciBrZXJuZWwgY29kZS5cclxuICpcclxuICogQGZ1bmN0aW9uIGNyZWF0ZUlubmVyS2VybmVsQ29kZVxyXG4gKiBAcGFyYW0gcHJvZ3JhbVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUlubmVyS2VybmVsQ29kZShwcm9ncmFtKSB7XHJcbiAgICB2YXIgY29kZUxpbmVzID0gW107XHJcblxyXG4gICAgdmFyIGZpcnN0SW5wdXQgPSBwcm9ncmFtLmtlcm5lbFBhcmFtTWFwLmlucHV0c1swXTtcclxuXHJcbiAgICBpZiAoZmlyc3RJbnB1dC50eXBlID09PSBcInVjaGFyNCpcIikge1xyXG4gICAgICAgIC8vIEFkZCBcIml0ZXJhdG9yc1wiXHJcbiAgICAgICAgY29kZUxpbmVzLnB1c2goXCJpbnQgeCA9IGdldF9nbG9iYWxfaWQoMCk7XCIpO1xyXG4gICAgICAgIGNvZGVMaW5lcy5wdXNoKFwiaW50IHkgPSBnZXRfZ2xvYmFsX2lkKDEpO1wiKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGJvdW5kcyBjaGVja2Vyc1xyXG4gICAgICAgIGNvZGVMaW5lcy5wdXNoKFwiaWYgKHggPj0gXCIgKyBmaXJzdElucHV0Lm5hbWUgKyBcIl93aWR0aCB8fCB5ID49IFwiICsgZmlyc3RJbnB1dC5uYW1lICsgXCJfaGVpZ2h0KSByZXR1cm47XCIpO1xyXG5cclxuICAgICAgICAvLyBBZGQgaW5wdXQgaXRlcmF0b3JcclxuICAgICAgICBjb2RlTGluZXMucHVzaChcImludCBcIiArIGZpcnN0SW5wdXQubmFtZSArIFwiX2kgPSB5ICogXCIgKyBmaXJzdElucHV0Lm5hbWUgKyBcIl93aWR0aCArIHg7XCIpO1xyXG5cclxuICAgIH0gZWxzZSB7IC8vIEVsc2UsIGFzc3VtaW5nIHRoYXQgdGhlIGZpcnN0IGlucHV0IGlzIGFuIDEtZGltZW5zaW9uYWwgYnVmZmVyXHJcblxyXG4gICAgICAgIGNvZGVMaW5lcy5wdXNoKFwiaW50IFwiICsgZmlyc3RJbnB1dC5uYW1lICsgXCJfaSA9IGdldF9nbG9iYWxfaWQoMCk7XCIpO1xyXG5cclxuICAgICAgICBjb2RlTGluZXMucHVzaChcImlmIChcIiArIGZpcnN0SW5wdXQubmFtZSArIFwiX2kgPj0gXCIgKyBmaXJzdElucHV0Lm5hbWUgKyBcIl9sZW5ndGgpIHJldHVybjtcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvZGVMaW5lcy5qb2luKCdcXG4nKTtcclxuXHJcbn1cclxuXHJcblxyXG4vKiogTUFJTiBXRUJDTCBQUk9HUkFNIElOSVRJQUxJU0FUSU9OICoqL1xyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpc2VzIHRoZSBtYWluIFdlYkNMIGFwcGxpY2F0aW9uIGNvZGUgdGhhdCBleGVjdXRlcyB0aGUgV2ViQ0wga2VybmVsXHJcbiAqXHJcbiAqIEBmdW5jdGlvbiBjcmVhdGVNYWluV2ViQ0xQcm9ncmFtXHJcbiAqIEBwYXJhbSBwcm9ncmFtXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cclxuICovXHJcblxyXG5mdW5jdGlvbiBjcmVhdGVNYWluV2ViQ0xQcm9ncmFtKHByb2dyYW0pIHtcclxuICAgIHZhciBjbCA9IHByb2dyYW0uY2w7XHJcbiAgICB2YXIga2VybmVsTWFuYWdlciA9IGNsLmtlcm5lbE1hbmFnZXI7XHJcbiAgICB2YXIgY21kUXVldWUgPSBjbC5jbWRRdWV1ZTtcclxuICAgIHZhciBtZW1PYmplY3RzID0ge2lucHV0czogW10sIG91dHB1dHM6IFtdfTtcclxuICAgIHZhciBhc3NlbWJsZWRBcmdzID0gYXNzZW1ibGVLZXJuZWxBcmd1bWVudHMocHJvZ3JhbS5rZXJuZWxQYXJhbU1hcCwgbWVtT2JqZWN0cyk7XHJcbiAgICB2YXIgV1NTaXplcyA9IGNvbXB1dGVXb3JrR3JvdXBTaXplKHByb2dyYW0ua2VybmVsUGFyYW1NYXAuaW5wdXRzWzBdKTtcclxuICAgIHZhciBrZXJuZWwgPSBwcm9ncmFtLmtlcm5lbFByb2dyYW07XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaSwgbGVuLCBtZW1PYmosIGFyZ3M7XHJcbiAgICAgICAgdmFyIGlucHV0TWVtT2JqcyA9IG1lbU9iamVjdHMuaW5wdXRzO1xyXG4gICAgICAgIHZhciBvdXRwdXRNZW1PYmpzID0gbWVtT2JqZWN0cy5vdXRwdXRzO1xyXG5cclxuICAgICAgICBpZiAoIWtlcm5lbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhcmdzID0gYXNzZW1ibGVkQXJncy5tYXAoZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEuYXJnO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBrZXJuZWxNYW5hZ2VyLnNldEFyZ3MuYXBwbHkobnVsbCwgW2tlcm5lbF0uY29uY2F0KGFyZ3MpKTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gV3JpdGUgdGhlIGJ1ZmZlciB0byBPcGVuQ0wgZGV2aWNlIG1lbW9yeVxyXG4gICAgICAgICAgICBsZW4gPSBpbnB1dE1lbU9ianMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG1lbU9iaiA9IGlucHV0TWVtT2Jqc1tpXTtcclxuICAgICAgICAgICAgICAgIGNtZFF1ZXVlLmVucXVldWVXcml0ZUJ1ZmZlcihtZW1PYmouYXJnLCBmYWxzZSwgMCwgLyptZW1PYmouYXJnLmdldEluZm8oV2ViQ0wuTUVNX1NJWkUpKi9tZW1PYmoubWVtT2JqZWN0U2l6ZSwgbWVtT2JqLnZhbCwgW10pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBFeGVjdXRlIChlbnF1ZXVlKSBrZXJuZWxcclxuICAgICAgICAgICAgY21kUXVldWUuZW5xdWV1ZU5EUmFuZ2VLZXJuZWwoa2VybmVsLCBXU1NpemVzWzFdLmxlbmd0aCwgW10sIFdTU2l6ZXNbMV0sIFdTU2l6ZXNbMF0pO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVhZCB0aGUgcmVzdWx0IGJ1ZmZlciBmcm9tIE9wZW5DTCBkZXZpY2VcclxuICAgICAgICAgICAgbGVuID0gb3V0cHV0TWVtT2Jqcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbWVtT2JqID0gb3V0cHV0TWVtT2Jqc1tpXTtcclxuICAgICAgICAgICAgICAgIGNtZFF1ZXVlLmVucXVldWVSZWFkQnVmZmVyKG1lbU9iai5hcmcsIGZhbHNlLCAwLCAvKm1lbU9iai5hcmcuZ2V0SW5mbyhXZWJDTC5NRU1fU0laRSkqL21lbU9iai5tZW1PYmplY3RTaXplLCBtZW1PYmoudmFsLCBbXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNtZFF1ZXVlLmZpbmlzaCgpOyAvL0ZpbmlzaCBhbGwgdGhlIG9wZXJhdGlvbnNcclxuXHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQXJyYW5nZXMgaW5pdGlhbGlzZWQga2VybmVsIGFyZ3VtZW50cyBpbnRvIGhlbHBlciBhcnJheXMgc28gdGhleSBhcmUgbW9yZSBlYXNpbHkgYXZhaWxhYmxlIGluXHJcbiAqIHRoZSBtYWluIFdlYkNMIGFwcGxpY2F0aW9uLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb24gYXNzZW1ibGVLZXJuZWxBcmd1bWVudHNcclxuICogQHBhcmFtIHBhcmFtTWFwXHJcbiAqIEBwYXJhbSBtZW1PYmplY3RzXHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICovXHJcblxyXG5mdW5jdGlvbiBhc3NlbWJsZUtlcm5lbEFyZ3VtZW50cyhwYXJhbU1hcCwgbWVtT2JqZWN0cykge1xyXG4gICAgdmFyIG91dHB1dHMgPSBwYXJhbU1hcC5vdXRwdXRzO1xyXG4gICAgdmFyIGlucHV0cyA9IHBhcmFtTWFwLmlucHV0cztcclxuICAgIHZhciBrZXJuZWxBcmdzID0gW107XHJcblxyXG4gICAgb3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgbWFwS2VybmVsQXJndW1lbnQocCwga2VybmVsQXJncywgbWVtT2JqZWN0cy5vdXRwdXRzKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgbWFwS2VybmVsQXJndW1lbnQocCwga2VybmVsQXJncywgbWVtT2JqZWN0cy5pbnB1dHMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGtlcm5lbEFyZ3M7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hcEtlcm5lbEFyZ3VtZW50KHBhcmFtLCBrZXJuZWxBcmdzLCBtZW1PYmplY3RzKSB7XHJcbiAgICBrZXJuZWxBcmdzLnB1c2gocGFyYW0pO1xyXG5cclxuICAgIGlmIChwYXJhbS5oYXNNZW1PYmplY3QpIHtcclxuICAgICAgICBtZW1PYmplY3RzLnB1c2gocGFyYW0pO1xyXG4gICAgICAgIHBhcmFtLmhlbHBlcnMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xyXG4gICAgICAgICAgICBrZXJuZWxBcmdzLnB1c2gocCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyBhIHByb3BlciBXZWJDTCBrZXJuZWwgd29ya2dyb3VwIHNpemUgZm9yIHRhcmdldCBpbnB1dCBidWZmZXJcclxuICpcclxuICogQGZ1bmN0aW9uIGNvbXB1dGVXb3JrR3JvdXBTaXplXHJcbiAqIEBwYXJhbSB0YXJnZXRJbnB1dFxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gY29tcHV0ZVdvcmtHcm91cFNpemUodGFyZ2V0SW5wdXQpIHtcclxuICAgIHZhciBsb2NhbFdTLCBnbG9iYWxXUztcclxuICAgIHZhciBlbnRyeVZhbCA9IHRhcmdldElucHV0LmVudHJ5VmFsdWU7XHJcblxyXG4gICAgaWYgKHRhcmdldElucHV0LnhmbG93VHlwZSA9PT0gQy5EQVRBX1RZUEUuVEVYVFVSRSkge1xyXG4gICAgICAgIGxvY2FsV1MgPSBbMTYsIDRdO1xyXG4gICAgICAgIGdsb2JhbFdTID0gW01hdGguY2VpbChlbnRyeVZhbC53aWR0aCAvIGxvY2FsV1NbMF0pICogbG9jYWxXU1swXSwgTWF0aC5jZWlsKGVudHJ5VmFsLmhlaWdodCAvIGxvY2FsV1NbMV0pICogbG9jYWxXU1sxXV07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBrID0gMTtcclxuICAgICAgICBzd2l0Y2ggKHRhcmdldElucHV0LnhmbG93VHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLklOVDQ6XHJcbiAgICAgICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuRkxPQVQ0OlxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBrID0gNDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuRkxPQVQzOlxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBrID0gMztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuRkxPQVQ0WDQ6XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGsgPSAxNjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxvY2FsV1MgPSBbMTZdO1xyXG4gICAgICAgIGdsb2JhbFdTID0gW01hdGguY2VpbChlbnRyeVZhbC5sZW5ndGggLyAobG9jYWxXU1swXSAqIGspKSAqIGxvY2FsV1NbMF1dO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBbbG9jYWxXUywgZ2xvYmFsV1NdO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENMUHJvZ3JhbTtcclxuIiwiWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmFkZFwiLCB7XHJcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0MycsIG5hbWU6ICdyZXN1bHQnfV0sXHJcbiAgICBwYXJhbXM6ICBbICB7dHlwZTogJ2Zsb2F0MycsIHNvdXJjZTogJ3ZhbHVlMSd9LFxyXG4gICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICd2YWx1ZTInfV0sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZTEsIHZhbHVlMiwgaW5mbykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCB1c2VkIVwiKTtcclxuICAgIH0sXHJcbiAgICBldmFsdWF0ZV9jb3JlOiBmdW5jdGlvbihyZXN1bHQsIHZhbHVlMSwgdmFsdWUyKXtcclxuICAgICAgICByZXN1bHRbMF0gPSB2YWx1ZTFbMF0gKyB2YWx1ZTJbMF07XHJcbiAgICAgICAgcmVzdWx0WzFdID0gdmFsdWUxWzFdICsgdmFsdWUyWzFdO1xyXG4gICAgICAgIHJlc3VsdFsyXSA9IHZhbHVlMVsyXSArIHZhbHVlMlsyXTtcclxuICAgIH1cclxufSk7XHJcbiIsIlhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5idWZmZXJTZWxlY3RcIiwge1xyXG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdDMnLCBuYW1lOiAncmVzdWx0Jywgbm9BbGxvYzogdHJ1ZX1dLFxyXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICd0cnVlT3B0aW9uJywgYXJyYXk6IHRydWV9LFxyXG4gICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICdmYWxzZU9wdGlvbicsIGFycmF5OiB0cnVlfSxcclxuICAgICAgICAgICAgICAgIHt0eXBlOiAnYm9vbCcsIHNvdXJjZTogJ3ZhbHVlJywgYXJyYXk6IHRydWV9XSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGZhbHNlT3B0aW9uLCB0cnVlT3B0aW9uLCB2YWx1ZSkge1xyXG4gICAgICAgIHJlc3VsdC5hc3NpZ24gPSB2YWx1ZVswXSA/IHRydWVPcHRpb24gOiBmYWxzZU9wdGlvbjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJYZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuY2xhbXBJbWFnZVwiLCB7XHJcbiAgICBvdXRwdXRzOiBbIHt0eXBlOiAndGV4dHVyZScsIG5hbWUgOiAncmVzdWx0Jywgc2l6ZW9mIDogJ2ltYWdlJywgZm9ybWF0VHlwZTogJ0ltYWdlRGF0YSd9IF0sXHJcbiAgICBwYXJhbXM6ICBbIHt0eXBlOiAndGV4dHVyZScsIHNvdXJjZSA6ICdpbWFnZSd9LFxyXG4gICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0Jywgc291cmNlIDogJ21pbid9LFxyXG4gICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0Jywgc291cmNlIDogJ21heCd9XHJcbiAgICAgICAgICAgICBdLFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgaW1hZ2UsIG1pbiwgbWF4KSB7XHJcbiAgICAgICAgdmFyIGlucGl4ID0gaW1hZ2UuZGF0YTtcclxuICAgICAgICB2YXIgb3V0cGl4ID0gcmVzdWx0LmRhdGE7XHJcbiAgICAgICAgdmFyIG1pbnYgPSBtaW5bMF07XHJcbiAgICAgICAgdmFyIG1heHYgPSBtYXhbMF07XHJcbiAgICAgICAgdmFyIGxlbiA9IGltYWdlLmRhdGEubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSBpbnBpeFtpXTtcclxuICAgICAgICAgICAgaWYgKHZhbCA8IG1pbnYpIHZhbCA9IG1pbnY7XHJcbiAgICAgICAgICAgIGlmICh2YWwgPiBtYXh2KSB2YWwgPSBtYXh2O1xyXG4gICAgICAgICAgICBvdXRwaXhbaV0gPSB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59KTtcclxuIiwiLy8gQ29kZSBwb3J0aW9ucyBmcm9tIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2NhbnZhcy9pbWFnZWZpbHRlcnMvXHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gY29udm9sdXRlKGlucGl4ZWxzLCBvdXRwaXhlbHMsIHdlaWdodHMsIG9wYXF1ZSkge1xyXG4gICAgICAgIHZhciBzaWRlID0gTWF0aC5yb3VuZChNYXRoLnNxcnQod2VpZ2h0cy5sZW5ndGgpKTtcclxuICAgICAgICB2YXIgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUvMik7XHJcbiAgICAgICAgdmFyIHNyYyA9IGlucGl4ZWxzLmRhdGE7XHJcbiAgICAgICAgdmFyIHN3ID0gaW5waXhlbHMud2lkdGg7XHJcbiAgICAgICAgdmFyIHNoID0gaW5waXhlbHMuaGVpZ2h0O1xyXG4gICAgICAgIC8vIHBhZCBvdXRwdXQgYnkgdGhlIGNvbnZvbHV0aW9uIG1hdHJpeFxyXG4gICAgICAgIHZhciB3ID0gc3c7XHJcbiAgICAgICAgdmFyIGggPSBzaDtcclxuICAgICAgICB2YXIgZHN0ID0gb3V0cGl4ZWxzLmRhdGE7XHJcbiAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgZGVzdGluYXRpb24gaW1hZ2UgcGl4ZWxzXHJcbiAgICAgICAgdmFyIGFscGhhRmFjID0gb3BhcXVlID8gMSA6IDA7XHJcbiAgICAgICAgZm9yICh2YXIgeT0wOyB5PGg7IHkrKykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciB4PTA7IHg8dzsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3kgPSB5O1xyXG4gICAgICAgICAgICAgICAgdmFyIHN4ID0geDtcclxuICAgICAgICAgICAgICAgIHZhciBkc3RPZmYgPSAoeSp3K3gpKjQ7XHJcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHdlaWdoZWQgc3VtIG9mIHRoZSBzb3VyY2UgaW1hZ2UgcGl4ZWxzIHRoYXRcclxuICAgICAgICAgICAgICAgIC8vIGZhbGwgdW5kZXIgdGhlIGNvbnZvbHV0aW9uIG1hdHJpeFxyXG4gICAgICAgICAgICAgICAgdmFyIHI9MCwgZz0wLCBiPTAsIGE9MDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGN5PTA7IGN5PHNpZGU7IGN5KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjeD0wOyBjeDxzaWRlOyBjeCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3kgPSBzeSArIGN5IC0gaGFsZlNpZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3ggPSBzeCArIGN4IC0gaGFsZlNpZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY3kgPj0gMCAmJiBzY3kgPCBzaCAmJiBzY3ggPj0gMCAmJiBzY3ggPCBzdykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNyY09mZiA9IChzY3kqc3crc2N4KSo0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHd0ID0gd2VpZ2h0c1tjeSpzaWRlK2N4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgKz0gc3JjW3NyY09mZl0gKiB3dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgKz0gc3JjW3NyY09mZisxXSAqIHd0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYiArPSBzcmNbc3JjT2ZmKzJdICogd3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhICs9IHNyY1tzcmNPZmYrM10gKiB3dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRzdFtkc3RPZmZdID0gcjtcclxuICAgICAgICAgICAgICAgIGRzdFtkc3RPZmYrMV0gPSBnO1xyXG4gICAgICAgICAgICAgICAgZHN0W2RzdE9mZisyXSA9IGI7XHJcbiAgICAgICAgICAgICAgICBkc3RbZHN0T2ZmKzNdID0gYSArIGFscGhhRmFjKigyNTUtYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHBpeGVscztcclxuICAgIH07XHJcblxyXG4gICAgWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmNvbnZvbHV0ZUltYWdlXCIsIHtcclxuICAgICAgICBvdXRwdXRzOiBbIHt0eXBlOiAndGV4dHVyZScsIG5hbWUgOiAncmVzdWx0Jywgc2l6ZW9mIDogJ2ltYWdlJ30gXSxcclxuICAgICAgICBwYXJhbXM6ICBbXHJcbiAgICAgICAgICAgIHt0eXBlOiAndGV4dHVyZScsIHNvdXJjZSA6ICdpbWFnZSd9LFxyXG4gICAgICAgICAgICB7dHlwZTogJ2Zsb2F0Jywgc291cmNlIDogJ2tlcm5lbCd9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCBpbWFnZSwga2VybmVsKSB7XHJcbiAgICAgICAgICAgIGNvbnZvbHV0ZShpbWFnZSwgcmVzdWx0LCBrZXJuZWwsIHRydWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBYZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuY29udm9sdXRlSW1hZ2VUb0Zsb2F0XCIsIHtcclxuICAgICAgICBvdXRwdXRzOiBbIHt0eXBlOiAndGV4dHVyZScsIG5hbWUgOiAncmVzdWx0Jywgc2l6ZW9mOiAnaW1hZ2UnLCBmb3JtYXRUeXBlIDogJ2Zsb2F0MzInfSBdLFxyXG4gICAgICAgIHBhcmFtczogIFtcclxuICAgICAgICAgICAge3R5cGU6ICd0ZXh0dXJlJywgc291cmNlIDogJ2ltYWdlJ30sXHJcbiAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQnLCBzb3VyY2UgOiAna2VybmVsJ31cclxuICAgICAgICBdLFxyXG4gICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGltYWdlLCBrZXJuZWwpIHtcclxuICAgICAgICAgICAgY29udm9sdXRlKGltYWdlLCByZXN1bHQsIGtlcm5lbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxufSkoKTtcclxuIiwiWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmNyZWF0ZUlHSW5kZXhcIiwge1xyXG4gICAgb3V0cHV0czpbXHJcbiAgICAgICAgLy97dHlwZTonaW50JywgbmFtZTonaW5kZXgnLCBjdXN0b21BbGxvYzp0cnVlIH0sXHJcbiAgICAgICAge3R5cGU6J2Zsb2F0MicsIG5hbWU6J3RleGNvb3JkJywgY3VzdG9tQWxsb2M6dHJ1ZSB9XHJcbiAgICBdLFxyXG4gICAgcGFyYW1zOltcclxuICAgICAgICB7dHlwZTonaW50Jywgc291cmNlOid2ZXJ0ZXhDb3VudCcsIG9wdGlvbmFsOmZhbHNlfSxcclxuICAgICAgICB7dHlwZTondGV4dHVyZScsIHNvdXJjZToncG9zaXRpb25UZXgnLCBvcHRpb25hbDogZmFsc2V9XHJcbiAgICBdLFxyXG4gICAgYWxsb2M6ZnVuY3Rpb24gKHNpemVzLCB2ZXJ0ZXhDb3VudCwgaW1hZ2UpIHtcclxuICAgICAgICBzaXplc1sndGV4Y29vcmQnXSA9IGltYWdlLndpZHRoICogaW1hZ2UuaGVpZ2h0O1xyXG4gICAgICAgIC8vc2l6ZXNbJ2luZGV4J10gPSB2ZXJ0ZXhDb3VudFswXTtcclxuICAgIH0sXHJcbiAgICBldmFsdWF0ZTpmdW5jdGlvbiAodGV4Y29vcmQsIHZlcnRleENvdW50LCBpbWFnZSwgaW5mbykge1xyXG4gICAgICAgIC8vIHRleCBjb29yZHNcclxuICAgICAgICB2YXIgaGFsZlBpeGVsID0ge1xyXG4gICAgICAgICAgICB4OiAwLjUgLyBpbWFnZS53aWR0aCxcclxuICAgICAgICAgICAgeTogMC41IC8gaW1hZ2UuaGVpZ2h0XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgeSA9IDAsIHlsZW5ndGggPSBpbWFnZS5oZWlnaHQ7IHkgPCB5bGVuZ3RoOyB5KyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMCwgeGxlbmd0aCA9IGltYWdlLndpZHRoOyB4IDwgeGxlbmd0aDsgeCsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0ZXhjb29yZFtpKytdID0gKHggLyB4bGVuZ3RoKSArIGhhbGZQaXhlbC54O1xyXG4gICAgICAgICAgICAgICAgdGV4Y29vcmRbaSsrXSA9IDEgLSAoKHkgLyB5bGVuZ3RoKSArIGhhbGZQaXhlbC55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaW5kZXggY3JlYXRpb25cclxuICAgICAgICAvKmZvcih2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudFswXTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGluZGV4W2ldID0gaTtcclxuICAgICAgICB9Ki9cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufSk7XHJcbiIsIihmdW5jdGlvbigpIHtcclxuICAgIHZhciBUTVBfTUFUUklYID0gWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpO1xyXG4gICAgdmFyIFRNUF9WRUMgPSBYTUwzRC5tYXRoLnZlYzMuY3JlYXRlKCk7XHJcbiAgICB2YXIgVE1QX1FVQVQgPSBYTUwzRC5tYXRoLnF1YXQuY3JlYXRlKCk7XHJcbiAgICB2YXIgbWF0NCA9IFhNTDNELm1hdGgubWF0NDtcclxuXHJcbiAgICBYZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuY3JlYXRlVHJhbnNmb3JtXCIsIHtcclxuICAgICAgICBvdXRwdXRzOiBbe3R5cGU6ICdmbG9hdDR4NCcsIG5hbWU6ICdyZXN1bHQnfV0sXHJcbiAgICAgICAgcGFyYW1zOiBbe3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICd0cmFuc2xhdGlvbicsIG9wdGlvbmFsOiB0cnVlfSxcclxuICAgICAgICAgICAge3R5cGU6ICdmbG9hdDQnLCBzb3VyY2U6ICdyb3RhdGlvbicsIG9wdGlvbmFsOiB0cnVlfSxcclxuICAgICAgICAgICAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICdzY2FsZScsIG9wdGlvbmFsOiB0cnVlfSxcclxuICAgICAgICAgICAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICdjZW50ZXInLCBvcHRpb25hbDogdHJ1ZX0sXHJcbiAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQ0Jywgc291cmNlOiAnc2NhbGVPcmllbnRhdGlvbicsIG9wdGlvbmFsOiB0cnVlfV0sXHJcbiAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uIChyZXN1bHQsIHRyYW5zbGF0aW9uLCByb3RhdGlvbiwgc2NhbGUsIGNlbnRlciwgc2NhbGVPcmllbnRhdGlvbiwgaW5mbykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZm8uaXRlcmF0ZUNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZXN0ID0gcmVzdWx0LnN1YmFycmF5KGkgKiAxNik7XHJcbiAgICAgICAgICAgICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb24gJiYgbWF0NC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgaW5mby5pdGVyRmxhZ1swXSA/IHRyYW5zbGF0aW9uLnN1YmFycmF5KGkqMykgOiB0cmFuc2xhdGlvbik7XHJcbiAgICAgICAgICAgICAgICBjZW50ZXIgJiYgbWF0NC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgaW5mby5pdGVyRmxhZ1swXSA/IGNlbnRlci5zdWJhcnJheShpKjMpIDogY2VudGVyKTtcclxuICAgICAgICAgICAgICAgIGlmIChyb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24oVE1QX01BVFJJWCwgaW5mby5pdGVyRmxhZ1sxXSA/IHJvdGF0aW9uLnN1YmFycmF5KGkqNCkgOiByb3RhdGlvbiwgWzAsIDAsIDBdKTtcclxuICAgICAgICAgICAgICAgICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIGRlc3QsIFRNUF9NQVRSSVgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNjYWxlT3JpZW50YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKFRNUF9NQVRSSVgsIGluZm8uaXRlckZsYWdbNF0gPyBzY2FsZU9yaWVudGF0aW9uLnN1YmFycmF5KGkqNCkgOiBzY2FsZU9yaWVudGF0aW9uLCBbMCwgMCwgMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgZGVzdCwgVE1QX01BVFJJWCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzY2FsZSAmJiBtYXQ0LnNjYWxlKGRlc3QsIGRlc3QsIGluZm8uaXRlckZsYWdbMl0gPyBzY2FsZS5zdWJhcnJheShpKjMpIDogc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjYWxlT3JpZW50YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5tYXRoLnF1YXQuY29weShUTVBfUVVBVCwgaW5mby5pdGVyRmxhZ1s0XSA/IHNjYWxlT3JpZW50YXRpb24uc3ViYXJyYXkoaSo0KSA6IHNjYWxlT3JpZW50YXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvbihUTVBfTUFUUklYLCBYTUwzRC5tYXRoLnF1YXQubmVnYXRlKFRNUF9RVUFULCBUTVBfUVVBVCksIFswLCAwLCAwXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBkZXN0LCBUTVBfTUFUUklYKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjZW50ZXIgJiYgbWF0NC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgWE1MM0QubWF0aC52ZWMzLm5lZ2F0ZShUTVBfVkVDLCBpbmZvLml0ZXJGbGFnWzNdID8gY2VudGVyLnN1YmFycmF5KGkqMykgOiBjZW50ZXIpKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG59KSgpOyIsIihmdW5jdGlvbigpIHtcclxuICAgIHZhciBUTVBfTUFUUklYID0gWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpO1xyXG4gICAgdmFyIFRNUF9WRUMgPSBYTUwzRC5tYXRoLnZlYzMuY3JlYXRlKCk7XHJcbiAgICB2YXIgVE1QX1FVQVQgPSBYTUwzRC5tYXRoLnF1YXQuY3JlYXRlKCk7XHJcbiAgICB2YXIgbWF0NCA9IFhNTDNELm1hdGgubWF0NDtcclxuXHJcbiAgICBYZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuY3JlYXRlVHJhbnNmb3JtSW52XCIsIHtcclxuICAgICAgICBvdXRwdXRzOiBbe3R5cGU6ICdmbG9hdDR4NCcsIG5hbWU6ICdyZXN1bHQnfV0sXHJcbiAgICAgICAgcGFyYW1zOiBbe3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICd0cmFuc2xhdGlvbicsIG9wdGlvbmFsOiB0cnVlfSxcclxuICAgICAgICAgICAge3R5cGU6ICdmbG9hdDQnLCBzb3VyY2U6ICdyb3RhdGlvbicsIG9wdGlvbmFsOiB0cnVlfSxcclxuICAgICAgICAgICAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICdzY2FsZScsIG9wdGlvbmFsOiB0cnVlfSxcclxuICAgICAgICAgICAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICdjZW50ZXInLCBvcHRpb25hbDogdHJ1ZX0sXHJcbiAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQ0Jywgc291cmNlOiAnc2NhbGVPcmllbnRhdGlvbicsIG9wdGlvbmFsOiB0cnVlfV0sXHJcbiAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uIChyZXN1bHQsIHRyYW5zbGF0aW9uLCByb3RhdGlvbiwgc2NhbGUsIGNlbnRlciwgc2NhbGVPcmllbnRhdGlvbiwgaW5mbykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZm8uaXRlcmF0ZUNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZXN0ID0gcmVzdWx0LnN1YmFycmF5KGkgKiAxNik7XHJcbiAgICAgICAgICAgICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gICAgICAgICAgICAgICAgY2VudGVyICYmIG1hdDQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIGluZm8uaXRlckZsYWdbM10gPyBjZW50ZXIuc3ViYXJyYXkoaSozKSA6IGNlbnRlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNjYWxlT3JpZW50YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKFRNUF9NQVRSSVgsIGluZm8uaXRlckZsYWdbNF0gPyBzY2FsZU9yaWVudGF0aW9uLnN1YmFycmF5KGkqNCkgOiBzY2FsZU9yaWVudGF0aW9uLCBbMCwgMCwgMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgZGVzdCwgVE1QX01BVFJJWCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzY2FsZSAmJiBtYXQ0LnNjYWxlKGRlc3QsIGRlc3QsIFhNTDNELm1hdGgudmVjMy5yZWNpcHJvY2FsKFRNUF9WRUMsIGluZm8uaXRlckZsYWdbMl0gPyBzY2FsZS5zdWJhcnJheShpKjMpIDogc2NhbGUpKTtcclxuICAgICAgICAgICAgICAgIGlmIChzY2FsZU9yaWVudGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QubWF0aC5xdWF0LmNvcHkoVE1QX1FVQVQsIGluZm8uaXRlckZsYWdbNF0gPyBzY2FsZU9yaWVudGF0aW9uLnN1YmFycmF5KGkqNCkgOiBzY2FsZU9yaWVudGF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBtYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKFRNUF9NQVRSSVgsIFhNTDNELm1hdGgucXVhdC5pbnZlcnQoVE1QX1FVQVQsIFRNUF9RVUFUKSwgWzAsIDAsIDBdKTtcclxuICAgICAgICAgICAgICAgICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIGRlc3QsIFRNUF9NQVRSSVgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QubWF0aC5xdWF0LmNvcHkoVE1QX1FVQVQsIGluZm8uaXRlckZsYWdbMV0gPyByb3RhdGlvbi5zdWJhcnJheShpKjQpIDogcm90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24oVE1QX01BVFJJWCwgWE1MM0QubWF0aC5xdWF0LmludmVydChUTVBfUVVBVCwgVE1QX1FVQVQpLCBbMCwgMCwgMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgZGVzdCwgVE1QX01BVFJJWCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjZW50ZXIgJiYgbWF0NC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgWE1MM0QubWF0aC52ZWMzLm5lZ2F0ZShUTVBfVkVDLCBpbmZvLml0ZXJGbGFnWzNdID8gY2VudGVyLnN1YmFycmF5KGkqMykgOiBjZW50ZXIpKTtcclxuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uICYmIG1hdDQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIFhNTDNELm1hdGgudmVjMy5uZWdhdGUoVE1QX1ZFQywgaW5mby5pdGVyRmxhZ1swXSA/IHRyYW5zbGF0aW9uLnN1YmFycmF5KGkqMykgOiB0cmFuc2xhdGlvbikpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59KSgpO1xyXG4iLCIoZnVuY3Rpb24oKXtcclxuXHJcbnZhciBjX0N1YmVQb3NpdGlvbnMgPSAgW1xyXG4gICAgWy0xLC0xLC0xXSwgWzEsLTEsLTFdLCBbLTEsMSwtMV0sIFsxLDEsLTFdLCAvLyBmcm9udFxyXG4gICAgWy0xLC0xLC0xXSwgWy0xLC0xLDFdLCBbLTEsMSwtMV0sIFstMSwxLDFdLCAvLyBsZWZ0XHJcbiAgICBbLTEsLTEsLTFdLCBbMSwtMSwtMV0sIFstMSwtMSwxXSwgWzEsLTEsMV0sIC8vIHRvcFxyXG4gICAgWzEsLTEsLTFdLCBbMSwxLC0xXSwgWzEsLTEsMV0sIFsxLDEsMV0sICAgICAvLyByaWdodFxyXG4gICAgWy0xLDEsLTFdLCBbMSwxLC0xXSwgWy0xLDEsMV0sIFsxLDEsMV0sICAgICAvLyBib3R0b21cclxuICAgIFstMSwtMSwxXSwgWzEsLTEsMV0sIFstMSwxLDFdLCBbMSwxLDFdICAgICAgLy8gYmFja1xyXG5dO1xyXG52YXIgY19DdWJlTm9ybWFscyA9ICBbXHJcbiAgICBbMCwwLC0xXSwgWzAsMCwtMV0sIFswLDAsLTFdLCBbMCwwLC0xXSwgLy8gZnJvbnRcclxuICAgIFstMSwwLDBdLCBbLTEsMCwwXSwgWy0xLDAsMF0sIFstMSwwLDBdLCAvLyBsZWZ0XHJcbiAgICBbMCwtMSwwXSwgWzAsLTEsMF0sIFswLC0xLDBdLCBbMCwtMSwwXSwgLy8gdG9wXHJcbiAgICBbMSwwLDBdLCBbMSwwLDBdLCBbMSwwLDBdLCBbMSwwLDBdLCAgICAgLy8gcmlnaHRcclxuICAgIFswLDEsMF0sIFswLDEsMF0sIFswLDEsMF0sIFswLDEsMF0sICAgICAvLyBib3R0b21cclxuICAgIFswLDAsMV0sIFswLDAsMV0sIFswLDAsMV0sIFswLDAsMV0gICAgICAvLyBiYWNrXHJcbl07XHJcbnZhciBjX0N1YmVJbmRleCA9IFtcclxuICAgIFswLDEsMiwxLDIsM10sXHJcbiAgICBbNCw1LDYsNSw2LDddLFxyXG4gICAgWzgsOSwxMCw5LDEwLDExXSxcclxuICAgIFsxMiwxMywxNCwxMywxNCwxNV0sXHJcbiAgICBbMTYsMTcsMTgsMTcsMTgsMTldLFxyXG4gICAgWzIwLDIxLDIyLDIxLDIyLDIzXVxyXG5dXHJcblxyXG4vKipcclxuICogR3JpZCBHZW5lcmF0aW9uXHJcbiAqL1xyXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuZGVidWcuY3JlYXRlU2tpbkN1YmVzXCIsIHtcclxuICAgIG91dHB1dHM6IFtcdHt0eXBlOiAnaW50JywgbmFtZTogJ2luZGV4JywgY3VzdG9tQWxsb2M6IHRydWV9LFxyXG4gICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdDMnLCBuYW1lOiAncG9zaXRpb24nLCBjdXN0b21BbGxvYzogdHJ1ZX0sXHJcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0MycsIG5hbWU6ICdub3JtYWwnLCBjdXN0b21BbGxvYzogdHJ1ZX0sXHJcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2ludDQnLCBuYW1lOiAnYm9uZUluZGljZXMnLCBjdXN0b21BbGxvYzogdHJ1ZX0sXHJcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0NCcsIG5hbWU6ICdib25lV2VpZ2h0cycsIGN1c3RvbUFsbG9jOiB0cnVlfV0sXHJcbiAgICBwYXJhbXM6ICBbe3R5cGU6ICdmbG9hdDR4NCcsIHNvdXJjZTogJ2JpbmRUcmFuc2Zvcm1zJywgYXJyYXk6IHRydWV9LFxyXG4gICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQnLCBzb3VyY2U6ICdzaXplJywgYXJyYXk6IHRydWUsIG9wdGlvbmFsOiB0cnVlfV0sXHJcbiAgICBhbGxvYzogZnVuY3Rpb24oc2l6ZXMsIGJpbmRUcmFuc2Zvcm1zKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBzID0gYmluZFRyYW5zZm9ybXMubGVuZ3RoIC8gMTY7XHJcbiAgICAgICAgc2l6ZXNbJ3Bvc2l0aW9uJ10gPSBzICogNCAqIDY7XHJcbiAgICAgICAgc2l6ZXNbJ25vcm1hbCddID0gcyAqIDQgKiA2O1xyXG4gICAgICAgIHNpemVzWydib25lSW5kaWNlcyddID0gcyAqIDQgKiA2O1xyXG4gICAgICAgIHNpemVzWydib25lV2VpZ2h0cyddID0gcyAqIDQgKiA2O1xyXG4gICAgICAgIHNpemVzWydpbmRleCddID0gcyAqIDYgKiA2O1xyXG4gICAgfSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihpbmRleCwgcG9zaXRpb24sIG5vcm1hbCwgYm9uZUlkeCwgYm9uZVdlaWdodCwgYmluZFRyYW5zZm9ybXMsIHNpemUpIHtcclxuICAgICAgICB2YXIgY3ViZUNvdW50ID0gYmluZFRyYW5zZm9ybXMubGVuZ3RoIC8gMTY7XHJcbiAgICAgICAgdmFyIHNpemUgPSAoc2l6ZSAmJiBzaXplWzBdIHx8IDEpIC8gMjtcclxuXHJcbiAgICAgICAgdmFyIHRtcFBvc2l0aW9uID0gWE1MM0QubWF0aC52ZWMzLmNyZWF0ZSgpLFxyXG4gICAgICAgICAgICB0bXBOb3JtYWwgPSBYTUwzRC5tYXRoLnZlYzMuY3JlYXRlKCk7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjdWJlQ291bnQ7ICsraSl7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCA2OyArK2ope1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IDQ7IGsrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2FsSWR4ID0gaio0KyBrLCBnbG9iYWxJZHggPSBpKjYqNCArIGxvY2FsSWR4O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5tYXRoLnZlYzMuY29weSh0bXBQb3NpdGlvbiwgY19DdWJlUG9zaXRpb25zW2xvY2FsSWR4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QubWF0aC52ZWMzLnNjYWxlKHRtcFBvc2l0aW9uLCB0bXBQb3NpdGlvbiwgc2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0Lm11bHRpcGx5T2Zmc2V0VmVjMyhiaW5kVHJhbnNmb3JtcywgaSoxNiwgdG1wUG9zaXRpb24sIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIFhNTDNELm1hdGgudmVjMy5jb3B5KHRtcE5vcm1hbCwgY19DdWJlTm9ybWFsc1tsb2NhbElkeF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIFhNTDNELm1hdGgubWF0NC5tdWx0aXBseU9mZnNldERpcmVjdGlvbihiaW5kVHJhbnNmb3JtcywgaSoxNiwgdG1wTm9ybWFsLCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25bZ2xvYmFsSWR4KjMrMF0gPSB0bXBQb3NpdGlvblswXTtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbltnbG9iYWxJZHgqMysxXSA9IHRtcFBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uW2dsb2JhbElkeCozKzJdID0gdG1wUG9zaXRpb25bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsW2dsb2JhbElkeCozKzBdID0gdG1wTm9ybWFsWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbFtnbG9iYWxJZHgqMysxXSA9IHRtcE5vcm1hbFsxXTtcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxbZ2xvYmFsSWR4KjMrMl0gPSB0bXBOb3JtYWxbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgYm9uZUlkeFtnbG9iYWxJZHgqNCswXSA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9uZUlkeFtnbG9iYWxJZHgqNCsxXSA9IGJvbmVJZHhbZ2xvYmFsSWR4KjQrMl0gPSBib25lSWR4W2dsb2JhbElkeCo0KzNdPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvbmVXZWlnaHRbZ2xvYmFsSWR4KjQrMF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvbmVXZWlnaHRbZ2xvYmFsSWR4KjQrMV0gPSBib25lV2VpZ2h0W2dsb2JhbElkeCo0KzJdID0gYm9uZVdlaWdodFtnbG9iYWxJZHgqNCszXT0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBnbG9iYWxJbmRleElkeCA9IGkqNio2ICsgaio2O1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IDY7ICsrayl7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhbZ2xvYmFsSW5kZXhJZHgra10gPSBpKjYqNCArIGNfQ3ViZUluZGV4W2pdW2tdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlIGFyZSBkb25lIVxyXG4gICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICB9XHJcbn0pO1xyXG5cclxufSgpKTtcclxuIiwiWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmRpdlwiLCB7XHJcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0JywgbmFtZTogJ3Jlc3VsdCd9XSxcclxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnZmxvYXQnLCBzb3VyY2U6ICd2YWx1ZTEnfSxcclxuICAgICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQnLCBzb3VyY2U6ICd2YWx1ZTInfV0sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZTEsIHZhbHVlMiwgaW5mbykge1xyXG4gICAgICAgIHJlc3VsdFswXSA9IHZhbHVlMVswXSAvIHZhbHVlMlswXTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG4iLCJYZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuZmxpcE5vcm1hbFwiLCB7XHJcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0MycsIG5hbWU6ICdyZXN1bHQnfV0sXHJcbiAgICBwYXJhbXM6ICBbICB7dHlwZTogJ2Zsb2F0MycsIHNvdXJjZTogJ3ZhbHVlJ31dLFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGluZm8pIHtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpPGluZm8uaXRlcmF0ZUNvdW50KjM7IGkrKylcclxuICAgICAgICAgICAgcmVzdWx0W2ldID0gLXZhbHVlW2ldO1xyXG4gICAgfVxyXG59KTtcclxuIiwiWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmZsaXBWZXJ0aWNhbEltYWdlXCIsIHtcclxuICAgIG91dHB1dHM6IFsge3R5cGU6ICd0ZXh0dXJlJywgbmFtZSA6ICdyZXN1bHQnLCBzaXplb2YgOiAnaW1hZ2UnfSBdLFxyXG4gICAgcGFyYW1zOiAgWyB7dHlwZTogJ3RleHR1cmUnLCBzb3VyY2UgOiAnaW1hZ2UnfSBdLFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgaW1hZ2UpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSBpbWFnZS53aWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xyXG5cclxuICAgICAgICB2YXIgZGVzdHBpeCA9IHJlc3VsdC5kYXRhO1xyXG4gICAgICAgIHZhciBzcmNwaXggPSBpbWFnZS5kYXRhO1xyXG5cclxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7ICsreCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvd09mZnNldCA9IHkgKiB3aWR0aDtcclxuICAgICAgICAgICAgICAgIHZhciBzcmNPZmZzZXQgPSAocm93T2Zmc2V0ICsgeCkgKiA0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGRzdE9mZnNldCA9IChyb3dPZmZzZXQgKyAoKHdpZHRoLTEpIC0geCkpICogNDtcclxuICAgICAgICAgICAgICAgIGRlc3RwaXhbZHN0T2Zmc2V0XSA9ICBzcmNwaXhbc3JjT2Zmc2V0XTtcclxuICAgICAgICAgICAgICAgIGRlc3RwaXhbZHN0T2Zmc2V0KzFdID0gc3JjcGl4W3NyY09mZnNldCsxXTtcclxuICAgICAgICAgICAgICAgIGRlc3RwaXhbZHN0T2Zmc2V0KzJdID0gc3JjcGl4W3NyY09mZnNldCsyXTtcclxuICAgICAgICAgICAgICAgIGRlc3RwaXhbZHN0T2Zmc2V0KzNdID0gc3JjcGl4W3NyY09mZnNldCszXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufSk7XHJcbiIsIlhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5mb3J3YXJkS2luZW1hdGljc1wiLCB7XHJcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0NHg0JywgIG5hbWU6ICdyZXN1bHQnLCBjdXN0b21BbGxvYzogdHJ1ZX1dLFxyXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdpbnQnLCAgICAgICBzb3VyY2U6ICdwYXJlbnQnLCBhcnJheTogdHJ1ZSB9LFxyXG4gICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdDR4NCcsICBzb3VyY2U6ICd4Zm9ybScsIGFycmF5OiB0cnVlIH1dLFxyXG4gICAgYWxsb2M6IGZ1bmN0aW9uKHNpemVzLCBwYXJlbnQsIHhmb3JtKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihwYXJlbnQubGVuZ3RoLCB4Zm9ybS5sZW5ndGggLyAxNik7XHJcbiAgICAgICAgc2l6ZXNbJ3Jlc3VsdCddID0gbGVuZ3RoO1xyXG4gICAgfSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIHBhcmVudCx4Zm9ybSwgaW5mbykge1xyXG5cclxuICAgICAgICB2YXIgYm9uZUNvdW50ID0gcmVzdWx0Lmxlbmd0aCAvIDE2O1xyXG5cclxuICAgICAgICB2YXIgY29tcHV0ZWQgPSBbXTtcclxuICAgICAgICAvL0ZvciBlYWNoIGJvbmUgZG86XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGJvbmVDb3VudDspe1xyXG4gICAgICAgICAgICBpZighY29tcHV0ZWRbaV0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gcGFyZW50W2ldO1xyXG4gICAgICAgICAgICAgICAgaWYocCA+PSAwKXtcclxuICAgICAgICAgICAgICAgICAgICAvL1RoaXMgYm9uZSBoYXMgYSBwYXJlbnQgYm9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFjb21wdXRlZFtwXSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVGhlIHBhcmVudCBib25lJ3MgdHJhbnNmb3JtYXRpb24gbWF0cml4IGhhc24ndCBiZWVuIGNvbXB1dGVkIHlldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZShwYXJlbnRbcF0gPj0gMCAmJiAhY29tcHV0ZWRbcGFyZW50W3BdXSkgcCA9IHBhcmVudFtwXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHBhcmVudFtwXSA+PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0Lm11bHRpcGx5T2Zmc2V0KHJlc3VsdCwgcCoxNiwgeGZvcm0sIHAqMTYsIHJlc3VsdCwgcGFyZW50W3BdKjE2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IDE2OyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcCoxNitqXSA9IHhmb3JtW3AqMTYral07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkW3BdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBYTUwzRC5tYXRoLm1hdDQubXVsdGlwbHlPZmZzZXQocmVzdWx0LCBpKjE2LCB4Zm9ybSwgaSoxNiwgcmVzdWx0LCAgcCoxNik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgMTY7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaSoxNitqXSA9IHhmb3JtW2kqMTYral07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29tcHV0ZWRbaV0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJYZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuZm9yd2FyZEtpbmVtYXRpY3NJbnZcIiwge1xyXG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdDR4NCcsICBuYW1lOiAncmVzdWx0JywgY3VzdG9tQWxsb2M6IHRydWV9XSxcclxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnaW50JywgICAgICAgc291cmNlOiAncGFyZW50JywgYXJyYXk6IHRydWUgfSxcclxuICAgICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQ0eDQnLCAgc291cmNlOiAneGZvcm0nLCBhcnJheTogdHJ1ZSB9XSxcclxuICAgIGFsbG9jOiBmdW5jdGlvbihzaXplcywgcGFyZW50LCB4Zm9ybSlcclxuICAgIHtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4ocGFyZW50Lmxlbmd0aCwgeGZvcm0ubGVuZ3RoIC8gMTYpO1xyXG4gICAgICAgIHNpemVzWydyZXN1bHQnXSA9IGxlbmd0aDtcclxuICAgIH0sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCBwYXJlbnQseGZvcm0sIGluZm8pIHtcclxuICAgICAgICB2YXIgYm9uZUNvdW50ID0geGZvcm0ubGVuZ3RoIC8gMTY7XHJcblxyXG4gICAgICAgIHZhciBjb21wdXRlZCA9IFtdO1xyXG4gICAgICAgIC8vRm9yIGVhY2ggYm9uZSBkbzpcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYm9uZUNvdW50Oyl7XHJcbiAgICAgICAgICAgIGlmKCFjb21wdXRlZFtpXSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwYXJlbnRbaV07XHJcbiAgICAgICAgICAgICAgICBpZihwID49IDApe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVGhpcyBib25lIGhhcyBhIHBhcmVudCBib25lXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIWNvbXB1dGVkW3BdKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UaGUgcGFyZW50IGJvbmUncyB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggaGFzbid0IGJlZW4gY29tcHV0ZWQgeWV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKHBhcmVudFtwXSA+PSAwICYmICFjb21wdXRlZFtwYXJlbnRbcF1dKSBwID0gcGFyZW50W3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RoZSBjdXJyZW50IGJvbmUgaGFzIGEgcGFyZW50IGFuZCBpdHMgdHJhbnNmb3JtIGhhc24ndCBiZWVuIGNvbXB1dGVkIHlldFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocGFyZW50W3BdID49IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBYTUwzRC5tYXRoLm1hdDQubXVsdGlwbHlPZmZzZXQocmVzdWx0LCBwKjE2LCByZXN1bHQsIHBhcmVudFtwXSoxNiwgeGZvcm0sIHAqMTYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgMTY7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtwKjE2K2pdID0geGZvcm1bcCoxNitqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWRbcF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBYTUwzRC5tYXRoLm1hdDQubXVsdGlwbHlPZmZzZXQocmVzdWx0LCBpKjE2LCAgcmVzdWx0LCAgcCoxNiwgeGZvcm0sIGkqMTYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IDE2OyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2kqMTYral0gPSB4Zm9ybVtpKjE2K2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbXB1dGVkW2ldID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuIiwiLy8gQmFzZWQgb246IGh0dHA6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzEwMDYzOTI1L2h0dHA6Ly9kZW0ub2NyYWN5Lm9yZy9saWJlcm8vcGhvdG9ib290aC9cclxuXHJcblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5mdW5NaXJyb3JJbWFnZVwiLCB7XHJcbiAgICBvdXRwdXRzOiBbIHt0eXBlOiAndGV4dHVyZScsIG5hbWUgOiAncmVzdWx0Jywgc2l6ZW9mIDogJ2ltYWdlJ30gXSxcclxuICAgIHBhcmFtczogIFsge3R5cGU6ICd0ZXh0dXJlJywgc291cmNlIDogJ2ltYWdlJ30sXHJcbiAgICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQnLCBzb3VyY2UgOiAndGltZSd9IF0sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCBpbWFnZSwgdGltZSkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHJlc3VsdC53aWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gcmVzdWx0LmhlaWdodDtcclxuICAgICAgICB2YXIgdGltZSA9IHRpbWVbMF07XHJcblxyXG4gICAgICAgIHZhciBzID0gaW1hZ2UuZGF0YTtcclxuICAgICAgICB2YXIgZCA9IHJlc3VsdC5kYXRhO1xyXG5cclxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7ICsreCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8qb3JpZ2luYWwgY29vcmRpbmF0ZXMqL1xyXG4gICAgICAgICAgICAgICAgLy8gWzAuMCAsMS4wXSB4IFswLjAsIDEuMF1cclxuICAgICAgICAgICAgICAgIHZhciBjb29yZFggPSB4IC8gd2lkdGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29vcmRZID0geSAvIGhlaWdodDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBbLTEuMCAsMS4wXSB4IFstMS4wLCAxLjBdXHJcbiAgICAgICAgICAgICAgICB2YXIgbm9ybUNvb3JkWCA9IDIuMCAqIGNvb3JkWCAtIDEuMDtcclxuICAgICAgICAgICAgICAgIHZhciBub3JtQ29vcmRZID0gMi4wICogY29vcmRZIC0gMS4wO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qZ28gdG8gcG9sYXIgY29vcmRpbmF0ZXMqL1xyXG4gICAgICAgICAgICAgICAgdmFyIHIgPSBNYXRoLnNxcnQobm9ybUNvb3JkWCpub3JtQ29vcmRYICsgbm9ybUNvb3JkWSpub3JtQ29vcmRZKTsgLy8gbGVuZ3RoKG5vcm1Db29yZClcclxuICAgICAgICAgICAgICAgIHZhciBwaGkgPSBNYXRoLmF0YW4yKG5vcm1Db29yZFksIG5vcm1Db29yZFgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qc3F1ZWV6ZSBhbmQgdmFyeSBpdCBvdmVyIHRpbWUqL1xyXG4gICAgICAgICAgICAgICAgciA9IE1hdGgucG93KHIsIDEuMC8xLjgpICogdGltZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKmJhY2sgdG8gY2FydGVzaWFuIGNvb3JkaW5hdGVzKi9cclxuICAgICAgICAgICAgICAgIG5vcm1Db29yZFggPSByICogTWF0aC5jb3MocGhpKTtcclxuICAgICAgICAgICAgICAgIG5vcm1Db29yZFkgPSByICogTWF0aC5zaW4ocGhpKTtcclxuICAgICAgICAgICAgICAgIC8vIFswLjAgLDEuMF0geCBbMC4wLCAxLjBdXHJcbiAgICAgICAgICAgICAgICBjb29yZFggPSBub3JtQ29vcmRYIC8gMi4wICsgMC41O1xyXG4gICAgICAgICAgICAgICAgY29vcmRZID0gbm9ybUNvb3JkWSAvIDIuMCArIDAuNTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc1ggPSBNYXRoLnJvdW5kKGNvb3JkWCAqIHdpZHRoKTtcclxuICAgICAgICAgICAgICAgIHZhciBzWSA9IE1hdGgucm91bmQoY29vcmRZICogaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IChzWSAqIHdpZHRoICsgc1gpKjQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgciA9IHNbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgZyA9IHNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGIgPSBzW2kgKyAyXTtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gc1tpICsgM107XHJcblxyXG4gICAgICAgICAgICAgICAgLypjb2xvciB0aGUgZnJhZ21lbnQgd2l0aCBjYWxjdWxhdGVkIHRleHR1cmUqL1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAoeSAqIHdpZHRoICsgeCkqNDtcclxuICAgICAgICAgICAgICAgIGRbaV0gPSByO1xyXG4gICAgICAgICAgICAgICAgZFtpICsgMV0gPSBnO1xyXG4gICAgICAgICAgICAgICAgZFtpICsgMl0gPSBiO1xyXG4gICAgICAgICAgICAgICAgZFtpICsgM10gPSBhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59KTtcclxuIiwiXHJcbmZ1bmN0aW9uIGZldGNoKHJlc3VsdCwgdmFsdWUsIGluZGV4LCBjb21wb25lbnRzKXtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpbmRleC5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhciBvZmZzZXQgPSBpbmRleFtpXSAqIGNvbXBvbmVudHM7XHJcbiAgICAgICAgdmFyIGogPSBjb21wb25lbnRzO1xyXG4gICAgICAgIHdoaWxlKGotLSkge1xyXG4gICAgICAgICAgICByZXN1bHRbaSpjb21wb25lbnRzICsgal0gPSB2YWx1ZVtvZmZzZXQgKyBqXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5nZXRcIiwge1xyXG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdCcsIG5hbWU6ICdyZXN1bHQnfV0sXHJcbiAgICBwYXJhbXM6ICBbICB7dHlwZTogJ2Zsb2F0Jywgc291cmNlOiAndmFsdWUnLCBhcnJheTogdHJ1ZX0sXHJcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2ludCcsIHNvdXJjZTogJ2luZGV4J31dLFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGluZGV4LCBpbmZvKSB7XHJcbiAgICAgICAgZmV0Y2gocmVzdWx0LCB2YWx1ZSwgaW5kZXgsIDEpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5nZXRcIiwge1xyXG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdDInLCBuYW1lOiAncmVzdWx0J31dLFxyXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdmbG9hdDInLCBzb3VyY2U6ICd2YWx1ZScsIGFycmF5OiB0cnVlfSxcclxuICAgICAgICAgICAgICAgIHt0eXBlOiAnaW50Jywgc291cmNlOiAnaW5kZXgnfV0sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwgaW5kZXgsIGluZm8pIHtcclxuICAgICAgICBmZXRjaChyZXN1bHQsIHZhbHVlLCBpbmRleCwgMik7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmdldFwiLCB7XHJcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0MycsIG5hbWU6ICdyZXN1bHQnfV0sXHJcbiAgICBwYXJhbXM6ICBbICB7dHlwZTogJ2Zsb2F0MycsIHNvdXJjZTogJ3ZhbHVlJywgYXJyYXk6IHRydWV9LFxyXG4gICAgICAgICAgICAgICAge3R5cGU6ICdpbnQnLCBzb3VyY2U6ICdpbmRleCd9XSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBpbmRleCwgaW5mbykge1xyXG4gICAgICAgIGZldGNoKHJlc3VsdCwgdmFsdWUsIGluZGV4LCA0KTtcclxuICAgIH1cclxufSk7XHJcblxyXG5cclxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmdldFwiLCB7XHJcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0NCcsIG5hbWU6ICdyZXN1bHQnfV0sXHJcbiAgICBwYXJhbXM6ICBbICB7dHlwZTogJ2Zsb2F0NCcsIHNvdXJjZTogJ3ZhbHVlJywgYXJyYXk6IHRydWV9LFxyXG4gICAgICAgICAgICAgICAge3R5cGU6ICdpbnQnLCBzb3VyY2U6ICdpbmRleCd9XSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBpbmRleCwgaW5mbykge1xyXG4gICAgICAgIGZldGNoKHJlc3VsdCwgdmFsdWUsIGluZGV4LCA0KTtcclxuICAgIH1cclxufSk7XHJcblxyXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuZ2V0XCIsIHtcclxuICAgIG91dHB1dHM6IFsgIHt0eXBlOiAnZmxvYXQ0eDQnLCBuYW1lOiAncmVzdWx0J31dLFxyXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdmbG9hdDR4NCcsIHNvdXJjZTogJ3ZhbHVlJywgYXJyYXk6IHRydWV9LFxyXG4gICAgICAgICAgICAgICAge3R5cGU6ICdpbnQnLCBzb3VyY2U6ICdpbmRleCd9XSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBpbmRleCwgaW5mbykge1xyXG4gICAgICAgIGZldGNoKHJlc3VsdCwgdmFsdWUsIGluZGV4LCAxNik7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuXHJcblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5nZXRcIiwge1xyXG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdpbnQnLCBuYW1lOiAncmVzdWx0J31dLFxyXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdpbnQnLCBzb3VyY2U6ICd2YWx1ZScsIGFycmF5OiB0cnVlfSxcclxuICAgICAgICAgICAgICAgIHt0eXBlOiAnaW50Jywgc291cmNlOiAnaW5kZXgnfV0sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwgaW5kZXgsIGluZm8pIHtcclxuICAgICAgICBmZXRjaChyZXN1bHQsIHZhbHVlLCBpbmRleCwgMSk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmdldFwiLCB7XHJcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Jvb2wnLCBuYW1lOiAncmVzdWx0J31dLFxyXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdib29sJywgc291cmNlOiAndmFsdWUnLCBhcnJheTogdHJ1ZX0sXHJcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2ludCcsIHNvdXJjZTogJ2luZGV4J31dLFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGluZGV4LCBpbmZvKSB7XHJcbiAgICAgICAgZmV0Y2gocmVzdWx0LCB2YWx1ZSwgaW5kZXgsIDEpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5nZXRcIiwge1xyXG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdieXRlJywgbmFtZTogJ3Jlc3VsdCd9XSxcclxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnYnl0ZScsIHNvdXJjZTogJ3ZhbHVlJywgYXJyYXk6IHRydWV9LFxyXG4gICAgICAgICAgICAgICAge3R5cGU6ICdpbnQnLCBzb3VyY2U6ICdpbmRleCd9XSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBpbmRleCwgaW5mbykge1xyXG4gICAgICAgIGZldGNoKHJlc3VsdCwgdmFsdWUsIGluZGV4LCAxKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5cclxuXHJcblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5nZXRcIiwge1xyXG4gICAgb3V0cHV0czogWyAge3R5cGU6ICd1Ynl0ZScsIG5hbWU6ICdyZXN1bHQnfV0sXHJcbiAgICBwYXJhbXM6ICBbICB7dHlwZTogJ3VieXRlJywgc291cmNlOiAndmFsdWUnLCBhcnJheTogdHJ1ZX0sXHJcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2ludCcsIHNvdXJjZTogJ2luZGV4J31dLFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGluZGV4LCBpbmZvKSB7XHJcbiAgICAgICAgZmV0Y2gocmVzdWx0LCB2YWx1ZSwgaW5kZXgsIDEpO1xyXG4gICAgfVxyXG59KTtcclxuIiwiWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmdyYXlzY2FsZUltYWdlXCIsIHtcclxuICAgIG91dHB1dHM6IFsge3R5cGU6ICd0ZXh0dXJlJywgbmFtZSA6ICdyZXN1bHQnLCBzaXplb2YgOiAnaW1hZ2UnfSBdLFxyXG4gICAgcGFyYW1zOiAgWyB7dHlwZTogJ3RleHR1cmUnLCBzb3VyY2UgOiAnaW1hZ2UnfSBdLFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgaW1hZ2UpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSBpbWFnZS53aWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xyXG5cclxuICAgICAgICB2YXIgcyA9IGltYWdlLmRhdGE7XHJcbiAgICAgICAgdmFyIGQgPSByZXN1bHQuZGF0YTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpICs9IDQpIHtcclxuICAgICAgICAgICAgdmFyIHIgPSBzW2ldO1xyXG4gICAgICAgICAgICB2YXIgZyA9IHNbaSArIDFdO1xyXG4gICAgICAgICAgICB2YXIgYiA9IHNbaSArIDJdO1xyXG4gICAgICAgICAgICB2YXIgYSA9IHNbaSArIDNdO1xyXG4gICAgICAgICAgICAvLyBDSUUgbHVtaW5hbmNlIGZvciB0aGUgUkdCXHJcbiAgICAgICAgICAgIC8vIFRoZSBodW1hbiBleWUgaXMgYmFkIGF0IHNlZWluZyByZWQgYW5kIGJsdWUsIHNvIHdlIGRlLWVtcGhhc2l6ZSB0aGVtLlxyXG4gICAgICAgICAgICB2YXIgdiA9IDAuMjEyNiAqIHIgKyAwLjcxNTIgKiBnICsgMC4wNzIyICogYjtcclxuICAgICAgICAgICAgZFtpXSA9IGRbaSArIDFdID0gZFtpICsgMl0gPSB2XHJcbiAgICAgICAgICAgIGRbaSArIDNdID0gYTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJyZXF1aXJlKFwiLi9hZGQuanNcIik7XHJcbnJlcXVpcmUoXCIuL2J1ZmZlclNlbGVjdC5qc1wiKTtcclxucmVxdWlyZShcIi4vY2xhbXBJbWFnZS5qc1wiKTtcclxucmVxdWlyZShcIi4vY29udm9sdXRlSW1hZ2UuanNcIik7XHJcbnJlcXVpcmUoXCIuL2NyZWF0ZUlHSW5kZXguanNcIik7XHJcbnJlcXVpcmUoXCIuL2NyZWF0ZVRyYW5zZm9ybS5qc1wiKTtcclxucmVxdWlyZShcIi4vY3JlYXRlVHJhbnNmb3JtSW52LmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9kZWJ1Zy5qc1wiKTtcclxucmVxdWlyZShcIi4vZmxpcE5vcm1hbC5qc1wiKTtcclxucmVxdWlyZShcIi4vZmxpcFZlcnRpY2FsSW1hZ2UuanNcIik7XHJcbnJlcXVpcmUoXCIuL2ZvcndhcmRLaW5lbWF0aWNzLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9mb3J3YXJkS2luZW1hdGljc0ludi5qc1wiKTtcclxucmVxdWlyZShcIi4vZnVuTWlycm9ySW1hZ2UuanNcIik7XHJcbnJlcXVpcmUoXCIuL2dldC5qc1wiKTtcclxucmVxdWlyZShcIi4vZ3JheXNjYWxlSW1hZ2UuanNcIik7XHJcbnJlcXVpcmUoXCIuL2xlcnAzc2VxLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9tYWduaXR1ZGVJbWFnZS5qc1wiKTtcclxucmVxdWlyZShcIi4vbW9ycGgzLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9tdWw0eDQuanNcIik7XHJcbnJlcXVpcmUoXCIuL25vaXNlSW1hZ2UuanNcIik7XHJcbnJlcXVpcmUoXCIuL25vcm1hbGl6ZTMuanNcIik7XHJcbnJlcXVpcmUoXCIuL3BvcGFydEltYWdlLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9yZ2JlUE5HdG9GbG9hdC5qc1wiKTtcclxucmVxdWlyZShcIi4vc2VsZWN0Qm9vbC5qc1wiKTtcclxucmVxdWlyZShcIi4vc2VsZWN0VHJhbnNmb3JtLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9zZXBpYUltYWdlLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9za2luRGlyZWN0aW9uLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9za2luUG9zaXRpb24uanNcIik7XHJcbnJlcXVpcmUoXCIuL3NsZXJwc2VxLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9zb2JlbEltYWdlLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9zdWIzLmpzXCIpO1xyXG5yZXF1aXJlKFwiLi9kaXYuanNcIik7XHJcbiIsInZhciBiaW5hcnlTZWFyY2ggPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvdXRpbHNcIikuYmluYXJ5U2VhcmNoO1xyXG52YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4vaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxuXHJcblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5sZXJwU2VxXCIsIHtcclxuICAgIG91dHB1dHM6IFsgIHt0eXBlOiAnZmxvYXQzJywgbmFtZTogJ3Jlc3VsdCd9XSxcclxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnZmxvYXQzJywgc291cmNlOiAnc2VxdWVuY2UnfSxcclxuICAgICAgICB7dHlwZTogJ2Zsb2F0Jywgc291cmNlOiAna2V5J31dLFxyXG4gICAgbWFwcGluZzogWyAgeyBuYW1lOiAndmFsdWUxJywgc291cmNlOiAnc2VxdWVuY2UnLCBzZXF1ZW5jZTogWEMuU0VRVUVOQ0UuUFJFVl9CVUZGRVIsIGtleVNvdXJjZTogJ2tleSd9LFxyXG4gICAgICAgIHsgbmFtZTogJ3ZhbHVlMicsIHNvdXJjZTogJ3NlcXVlbmNlJywgc2VxdWVuY2U6IFhDLlNFUVVFTkNFLk5FWFRfQlVGRkVSLCBrZXlTb3VyY2U6ICdrZXknfSxcclxuICAgICAgICB7IG5hbWU6ICd3ZWlnaHQnLCBzb3VyY2U6ICdzZXF1ZW5jZScsIHNlcXVlbmNlOiBYQy5TRVFVRU5DRS5MSU5FQVJfV0VJR0hULCBrZXlTb3VyY2U6ICdrZXknfV0sXHJcbiAgICBldmFsdWF0ZV9jb3JlOiBmdW5jdGlvbihyZXN1bHQsIHZhbHVlMSwgdmFsdWUyLCB3ZWlnaHQpe1xyXG4gICAgICAgIHZhciBpbnZXZWlnaHQgPSAxIC0gd2VpZ2h0WzBdO1xyXG4gICAgICAgIHJlc3VsdFswXSA9IGludldlaWdodCp2YWx1ZTFbMF0gKyB3ZWlnaHRbMF0qdmFsdWUyWzBdO1xyXG4gICAgICAgIHJlc3VsdFsxXSA9IGludldlaWdodCp2YWx1ZTFbMV0gKyB3ZWlnaHRbMF0qdmFsdWUyWzFdO1xyXG4gICAgICAgIHJlc3VsdFsyXSA9IGludldlaWdodCp2YWx1ZTFbMl0gKyB3ZWlnaHRbMF0qdmFsdWUyWzJdO1xyXG4gICAgfVxyXG59KTtcclxuXHJcblxyXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cubGVycFNlcUFzeW5jXCIsIHtcclxuICAgIG91dHB1dHM6IFsgIHt0eXBlOiAnZmxvYXQzJywgbmFtZTogJ3Jlc3VsdCd9XSxcclxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnZmxvYXQzJywgc291cmNlOiAnc2VxdWVuY2UnfSxcclxuICAgICAgICB7dHlwZTogJ2Zsb2F0Jywgc291cmNlOiAna2V5J31dLFxyXG4gICAgbWFwcGluZzogWyAgeyBuYW1lOiAndmFsdWUxJywgc291cmNlOiAnc2VxdWVuY2UnLCBzZXF1ZW5jZTogWEMuU0VRVUVOQ0UuUFJFVl9CVUZGRVIsIGtleVNvdXJjZTogJ2tleSd9LFxyXG4gICAgICAgIHsgbmFtZTogJ3ZhbHVlMicsIHNvdXJjZTogJ3NlcXVlbmNlJywgc2VxdWVuY2U6IFhDLlNFUVVFTkNFLk5FWFRfQlVGRkVSLCBrZXlTb3VyY2U6ICdrZXknfSxcclxuICAgICAgICB7IG5hbWU6ICd3ZWlnaHQnLCBzb3VyY2U6ICdzZXF1ZW5jZScsIHNlcXVlbmNlOiBYQy5TRVFVRU5DRS5MSU5FQVJfV0VJR0hULCBrZXlTb3VyY2U6ICdrZXknfV0sXHJcbiAgICBldmFsdWF0ZV9hc3luYzogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZTEsIHZhbHVlMiwgd2VpZ2h0LCBpbmZvLCBjYWxsYmFjayl7XHJcbiAgICAgICAgdmFyIGkgPSBpbmZvLml0ZXJhdGVDb3VudCwgb2ZmMCwgb2ZmMSwgb2ZmMjtcclxuICAgICAgICB3aGlsZShpLS0pe1xyXG4gICAgICAgICAgICBvZmYwID0gKGluZm8uaXRlckZsYWdbMF0gPyBpIDogMCkqMztcclxuICAgICAgICAgICAgb2ZmMSA9IChpbmZvLml0ZXJGbGFnWzFdID8gaSA6IDApKjM7XHJcbiAgICAgICAgICAgIG9mZjIgPSBpbmZvLml0ZXJGbGFnWzJdID8gaSA6IDA7XHJcbiAgICAgICAgICAgIHZhciBpbnZXZWlnaHQgPSAxIC0gd2VpZ2h0W29mZjJdO1xyXG4gICAgICAgICAgICByZXN1bHRbaSozXSA9IGludldlaWdodCp2YWx1ZTFbb2ZmMF0gKyB3ZWlnaHRbb2ZmMl0qdmFsdWUyW29mZjFdO1xyXG4gICAgICAgICAgICByZXN1bHRbaSozKzFdID0gaW52V2VpZ2h0KnZhbHVlMVtvZmYwKzFdICsgd2VpZ2h0W29mZjJdKnZhbHVlMltvZmYxKzFdO1xyXG4gICAgICAgICAgICByZXN1bHRbaSozKzJdID0gaW52V2VpZ2h0KnZhbHVlMVtvZmYwKzJdICsgd2VpZ2h0W29mZjJdKnZhbHVlMltvZmYxKzJdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMjAwKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5cclxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmxlcnBLZXlzXCIsIHtcclxuICAgIG91dHB1dHM6IFsgIHt0eXBlOiAnZmxvYXQzJywgbmFtZTogJ3Jlc3VsdCd9XSxcclxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnZmxvYXQnLCBzb3VyY2U6ICdrZXlzJywgYXJyYXk6IHRydWV9LFxyXG4gICAgICAgIHt0eXBlOiAnZmxvYXQzJywgc291cmNlOiAndmFsdWVzJywgYXJyYXk6IHRydWV9LFxyXG4gICAgICAgIHt0eXBlOiAnZmxvYXQnLCBzb3VyY2U6ICdrZXknfV0sXHJcbiAgICBhbGxvYzogZnVuY3Rpb24oc2l6ZXMsIGtleXMsIHZhbHVlcywga2V5KVxyXG4gICAge1xyXG4gICAgICAgIHNpemVzWydyZXN1bHQnXSA9IDM7XHJcbiAgICB9LFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwga2V5cywgdmFsdWVzLCBrZXkpIHtcclxuICAgICAgICB2YXIgbWF4SWR4ID0gTWF0aC5taW4oa2V5cy5sZW5ndGgsIE1hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIDMpKTtcclxuICAgICAgICB2YXIgaWR4ID0gYmluYXJ5U2VhcmNoKGtleXMsIGtleVswXSwgbWF4SWR4KTtcclxuXHJcbiAgICAgICAgaWYoaWR4IDwgMCB8fCBpZHggPT0gbWF4SWR4IC0gMSl7XHJcbiAgICAgICAgICAgIGlkeCA9IE1hdGgubWF4KDAsaWR4KTtcclxuICAgICAgICAgICAgcmVzdWx0WzBdID0gdmFsdWVzWzMqaWR4XTtcclxuICAgICAgICAgICAgcmVzdWx0WzFdID0gdmFsdWVzWzMqaWR4KzFdO1xyXG4gICAgICAgICAgICByZXN1bHRbMl0gPSB2YWx1ZXNbMyppZHgrMl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHZhciB3ZWlnaHQgPSAoa2V5WzBdIC0ga2V5c1tpZHhdKSAvIChrZXlzW2lkeCsxXSAtIGtleXNbaWR4XSk7XHJcbiAgICAgICAgICAgIHZhciBpbnZXZWlnaHQgPSAxIC0gd2VpZ2h0O1xyXG4gICAgICAgICAgICByZXN1bHRbMF0gPSBpbnZXZWlnaHQqdmFsdWVzWzMqaWR4XSArIHdlaWdodCp2YWx1ZXNbMyppZHggKyAzXTtcclxuICAgICAgICAgICAgcmVzdWx0WzFdID0gaW52V2VpZ2h0KnZhbHVlc1szKmlkeCsxXSArIHdlaWdodCp2YWx1ZXNbMyppZHggKyA0XTtcclxuICAgICAgICAgICAgcmVzdWx0WzJdID0gaW52V2VpZ2h0KnZhbHVlc1szKmlkeCsyXSArIHdlaWdodCp2YWx1ZXNbMyppZHggKyA1XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuXHJcblxyXG5cclxuXHJcbiIsIlhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5tYWduaXR1ZGVJbWFnZVwiLCB7XHJcbiAgICBvdXRwdXRzOiBbIHt0eXBlOiAndGV4dHVyZScsIG5hbWUgOiAncmVzdWx0Jywgc2l6ZW9mIDogJ2ltYWdlMSd9IF0sXHJcbiAgICBwYXJhbXM6ICBbXHJcbiAgICAgICAge3R5cGU6ICd0ZXh0dXJlJywgc291cmNlIDogJ2ltYWdlMSd9LFxyXG4gICAgICAgIHt0eXBlOiAndGV4dHVyZScsIHNvdXJjZSA6ICdpbWFnZTInfVxyXG4gICAgXSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGltYWdlMSwgaW1hZ2UyKSB7XHJcbiAgICAgICAgdmFyIGlucGl4MSA9IGltYWdlMS5kYXRhO1xyXG4gICAgICAgIHZhciBpbnBpeDIgPSBpbWFnZTIuZGF0YTtcclxuICAgICAgICB2YXIgb3V0cGl4ID0gcmVzdWx0LmRhdGE7XHJcblxyXG4gICAgICAgIHZhciBsZW4gPSBpbnBpeDEubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGxlbjsgaSs9MSkge1xyXG4gICAgICAgICAgICB2YXIgdmFsMSA9IGlucGl4MVtpXTtcclxuICAgICAgICAgICAgdmFyIHZhbDIgPSBpbnBpeDJbaV07XHJcbiAgICAgICAgICAgIG91dHBpeFtpXSA9IE1hdGguc3FydCh2YWwxKnZhbDEgKyB2YWwyKnZhbDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufSk7XHJcbiIsIlxyXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cubW9ycGhcIiwge1xyXG4gICAgb3V0cHV0czogW3t0eXBlOiAnZmxvYXQzJywgbmFtZTogJ3Jlc3VsdCd9XSxcclxuICAgIHBhcmFtczogIFtcclxuICAgICAgICB7IHR5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICd2YWx1ZScgfSxcclxuICAgICAgICB7IHR5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICd2YWx1ZUFkZCd9LFxyXG4gICAgICAgIHsgdHlwZTogJ2Zsb2F0Jywgc291cmNlOiAnd2VpZ2h0J31cclxuICAgIF0sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwgdmFsdWVBZGQsIHdlaWdodCwgaW5mbykge1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpbmZvLml0ZXJhdGVDb3VudDsgaSsrKXtcclxuICAgICAgICAgICAgdmFyIHcgPSB3ZWlnaHRbaW5mby5pdGVyRmxhZ1syXSA/IGkgOiAwXTtcclxuICAgICAgICAgICAgcmVzdWx0WzMqaV0gPSB2YWx1ZVsgaW5mby5pdGVyRmxhZ1swXSA/IDMqaSA6IDBdICsgdyAqIHZhbHVlQWRkW2luZm8uaXRlckZsYWdbMV0gPyAzKmkgOiAwXTtcclxuICAgICAgICAgICAgcmVzdWx0WzMqaSsxXSA9IHZhbHVlWyBpbmZvLml0ZXJGbGFnWzBdID8gMyppKzEgOiAxXSArIHcgKiB2YWx1ZUFkZFtpbmZvLml0ZXJGbGFnWzFdID8gMyppKzEgOiAxXTtcclxuICAgICAgICAgICAgcmVzdWx0WzMqaSsyXSA9IHZhbHVlWyBpbmZvLml0ZXJGbGFnWzBdID8gMyppKzIgOiAyXSArIHcgKiB2YWx1ZUFkZFtpbmZvLml0ZXJGbGFnWzFdID8gMyppKzIgOiAyXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgZXZhbHVhdGVfY29yZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwgdmFsdWVBZGQsIHdlaWdodCl7XHJcbiAgICAgICAgcmVzdWx0WzBdID0gdmFsdWVbMF0gKyB3ZWlnaHRbMF0gKiB2YWx1ZUFkZFswXTtcclxuICAgICAgICByZXN1bHRbMV0gPSB2YWx1ZVsxXSArIHdlaWdodFswXSAqIHZhbHVlQWRkWzFdO1xyXG4gICAgICAgIHJlc3VsdFsyXSA9IHZhbHVlWzJdICsgd2VpZ2h0WzBdICogdmFsdWVBZGRbMl07XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJYZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cubXVsXCIsIHtcclxuICAgIG91dHB1dHM6IFsgIHt0eXBlOiAnZmxvYXQ0eDQnLCBuYW1lOiAncmVzdWx0J31dLFxyXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdmbG9hdDR4NCcsIHNvdXJjZTogJ3ZhbHVlMSd9LFxyXG4gICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdDR4NCcsIHNvdXJjZTogJ3ZhbHVlMid9XSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIHZhbHVlMSwgdmFsdWUyLCBpbmZvKSB7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGluZm8uaXRlcmF0ZUNvdW50OyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBYTUwzRC5tYXRoLm1hdDQubXVsdGlwbHlPZmZzZXQocmVzdWx0LCBpKjE2LFxyXG4gICAgICAgICAgICAgICAgdmFsdWUxLCAgaW5mby5pdGVyRmxhZ1swXSA/IGkqMTYgOiAwLFxyXG4gICAgICAgICAgICAgICAgdmFsdWUyLCBpbmZvLml0ZXJGbGFnWzFdID8gaSoxNiA6IDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcbiIsIlxyXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cubm9pc2VJbWFnZVwiLCB7XHJcbiAgICBvdXRwdXRzOiBbIHt0eXBlOiAndGV4dHVyZScsIG5hbWUgOiAnaW1hZ2UnLCBjdXN0b21BbGxvYzogdHJ1ZX0gXSxcclxuICAgIHBhcmFtczogIFsge3R5cGU6ICdpbnQnLCBzb3VyY2U6ICd3aWR0aCd9LFxyXG4gICAgICAgICAgICAgICB7dHlwZTogJ2ludCcsIHNvdXJjZTonaGVpZ2h0J30sXHJcbiAgICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQyJywgc291cmNlOiAnc2NhbGUnfSxcclxuICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdCcsIHNvdXJjZTogJ21pbkZyZXEnfSxcclxuICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdCcsIHNvdXJjZTogJ21heEZyZXEnfSBdLFxyXG4gICAgYWxsb2M6IGZ1bmN0aW9uKHNpemVzLCB3aWR0aCwgaGVpZ2h0LCBzY2FsZSwgbWluRnJlcSwgbWF4RnJlcSkge1xyXG4gICAgICAgIHZhciBzYW1wbGVyQ29uZmlnID0gbmV3IFhmbG93LlNhbXBsZXJDb25maWc7XHJcbiAgICAgICAgc2FtcGxlckNvbmZpZy5zZXREZWZhdWx0cygpO1xyXG4gICAgICAgIHNpemVzWydpbWFnZSddID0ge1xyXG4gICAgICAgICAgICBpbWFnZUZvcm1hdCA6IHt3aWR0aDogd2lkdGhbMF0sIGhlaWdodCA6aGVpZ2h0WzBdfSxcclxuICAgICAgICAgICAgc2FtcGxlckNvbmZpZyA6IHNhbXBsZXJDb25maWdcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihpbWFnZSwgd2lkdGgsIGhlaWdodCwgc2NhbGUsIG1pbkZyZXEsIG1heEZyZXEpIHtcclxuICAgICAgICB3aWR0aCA9IHdpZHRoWzBdO1xyXG4gICAgICAgIGhlaWdodCA9IGhlaWdodFswXTtcclxuICAgICAgICBtaW5GcmVxID0gbWluRnJlcVswXTtcclxuICAgICAgICBtYXhGcmVxID0gbWF4RnJlcVswXTtcclxuXHJcbiAgICAgICAgdmFyIGlkID0gaW1hZ2U7XHJcbiAgICAgICAgdmFyIHBpeCA9IGlkLmRhdGE7XHJcbiAgICAgICAgdGhpcy5ub2lzZSA9IHRoaXMubm9pc2UgfHwgbmV3IFNpbXBsZXhOb2lzZSgpO1xyXG4gICAgICAgIHZhciBub2lzZSA9IHRoaXMubm9pc2U7XHJcblxyXG4gICAgICAgIHZhciB1c2VUdXJidWxlbmNlID0gbWluRnJlcSAhPSAwLjAgJiYgbWF4RnJlcSAhPSAwLjAgJiYgbWluRnJlcSA8IG1heEZyZXE7XHJcblxyXG4gICAgICAgIHZhciBzbm9pc2UgPSBmdW5jdGlvbih4LHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vaXNlLm5vaXNlKHgsIHkpOyAvLyBub2lzZS5ub2lzZSByZXR1cm5zIHZhbHVlcyBpbiByYW5nZSBbLTEsMV1cclxuICAgICAgICAgICAgLy9yZXR1cm4gMi4wICogbm9pc2Uubm9pc2UoeCwgeSkgLSAxLjA7IC8vIHRoaXMgY29kZSBpcyBmb3Igbm9pc2UgdmFsdWUgaW4gcmFuZ2UgWzAsMV1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgdHVyYnVsZW5jZSA9IGZ1bmN0aW9uKG1pbkZyZXEsIG1heEZyZXEsIHMsIHQpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgZiA9IG1pbkZyZXE7IGYgPCBtYXhGcmVxOyBmICo9IDIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlICs9IE1hdGguYWJzKHNub2lzZShzICogZiwgdCAqIGYpKS9mO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHQgPSB5IC8gaGVpZ2h0ICogc2NhbGVbMV07XHJcbiAgICAgICAgICAgIHZhciBpbnZXaWR0aCA9IDEuMCAvIHdpZHRoO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgKyt4KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHggKiBpbnZXaWR0aCAqIHNjYWxlWzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSB1c2VUdXJidWxlbmNlID8gdHVyYnVsZW5jZShtaW5GcmVxLCBtYXhGcmVxLCBzLCB0KSA6IHNub2lzZShzLCB0KTtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAoeCAqIHdpZHRoICsgeSkgKiA0O1xyXG4gICAgICAgICAgICAgICAgcGl4W29mZnNldF0gPSAgTWF0aC5mbG9vcih2ICogMjU1KTtcclxuICAgICAgICAgICAgICAgIHBpeFtvZmZzZXQrMV0gPSBNYXRoLmZsb29yKHYgKiAyNTUpO1xyXG4gICAgICAgICAgICAgICAgcGl4W29mZnNldCsyXSA9IE1hdGguZmxvb3IodiAqIDI1NSk7XHJcbiAgICAgICAgICAgICAgICBwaXhbb2Zmc2V0KzNdID0gMjU1O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBGaWxsIHdpdGggZ3JlZW4gY29sb3JcclxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgKyt4KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gKHggKiB3aWR0aCArIHkpICogNDtcclxuICAgICAgICAgICAgICAgIHBpeFtvZmZzZXRdID0gIDBcclxuICAgICAgICAgICAgICAgIHBpeFtvZmZzZXQrMV0gPSAyNTU7XHJcbiAgICAgICAgICAgICAgICBwaXhbb2Zmc2V0KzJdID0gMDtcclxuICAgICAgICAgICAgICAgIHBpeFtvZmZzZXQrM10gPSAyNTU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgKi9cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJcclxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93Lm5vcm1hbGl6ZVwiLCB7XHJcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0MycsIG5hbWU6ICdyZXN1bHQnfV0sXHJcbiAgICBwYXJhbXM6ICBbICB7dHlwZTogJ2Zsb2F0MycsIHNvdXJjZTogJ3ZhbHVlJ31dLFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGluZm8pIHtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgaW5mby5pdGVyYXRlQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMyppO1xyXG4gICAgICAgICAgICB2YXIgeCA9IHZhbHVlW29mZnNldF07XHJcbiAgICAgICAgICAgIHZhciB5ID0gdmFsdWVbb2Zmc2V0KzFdO1xyXG4gICAgICAgICAgICB2YXIgeiA9IHZhbHVlW29mZnNldCsyXTtcclxuICAgICAgICAgICAgdmFyIGwgPSAxLjAvTWF0aC5zcXJ0KHgqeCt5Knkreip6KTtcclxuICAgICAgICAgICAgcmVzdWx0W29mZnNldF0gPSB4Kmw7XHJcbiAgICAgICAgICAgIHJlc3VsdFtvZmZzZXQrMV0gPSB5Kmw7XHJcbiAgICAgICAgICAgIHJlc3VsdFtvZmZzZXQrMl0gPSB6Kmw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuIiwiXHJcbi8vIEJhc2VkIG9uIGh0dHA6Ly9rb2RlbW9uZ2tpLmJsb2dzcG90LmRlLzIwMTEvMDYva2FtZXJha3UtY3VzdG9tLXNoYWRlci1lZmZlY3RzLWV4YW1wbGUuaHRtbFxyXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cucG9wYXJ0SW1hZ2VcIiwge1xyXG4gICAgb3V0cHV0czogWyB7dHlwZTogJ3RleHR1cmUnLCBuYW1lIDogJ3Jlc3VsdCcsIHNpemVvZiA6ICdpbWFnZSd9IF0sXHJcbiAgICBwYXJhbXM6ICBbIHt0eXBlOiAndGV4dHVyZScsIHNvdXJjZSA6ICdpbWFnZSd9LFxyXG4gICAgICAgIHt0eXBlOiAnZmxvYXQnLCBzb3VyY2UgOiAndGltZSd9IF0sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCBpbWFnZSwgdGltZSkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IGltYWdlLndpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XHJcblxyXG4gICAgICAgIHZhciBzID0gaW1hZ2UuZGF0YTtcclxuICAgICAgICB2YXIgZCA9IHJlc3VsdC5kYXRhO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkgKz0gNCkge1xyXG4gICAgICAgICAgICB2YXIgciA9IHNbaV0gLyAyNTU7XHJcbiAgICAgICAgICAgIHZhciBnID0gc1tpICsgMV0gLyAyNTU7XHJcbiAgICAgICAgICAgIHZhciBiID0gc1tpICsgMl0gLyAyNTU7XHJcbiAgICAgICAgICAgIHZhciBhID0gc1tpICsgM10gLyAyNTU7XHJcblxyXG4gICAgICAgICAgICB2YXIgeSA9IDAuMyAqIHIgKyAwLjU5ICogZyArIDAuMTEgKiBiO1xyXG4gICAgICAgICAgICB5ID0geSA8IDAuMyA/IDAuMCA6ICh5IDwgMC42ID8gMC41IDogMS4wKTtcclxuICAgICAgICAgICAgaWYgKHkgPT0gMC41KSB7XHJcbiAgICAgICAgICAgICAgICBkW2ldICAgPSAwLjggKiAyNTU7XHJcbiAgICAgICAgICAgICAgICBkW2krMV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgZFtpKzJdID0gMDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh5ID09IDEuMCkge1xyXG4gICAgICAgICAgICAgICAgZFtpXSAgID0gMC45ICogMjU1O1xyXG4gICAgICAgICAgICAgICAgZFtpKzFdID0gMC45ICogMjU1O1xyXG4gICAgICAgICAgICAgICAgZFtpKzJdID0gMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRbaV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgZFtpKzFdID0gMDtcclxuICAgICAgICAgICAgICAgIGRbaSsyXSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZFtpKzNdID0gc1tpKzNdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufSk7XHJcbiIsInZhciBTYW1wbGVyQ29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZS9kYXRhLmpzXCIpLlNhbXBsZXJDb25maWc7XHJcbnZhciBYQyA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xyXG5cclxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LnJnYmVQTkd0b0Zsb2F0XCIsIHtcclxuICAgIG91dHB1dHM6IFsge3R5cGU6ICd0ZXh0dXJlJywgbmFtZSA6ICdyZXN1bHQnLCBjdXN0b21BbGxvYzogdHJ1ZSB9IF0sXHJcbiAgICBwYXJhbXM6ICBbXHJcbiAgICAgICAge3R5cGU6ICd0ZXh0dXJlJywgc291cmNlIDogJ2ltYWdlJ31cclxuICAgIF0sXHJcbiAgICBhbGxvYzogZnVuY3Rpb24gKHNpemVzLCBpbWFnZSkge1xyXG4gICAgICAgIHZhciBzYW1wbGVyQ29uZmlnID0gbmV3IFNhbXBsZXJDb25maWc7XHJcbiAgICAgICAgc2FtcGxlckNvbmZpZy5zZXREZWZhdWx0cygpO1xyXG4gICAgICAgIHNhbXBsZXJDb25maWcubWluRmlsdGVyID0gWEMuVEVYX0ZJTFRFUl9UWVBFLk5FQVJFU1Q7XHJcbiAgICAgICAgc2FtcGxlckNvbmZpZy5tYWdGaWx0ZXIgPSBYQy5URVhfRklMVEVSX1RZUEUuTkVBUkVTVDtcclxuICAgICAgICBzaXplc1tcInJlc3VsdFwiXSA9IHtcclxuICAgICAgICAgICAgaW1hZ2VGb3JtYXQgOiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogaW1hZ2Uud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGltYWdlLmhlaWdodCxcclxuICAgICAgICAgICAgICAgIHRleGVsVHlwZTogWEMuVEVYVFVSRV9UWVBFLkZMT0FULFxyXG4gICAgICAgICAgICAgICAgdGV4ZWxGb3JtYXQ6IFhDLlRFWFRVUkVfRk9STUFULlJHQlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzYW1wbGVyQ29uZmlnOiBzYW1wbGVyQ29uZmlnXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCBpbWFnZSkge1xyXG4gICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGltYWdlLmRhdGEubGVuZ3RoOyBpZHggKz0gNCkge1xyXG4gICAgICAgICAgICB2YXIgcmdiZSA9IGltYWdlLmRhdGEuc3ViYXJyYXkoaWR4LCBpZHggKyA0KTtcclxuICAgICAgICAgICAgdmFyIGYgPSAwLjA7XHJcbiAgICAgICAgICAgIHZhciBlID0gcmdiZVszXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChlID4gMC4wKVxyXG4gICAgICAgICAgICAgICAgZiA9IE1hdGgucG93KDIuMCwgZSAtICgxMjguMCArIDguMCkpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJnYiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XHJcbiAgICAgICAgICAgIHJnYlswXSA9IHJnYmVbMF0gKiBmO1xyXG4gICAgICAgICAgICByZ2JbMV0gPSByZ2JlWzFdICogZjtcclxuICAgICAgICAgICAgcmdiWzJdID0gcmdiZVsyXSAqIGY7XHJcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhLnNldChyZ2IsIGlkeCAvIDQgKiAzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJcclxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LnNlbGVjdEJvb2xcIiwge1xyXG4gICAgb3V0cHV0czogWyB7dHlwZTogJ2Jvb2wnLCBuYW1lIDogJ3Jlc3VsdCcsIGN1c3RvbUFsbG9jOiB0cnVlfSBdLFxyXG4gICAgcGFyYW1zOiAgWyB7dHlwZTogJ2ludCcsIHNvdXJjZSA6ICdpbmRleCd9LFxyXG4gICAgICAgICAgICAgICB7dHlwZTogJ2Jvb2wnLCBzb3VyY2U6ICd2YWx1ZSd9IF0sXHJcbiAgICBhbGxvYzogZnVuY3Rpb24oc2l6ZXMsIGluZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgIHNpemVzWydyZXN1bHQnXSA9IDE7XHJcbiAgICB9LFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGkgPSBpbmRleFswXTtcclxuICAgICAgICBpZiAoaSA8IHZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXN1bHRbMF0gPSB2YWx1ZVtpXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHRbMF0gPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJcclxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LnNlbGVjdFRyYW5zZm9ybVwiLCB7XHJcbiAgICBvdXRwdXRzOiBbIHt0eXBlOiAnZmxvYXQ0eDQnLCBuYW1lIDogJ3Jlc3VsdCcsIGN1c3RvbUFsbG9jOiB0cnVlfSBdLFxyXG4gICAgcGFyYW1zOiAgWyB7dHlwZTogJ2ludCcsIHNvdXJjZSA6ICdpbmRleCd9LFxyXG4gICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0NHg0Jywgc291cmNlOiAndHJhbnNmb3JtJ30gXSxcclxuICAgIGFsbG9jOiBmdW5jdGlvbihzaXplcywgaW5kZXgsIHRyYW5zZm9ybSkge1xyXG4gICAgICAgIHNpemVzWydyZXN1bHQnXSA9IDE7XHJcbiAgICB9LFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgaW5kZXgsIHRyYW5zZm9ybSkge1xyXG4gICAgICAgIHZhciBpID0gMTYgKiBpbmRleFswXTtcclxuICAgICAgICBpZiAoaSA8IHRyYW5zZm9ybS5sZW5ndGggJiYgaSsxNSA8IHRyYW5zZm9ybS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmVzdWx0WzBdID0gdHJhbnNmb3JtW2krMF07XHJcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IHRyYW5zZm9ybVtpKzFdO1xyXG4gICAgICAgICAgICByZXN1bHRbMl0gPSB0cmFuc2Zvcm1baSsyXTtcclxuICAgICAgICAgICAgcmVzdWx0WzNdID0gdHJhbnNmb3JtW2krM107XHJcbiAgICAgICAgICAgIHJlc3VsdFs0XSA9IHRyYW5zZm9ybVtpKzRdO1xyXG4gICAgICAgICAgICByZXN1bHRbNV0gPSB0cmFuc2Zvcm1baSs1XTtcclxuICAgICAgICAgICAgcmVzdWx0WzZdID0gdHJhbnNmb3JtW2krNl07XHJcbiAgICAgICAgICAgIHJlc3VsdFs3XSA9IHRyYW5zZm9ybVtpKzddO1xyXG4gICAgICAgICAgICByZXN1bHRbOF0gPSB0cmFuc2Zvcm1baSs4XTtcclxuICAgICAgICAgICAgcmVzdWx0WzldID0gdHJhbnNmb3JtW2krOV07XHJcbiAgICAgICAgICAgIHJlc3VsdFsxMF0gPSB0cmFuc2Zvcm1baSsxMF07XHJcbiAgICAgICAgICAgIHJlc3VsdFsxMV0gPSB0cmFuc2Zvcm1baSsxMV07XHJcbiAgICAgICAgICAgIHJlc3VsdFsxMl0gPSB0cmFuc2Zvcm1baSsxMl07XHJcbiAgICAgICAgICAgIHJlc3VsdFsxM10gPSB0cmFuc2Zvcm1baSsxM107XHJcbiAgICAgICAgICAgIHJlc3VsdFsxNF0gPSB0cmFuc2Zvcm1baSsxNF07XHJcbiAgICAgICAgICAgIHJlc3VsdFsxNV0gPSB0cmFuc2Zvcm1baSsxNV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0WzBdID0gMTtcclxuICAgICAgICAgICAgcmVzdWx0WzFdID0gMDtcclxuICAgICAgICAgICAgcmVzdWx0WzJdID0gMDtcclxuICAgICAgICAgICAgcmVzdWx0WzNdID0gMDtcclxuICAgICAgICAgICAgcmVzdWx0WzRdID0gMDtcclxuICAgICAgICAgICAgcmVzdWx0WzVdID0gMTtcclxuICAgICAgICAgICAgcmVzdWx0WzZdID0gMDtcclxuICAgICAgICAgICAgcmVzdWx0WzddID0gMDtcclxuICAgICAgICAgICAgcmVzdWx0WzhdID0gMDtcclxuICAgICAgICAgICAgcmVzdWx0WzldID0gMDtcclxuICAgICAgICAgICAgcmVzdWx0WzEwXSA9IDE7XHJcbiAgICAgICAgICAgIHJlc3VsdFsxMV0gPSAwO1xyXG4gICAgICAgICAgICByZXN1bHRbMTJdID0gMDtcclxuICAgICAgICAgICAgcmVzdWx0WzEzXSA9IDA7XHJcbiAgICAgICAgICAgIHJlc3VsdFsxNF0gPSAwO1xyXG4gICAgICAgICAgICByZXN1bHRbMTVdID0gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJcclxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LnNlcGlhSW1hZ2VcIiwge1xyXG4gICAgb3V0cHV0czogWyB7dHlwZTogJ3RleHR1cmUnLCBuYW1lIDogJ3Jlc3VsdCcsIHNpemVvZiA6ICdpbWFnZSd9IF0sXHJcbiAgICBwYXJhbXM6ICBbIHt0eXBlOiAndGV4dHVyZScsIHNvdXJjZSA6ICdpbWFnZSd9IF0sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCBpbWFnZSkge1xyXG4gICAgICAgIHZhciBzID0gaW1hZ2UuZGF0YTtcclxuICAgICAgICB2YXIgZCA9IHJlc3VsdC5kYXRhO1xyXG4gICAgICAgIHZhciByID0gMCwgZyA9IDAsIGIgPSAwO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDAgOyBpIDwgcy5sZW5ndGg7IGkgKz0gNCkge1xyXG4gICAgICAgICAgICByID0gKHNbaV0gKiAwLjM5MyArIHNbaSsxXSAqIDAuNzY5ICsgc1tpKzJdICogMC4xODkpO1xyXG4gICAgICAgICAgICBnID0gKHNbaV0gKiAwLjM0OSArIHNbaSsxXSAqIDAuNjg2ICsgc1tpKzJdICogMC4xNjgpO1xyXG4gICAgICAgICAgICBiID0gKHNbaV0gKiAwLjI3MiArIHNbaSsxXSAqIDAuNTM0ICsgc1tpKzJdICogMC4xMzEpO1xyXG4gICAgICAgICAgICBpZiAocj4yNTUpIHIgPSAyNTU7XHJcbiAgICAgICAgICAgIGlmIChnPjI1NSkgZyA9IDI1NTtcclxuICAgICAgICAgICAgaWYgKGI+MjU1KSBiID0gMjU1O1xyXG4gICAgICAgICAgICBpZiAocjwwKSByID0gMDtcclxuICAgICAgICAgICAgaWYgKGc8MCkgZyA9IDA7XHJcbiAgICAgICAgICAgIGlmIChiPDApIGIgPSAwO1xyXG4gICAgICAgICAgICBkW2ldID0gcjtcclxuICAgICAgICAgICAgZFtpKzFdID0gZztcclxuICAgICAgICAgICAgZFtpKzJdID0gYjtcclxuICAgICAgICAgICAgZFtpKzNdID0gMjU1O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufSk7XHJcbiIsIlxyXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuc2tpbkRpcmVjdGlvblwiLCB7XHJcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0MycsIG5hbWU6ICdyZXN1bHQnIH1dLFxyXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICdkaXInIH0sXHJcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2ludDQnLCBzb3VyY2U6ICdib25lSWR4JyB9LFxyXG4gICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdDQnLCBzb3VyY2U6ICdib25lV2VpZ2h0JyB9LFxyXG4gICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdDR4NCcsIHNvdXJjZTogJ2JvbmVYZm9ybScsIGFycmF5OiB0cnVlIH0gXSxcclxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGRpcixib25lSWR4LGJvbmVXZWlnaHQsYm9uZVhmb3JtLCBpbmZvKSB7XHJcbiAgICAgICAgdmFyIHZlYzMgPSBYTUwzRC5tYXRoLnZlYzMsXHJcbiAgICAgICAgICAgIG1hdDQgPSBYTUwzRC5tYXRoLm1hdDQ7XHJcbiAgICAgICAgdmFyIHIgPSB2ZWMzLmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciB0bXAgPSAgdmVjMy5jcmVhdGUoKTtcclxuXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaTwgaW5mby5pdGVyYXRlQ291bnQ7KytpKSB7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpKjM7XHJcbiAgICAgICAgICAgIHJbMF0gPSByWzFdID0gclsyXSA9ICswO1xyXG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgNDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0ID0gYm9uZVdlaWdodFtpbmZvLml0ZXJGbGFnWzJdID8gaSo0K2ogOiBqXTtcclxuICAgICAgICAgICAgICAgIGlmICh3ZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbW8gPSBib25lSWR4W2luZm8uaXRlckZsYWdbMV0gPyBpKjQraiA6IGpdKjE2O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBtYXQ0Lm11bHRpcGx5T2Zmc2V0RGlyZWN0aW9uKGJvbmVYZm9ybSwgbW8sIGRpciwgb2Zmc2V0LCB0bXApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZlYzMuc2NhbGUodG1wLCB0bXAsIHdlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVjMy5hZGQociwgciwgdG1wKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2ZWMzLm5vcm1hbGl6ZShyLCByKTtcclxuICAgICAgICAgICAgcmVzdWx0W29mZnNldF0gPSByWzBdO1xyXG4gICAgICAgICAgICByZXN1bHRbb2Zmc2V0KzFdID0gclsxXTtcclxuICAgICAgICAgICAgcmVzdWx0W29mZnNldCsyXSA9IHJbMl07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuIiwiXHJcblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5za2luUG9zaXRpb25cIiwge1xyXG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdDMnLCBuYW1lOiAncmVzdWx0JyB9XSxcclxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnZmxvYXQzJywgc291cmNlOiAncG9zJyB9LFxyXG4gICAgICAgICAgICAgICAge3R5cGU6ICdpbnQ0Jywgc291cmNlOiAnYm9uZUlkeCcgfSxcclxuICAgICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQ0Jywgc291cmNlOiAnYm9uZVdlaWdodCcgfSxcclxuICAgICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQ0eDQnLCBzb3VyY2U6ICdib25lWGZvcm0nLCBhcnJheTogdHJ1ZSB9IF0sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCBwb3MsYm9uZUlkeCxib25lV2VpZ2h0LGJvbmVYZm9ybSwgaW5mbykge1xyXG4gICAgICAgIHZhciB2ZWMzID0gWE1MM0QubWF0aC52ZWMzLFxyXG4gICAgICAgICAgICBtYXQ0ID0gWE1MM0QubWF0aC5tYXQ0O1xyXG4gICAgICAgIHZhciByID0gdmVjMy5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgdG1wID0gIHZlYzMuY3JlYXRlKCk7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGk8IGluZm8uaXRlcmF0ZUNvdW50OysraSkge1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaSozO1xyXG4gICAgICAgICAgICByWzBdID0gclsxXSA9IHJbMl0gPSArMDtcclxuICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IDQ7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHdlaWdodCA9IGJvbmVXZWlnaHRbaW5mby5pdGVyRmxhZ1syXSA/IGkqNCtqIDogal07XHJcbiAgICAgICAgICAgICAgICBpZiAod2VpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vID0gYm9uZUlkeFtpbmZvLml0ZXJGbGFnWzFdID8gaSo0K2ogOiBqXSoxNjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0NC5tdWx0aXBseU9mZnNldFZlYzMoYm9uZVhmb3JtLCBtbywgcG9zLCBvZmZzZXQsIHRtcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVjMy5zY2FsZSh0bXAsIHRtcCwgd2VpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICB2ZWMzLmFkZChyLCByLCB0bXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdFtvZmZzZXRdID0gclswXTtcclxuICAgICAgICAgICAgcmVzdWx0W29mZnNldCsxXSA9IHJbMV07XHJcbiAgICAgICAgICAgIHJlc3VsdFtvZmZzZXQrMl0gPSByWzJdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcbiIsInZhciBiaW5hcnlTZWFyY2ggPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvdXRpbHNcIikuYmluYXJ5U2VhcmNoO1xyXG52YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4vaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxuXHJcblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5zbGVycFNlcVwiLCB7XHJcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0NCcsIG5hbWU6ICdyZXN1bHQnfV0sXHJcbiAgICBwYXJhbXM6ICBbICB7dHlwZTogJ2Zsb2F0NCcsIHNvdXJjZTogJ3NlcXVlbmNlJ30sXHJcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0Jywgc291cmNlOiAna2V5J31dLFxyXG4gICAgbWFwcGluZzogWyAge25hbWU6ICd2YWx1ZTEnLCBzb3VyY2U6ICdzZXF1ZW5jZScsIHNlcXVlbmNlOiBYQy5TRVFVRU5DRS5QUkVWX0JVRkZFUiwga2V5U291cmNlOiAna2V5J30sXHJcbiAgICAgICAgICAgICAgICB7bmFtZTogJ3ZhbHVlMicsICBzb3VyY2U6ICdzZXF1ZW5jZScsIHNlcXVlbmNlOiBYQy5TRVFVRU5DRS5ORVhUX0JVRkZFUiwga2V5U291cmNlOiAna2V5J30sXHJcbiAgICAgICAgICAgICAgICB7bmFtZTogJ3dlaWdodCcsICBzb3VyY2U6ICdzZXF1ZW5jZScsIHNlcXVlbmNlOiBYQy5TRVFVRU5DRS5MSU5FQVJfV0VJR0hULCBrZXlTb3VyY2U6ICdrZXknfV0sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZTEsIHZhbHVlMiwgd2VpZ2h0LCBpbmZvKSB7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGluZm8uaXRlcmF0ZUNvdW50OyArK2kpe1xyXG4gICAgICAgICAgICBYTUwzRC5tYXRoLnF1YXQuc2xlcnBPZmZzZXQoICB2YWx1ZTEsaW5mby5pdGVyRmxhZ1swXSA/IGkqNCA6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlMixpbmZvLml0ZXJGbGFnWzFdID8gaSo0IDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0WzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQsIGkqNCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcblxyXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuc2xlcnBLZXlzXCIsIHtcclxuICAgIG91dHB1dHM6IFsgIHt0eXBlOiAnZmxvYXQ0JywgbmFtZTogJ3Jlc3VsdCd9XSxcclxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnZmxvYXQnLCBzb3VyY2U6ICdrZXlzJywgYXJyYXk6IHRydWV9LFxyXG4gICAgICAgIHt0eXBlOiAnZmxvYXQ0Jywgc291cmNlOiAndmFsdWVzJywgYXJyYXk6IHRydWV9LFxyXG4gICAgICAgIHt0eXBlOiAnZmxvYXQnLCBzb3VyY2U6ICdrZXknfV0sXHJcbiAgICBhbGxvYzogZnVuY3Rpb24oc2l6ZXMsIGtleXMsIHZhbHVlcywga2V5KVxyXG4gICAge1xyXG4gICAgICAgIHNpemVzWydyZXN1bHQnXSA9IDQ7XHJcbiAgICB9LFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwga2V5cywgdmFsdWVzLCBrZXkpIHtcclxuICAgICAgICB2YXIgbWF4SWR4ID0gTWF0aC5taW4oa2V5cy5sZW5ndGgsIE1hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIDQpKTtcclxuICAgICAgICB2YXIgaWR4ID0gYmluYXJ5U2VhcmNoKGtleXMsIGtleVswXSwgbWF4SWR4KTtcclxuXHJcbiAgICAgICAgaWYoaWR4IDwgMCB8fCBpZHggPT0gbWF4SWR4IC0gMSl7XHJcbiAgICAgICAgICAgIGlkeCA9IE1hdGgubWF4KDAsaWR4KTtcclxuICAgICAgICAgICAgcmVzdWx0WzBdID0gdmFsdWVzWzQqaWR4XTtcclxuICAgICAgICAgICAgcmVzdWx0WzFdID0gdmFsdWVzWzQqaWR4KzFdO1xyXG4gICAgICAgICAgICByZXN1bHRbMl0gPSB2YWx1ZXNbNCppZHgrMl07XHJcbiAgICAgICAgICAgIHJlc3VsdFszXSA9IHZhbHVlc1s0KmlkeCszXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgdmFyIHdlaWdodCA9IChrZXlbMF0gLSBrZXlzW2lkeF0pIC8gKGtleXNbaWR4KzFdIC0ga2V5c1tpZHhdKTtcclxuICAgICAgICAgICAgWE1MM0QubWF0aC5xdWF0LnNsZXJwT2Zmc2V0KCAgdmFsdWVzLCBpZHgqNCxcclxuICAgICAgICAgICAgICAgIHZhbHVlcywoaWR4KzEpKjQsIHdlaWdodCxcclxuICAgICAgICAgICAgICAgIHJlc3VsdCwgMCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuIiwiXHJcbi8vIENvZGUgcG9ydGlvbnMgZnJvbSBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9jYW52YXMvaW1hZ2VmaWx0ZXJzL1xyXG4oZnVuY3Rpb24oKSB7XHJcbiAgICBYZmxvdy5GaWx0ZXJzID0ge307XHJcblxyXG4gICAgdmFyIHRtcENhbnZhcyA9IG51bGw7XHJcbiAgICB2YXIgdG1wQ3R4ID0gbnVsbDtcclxuXHJcbiAgICBYZmxvdy5GaWx0ZXJzLmNyZWF0ZUltYWdlRGF0YSA9IGZ1bmN0aW9uKHcsaCkge1xyXG4gICAgICAgIGlmICghdG1wQ2FudmFzKVxyXG4gICAgICAgICAgICB0bXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICBpZiAoIXRtcEN0eClcclxuICAgICAgICAgICAgdG1wQ3R4ID0gdG1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgcmV0dXJuIHRtcEN0eC5jcmVhdGVJbWFnZURhdGEodywgaCk7XHJcbiAgICB9O1xyXG5cclxuICAgIFhmbG93LkZpbHRlcnMuY3JlYXRlSW1hZ2VEYXRhRmxvYXQzMiA9IGZ1bmN0aW9uKHcsIGgpIHtcclxuICAgICAgICByZXR1cm4ge3dpZHRoOiB3LCBoZWlnaHQ6IGgsIGRhdGE6IG5ldyBGbG9hdDMyQXJyYXkodyAqIGggKiA0KX07XHJcbiAgICB9O1xyXG5cclxuICAgIFhmbG93LkZpbHRlcnMuZ3JheXNjYWxlID0gZnVuY3Rpb24oaW5waXhlbHMsIG91dHBpeGVscywgYXJncykge1xyXG4gICAgICAgICAgICB2YXIgcyA9IGlucGl4ZWxzLmRhdGE7XHJcbiAgICAgICAgICAgIHZhciBkID0gb3V0cGl4ZWxzLmRhdGE7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxzLmxlbmd0aDsgaSs9NCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHIgPSBzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGcgPSBzW2krMV07XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHNbaSsyXTtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gc1tpKzNdO1xyXG4gICAgICAgICAgICAgICAgLy8gQ0lFIGx1bWluYW5jZSBmb3IgdGhlIFJHQlxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGh1bWFuIGV5ZSBpcyBiYWQgYXQgc2VlaW5nIHJlZCBhbmQgYmx1ZSwgc28gd2UgZGUtZW1waGFzaXplIHRoZW0uXHJcbiAgICAgICAgICAgICAgICB2YXIgdiA9IDAuMjEyNipyICsgMC43MTUyKmcgKyAwLjA3MjIqYjtcclxuICAgICAgICAgICAgICAgIGRbaV0gPSBkW2krMV0gPSBkW2krMl0gPSB2XHJcbiAgICAgICAgICAgICAgICBkW2krM10gPSBhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpbnBpeGVscztcclxuICAgIH07XHJcblxyXG4gICAgWGZsb3cuRmlsdGVycy5jb252b2x1dGUgPSBmdW5jdGlvbihpbnBpeGVscywgb3V0cGl4ZWxzLCB3ZWlnaHRzLCBvcGFxdWUpIHtcclxuICAgICAgICAgICAgdmFyIHNpZGUgPSBNYXRoLnJvdW5kKE1hdGguc3FydCh3ZWlnaHRzLmxlbmd0aCkpO1xyXG4gICAgICAgICAgICB2YXIgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUvMik7XHJcbiAgICAgICAgICAgIHZhciBzcmMgPSBpbnBpeGVscy5kYXRhO1xyXG4gICAgICAgICAgICB2YXIgc3cgPSBpbnBpeGVscy53aWR0aDtcclxuICAgICAgICAgICAgdmFyIHNoID0gaW5waXhlbHMuaGVpZ2h0O1xyXG4gICAgICAgICAgICAvLyBwYWQgb3V0cHV0IGJ5IHRoZSBjb252b2x1dGlvbiBtYXRyaXhcclxuICAgICAgICAgICAgdmFyIHcgPSBzdztcclxuICAgICAgICAgICAgdmFyIGggPSBzaDtcclxuICAgICAgICAgICAgdmFyIGRzdCA9IG91dHBpeGVscy5kYXRhO1xyXG4gICAgICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBkZXN0aW5hdGlvbiBpbWFnZSBwaXhlbHNcclxuICAgICAgICAgICAgdmFyIGFscGhhRmFjID0gb3BhcXVlID8gMSA6IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHk9MDsgeTxoOyB5KyspIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHg9MDsgeDx3OyB4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3kgPSB5O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzeCA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRzdE9mZiA9ICh5KncreCkqNDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHdlaWdoZWQgc3VtIG9mIHRoZSBzb3VyY2UgaW1hZ2UgcGl4ZWxzIHRoYXRcclxuICAgICAgICAgICAgICAgICAgICAvLyBmYWxsIHVuZGVyIHRoZSBjb252b2x1dGlvbiBtYXRyaXhcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcj0wLCBnPTAsIGI9MCwgYT0wO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGN5PTA7IGN5PHNpZGU7IGN5KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY3g9MDsgY3g8c2lkZTsgY3grKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjeSA9IHN5ICsgY3kgLSBoYWxmU2lkZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3ggPSBzeCArIGN4IC0gaGFsZlNpZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2N5ID49IDAgJiYgc2N5IDwgc2ggJiYgc2N4ID49IDAgJiYgc2N4IDwgc3cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3JjT2ZmID0gKHNjeSpzdytzY3gpKjQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHd0ID0gd2VpZ2h0c1tjeSpzaWRlK2N4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByICs9IHNyY1tzcmNPZmZdICogd3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZyArPSBzcmNbc3JjT2ZmKzFdICogd3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiArPSBzcmNbc3JjT2ZmKzJdICogd3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSArPSBzcmNbc3JjT2ZmKzNdICogd3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZHN0W2RzdE9mZl0gPSByO1xyXG4gICAgICAgICAgICAgICAgICAgIGRzdFtkc3RPZmYrMV0gPSBnO1xyXG4gICAgICAgICAgICAgICAgICAgIGRzdFtkc3RPZmYrMl0gPSBiO1xyXG4gICAgICAgICAgICAgICAgICAgIGRzdFtkc3RPZmYrM10gPSBhICsgYWxwaGFGYWMqKDI1NS1hKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3V0cGl4ZWxzO1xyXG4gICAgICAgIH07XHJcbi8qXHJcbiAgICBYZmxvdy5GaWx0ZXJzLmNvbnZvbHV0ZUZsb2F0MzIgPSBmdW5jdGlvbihwaXhlbHMsIHdlaWdodHMsIG9wYXF1ZSkge1xyXG4gICAgICAgIHZhciBzaWRlID0gTWF0aC5yb3VuZChNYXRoLnNxcnQod2VpZ2h0cy5sZW5ndGgpKTtcclxuICAgICAgICB2YXIgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUgLyAyKTtcclxuXHJcbiAgICAgICAgdmFyIHNyYyA9IHBpeGVscy5kYXRhO1xyXG4gICAgICAgIHZhciBzdyA9IHBpeGVscy53aWR0aDtcclxuICAgICAgICB2YXIgc2ggPSBwaXhlbHMuaGVpZ2h0O1xyXG5cclxuICAgICAgICB2YXIgdyA9IHN3O1xyXG4gICAgICAgIHZhciBoID0gc2g7XHJcbiAgICAgICAgdmFyIG91dHB1dCA9IHtcclxuICAgICAgICAgICAgd2lkdGg6IHcsIGhlaWdodDogaCwgZGF0YTogbmV3IEZsb2F0MzJBcnJheSh3ICogaCAqIDQpXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgZHN0ID0gb3V0cHV0LmRhdGE7XHJcblxyXG4gICAgICAgIHZhciBhbHBoYUZhYyA9IG9wYXF1ZSA/IDEgOiAwO1xyXG5cclxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGg7IHkrKykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHc7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN5ID0geTtcclxuICAgICAgICAgICAgICAgIHZhciBzeCA9IHg7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHN0T2ZmID0gKHkgKiB3ICsgeCkgKiA0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHIgPSAwLCBnID0gMCwgYiA9IDAsIGEgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY3kgPSAwOyBjeSA8IHNpZGU7IGN5KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjeCA9IDA7IGN4IDwgc2lkZTsgY3grKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2N5ID0gTWF0aC5taW4oc2ggLSAxLCBNYXRoLm1heCgwLCBzeSArIGN5IC0gaGFsZlNpZGUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjeCA9IE1hdGgubWluKHN3IC0gMSwgTWF0aC5tYXgoMCwgc3ggKyBjeCAtIGhhbGZTaWRlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcmNPZmYgPSAoc2N5ICogc3cgKyBzY3gpICogNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHd0ID0gd2VpZ2h0c1tjeSAqIHNpZGUgKyBjeF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgKz0gc3JjW3NyY09mZl0gKiB3dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyArPSBzcmNbc3JjT2ZmICsgMV0gKiB3dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYiArPSBzcmNbc3JjT2ZmICsgMl0gKiB3dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSArPSBzcmNbc3JjT2ZmICsgM10gKiB3dDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkc3RbZHN0T2ZmXSA9IHI7XHJcbiAgICAgICAgICAgICAgICBkc3RbZHN0T2ZmICsgMV0gPSBnO1xyXG4gICAgICAgICAgICAgICAgZHN0W2RzdE9mZiArIDJdID0gYjtcclxuICAgICAgICAgICAgICAgIGRzdFtkc3RPZmYgKyAzXSA9IGEgKyBhbHBoYUZhYyAqICgyNTUgLSBhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfVxyXG4qL1xyXG59KCkpO1xyXG5cclxuZnVuY3Rpb24gZmxvYXQ0KHgseSx6LHcpIHtcclxuICAgIHZhciB2ID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcclxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgdlswXSA9IDA7XHJcbiAgICAgICAgICAgIHZbMV0gPSAwO1xyXG4gICAgICAgICAgICB2WzJdID0gMDtcclxuICAgICAgICAgICAgdlszXSA9IDA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgdlswXSA9IHg7XHJcbiAgICAgICAgICAgIHZbMV0gPSB4O1xyXG4gICAgICAgICAgICB2WzJdID0geDtcclxuICAgICAgICAgICAgdlszXSA9IHg7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgdlswXSA9IHg7XHJcbiAgICAgICAgICAgIHZbMV0gPSB5O1xyXG4gICAgICAgICAgICB2WzJdID0gMDtcclxuICAgICAgICAgICAgdlszXSA9IDA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgdlswXSA9IHg7XHJcbiAgICAgICAgICAgIHZbMV0gPSB5O1xyXG4gICAgICAgICAgICB2WzJdID0gejtcclxuICAgICAgICAgICAgdlszXSA9IDA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHZbMF0gPSB4O1xyXG4gICAgICAgICAgICB2WzFdID0geTtcclxuICAgICAgICAgICAgdlsyXSA9IHo7XHJcbiAgICAgICAgICAgIHZbM10gPSB3O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHY7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGh5cG90KGEsIGIpXHJcbntcclxuICAgIHJldHVybiBNYXRoLnNxcnQoYSphICsgYipiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaHlwb3Q0KGEsIGIpXHJcbntcclxuICAgIHJldHVybiBmbG9hdDQoaHlwb3QoYVswXSwgYlswXSksXHJcbiAgICAgICAgICAgICAgICAgIGh5cG90KGFbMV0sIGJbMV0pLFxyXG4gICAgICAgICAgICAgICAgICBoeXBvdChhWzJdLCBiWzJdKSxcclxuICAgICAgICAgICAgICAgICAgaHlwb3QoYVszXSwgYlszXSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoeXBvdDRUbyhyLCBhLCBiKVxyXG57XHJcbiAgICByWzBdID0gaHlwb3QoYVswXSwgYlswXSk7XHJcbiAgICByWzFdID0gaHlwb3QoYVsxXSwgYlsxXSk7XHJcbiAgICByWzJdID0gaHlwb3QoYVsyXSwgYlsyXSk7XHJcbiAgICByWzNdID0gaHlwb3QoYVszXSwgYlszXSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFRleGVsMkQoaW1hZ2VkYXRhLCB4LCB5KSB7XHJcbiAgICB2YXIgb2Zmc2V0ID0gKHkgKiBpbWFnZWRhdGEud2lkdGggKyB4KSAqIDQ7XHJcbiAgICB2YXIgZGF0YSA9IGltYWdlZGF0YS5kYXRhO1xyXG4gICAgdmFyIGNvbG9yID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcclxuICAgIGNvbG9yWzBdID0gZGF0YVtvZmZzZXRdIC8gMjU1LjA7XHJcbiAgICBjb2xvclsxXSA9IGRhdGFbb2Zmc2V0KzFdIC8gMjU1LjA7XHJcbiAgICBjb2xvclsyXSA9IGRhdGFbb2Zmc2V0KzJdIC8gMjU1LjA7XHJcbiAgICBjb2xvclszXSA9IGRhdGFbb2Zmc2V0KzNdIC8gMjU1LjA7XHJcbiAgICByZXR1cm4gY29sb3I7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFRleGVsMkRUbyhjb2xvciwgaW1hZ2VkYXRhLCB4LCB5KSB7XHJcbiAgICB2YXIgb2Zmc2V0ID0gKHkgKiBpbWFnZWRhdGEud2lkdGggKyB4KSAqIDQ7XHJcbiAgICB2YXIgZGF0YSA9IGltYWdlZGF0YS5kYXRhO1xyXG4gICAgY29sb3JbMF0gPSBkYXRhW29mZnNldF0gLyAyNTUuMDtcclxuICAgIGNvbG9yWzFdID0gZGF0YVtvZmZzZXQrMV0gLyAyNTUuMDtcclxuICAgIGNvbG9yWzJdID0gZGF0YVtvZmZzZXQrMl0gLyAyNTUuMDtcclxuICAgIGNvbG9yWzNdID0gZGF0YVtvZmZzZXQrM10gLyAyNTUuMDtcclxuICAgIHJldHVybiBjb2xvcjtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0VGV4ZWwyRChpbWFnZWRhdGEsIHgsIHksIGNvbG9yKSB7XHJcbiAgICB2YXIgb2Zmc2V0ID0gKHkgKiBpbWFnZWRhdGEud2lkdGggKyB4KSAqIDQ7XHJcbiAgICB2YXIgZGF0YSA9IGltYWdlZGF0YS5kYXRhO1xyXG4gICAgZGF0YVtvZmZzZXRdID0gY29sb3JbMF0gKiAyNTUuMCA7XHJcbiAgICBkYXRhW29mZnNldCsxXSA9IGNvbG9yWzFdICogMjU1LjA7XHJcbiAgICBkYXRhW29mZnNldCsyXSA9IGNvbG9yWzJdICogMjU1LjA7XHJcbiAgICBkYXRhW29mZnNldCszXSA9IGNvbG9yWzNdICogMjU1LjA7XHJcbn1cclxuXHJcblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5zb2JlbEltYWdlXCIsIHtcclxuICAgIG91dHB1dHM6IFsge3R5cGU6ICd0ZXh0dXJlJywgbmFtZSA6ICdyZXN1bHQnLCBzaXplb2YgOiAnaW1hZ2UnfSBdLFxyXG4gICAgcGFyYW1zOiAgWyB7dHlwZTogJ3RleHR1cmUnLCBzb3VyY2UgOiAnaW1hZ2UnfSBdLFxyXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgaW1hZ2UpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSBpbWFnZS53aWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyBTb2JlbCBmaWx0ZXIsIEFueVNMIG1ldGhvZFxyXG4gICAgICAgIHZhciBneCA9IGZsb2F0NCgwLjApO1xyXG4gICAgICAgIHZhciBneSA9IGZsb2F0NCgwLjApO1xyXG4gICAgICAgIHZhciBpMDAgPSBmbG9hdDQoKTtcclxuICAgICAgICB2YXIgaTAwID0gZmxvYXQ0KCk7XHJcbiAgICAgICAgdmFyIGkxMCA9IGZsb2F0NCgpO1xyXG4gICAgICAgIHZhciBpMjAgPSBmbG9hdDQoKTtcclxuICAgICAgICB2YXIgaTAxID0gZmxvYXQ0KCk7XHJcbiAgICAgICAgdmFyIGkxMSA9IGZsb2F0NCgpO1xyXG4gICAgICAgIHZhciBpMjEgPSBmbG9hdDQoKTtcclxuICAgICAgICB2YXIgaTAyID0gZmxvYXQ0KCk7XHJcbiAgICAgICAgdmFyIGkxMiA9IGZsb2F0NCgpO1xyXG4gICAgICAgIHZhciBpMjIgPSBmbG9hdDQoKTtcclxuICAgICAgICB2YXIgY29sb3IgPSBmbG9hdDQoKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7ICsreSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7ICsreClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLyogUmVhZCBlYWNoIHRleGVsIGNvbXBvbmVudCBhbmQgY2FsY3VsYXRlIHRoZSBmaWx0ZXJlZCB2YWx1ZSB1c2luZyBuZWlnaGJvdXJpbmcgdGV4ZWwgY29tcG9uZW50cyAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKCB4ID49IDEgJiYgeCA8ICh3aWR0aC0xKSAmJiB5ID49IDEgJiYgeSA8IGhlaWdodCAtIDEpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0VGV4ZWwyRFRvKGkwMCwgaW1hZ2UsIHgtMSwgeS0xKTtcclxuICAgICAgICAgICAgICAgICAgICBnZXRUZXhlbDJEVG8oaTEwLCBpbWFnZSwgeCwgeS0xKTtcclxuICAgICAgICAgICAgICAgICAgICBnZXRUZXhlbDJEVG8oaTIwLCBpbWFnZSwgeCsxLCB5LTEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGdldFRleGVsMkRUbyhpMDEsIGltYWdlLCB4LTEsIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGdldFRleGVsMkRUbyhpMTEsIGltYWdlLCB4LCB5KTtcclxuICAgICAgICAgICAgICAgICAgICBnZXRUZXhlbDJEVG8oaTIxLCBpbWFnZSwgeCsxLCB5KTtcclxuICAgICAgICAgICAgICAgICAgICBnZXRUZXhlbDJEVG8oaTAyLCBpbWFnZSwgeC0xLCB5KzEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGdldFRleGVsMkRUbyhpMTIsIGltYWdlLCB4LCB5KzEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGdldFRleGVsMkRUbyhpMjIsIGltYWdlLCB4KzEsIHkrMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGd4WzBdID0gaTAwWzBdICsgMiAqIGkxMFswXSArIGkyMFswXSAtIGkwMlswXSAgLSAyICogaTEyWzBdIC0gaTIyWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGd4WzFdID0gaTAwWzFdICsgMiAqIGkxMFsxXSArIGkyMFsxXSAtIGkwMlsxXSAgLSAyICogaTEyWzFdIC0gaTIyWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGd4WzJdID0gaTAwWzJdICsgMiAqIGkxMFsyXSArIGkyMFsyXSAtIGkwMlsyXSAgLSAyICogaTEyWzJdIC0gaTIyWzJdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBneVswXSA9IGkwMFswXSAtIGkyMFswXSAgKyAyKmkwMVswXSAtIDIqaTIxWzBdICsgaTAyWzBdICAtICBpMjJbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgZ3lbMV0gPSBpMDBbMV0gLSBpMjBbMV0gICsgMippMDFbMV0gLSAyKmkyMVsxXSArIGkwMlsxXSAgLSAgaTIyWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGd5WzJdID0gaTAwWzJdIC0gaTIwWzJdICArIDIqaTAxWzJdIC0gMippMjFbMl0gKyBpMDJbMl0gIC0gIGkyMlsyXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyogdGFraW5nIHJvb3Qgb2Ygc3VtcyBvZiBzcXVhcmVzIG9mIEd4IGFuZCBHeSAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGh5cG90NFRvKGNvbG9yLCBneCwgZ3kpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yWzBdLz0yO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yWzFdLz0yO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yWzJdLz0yO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yWzNdPTEuMDtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUZXhlbDJEKHJlc3VsdCwgeCwgeSwgY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG4vLyBTb2JlbCBmaWx0ZXIgd2l0aCBzZXBhcmF0ZSBzdGVwc1xyXG4vL1xyXG4vLyAgICAgICAgdmFyIHZlcnRpY2FsID0gWGZsb3cuRmlsdGVycy5jcmVhdGVJbWFnZURhdGFGbG9hdDMyKHdpZHRoLCBoZWlnaHQpO1xyXG4vLyAgICAgICAgWGZsb3cuRmlsdGVycy5jb252b2x1dGUocmVzdWx0LCB2ZXJ0aWNhbCxcclxuLy8gICAgICAgICAgICBbIC0xLCAwLCAxLFxyXG4vLyAgICAgICAgICAgICAgLTIsIDAsIDIsXHJcbi8vICAgICAgICAgICAgICAtMSwgMCwgMSBdKTtcclxuLy8gICAgICAgIHZhciBob3Jpem9udGFsID0gWGZsb3cuRmlsdGVycy5jcmVhdGVJbWFnZURhdGFGbG9hdDMyKHdpZHRoLCBoZWlnaHQpO1xyXG4vLyAgICAgICAgWGZsb3cuRmlsdGVycy5jb252b2x1dGUocmVzdWx0LCBob3Jpem9udGFsLFxyXG4vLyAgICAgICAgICAgIFsgLTEsIC0yLCAtMSxcclxuLy8gICAgICAgICAgICAgICAwLCAgMCwgIDAsXHJcbi8vICAgICAgICAgICAgICAgMSwgIDIsICAxIF0pO1xyXG4vL1xyXG4vLyAgICAgICAgZm9yICh2YXIgaT0wOyBpPHJlc3VsdC5kYXRhLmxlbmd0aDsgaSs9NCkge1xyXG4vLyAgICAgICAgICAgIC8vIG1ha2UgdGhlIHZlcnRpY2FsIGdyYWRpZW50IHJlZFxyXG4vLyAgICAgICAgICAgIHZhciB2ID0gTWF0aC5hYnModmVydGljYWwuZGF0YVtpXSk7XHJcbi8vICAgICAgICAgICAgcmVzdWx0LmRhdGFbaV0gPSB2O1xyXG4vLyAgICAgICAgICAgIC8vIG1ha2UgdGhlIGhvcml6b250YWwgZ3JhZGllbnQgZ3JlZW5cclxuLy8gICAgICAgICAgICB2YXIgaCA9IE1hdGguYWJzKGhvcml6b250YWwuZGF0YVtpXSk7XHJcbi8vICAgICAgICAgICAgcmVzdWx0LmRhdGFbaSsxXSA9IGg7XHJcbi8vICAgICAgICAgICAgLy8gYW5kIG1peCBpbiBzb21lIGJsdWUgZm9yIGFlc3RoZXRpY3NcclxuLy8gICAgICAgICAgICByZXN1bHQuZGF0YVtpKzJdID0gKHYraCkvNDtcclxuLy8gICAgICAgICAgICByZXN1bHQuZGF0YVtpKzNdID0gMjU1OyAvLyBvcGFxdWUgYWxwaGFcclxuLy8gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogQ29weSBpbWFnZVxyXG4gICAgICAgIHZhciBkZXN0cGl4ID0gcmVzdWx0LmRhdGE7XHJcbiAgICAgICAgdmFyIHNyY3BpeCA9IGltYWdlLmRhdGE7XHJcblxyXG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyArK3kpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyArK3gpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAoeSAqIHdpZHRoICsgeCkgKiA0O1xyXG4gICAgICAgICAgICAgICAgZGVzdHBpeFtvZmZzZXRdID0gIHNyY3BpeFtvZmZzZXRdO1xyXG4gICAgICAgICAgICAgICAgZGVzdHBpeFtvZmZzZXQrMV0gPSBzcmNwaXhbb2Zmc2V0KzFdO1xyXG4gICAgICAgICAgICAgICAgZGVzdHBpeFtvZmZzZXQrMl0gPSBzcmNwaXhbb2Zmc2V0KzJdO1xyXG4gICAgICAgICAgICAgICAgZGVzdHBpeFtvZmZzZXQrM10gPSBzcmNwaXhbb2Zmc2V0KzNdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgICovXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJcclxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LnN1YlwiLCB7XHJcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0MycsIG5hbWU6ICdyZXN1bHQnfV0sXHJcbiAgICBwYXJhbXM6ICBbICB7dHlwZTogJ2Zsb2F0MycsIHNvdXJjZTogJ3ZhbHVlMSd9LFxyXG4gICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICd2YWx1ZTInfV0sXHJcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZTEsIHZhbHVlMiwgaW5mbykge1xyXG4gICAgICAgIHRocm93IFwiTm90IHVzZWQhXCI7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGk8IGluZm8uaXRlcmF0ZUNvdW50KjM7IGkrKylcclxuICAgICAgICAgICAgcmVzdWx0W2ldID0gdmFsdWUxW2ldIC0gdmFsdWUyW2ldO1xyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgZXZhbHVhdGVfY29yZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZTEsIHZhbHVlMil7XHJcbiAgICAgICAgcmVzdWx0WzBdID0gdmFsdWUxWzBdIC0gdmFsdWUyWzBdO1xyXG4gICAgICAgIHJlc3VsdFsxXSA9IHZhbHVlMVsxXSAtIHZhbHVlMlsxXTtcclxuICAgICAgICByZXN1bHRbMl0gPSB2YWx1ZTFbMl0gLSB2YWx1ZTJbMl07XHJcbiAgICB9XHJcbn0pO1xyXG4iLCIvKipcclxuICogT25lIG9wZXJhdG9yIGV4ZWN1dGlvbiB3aXRoaW4gdGhlIEBzZWV7T3BlcmF0b3JMaXN0fS5cclxuICogQHBhcmFtIG9wZXJhdG9yXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIE9wZXJhdG9yRW50cnkgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcclxuICAgIC8qKlxyXG4gICAgICogUG9zaXRpb24gaW4gT3BlcmF0b3JMaXN0XHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmluZGV4ID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wZXJhdG9yIG9iamVjdFxyXG4gICAgICogQHR5cGUge3t9fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBvcGVyYXRvckluZGV4OiBQb3NpdGlvbiBvZiB0aGUgaW5wdXQncyBvcGVyYXRvciBpbiB0aGUgT3BlcmF0b3JMaXN0IGlmIHRoZSBpbnB1dCBjb21lcyBmcm9tXHJcbiAgICAgKiBwcmV2aW91c2x5IGV4ZWN1dGVkIG9wZXJhdG9yIG90aGVyd2lzZSB1bmRlZmluZWRcclxuICAgICAqIG91dHB1dEluZGV4OiBSZWZlcmVuY2VzIHRoZSBvdXRwdXRzIG9mIHRoZSBvcGVyYXRvciBvYmplY3QgZGVmaW5lZCBieSB0aGUgb3BlcmF0b3JJbmRleFxyXG4gICAgICogbWFwcGVkTmFtZTogT3JpZ2luYWwgbmFtZSBhcyBkZWZpbmVkIGluIG9wZXJhdG9yIGludm9jYXRpb24gaW4gRGF0YU5vZGUgKGN1cnJlbnRseSBub3QgdXNlZClcclxuICAgICAqIGlucHV0SW5kZXg6IE9ubHkgc2V0IGlmIHRoaXMgaXMgZGlyZWN0IGlucHV0IGFuZCByZWZlcmVuY2VzIGludG8gdGhlIGlucHV0cyBkZWZpbmVkIGluIEBzZWV7UHJvZ3JhbURhdGF9XHJcbiAgICAgKiBAdHlwZSB7QXJyYXkuPHtvcGVyYXRvckluZGV4OiBudW1iZXI/LCBvdXRwdXRJbmRleDogbnVtYmVyPywgbWFwcGVkTmFtZTogc3RyaW5nPywgaW5wdXRJbmRleDogbnVtYmVyP30+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmlucHV0SW5mbyA9IFtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBmaW5hbE91dDoge251bWJlcn0gSXMgc2V0LCBpZiB0aGlzIG91dHB1dCBhIGZpbmFsIG91dHB1dCAoZS5nLiBhIHZhcnlpbmcgaW4gYSB2ZXJ0ZXggc2hhZGVyKS4gUmVmZXJlbmNlcyB0aGUgb3V0cHV0cyBvZiB0aGUgUHJvZ3JhbURhdGEuXHJcbiAgICAgKiB0cmFuc2Zlcjoge2Jvb2xlYW59IElzIHRydWUgaWYgdGhpcyBpcyBhIHRyYW5zZmVyIG91dHB1dCBpLmUuIHRoaXMgb3V0cHV0IGlzIHVzZWQgYXMgaW5wdXQgYnkgYW5vdGhlciBvcGVyYXRvcixcclxuICAgICAqIGxvc3Q6IERhdGEgdGhhdCBpcyBsb3N0LCBpLmUuIG5vdCB1c2VkIGluIG5leHQgZXhlY3V0b3IuIFJlZmVyZW5jZSB0byBQcm9ncmFtRGF0YSdzIG91dHB1dHNcclxuICAgICAqIEB0eXBlIHtBcnJheS48e2ZpbmFsT3V0OiBudW1iZXI/LCB0cmFuc2ZlcjogYm9vbGVhbj8sIGxvc3Q6IG51bWJlcj99Pn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vdXRwdXRJbmZvID0gW107XHJcbn07XHJcblxyXG4vKipcclxuICogSXMgdGhlIGlucHV0IHRoZSByZXN1bHQgb2YgYSBwcmV2aW91c2x5IGV4ZWN1dGVkIG9wZXJhdG9yXHJcbiAqIEBwYXJhbSBtYXBwaW5nSW5kZXggSW5wdXQgaW5kZXggb2YgdGhlIG9wZXJhdG9yIChjYW4gYmUgbWFwcGVkIHVzaW5nIGEgbWFwcGluZyBkZWNsYXJhdGlvbilcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5PcGVyYXRvckVudHJ5LnByb3RvdHlwZS5pc1RyYW5zZmVySW5wdXQgPSBmdW5jdGlvbiAobWFwcGluZ0luZGV4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5pbnB1dEluZm9bbWFwcGluZ0luZGV4XS5vcGVyYXRvckluZGV4ICE9PSB1bmRlZmluZWQ7XHJcbn07XHJcblxyXG5PcGVyYXRvckVudHJ5LnByb3RvdHlwZS5nZXRUcmFuc2ZlcklucHV0T3BlcmF0b3JJbmRleCA9IGZ1bmN0aW9uIChtYXBwaW5nSW5kZXgpIHtcclxuICAgIHJldHVybiB0aGlzLmlucHV0SW5mb1ttYXBwaW5nSW5kZXhdLm9wZXJhdG9ySW5kZXg7XHJcbn07XHJcbk9wZXJhdG9yRW50cnkucHJvdG90eXBlLmdldFRyYW5zZmVySW5wdXRPdXRwdXRJbmRleCA9IGZ1bmN0aW9uIChtYXBwaW5nSW5kZXgpIHtcclxuICAgIHJldHVybiB0aGlzLmlucHV0SW5mb1ttYXBwaW5nSW5kZXhdLm91dHB1dEluZGV4O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIHVuaXF1ZSBuYW1lIGZvciBhIHNwZWNpZmllZCB0cmFuc2ZlciBpbnB1dFxyXG4gKiBAcGFyYW0gbWFwcGluZ0lkeFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuT3BlcmF0b3JFbnRyeS5wcm90b3R5cGUuZ2V0VHJhbnNmZXJJbnB1dElkID0gZnVuY3Rpb24gKG1hcHBpbmdJZHgpIHtcclxuICAgIHZhciBpbmZvID0gdGhpcy5pbnB1dEluZm9bbWFwcGluZ0lkeF07XHJcbiAgICByZXR1cm4gaW5mby5vcGVyYXRvckluZGV4ICsgXCJfXCIgKyBpbmZvLm91dHB1dEluZGV4O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIHVuaXF1ZSBuYW1lIGZvciB0cmFuc2ZlciBvdXRwdXRcclxuICogQHBhcmFtIG91dHB1dEluZGV4XHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5PcGVyYXRvckVudHJ5LnByb3RvdHlwZS5nZXRUcmFuc2Zlck91dHB1dElkID0gZnVuY3Rpb24gKG91dHB1dEluZGV4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5pbmRleCArIFwiX1wiICsgb3V0cHV0SW5kZXg7XHJcbn07XHJcblxyXG4vKipcclxuICogVE9ETzogcmVtb3ZlIG9yIGludGVncmF0ZSBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXHJcbiAqIEB1bnVzZWRcclxuICogQHBhcmFtIG1hcHBpbmdJZHhcclxuICogQHJldHVybnMge3N0cmluZ3wqfVxyXG4gKi9cclxuT3BlcmF0b3JFbnRyeS5wcm90b3R5cGUuZ2V0SW5wdXRNYXBwaW5nTmFtZSA9IGZ1bmN0aW9uIChtYXBwaW5nSWR4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5pbnB1dEluZm9bbWFwcGluZ0lkeF0ubWFwcGVkTmFtZTtcclxufTtcclxuT3BlcmF0b3JFbnRyeS5wcm90b3R5cGUuZ2V0RGlyZWN0SW5wdXRJbmRleCA9IGZ1bmN0aW9uIChtYXBwaW5nSWR4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5pbnB1dEluZm9bbWFwcGluZ0lkeF0uaW5wdXRJbmRleDtcclxufTtcclxuXHJcbk9wZXJhdG9yRW50cnkucHJvdG90eXBlLmdldE91dHB1dEluZGV4ID0gZnVuY3Rpb24gKG9wZXJhdG9yT3V0cHV0SWR4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRJbmZvW29wZXJhdG9yT3V0cHV0SWR4XS5maW5hbE91dCB8fCB0aGlzLm91dHB1dEluZm9bb3BlcmF0b3JPdXRwdXRJZHhdLmxvc3QgfHwgMDtcclxufTtcclxuXHJcblxyXG5PcGVyYXRvckVudHJ5LnByb3RvdHlwZS5pc0ZpbmFsT3V0cHV0ID0gZnVuY3Rpb24gKG91dHB1dEluZGV4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRJbmZvW291dHB1dEluZGV4XSAmJiB0aGlzLm91dHB1dEluZm9bb3V0cHV0SW5kZXhdLmZpbmFsT3V0ICE9PSB1bmRlZmluZWQ7XHJcbn07XHJcbk9wZXJhdG9yRW50cnkucHJvdG90eXBlLmlzVHJhbnNmZXJPdXRwdXQgPSBmdW5jdGlvbiAob3V0cHV0SW5kZXgpIHtcclxuICAgIHJldHVybiB0aGlzLm91dHB1dEluZm9bb3V0cHV0SW5kZXhdICYmIHRoaXMub3V0cHV0SW5mb1tvdXRwdXRJbmRleF0udHJhbnNmZXI7XHJcbn07XHJcbk9wZXJhdG9yRW50cnkucHJvdG90eXBlLmlzTG9zdE91dHB1dCA9IGZ1bmN0aW9uIChvdXRwdXRJbmRleCkge1xyXG4gICAgcmV0dXJuIHRoaXMub3V0cHV0SW5mb1tvdXRwdXRJbmRleF0gJiYgdGhpcy5vdXRwdXRJbmZvW291dHB1dEluZGV4XS5sb3N0ICE9PSB1bmRlZmluZWQ7XHJcbn07XHJcblxyXG5cclxuT3BlcmF0b3JFbnRyeS5wcm90b3R5cGUuc2V0VHJhbnNmZXJJbnB1dCA9IGZ1bmN0aW9uIChtYXBwaW5nSW5kZXgsIG9wZXJhdG9ySW5kZXgsIG91dHB1dEluZGV4KSB7XHJcbiAgICB0aGlzLmlucHV0SW5mb1ttYXBwaW5nSW5kZXhdID0ge29wZXJhdG9ySW5kZXg6IG9wZXJhdG9ySW5kZXgsIG91dHB1dEluZGV4OiBvdXRwdXRJbmRleH07XHJcbn07XHJcblxyXG5PcGVyYXRvckVudHJ5LnByb3RvdHlwZS5zZXREaXJlY3RJbnB1dCA9IGZ1bmN0aW9uIChtYXBwaW5nSW5kZXgsIGlucHV0SW5kZXgsIG1hcHBlZE5hbWUpIHtcclxuICAgIHRoaXMuaW5wdXRJbmZvW21hcHBpbmdJbmRleF0gPSB7aW5wdXRJbmRleDogaW5wdXRJbmRleCwgbWFwcGVkTmFtZTogbWFwcGVkTmFtZX07XHJcbn07XHJcblxyXG5PcGVyYXRvckVudHJ5LnByb3RvdHlwZS5zZXRGaW5hbE91dHB1dCA9IGZ1bmN0aW9uIChvcGVyYXRvck91dHB1dEluZGV4LCBnbG9iYWxPdXRwdXRJbmRleCkge1xyXG4gICAgdGhpcy5vdXRwdXRJbmZvW29wZXJhdG9yT3V0cHV0SW5kZXhdID0ge2ZpbmFsT3V0OiBnbG9iYWxPdXRwdXRJbmRleH07XHJcbn07XHJcbk9wZXJhdG9yRW50cnkucHJvdG90eXBlLnNldFRyYW5zZmVyT3V0cHV0ID0gZnVuY3Rpb24gKG9wZXJhdG9yT3V0cHV0SW5kZXgpIHtcclxuICAgIHRoaXMub3V0cHV0SW5mb1tvcGVyYXRvck91dHB1dEluZGV4XSA9IHt0cmFuc2ZlcjogdHJ1ZX07XHJcbn07XHJcbk9wZXJhdG9yRW50cnkucHJvdG90eXBlLnNldExvc3RPdXRwdXQgPSBmdW5jdGlvbiAob3BlcmF0b3JPdXRwdXRJbmRleCwgZ2xvYmFsT3V0cHV0SW5kZXgpIHtcclxuICAgIHRoaXMub3V0cHV0SW5mb1tvcGVyYXRvck91dHB1dEluZGV4XSA9IHtsb3N0OiBnbG9iYWxPdXRwdXRJbmRleH07XHJcbn07XHJcblxyXG4vKipcclxuICogR2VuZXJhdGUgaGFzaC1hYmxlIGtleSBmb3IgdGhlIGVudHJ5XHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5PcGVyYXRvckVudHJ5LnByb3RvdHlwZS5nZXRLZXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIga2V5ID0gdGhpcy5vcGVyYXRvci5uYW1lICsgXCIqT1wiO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm91dHB1dEluZm8ubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICB2YXIgaW5mbyA9IHRoaXMub3V0cHV0SW5mb1tpXTtcclxuICAgICAgICBrZXkgKz0gXCIqXCIgKyAoIGluZm8udHJhbnNmZXIgPyBcIl9cIiA6IGluZm8uZmluYWxPdXQgfHwgKGluZm8ubG9zdCArIFwiP1wiKSk7XHJcbiAgICB9XHJcbiAgICBrZXkgKz0gK1wiKklcIjtcclxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmlucHV0SW5mby5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGluZm8gPSB0aGlzLmlucHV0SW5mb1tpXTtcclxuICAgICAgICBrZXkgKz0gXCIqXCIgKyAoaW5mby5pbnB1dEluZGV4ID8gaW5mby5pbnB1dEluZm8gOiBpbmZvLm9wZXJhdG9ySW5kZXggKyBcIj5cIiArIGluZm8ub3V0cHV0SW5kZXgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGtleTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT3BlcmF0b3JFbnRyeTtcclxuIiwidmFyIEMgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIEJhc2UgPSByZXF1aXJlKFwiLi4vYmFzZS5qc1wiKTtcclxuXHJcblxyXG4vKipcclxuICogTGlzdCBvZiBwbGF0Zm9ybS1zcGVjaWZpYyBvcGVyYXRvcnMsIG9yZGVyZWQgYnkgZXhlY3V0aW9uIChsYXN0IGVudHJ5IGlzIGxhc3Qgb3BlcmF0b3JcclxuICogZXhlY3V0ZWQpLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0MuUExBVEZPUk19IHBsYXRmb3JtXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIE9wZXJhdG9yTGlzdCA9IGZ1bmN0aW9uIChwbGF0Zm9ybSkge1xyXG4gICAgdGhpcy5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7QXJyYXkuPE9wZXJhdG9yRW50cnk+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmVudHJpZXMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcCBmcm9tIHBvc2l0aW9uIG9mIGlucHV0IHBhcmFtZXRlciB0byBzaXplIGFuZCBpdGVyYXRvciB0eXBlIG9mIHBhcmFtZXRlcnMuXHJcbiAgICAgKiBTaXplIGlzIG9ubHkgc3BlY2lmaWVkIGZvciB1bmlmb3JtIGFycmF5IGlucHV0LCByZXF1aXJlZCBmb3IgcHJvZ3JhbXMgdGhhdFxyXG4gICAgICogaGF2ZSB0aGUgYXJyYXkgc2l6ZSBzcGVjaWZpZWQuXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIse3NpemU6IG51bWJlciwgaXRlcmF0ZTogQy5JVEVSQVRJT05fVFlQRX0+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmlucHV0SW5mbyA9IHt9O1xyXG59O1xyXG5cclxuT3BlcmF0b3JMaXN0LnByb3RvdHlwZS5hZGRFbnRyeSA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgZW50cnkuaW5kZXggPSB0aGlzLmVudHJpZXMubGVuZ3RoO1xyXG4gICAgdGhpcy5lbnRyaWVzLnB1c2goZW50cnkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEhhc2hhYmxlIGtleSBmb3Igd2hvbGUgbGlzdFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuT3BlcmF0b3JMaXN0LnByb3RvdHlwZS5nZXRLZXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBrZXlzLnB1c2godGhpcy5lbnRyaWVzW2ldLmdldEtleSgpKTtcclxuICAgIH1cclxuICAgIHZhciByZXN1bHQgPSB0aGlzLnBsYXRmb3JtICsgXCI+XCIgKyBrZXlzLmpvaW4oXCIhXCIpICsgXCJ8XCI7XHJcbiAgICBmb3IgKHZhciBpIGluIHRoaXMuaW5wdXRJbmZvKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IGkgKyBcIj5cIiArICh0aGlzLmlucHV0SW5mb1tpXS5pdGVyYXRlIHx8IDApICsgXCJ4XCIgKyAodGhpcy5pbnB1dEluZm9baV0uc2l6ZSB8fCAwKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5PcGVyYXRvckxpc3QucHJvdG90eXBlLnNldElucHV0SXRlcmF0ZVR5cGUgPSBmdW5jdGlvbiAoaW5wdXRJbmRleCwgdHlwZSkge1xyXG4gICAgaWYgKCF0aGlzLmlucHV0SW5mb1tpbnB1dEluZGV4XSkgdGhpcy5pbnB1dEluZm9baW5wdXRJbmRleF0gPSB7fTtcclxuICAgIHRoaXMuaW5wdXRJbmZvW2lucHV0SW5kZXhdLml0ZXJhdGUgPSB0eXBlO1xyXG59O1xyXG5PcGVyYXRvckxpc3QucHJvdG90eXBlLnNldElucHV0U2l6ZSA9IGZ1bmN0aW9uIChpbnB1dEluZGV4LCBzaXplKSB7XHJcbiAgICBpZiAoIXRoaXMuaW5wdXRJbmZvW2lucHV0SW5kZXhdKSB0aGlzLmlucHV0SW5mb1tpbnB1dEluZGV4XSA9IHt9O1xyXG4gICAgdGhpcy5pbnB1dEluZm9baW5wdXRJbmRleF0uc2l6ZSA9IHNpemU7XHJcbn07XHJcblxyXG5cclxuT3BlcmF0b3JMaXN0LnByb3RvdHlwZS5pc0lucHV0SXRlcmF0ZSA9IGZ1bmN0aW9uIChpbnB1dEluZGV4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5pbnB1dEluZm9baW5wdXRJbmRleF0gJiYgdGhpcy5pbnB1dEluZm9baW5wdXRJbmRleF0uaXRlcmF0ZSA9PSBDLklURVJBVElPTl9UWVBFLk1BTlk7XHJcbn07XHJcbk9wZXJhdG9yTGlzdC5wcm90b3R5cGUuaXNJbnB1dFVuaWZvcm0gPSBmdW5jdGlvbiAoaW5wdXRJbmRleCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaW5wdXRJbmZvW2lucHV0SW5kZXhdICYmIHRoaXMuaW5wdXRJbmZvW2lucHV0SW5kZXhdLml0ZXJhdGUgPT0gQy5JVEVSQVRJT05fVFlQRS5PTkU7XHJcbn07XHJcbk9wZXJhdG9yTGlzdC5wcm90b3R5cGUuaXNJbnB1dE51bGwgPSBmdW5jdGlvbiAoaW5wdXRJbmRleCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaW5wdXRJbmZvW2lucHV0SW5kZXhdICYmIHRoaXMuaW5wdXRJbmZvW2lucHV0SW5kZXhdLml0ZXJhdGUgPT0gQy5JVEVSQVRJT05fVFlQRS5OVUxMO1xyXG59O1xyXG5PcGVyYXRvckxpc3QucHJvdG90eXBlLmdldElucHV0SXRlcmF0ZVR5cGUgPSBmdW5jdGlvbiAoaW5wdXRJbmRleCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaW5wdXRJbmZvW2lucHV0SW5kZXhdICYmIHRoaXMuaW5wdXRJbmZvW2lucHV0SW5kZXhdLml0ZXJhdGU7XHJcbn07XHJcblxyXG5PcGVyYXRvckxpc3QucHJvdG90eXBlLmdldElucHV0U2l6ZSA9IGZ1bmN0aW9uIChpbnB1dEluZGV4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5pbnB1dEluZm9baW5wdXRJbmRleF0gJiYgdGhpcy5pbnB1dEluZm9baW5wdXRJbmRleF0uc2l6ZSB8fCAwO1xyXG59O1xyXG5cclxuT3BlcmF0b3JMaXN0LnByb3RvdHlwZS5nZXRJdGVyYXRlQ291bnQgPSBmdW5jdGlvbiAocHJvZ3JhbURhdGEpIHtcclxuICAgIHZhciBjb3VudCA9IC0xO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9ncmFtRGF0YS5pbnB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0lucHV0SXRlcmF0ZShpKSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YUVudHJ5ID0gcHJvZ3JhbURhdGEuZ2V0RGF0YUVudHJ5KGkpO1xyXG4gICAgICAgICAgICBpZiAoZGF0YUVudHJ5ICYmIGRhdGFFbnRyeS5nZXRJdGVyYXRlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzaXplID0gZGF0YUVudHJ5LmdldEl0ZXJhdGVDb3VudCgpO1xyXG4gICAgICAgICAgICAgICAgY291bnQgPSBjb3VudCA8IDAgPyBzaXplIDogTWF0aC5taW4oc2l6ZSwgY291bnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvdW50IDwgMCA/IDEgOiBjb3VudDtcclxufTtcclxuXHJcbnZhciBjX3NpemVzID0ge307XHJcblxyXG5PcGVyYXRvckxpc3QucHJvdG90eXBlLmFsbG9jYXRlT3V0cHV0ID0gZnVuY3Rpb24gKHByb2dyYW1EYXRhLCBhc3luYykge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmVudHJpZXNbaV07XHJcbiAgICAgICAgdmFyIG9wZXJhdG9yID0gZW50cnkub3BlcmF0b3I7XHJcbiAgICAgICAgdmFyIG9wZXJhdG9yRGF0YSA9IHByb2dyYW1EYXRhLm9wZXJhdG9yRGF0YVtpXTtcclxuICAgICAgICB2YXIgaXRlcmF0ZUNvdW50ID0gdGhpcy5nZXRJdGVyYXRlQ291bnQocHJvZ3JhbURhdGEpO1xyXG4gICAgICAgIGlmIChvcGVyYXRvci5hbGxvYykge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtjX3NpemVzXTtcclxuICAgICAgICAgICAgYWRkSW5wdXRUb0FyZ3MoYXJncywgZW50cnksIHByb2dyYW1EYXRhKTtcclxuICAgICAgICAgICAgYXJncy5wdXNoKGl0ZXJhdGVDb3VudCk7XHJcbiAgICAgICAgICAgIG9wZXJhdG9yLmFsbG9jLmFwcGx5KG9wZXJhdG9yRGF0YSwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3BlcmF0b3Iub3V0cHV0cy5sZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgICB2YXIgZCA9IG9wZXJhdG9yLm91dHB1dHNbal07XHJcbiAgICAgICAgICAgIHZhciBkYXRhU2xvdCA9IHByb2dyYW1EYXRhLm91dHB1dHNbZW50cnkuZ2V0T3V0cHV0SW5kZXgoaildLCBkYXRhRW50cnk7XHJcbiAgICAgICAgICAgIGRhdGFFbnRyeSA9IGFzeW5jID8gZGF0YVNsb3QuYXN5bmNEYXRhRW50cnkgOiBkYXRhU2xvdC5kYXRhRW50cnk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZC5ub0FsbG9jKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YUVudHJ5LnR5cGUgPT0gQy5EQVRBX1RZUEUuVEVYVFVSRSkge1xyXG4gICAgICAgICAgICAgICAgLy8gdGV4dHVyZSBlbnRyeVxyXG4gICAgICAgICAgICAgICAgaWYgKGQuY3VzdG9tQWxsb2MpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4UGFyYW1zID0gY19zaXplc1tkLm5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdXaWR0aCA9IHRleFBhcmFtcy5pbWFnZUZvcm1hdC53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gdGV4UGFyYW1zLmltYWdlRm9ybWF0LmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VHlwZSA9IHRleFBhcmFtcy5pbWFnZUZvcm1hdC50ZXhlbFR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0Zvcm1hdCA9IHRleFBhcmFtcy5pbWFnZUZvcm1hdC50ZXhlbEZvcm1hdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U2FtcGxlckNvbmZpZyA9IHRleFBhcmFtcy5zYW1wbGVyQ29uZmlnO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFFbnRyeS5fY3JlYXRlSW1hZ2UobmV3V2lkdGgsIG5ld0hlaWdodCwgbmV3Rm9ybWF0LCBuZXdUeXBlLCBuZXdTYW1wbGVyQ29uZmlnKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZC5zaXplb2YpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3JjRW50cnkgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3BlcmF0b3IubWFwcGluZy5sZW5ndGg7ICsraykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0b3IubWFwcGluZ1trXS5zb3VyY2UgPT0gZC5zaXplb2YpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY0VudHJ5ID0gcHJvZ3JhbURhdGEuZ2V0RGF0YUVudHJ5KGVudHJ5LmdldERpcmVjdElucHV0SW5kZXgoaykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyY0VudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdXaWR0aCA9IE1hdGgubWF4KHNyY0VudHJ5LndpZHRoLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0hlaWdodCA9IE1hdGgubWF4KHNyY0VudHJ5LmhlaWdodCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdGb3JtYXQgPSBkLnRleGVsRm9ybWF0IHx8IHNyY0VudHJ5LnRleGVsRm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VHlwZSA9IGQudGV4ZWxUeXBlIHx8IHNyY0VudHJ5LnRleGVsVHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1NhbXBsZXJDb25maWcgPSBkLnNhbXBsZXJDb25maWcgfHwgc3JjRW50cnkuZ2V0U2FtcGxlckNvbmZpZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhRW50cnkuX2NyZWF0ZUltYWdlKG5ld1dpZHRoLCBuZXdIZWlnaHQsIG5ld0Zvcm1hdCwgbmV3VHlwZSwgbmV3U2FtcGxlckNvbmZpZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdGV4dHVyZSBpbnB1dCBwYXJhbWV0ZXIgJ1wiICsgZC5zaXplb2YgKyBcIicgaW4gb3BlcmF0b3IgJ1wiICsgb3BlcmF0b3IubmFtZSArIFwiJ1wiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjcmVhdGUgdGV4dHVyZS4gVXNlIGN1c3RvbUFsbG9jIG9yIHNpemVvZiBwYXJhbWV0ZXIgYXR0cmlidXRlXCIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBzaXplID0gKGQuY3VzdG9tQWxsb2MgPyBjX3NpemVzW2QubmFtZV0gOiBpdGVyYXRlQ291bnQpICogZGF0YUVudHJ5LmdldFR1cGxlU2l6ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghZGF0YUVudHJ5Ll92YWx1ZSB8fCBkYXRhRW50cnkuX3ZhbHVlLmxlbmd0aCAhPSBzaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChkYXRhRW50cnkudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5GTE9BVDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuRkxPQVQ0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUNFg0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUVudHJ5Ll9zZXRWYWx1ZShuZXcgRmxvYXQzMkFycmF5KHNpemUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLklOVDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5JTlQ0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkJPT0w6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhRW50cnkuX3NldFZhbHVlKG5ldyBJbnQzMkFycmF5KHNpemUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLlNUUklORzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFFbnRyeS5fc2V0VmFsdWUobmV3IEFycmF5KHNpemUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIkNvdWxkIG5vdCBhbGxvY2F0ZSBvdXRwdXQgYnVmZmVyIG9mIFRZUEU6IFwiICsgZGF0YUVudHJ5LnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YUVudHJ5Ll9ub3RpZnlDaGFuZ2VkKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4gICAgLy8gVE9ETzogVGhpcyBmdW5jdGlvbiBhcHBlYXJzIGluIG11bHRpcGxlIHVuaXRzXHJcbiAgICBmdW5jdGlvbiBhZGRJbnB1dFRvQXJncyhhcmdzLCBlbnRyeSwgcHJvZ3JhbURhdGEpe1xyXG4gICAgICAgIHZhciBtYXBwaW5nID0gZW50cnkub3BlcmF0b3IubWFwcGluZztcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbWFwcGluZy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBkYXRhRW50cnkgPSBwcm9ncmFtRGF0YS5nZXREYXRhRW50cnkoZW50cnkuZ2V0RGlyZWN0SW5wdXRJbmRleChpKSk7XHJcbiAgICAgICAgICAgIGFyZ3MucHVzaChkYXRhRW50cnkgPyBkYXRhRW50cnkuZ2V0VmFsdWUoKSA6IG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9wZXJhdG9yTGlzdDtcclxuIiwidmFyIEJhc2UgPSByZXF1aXJlKFwiLi4vYmFzZS5qc1wiKTtcclxudmFyIEMgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyByZWdpc3Rlck9wZXJhdG9yICYmIGdldE9wZXJhdG9yXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxudmFyIG9wZXJhdG9ycyA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIFhmbG93IG9wZXJhdG9yLlxyXG4gICAgICogVGhlIG9wZXJhdG9ycyBhcmUgc3RvcmVkIGluIGNvbGxlY3Rpb25zIHVzaW5nIHRoZWlyIHBsYXRmb3JtIGFzIGEga2V5LiBJZiBubyBwbGF0Zm9ybSBpcyBkZWZpbmVkLCB0aGUgb3BlcmF0b3JcclxuICAgICAqIHdpbGwgYmUgcmVnaXN0ZXJlZCBhcyBhIEphdmFTY3JpcHQtYmFzZWQgb3BlcmF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5hbWVcclxuICAgICAqIEBwYXJhbSBkYXRhXHJcbiAgICAgKi9cclxuXHJcbnZhciByZWdpc3Rlck9wZXJhdG9yID0gZnVuY3Rpb24obmFtZSwgZGF0YSl7XHJcbiAgICB2YXIgb3BDb2xsZWN0aW9uLCBwbGF0Zm9ybTtcclxuXHJcbiAgICBpbml0T3BlcmF0b3IoZGF0YSwgbmFtZSk7XHJcbiAgICBpZighb3BlcmF0b3JzW25hbWVdKSB7XHJcbiAgICAgICAgb3BlcmF0b3JzW25hbWVdID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgcGxhdGZvcm0gPSBkYXRhWydwbGF0Zm9ybSddIHx8IEMuUExBVEZPUk0uSkFWQVNDUklQVDtcclxuXHJcbiAgICBvcENvbGxlY3Rpb24gPSBvcGVyYXRvcnNbbmFtZV07XHJcblxyXG4gICAgaWYgKCFuYW1lKSB7XHJcbiAgICAgICAgWE1MM0QubG9nV2FybmluZyhcIlhmbG93LnJlZ2lzdGVyT3BlcmF0b3I6IE9wZXJhdG9yIG5hbWUgdW5kZWZpbmVkLlwiKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgICAgWE1MM0QubG9nV2FybmluZyhcIlhmbG93LnJlZ2lzdGVyT3BlcmF0b3I6IE9wZXJhdG9yIGRhdGEgdW5kZWZpbmVkLlwiKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZGF0YS5uYW1lID0gbmFtZTtcclxuICAgIGlmKCFvcENvbGxlY3Rpb25bcGxhdGZvcm1dKVxyXG4gICAgICAgIG9wQ29sbGVjdGlvbltwbGF0Zm9ybV0gPSBbXTtcclxuXHJcbiAgICBvcENvbGxlY3Rpb25bcGxhdGZvcm1dLnB1c2goZGF0YSk7XHJcbn07XHJcblxyXG52YXIgaW5pdEFub255bW91c09wZXJhdG9yID0gZnVuY3Rpb24obmFtZSwgZGF0YSl7XHJcbiAgICBpbml0T3BlcmF0b3IoZGF0YSk7XHJcbiAgICBkYXRhLm5hbWUgPSBuYW1lO1xyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn07XHJcblxyXG52YXIgaXNPcGVyYXRvckFzeW5jID0gZnVuY3Rpb24ob3BlcmF0b3Ipe1xyXG4gICAgcmV0dXJuICEhb3BlcmF0b3IuZXZhbHVhdGVfYXN5bmM7XHJcbn07XHJcblxyXG52YXIgZ2V0T3BlcmF0b3JzID0gZnVuY3Rpb24obmFtZSwgcGxhdGZvcm0pe1xyXG4gICAgcGxhdGZvcm0gPSBwbGF0Zm9ybSB8fCBDLlBMQVRGT1JNLkpBVkFTQ1JJUFQ7XHJcblxyXG4gICAgaWYgKG5hbWUgJiYgIW9wZXJhdG9yc1tuYW1lXSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKCFvcGVyYXRvcnNbbmFtZV1bcGxhdGZvcm1dIHx8IG9wZXJhdG9yc1tuYW1lXVtwbGF0Zm9ybV0ubGVuZ3RoID09IDApIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3BlcmF0b3JzW25hbWVdW3BsYXRmb3JtXTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGluaXRPcGVyYXRvcihvcGVyYXRvciwgbmFtZSl7XHJcbiAgICB2YXIgaW5kZXhNYXAgPSB7fTtcclxuICAgIC8vIEluaXQgdHlwZXMgb2Ygb3V0cHV0cyBhbmQgcGFyYW1zXHJcbiAgICBmb3IodmFyIGk9IDA7IGkgPCBvcGVyYXRvci5vdXRwdXRzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICBpZiAob3BlcmF0b3Iub3V0cHV0c1tpXS50eXBlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJYZmxvdyBvcGVyYXRvciAnXCIrbmFtZStcIicgaXMgbWlzc2luZyByZXF1aXJlZCBhdHRyaWJ1dGUgJ3R5cGUnIGZvciBvdXRwdXQgcGFyYW1ldGVyIFwiK2kpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvcGVyYXRvci5vdXRwdXRzW2ldLnR5cGUgPSBDLkRBVEFfVFlQRV9NQVBbb3BlcmF0b3Iub3V0cHV0c1tpXS50eXBlXTtcclxuICAgIH1cclxuICAgIGZvcih2YXIgaT0gMDsgaSA8IG9wZXJhdG9yLnBhcmFtcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgaWYgKG9wZXJhdG9yLnBhcmFtc1tpXS5zb3VyY2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIlhmbG93IG9wZXJhdG9yICdcIituYW1lK1wiJyBpcyBtaXNzaW5nIHJlcXVpcmVkIGF0dHJpYnV0ZSAnc291cmNlJyBmb3IgaW5wdXQgcGFyYW1ldGVyIFwiK2kpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3BlcmF0b3IucGFyYW1zW2ldLnR5cGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIlhmbG93IG9wZXJhdG9yICdcIituYW1lK1wiJyBpcyBtaXNzaW5nIHJlcXVpcmVkIGF0dHJpYnV0ZSAndHlwZScgZm9yIGlucHV0IHBhcmFtZXRlciBcIitpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3BlcmF0b3IucGFyYW1zW2ldLnR5cGUgPSBDLkRBVEFfVFlQRV9NQVBbb3BlcmF0b3IucGFyYW1zW2ldLnR5cGVdO1xyXG4gICAgICAgIGluZGV4TWFwW29wZXJhdG9yLnBhcmFtc1tpXS5zb3VyY2VdID0gaTtcclxuICAgIH1cclxuICAgIGlmKCFvcGVyYXRvci5tYXBwaW5nKVxyXG4gICAgICAgIG9wZXJhdG9yLm1hcHBpbmcgPSBvcGVyYXRvci5wYXJhbXM7XHJcblxyXG4gICAgLy8gSW5pdCBpbnRlclR5cGVzIG9mIG1hcHBpbmdcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvcGVyYXRvci5tYXBwaW5nLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB2YXIgbWFwcGluZyA9IG9wZXJhdG9yLm1hcHBpbmdbaV07XHJcbiAgICAgICAgdmFyIHBhcmFtSWR4ID0gaW5kZXhNYXBbbWFwcGluZy5zb3VyY2VdO1xyXG4gICAgICAgIG1hcHBpbmcucGFyYW1JZHggPSBwYXJhbUlkeDtcclxuICAgICAgICB2YXIgdHlwZSA9IG9wZXJhdG9yLnBhcmFtc1twYXJhbUlkeF0udHlwZTtcclxuICAgICAgICBpZihtYXBwaW5nLnNlcXVlbmNlKVxyXG4gICAgICAgICAgICBtYXBwaW5nLmtleVBhcmFtSWR4ID0gaW5kZXhNYXBbbWFwcGluZy5rZXlTb3VyY2VdO1xyXG4gICAgICAgIGlmKG1hcHBpbmcuc2VxdWVuY2UgPT0gQy5TRVFVRU5DRS5MSU5FQVJfV0VJR0hUKVxyXG4gICAgICAgICAgICB0eXBlID0gQy5EQVRBX1RZUEUuRkxPQVQ7XHJcbiAgICAgICAgbWFwcGluZy5pbnRlcm5hbFR5cGUgPSB0eXBlO1xyXG4gICAgICAgIG1hcHBpbmcubmFtZSA9IG1hcHBpbmcubmFtZSB8fCBtYXBwaW5nLnNvdXJjZTtcclxuICAgIH1cclxuXHJcbiAgICAvL0NoZWNrL2luaXQgcGxhdGZvcm1cclxuICAgIG9wZXJhdG9yLnBsYXRmb3JtID0gb3BlcmF0b3IucGxhdGZvcm0gfHwgQy5QTEFURk9STS5KQVZBU0NSSVBUO1xyXG59XHJcblxyXG4vL3dpbmRvdy5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yID0gcmVnaXN0ZXJPcGVyYXRvcjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgcmVnaXN0ZXJPcGVyYXRvcjogcmVnaXN0ZXJPcGVyYXRvcixcclxuICAgIGluaXRBbm9ueW1vdXNPcGVyYXRvcjogaW5pdEFub255bW91c09wZXJhdG9yLFxyXG4gICAgaXNPcGVyYXRvckFzeW5jOiBpc09wZXJhdG9yQXN5bmMsXHJcbiAgICBnZXRPcGVyYXRvcnM6IGdldE9wZXJhdG9yc1xyXG59O1xyXG4iLCJ2YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi9iYXNlLmpzXCIpO1xyXG52YXIgQyA9IHJlcXVpcmUoXCIuLi9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xyXG52YXIgVlNQcm9ncmFtID0gcmVxdWlyZShcIi4vdnMtcHJvZ3JhbS5qc1wiKTtcclxudmFyIENMUHJvZ3JhbSA9IHJlcXVpcmUoXCIuL2NsLXByb2dyYW0uanNcIik7XHJcblxyXG4vKipcclxuICogRGF0YSBmb3IgYSBPcGVyYXRvckxpc3QsIGdlbmVyYXRlZCBieSBhbiBFeGVjdXRvclxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBQcm9ncmFtRGF0YSA9IGZ1bmN0aW9uKCl7XHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtBcnJheS48UHJvZ3JhbUlucHV0Q29ubmVjdGlvbj59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaW5wdXRzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge0FycmF5LjxEYXRhU2xvdD59XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3V0cHV0cyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogaXRlcmF0ZUNvdW50OiBIb3cgb2Z0ZW4gd2UgaXRlcmF0ZSB3aXRoIHRoZSBkZWZhdWx0IGV4ZWN1dGlvbiBtb2RlbFxyXG4gICAgICogaXRlckZsYWc6IFBlciBpbnB1dDogdHJ1ZSBpZiB0aGUgaW5wdXQgY2FuIGJlIGl0ZXJhdGVkLCBvdGhlcndpc2UgZmFsc2VcclxuICAgICAqIGN1c3RvbURhdGE6IFBlciBpbnN0YW5jZSBkYXRhIHRoYXQgdXNlcnMgY2FuIHBlcnNpc3QgYmV0d2VlbiBvcGVyYXRvciBpbnZvY2F0aW9uc1xyXG4gICAgICogQHR5cGUge0FycmF5Ljx7aXRlcmF0ZUNvdW50OiBudW1iZXIsIGl0ZXJGbGFnOiBBcnJheSwgY3VzdG9tRGF0YToge319Pn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcGVyYXRvckRhdGEgPSBbXTtcclxufTtcclxuXHJcblByb2dyYW1EYXRhLnByb3RvdHlwZS5nZXRDaGFubmVsID0gZnVuY3Rpb24oaW5kZXgpe1xyXG4gICAgcmV0dXJuIHRoaXMuaW5wdXRzW2luZGV4XS5jaGFubmVsO1xyXG59O1xyXG5cclxuUHJvZ3JhbURhdGEucHJvdG90eXBlLmdldERhdGFFbnRyeSA9IGZ1bmN0aW9uKGluZGV4KXtcclxuICAgIHZhciBlbnRyeSA9IHRoaXMuaW5wdXRzW2luZGV4XTtcclxuICAgIHZhciBjaGFubmVsID0gZW50cnkuY2hhbm5lbDtcclxuICAgIGlmKCFjaGFubmVsKSByZXR1cm4gbnVsbDtcclxuICAgIHZhciBrZXkgPSAwO1xyXG4gICAgaWYoZW50cnkuc2VxdWVuY2VLZXlTb3VyY2VDaGFubmVsKXtcclxuICAgICAgICB2YXIga2V5RGF0YUVudHJ5ID0gZW50cnkuc2VxdWVuY2VLZXlTb3VyY2VDaGFubmVsLmdldERhdGFFbnRyeSgpO1xyXG4gICAgICAgIGtleSA9IGtleURhdGFFbnRyeSAmJiBrZXlEYXRhRW50cnkuX3ZhbHVlID8ga2V5RGF0YUVudHJ5Ll92YWx1ZVswXSA6IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNoYW5uZWwuZ2V0RGF0YUVudHJ5KGVudHJ5LnNlcXVlbmNlQWNjZXNzVHlwZSwga2V5KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBQcm9ncmFtSW5wdXRDb25uZWN0aW9uID0gZnVuY3Rpb24oKXtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge0NoYW5uZWx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2hhbm5lbCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJcyB0aGlzIGlucHV0IGEgdW5pZm9ybSBhcnJheVxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYXJyYXlBY2Nlc3MgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtDLlNFUVVFTkNFfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNlcXVlbmNlQWNjZXNzVHlwZSA9IEMuU0VRVUVOQ0UuTk9fQUNDRVNTO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtDaGFubmVsfG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2VxdWVuY2VLZXlTb3VyY2VDaGFubmVsID0gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBIYXNoLWFibGUga2V5IHRvIGlkZW50aWZ5IGVxdWFsIGlucHV0cyB3aXRoaW4gZXhlY3V0b3JcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcblByb2dyYW1JbnB1dENvbm5lY3Rpb24ucHJvdG90eXBlLmdldEtleSA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gKHRoaXMuY2hhbm5lbCA/IHRoaXMuY2hhbm5lbC5pZCA6IFwiTlVMTFwiKSArIFwiO1wiICsgdGhpcy5hcnJheUFjY2VzcyArIFwiO1wiICsgdGhpcy5zZXF1ZW5jZUFjY2Vzc1R5cGUgKyBcIjtcIiArXHJcbiAgICAoIHRoaXMuc2VxdWVuY2VLZXlTb3VyY2VDaGFubmVsID8gdGhpcy5zZXF1ZW5jZUtleVNvdXJjZUNoYW5uZWwuaWQgOiBcIlwiKTtcclxufTtcclxuXHJcblxyXG52YXIgY19wcm9ncmFtX2NhY2hlID0ge307XHJcblxyXG52YXIgY3JlYXRlUHJvZ3JhbSA9IGZ1bmN0aW9uKG9wZXJhdG9yTGlzdCl7XHJcbiAgICB2YXIgZmlyc3RPcGVyYXRvcjtcclxuXHJcbiAgICBpZihvcGVyYXRvckxpc3QuZW50cmllcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBmaXJzdE9wZXJhdG9yID0gb3BlcmF0b3JMaXN0LmVudHJpZXNbMF0ub3BlcmF0b3I7XHJcblxyXG4gICAgdmFyIGtleSA9IG9wZXJhdG9yTGlzdC5nZXRLZXkoKTtcclxuICAgIGlmKCFjX3Byb2dyYW1fY2FjaGVba2V5XSl7XHJcbiAgICAgICAgLy8gR0xTTCBvcGVyYXRvcnMgYXJlIGltcGxlbWVudGVkIGluIGEgZGlmZmVyZW50IHdheSwgc28gcGxhdGZvcm0gaW5mb3JtYXRpb24gaXMgZmV0Y2hlZCBmcm9tIHRoZSBvcGVyYXRvckxpc3RcclxuICAgICAgICAvLyBhcyBhIGZhbGxiYWNrIG1vZGUgdG8gbm90IGJyZWFrIHRoZSBvbGQgaW1wbGVtZW50YXRpb25zXHJcbiAgICAgICAgaWYob3BlcmF0b3JMaXN0LnBsYXRmb3JtID09PSBDLlBMQVRGT1JNLkdMU0wpe1xyXG4gICAgICAgICAgICBjX3Byb2dyYW1fY2FjaGVba2V5XSA9IG5ldyBWU1Byb2dyYW0ob3BlcmF0b3JMaXN0KTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmIChmaXJzdE9wZXJhdG9yLnBsYXRmb3JtID09PSBDLlBMQVRGT1JNLkNMKSB7XHJcbiAgICAgICAgICAgIGNfcHJvZ3JhbV9jYWNoZVtrZXldID0gbmV3IENMUHJvZ3JhbShvcGVyYXRvckxpc3QpO1xyXG5cclxuICAgICAgICB9ZWxzZSBpZihmaXJzdE9wZXJhdG9yLnBsYXRmb3JtID09PSBDLlBMQVRGT1JNLkpBVkFTQ1JJUFQgJiYgb3BlcmF0b3JMaXN0LmVudHJpZXMubGVuZ3RoID09PSAxICkge1xyXG4gICAgICAgICAgICBjX3Byb2dyYW1fY2FjaGVba2V5XSA9IG5ldyBTaW5nbGVQcm9ncmFtKG9wZXJhdG9yTGlzdCk7XHJcblxyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgQmFzZS5ub3RpZnlFcnJvcihcIkNvdWxkIG5vdCBjcmVhdGUgcHJvZ3JhbSBmcm9tIG9wZXJhdG9yTGlzdFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY19wcm9ncmFtX2NhY2hlW2tleV07XHJcbn07XHJcblxyXG5cclxuXHJcbnZhciBTaW5nbGVQcm9ncmFtID0gZnVuY3Rpb24ob3BlcmF0b3JMaXN0KXtcclxuICAgIHRoaXMubGlzdCA9IG9wZXJhdG9yTGlzdDtcclxuICAgIHRoaXMuZW50cnkgPSBvcGVyYXRvckxpc3QuZW50cmllc1swXTtcclxuICAgIHRoaXMub3BlcmF0b3IgPSB0aGlzLmVudHJ5Lm9wZXJhdG9yO1xyXG4gICAgdGhpcy5faW5saW5lTG9vcCA9IG51bGw7XHJcbn07XHJcblxyXG5TaW5nbGVQcm9ncmFtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbihwcm9ncmFtRGF0YSwgYXN5bmNDYWxsYmFjayl7XHJcbiAgICB2YXIgb3BlcmF0b3JEYXRhID0gcHJlcGFyZU9wZXJhdG9yRGF0YSh0aGlzLmxpc3QsIDAsIHByb2dyYW1EYXRhKTtcclxuXHJcbiAgICBpZihhc3luY0NhbGxiYWNrKVxyXG4gICAgICAgIGFwcGx5QXN5bmNPcGVyYXRvcih0aGlzLmVudHJ5LCBwcm9ncmFtRGF0YSwgb3BlcmF0b3JEYXRhLCBhc3luY0NhbGxiYWNrKTtcclxuICAgIGVsc2UgaWYodGhpcy5vcGVyYXRvci5ldmFsdWF0ZV9jb3JlKXtcclxuICAgICAgICBhcHBseUNvcmVPcGVyYXRpb24odGhpcywgcHJvZ3JhbURhdGEsIG9wZXJhdG9yRGF0YSk7XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICAgIGFwcGx5RGVmYXVsdE9wZXJhdGlvbih0aGlzLmVudHJ5LCBwcm9ncmFtRGF0YSwgb3BlcmF0b3JEYXRhKTtcclxuICAgIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdE9wZXJhdGlvbihlbnRyeSwgcHJvZ3JhbURhdGEsIG9wZXJhdG9yRGF0YSl7XHJcbiAgICB2YXIgYXJncyA9IGFzc2VtYmxlRnVuY3Rpb25BcmdzKGVudHJ5LCBwcm9ncmFtRGF0YSk7XHJcbiAgICBhcmdzLnB1c2gob3BlcmF0b3JEYXRhKTtcclxuICAgIGVudHJ5Lm9wZXJhdG9yLmV2YWx1YXRlLmFwcGx5KG9wZXJhdG9yRGF0YSwgYXJncyk7XHJcbiAgICBoYW5kbGVQb3N0UHJvY2Vzc091dHB1dChlbnRyeSwgcHJvZ3JhbURhdGEsIGFyZ3MsIGZhbHNlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlBc3luY09wZXJhdG9yKGVudHJ5LCBwcm9ncmFtRGF0YSwgb3BlcmF0b3JEYXRhLCBhc3luY0NhbGxiYWNrKXtcclxuICAgIHZhciBhcmdzID0gYXNzZW1ibGVGdW5jdGlvbkFyZ3MoZW50cnksIHByb2dyYW1EYXRhLCB0cnVlKTtcclxuICAgIGFyZ3MucHVzaChvcGVyYXRvckRhdGEpO1xyXG4gICAgYXJncy5wdXNoKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaGFuZGxlUG9zdFByb2Nlc3NPdXRwdXQoZW50cnksIHByb2dyYW1EYXRhLCBhcmdzLCB0cnVlKTtcclxuICAgICAgICBhc3luY0NhbGxiYWNrKCk7XHJcbiAgICB9KTtcclxuICAgIGVudHJ5Lm9wZXJhdG9yLmV2YWx1YXRlX2FzeW5jLmFwcGx5KG9wZXJhdG9yRGF0YSwgYXJncyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5Q29yZU9wZXJhdGlvbihwcm9ncmFtLCBwcm9ncmFtRGF0YSwgb3BlcmF0b3JEYXRhKXtcclxuICAgIHZhciBhcmdzID0gYXNzZW1ibGVGdW5jdGlvbkFyZ3MocHJvZ3JhbS5lbnRyeSwgcHJvZ3JhbURhdGEpO1xyXG4gICAgYXJncy5wdXNoKG9wZXJhdG9yRGF0YS5pdGVyYXRlQ291bnQpO1xyXG5cclxuICAgIGlmKCFwcm9ncmFtLl9pbmxpbmVMb29wKXtcclxuICAgICAgICBwcm9ncmFtLl9pbmxpbmVMb29wID0gY3JlYXRlT3BlcmF0b3JJbmxpbmVMb29wKHByb2dyYW0ub3BlcmF0b3IsIG9wZXJhdG9yRGF0YSk7XHJcbiAgICB9XHJcbiAgICBwcm9ncmFtLl9pbmxpbmVMb29wLmFwcGx5KG9wZXJhdG9yRGF0YSwgYXJncyk7XHJcbn1cclxuXHJcbnZhciBjX1ZhclBhdHRlcm4gPSAvdmFyXFxzKyguKStbO1xcbl0vO1xyXG52YXIgY19Jbm5lclZhclBhdHRlcm4gPSAvW149LFxcc10rXFxzKig9W14sXSspPygsKT8vO1xyXG5mdW5jdGlvbiBjcmVhdGVPcGVyYXRvcklubGluZUxvb3Aob3BlcmF0b3IsIG9wZXJhdG9yRGF0YSl7XHJcblxyXG4gICAgdmFyIGNvZGUgPSBcImZ1bmN0aW9uIChcIjtcclxuICAgIHZhciBmdW5jRGF0YSA9IHBhcnNlRnVuY3Rpb24ob3BlcmF0b3IuZXZhbHVhdGVfY29yZSk7XHJcbiAgICBjb2RlICs9IGZ1bmNEYXRhLmFyZ3Muam9pbihcIixcIikgKyBcIixfX3hmbG93TWF4KSB7XFxuXCI7XHJcbiAgICBjb2RlICs9IFwiICAgIHZhciBfX3hmbG93SSA9IF9feGZsb3dNYXhcXG5cIiArXHJcbiAgICAgICAgXCIgICAgd2hpbGUoX194Zmxvd0ktLSl7XFxuXCI7XHJcblxyXG4gICAgdmFyIGJvZHkgPSBmdW5jRGF0YS5ib2R5O1xyXG4gICAgYm9keSA9IHJlcGxhY2VBcnJheUFjY2Vzcyhib2R5LCBmdW5jRGF0YS5hcmdzLCBvcGVyYXRvciwgb3BlcmF0b3JEYXRhKTtcclxuICAgIGNvZGUgKz0gYm9keSArIFwiXFxuICB9XFxufVwiO1xyXG5cclxuICAgIHZhciBpbmxpbmVGdW5jID0gZXZhbChcIihcIiArIGNvZGUgKyBcIilcIik7XHJcbiAgICByZXR1cm4gaW5saW5lRnVuYztcclxufVxyXG5cclxuICAgIHZhciBjX0Z1bmN0aW9uUGF0dGVybiA9IC9mdW5jdGlvblxccyooW14oXSopXFwoKFteKV0qKVxcKVxccypcXHsoW1xcc1xcU10qKVxcfS87XHJcblxyXG5mdW5jdGlvbiBwYXJzZUZ1bmN0aW9uKGZ1bmMpe1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgdmFyIG1hdGNoZXMgPSBmdW5jLnRvU3RyaW5nKCkubWF0Y2goY19GdW5jdGlvblBhdHRlcm4pO1xyXG4gICAgaWYoIW1hdGNoZXMpe1xyXG4gICAgICAgIEJhc2Uubm90aWZ5RXJyb3IoXCJYZmxvdyBJbnRlcm5hbDogQ291bGQgbm90IHBhcnNlIGZ1bmN0aW9uOiBcIiArIGZ1bmMpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmVzdWx0LmFyZ3MgPSBtYXRjaGVzWzJdLnNwbGl0KFwiLFwiKTtcclxuICAgIGZvcih2YXIgaSBpbiByZXN1bHQuYXJncykgcmVzdWx0LmFyZ3NbaV0gPSByZXN1bHQuYXJnc1tpXS50cmltKCk7XHJcbiAgICByZXN1bHQuYm9keSA9IG1hdGNoZXNbM107XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG52YXIgY19icmFja2V0UGF0dGVybiA9IC8oW2EtekEtWl8kXVtcXHckXSopKFxcWykvO1xyXG5cclxuZnVuY3Rpb24gcmVwbGFjZUFycmF5QWNjZXNzKGNvZGUsIGFyZ3MsIG9wZXJhdG9yLCBvcGVyYXRvckRhdGEpe1xyXG4gICAgdmFyIHJlc3VsdCA9IFwiXCI7XHJcbiAgICB2YXIgaW5kZXggPSAwLCBicmFja2V0SW5kZXggPSBjb2RlLmluZGV4T2YoXCJbXCIsIGluZGV4KTtcclxuICAgIHdoaWxlKGJyYWNrZXRJbmRleCAhPSAtMSl7XHJcbiAgICAgICAgdmFyIGtleSA9IGNvZGUuc3Vic3RyKGluZGV4KS5tYXRjaChjX2JyYWNrZXRQYXR0ZXJuKVsxXTtcclxuXHJcbiAgICAgICAgdmFyIGFyZ0lkeCA9IGFyZ3MuaW5kZXhPZihrZXkpO1xyXG4gICAgICAgIHZhciBhZGRJbmRleCA9IGZhbHNlLCB0dXBsZUNudCA9IDA7XHJcbiAgICAgICAgaWYoYXJnSWR4ICE9IC0xKXtcclxuICAgICAgICAgICAgaWYoYXJnSWR4IDwgb3BlcmF0b3Iub3V0cHV0cy5sZW5ndGgpe1xyXG4gICAgICAgICAgICAgICAgYWRkSW5kZXggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdHVwbGVDbnQgPSBDLkRBVEFfVFlQRV9UVVBMRV9TSVpFW1tvcGVyYXRvci5vdXRwdXRzW2FyZ0lkeF0udHlwZV1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGFyZ0lkeCAtIG9wZXJhdG9yLm91dHB1dHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgYWRkSW5kZXggPSBvcGVyYXRvckRhdGEuaXRlckZsYWdbaV07XHJcbiAgICAgICAgICAgICAgICB0dXBsZUNudCA9IEMuREFUQV9UWVBFX1RVUExFX1NJWkVbb3BlcmF0b3IubWFwcGluZ1tpXS5pbnRlcm5hbFR5cGVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXN1bHQgKz0gY29kZS5zdWJzdHJpbmcoaW5kZXgsIGJyYWNrZXRJbmRleCkgKyBcIltcIjtcclxuICAgICAgICBpZihhZGRJbmRleCl7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSB0dXBsZUNudCArIFwiKl9feGZsb3dJICsgXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluZGV4ID0gYnJhY2tldEluZGV4ICsgMTtcclxuICAgICAgICBicmFja2V0SW5kZXggPSBjb2RlLmluZGV4T2YoXCJbXCIsIGluZGV4KTtcclxuICAgIH1cclxuICAgIHJlc3VsdCArPSAgY29kZS5zdWJzdHJpbmcoaW5kZXgpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHByZXBhcmVPcGVyYXRvckRhdGEobGlzdCwgaWR4LCBwcm9ncmFtRGF0YSl7XHJcbiAgICB2YXIgZGF0YSA9IHByb2dyYW1EYXRhLm9wZXJhdG9yRGF0YVswXTtcclxuICAgIHZhciBlbnRyeSA9IGxpc3QuZW50cmllc1tpZHhdO1xyXG4gICAgdmFyIG1hcHBpbmcgPSBlbnRyeS5vcGVyYXRvci5tYXBwaW5nO1xyXG4gICAgZGF0YS5pdGVyRmxhZyA9IHt9O1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG1hcHBpbmcubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIHZhciBkb0l0ZXJhdGUgPSAoZW50cnkuaXNUcmFuc2ZlcklucHV0KGkpIHx8IGxpc3QuaXNJbnB1dEl0ZXJhdGUoZW50cnkuZ2V0RGlyZWN0SW5wdXRJbmRleChpKSkpO1xyXG4gICAgICAgIGRhdGEuaXRlckZsYWdbaV0gPSBkb0l0ZXJhdGU7XHJcbiAgICB9XHJcbiAgICBkYXRhLml0ZXJhdGVDb3VudCA9IGxpc3QuZ2V0SXRlcmF0ZUNvdW50KHByb2dyYW1EYXRhKTtcclxuICAgIGlmKCFkYXRhLmN1c3RvbURhdGEpXHJcbiAgICAgICAgZGF0YS5jdXN0b21EYXRhID0ge307XHJcbiAgICByZXR1cm4gZGF0YTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXNzZW1ibGVGdW5jdGlvbkFyZ3MoZW50cnksIHByb2dyYW1EYXRhLCBhc3luYyl7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgdmFyIG91dHB1dHMgPSBlbnRyeS5vcGVyYXRvci5vdXRwdXRzO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG91dHB1dHMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIGlmKG91dHB1dHNbaV0ubm9BbGxvYyl7XHJcbiAgICAgICAgICAgIGFyZ3MucHVzaCh7YXNzaWduOiBudWxsfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHZhciBkYXRhU2xvdCA9IHByb2dyYW1EYXRhLm91dHB1dHNbZW50cnkuZ2V0T3V0cHV0SW5kZXgoaSldO1xyXG4gICAgICAgICAgICB2YXIgZGF0YUVudHJ5ID0gYXN5bmMgPyBkYXRhU2xvdC5hc3luY0RhdGFFbnRyeSA6IGRhdGFTbG90LmRhdGFFbnRyeTtcclxuICAgICAgICAgICAgYXJncy5wdXNoKGRhdGFFbnRyeSA/IGRhdGFFbnRyeS5nZXRWYWx1ZSgpIDogbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWRkSW5wdXRUb0FyZ3MoYXJncywgZW50cnksIHByb2dyYW1EYXRhKTtcclxuICAgIHJldHVybiBhcmdzO1xyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZVBvc3RQcm9jZXNzT3V0cHV0KGVudHJ5LCBwcm9ncmFtRGF0YSwgcGFyYW1ldGVycywgYXN5bmMpe1xyXG4gICAgdmFyIG91dHB1dHMgPSBlbnRyeS5vcGVyYXRvci5vdXRwdXRzO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG91dHB1dHMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIHZhciBkYXRhU2xvdCA9IHByb2dyYW1EYXRhLm91dHB1dHNbZW50cnkuZ2V0T3V0cHV0SW5kZXgoaSldO1xyXG4gICAgICAgIGlmKG91dHB1dHNbaV0ubm9BbGxvYyl7XHJcbiAgICAgICAgICAgIHZhciBkYXRhRW50cnkgPSBhc3luYyA/IGRhdGFTbG90LmFzeW5jRGF0YUVudHJ5IDogZGF0YVNsb3QuZGF0YUVudHJ5O1xyXG4gICAgICAgICAgICBpZihkYXRhRW50cnkudHlwZSA9PSBDLkRBVEFfVFlQRS5URVhUVVJFICl7XHJcbiAgICAgICAgICAgICAgICBkYXRhRW50cnkuX3NldEltYWdlKHBhcmFtZXRlcnNbaV0uYXNzaWduKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgZGF0YUVudHJ5Ll9zZXRWYWx1ZShwYXJhbWV0ZXJzW2ldLmFzc2lnbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoYXN5bmMpe1xyXG4gICAgICAgICAgICBkYXRhU2xvdC5zd2FwQXN5bmMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBhZGRJbnB1dFRvQXJncyhhcmdzLCBlbnRyeSwgcHJvZ3JhbURhdGEpe1xyXG4gICAgdmFyIG1hcHBpbmcgPSBlbnRyeS5vcGVyYXRvci5tYXBwaW5nO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG1hcHBpbmcubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIHZhciBtYXBFbnRyeSA9IG1hcHBpbmdbaV07XHJcbiAgICAgICAgdmFyIGRhdGFFbnRyeSA9IHByb2dyYW1EYXRhLmdldERhdGFFbnRyeShlbnRyeS5nZXREaXJlY3RJbnB1dEluZGV4KGkpKTtcclxuICAgICAgICBhcmdzLnB1c2goZGF0YUVudHJ5ID8gZGF0YUVudHJ5LmdldFZhbHVlKCkgOiBudWxsKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBjcmVhdGVQcm9ncmFtOiBjcmVhdGVQcm9ncmFtLFxyXG4gICAgUHJvZ3JhbURhdGE6IFByb2dyYW1EYXRhLFxyXG4gICAgUHJvZ3JhbUlucHV0Q29ubmVjdGlvbjogUHJvZ3JhbUlucHV0Q29ubmVjdGlvblxyXG59O1xyXG4iLCJ2YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi9iYXNlLmpzXCIpO1xyXG52YXIgQyA9IHJlcXVpcmUoXCIuLi9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xyXG52YXIgVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvdXRpbHMuanNcIik7XHJcbnZhciBWZXJ0ZXhTaGFkZXIgPSByZXF1aXJlKFwiLi4vcHJvY2Vzc2luZy92cy1jb25uZWN0LmpzXCIpLlZlcnRleFNoYWRlcjtcclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBPcGVyYXRvckxpc3RcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG52YXIgY19TSEFERVJfQ09OU1RBTlRfVFlQRVMgPSB7fTtcclxuY19TSEFERVJfQ09OU1RBTlRfVFlQRVNbQy5TSEFERVJfQ09OU1RBTlRfS0VZLk9CSkVDVF9JRF0gPSAnaW50JztcclxuY19TSEFERVJfQ09OU1RBTlRfVFlQRVNbQy5TSEFERVJfQ09OU1RBTlRfS0VZLlNDUkVFTl9UUkFOU0ZPUk1dID0gJ21hdDQnO1xyXG5jX1NIQURFUl9DT05TVEFOVF9UWVBFU1tDLlNIQURFUl9DT05TVEFOVF9LRVkuU0NSRUVOX1RSQU5TRk9STV9OT1JNQUxdID0gJ21hdDMnO1xyXG5jX1NIQURFUl9DT05TVEFOVF9UWVBFU1tDLlNIQURFUl9DT05TVEFOVF9LRVkuVklFV19UUkFOU0ZPUk1dID0gJ21hdDQnO1xyXG5jX1NIQURFUl9DT05TVEFOVF9UWVBFU1tDLlNIQURFUl9DT05TVEFOVF9LRVkuVklFV19UUkFOU0ZPUk1fTk9STUFMXSA9ICdtYXQzJztcclxuY19TSEFERVJfQ09OU1RBTlRfVFlQRVNbQy5TSEFERVJfQ09OU1RBTlRfS0VZLldPUkxEX1RSQU5TRk9STV0gPSAnbWF0NCc7XHJcbmNfU0hBREVSX0NPTlNUQU5UX1RZUEVTW0MuU0hBREVSX0NPTlNUQU5UX0tFWS5XT1JMRF9UUkFOU0ZPUk1fTk9STUFMXSA9ICdtYXQzJztcclxuXHJcbnZhciBWU1Byb2dyYW0gPSBmdW5jdGlvbihvcGVyYXRvckxpc3Qpe1xyXG4gICAgdGhpcy5saXN0ID0gb3BlcmF0b3JMaXN0O1xyXG4gICAgdGhpcy5fb3V0cHV0SW5mbyA9IHt9O1xyXG4gICAgc2V0T3V0cHV0SXRlcmF0ZSh0aGlzKTtcclxufTtcclxuXHJcblZTUHJvZ3JhbS5wcm90b3R5cGUuZ2V0T3V0cHV0TmFtZXMgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX291dHB1dEluZm8pO1xyXG59O1xyXG5cclxuVlNQcm9ncmFtLnByb3RvdHlwZS5nZXRPdXRwdXRUeXBlID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgICByZXR1cm4gdGhpcy5fb3V0cHV0SW5mb1tuYW1lXS50eXBlO1xyXG59O1xyXG5cclxuVlNQcm9ncmFtLnByb3RvdHlwZS5pc091dHB1dFVuaWZvcm0gPSBmdW5jdGlvbihuYW1lKXtcclxuICAgIHJldHVybiB0aGlzLl9vdXRwdXRJbmZvW25hbWVdLml0ZXJhdGlvbiA9PSBDLklURVJBVElPTl9UWVBFLk9ORTtcclxufTtcclxuXHJcblZTUHJvZ3JhbS5wcm90b3R5cGUuaXNPdXRwdXROdWxsID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgICByZXR1cm4gdGhpcy5fb3V0cHV0SW5mb1tuYW1lXS5pdGVyYXRpb24gPT0gQy5JVEVSQVRJT05fVFlQRS5OVUxMO1xyXG59O1xyXG5cclxuVlNQcm9ncmFtLnByb3RvdHlwZS5jcmVhdGVWZXJ0ZXhTaGFkZXIgPSBmdW5jdGlvbihwcm9ncmFtRGF0YSwgdnNDb25maWcpe1xyXG4gICAgdmFyIHJlc3VsdCA9IG5ldyBWZXJ0ZXhTaGFkZXIocHJvZ3JhbURhdGEpO1xyXG4gICAgY29uc3RydWN0VlMocmVzdWx0LCB0aGlzLCB2c0NvbmZpZyk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gc2V0T3V0cHV0SXRlcmF0ZShwcm9ncmFtKXtcclxuICAgIHZhciBvcGVyYXRvckxpc3QgPSBwcm9ncmFtLmxpc3QsIGVudHJpZXMgPSBvcGVyYXRvckxpc3QuZW50cmllcztcclxuXHJcbiAgICB2YXIgYmFzZUVudHJ5ID0gZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdLCBiYXNlT3BlcmF0b3IgPSBiYXNlRW50cnkub3BlcmF0b3I7XHJcblxyXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBiYXNlT3BlcmF0b3IucGFyYW1zLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB2YXIgZW50cnkgPSBiYXNlT3BlcmF0b3IucGFyYW1zW2ldLFxyXG4gICAgICAgICAgICBuYW1lID0gZW50cnkuc291cmNlLFxyXG4gICAgICAgICAgICBpbnB1dEluZGV4ID0gaSxcclxuICAgICAgICAgICAgZGlyZWN0SW5wdXRJbmRleCA9IGJhc2VFbnRyeS5nZXREaXJlY3RJbnB1dEluZGV4KGlucHV0SW5kZXgpO1xyXG4gICAgICAgIHByb2dyYW0uX291dHB1dEluZm9bbmFtZV0gPSB7dHlwZTogZW50cnkudHlwZX07XHJcbiAgICAgICAgaWYoIGJhc2VFbnRyeS5pc1RyYW5zZmVySW5wdXQoaW5wdXRJbmRleCkgfHxcclxuICAgICAgICAgICAgb3BlcmF0b3JMaXN0LmlzSW5wdXRJdGVyYXRlKGRpcmVjdElucHV0SW5kZXgpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcHJvZ3JhbS5fb3V0cHV0SW5mb1tuYW1lXS5pdGVyYXRpb24gPSBDLklURVJBVElPTl9UWVBFLk1BTlk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYob3BlcmF0b3JMaXN0LmlzSW5wdXRVbmlmb3JtKGRpcmVjdElucHV0SW5kZXgpKXtcclxuICAgICAgICAgICAgcHJvZ3JhbS5fb3V0cHV0SW5mb1tuYW1lXS5pdGVyYXRpb24gPSBDLklURVJBVElPTl9UWVBFLk9ORTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgcHJvZ3JhbS5fb3V0cHV0SW5mb1tuYW1lXS5pdGVyYXRpb24gPSBDLklURVJBVElPTl9UWVBFLk5VTEw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjb25zdHJ1Y3RWUyh2cywgcHJvZ3JhbSwgdnNDb25maWcpe1xyXG4gICAgdmFyIG9wZXJhdG9yTGlzdCA9IHByb2dyYW0ubGlzdCwgZW50cmllcyA9IG9wZXJhdG9yTGlzdC5lbnRyaWVzO1xyXG5cclxuICAgIHZhciB1c2VkTmFtZXMgPSBbXSxcclxuICAgICAgICBkaXJlY3RJbnB1dE5hbWVzID0ge30sXHJcbiAgICAgICAgdHJhbnNmZXJOYW1lcyA9IHt9O1xyXG5cclxuICAgIHZhciBiYXNlRW50cnkgPSBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0sIGFjY2VwdGVkQmFzZVNoYWRlcklucHV0ID0gW10sIGJhc2VPcGVyYXRvciA9IGJhc2VFbnRyeS5vcGVyYXRvcjtcclxuXHJcbiAgICBpZighdnNDb25maWcpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgdnNDb25maWchIEF0dGVtcHQgdG8gY3JlYXRlIHZlcnRleCBzaGFkZXIgcHJvZ3JhbW0gd2l0aG91dCBWUyBvcGVyYXRvcj9cIik7XHJcblxyXG4gICAgVXRpbHMubmFtZXNldC5hZGQodXNlZE5hbWVzLCB2c0NvbmZpZy5nZXRCbG9ja2VkTmFtZXMoKSk7XHJcblxyXG4gICAgdmFyIGNvZGUgPSBcIlwiO1xyXG4gICAgY29kZSArPSBcIi8vIE9VVFBVVFxcblwiO1xyXG4gICAgLy8gRmlyc3Q6IGNvbGxlY3Qgb3V0cHV0IG5hbWVzXHJcbiAgICBmb3IodmFyIG5hbWUgaW4gdnNDb25maWcuX2FkZE91dHB1dCl7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdnNDb25maWcuX2FkZE91dHB1dFtuYW1lXTtcclxuICAgICAgICBjb2RlICs9IFwidmFyeWluZyBcIiArIGdldEdMU0xUeXBlKGVudHJ5LnR5cGUpICsgXCIgXCIgKyBuYW1lICsgXCI7XFxuXCI7XHJcbiAgICAgICAgVXRpbHMubmFtZXNldC5hZGQodXNlZE5hbWVzLCBuYW1lKTtcclxuICAgIH1cclxuICAgIHZhciBpbnB1dEluZGV4ID0gMDtcclxuICAgIGZvciggdmFyIG5hbWUgaW4gdnNDb25maWcuX2F0dHJpYnV0ZXMpe1xyXG4gICAgICAgIHZhciBjb25maWdBdHRyID0gdnNDb25maWcuX2F0dHJpYnV0ZXNbbmFtZV0sXHJcbiAgICAgICAgICAgIGRpcmVjdElucHV0SW5kZXggPSBiYXNlRW50cnkuZ2V0RGlyZWN0SW5wdXRJbmRleChpbnB1dEluZGV4KTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY29uZmlnQXR0ci5jaGFubmVsaW5nLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIGNoYW5uZWxpbmcgPSBjb25maWdBdHRyLmNoYW5uZWxpbmdbaV07XHJcbiAgICAgICAgICAgIHZhciBvdXRwdXRJbmZvID0ge3R5cGU6IGNvbmZpZ0F0dHIudHlwZSwgaXRlcmF0aW9uOiAwLCBpbmRleDogMCwgc291cmNlTmFtZTogbmFtZX0sXHJcbiAgICAgICAgICAgICAgICBvdXRwdXROYW1lID0gY2hhbm5lbGluZy5vdXRwdXROYW1lO1xyXG4gICAgICAgICAgICBpZiggY2hhbm5lbGluZy5jb2RlIHx8XHJcbiAgICAgICAgICAgICAgICBiYXNlRW50cnkuaXNUcmFuc2ZlcklucHV0KGlucHV0SW5kZXgpIHx8XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvckxpc3QuaXNJbnB1dEl0ZXJhdGUoZGlyZWN0SW5wdXRJbmRleCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGFjY2VwdGVkQmFzZVNoYWRlcklucHV0W2lucHV0SW5kZXhdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIG91dHB1dEluZm8uaXRlcmF0aW9uID0gQy5JVEVSQVRJT05fVFlQRS5NQU5ZO1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBiYXNlT3BlcmF0b3Iub3V0cHV0c1tpbnB1dEluZGV4XS50eXBlO1xyXG4gICAgICAgICAgICAgICAgY29kZSArPSBcInZhcnlpbmcgXCIgKyBnZXRHTFNMVHlwZSh0eXBlKSArIFwiIFwiICsgb3V0cHV0TmFtZSArIFwiO1xcblwiO1xyXG4gICAgICAgICAgICAgICAgVXRpbHMubmFtZXNldC5hZGQodXNlZE5hbWVzLCBvdXRwdXROYW1lKTtcclxuICAgICAgICAgICAgICAgIHRyYW5zZmVyTmFtZXNbYmFzZUVudHJ5LmdldFRyYW5zZmVyT3V0cHV0SWQoaSldID0gb3V0cHV0TmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKG9wZXJhdG9yTGlzdC5pc0lucHV0VW5pZm9ybShkaXJlY3RJbnB1dEluZGV4KSl7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXRJbmZvLml0ZXJhdGlvbiA9IEMuSVRFUkFUSU9OX1RZUEUuT05FO1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0SW5mby5pbmRleCA9IGRpcmVjdElucHV0SW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIG91dHB1dEluZm8uaXRlcmF0aW9uID0gQy5JVEVSQVRJT05fVFlQRS5OVUxMO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFV0aWxzLm5hbWVzZXQuYWRkKHZzLl9vdXRwdXROYW1lcywgb3V0cHV0TmFtZSk7XHJcbiAgICAgICAgICAgIHZzLl9vdXRwdXRJbmZvW291dHB1dE5hbWVdID0gb3V0cHV0SW5mbztcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5wdXRJbmRleCsrO1xyXG4gICAgfVxyXG4gICAgY29kZSArPSBcIlxcblwiO1xyXG4gICAgY29kZSArPSBcIi8vIElOUFVUXFxuXCI7XHJcbiAgICAvLyBBZGQgYWRkaXRpb25hbCBpbnB1dFxyXG4gICAgZm9yKHZhciBuYW1lIGluIHZzQ29uZmlnLl9hZGRJbnB1dCl7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdnNDb25maWcuX2FkZElucHV0W25hbWVdO1xyXG4gICAgICAgIGNvZGUgKz0gKGVudHJ5LnVuaWZvcm0gPyBcInVuaWZvcm0gXCIgOiBcImF0dHJpYnV0ZSBcIiApICsgZ2V0R0xTTFR5cGUoZW50cnkudHlwZSkgKyBcIiBcIiArIG5hbWUgKyBcIjtcXG5cIjtcclxuICAgICAgICBVdGlscy5uYW1lc2V0LmFkZCh1c2VkTmFtZXMsIG5hbWUpO1xyXG4gICAgfVxyXG4gICAgLy8gU2Vjb25kOiBjb2xsZWN0IGlucHV0IG5hbWVzXHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpXSwgb3BlcmF0b3IgPSBlbnRyeS5vcGVyYXRvcjtcclxuICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgb3BlcmF0b3IubWFwcGluZy5sZW5ndGg7ICsrail7XHJcbiAgICAgICAgICAgIGlmKCAoaSA8IGVudHJpZXMubGVuZ3RoIC0gMSB8fCBhY2NlcHRlZEJhc2VTaGFkZXJJbnB1dFtqXSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAhZW50cnkuaXNUcmFuc2ZlcklucHV0KGopICYmICFkaXJlY3RJbnB1dE5hbWVzW2VudHJ5LmdldERpcmVjdElucHV0SW5kZXgoaildKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWFwRW50cnkgPSBvcGVyYXRvci5tYXBwaW5nW2pdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBnZXRGcmVlTmFtZShtYXBFbnRyeS5uYW1lLCB1c2VkTmFtZXMpLCBpbnB1dEluZGV4ID0gZW50cnkuZ2V0RGlyZWN0SW5wdXRJbmRleChqKSxcclxuICAgICAgICAgICAgICAgICAgICB1bmlmb3JtID0gIW9wZXJhdG9yTGlzdC5pc0lucHV0SXRlcmF0ZShpbnB1dEluZGV4KTtcclxuICAgICAgICAgICAgICAgIHZzLl9pbnB1dEluZm9bbmFtZV0gPSB7IGluZGV4OiBpbnB1dEluZGV4LCB1bmlmb3JtOiB1bmlmb3JtIH07XHJcbiAgICAgICAgICAgICAgICBVdGlscy5uYW1lc2V0LmFkZCh2cy5faW5wdXROYW1lcywgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICBkaXJlY3RJbnB1dE5hbWVzW2lucHV0SW5kZXhdID0gbmFtZTtcclxuICAgICAgICAgICAgICAgIGNvZGUgKz0gKHVuaWZvcm0gPyBcInVuaWZvcm0gXCIgOiBcImF0dHJpYnV0ZSBcIikgKyBnZXRHTFNMVHlwZShtYXBFbnRyeS5pbnRlcm5hbFR5cGUpICsgXCIgXCIgKyBuYW1lO1xyXG4gICAgICAgICAgICAgICAgaWYobWFwRW50cnkuYXJyYXkpXHJcbiAgICAgICAgICAgICAgICAgICAgY29kZSArPSBcIltcIiArIG9wZXJhdG9yTGlzdC5nZXRJbnB1dFNpemUoaW5wdXRJbmRleCkgKyBcIl1cIjtcclxuICAgICAgICAgICAgICAgIGNvZGUgKz0gXCI7XFxuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RhcnQgbWFpblxyXG4gICAgY29kZSArPSBcIlxcbi8vIENPREVcXG5cIjtcclxuICAgIGNvZGUgKz0gXCJ2b2lkIG1haW4odm9pZCl7XFxuXCI7XHJcblxyXG4gICAgLy8gQ3JlYXRlIENvZGVcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2ldLCBvcGVyYXRvciA9IGVudHJ5Lm9wZXJhdG9yO1xyXG4gICAgICAgIC8vIERlY2xhcmUgdHJhbnNmZXIgb3V0cHV0IG5hbWVzXHJcbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IG9wZXJhdG9yLm91dHB1dHMubGVuZ3RoOyArK2ope1xyXG4gICAgICAgICAgICBpZighZW50cnkuaXNGaW5hbE91dHB1dChqKSl7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGdldEZyZWVOYW1lKG9wZXJhdG9yLm91dHB1dHNbal0ubmFtZSwgdXNlZE5hbWVzKTtcclxuICAgICAgICAgICAgICAgIHRyYW5zZmVyTmFtZXNbZW50cnkuZ2V0VHJhbnNmZXJPdXRwdXRJZChqKV0gPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgY29kZSArPSBcIlxcdFwiICsgZ2V0R0xTTFR5cGUob3BlcmF0b3Iub3V0cHV0c1tqXS50eXBlKSArIFwiIFwiICsgbmFtZSArIFwiO1xcblwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRha2UgQ29kZSBGcmFnbWVudFxyXG4gICAgICAgIHZhciBjb2RlRnJhZ21lbnQgPSBjb252ZXJ0Q29kZUZyYWdtZW50KG9wZXJhdG9yLmV2YWx1YXRlX2dsc2wsIGVudHJ5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZmVyTmFtZXMsIGRpcmVjdElucHV0TmFtZXMsIHVzZWROYW1lcyk7XHJcbiAgICAgICAgY29kZSArPSBjb2RlRnJhZ21lbnQgKyBcIlxcblwiO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCBhdHRyaWJ1dGUgY2hhbm5lbGluZyBjb2RlXHJcbiAgICB2YXIgbWFwcGluZ0luZGV4ID0gMCwgY29udmVyc2lvbkNvZGUgPSBcIlwiO1xyXG4gICAgZm9yKCB2YXIgbmFtZSBpbiB2c0NvbmZpZy5fYXR0cmlidXRlcyl7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdnNDb25maWcuX2F0dHJpYnV0ZXNbbmFtZV07XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGVudHJ5LmNoYW5uZWxpbmcubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgY2hhbm5lbGluZyA9IGVudHJ5LmNoYW5uZWxpbmdbaV0sIG91dHB1dE5hbWUgPSBjaGFubmVsaW5nLm91dHB1dE5hbWU7XHJcbiAgICAgICAgICAgIGlmKHZzLl9vdXRwdXRJbmZvW291dHB1dE5hbWVdLml0ZXJhdGlvbiA9PSBDLklURVJBVElPTl9UWVBFLk1BTlkpe1xyXG4gICAgICAgICAgICAgICAgaWYoY2hhbm5lbGluZy5jb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnNpb25Db2RlICs9IFwiXFx0XCIgKyBjaGFubmVsaW5nLmNvZGUgKyBcIlxcblwiO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnNpb25Db2RlICs9IFwiXFx0XCIgKyBvdXRwdXROYW1lICsgXCIgPSAjSXtcIiArIG5hbWUgKyBcIn07XFxuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbWFwcGluZ0luZGV4Kys7XHJcbiAgICB9XHJcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHZzQ29uZmlnLl9jb2RlRnJhZ21lbnRzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICBjb252ZXJzaW9uQ29kZSArPSBcIlxcdFwiICsgdnNDb25maWcuX2NvZGVGcmFnbWVudHNbaV0gKyBcIlxcblwiO1xyXG4gICAgfVxyXG4gICAgY29kZSArPSBjb252ZXJ0Q29kZUZyYWdtZW50KGNvbnZlcnNpb25Db2RlLCBiYXNlRW50cnksIHRyYW5zZmVyTmFtZXMsIGRpcmVjdElucHV0TmFtZXMsIHVzZWROYW1lcykgKyBcIlxcblwiO1xyXG5cclxuICAgIGNvZGUgKz0gXCJ9XFxuXCI7XHJcbiAgICB2cy5fZ2xzbENvZGUgPSBjb2RlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb252ZXJ0Q29kZUZyYWdtZW50KGNvZGVGcmFnbWVudCwgZW50cnksIHRyYW5zZmVyTmFtZXMsIGRpcmVjdElucHV0TmFtZXMsIHVzZWROYW1lcyl7XHJcbiAgICB2YXIgaW5kZXgsIG9wZXJhdG9yID0gZW50cnkub3BlcmF0b3I7XHJcbiAgICB3aGlsZSgoaW5kZXggPSBjb2RlRnJhZ21lbnQuaW5kZXhPZihcIiNJe1wiKSkgIT0gLTEpe1xyXG4gICAgICAgIHZhciBlbmQgPSBjb2RlRnJhZ21lbnQuaW5kZXhPZihcIn1cIixpbmRleCk7XHJcbiAgICAgICAgdmFyIG1hcHBpbmdJbmRleCA9IGdldE1hcHBpbmdJbmRleChvcGVyYXRvciwgY29kZUZyYWdtZW50LnN1YnN0cmluZyhpbmRleCszLGVuZCkpO1xyXG4gICAgICAgIHZhciByZXBsYWNlTmFtZSA9IGVudHJ5LmlzVHJhbnNmZXJJbnB1dChtYXBwaW5nSW5kZXgpID9cclxuICAgICAgICAgICAgdHJhbnNmZXJOYW1lc1tlbnRyeS5nZXRUcmFuc2ZlcklucHV0SWQobWFwcGluZ0luZGV4KV0gOlxyXG4gICAgICAgICAgICBkaXJlY3RJbnB1dE5hbWVzW2VudHJ5LmdldERpcmVjdElucHV0SW5kZXgobWFwcGluZ0luZGV4KV07XHJcbiAgICAgICAgY29kZUZyYWdtZW50ID0gY29kZUZyYWdtZW50LnN1YnN0cmluZygwLCBpbmRleCkgKyByZXBsYWNlTmFtZSArIGNvZGVGcmFnbWVudC5zdWJzdHJpbmcoZW5kKzEpO1xyXG4gICAgfVxyXG4gICAgd2hpbGUoKGluZGV4ID0gY29kZUZyYWdtZW50LmluZGV4T2YoXCIjT3tcIikpICE9IC0xKXtcclxuICAgICAgICB2YXIgZW5kID0gY29kZUZyYWdtZW50LmluZGV4T2YoXCJ9XCIsaW5kZXgpO1xyXG4gICAgICAgIHZhciBvdXRwdXRJbmRleCA9IGdldE91dHB1dEluZGV4KG9wZXJhdG9yLCBjb2RlRnJhZ21lbnQuc3Vic3RyaW5nKGluZGV4KzMsZW5kKSk7XHJcbiAgICAgICAgdmFyIHJlcGxhY2VOYW1lID0gdHJhbnNmZXJOYW1lc1tlbnRyeS5nZXRUcmFuc2Zlck91dHB1dElkKG91dHB1dEluZGV4KV07XHJcbiAgICAgICAgY29kZUZyYWdtZW50ID0gY29kZUZyYWdtZW50LnN1YnN0cmluZygwLCBpbmRleCkgKyByZXBsYWNlTmFtZSArIGNvZGVGcmFnbWVudC5zdWJzdHJpbmcoZW5kKzEpO1xyXG4gICAgfVxyXG4gICAgdmFyIGxvY2FsTmFtZXMgPSBbXTtcclxuICAgIHdoaWxlKChpbmRleCA9IGNvZGVGcmFnbWVudC5pbmRleE9mKFwiI0x7XCIpKSAhPSAtMSl7XHJcbiAgICAgICAgdmFyIGVuZCA9IGNvZGVGcmFnbWVudC5pbmRleE9mKFwifVwiLGluZGV4KTtcclxuICAgICAgICB2YXIga2V5ID0gY29kZUZyYWdtZW50LnN1YnN0cmluZyhpbmRleCszLGVuZCk7XHJcbiAgICAgICAgaWYoIWxvY2FsTmFtZXNba2V5XSl7XHJcbiAgICAgICAgICAgIGxvY2FsTmFtZXNba2V5XSA9IGdldEZyZWVOYW1lKGtleSwgdXNlZE5hbWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlcGxhY2VOYW1lID0gbG9jYWxOYW1lc1trZXldO1xyXG4gICAgICAgIGNvZGVGcmFnbWVudCA9IGNvZGVGcmFnbWVudC5zdWJzdHJpbmcoMCwgaW5kZXgpICsgcmVwbGFjZU5hbWUgKyBjb2RlRnJhZ21lbnQuc3Vic3RyaW5nKGVuZCsxKTtcclxuICAgIH1cclxuICAgIHdoaWxlKChpbmRleCA9IGNvZGVGcmFnbWVudC5pbmRleE9mKFwiI0d7XCIpKSAhPSAtMSl7XHJcbiAgICAgICAgdmFyIGVuZCA9IGNvZGVGcmFnbWVudC5pbmRleE9mKFwifVwiLGluZGV4KTtcclxuICAgICAgICB2YXIgcmVwbGFjZU5hbWUgPSBjb2RlRnJhZ21lbnQuc3Vic3RyaW5nKGluZGV4KzMsZW5kKTtcclxuICAgICAgICBjb2RlRnJhZ21lbnQgPSBjb2RlRnJhZ21lbnQuc3Vic3RyaW5nKDAsIGluZGV4KSArIHJlcGxhY2VOYW1lICsgY29kZUZyYWdtZW50LnN1YnN0cmluZyhlbmQrMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29kZUZyYWdtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRGcmVlTmFtZShuYW1lLCB1c2VkTmFtZXMpe1xyXG4gICAgdmFyIHJlc3VsdCA9IG5hbWUsIGkgPSAxO1xyXG4gICAgd2hpbGUodXNlZE5hbWVzLmluZGV4T2YocmVzdWx0KSAhPSAtMSl7XHJcbiAgICAgICAgcmVzdWx0ID0gbmFtZSArIFwiX1wiICsgKCsraSk7XHJcbiAgICB9XHJcbiAgICBVdGlscy5uYW1lc2V0LmFkZCh1c2VkTmFtZXMsIHJlc3VsdCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRNYXBwaW5nSW5kZXgob3BlcmF0b3IsIG5hbWUpe1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG9wZXJhdG9yLm1hcHBpbmcubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIGlmKG9wZXJhdG9yLm1hcHBpbmdbaV0ubmFtZSA9PSBuYW1lKVxyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgbmFtZSAnXCIgKyBuYW1lICArIFwiJyBpbnNpZGUgb2YgY29kZSBmcmFnbWVudFwiICk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldE91dHB1dEluZGV4KG9wZXJhdG9yLCBuYW1lKXtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvcGVyYXRvci5vdXRwdXRzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICBpZihvcGVyYXRvci5vdXRwdXRzW2ldLm5hbWUgPT0gbmFtZSlcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEdMU0xUeXBlKHhmbG93VHlwZSl7XHJcbiAgICBzd2l0Y2goeGZsb3dUeXBlKXtcclxuICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkJPT0wgOiByZXR1cm4gJ2Jvb2wnO1xyXG4gICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuQllURSA6IHJldHVybiAndWludCc7XHJcbiAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5GTE9BVCA6IHJldHVybiAnZmxvYXQnO1xyXG4gICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuRkxPQVQyIDogcmV0dXJuICd2ZWMyJztcclxuICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUMyA6IHJldHVybiAndmVjMyc7XHJcbiAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5GTE9BVDQgOiByZXR1cm4gJ3ZlYzQnO1xyXG4gICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuRkxPQVQzWDMgOiByZXR1cm4gJ21hdDMnO1xyXG4gICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuRkxPQVQ0WDQgOiByZXR1cm4gJ21hdDQnO1xyXG4gICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuSU5UIDogcmV0dXJuICdpbnQnO1xyXG4gICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuSU5UNCA6IHJldHVybiAnaXZlYzQnO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVHlwZSBub3Qgc3VwcG9ydGVkIGZvciBHTFNMIFwiICsgQy5nZXRUeXBlTmFtZSh4Zmxvd1R5cGUpICk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVlNQcm9ncmFtO1xyXG4iLCJ2YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi9iYXNlLmpzXCIpO1xyXG52YXIgQyA9IHJlcXVpcmUoXCIuLi9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xyXG52YXIgQ2hhbm5lbHMgPSByZXF1aXJlKFwiLi9jaGFubmVsLmpzXCIpO1xyXG52YXIgUmVxdWVzdE5vZGUgPSByZXF1aXJlKFwiLi9wcm9jZXNzLW5vZGUuanNcIikuUmVxdWVzdE5vZGU7XHJcbnZhciBQcm9jZXNzTm9kZSA9IHJlcXVpcmUoXCIuL3Byb2Nlc3Mtbm9kZS5qc1wiKS5Qcm9jZXNzTm9kZTtcclxudmFyIERhdGFTbG90ID0gcmVxdWlyZShcIi4vZGF0YS1zbG90LmpzXCIpO1xyXG52YXIgT3BlcmF0b3IgPSByZXF1aXJlKFwiLi4vb3BlcmF0b3Ivb3BlcmF0b3IuanNcIik7XHJcblxyXG52YXIgQ2hhbm5lbE1hcCA9IENoYW5uZWxzLkNoYW5uZWxNYXA7XHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gQ2hhbm5lbE5vZGVcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vKipcclxuICogSXMgY3JlYXRlZCBmb3IgZWFjaCBzdWJzdGl0dXRpb24gKHZpYSBkYXRhZmxvdykgb2YgYSBEYXRhTm9kZS5cclxuICogU3RvcmVzIGFuIG9wdGltaXplZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGF0YSB3aXRoIENoYW5uZWxNYXBzIGFuZCBDaGFubmVsc1xyXG4gKiBPbiBjb25zdHJ1Y3Rpb24gYSBDaGFubmVsTm9kZSBpcyBtYXJrZWQgb3V0T2ZTeW5jIGFuZCBzeW5jaHJvbml6ZWQgb25seSBvbmNlIGRhdGEgaXMgcmVxdWVzdGVkLlxyXG4gKiBXaGVuIHRoZSBzdHJ1Y3R1cmUgb2YgYSBEYXRhTm9kZSBpcyBjaGFuZ2VkIGluIGFueSB3YXkgKGUuZy4gcmVuYW1lIElucHV0Tm9kZSwgYWRkL3JlbW92ZSBjaGlsZHJlbikgYSBjaGFubmVsTm9kZVxyXG4gKiBpcyBtYXJrZWQgb3V0T2ZTeW5jLlxyXG4gKiBAcGFyYW0ge0RhdGFOb2RlfSBkYXRhTm9kZVxyXG4gKiBAcGFyYW0ge1N1YnN0aXR1dGlvbn0gc3Vic3RpdHV0aW9uXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIENoYW5uZWxOb2RlID0gZnVuY3Rpb24oZGF0YU5vZGUsIHN1YnN0aXR1dGlvbil7XHJcbiAgICB0aGlzLm93bmVyID0gZGF0YU5vZGU7XHJcbiAgICB0aGlzLnBsYXRmb3JtID0gQy5QTEFURk9STS5KQVZBU0NSSVBUO1xyXG4gICAgdGhpcy5zdWJzdGl0dXRpb24gPSBzdWJzdGl0dXRpb247ICAgLy8gU3Vic3RpdHV0aW9uIGlzIGRlZmluZWQgYnkgdGhlIGRhdGFmbG93IGluc3RhbmNlXHJcbiAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTsgICAvLyBpcyB0cnVlIGlmIGFueSB2YWx1ZSBpbiB0aGUgc3ViIHRyZWUgaXMgbG9hZGluZyBhbmQgdGhlIHJlc3VsdCBjYW4ndCBiZSBjYWxjdWxhdGVkXHJcbiAgICB0aGlzLmlucHV0U2xvdHMgPSB7fTsgICAvLyBEYXRhRW50cmllcyBmcm9tIGRpcmVjdCBJbnB1dE5vZGUgY2hpbGRyZW4gb2YgdGhlIERhdGFOb2RlXHJcbiAgICB0aGlzLmlucHV0Q2hhbm5lbHMgPSBuZXcgQ2hhbm5lbE1hcCgpOyAgICAvLyBjaGFubmVsIG1hcCBmb3IgaW5wdXQgZGF0YSBwcmlvIHRvIG9wZXJhdG9yIGV4ZWN1dGlvblxyXG4gICAgdGhpcy5jb21wdXRlZENoYW5uZWxzID0gbmV3IENoYW5uZWxNYXAoKTsgLy8gY2hhbm5lbCBtYXAgZXh0ZW5kIGJ5IG9wZXJhdG9yIG91dHB1dFxyXG4gICAgdGhpcy5vdXRwdXRDaGFubmVscyA9IG5ldyBDaGFubmVsTWFwKCk7ICAgLy8gY2hhbm5lbCBtYXAgd2l0aCBhcHBsaWVkIGZpbHRlciA9PiBmaW5hbCBvdXRwdXRcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wZXJhdG9yIGF0dGFjaGVkIHRvIERhdGFOb2RlIChndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkKVxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcGVyYXRvciA9IG51bGw7XHJcbiAgICAvKipcclxuICAgICAqIENoYW5uZWwgbm9kZSBvZiB0aGUgZGF0YWZsb3dOb2RlIChhbmFsb2d1ZSB0byBkYXRhZmxvd05vZGUgb2YgRGF0YU5vZGUpXHJcbiAgICAgKiBAdHlwZSB7Q2hhbm5lbE5vZGV9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGF0YWZsb3dDaGFubmVsTm9kZSA9IG51bGw7XHJcbiAgICAvKipcclxuICAgICAqIFByb2Nlc3Mgbm9kZSAtIG9ubHkgY29uc3RydWN0ZWQgaWYgYW4gb3BlcmF0b3IvZGF0YWZsb3cgaXMgZGVmaW5lZFxyXG4gICAgICogQHR5cGUge1Byb2Nlc3NOb2RlfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnByb2Nlc3NOb2RlID0gbnVsbDtcclxuICAgIC8qKlxyXG4gICAgICogUmVxdWVzdCBOb2RlcyBjcmVhdGVkIGZvciBlYWNoIHJlc3VsdCByZXF1ZXN0IG9uIHRoaXMgZGF0YU5vZGUuXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxTdHJpbmcsUmVxdWVzdE5vZGU+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlcXVlc3ROb2RlcyA9IHt9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBOdW1iZXIgb2YgdXNlcyBvZiBjaGFubmVsIG5vZGUuIFRoaXMgaXMgb25seSByZWxldmFudCBmb3IgY2hhbm5lbCBub2RlcyBjcmVhdGVkIHdpdGggc3Vic3RpdHV0aW9uLlxyXG4gICAgICogVGhlc2Ugbm9kZXMgYXJlIGNhY2hlZCBhbmQgdGhlIHVzZUNvdW50IGlzIHVzZWQgdG8gY2xlYW4gdGhpcyBjYWNoZS5cclxuICAgICAqIFRPRE86IFVzZSB3ZWFrbWFwIGhlcmUgdG8gYXZvaWQgZXhwbGljaXQgcmVmZXJlbmNlIGNvdW50XHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnVzZUNvdW50ID0gMTtcclxuICAgIC8qKlxyXG4gICAgICogVHJ1ZSBpZiB0aGUgY2hhbm5lbCBub2RlIGlzIG91dCBvZiBzeW5jIGFuZCBpbnRlcm5hbCBjaGFubmVsIG1hcHMgbmVlZCB0byBiZSByZWNvbnN0cnVjdGVkXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vdXRPZlN5bmMgPSB0cnVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIElmIG5vZGUgaXMgb3V0IG9mIHN5bmMsIHJlY29uc3RydWN0IGFsbCBjaGFubmVsc1xyXG4gKi9cclxuQ2hhbm5lbE5vZGUucHJvdG90eXBlLnN5bmNocm9uaXplID0gZnVuY3Rpb24oKXtcclxuXHJcbiAgICBpZih0aGlzLm91dE9mU3luYyl7XHJcbiAgICAgICAgdXBkYXRlUGxhdGZvcm0odGhpcyk7XHJcbiAgICAgICAgc3luY2hyb25pemVDaGlsZHJlbih0aGlzKTtcclxuICAgICAgICB1cGRhdGVJbnB1dENoYW5uZWxzKHRoaXMpO1xyXG4gICAgICAgIHVwZGF0ZUNvbXB1dGVkQ2hhbm5lbHModGhpcyk7XHJcbiAgICAgICAgdXBkYXRlT3V0cHV0Q2hhbm5lbHModGhpcyk7XHJcbiAgICAgICAgdGhpcy5vdXRPZlN5bmMgPSBmYWxzZTtcclxuICAgIH1cclxufTtcclxuXHJcbkNoYW5uZWxOb2RlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLnVzZUNvdW50ID0gMDtcclxuICAgIHRoaXMuaW5wdXRDaGFubmVscy5jbGVhcigpO1xyXG4gICAgdGhpcy5vdXRwdXRDaGFubmVscy5jbGVhcigpO1xyXG4gICAgZGVsZXRlIHRoaXMub3duZXI7XHJcbiAgICB2YXIgcmVxcyA9IE9iamVjdC5rZXlzKHRoaXMucmVxdWVzdE5vZGVzKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVxcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRoaXMucmVxdWVzdE5vZGVzW3JlcXNbaV1dLmNsZWFyKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnJlcXVlc3ROb2RlcyA9IHt9O1xyXG59O1xyXG5cclxuQ2hhbm5lbE5vZGUucHJvdG90eXBlLmluY3JlYXNlUmVmID0gZnVuY3Rpb24oKXtcclxuICAgIHRoaXMudXNlQ291bnQrKztcclxufTtcclxuXHJcbkNoYW5uZWxOb2RlLnByb3RvdHlwZS5kZWNyZWFzZVJlZiA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLnVzZUNvdW50LS07XHJcbiAgICBpZih0aGlzLnVzZUNvdW50ID09IDApe1xyXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbkNoYW5uZWxOb2RlLnByb3RvdHlwZS5nZXRPdXRwdXROYW1lcyA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLnN5bmNocm9uaXplKCk7XHJcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRDaGFubmVscy5nZXROYW1lcygpO1xyXG59O1xyXG5cclxuQ2hhbm5lbE5vZGUucHJvdG90eXBlLmdldENoaWxkRGF0YUluZGV4ID0gZnVuY3Rpb24oZmlsdGVyKXtcclxuICAgIHRoaXMuc3luY2hyb25pemUoKTtcclxuICAgIHJldHVybiB0aGlzLm91dHB1dENoYW5uZWxzLmdldENoaWxkRGF0YUluZGV4Rm9yRmlsdGVyKGZpbHRlcik7XHJcbn07XHJcblxyXG5DaGFubmVsTm9kZS5wcm90b3R5cGUuc2V0U3RydWN0dXJlT3V0T2ZTeW5jID0gZnVuY3Rpb24oKVxyXG57XHJcbiAgICBpZighdGhpcy5vdXRPZlN5bmMpe1xyXG4gICAgICAgIHRoaXMub3V0T2ZTeW5jID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmlucHV0Q2hhbm5lbHMuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmNvbXB1dGVkQ2hhbm5lbHMuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLm91dHB1dENoYW5uZWxzLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzTm9kZSAmJiB0aGlzLnByb2Nlc3NOb2RlLmNsZWFyKCk7XHJcbiAgICAgICAgZm9yKHZhciBrZXkgaW4gdGhpcy5yZXF1ZXN0Tm9kZXMpe1xyXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3ROb2Rlc1trZXldLnNldFN0cnVjdHVyZU91dE9mU3luYygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0aGlzLmRhdGFmbG93Q2hhbm5lbE5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhZmxvd0NoYW5uZWxOb2RlLnNldFN0cnVjdHVyZU91dE9mU3luYygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbkNoYW5uZWxOb2RlLnByb3RvdHlwZS5ub3RpZnlEYXRhQ2hhbmdlID0gZnVuY3Rpb24oaW5wdXROb2RlLCBjaGFuZ2VUeXBlKXtcclxuICAgIHZhciBrZXkgPSBpbnB1dE5vZGUuX25hbWUgKyBcIjtcIiArIGlucHV0Tm9kZS5fa2V5O1xyXG4gICAgaWYodGhpcy5pbnB1dFNsb3RzW2tleV0pXHJcbiAgICAgICAgdGhpcy5pbnB1dFNsb3RzW2tleV0uc2V0RGF0YUVudHJ5KGlucHV0Tm9kZS5fZGF0YSwgY2hhbmdlVHlwZSk7XHJcbn07XHJcblxyXG5DaGFubmVsTm9kZS5wcm90b3R5cGUuZ2V0UmVzdWx0ID0gZnVuY3Rpb24odHlwZSwgZmlsdGVyKSB7XHJcbiAgICB0aGlzLnN5bmNocm9uaXplKCk7XHJcblxyXG4gICAgdmFyIGtleSA9IGZpbHRlciA/IGZpbHRlci5qb2luKFwiO1wiKSA6IFwiW251bGxdXCI7XHJcbiAgICBpZighdGhpcy5yZXF1ZXN0Tm9kZXNba2V5XSl7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0Tm9kZXNba2V5XSA9IG5ldyBSZXF1ZXN0Tm9kZSh0aGlzLCBmaWx0ZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdE5vZGVzW2tleV0uZ2V0UmVzdWx0KHR5cGUpO1xyXG59O1xyXG5cclxuXHJcbkNoYW5uZWxOb2RlLnByb3RvdHlwZS5nZXRPdXRwdXRDaGFubmVsSW5mbyA9IGZ1bmN0aW9uKG5hbWUpe1xyXG4gICAgdGhpcy5zeW5jaHJvbml6ZSgpO1xyXG5cclxuICAgIHZhciBjaGFubmVsID0gdGhpcy5vdXRwdXRDaGFubmVscy5nZXRDaGFubmVsKG5hbWUpO1xyXG4gICAgaWYoIWNoYW5uZWwpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB2YXIgcmVzdWx0ID0ge1xyXG4gICAgICAgIHR5cGU6IGNoYW5uZWwuZ2V0VHlwZSgpLFxyXG4gICAgICAgIHNlcUxlbmd0aDogY2hhbm5lbC5nZXRTZXF1ZW5jZUxlbmd0aCgpLFxyXG4gICAgICAgIHNlcU1pbktleTogY2hhbm5lbC5nZXRTZXF1ZW5jZU1pbktleSgpLFxyXG4gICAgICAgIHNlcU1heEtleTogY2hhbm5lbC5nZXRTZXF1ZW5jZU1heEtleSgpLFxyXG4gICAgICAgIG9yaWdpbjogMCxcclxuICAgICAgICBvcmlnaW5hbE5hbWU6IFwiXCJcclxuICAgIH07XHJcbiAgICB2YXIgcHJlRmlsdGVyTmFtZSA9IHRoaXMub3duZXIuX2ZpbHRlck1hcHBpbmcgPyB0aGlzLm93bmVyLl9maWx0ZXJNYXBwaW5nLmdldFJlbmFtZVNyY05hbWUobmFtZSkgOiBuYW1lO1xyXG4gICAgdmFyIGRhdGFFbnRyeSA9IGNoYW5uZWwuZ2V0RGF0YUVudHJ5KCk7XHJcbiAgICBpZih0aGlzLmRhdGFmbG93Q2hhbm5lbE5vZGUpe1xyXG4gICAgICAgIHZhciBwcm90b0lucHV0Q2hhbm5lbCA9IHRoaXMuaW5wdXRDaGFubmVscy5nZXRDaGFubmVsKHByZUZpbHRlck5hbWUpO1xyXG4gICAgICAgIGlmKCFwcm90b0lucHV0Q2hhbm5lbCB8fCBkYXRhRW50cnkgIT0gcHJvdG9JbnB1dENoYW5uZWwuZ2V0RGF0YUVudHJ5KCkpe1xyXG4gICAgICAgICAgICByZXN1bHQub3JpZ2luID0gQy5PUklHSU4uUFJPVE87XHJcbiAgICAgICAgICAgIHJlc3VsdC5vcmlnaW5hbE5hbWUgPSBwcmVGaWx0ZXJOYW1lO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmKHRoaXMub3BlcmF0b3Ipe1xyXG4gICAgICAgIHZhciBpbnB1dENoYW5uZWwgPSB0aGlzLmlucHV0Q2hhbm5lbHMuZ2V0Q2hhbm5lbChwcmVGaWx0ZXJOYW1lKTtcclxuICAgICAgICBpZighaW5wdXRDaGFubmVsIHx8IGRhdGFFbnRyeSAhPSBpbnB1dENoYW5uZWwuZ2V0RGF0YUVudHJ5KCkpe1xyXG4gICAgICAgICAgICByZXN1bHQub3JpZ2luID0gQy5PUklHSU4uQ09NUFVURTtcclxuICAgICAgICAgICAgcmVzdWx0Lm9yaWdpbmFsTmFtZSA9IHRoaXMub3duZXIuX2NvbXB1dGVPdXRwdXRNYXBwaW5nLmdldFNjcmlwdE91dHB1dE5hbWVJbnYocHJlRmlsdGVyTmFtZSwgdGhpcy5vcGVyYXRvci5vdXRwdXRzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXN1bHQub3JpZ2luID0gQy5PUklHSU4uQ0hJTEQ7XHJcbiAgICByZXN1bHQub3JpZ2luYWxOYW1lID0gcHJlRmlsdGVyTmFtZTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogU2VsZWN0IHRoZSBwbGF0Zm9ybSB0byBjb21wdXRlIHRoZSBhdHRhY2hlZCBwbGF0Zm9ybVxyXG4gKiBAcGFyYW0ge0NoYW5uZWxOb2RlfSBjaGFubmVsTm9kZVxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlUGxhdGZvcm0oY2hhbm5lbE5vZGUpIHtcclxuICAgIHZhciBwbGF0Zm9ybTtcclxuICAgIHZhciBvd25lciA9IGNoYW5uZWxOb2RlLm93bmVyO1xyXG5cclxuICAgIC8vIFBsYXRmb3JtcyBvdGhlciB0aGFuIEphdmFTY3JpcHQgYXJlIGF2YWlsYWJsZSBvbmx5IGZvciBjb21wdXRpbmcgb3BlcmF0b3JzXHJcbiAgICBpZighY2hhbm5lbE5vZGUub3duZXIuX2NvbXB1dGVPcGVyYXRvcikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvL1RPRE86IEltcHJvdmUgcGxhdGZvcm0gc2VsZWN0aW9uIGxvZ2ljLlxyXG4gICAgLy8gQ3VycmVudGx5IHdlIHVzZSBmb3JjZWQgcGxhdGZvcm0gaWYgZ3JhcGggcGxhdGZvcm0gaXMgc29tZXRoaW5nIG90aGVyIHRoYW4gSmF2YVNjcmlwdFxyXG4gICAgLy8gYW5kIGZvcmNlZCBwbGF0Zm9ybSAob3duZXIuX3BsYXRmb3JtKSBpcyBkZWZpbmVkXHJcbiAgICBwbGF0Zm9ybSA9IG93bmVyLl9wbGF0Zm9ybSAhPT0gbnVsbCA/IG93bmVyLl9wbGF0Zm9ybSA6IEMuUExBVEZPUk0uSkFWQVNDUklQVDtcclxuXHJcbiAgICBjaGFubmVsTm9kZS5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xyXG59XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHtDaGFubmVsTm9kZX0gY2hhbm5lbE5vZGVcclxuICovXHJcbmZ1bmN0aW9uIHN5bmNocm9uaXplQ2hpbGRyZW4oY2hhbm5lbE5vZGUpe1xyXG4gICAgdmFyIGRhdGFOb2RlID0gY2hhbm5lbE5vZGUub3duZXI7XHJcbiAgICBjaGFubmVsTm9kZS5sb2FkaW5nID0gZGF0YU5vZGUuaXNTdWJ0cmVlTG9hZGluZygpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIGNoYW5uZWwgbm9kZSByZXByZXNlbnRzIGEgc3Vic3RpdHV0aW9uLCB3ZSBhbHNvIG5lZWQgdG9cclxuICAgICAqIHN5bmNocm9uaXplIHRoZSBtYWluIENoYW5uZWxOb2RlIG9mIHRoZSBEYXRhTm9kZVxyXG4gICAgICovXHJcbiAgICBpZihjaGFubmVsTm9kZS5zdWJzdGl0dXRpb24pIHtcclxuICAgICAgICBkYXRhTm9kZS5fY2hhbm5lbE5vZGUuc3luY2hyb25pemUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOb3cgc3luY2hyb25pemUgYWxsIGNoaWxkcmVuIChlaXRoZXIgcmVmZXJlbmNlZCBkYXRhIG5vZGUsIG9yIHJlYWwgY2hpbGRyZW4pXHJcbiAgICAvLyBUT0RPOiBDaGFuZ2UgaGVyZSBpZiB3ZSBjaGFuZ2UgYmVoYXZpb3VyIG9mIHNyYyBhdHRyaWJ1dGVcclxuICAgIGlmKGRhdGFOb2RlLl9zb3VyY2VOb2RlKXtcclxuICAgICAgICBkYXRhTm9kZS5fc291cmNlTm9kZS5fZ2V0T3JDcmVhdGVDaGFubmVsTm9kZShjaGFubmVsTm9kZS5zdWJzdGl0dXRpb24pLnN5bmNocm9uaXplKCk7XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBkYXRhTm9kZS5fY2hpbGRyZW4ubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICBpZihkYXRhTm9kZS5fY2hpbGRyZW5baV0uX2dldE9yQ3JlYXRlQ2hhbm5lbE5vZGUpe1xyXG4gICAgICAgICAgICAgICAgZGF0YU5vZGUuX2NoaWxkcmVuW2ldLl9nZXRPckNyZWF0ZUNoYW5uZWxOb2RlKGNoYW5uZWxOb2RlLnN1YnN0aXR1dGlvbikuc3luY2hyb25pemUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7Q2hhbm5lbE5vZGV9IGNoYW5uZWxOb2RlXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGVJbnB1dENoYW5uZWxzKGNoYW5uZWxOb2RlKXtcclxuICAgIHZhciBvd25lciA9IGNoYW5uZWxOb2RlLm93bmVyO1xyXG4gICAgLy8gVE9ETzogQ2hhbmdlIGhlcmUgaWYgd2UgY2hhbmdlIGJlaGF2aW91ciBvZiBzcmMgYXR0cmlidXRlXHJcbiAgICBpZihvd25lci5fc291cmNlTm9kZSl7XHJcbiAgICAgICAgY2hhbm5lbE5vZGUuaW5wdXRDaGFubmVscy5tZXJnZShvd25lci5fc291cmNlTm9kZS5fZ2V0T3JDcmVhdGVDaGFubmVsTm9kZShjaGFubmVsTm9kZS5zdWJzdGl0dXRpb24pLm91dHB1dENoYW5uZWxzLCAwKTtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gb3duZXIuX2NoaWxkcmVuO1xyXG4gICAgICAgIC8vIEZpcnN0IHRoZSBEYXRhTm9kZXMgdGhhbiB0aGUgaW5wdXQgbm9kZXMgaW4gb3JkZXIgdG8gb3ZlcnJpZGUgdGhlIERhdGFOb2RlIGNoYW5uZWxzXHJcbiAgICAgICAgbWVyZ2VJbnB1dENoYW5uZWxEYXRhTm9kZXMoY2hhbm5lbE5vZGUsIGNoaWxkcmVuKTtcclxuICAgICAgICBtZXJnZUlucHV0Q2hhbm5lbElucHV0Tm9kZXMoY2hhbm5lbE5vZGUsIGNoaWxkcmVuKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7Q2hhbm5lbE5vZGV9IGNoYW5uZWxOb2RlXHJcbiAqIEBwYXJhbSB7QXJyYXkuPEdyYXBoTm9kZT59IGNoaWxkcmVuXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZUlucHV0Q2hhbm5lbElucHV0Tm9kZXMoY2hhbm5lbE5vZGUsIGNoaWxkcmVuKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgaWYgKCFjaGlsZHJlbltpXS5fZ2V0T3JDcmVhdGVDaGFubmVsTm9kZSkgeyAgLy8gQ2hpbGQgaXMgYW4gSW5wdXROb2RlXHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gY2hpbGQuX25hbWUgKyBcIjtcIiArIGNoaWxkLl9rZXk7XHJcbiAgICAgICAgICAgIGlmICghY2hhbm5lbE5vZGUuc3Vic3RpdHV0aW9uKSB7ICAvLyBObyBkYXRhZmxvd1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsb3QgPSBuZXcgRGF0YVNsb3QoY2hpbGQuX2RhdGEsIGNoaWxkLl9rZXkpO1xyXG4gICAgICAgICAgICAgICAgY2hhbm5lbE5vZGUuaW5wdXRTbG90c1trZXldID0gc2xvdDtcclxuICAgICAgICAgICAgICAgIGNoYW5uZWxOb2RlLmlucHV0Q2hhbm5lbHMuYWRkRGF0YUVudHJ5KGNoaWxkLl9uYW1lLCBzbG90KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5fcGFyYW1OYW1lICYmIGNoYW5uZWxOb2RlLnN1YnN0aXR1dGlvbi5oYXNDaGFubmVsKGNoaWxkLl9wYXJhbU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbE5vZGUuaW5wdXRDaGFubmVscy5hZGRDaGFubmVsKGNoaWxkLl9uYW1lLCBjaGFubmVsTm9kZS5zdWJzdGl0dXRpb24uZ2V0Q2hhbm5lbChjaGlsZC5fcGFyYW1OYW1lKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxOb2RlLmlucHV0Q2hhbm5lbHMuYWRkRGF0YUVudHJ5KGNoaWxkLl9uYW1lLCBjaGFubmVsTm9kZS5vd25lci5fY2hhbm5lbE5vZGUuaW5wdXRTbG90c1trZXldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7Q2hhbm5lbE5vZGV9IGNoYW5uZWxOb2RlXHJcbiAqIEBwYXJhbSB7QXJyYXkuPEdyYXBoTm9kZT59IGNoaWxkcmVuXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZUlucHV0Q2hhbm5lbERhdGFOb2RlcyhjaGFubmVsTm9kZSwgY2hpbGRyZW4pIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBpZiAoY2hpbGRyZW5baV0uX2dldE9yQ3JlYXRlQ2hhbm5lbE5vZGUpIHsgIC8vIENoaWxkIGlzIGEgRGF0YU5vZGVcclxuICAgICAgICAgICAgY2hhbm5lbE5vZGUuaW5wdXRDaGFubmVscy5tZXJnZShjaGlsZHJlbltpXS5fZ2V0T3JDcmVhdGVDaGFubmVsTm9kZShjaGFubmVsTm9kZS5zdWJzdGl0dXRpb24pLm91dHB1dENoYW5uZWxzLCBpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUNvbXB1dGVkQ2hhbm5lbHMoY2hhbm5lbE5vZGUpe1xyXG4gICAgdmFyIG93bmVyID0gY2hhbm5lbE5vZGUub3duZXI7XHJcbiAgICBjaGFubmVsTm9kZS5jb21wdXRlZENoYW5uZWxzLm1lcmdlKGNoYW5uZWxOb2RlLmlucHV0Q2hhbm5lbHMpO1xyXG5cclxuICAgIHZhciBvbGREYXRhZmxvd0NoYW5uZWxOb2RlID0gY2hhbm5lbE5vZGUuZGF0YWZsb3dDaGFubmVsTm9kZTtcclxuXHJcbiAgICBpZiggb3duZXIuX2NvbXB1dGVVc2VzRGF0YWZsb3cgJiYgb3duZXIuX2RhdGFmbG93Tm9kZSl7XHJcbiAgICAgICAgY2hhbm5lbE5vZGUub3BlcmF0b3IgPSBudWxsO1xyXG4gICAgICAgIHVwZGF0ZURhdGFmbG93Q2hhbm5lbE5vZGUoY2hhbm5lbE5vZGUpO1xyXG4gICAgICAgIHVwZGF0ZUNvbXB1dGVkQ2hhbm5lbHNGcm9tRGF0YWZsb3coY2hhbm5lbE5vZGUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZighb3duZXIuX2NvbXB1dGVVc2VzRGF0YWZsb3cgJiYgb3duZXIuX2NvbXB1dGVPcGVyYXRvcil7XHJcbiAgICAgICAgY2hhbm5lbE5vZGUuZGF0YWZsb3dDaGFubmVsTm9kZSA9IG51bGw7XHJcbiAgICAgICAgdXBkYXRlT3BlcmF0b3IoY2hhbm5lbE5vZGUpO1xyXG4gICAgICAgIHVwZGF0ZUNvbXB1dGVkQ2hhbm5lbHNGcm9tT3BlcmF0b3IoY2hhbm5lbE5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKG9sZERhdGFmbG93Q2hhbm5lbE5vZGUgJiYgb2xkRGF0YWZsb3dDaGFubmVsTm9kZSAhPSBjaGFubmVsTm9kZS5kYXRhZmxvd0NoYW5uZWxOb2RlKXtcclxuICAgICAgICBvbGREYXRhZmxvd0NoYW5uZWxOb2RlLm93bmVyLl9yZW1vdmVTdWJzdGl0dXRpb25Ob2RlKG9sZERhdGFmbG93Q2hhbm5lbE5vZGUpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogRmluZCBhbmQgc2V0IHRoZSBvcGVyYXRvciBmb3IgdGhlIGdpdmVuIENoYW5uZWxOb2RlXHJcbiAqIEBwYXJhbSBjaGFubmVsTm9kZVxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlT3BlcmF0b3IoY2hhbm5lbE5vZGUpe1xyXG4gICAgdmFyIG9wZXJhdG9yTmFtZSwgb3BlcmF0b3I7XHJcbiAgICB2YXIgb3duZXIgPSBjaGFubmVsTm9kZS5vd25lcjtcclxuXHJcbiAgICBpZihjaGFubmVsTm9kZS5sb2FkaW5nKXtcclxuICAgICAgICBjaGFubmVsTm9kZS5vcGVyYXRvciA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYodHlwZW9mIG93bmVyLl9jb21wdXRlT3BlcmF0b3IgPT0gXCJzdHJpbmdcIil7XHJcbiAgICAgICAgb3BlcmF0b3JOYW1lID0gb3duZXIuX2NvbXB1dGVPcGVyYXRvcjtcclxuICAgICAgICBvcGVyYXRvciA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIEdldHRpbmcgYSBjb3JyZWN0IG9wZXJhdG9yIGZvciB0aGUgc2VsZWN0ZWQgcGxhdGZvcm0uIElmIG9wZXJhdG9yIGlzIG5vdCBhdmFpbGFibGUsIHdlJ2xsIHRyeSB0byBnZXRcclxuICAgICAgICAvLyB0aGUgZGVmYXVsdCBKYXZhU2NyaXB0IHBsYXRmb3JtIG9wZXJhdG9yXHJcbiAgICAgICAgaWYob3BlcmF0b3JOYW1lKXtcclxuICAgICAgICAgICAgb3BlcmF0b3IgPSBmaW5kT3BlcmF0b3JCeU5hbWUoY2hhbm5lbE5vZGUsIG93bmVyKTtcclxuICAgICAgICAgICAgaWYob3BlcmF0b3IpIHsgLy8gVE9ETzogSXMgdGhpcyBnb29kPyBXZSBjYWxjdWxhdGVkIHRoZSBwbGF0Zm9ybSBiZWZvcmUsIG5vdyBpdCBqdXN0IGdldHMgb3ZlcnJpZGVuXHJcbiAgICAgICAgICAgICAgICBjaGFubmVsTm9kZS5wbGF0Zm9ybSA9IG9wZXJhdG9yLnBsYXRmb3JtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoYW5uZWxOb2RlLm9wZXJhdG9yID0gb3BlcmF0b3I7XHJcbiAgICB9ZWxzZXtcclxuICAgICAgICBjaGFubmVsTm9kZS5vcGVyYXRvciA9IG93bmVyLl9jb21wdXRlT3BlcmF0b3I7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBjX3R5cGVDb21wYXJpc29ucyA9IFtdO1xyXG5cclxuLyoqXHJcbiAqIEZpbmQgb3BlcmF0b3IgYmFzZWQgb24gbmFtZSBpbiBkYXRhTm9kZSwgcGxhdGZvcm0gYW5kIGlucHV0IG1hcHBpbmcgKHNpZ25hdHVyZSlcclxuICogQHBhcmFtIHtDaGFubmVsTm9kZX0gY2hhbm5lbE5vZGVcclxuICogQHBhcmFtIHtEYXRhTm9kZX0gZGF0YU5vZGVcclxuICogQHJldHVybnMge09iamVjdHxudWxsfVxyXG4gKi9cclxuZnVuY3Rpb24gZmluZE9wZXJhdG9yQnlOYW1lKGNoYW5uZWxOb2RlLCBkYXRhTm9kZSl7XHJcbiAgICB2YXIgb3BlcmF0b3JOYW1lID0gZGF0YU5vZGUuX2NvbXB1dGVPcGVyYXRvcixcclxuICAgICAgICBpbnB1dE1hcHBpbmcgPSBkYXRhTm9kZS5fY29tcHV0ZUlucHV0TWFwcGluZyxcclxuICAgICAgICBpbnB1dENoYW5uZWxzID0gY2hhbm5lbE5vZGUuaW5wdXRDaGFubmVscztcclxuXHJcbiAgICB2YXIgb3BlcmF0b3JzID0gT3BlcmF0b3IuZ2V0T3BlcmF0b3JzKG9wZXJhdG9yTmFtZSwgY2hhbm5lbE5vZGUucGxhdGZvcm0pIHx8XHJcbiAgICAgICAgICAgICAgICBPcGVyYXRvci5nZXRPcGVyYXRvcnMob3BlcmF0b3JOYW1lLCBDLlBMQVRGT1JNLkpBVkFTQ1JJUFQpO1xyXG4gICAgaWYoIW9wZXJhdG9ycyl7XHJcbiAgICAgICAgQmFzZS5ub3RpZnlFcnJvcihcIk5vIG9wZXJhdG9yIHdpdGggbmFtZSAnXCIgKyBvcGVyYXRvck5hbWUrXCInIGZvdW5kXCIsIGNoYW5uZWxOb2RlLm93bmVyKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaSA9IG9wZXJhdG9ycy5sZW5ndGg7XHJcbiAgICB3aGlsZShpLS0pe1xyXG4gICAgICAgIGlmKGNoZWNrT3BlcmF0b3Iob3BlcmF0b3JzW2ldLCBpbnB1dE1hcHBpbmcsIGlucHV0Q2hhbm5lbHMpKXtcclxuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdG9yc1tpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjX3R5cGVDb21wYXJpc29ucy5sZW5ndGggPSAwO1xyXG4gICAgaSA9IG9wZXJhdG9ycy5sZW5ndGg7XHJcbiAgICB3aGlsZShpLS0pe1xyXG4gICAgICAgIGNoZWNrT3BlcmF0b3Iob3BlcmF0b3JzW2ldLCBpbnB1dE1hcHBpbmcsIGlucHV0Q2hhbm5lbHMsIGNfdHlwZUNvbXBhcmlzb25zKTtcclxuICAgIH1cclxuICAgIHZhciBlcnJvck1lc3NhZ2UgPSBcIk5vIG9wZXJhdG9yICdcIiArIG9wZXJhdG9yTmFtZStcIicgd2l0aCBtYXRjaGluZyB0eXBlIHNpZ25hdHVyZSBmb3VuZDpcXG5cXG5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICArIGNfdHlwZUNvbXBhcmlzb25zLmpvaW4oXCJcXG5cIik7XHJcbiAgICBCYXNlLm5vdGlmeUVycm9yKGVycm9yTWVzc2FnZSwgY2hhbm5lbE5vZGUub3duZXIpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gb3BlcmF0b3JcclxuICogQHBhcmFtIGlucHV0TWFwcGluZ1xyXG4gKiBAcGFyYW0gaW5wdXRDaGFubmVsc1xyXG4gKiBAcGFyYW0ge0FycmF5P30gdHlwZUNvbXBhcmlzb25zT3V0cHV0IElmIGFycmF5IGlzIGdpdmUsIHNhdmUgZXJyb3IgaW5mb3JtYXRpb25cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBjaGVja09wZXJhdG9yKG9wZXJhdG9yLCBpbnB1dE1hcHBpbmcsIGlucHV0Q2hhbm5lbHMsIHR5cGVDb21wYXJpc29uc091dHB1dCl7XHJcbiAgICB2YXIgaW5wdXRzLCBlcnJvcnM7XHJcbiAgICBpZih0eXBlQ29tcGFyaXNvbnNPdXRwdXQpe1xyXG4gICAgICAgIGlucHV0cyA9IFtdOyBlcnJvcnMgPSBbXTtcclxuICAgIH1cclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvcGVyYXRvci5wYXJhbXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIHZhciBpbnB1dEVudHJ5ID0gb3BlcmF0b3IucGFyYW1zW2ldLCBzb3VyY2VOYW1lID0gaW5wdXRFbnRyeS5zb3VyY2U7XHJcbiAgICAgICAgdmFyIGRhdGFOYW1lID0gaW5wdXRNYXBwaW5nID8gaW5wdXRNYXBwaW5nLmdldFNjcmlwdElucHV0TmFtZShpLCBzb3VyY2VOYW1lKSA6IHNvdXJjZU5hbWU7XHJcbiAgICAgICAgdmFyIGVycm9ySGVhZGVyO1xyXG4gICAgICAgIGlmKHR5cGVDb21wYXJpc29uc091dHB1dCl7XHJcbiAgICAgICAgICAgIGVycm9ySGVhZGVyID0gXCJGb3IgXCIgKyAoaSsxKSArIFwiLiBhcmd1bWVudCAnXCIgKyBzb3VyY2VOYW1lICsgXCInOiBcIjtcclxuICAgICAgICAgICAgaW5wdXRzLnB1c2goIEMuZ2V0VHlwZU5hbWUoaW5wdXRFbnRyeS50eXBlKSArIFwiIFwiICsgc291cmNlTmFtZSArIChpbnB1dEVudHJ5Lm9wdGlvbmFsID8gXCIgW29wdGlvbmFsXVwiIDogXCJcIikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihkYXRhTmFtZSl7XHJcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gaW5wdXRDaGFubmVscy5nZXRDaGFubmVsKGRhdGFOYW1lKTtcclxuICAgICAgICAgICAgaWYoIWNoYW5uZWwgJiYgIWlucHV0RW50cnkub3B0aW9uYWwpe1xyXG4gICAgICAgICAgICAgICAgaWYoIXR5cGVDb21wYXJpc29uc091dHB1dClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9ySGVhZGVyICsgXCJEYXRhRW50cnkgJ1wiICsgZGF0YU5hbWUgKyBcIicgZG9lcyBub3QgZXhpc3RcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoY2hhbm5lbCAmJiBjaGFubmVsLmdldFR5cGUoKSAhPSBpbnB1dEVudHJ5LnR5cGUpe1xyXG4gICAgICAgICAgICAgICAgaWYoIXR5cGVDb21wYXJpc29uc091dHB1dClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9ySGVhZGVyICsgXCJEYXRhRW50cnkgJ1wiICsgZGF0YU5hbWUgKyBcIicgaGFzIHdyb25nIHR5cGUgJ1wiICsgQy5nZXRUeXBlTmFtZShjaGFubmVsLmdldFR5cGUoKSkgKyBcIidcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZih0eXBlQ29tcGFyaXNvbnNPdXRwdXQpe1xyXG4gICAgICAgIHR5cGVDb21wYXJpc29uc091dHB1dC5wdXNoKG9wZXJhdG9yLm5hbWUgKyBcIihcIiArIGlucHV0cy5qb2luKFwiLCBcIikgKyBcIilcXG5cXHQgKiBcIiArIGVycm9ycy5qb2luKFwiXFxuXFx0ICogXCIpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIGNoYW5uZWxOb2RlXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGVDb21wdXRlZENoYW5uZWxzRnJvbU9wZXJhdG9yKGNoYW5uZWxOb2RlKXtcclxuICAgIHZhciBvd25lciA9IGNoYW5uZWxOb2RlLm93bmVyO1xyXG4gICAgaWYoY2hhbm5lbE5vZGUub3BlcmF0b3Ipe1xyXG4gICAgICAgIHZhciBwcm9jTm9kZSA9IGNoYW5uZWxOb2RlLnByb2Nlc3NOb2RlID0gbmV3IFByb2Nlc3NOb2RlKGNoYW5uZWxOb2RlKTtcclxuICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgICAgIGZvcih2YXIgbmFtZSBpbiBwcm9jTm9kZS5vdXRwdXREYXRhU2xvdHMpe1xyXG4gICAgICAgICAgICB2YXIgZGVzdE5hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICBpZihvd25lci5fY29tcHV0ZU91dHB1dE1hcHBpbmcpIGRlc3ROYW1lID0gb3duZXIuX2NvbXB1dGVPdXRwdXRNYXBwaW5nLmdldFNjcmlwdE91dHB1dE5hbWUoaW5kZXgsIG5hbWUpO1xyXG4gICAgICAgICAgICBpZihkZXN0TmFtZSl7XHJcbiAgICAgICAgICAgICAgICBjaGFubmVsTm9kZS5jb21wdXRlZENoYW5uZWxzLmFkZE91dHB1dERhdGFTbG90KGRlc3ROYW1lLCBwcm9jTm9kZS5vdXRwdXREYXRhU2xvdHNbbmFtZV0sIHByb2NOb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7Q2hhbm5lbE5vZGV9IGNoYW5uZWxOb2RlXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGVEYXRhZmxvd0NoYW5uZWxOb2RlKGNoYW5uZWxOb2RlKXtcclxuICAgIHZhciBvd25lciA9IGNoYW5uZWxOb2RlLm93bmVyO1xyXG4gICAgdmFyIHN1YlN1YnN0aXR1dGlvbiA9IG5ldyBTdWJzdGl0dXRpb24ob3duZXIuX2RhdGFmbG93Tm9kZSwgY2hhbm5lbE5vZGUpO1xyXG4gICAgY2hhbm5lbE5vZGUuZGF0YWZsb3dDaGFubmVsTm9kZSA9IG93bmVyLl9kYXRhZmxvd05vZGUuX2dldE9yQ3JlYXRlQ2hhbm5lbE5vZGUoc3ViU3Vic3RpdHV0aW9uKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7Q2hhbm5lbE5vZGV9IGNoYW5uZWxOb2RlXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGVDb21wdXRlZENoYW5uZWxzRnJvbURhdGFmbG93KGNoYW5uZWxOb2RlKXtcclxuICAgIHZhciBvd25lciA9IGNoYW5uZWxOb2RlLm93bmVyO1xyXG4gICAgaWYoY2hhbm5lbE5vZGUuZGF0YWZsb3dDaGFubmVsTm9kZSl7XHJcbiAgICAgICAgdmFyIGRhdGFmbG93Q05vZGUgPSBjaGFubmVsTm9kZS5kYXRhZmxvd0NoYW5uZWxOb2RlO1xyXG4gICAgICAgIGRhdGFmbG93Q05vZGUuc3luY2hyb25pemUoKTtcclxuICAgICAgICAvLyBUT0RPOiBXZSBoYXZlIHRvIG1ha2Ugc3VyZSB0byBnZXQgb3V0cHV0TmFtZXMgaW4gdGhlIHJpZ2h0IG9yZGVyIHRvIGFwcGx5IG91dHB1dCBtYXBwaW5nIGNvcnJlY3RseVxyXG4gICAgICAgIHZhciBvdXRwdXROYW1lcyA9IGRhdGFmbG93Q05vZGUub3V0cHV0Q2hhbm5lbHMuZ2V0TmFtZXMoKTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgb3V0cHV0TmFtZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgc3JjTmFtZSA9IG91dHB1dE5hbWVzW2ldLCBkZXN0TmFtZSA9IHNyY05hbWU7XHJcbiAgICAgICAgICAgIGlmKG93bmVyLl9jb21wdXRlT3V0cHV0TWFwcGluZylcclxuICAgICAgICAgICAgICAgIGRlc3ROYW1lID0gb3duZXIuX2NvbXB1dGVPdXRwdXRNYXBwaW5nLmdldFNjcmlwdE91dHB1dE5hbWUoaSwgc3JjTmFtZSk7XHJcbiAgICAgICAgICAgIGlmKGRlc3ROYW1lKVxyXG4gICAgICAgICAgICAgICAgY2hhbm5lbE5vZGUuY29tcHV0ZWRDaGFubmVscy5hZGRDaGFubmVsKGRlc3ROYW1lLCBkYXRhZmxvd0NOb2RlLm91dHB1dENoYW5uZWxzLmdldENoYW5uZWwoc3JjTmFtZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlT3V0cHV0Q2hhbm5lbHMoY2hhbm5lbE5vZGUpe1xyXG4gICAgdmFyIGRhdGFOb2RlID0gY2hhbm5lbE5vZGUub3duZXI7XHJcbiAgICBpZihkYXRhTm9kZS5fZmlsdGVyTWFwcGluZykge1xyXG4gICAgICAgIC8vIFRPRE86IFRoaXMgaXMgdGhlIG9ubHkgbG9jYXRpb24gd2hlcmUgYXBwbHlGaWx0ZXJPbkNoYW5uZWxNYXAgaXMgdXNlZC4gQ2FuIGJlIHNpbXBsaWZpZWQgKGUuZy4gd2l0aG91dCBjYWxsYmFjaylcclxuICAgICAgICBkYXRhTm9kZS5fZmlsdGVyTWFwcGluZy5hcHBseUZpbHRlck9uQ2hhbm5lbE1hcChjaGFubmVsTm9kZS5vdXRwdXRDaGFubmVscywgY2hhbm5lbE5vZGUuY29tcHV0ZWRDaGFubmVscywgZGF0YU5vZGUuX2ZpbHRlclR5cGUsIHNldENoYW5uZWxGaWx0ZXJDYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICAgICAgY2hhbm5lbE5vZGUub3V0cHV0Q2hhbm5lbHMubWVyZ2UoY2hhbm5lbE5vZGUuY29tcHV0ZWRDaGFubmVscyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldENoYW5uZWxGaWx0ZXJDYWxsYmFjayhkZXN0TWFwLCBkZXN0TmFtZSwgc3JjTWFwLCBzcmNOYW1lKXtcclxuICAgIHZhciBjaGFubmVsID0gc3JjTWFwLmdldENoYW5uZWwoc3JjTmFtZSk7XHJcbiAgICBkZXN0TWFwLmFkZENoYW5uZWwoZGVzdE5hbWUsIGNoYW5uZWwsIHNyY01hcC5nZXRDaGlsZERhdGFJbmRleChzcmNOYW1lKSk7XHJcbn1cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBTdWJzdGl0dXRpb25cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vKipcclxuICogVE9ETzogVGhpbmsgb2YgcmVwbGFjaW5nIHRoaXMgd2l0aCBhIGNoYW5uZWwgbWFwXHJcbiAqIEBwYXJhbSBkYXRhZmxvd05vZGVcclxuICogQHBhcmFtIHVzZXJDaGFubmVsTm9kZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBTdWJzdGl0dXRpb24gPSBmdW5jdGlvbihkYXRhZmxvd05vZGUsIHVzZXJDaGFubmVsTm9kZSl7XHJcbiAgICB0aGlzLm1hcCA9IHt9O1xyXG5cclxuICAgIGNyZWF0ZVN1YnN0aXR1dGlvbih0aGlzLCBkYXRhZmxvd05vZGUsIHVzZXJDaGFubmVsTm9kZSk7XHJcbn07XHJcblxyXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmhhc0NoYW5uZWwgPSBmdW5jdGlvbihuYW1lKXtcclxuICAgIHJldHVybiAhIXRoaXMubWFwW25hbWVdO1xyXG59O1xyXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmdldENoYW5uZWwgPSBmdW5jdGlvbihuYW1lKXtcclxuICAgIHJldHVybiB0aGlzLm1hcFtuYW1lXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBoYXNoYWJsZSBrZXkgZm9yIHRoZSBzdWJzdGl1dGlvblxyXG4gKiBAcGFyYW0gc3ViRGF0YWZsb3dOb2RlXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmdldEtleSA9IGZ1bmN0aW9uKHN1YkRhdGFmbG93Tm9kZSl7XHJcbiAgICB2YXIga2V5ID0gXCJcIjtcclxuICAgIHZhciBnbG9iYWxQYXJhbU5hbWVzID0gc3ViRGF0YWZsb3dOb2RlLl9nZXRHbG9iYWxQYXJhbU5hbWVzKCk7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZ2xvYmFsUGFyYW1OYW1lcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLm1hcFtnbG9iYWxQYXJhbU5hbWVzW2ldXTtcclxuICAgICAgICBrZXkrPSAoY2hhbm5lbCAmJiBjaGFubmVsLmlkIHx8IFwiLVwiKSArIFwiIVwiO1xyXG4gICAgfVxyXG4gICAgdmFyIHBhcmFtTmFtZXMgPSBzdWJEYXRhZmxvd05vZGUuX2dldFBhcmFtTmFtZXMoKTtcclxuICAgIGZvcihpID0gMDsgaSA8IHBhcmFtTmFtZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIGNoYW5uZWwgPSB0aGlzLm1hcFtwYXJhbU5hbWVzW2ldXTtcclxuICAgICAgICBrZXkrPSAoY2hhbm5lbCAmJiBjaGFubmVsLmlkIHx8IFwiLVwiKSArIFwiLlwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGtleTtcclxufTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N1YnN0aXR1dGlvbn0gc3Vic3RpdHV0aW9uXHJcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IGRhdGFmbG93Tm9kZVxyXG4gKiBAcGFyYW0ge0NoYW5uZWxOb2RlfSB1c2VyQ2hhbm5lbE5vZGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVN1YnN0aXR1dGlvbihzdWJzdGl0dXRpb24sIGRhdGFmbG93Tm9kZSwgdXNlckNoYW5uZWxOb2RlKXtcclxuICAgIHZhciB1c2VyT3duZXIgPSB1c2VyQ2hhbm5lbE5vZGUub3duZXI7XHJcblxyXG4gICAgLy8gRmluZCBjaGFubmVscyBmb3IgZ2xvYmFsIHBhcmFtZXRlcnNcclxuICAgIHZhciBnbG9iYWxQYXJhbU5hbWVzID0gZGF0YWZsb3dOb2RlLl9nZXRHbG9iYWxQYXJhbU5hbWVzKCk7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZ2xvYmFsUGFyYW1OYW1lcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgc3Vic3RpdHV0aW9uLm1hcFtnbG9iYWxQYXJhbU5hbWVzW2ldXSA9IHVzZXJDaGFubmVsTm9kZS5pbnB1dENoYW5uZWxzLmdldENoYW5uZWwoZ2xvYmFsUGFyYW1OYW1lc1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmluZCBjaGFubmVscyBmb3IgbG9jYWwgcGFyYW1ldGVycy4gVGhlc2Ugd2lsbCBvdmVycmlkZSBleGlzdGluZyBnbG9iYWwgcGFyYW1ldGVyc1xyXG4gICAgdmFyIHBhcmFtTmFtZXMgPSBkYXRhZmxvd05vZGUuX2dldFBhcmFtTmFtZXMoKTtcclxuICAgIGZvcihpID0gMDsgaSA8IHBhcmFtTmFtZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIHZhciBkZXN0TmFtZSA9IHBhcmFtTmFtZXNbaV0sIHNyY05hbWUgPSBkZXN0TmFtZTtcclxuICAgICAgICBpZih1c2VyT3duZXIuX2NvbXB1dGVJbnB1dE1hcHBpbmcpe1xyXG4gICAgICAgICAgICBzcmNOYW1lID0gdXNlck93bmVyLl9jb21wdXRlSW5wdXRNYXBwaW5nLmdldFNjcmlwdElucHV0TmFtZShpLCBkZXN0TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1YnN0aXR1dGlvbi5tYXBbZGVzdE5hbWVdID0gdXNlckNoYW5uZWxOb2RlLmlucHV0Q2hhbm5lbHMuZ2V0Q2hhbm5lbChzcmNOYW1lKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBDaGFubmVsTm9kZTogIENoYW5uZWxOb2RlLFxyXG4gICAgU3Vic3RpdHV0aW9uOiBTdWJzdGl0dXRpb25cclxufTtcclxuIiwidmFyIEJhc2UgPSByZXF1aXJlKFwiLi4vYmFzZS5qc1wiKTtcclxudmFyIEMgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcclxudmFyIEJ1ZmZlckVudHJ5ID0gcmVxdWlyZShcIi4uL2ludGVyZmFjZS9kYXRhLmpzXCIpLkJ1ZmZlckVudHJ5O1xyXG5cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBEYXRhU2xvdFxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gQ2hhbm5lbE1hcFxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8qKlxyXG4gKiBBIG1hcCB3aXRoIGNoYW5uZWxzLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBDaGFubmVsTWFwID0gZnVuY3Rpb24oKXtcclxuICAgIC8qKlxyXG4gICAgICogQSBtYXAgb2YgY2hhbm5lbHMuXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIHtjaGFubmVsOiBDaGFubmVsLCBjaGlsZERhdGFJbmRleDogTnVtYmVyfT59XHJcbiAgICAgKi9cclxuICAgIHRoaXMubWFwID0ge307XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhIGxpc3Qgb2YgYWxsIGtleXMuXHJcbiAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn1cclxuICovXHJcbkNoYW5uZWxNYXAucHJvdG90eXBlLmdldE5hbWVzID0gZnVuY3Rpb24oKVxyXG57XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5tYXApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBuYW1lXHJcbiAqIEByZXR1cm5zIHtDaGFubmVsfVxyXG4gKi9cclxuQ2hhbm5lbE1hcC5wcm90b3R5cGUuZ2V0Q2hhbm5lbCA9IGZ1bmN0aW9uKG5hbWUpXHJcbntcclxuICAgIGlmKCF0aGlzLm1hcFtuYW1lXSlcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIHJldHVybiB0aGlzLm1hcFtuYW1lXS5jaGFubmVsO1xyXG59O1xyXG5cclxuQ2hhbm5lbE1hcC5wcm90b3R5cGUuZ2V0Q2hpbGREYXRhSW5kZXggPSBmdW5jdGlvbihuYW1lKVxyXG57XHJcbiAgICBpZighdGhpcy5tYXBbbmFtZV0pXHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIHJldHVybiB0aGlzLm1hcFtuYW1lXS5jaGlsZERhdGFJbmRleDtcclxufTtcclxuQ2hhbm5lbE1hcC5wcm90b3R5cGUuZ2V0Q2hpbGREYXRhSW5kZXhGb3JGaWx0ZXIgPSBmdW5jdGlvbihmaWx0ZXIpe1xyXG4gICAgdmFyIHJlc3VsdDtcclxuICAgIGZpbHRlciA9IGZpbHRlciB8fCB0aGlzLmdldE5hbWVzKCk7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZmlsdGVyLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5nZXRDaGlsZERhdGFJbmRleChmaWx0ZXJbaV0pO1xyXG4gICAgICAgIGlmKGlkeCA9PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xyXG4gICAgICAgIGlmKHJlc3VsdCAhPSB1bmRlZmluZWQgJiYgcmVzdWx0ICE9IGlkeClcclxuICAgICAgICAgICAgcmVzdWx0ID0gLTE7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXN1bHQgPSBpZHg7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRPRE86IEFkZCBhIG1lcmdlV2l0aENoaWxkSW5kZXggbWV0aG9kP1xyXG4gKiBAcGFyYW0ge0NoYW5uZWxNYXB9IG90aGVyQ2hhbm5lbE1hcFxyXG4gKiBAcGFyYW0ge251bWJlcj99IGNoaWxkRGF0YUluZGV4IEluZGV4IHJlbGF0aXZlIHRvIERhdGFOb2RlLiBVc2VkIHRvIG1hcmsgaWYgY2hhbm5lbCBjb21lc1xyXG4gKiBmcm9tIGEgc3BlY2lmaWMgY2hpbGQgRGF0YU5vZGUsIHVuZGVmaW5lZCBpZiBDaGFubmVsTWFwIHNob3VsZCB0YWtlIG92ZXIgY2hpbGQgaW5kZXggZnJvbSBvdGhlckNoYW5uZWxNYXBcclxuICovXHJcbkNoYW5uZWxNYXAucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24ob3RoZXJDaGFubmVsTWFwLCBjaGlsZERhdGFJbmRleCl7XHJcbiAgICBmb3IodmFyIG5hbWUgaW4gb3RoZXJDaGFubmVsTWFwLm1hcCl7XHJcbiAgICAgICAgLy8gRWl0aGVyIHVzZSBwcm92aWRlZCBjaGlsZCBpbmRleCwgb3RoZXJ3aXNlIHVzZSBjaGlsZCBpbmRleCBmcm9tIENoYW5uZWxNYXAgdG8gbWVyZ2VcclxuICAgICAgICAvLyBGb3IgaW5wdXQgY2hhbm5lbCBtYXAgd2UgZGVmaW5lIHRoZSBjaGlsZERhdGFJbmRleCBkaXJlY3RseSwgZm9yIGFwcGxpZWQgZmlsdGVycyB3ZSB1c2UgdGhlXHJcbiAgICAgICAgLy8gY2hpbGREYXRhSW5kZXggb2YgdGhlIHByb3ZpZGVkIENoYW5uZWxNYXAgKGl0J3MganVzdCBhIHJlbmFtaW5nKVxyXG4gICAgICAgIHZhciBpbmRleCA9IGNoaWxkRGF0YUluZGV4ID09IHVuZGVmaW5lZCA/IG90aGVyQ2hhbm5lbE1hcC5nZXRDaGlsZERhdGFJbmRleChuYW1lKSA6IGNoaWxkRGF0YUluZGV4O1xyXG4gICAgICAgIHRoaXMuYWRkQ2hhbm5lbChuYW1lLCBvdGhlckNoYW5uZWxNYXAuZ2V0Q2hhbm5lbChuYW1lKSwgaW5kZXgpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogQWRkIGEgY2hhbm5lbCB3aXRoIGEgY2hpbGREYXRhSW5kZXhcclxuICogVGhlIGNoaWxkRGF0YUluZGV4IGRlZmluZXMgdGhlIG9yaWdpbiBvZiB0aGUgY2hhbm5lbC5cclxuICogSWYgY2hpbGREYXRhSW5kZXggaXMgdW5kZWZpbmVkIHRoZSB2YWx1ZSBvZiB0aGUgY2hhbm5lbCBjYW4ndCBiZSBkZXRlcm1pbmVkIGZyb20gb25lIHNpbmdsZSBEYXRhTm9kZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gKiBAcGFyYW0ge0NoYW5uZWx9IGNoYW5uZWxcclxuICogQHBhcmFtIHtOdW1iZXI/fSBjaGlsZERhdGFJbmRleFxyXG4gKi9cclxuQ2hhbm5lbE1hcC5wcm90b3R5cGUuYWRkQ2hhbm5lbCA9IGZ1bmN0aW9uKG5hbWUsIGNoYW5uZWwsIGNoaWxkRGF0YUluZGV4KXtcclxuICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgaXMgZXZlciBjYWxsZWQgd2l0aCBhIHByb3BlciBjaGlsZERhdGFJbmRleCB2YWx1ZVxyXG4gICAgaWYoIWNoYW5uZWwpIHJldHVybjtcclxuICAgIGlmKGNoaWxkRGF0YUluZGV4ID09IHVuZGVmaW5lZCkgY2hpbGREYXRhSW5kZXggPSAtMTtcclxuICAgIG1lcmdlQ2hhbm5lbEludG9DaGFubmVsKHRoaXMsIG5hbWUsIGNoYW5uZWwsIGNoaWxkRGF0YUluZGV4KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGQgRGF0YVNsb3QgdG8gdGhlIENoYW5uZWxcclxuICogQHBhcmFtIG5hbWVcclxuICogQHBhcmFtIGRhdGFTbG90XHJcbiAqL1xyXG5DaGFubmVsTWFwLnByb3RvdHlwZS5hZGREYXRhRW50cnkgPSBmdW5jdGlvbihuYW1lLCBkYXRhU2xvdClcclxue1xyXG4gICAgbWVyZ2VEYXRhU2xvdEludG9DaGFubmVsKHRoaXMsIG5hbWUsIGRhdGFTbG90LCAtMSk7XHJcbn07XHJcbi8qKlxyXG4gKiBBZGQgYW4gb3V0cHV0IERhdGFTbG90IHRoYXQgb3JpZ2luYXRlcyBmcm9tIGFuIG9wZXJhdG9yXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAqIEBwYXJhbSB7RGF0YVNsb3R9IGRhdGFTbG90XHJcbiAqIEBwYXJhbSB7UHJvY2Vzc05vZGV9IGNyZWF0b3JOb2RlXHJcbiAqL1xyXG5DaGFubmVsTWFwLnByb3RvdHlwZS5hZGRPdXRwdXREYXRhU2xvdCA9IGZ1bmN0aW9uKG5hbWUsIGRhdGFTbG90LCBjcmVhdG9yTm9kZSl7XHJcbiAgICB2YXIgZmluYWxDaGFubmVsID0gbWVyZ2VEYXRhU2xvdEludG9DaGFubmVsKHRoaXMsIG5hbWUsIGRhdGFTbG90LCAtMSk7XHJcbiAgICBmaW5hbENoYW5uZWwuY3JlYXRvclByb2Nlc3NOb2RlID0gY3JlYXRvck5vZGU7XHJcbn07XHJcblxyXG4vKipcclxuICogRW1wdHkgdGhlIGNoYW5uZWwgbWFwLlxyXG4gKi9cclxuQ2hhbm5lbE1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpe1xyXG4gICAgZm9yKHZhciBuYW1lIGluIHRoaXMubWFwKXtcclxuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMubWFwW25hbWVdO1xyXG4gICAgICAgIGlmKGNoYW5uZWwgJiYgY2hhbm5lbC5tYXAgPT0gdGhpcylcclxuICAgICAgICAgICAgY2hhbm5lbC5jbGVhcigpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5tYXAgPSB7fTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGluaXRDaGFubmVsU2xvdChjaGFubmVsTWFwLCBuYW1lKXtcclxuICAgIGlmKCFjaGFubmVsTWFwLm1hcFtuYW1lXSl7XHJcbiAgICAgICAgY2hhbm5lbE1hcC5tYXBbbmFtZV0gPSB7XHJcbiAgICAgICAgICAgIGNoYW5uZWw6IG51bGwsXHJcbiAgICAgICAgICAgIGNoaWxkRGF0YUluZGV4OiB1bmRlZmluZWRcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1lcmdlQ2hhbm5lbEludG9DaGFubmVsKGNoYW5uZWxNYXAsIG5hbWUsIG5ld0NoYW5uZWwsIGNoaWxkRGF0YUluZGV4KXtcclxuICAgIGluaXRDaGFubmVsU2xvdChjaGFubmVsTWFwLCBuYW1lKTtcclxuICAgIHZhciBjdXJyZW50Q2hhbm5lbCA9IGNoYW5uZWxNYXAubWFwW25hbWVdLmNoYW5uZWw7XHJcbiAgICBpZighY3VycmVudENoYW5uZWwgfHwgIWN1cnJlbnRDaGFubmVsLndpbGxNZXJnZVdpdGhDaGFubmVsKG5ld0NoYW5uZWwpKSB7XHJcbiAgICAgICAgY2hhbm5lbE1hcC5tYXBbbmFtZV0uY2hhbm5lbCA9IG5ld0NoYW5uZWw7XHJcbiAgICAgICAgY2hhbm5lbE1hcC5tYXBbbmFtZV0uY2hpbGREYXRhSW5kZXggPSBjaGlsZERhdGFJbmRleDtcclxuICAgICAgICByZXR1cm4gbmV3Q2hhbm5lbDtcclxuICAgIH1cclxuICAgIGN1cnJlbnRDaGFubmVsID0gZ2V0TWFwT3duZWRDaGFubmVsKGNoYW5uZWxNYXAsIGN1cnJlbnRDaGFubmVsKTtcclxuICAgIGN1cnJlbnRDaGFubmVsLmFkZENoYW5uZWxFbnRyaWVzKG5ld0NoYW5uZWwpO1xyXG4gICAgY2hhbm5lbE1hcC5tYXBbbmFtZV0uY2hhbm5lbCA9IGN1cnJlbnRDaGFubmVsO1xyXG4gICAgY2hhbm5lbE1hcC5tYXBbbmFtZV0uY2hpbGREYXRhSW5kZXggPSAtMTtcclxuICAgIHJldHVybiBjdXJyZW50Q2hhbm5lbDtcclxufVxyXG5cclxuZnVuY3Rpb24gbWVyZ2VEYXRhU2xvdEludG9DaGFubmVsKGNoYW5uZWxNYXAsIG5hbWUsIGRhdGFTbG90LCBjaGlsZERhdGFJbmRleCl7XHJcbiAgICBpbml0Q2hhbm5lbFNsb3QoY2hhbm5lbE1hcCwgbmFtZSk7XHJcbiAgICB2YXIgY3VycmVudENoYW5uZWwgPSBjaGFubmVsTWFwLm1hcFtuYW1lXS5jaGFubmVsO1xyXG4gICAgaWYoIWN1cnJlbnRDaGFubmVsIHx8ICFjdXJyZW50Q2hhbm5lbC53aWxsTWVyZ2VXaXRoRGF0YVNsb3QoZGF0YVNsb3QpKXtcclxuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBDaGFubmVsKGNoYW5uZWxNYXAsIGRhdGFTbG90KTtcclxuICAgICAgICBjaGFubmVsTWFwLm1hcFtuYW1lXS5jaGFubmVsID0gY2hhbm5lbDtcclxuICAgICAgICBjaGFubmVsTWFwLm1hcFtuYW1lXS5jaGlsZERhdGFJbmRleCA9IGNoaWxkRGF0YUluZGV4O1xyXG4gICAgICAgIHJldHVybiBjaGFubmVsO1xyXG4gICAgfVxyXG4gICAgY3VycmVudENoYW5uZWwgPSBnZXRNYXBPd25lZENoYW5uZWwoY2hhbm5lbE1hcCwgY3VycmVudENoYW5uZWwpO1xyXG4gICAgY3VycmVudENoYW5uZWwuYWRkRGF0YVNsb3QoZGF0YVNsb3QpO1xyXG4gICAgY2hhbm5lbE1hcC5tYXBbbmFtZV0uY2hhbm5lbCA9IGN1cnJlbnRDaGFubmVsO1xyXG4gICAgY2hhbm5lbE1hcC5tYXBbbmFtZV0uY2hpbGREYXRhSW5kZXggPSAtMTtcclxuICAgIHJldHVybiBjdXJyZW50Q2hhbm5lbDtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldE1hcE93bmVkQ2hhbm5lbChtYXAsIGNoYW5uZWwpe1xyXG4gICAgaWYoY2hhbm5lbC5tYXAgIT0gbWFwKXtcclxuICAgICAgICB2YXIgbmV3Q2hhbm5lbCA9IG5ldyBDaGFubmVsKG1hcCk7XHJcbiAgICAgICAgbmV3Q2hhbm5lbC5hZGRDaGFubmVsRW50cmllcyhjaGFubmVsKTtcclxuICAgICAgICBuZXdDaGFubmVsLmNyZWF0b3JQcm9jZXNzTm9kZSA9IGNoYW5uZWwuY3JlYXRvclByb2Nlc3NOb2RlO1xyXG4gICAgICAgIHJldHVybiBuZXdDaGFubmVsXHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2hhbm5lbDtcclxufVxyXG5cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBDaGFubmVsXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbi8qKlxyXG4gKiBBIGNoYW5uZWwgbWF5IGluY2x1ZSBzZXZlcmFsIERhdGFTbG90cy9EYXRhRW50cmllc1xyXG4gKiBBIGRlY2xhcmVkIFNlcXVlbmNlIHdpbGwgcmVzdWx0IGluIG9uIGNoYW5uZWwgd2l0aCBtdWx0aXBsZSBEYXRhRW50cmllcy5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7Q2hhbm5lbE1hcH0gbWFwIE93bmVyIG9mIHRoZSBjaGFubmVsXHJcbiAqIEBwYXJhbSB7RGF0YVNsb3Q9fSBkYXRhU2xvdCBPcHRpb25hbCBEYXRhU2xvdCBhZGRlZCB0byB0aGUgY2hhbm5lbFxyXG4gKi9cclxudmFyIENoYW5uZWwgPSBmdW5jdGlvbihtYXAsIGRhdGFTbG90KXtcclxuICAgIC8qKlxyXG4gICAgICogRGF0YVNsb3QgZW50cmllcyBzb3J0ZWQgYnkga2V5IHZhbHVlXHJcbiAgICAgKiBAdHlwZSB7QXJyYXkuPERhdGFTbG90Pn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5lbnRyaWVzID0gW107XHJcbiAgICAvKipcclxuICAgICAqIE93bmVyIENoYW5uZWxNYXAgdGhhdCBjcmVhdGVkIHdpdGggY2hhbm5lbC5cclxuICAgICAqIE5vdGU6IGEgY2hhbm5lbCBjYW4gc3RpbGwgZXhpc3QgaW4gc2V2ZXJhbCBDaGFubmVsTWFwc1xyXG4gICAgICogQHR5cGUge0NoYW5uZWxNYXB9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubWFwID0gbWFwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbmlxdWUgSUQgZm9yIHRoaXMgY2hhbm5lbC4gSXMgdXNlZCBmb3Igc2V2ZXJhbCBvcHRpbWl6YXRpb25zLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmlkID0gZ2VuZXJhdGVDaGFubmVsSWQoKTtcclxuICAgIC8qKlxyXG4gICAgICogTGlzdGVuZXJzIG9mIHRoaXMgY2hhbm5lbHMgKHVzdWFsbHkgUHJvY2Vzc05vZGVzIGFuZCBSZXF1ZXN0Tm9kZXMpXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGlzdGVuZXJzID0gW107XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBQcm9jZXNzTm9kZSB0aGF0IGNyZWF0ZWQvZXh0ZW5kZWQgdGhlIGNvbnRlbnQgb2YgdGhpcyBjaGFubmVsXHJcbiAgICAgKiBUaGVyZSBjYW4gYmUgb25seSBvbmUgY3JlYXRvclByb2Nlc3NOb2RlIHBlciBjaGFubmVsIGJlY2F1c2VcclxuICAgICAqIHRoZW4gb3VwdXQgRGF0YVNsb3RzIG9mIGFuIG9wZXJhdG9yIHdpbGwgYWx3YXlzIGhhdmUga2V5IFwiMFwiXHJcbiAgICAgKiBJZiB0d28gb3BlcmF0b3JzIGluZmx1ZW5jZSB0aGUgc2FtZSBzZXF1ZW5jZSwgdGhlIHNlY29uZCBvcGVyYXRvcidcclxuICAgICAqIG91dHB1dCB3aWxsIHJlcGxhY2UgdGhlIGZpcnN0IG9wZXJhdG9yJ3Mgb3V0cHV0LCBlZmZlY3RpdmVseSByZW1vdmluZyB0aGUgZGVwZW5kZW5jeS5cclxuICAgICAqIEB0eXBlIHtudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNyZWF0b3JQcm9jZXNzTm9kZSA9IG51bGw7XHJcblxyXG4gICAgaWYoZGF0YVNsb3Qpe1xyXG4gICAgICAgIHRoaXMuYWRkRGF0YVNsb3QoZGF0YVNsb3QpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZCBhIGRhdGFTbG90IHRvIHRoZSBjaGFubmVsLCBhZGRpbmcgZGVwZW5kZW5jaWVzLlxyXG4gKiBObyBub3RpZmljYXRpb25zIHNlbmQgZXRjLlxyXG4gKiBNYWtlcyBzdXJlIHRoYXQgcmVzdWx0aW5nIGNoYW5uZWwgaGFzIGRhdGFTbG90cyBvcmRlcmVkIGJ5IGtleVxyXG4gKiBAcGFyYW0gZGF0YVNsb3RcclxuICovXHJcbkNoYW5uZWwucHJvdG90eXBlLmFkZERhdGFTbG90ID0gZnVuY3Rpb24oZGF0YVNsb3Qpe1xyXG4gICAgZGF0YVNsb3QuYWRkQ2hhbm5lbCh0aGlzKTtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuZW50cmllc1tpXTtcclxuICAgICAgICAvLyBXZSB1c2UgZXBzaWxvbiBoZXJlIHRvIGRldGVjdCBkYXRhIGVudHJpZXMgd2l0aCBcImVxdWFsXCIga2V5XHJcbiAgICAgICAgaWYoZW50cnkua2V5ID49IGRhdGFTbG90LmtleSAtIEMuRVBTSUxPTiApe1xyXG4gICAgICAgICAgICBpZihNYXRoLmFicyhlbnRyeS5rZXkgLSBkYXRhU2xvdC5rZXkpIDw9IEMuRVBTSUxPTil7XHJcbiAgICAgICAgICAgICAgICBlbnRyeS5yZW1vdmVDaGFubmVsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbnRyaWVzLnNwbGljZShpLCAxLCBkYXRhU2xvdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW50cmllcy5zcGxpY2UoaSwgMCwgZGF0YVNsb3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuZW50cmllcy5wdXNoKGRhdGFTbG90KTtcclxufTtcclxuXHJcbkNoYW5uZWwucHJvdG90eXBlLmdldFNlcXVlbmNlTGVuZ3RoID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLmVudHJpZXMubGVuZ3RoO1xyXG59O1xyXG5DaGFubmVsLnByb3RvdHlwZS5nZXRTZXF1ZW5jZU1pbktleSA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzWzBdLmtleTtcclxufTtcclxuQ2hhbm5lbC5wcm90b3R5cGUuZ2V0U2VxdWVuY2VNYXhLZXkgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMuZW50cmllc1t0aGlzLmVudHJpZXMubGVuZ3RoIC0gMV0ua2V5O1xyXG59O1xyXG4vKipcclxuICogVGhlIERhdGFUeXBlIG9mIHRoZSBjaGFubmVsLlxyXG4gKiBTaW5jZSBhbGwgRGF0YUVudHJpZXMgd2l0aGluIGEgY2hhbm5lbCBoYXZlIHRoZSBzYW1lIHR5cGUsIHdlIGNhbiBzaW1wbHkgcmV0dXJuIHRoZSB0eXBlIG9mIHRoZSBmaXJzdCBlbnRyeS5cclxuICogQHJldHVybnMge0RBVEFfVFlQRX1cclxuICovXHJcbkNoYW5uZWwucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbigpe1xyXG4gICAgaWYodGhpcy5lbnRyaWVzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgIHJldHVybiBDLkRBVEFfVFlQRS5VTktOT1dOO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXNbMF0uZGF0YUVudHJ5Ll90eXBlO1xyXG59O1xyXG4vKipcclxuICogTWVyZ2UgYW5vdGhlciBjaGFubmVsIGludG8gdGhpcyBjaGFubmVsLlxyXG4gKi9cclxuQ2hhbm5lbC5wcm90b3R5cGUuYWRkQ2hhbm5lbEVudHJpZXMgPSBmdW5jdGlvbihvdGhlckNoYW5uZWwpe1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG90aGVyQ2hhbm5lbC5lbnRyaWVzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB2YXIgc2xvdCA9IG90aGVyQ2hhbm5lbC5lbnRyaWVzW2ldO1xyXG4gICAgICAgIHRoaXMuYWRkRGF0YVNsb3Qoc2xvdCk7XHJcbiAgICB9XHJcbiAgICAvLyBGSVhNRTogb3RoZXJDaGFubmVsIG1pZ2h0IGJlIHdpdGhvdXQgY3JlYXRvclByb2Nlc3NOb2RlIGJ1dCBzdGlsbCBkZWZpbmUgYSBEYXRhU2xvdCB3aXRoIGtleSAwXHJcbiAgICAvLyBJbiB0aGlzIGNhc2Ugd2UgaGF2ZSB0byBzZXQgY3JlYXRvclByb2Nlc3NOb2RlIHRvIG51bGxcclxuICAgIGlmKG90aGVyQ2hhbm5lbC5jcmVhdG9yUHJvY2Vzc05vZGUpXHJcbiAgICAgICAgdGhpcy5jcmVhdG9yUHJvY2Vzc05vZGUgPSBvdGhlckNoYW5uZWwuY3JlYXRvclByb2Nlc3NOb2RlO1xyXG4gICAgLy9lbHNlXHJcbiAgICAvLyAgICB0aGlzLmNyZWF0b3JQcm9jZXNzTm9kZSA9IG51bGw7XHJcbn07XHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBEYXRhRW50cnkgZnJvbSB0aGlzIGNoYW5uZWwgZGVwZW5kaW5nIG9uIHNlcXVlbmNlS2V5LlxyXG4gKiBAcGFyYW0ge0MuU0VRVUVOQ0U/fSBzZXF1ZW5jZUFjY2Vzc1R5cGVcclxuICogQHBhcmFtIHtudW1iZXI/fSBzZXF1ZW5jZUtleVxyXG4gKiBAcmV0dXJucyB7RGF0YUVudHJ5fVxyXG4gKi9cclxuQ2hhbm5lbC5wcm90b3R5cGUuZ2V0RGF0YUVudHJ5ID0gZnVuY3Rpb24oc2VxdWVuY2VBY2Nlc3NUeXBlLCBzZXF1ZW5jZUtleSl7XHJcbiAgICBpZih0aGlzLmVudHJpZXMubGVuZ3RoID09IDApXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICBpZighc2VxdWVuY2VBY2Nlc3NUeXBlKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzWzBdLmRhdGFFbnRyeTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgdmFyIGkgPSAwLCBtYXggPSB0aGlzLmVudHJpZXMubGVuZ3RoO1xyXG4gICAgLy8gVE9ETzogRG8gYmluYXJ5IHNlYXJjaCBoZXJlP1xyXG4gICAgd2hpbGUoaSA8IG1heCAmJiB0aGlzLmVudHJpZXNbaV0ua2V5IDwgc2VxdWVuY2VLZXkpICsraTtcclxuICAgIGlmKHNlcXVlbmNlQWNjZXNzVHlwZSA9PSBDLlNFUVVFTkNFLlBSRVZfQlVGRkVSKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzW2kgPyBpIC0xIDogMF0uZGF0YUVudHJ5O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZihzZXF1ZW5jZUFjY2Vzc1R5cGUgPT0gQy5TRVFVRU5DRS5ORVhUX0JVRkZFUil7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllc1tpIDwgbWF4ID8gaSA6IG1heCAtIDFdLmRhdGFFbnRyeTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYoc2VxdWVuY2VBY2Nlc3NUeXBlID09IEMuU0VRVUVOQ0UuTElORUFSX1dFSUdIVCl7XHJcbiAgICAgICAgdmFyIHdlaWdodDEgPSB0aGlzLmVudHJpZXNbaSA/IGkgLSAxIDogMF0ua2V5O1xyXG4gICAgICAgIHZhciB3ZWlnaHQyID0gdGhpcy5lbnRyaWVzW2kgPCBtYXggPyBpIDogbWF4IC0gMV0ua2V5O1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkoMSk7XHJcbiAgICAgICAgdmFsdWVbMF0gPSB3ZWlnaHQyID09IHdlaWdodDEgPyAwIDogKHNlcXVlbmNlS2V5IC0gd2VpZ2h0MSkgLyAod2VpZ2h0MiAtIHdlaWdodDEpO1xyXG4gICAgICAgIC8vIFRPRE86IENoZWNrIGlmIHJlcGVhdGVkIEJ1ZmZlckVudHJ5IGFuZCBGbG9hdDMyQXJyYXkgYWxsb2NhdGlvbiBpcyBhIHNlcmlvdXMgYm90dGxlbmVja1xyXG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyRW50cnkoQy5EQVRBX1RZUEUuRkxPQVQsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiB0cnVlIG9mIHRoZSB0d28gY2hhbm5lbHMgbmVlZCB0byBiZSBtZXJnZWQgKGluc3RlYWQgb2YgcmVwbGFjaW5nIHRoaXMgY2hhbm5lbCB3aXRoIG90aGVyQ2hhbm5lbClcclxuICogQHBhcmFtIG90aGVyQ2hhbm5lbFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkNoYW5uZWwucHJvdG90eXBlLndpbGxNZXJnZVdpdGhDaGFubmVsID0gZnVuY3Rpb24ob3RoZXJDaGFubmVsKXtcclxuICAgIGlmKHRoaXMuZW50cmllcy5sZW5ndGggIT0gb3RoZXJDaGFubmVsLmVudHJpZXMubGVuZ3RoKSByZXR1cm4gdHJ1ZTtcclxuICAgIGlmKHRoaXMuZ2V0VHlwZSgpICE9IG90aGVyQ2hhbm5lbC5nZXRUeXBlKCkpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuZW50cmllcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgaWYoTWF0aC5hYnModGhpcy5lbnRyaWVzW2ldLmtleSAtIG90aGVyQ2hhbm5lbC5lbnRyaWVzW2ldLmtleSkgPiBDLkVQU0lMT04pXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG4vKipcclxuICogUmV0dXJuIHRydWUgaWYgd2UgbmVlZCB0byBtZXJnZSB0aGUgY2hhbm5lbCB3aXRoIHRoaXMgZGF0YVNsb3RcclxuICogKGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgY2hhbm5lbCBmcm9tdGhpcyBkYXRhU2xvdClcclxuICogQHBhcmFtIGRhdGFTbG90XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuQ2hhbm5lbC5wcm90b3R5cGUud2lsbE1lcmdlV2l0aERhdGFTbG90ID0gZnVuY3Rpb24oZGF0YVNsb3Qpe1xyXG4gICAgaWYodGhpcy5lbnRyaWVzLmxlbmd0aCA+IDEpIHJldHVybiB0cnVlO1xyXG4gICAgaWYodGhpcy5nZXRUeXBlKCkgIT0gZGF0YVNsb3QuZGF0YUVudHJ5Ll90eXBlKSByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gKE1hdGguYWJzKHRoaXMuZW50cmllc1swXS5rZXkgLSBkYXRhU2xvdC5rZXkpID4gQy5FUFNJTE9OKTtcclxufTtcclxuXHJcbkNoYW5uZWwucHJvdG90eXBlLm5vdGlmeU9uQ2hhbmdlID0gZnVuY3Rpb24oc3RhdGUpe1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGlzdGVuZXJzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyc1tpXS5vblhmbG93Q2hhbm5lbENoYW5nZSh0aGlzLCBzdGF0ZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5DaGFubmVsLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHByb2Nlc3NOb2RlKXtcclxuICAgIHRoaXMubGlzdGVuZXJzLnB1c2gocHJvY2Vzc05vZGUpO1xyXG59O1xyXG5DaGFubmVsLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHByb2Nlc3NOb2RlKXtcclxuICAgIHZhciBpZHggPSB0aGlzLmxpc3RlbmVycy5pbmRleE9mKHByb2Nlc3NOb2RlKTtcclxuICAgIGlmKGlkeCAhPSAtMSkgdGhpcy5saXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XHJcbn07XHJcblxyXG5DaGFubmVsLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCl7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5lbnRyaWVzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICB0aGlzLmVudHJpZXNbaV0ucmVtb3ZlQ2hhbm5lbCh0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcbnZhciBjX2NoYW5uZWxLZXlJZHggPSAwO1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUNoYW5uZWxJZCgpe1xyXG4gICAgcmV0dXJuICsrY19jaGFubmVsS2V5SWR4O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIENoYW5uZWw6IENoYW5uZWwsXHJcbiAgICBDaGFubmVsTWFwOiBDaGFubmVsTWFwXHJcbn07XHJcbiIsInZhciBCYXNlID0gcmVxdWlyZShcIi4uL2Jhc2UuanNcIik7XHJcbnZhciBDID0gcmVxdWlyZShcIi4uL2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XHJcblxyXG4vKipcclxuICogQSBEYXRhU2xvdCB3cmFwcyBhIGRhdGFFbnRyeSBhbmQgYWRkcyBhIGtleSB2YWx1ZSBmb3Igc2VxdWVuY2VzLlxyXG4gKiBUaGlzIHN0cnVjdHVyZSBpcyB1c2VkIGludGVybmFsbHkgd2l0aGluIGNoYW5uZWxzIGFuZCBwcm9jZXNzIG5vZGVzXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0RhdGFFbnRyeX0gZGF0YUVudHJ5XHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0ga2V5XHJcbiAqL1xyXG52YXIgRGF0YVNsb3QgPSBmdW5jdGlvbihkYXRhRW50cnksIGtleSl7XHJcbiAgICB0aGlzLmtleSA9IGtleSB8fCAwOyAgICAgICAgICAgIC8vIHNlcXVlbmNlIGtleVxyXG4gICAgdGhpcy5kYXRhRW50cnkgPSBkYXRhRW50cnk7ICAgICAvLyBkYXRhRW50cnkgb2YgdGhlIHNsb3RcclxuICAgIC8qKlxyXG4gICAgICogYWx0ZXJuYXRpdmUgZGF0YUVudHJ5IGZvciBhc3luY2hyb25vdXMgcHJvY2Vzc2luZ1xyXG4gICAgICogb25seSB1c2VkIGZvciBvdXRwdXQgRGF0YVNsb3RzIG9mIGFzeW5jaHJvbm91cyBvcGVyYXRvcnNcclxuICAgICAqIEB0eXBlIHtEYXRhRW50cnl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYXN5bmNEYXRhRW50cnkgPSBudWxsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBsaXN0IG9mIGFsbCBjaGFubmVscyB0aGF0IGNvbnRhaW4gdGhpcyBEYXRhU2xvdFxyXG4gICAgICogQHR5cGUge0FycmF5LjxDaGFubmVsPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5wYXJlbnRDaGFubmVscyA9IFtdO1xyXG5cclxufTtcclxuRGF0YVNsb3QucHJvdG90eXBlLmFkZENoYW5uZWwgPSBmdW5jdGlvbihjaGFubmVsKXtcclxuICAgIHRoaXMucGFyZW50Q2hhbm5lbHMucHVzaChjaGFubmVsKTtcclxufTtcclxuRGF0YVNsb3QucHJvdG90eXBlLnJlbW92ZUNoYW5uZWwgPSBmdW5jdGlvbihjaGFubmVsKXtcclxuICAgIHZhciBpZHggPSB0aGlzLnBhcmVudENoYW5uZWxzLmluZGV4T2YoY2hhbm5lbCk7XHJcbiAgICBpZihpZHggIT0gLTEpIHRoaXMucGFyZW50Q2hhbm5lbHMuc3BsaWNlKGlkeCwgMSk7XHJcbn07XHJcbkRhdGFTbG90LnByb3RvdHlwZS5zd2FwQXN5bmMgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIHRtcCA9IHRoaXMuZGF0YUVudHJ5O1xyXG4gICAgdGhpcy5kYXRhRW50cnkgPSB0aGlzLmFzeW5jRGF0YUVudHJ5O1xyXG4gICAgdGhpcy5hc3luY0RhdGFFbnRyeSA9IHRtcDtcclxufTtcclxuXHJcbkRhdGFTbG90LnByb3RvdHlwZS5zZXREYXRhRW50cnkgPSBmdW5jdGlvbihkYXRhRW50cnksIGNoYW5nZVR5cGUpe1xyXG4gICAgdGhpcy5kYXRhRW50cnkgPSBkYXRhRW50cnk7XHJcbiAgICB2YXIgc3RhdGUgPSBjaGFuZ2VUeXBlID09IEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfREFUQV9WQUxVRSA/IEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX1ZBTFVFIDpcclxuICAgICAgICBDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9TSVpFO1xyXG4gICAgdGhpcy5ub3RpZnlPbkNoYW5nZShzdGF0ZSk7XHJcbn07XHJcblxyXG5EYXRhU2xvdC5wcm90b3R5cGUubm90aWZ5T25DaGFuZ2UgPSBmdW5jdGlvbihzdGF0ZSl7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5wYXJlbnRDaGFubmVscy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRDaGFubmVsc1tpXS5ub3RpZnlPbkNoYW5nZShzdGF0ZSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTbG90O1xyXG4iLCJ2YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi9iYXNlLmpzXCIpO1xyXG52YXIgQyA9IHJlcXVpcmUoXCIuLi9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xyXG52YXIgT3BlcmF0b3JMaXN0ID0gcmVxdWlyZShcIi4uL29wZXJhdG9yL29wZXJhdG9yLWxpc3QuanNcIik7XHJcbnZhciBVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy91dGlscy5qc1wiKTtcclxudmFyIE9wZXJhdG9yID0gcmVxdWlyZShcIi4uL29wZXJhdG9yL29wZXJhdG9yLmpzXCIpO1xyXG52YXIgT3BlcmF0b3JFbnRyeSA9IHJlcXVpcmUoXCIuLi9vcGVyYXRvci9vcGVyYXRvci1lbnRyeS5qc1wiKTtcclxudmFyIFByb2dyYW0gPSByZXF1aXJlKFwiLi4vb3BlcmF0b3IvcHJvZ3JhbS5qc1wiKTtcclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBFeGVjdXRvclxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8qKlxyXG4gKiBUcmllcyB0byBjb21iaW5lIG11bHRpcGxlIFByb2Nlc3NOb2RlcyBpbnRvIGEgUHJvZ3JhbS4gQ3VycmVudGx5IG9ubHkgdXNlZCBmb3IgdmVydGV4IHNoYWRlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVxdWVzdE5vZGV8UHJvY2Vzc05vZGV9IG93bmVyTm9kZVxyXG4gKiBAcGFyYW0ge0MuUExBVEZPUk19IHBsYXRmb3JtXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIEV4ZWN1dG9yID0gZnVuY3Rpb24ob3duZXJOb2RlLCBwbGF0Zm9ybSl7XHJcbiAgICB0aGlzLnBsYXRmb3JtID0gcGxhdGZvcm07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb2RlcyB0aGF0IGFyZSBtZXJnZWQgYnkgdGhpcyBleGVjdXRvclxyXG4gICAgICogQHR5cGUge0FycmF5LjxQcm9jZXNzTm9kZXxSZXF1ZXN0Tm9kZT59XHJcbiAgICAgKi9cclxuICAgIHRoaXMubWVyZ2VkTm9kZXMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YnNldCBvZiB0aGlzLm1lcmdlZE5vZGVzIHRoYXQgZGlyZWN0bHkgcHJvdmlkZSByZXN1bHRzIG9mIHRoZSBleGVjdXRvclxyXG4gICAgICogQHR5cGUge0FycmF5LjxQcm9jZXNzTm9kZT59XHJcbiAgICAgKi9cclxuICAgIHRoaXMubWVyZ2VkT3V0cHV0Tm9kZXMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2Nlc3NOb2RlcyB0byBiZSBleGVjdXRlZCBiZWZvcmUgdGhpcyBleGVjdXRvciBjYW4gYmVcclxuICAgICAqIGV4ZWN1dGVkXHJcbiAgICAgKiBAdHlwZSB7QXJyYXkuPFByb2Nlc3NOb2RlPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdWJOb2RlcyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVE9ETzogVW51c2VkLiBSZW1vdmU/XHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudW5wcm9jZXNzZWREYXRhTmFtZXMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqICBUT0RPOiBNYXliZSB3ZSBzaG91bGQganVzdCBzdG9yZSB0aGUgY2wtcGxhdGZvcm0gb2JqZWN0cyBpbiBnbG9iYWwgb2JqZWN0IHNvIHRoZXkgYXJlIG1vcmUgZWFzaWx5IGF2YWlsYWJsZSBhbmRcclxuICAgICAqICB0byBhdm9pZCBsb25nIHByb3RvdHlwZSBjaGFpbnMuIE9yIHdlIGNvdWxkIHBhc3MgdGhlIGdyYXBoIGNvbnRleHQgdG8gZWFjaCBub2RlIG9mIHRoZSBncmFwaC5cclxuICAgICAqICBIb3dldmVyLCBpdCB3b3VsZCBiZSBnb29kIHRvIGFsbG93IGVhY2ggR3JhcGggb2JqZWN0IHRvIGhhdmUgYXQgbGVhc3Qgb3duIGNvbnRleHQsIGNtZFF1ZXVlIGFuZCBrZXJuZWxNYW5hZ2VyLlxyXG4gICAgICogIGUuZy4gcGFzc2luZyBncmFwaCBpbmZvcm1hdGlvbiBoZXJlIHJlcXVpcmVzIGEgbG9uZyBwcm90b3R5cGUgY2hhaW5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcGVyYXRvckxpc3QgPSAgbmV3IE9wZXJhdG9yTGlzdChwbGF0Zm9ybSk7XHJcbiAgICB0aGlzLnByb2dyYW1EYXRhID0gIG5ldyBQcm9ncmFtLlByb2dyYW1EYXRhKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge1Byb2dyYW19XHJcbiAgICAgKi9cclxuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XHJcblxyXG4gICAgY29uc3RydWN0RXhlY3V0b3IodGhpcywgb3duZXJOb2RlKTtcclxufTtcclxuXHJcbiAgICBFeGVjdXRvci5wcm90b3R5cGUuaXNQcm9jZXNzZWQgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5tZXJnZWRPdXRwdXROb2Rlcy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUoaS0tKXtcclxuICAgICAgICAgICAgaWYodGhpcy5tZXJnZWRPdXRwdXROb2Rlc1tpXS5zdGF0dXMgIT0gQy5QUk9DRVNTX1NUQVRFLlBST0NFU1NFRClcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBFeGVjdXRvci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oYXN5bmNDYWxsYmFjayl7XHJcbiAgICAgICAgcnVuU3ViTm9kZXModGhpcyk7XHJcbiAgICAgICAgdXBkYXRlSXRlcmF0ZVN0YXRlKHRoaXMpOyAvLyBUT0RPIGNoZWNrIGlmIGl0ZXJhdGUgU3RhdGUgaGFzIGNoYW5nZXMgaW4gYW55IHdheSBhbmQgb25seSByZWZldGNoIHByb2dyYW0gaW4gdGhhdCBjYXNlXHJcblxyXG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IFByb2dyYW0uY3JlYXRlUHJvZ3JhbSh0aGlzLm9wZXJhdG9yTGlzdCk7XHJcblxyXG4gICAgICAgIGlmKHRoaXMucHJvZ3JhbSl7XHJcbiAgICAgICAgICAgIHRoaXMub3BlcmF0b3JMaXN0LmFsbG9jYXRlT3V0cHV0KHRoaXMucHJvZ3JhbURhdGEsICEhYXN5bmNDYWxsYmFjayk7XHJcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbS5ydW4odGhpcy5wcm9ncmFtRGF0YSwgYXN5bmNDYWxsYmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMucGxhdGZvcm0gIT0gQy5QTEFURk9STS5BU1lOQyl7XHJcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5tZXJnZWRPdXRwdXROb2Rlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdoaWxlKGktLSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1lcmdlZE91dHB1dE5vZGVzW2ldLnN0YXR1cyA9IEMuUFJPQ0VTU19TVEFURS5QUk9DRVNTRUQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH07XHJcblxyXG4gICAgRXhlY3V0b3IucHJvdG90eXBlLmdldFZlcnRleFNoYWRlciA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcnVuU3ViTm9kZXModGhpcyk7XHJcbiAgICAgICAgdXBkYXRlSXRlcmF0ZVN0YXRlKHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBQcm9ncmFtLmNyZWF0ZVByb2dyYW0odGhpcy5vcGVyYXRvckxpc3QpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5wcm9ncmFtO1xyXG4gICAgfTtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3QgRXhlY3V0b3JcclxuICogQHBhcmFtIGV4ZWN1dGVyXHJcbiAqIEBwYXJhbSBvd25lck5vZGVcclxuICovXHJcbmZ1bmN0aW9uIGNvbnN0cnVjdEV4ZWN1dG9yKGV4ZWN1dGVyLCBvd25lck5vZGUpe1xyXG4gICAgdmFyIGNEYXRhID0ge1xyXG4gICAgICAgIGJsb2NrZWROb2RlczogW10sICAgLy8gQmFkIE5vZGVzIHRoYXQgY2Fubm90IGJlIG1lcmdlLiBGaWxsZWQgZHVyaW5nIHByZSBzY2FuXHJcbiAgICAgICAgZG9uZU5vZGVzOiBbXSwgICAgICAvLyBOb2RlcyB0aGF0IGhhdmUgYmVlbiBzaWduZWQgdXAgZm9yIG1lcmdpbmcuIFRPRE86IFJlZHVuZGFudCB3aXRoIGNvbnN0cnVjdGlvbk9yZGVyIGFuZCBzdWJOb2Rlcz8gLSBtYXliZSB5ZXMhXHJcbiAgICAgICAgY29uc3RydWN0aW9uT3JkZXI6IFtdLCAvLyBTdG9yZSBub2RlcyBpbiBvcmRlciBvZiBjb25zdHJ1Y3Rpb24gb2YgT3BlcmF0b3JFbnRyaWVzLlxyXG4gICAgICAgIGlucHV0U2xvdHM6IHt9LCAgICAgLy8gQ29sbGVjdGVkIGlucHV0IGNoYW5uZWxzIG9mIGFsbCBtZXJnZWQgbm9kZXMuIFVzZWQgdG8gYXZvaWQgYXNzaWduaW5nIHNhbWUgaW5wdXQgYnVmZmVyIHR3aWNlXHJcbiAgICAgICAgZmluYWxPdXRwdXQ6IG51bGwsICAvLyBmaW5hbE91dHB1dCBjaGFubmVzIGluIGNhc2Ugd2UgaGF2ZSBhIFJlcXVlc3ROb2RlXHJcbiAgICAgICAgZmlyc3RPcGVyYXRvcjogbnVsbCAvLyBTZXQgdG8gZmlyc3Qgb3BlcmF0b3IgdGhhdCBoYXMgYmVlbiBtZXJnZWQgKHdpbGwgYmUgZXhlY3V0ZWQgbGFzdClcclxuICAgIH07XHJcbiAgICB2YXIgcmVxdWVzdE5vZGUgPSBpbml0UmVxdWVzdE5vZGUoY0RhdGEsIGV4ZWN1dGVyLCBvd25lck5vZGUpO1xyXG5cclxuICAgIHZhciBub09wZXJhdG9ycyA9IGZhbHNlOyAvLyBUT0RPOiBSZW1vdmUgdGhpcz9cclxuICAgIGNvbnN0cnVjdFByZVNjYW4oY0RhdGEsIG93bmVyTm9kZSwgZXhlY3V0ZXIucGxhdGZvcm0sIG5vT3BlcmF0b3JzKTtcclxuXHJcbiAgICBzZXRDb25zdHJ1Y3Rpb25PcmRlckFuZFN1Yk5vZGVzKGNEYXRhLCBleGVjdXRlciwgb3duZXJOb2RlKTtcclxuXHJcbiAgICBjb25zdHJ1Y3RGcm9tRGF0YShleGVjdXRlciwgY0RhdGEpO1xyXG59XHJcbi8qKlxyXG4gKiBPbmx5IHJlbGV2YW50IGlmIG93bmVyTm9kZXMgaXMgYSBSZXF1ZXN0Tm9kZVxyXG4gKiBTZXRzIGZpbmFsT3V0cHV0IG9mIGNvbnN0cnVjdGlvbiBkYXRhIGFuZCB1bnByb2Nlc3NlZERhdGFOYW1lc1xyXG4gKiBAcGFyYW0gY0RhdGFcclxuICogQHBhcmFtIGV4ZWN1dGVyXHJcbiAqIEBwYXJhbSBvd25lck5vZGVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBpbml0UmVxdWVzdE5vZGUoY0RhdGEsIGV4ZWN1dGVyLCBvd25lck5vZGUpe1xyXG4gICAgaWYodHJ1ZSkgeyAvLyBGSVhNRTogb3duZXJOb2RlIGluc3RhbmNlb2YgUmVxdWVzdE5vZGUpe1xyXG4gICAgICAgIGNEYXRhLmZpbmFsT3V0cHV0ID0ge307XHJcbiAgICAgICAgdmFyIGZpbHRlciA9IG93bmVyTm9kZS5maWx0ZXIgfHwgb3duZXJOb2RlLm93bmVyLm91dHB1dENoYW5uZWxzLmdldE5hbWVzKCk7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGZpbHRlci5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gZmlsdGVyW2ldO1xyXG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IG93bmVyTm9kZS5vd25lci5vdXRwdXRDaGFubmVscy5nZXRDaGFubmVsKG5hbWUpO1xyXG4gICAgICAgICAgICBpZihjaGFubmVsICYmIGNoYW5uZWwuY3JlYXRvclByb2Nlc3NOb2RlKVxyXG4gICAgICAgICAgICAgICAgY0RhdGEuZmluYWxPdXRwdXRbbmFtZV0gPSBjaGFubmVsLmdldERhdGFFbnRyeSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBVdGlscy5uYW1lc2V0LmFkZChleGVjdXRlci51bnByb2Nlc3NlZERhdGFOYW1lcywgZmlsdGVyKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKipcclxuICogR29lcyB0byBwcm9jZXNzaW5nIHN1YnRyZWUgYXQgZmlsbGVkIGJsb2NrZWROb2RlcyBhcnJheSBpbiBjb25zdHJ1Y3Rpb24gZGF0YS5cclxuICogQWxsIG5vZGVzIHRoYXQgY2Fubm90IGJlIG1lcmdlZCBvciBoYXZlIHBhcmVudHMgdGhhdCBjYW4ndCBiZSBtZXJnZWQgd2lsbCBiZSBibG9ja2VkXHJcbiAqIEBwYXJhbSBjRGF0YVxyXG4gKiBAcGFyYW0gbm9kZVxyXG4gKiBAcGFyYW0gcGxhdGZvcm1cclxuICogQHBhcmFtIG5vT3BlcmF0b3JzXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25zdHJ1Y3RQcmVTY2FuKGNEYXRhLCBub2RlLCBwbGF0Zm9ybSwgbm9PcGVyYXRvcnMpe1xyXG4gICAgaWYoY0RhdGEuYmxvY2tlZE5vZGVzLmluZGV4T2Yobm9kZSkgIT0gLTEpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGlmKG5vZGUub3BlcmF0b3Ipe1xyXG4gICAgICAgIGlmKG5vT3BlcmF0b3JzIHx8ICFjYW5PcGVyYXRvck1lcmdlKGNEYXRhLCBub2RlLm9wZXJhdG9yLCBwbGF0Zm9ybSkpe1xyXG4gICAgICAgICAgICBibG9ja1N1YnRyZWUoY0RhdGEsIG5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIGlmKCFjRGF0YS5maXJzdE9wZXJhdG9yKSBjRGF0YS5maXJzdE9wZXJhdG9yID0gbm9kZS5vcGVyYXRvcjtcclxuICAgICAgICAgICAgdmFyIG1hcHBpbmcgPSBub2RlLm9wZXJhdG9yLm1hcHBpbmc7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtYXBwaW5nLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgIGlmKG1hcHBpbmdbaV0uc2VxdWVuY2Upe1xyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrSW5wdXQoY0RhdGEsIG5vZGUsIG1hcHBpbmdbaV0uc291cmNlKTtcclxuICAgICAgICAgICAgICAgICAgICBibG9ja0lucHV0KGNEYXRhLCBub2RlLCBtYXBwaW5nW2ldLmtleVNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKG1hcHBpbmdbaV0uYXJyYXkpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFJlbmFtZSAuYXJyYXkgdG8gLnJhbmRvbUFjY2Vzc1xyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrSW5wdXQoY0RhdGEsIG5vZGUsIG1hcHBpbmdbaV0uc291cmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytpKXtcclxuICAgICAgICBjb25zdHJ1Y3RQcmVTY2FuKGNEYXRhLCBub2RlLmNoaWxkcmVuW2ldLCBwbGF0Zm9ybSwgbm9PcGVyYXRvcnMpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjYW5PcGVyYXRvck1lcmdlKGNEYXRhLCBvcGVyYXRvciwgcGxhdGZvcm0pe1xyXG4gICAgLy8gVE9ETzogRGV0ZWN0IG1lcmdlIHN1cHBvcnRcclxuICAgIHJldHVybiAocGxhdGZvcm0gPT0gQy5QTEFURk9STS5BU1lOQyB8fCAhT3BlcmF0b3IuaXNPcGVyYXRvckFzeW5jKG9wZXJhdG9yKSkgJiZcclxuICAgICAgICAoIWNEYXRhLmZpcnN0T3BlcmF0b3IgfHxcclxuICAgICAgICAocGxhdGZvcm0gPT0gQy5QTEFURk9STS5HTFNMICYmIGNEYXRhLmZpcnN0T3BlcmF0b3IuZXZhbHVhdGVfZ2xzbCAmJiBvcGVyYXRvci5ldmFsdWF0ZV9nbHNsKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJsb2NrU3VidHJlZShjRGF0YSwgbm9kZSl7XHJcbiAgICBpZihjRGF0YS5ibG9ja2VkTm9kZXMuaW5kZXhPZihub2RlKSAhPSAtMSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgY0RhdGEuYmxvY2tlZE5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgYmxvY2tTdWJ0cmVlKGNEYXRhLCBub2RlLmNoaWxkcmVuW2ldKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQmxvY2sgYWxsIHByb2Nlc3NOb2RlcyBhc3NpZ25lZCB0byBhbiBpbnB1dCBjaGFubmVsXHJcbiAqIEBwYXJhbSBjRGF0YVxyXG4gKiBAcGFyYW0gbm9kZVxyXG4gKiBAcGFyYW0gaW5wdXROYW1lXHJcbiAqL1xyXG4gICAgZnVuY3Rpb24gYmxvY2tJbnB1dChjRGF0YSwgbm9kZSwgaW5wdXROYW1lKXtcclxuICAgICAgICB2YXIgY2hhbm5lbCA9IG5vZGUuaW5wdXRDaGFubmVsc1tpbnB1dE5hbWVdO1xyXG4gICAgICAgIGlmKGNoYW5uZWwgJiYgY2hhbm5lbC5jcmVhdG9yUHJvY2Vzc05vZGUpe1xyXG4gICAgICAgICAgICBibG9ja1N1YnRyZWUoY0RhdGEsIGNoYW5uZWwuY3JlYXRvclByb2Nlc3NOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbi8qKlxyXG4gKiBGaWxsIGRvbmVOb2RlcyBhbmQgY29uc3RydWN0aW9uT3JkZXIgYXJyYXlzIG9mIGNvbnN0cnVjdGlvbiBkYXRhLlxyXG4gKiBJdCBhbHNvIGZpbGxzIHRoZSBzdWJOb2RlcyBhcnJheSBvZiB0aGUgZXhlY3V0ZXJcclxuICogQHBhcmFtIGNEYXRhIGNvbnN0cnVjdGlvbiBkYXRhXHJcbiAqIEBwYXJhbSBleGVjdXRlclxyXG4gKiBAcGFyYW0gbm9kZVxyXG4gKi9cclxuICAgIGZ1bmN0aW9uIHNldENvbnN0cnVjdGlvbk9yZGVyQW5kU3ViTm9kZXMoY0RhdGEsIGV4ZWN1dGVyLCBub2RlKXtcclxuICAgICAgICBpZihjRGF0YS5kb25lTm9kZXMuaW5kZXhPZihub2RlKSAhPSAtMSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBjRGF0YS5kb25lTm9kZXMucHVzaChub2RlKTtcclxuXHJcbiAgICAgICAgaWYoY0RhdGEuYmxvY2tlZE5vZGVzLmluZGV4T2Yobm9kZSkgIT0gLTEpe1xyXG4gICAgICAgICAgICBleGVjdXRlci5zdWJOb2Rlcy5wdXNoKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgICAgICBzZXRDb25zdHJ1Y3Rpb25PcmRlckFuZFN1Yk5vZGVzKGNEYXRhLCBleGVjdXRlciwgbm9kZS5jaGlsZHJlbltpXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKG5vZGUub3BlcmF0b3IpeyAvLyBSZXF1ZXN0Tm9kZXMgZG9uJ3QgaGF2ZSBhbiBvcGVyYXRvci4gQ29uc2lkZXIgdGhpcyBjYXNlLlxyXG4gICAgICAgICAgICAgICAgY0RhdGEuY29uc3RydWN0aW9uT3JkZXIucHVzaChub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuLyoqXHJcbiAqIExhc3Qgc3RlcCBvZiBjb25zdHJ1Y3Rpb246IGNyZWF0ZSBPcGVyYXRvckxpc3QgZnJvbSBjb25zdHJ1Y3Rpb25PcmRlciBhcnJheVxyXG4gKiBBbHNvIGZpbGwgbWVyZ2VkTm9kZXMgYW5kIHByb2dyYW1EYXRhXHJcbiAqIEBwYXJhbSBleGVjdXRlclxyXG4gKiBAcGFyYW0gY0RhdGFcclxuICovXHJcbiAgICBmdW5jdGlvbiBjb25zdHJ1Y3RGcm9tRGF0YShleGVjdXRlciwgY0RhdGEpe1xyXG5cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY0RhdGEuY29uc3RydWN0aW9uT3JkZXIubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNEYXRhLmNvbnN0cnVjdGlvbk9yZGVyW2ldO1xyXG5cclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gbmV3IE9wZXJhdG9yRW50cnkobm9kZS5vcGVyYXRvcik7XHJcblxyXG4gICAgICAgICAgICBjb25zdHJ1Y3RJbnB1dENvbm5lY3Rpb24oZXhlY3V0ZXIsIGVudHJ5LCBjRGF0YSwgbm9kZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgaXNPdXRwdXROb2RlID0gY29uc3RydWN0T3V0cHV0Q29ubmVjdGlvbihleGVjdXRlciwgZW50cnksIGNEYXRhLCBub2RlKTtcclxuXHJcbiAgICAgICAgICAgIGV4ZWN1dGVyLnByb2dyYW1EYXRhLm9wZXJhdG9yRGF0YS5wdXNoKHt9KTtcclxuICAgICAgICAgICAgZXhlY3V0ZXIub3BlcmF0b3JMaXN0LmFkZEVudHJ5KGVudHJ5KTtcclxuICAgICAgICAgICAgZXhlY3V0ZXIubWVyZ2VkTm9kZXMucHVzaChub2RlKTtcclxuICAgICAgICAgICAgaWYoaXNPdXRwdXROb2RlIHx8IChpID09IGNEYXRhLmNvbnN0cnVjdGlvbk9yZGVyLmxlbmd0aC0xKSlcclxuICAgICAgICAgICAgICAgIGV4ZWN1dGVyLm1lcmdlZE91dHB1dE5vZGVzLnB1c2gobm9kZSlcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdHJ1Y3RMb3N0T3V0cHV0KGV4ZWN1dGVyLCBjRGF0YSk7XHJcbiAgICB9XHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3QgaW5wdXQgaW5mbyBmb3IgT3BlcmF0b3JFbnRyeS5cclxuICogV2lsbCBpbXBsaWNpdGx5IGNyZWF0ZSBQcm9ncmFtSW5wdXRDb25uZWN0aW9ucyBmb3IgUHJvZ3JhbURhdGFcclxuICogQHBhcmFtIHtFeGVjdXRvcn0gZXhlY3V0ZXJcclxuICogQHBhcmFtIHtPcGVyYXRvckVudHJ5fSBlbnRyeVxyXG4gKiBAcGFyYW0ge3t9fSBjRGF0YVxyXG4gKiBAcGFyYW0ge1Byb2Nlc3NOb2RlfSBub2RlXHJcbiAqL1xyXG4gICAgZnVuY3Rpb24gY29uc3RydWN0SW5wdXRDb25uZWN0aW9uKGV4ZWN1dGVyLCBlbnRyeSwgY0RhdGEsIG5vZGUpe1xyXG4gICAgICAgIHZhciBtYXBwaW5nID0gbm9kZS5vcGVyYXRvci5tYXBwaW5nO1xyXG4gICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBtYXBwaW5nLmxlbmd0aDsgKytqKXtcclxuICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSBub2RlLmlucHV0Q2hhbm5lbHNbbWFwcGluZ1tqXS5zb3VyY2VdO1xyXG4gICAgICAgICAgICB2YXIgb3BlcmF0b3JJbmRleDtcclxuICAgICAgICAgICAgaWYoY2hhbm5lbCAmJiBjaGFubmVsLmNyZWF0b3JQcm9jZXNzTm9kZSAmJiAob3BlcmF0b3JJbmRleCA9XHJcbiAgICAgICAgICAgICAgICBleGVjdXRlci5tZXJnZWROb2Rlcy5pbmRleE9mKGNoYW5uZWwuY3JlYXRvclByb2Nlc3NOb2RlKSApICE9IC0xIClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gaXQncyB0cmFuc2ZlciBpbnB1dFxyXG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dEluZGV4ID0gZ2V0T3BlcmF0b3JPdXRwdXRJbmRleChjaGFubmVsLmNyZWF0b3JQcm9jZXNzTm9kZSwgY2hhbm5lbCk7XHJcbiAgICAgICAgICAgICAgICBlbnRyeS5zZXRUcmFuc2ZlcklucHV0KGosIG9wZXJhdG9ySW5kZXgsIG91dHB1dEluZGV4KTtcclxuICAgICAgICAgICAgICAgIHZhciBwcmV2T3BlcmF0b3IgPSBleGVjdXRlci5vcGVyYXRvckxpc3QuZW50cmllc1tvcGVyYXRvckluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmKCFwcmV2T3BlcmF0b3IuaXNGaW5hbE91dHB1dChvdXRwdXRJbmRleCkpe1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZPcGVyYXRvci5zZXRUcmFuc2Zlck91dHB1dChvdXRwdXRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgZGlyZWN0IGlucHV0XHJcblxyXG4gICAgICAgICAgICB2YXIgbWFwcGVkSW5wdXROYW1lID0gbWFwcGluZ1tqXS5zb3VyY2U7XHJcbiAgICAgICAgICAgIGlmKG5vZGUub3duZXIub3duZXIuX2NvbXB1dGVJbnB1dE1hcHBpbmcpXHJcbiAgICAgICAgICAgICAgICBtYXBwZWRJbnB1dE5hbWUgPSBub2RlLm93bmVyLm93bmVyLl9jb21wdXRlSW5wdXRNYXBwaW5nLmdldFNjcmlwdElucHV0TmFtZShtYXBwaW5nW2pdLnBhcmFtSWR4LCBtYXBwaW5nW2pdLnNvdXJjZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbiA9IG5ldyBQcm9ncmFtLlByb2dyYW1JbnB1dENvbm5lY3Rpb24oKTtcclxuICAgICAgICAgICAgY29ubmVjdGlvbi5jaGFubmVsID0gY2hhbm5lbDtcclxuICAgICAgICAgICAgY29ubmVjdGlvbi5hcnJheUFjY2VzcyA9IG1hcHBpbmdbal0uYXJyYXkgfHwgZmFsc2U7IC8vIFRPRE86IHJlbmFtZSB0byByYW5kb21BY2Nlc3NcclxuICAgICAgICAgICAgY29ubmVjdGlvbi5zZXF1ZW5jZUFjY2Vzc1R5cGUgPSBtYXBwaW5nW2pdLnNlcXVlbmNlIHx8IDA7XHJcbiAgICAgICAgICAgIGlmKGNvbm5lY3Rpb24uc2VxdWVuY2VBY2Nlc3NUeXBlKVxyXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5zZXF1ZW5jZUtleVNvdXJjZUNoYW5uZWwgPSBub2RlLmlucHV0Q2hhbm5lbHNbbWFwcGluZ1tqXS5rZXlTb3VyY2VdO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb25LZXkgPSBjb25uZWN0aW9uLmdldEtleSgpO1xyXG4gICAgICAgICAgICB2YXIgaW5wdXRTbG90SWR4ID0gY0RhdGEuaW5wdXRTbG90c1tjb25uZWN0aW9uS2V5XTtcclxuICAgICAgICAgICAgaWYoY2hhbm5lbCAmJiBpbnB1dFNsb3RJZHggIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgIC8vIERpcmVjdCBpbnB1dCBhbHJlYWR5IGV4aXN0c1xyXG4gICAgICAgICAgICAgICAgZW50cnkuc2V0RGlyZWN0SW5wdXQoaiwgaW5wdXRTbG90SWR4LCBtYXBwZWRJbnB1dE5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAvLyBuZXcgZGlyZWN0IGlucHV0XHJcbiAgICAgICAgICAgICAgICBpbnB1dFNsb3RJZHggPSBleGVjdXRlci5wcm9ncmFtRGF0YS5pbnB1dHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgY0RhdGEuaW5wdXRTbG90c1tjb25uZWN0aW9uS2V5XSA9IGlucHV0U2xvdElkeDtcclxuICAgICAgICAgICAgICAgIGV4ZWN1dGVyLnByb2dyYW1EYXRhLmlucHV0cy5wdXNoKGNvbm5lY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgZW50cnkuc2V0RGlyZWN0SW5wdXQoaiwgaW5wdXRTbG90SWR4LCBtYXBwZWRJbnB1dE5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdCBvdXRwdXQgaW5mbyBvZiBPcGVyYXRvckVudHJ5XHJcbiAqIEBwYXJhbSB7RXhlY3V0b3J9IGV4ZWN1dGVyXHJcbiAqIEBwYXJhbSB7T3BlcmF0b3JFbnRyeX0gZW50cnlcclxuICogQHBhcmFtIHt7fX0gY0RhdGFcclxuICogQHBhcmFtIHtQcm9jZXNzTm9kZX0gbm9kZVxyXG4gKi9cclxuICAgIGZ1bmN0aW9uIGNvbnN0cnVjdE91dHB1dENvbm5lY3Rpb24oZXhlY3V0ZXIsIGVudHJ5LCBjRGF0YSwgbm9kZSl7XHJcbiAgICAgICAgdmFyIG91dHB1dHMgPSBub2RlLm9wZXJhdG9yLm91dHB1dHM7XHJcbiAgICAgICAgdmFyIGlzT3V0cHV0Tm9kZSA9IHRydWU7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG91dHB1dHMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgc2xvdCA9IG5vZGUub3V0cHV0RGF0YVNsb3RzW291dHB1dHNbaV0ubmFtZV07XHJcbiAgICAgICAgICAgIHZhciBmaW5hbE91dHB1dE5hbWUgPSBnZXRGaW5hbE91dHB1dE5hbWUoc2xvdCwgY0RhdGEpO1xyXG4gICAgICAgICAgICBpZihmaW5hbE91dHB1dE5hbWUpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gIGV4ZWN1dGVyLnByb2dyYW1EYXRhLm91dHB1dHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZXhlY3V0ZXIucHJvZ3JhbURhdGEub3V0cHV0cy5wdXNoKHNsb3QpO1xyXG4gICAgICAgICAgICAgICAgZW50cnkuc2V0RmluYWxPdXRwdXQoaSwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgaWYoZmluYWxPdXRwdXROYW1lICE9PSB0cnVlKXtcclxuICAgICAgICAgICAgICAgICAgICBVdGlscy5uYW1lc2V0LnJlbW92ZShleGVjdXRlci51bnByb2Nlc3NlZERhdGFOYW1lcywgZmluYWxPdXRwdXROYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgaXNPdXRwdXROb2RlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzT3V0cHV0Tm9kZTsgLy8gVE9ETzogQ2hlY2sgaWYgY29tcHV0YXRpb24gb2YgaXNPdXRwdXROb2RlIGlzIHJlYWxseSBjb3JyZWN0P1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRPcGVyYXRvck91dHB1dEluZGV4KHByb2Nlc3NOb2RlLCBjaGFubmVsKXtcclxuICAgICAgICB2YXIgb3V0cHV0cyA9IHByb2Nlc3NOb2RlLm9wZXJhdG9yLm91dHB1dHM7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG91dHB1dHMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICBpZihjaGFubmVsLmdldERhdGFFbnRyeSgpID09IHByb2Nlc3NOb2RlLm91dHB1dERhdGFTbG90c1tvdXRwdXRzW2ldLm5hbWVdLmRhdGFFbnRyeSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRGaW5hbE91dHB1dE5hbWUoZGF0YVNsb3QsIGNEYXRhKXtcclxuICAgICAgICBpZighY0RhdGEuZmluYWxPdXRwdXQpIC8vIElmIHJvb3Qgb2YgRXhlY3V0b3IgaXMgYSBQcm9jZXNzTm9kZSB3ZSBkb24ndCBoYXZlIGZpbmFsT3V0cHV0IGRlZmluZWQgYW5kIGFsbCBvdXRwdXRzIGFyZSBmaW5hbC5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgZm9yKHZhciBuYW1lIGluIGNEYXRhLmZpbmFsT3V0cHV0KXtcclxuICAgICAgICAgICAgaWYoY0RhdGEuZmluYWxPdXRwdXRbbmFtZV0gPT0gZGF0YVNsb3QuZGF0YUVudHJ5KXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb25zdHJ1Y3RMb3N0T3V0cHV0KGV4ZWN1dGVyLCBjRGF0YSl7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNEYXRhLmNvbnN0cnVjdGlvbk9yZGVyLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSBjRGF0YS5jb25zdHJ1Y3Rpb25PcmRlcltpXTtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gZXhlY3V0ZXIub3BlcmF0b3JMaXN0LmVudHJpZXNbaV07XHJcblxyXG4gICAgICAgICAgICB2YXIgb3V0cHV0cyA9IG5vZGUub3BlcmF0b3Iub3V0cHV0cztcclxuICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IG91dHB1dHMubGVuZ3RoOyArK2ope1xyXG4gICAgICAgICAgICAgICAgaWYoIWVudHJ5LmlzRmluYWxPdXRwdXQoaikgJiYgISBlbnRyeS5pc1RyYW5zZmVyT3V0cHV0KGopKXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBleGVjdXRlci5wcm9ncmFtRGF0YS5vdXRwdXRzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBleGVjdXRlci5wcm9ncmFtRGF0YS5vdXRwdXRzLnB1c2gobm9kZS5vdXRwdXREYXRhU2xvdHNbb3V0cHV0c1tqXS5uYW1lXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZW50cnkuc2V0TG9zdE91dHB1dChqLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZUl0ZXJhdGVTdGF0ZShleGVjdXRlcil7XHJcbiAgICAgICAgdmFyIGlucHV0cyA9IGV4ZWN1dGVyLnByb2dyYW1EYXRhLmlucHV0cztcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZXhlY3V0ZXIucHJvZ3JhbURhdGEuaW5wdXRzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gZXhlY3V0ZXIucHJvZ3JhbURhdGEuZ2V0RGF0YUVudHJ5KGkpO1xyXG4gICAgICAgICAgICB2YXIgaXRlcmF0ZUNvdW50ID0gZW50cnkgPyBlbnRyeS5nZXRJdGVyYXRlQ291bnQgPyBlbnRyeS5nZXRJdGVyYXRlQ291bnQoKSA6IDEgOiAwO1xyXG4gICAgICAgICAgICBpZighaXRlcmF0ZUNvdW50KVxyXG4gICAgICAgICAgICAgICAgZXhlY3V0ZXIub3BlcmF0b3JMaXN0LnNldElucHV0SXRlcmF0ZVR5cGUoaSwgQy5JVEVSQVRJT05fVFlQRS5OVUxMKTtcclxuICAgICAgICAgICAgZWxzZSBpZighaW5wdXRzW2ldLmFycmF5QWNjZXNzICYmIGl0ZXJhdGVDb3VudCA+IDEpXHJcbiAgICAgICAgICAgICAgICBleGVjdXRlci5vcGVyYXRvckxpc3Quc2V0SW5wdXRJdGVyYXRlVHlwZShpLCBDLklURVJBVElPTl9UWVBFLk1BTlkpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBleGVjdXRlci5vcGVyYXRvckxpc3Quc2V0SW5wdXRJdGVyYXRlVHlwZShpLCBDLklURVJBVElPTl9UWVBFLk9ORSk7XHJcblxyXG4gICAgICAgICAgICBpZihpbnB1dHNbaV0uYXJyYXlBY2Nlc3MgJiYgcGxhdGZvcm1SZXF1aXJlc0FycmF5U2l6ZShleGVjdXRlci4gcGxhdGZvcm0pKXtcclxuICAgICAgICAgICAgICAgIGV4ZWN1dGVyLm9wZXJhdG9yTGlzdC5zZXRJbnB1dFNpemUoaSwgaXRlcmF0ZUNvdW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuLyoqXHJcbiAqIERldGVybWluZSBpZiB0aGUgcGxhdGZvcm0gbmVlZHMgdG8gZGVjbGFyZSB1bmlmb3JtIGFycmF5IHNpemVzIGluIHRoZSBzb3VyY2UgY29kZS5cclxuICogQHBhcmFtIHBsYXRmb3JtXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuICAgIGZ1bmN0aW9uIHBsYXRmb3JtUmVxdWlyZXNBcnJheVNpemUocGxhdGZvcm0pe1xyXG4gICAgICAgIHJldHVybiBwbGF0Zm9ybSA9PSBDLlBMQVRGT1JNLkdMU0w7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHJ1blN1Yk5vZGVzKGV4ZWN1dGVyKXtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZXhlY3V0ZXIuc3ViTm9kZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICBleGVjdXRlci5zdWJOb2Rlc1tpXS5wcm9jZXNzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRvcjtcclxuIiwidmFyIEJhc2UgPSByZXF1aXJlKFwiLi4vYmFzZS5qc1wiKTtcclxudmFyIEMgPSByZXF1aXJlKFwiLi8uLi9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xyXG5cclxuXHJcbnZhciBvcmRlck1hcHBpbmdQYXJzZXIgPSAvXihbXjose31dKykoLFteOnt9LF0rKSokLztcclxudmFyIG5hbWVNYXBwaW5nUGFyc2VyID0gL15cXHsoKFteOix7fV0rOlteOnt9LF0rKSgsW146e30sXSs6W146fSxdKykqKX0kLztcclxuXHJcbi8qKlxyXG4gKiBBIG1hcHBpbmcgdXNlZCBmb3IgYSBmaWx0ZXIgb3IgYSBjb21wdXRlIHByb3BlcnRpZXMgb2YgYSBEYXRhTm9kZVxyXG4gKiBAYWJzdHJhY3RcclxuICovXHJcbnZhciBNYXBwaW5nID0gZnVuY3Rpb24oKXtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge0FycmF5PERhdGFOb2RlPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5fb3duZXJzID0gW107XHJcbn07XHJcblxyXG4vKipcclxuICogUGFyc2UgYSBNYXBwaW5nIChib3RoIEMuT3JkZXJNYXBwaW5nIG9yIEMuQ29tcHV0ZU1hcHBpbmcpIGZyb20gYSBzeW50YXggc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzeW50YXggc3RyaW5nLlxyXG4gKiBAcGFyYW0ge0MuRGF0YU5vZGV9IGRhdGFOb2RlIERhdGFOb2RlIG9mIHRoZSBNYXBwaW5nXHJcbiAqIEByZXR1cm5zIHs/Qy5NYXBwaW5nfVxyXG4gKi9cclxuTWFwcGluZy5wYXJzZSA9IGZ1bmN0aW9uKHN0cmluZywgZGF0YU5vZGUpe1xyXG4gICAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcclxuICAgIHZhciByZXN1bHRzID0gc3RyaW5nLnRyaW0oKS5tYXRjaChvcmRlck1hcHBpbmdQYXJzZXIpO1xyXG4gICAgaWYocmVzdWx0cylcclxuICAgICAgICByZXR1cm4gT3JkZXJNYXBwaW5nLnBhcnNlKHN0cmluZywgZGF0YU5vZGUpO1xyXG4gICAgcmVzdWx0cyA9IHN0cmluZy50cmltKCkubWF0Y2gobmFtZU1hcHBpbmdQYXJzZXIpO1xyXG4gICAgaWYocmVzdWx0cylcclxuICAgICAgICByZXR1cm4gTmFtZU1hcHBpbmcucGFyc2UocmVzdWx0c1sxXSwgZGF0YU5vZGUpO1xyXG4gICAgQmFzZS5ub3RpZnlFcnJvcihcIkNhbm5vdCBwYXJzZSBuYW1lIG1hcHBpbmcgJ1wiICsgc3RyaW5nICsgXCInXCIsIGRhdGFOb2RlKTtcclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IG93bmVyXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5NYXBwaW5nLnByb3RvdHlwZS5fYWRkT3duZXIgPSBmdW5jdGlvbihvd25lcil7XHJcbiAgICB2YXIgaWR4ID0gdGhpcy5fb3duZXJzLmluZGV4T2Yob3duZXIpO1xyXG4gICAgaWYoaWR4ID09IC0xKVxyXG4gICAgICAgIHRoaXMuX293bmVycy5wdXNoKG93bmVyKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ge0RhdGFOb2RlfSBvd25lclxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuTWFwcGluZy5wcm90b3R5cGUuX3JlbW92ZU93bmVyID0gZnVuY3Rpb24ob3duZXIpe1xyXG4gICAgdmFyIGlkeCA9IHRoaXMuX293bmVycy5pbmRleE9mKG93bmVyKTtcclxuICAgIGlmKGlkeCAhPSAtMSlcclxuICAgICAgICB0aGlzLl9vd25lcnMuc3BsaWNlKGlkeCwgLTEpO1xyXG59O1xyXG5cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBPcmRlck1hcHBpbmdcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vKipcclxuICogQW4gT3JkZXJNYXBwaW5nIHVzZWQgZm9yIGEgZmlsdGVyIG9yIGNvbXB1dGUgcHJvcGVydGllcyBvZiBhIERhdGFOb2RlXHJcbiAqIEl0IGRlc2NyaWJlcyBhIG1hcHBpbmcgb2YgbmFtZXMgcmVmZXJyaW5nIHRvIHRoZSBvcmRlciBvZiBhcmd1bWVudHMgLyBvdXRwdXQgdmFsdWVzLlxyXG4gKiBPcmRlck1hcHBpbmcgc3ludGF4IGV4YW1wbGVzIGluIGNvbXB1dGU6XHJcbiAqIHBvc2l0aW9uID0gQy5tb3JwaChwb3NpdGlvbiwgcG9zQWRkLCB3ZWlnaHQpXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyB7TWFwcGluZ31cclxuICovXHJcbnZhciBPcmRlck1hcHBpbmcgPSBmdW5jdGlvbigpe1xyXG4gICAgTWFwcGluZy5jYWxsKHRoaXMpO1xyXG4gICAgdGhpcy5fbmFtZXMgPSBbXTtcclxufTtcclxuQmFzZS5jcmVhdGVDbGFzcyhPcmRlck1hcHBpbmcsIE1hcHBpbmcpO1xyXG5cclxuT3JkZXJNYXBwaW5nLnBhcnNlID0gZnVuY3Rpb24oc3RyaW5nLCBkYXRhTm9kZSl7XHJcbiAgICB2YXIgbWFwcGluZyA9IG5ldyBPcmRlck1hcHBpbmcoZGF0YU5vZGUpO1xyXG4gICAgdmFyIHRva2VuID0gc3RyaW5nLnNwbGl0KFwiLFwiKTtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgbWFwcGluZy5fbmFtZXMucHVzaCh0b2tlbltpXS50cmltKCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hcHBpbmc7XHJcbn07XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE9yZGVyTWFwcGluZy5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcclxuICAgIHNldDogZnVuY3Rpb24oKXsgdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIGlzIHJlYWQtb25seVwiKTtcclxuICAgIH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9uYW1lcy5sZW5ndGg7IH1cclxufSk7XHJcblxyXG5PcmRlck1hcHBpbmcucHJvdG90eXBlLmdldE5hbWUgPSBmdW5jdGlvbihpZHgpe1xyXG4gICAgcmV0dXJuIHRoaXMuX25hbWVzW2lkeF07XHJcbn07XHJcblxyXG5PcmRlck1hcHBpbmcucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuX25hbWVzID0gW107XHJcbiAgICBtYXBwaW5nTm90aWZ5T3duZXIodGhpcyk7XHJcbn07XHJcblxyXG5PcmRlck1hcHBpbmcucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbihpbmRleCwgbmFtZSl7XHJcbiAgICB0aGlzLl9uYW1lc1tpbmRleF0gPSBuYW1lO1xyXG4gICAgbWFwcGluZ05vdGlmeU93bmVyKHRoaXMpO1xyXG59O1xyXG5cclxuXHJcbi8vbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xyXG5PcmRlck1hcHBpbmcucHJvdG90eXBlLnJlbW92ZU5hbWUgPSBmdW5jdGlvbihpbmRleCl7XHJcbiAgICB0aGlzLl9uYW1lcy5zcGxpY2UoaW5kZXgpO1xyXG4gICAgbWFwcGluZ05vdGlmeU93bmVyKHRoaXMpO1xyXG59O1xyXG5cclxuT3JkZXJNYXBwaW5nLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLl9uYW1lcy5sZW5ndGggPT0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NoYW5uZWxNYXB9IGRlc3RNYXBcclxuICogQHBhcmFtIHtDaGFubmVsTWFwfSBzb3VyY2VNYXBcclxuICogQHBhcmFtIHtleHBvcnRzLkMuREFUQV9GSUxURVJfVFlQRX0gZmlsdGVyVHlwZVxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKENoYW5uZWxNYXAsIHN0cmluZywgQ2hhbm5lbE1hcCwgc3RyaW5nKX0gY2FsbGJhY2tcclxuICovXHJcbk9yZGVyTWFwcGluZy5wcm90b3R5cGUuYXBwbHlGaWx0ZXJPbkNoYW5uZWxNYXAgPSBmdW5jdGlvbihkZXN0TWFwLCBzb3VyY2VNYXAsIGZpbHRlclR5cGUsIGNhbGxiYWNrKXtcclxuICAgIHZhciBpO1xyXG4gICAgaWYoZmlsdGVyVHlwZSA9PSBDLkRBVEFfRklMVEVSX1RZUEUuS0VFUCl7XHJcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgdGhpcy5fbmFtZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMuX25hbWVzW2ldO1xyXG4gICAgICAgICAgICBpZihzb3VyY2VNYXAubWFwW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhkZXN0TWFwLCBuYW1lLCBzb3VyY2VNYXAsIG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgICBmb3IoaSBpbiBzb3VyY2VNYXAubWFwKXtcclxuICAgICAgICAgICAgdmFyIGlkeCA9IHRoaXMuX25hbWVzLmluZGV4T2YoaSk7XHJcbiAgICAgICAgICAgIGlmKGZpbHRlclR5cGUgPT0gQy5EQVRBX0ZJTFRFUl9UWVBFLlJFTkFNRSB8fFxyXG4gICAgICAgICAgICAgICAgKGZpbHRlclR5cGUgPT0gQy5EQVRBX0ZJTFRFUl9UWVBFLlJFTU9WRSAmJiBpZHggPT0gLTEpKVxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZGVzdE1hcCwgaSwgc291cmNlTWFwLCBpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIHRoZSBuYW1lIG9mIHRoZSBpbnB1dCB2YWx1ZSBhc3NpZ25lZCB0byBvcGVyYXRvciBhcmd1bWVudC5cclxuICogUmV0dXJucyBudWxsLCBpZiBubyBtYXBwaW5nIGlzIGRlZmluZWQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBQb3NpdGlvbiBvZiB0aGUgb3BlcmF0b3IgYXJndW1lbnRcclxuICogQHJldHVybnMge3N0cmluZ3xudWxsfVxyXG4gKi9cclxuT3JkZXJNYXBwaW5nLnByb3RvdHlwZS5nZXRTY3JpcHRJbnB1dE5hbWUgPSBmdW5jdGlvbihpbmRleCAvKiwgZGVzdE5hbWUgKi8pe1xyXG4gICAgaWYodGhpcy5fbmFtZXNbaW5kZXhdKVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lc1tpbmRleF07XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgb3V0cHV0IHBhcmFtZXRlciBhcyBpdCBzaG91bGQgYmUgdXNlZCBmb3IgdGhlXHJcbiAqIGZvbGxvd2luZyBkYXRhZmxvdy4gUmV0dXJucyBudWxsLCBpZiBubyBtYXBwaW5nIGlzIGRlZmluZWQuXHJcbiAqIEBwYXJhbSBpbmRleFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9XHJcbiAqL1xyXG5PcmRlck1hcHBpbmcucHJvdG90eXBlLmdldFNjcmlwdE91dHB1dE5hbWUgPSBmdW5jdGlvbihpbmRleCAvKiwgc3JjTmFtZSAqLyl7XHJcbiAgICBpZih0aGlzLl9uYW1lc1tpbmRleF0pXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWVzW2luZGV4XTtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG5hbWUgb2YgdGhlIG91dHB1dCBwYXJhbWV0ZXIgYXMgaXQgc2hvdWxkIGJlIHVzZWQgZm9yIHRoZVxyXG4gKiBmb2xsb3dpbmcgZGF0YWZsb3cuIFJldHVybnMgbnVsbCwgaWYgbm8gbWFwcGluZyBpcyBkZWZpbmVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdE5hbWVcclxuICogQHBhcmFtIHthcnJheTxvYmplY3Q+fSBvcGVyYXRvck91dHB1dHNcclxuICogQHJldHVybnMge3N0cmluZ3xudWxsfVxyXG4gKi9cclxuT3JkZXJNYXBwaW5nLnByb3RvdHlwZS5nZXRTY3JpcHRPdXRwdXROYW1lSW52ID0gZnVuY3Rpb24oZGVzdE5hbWUsIG9wZXJhdG9yT3V0cHV0cyl7XHJcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9uYW1lcy5pbmRleE9mKGRlc3ROYW1lKTtcclxuICAgIGlmKGluZGV4ID09IC0xKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIG9wZXJhdG9yT3V0cHV0c1tpbmRleF0ubmFtZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJZGVudGl0eSBmdW5jdGlvbi4gVXNlZCB0byBpbXBsZW1lbnQgaW50ZXJmYWNlLiBVc3VhbGx5IHlvdSBkb24ndCByZW5hbWUgd2l0aCBvcmRlclxyXG4gKiBtYXBwaW5nLlxyXG4gKiBAcGFyYW0gbmFtZVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuT3JkZXJNYXBwaW5nLnByb3RvdHlwZS5nZXRSZW5hbWVTcmNOYW1lID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgICByZXR1cm4gbmFtZTtcclxufTtcclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBOYW1lTWFwcGluZ1xyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbi8qKlxyXG4gKiBBbiBOYW1lTWFwcGluZyB1c2VkIGZvciBhIGZpbHRlciBvciBjb21wdXRlIHByb3BlcnRpZXMgb2YgYSBEYXRhTm9kZVxyXG4gKiBJdCBkZXNjcmliZXMgYSBtYXBwaW5nIG9mIG5hbWVzIHJlZmVycmluZyB0byB0aGUgb3JpZ2luYWwgbmFtZXMgb2YgdGhlIGFyZ3VtZW50cyAvIG91dHB1dCB2YWx1ZXMuXHJcbiAqIE5hbWVNYXBwaW5nIHN5bnRheCBleGFtcGxlcyBpbiBjb21wdXRlOlxyXG4gKiB7cG9zaXRpb246IHJlc3VsdH0gPSBDLm1vcnBoKHt2YWx1ZTogcG9zaXRpb24sIHZhbHVlQWRkOiBwb3NBZGQsIHdlaWdodDogd2VpZ2h0fSlcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIHtNYXBwaW5nfVxyXG4gKi9cclxudmFyIE5hbWVNYXBwaW5nID0gZnVuY3Rpb24oKXtcclxuICAgIE1hcHBpbmcuY2FsbCh0aGlzKTtcclxuICAgIHRoaXMuX2Rlc3ROYW1lcyA9IFtdO1xyXG4gICAgdGhpcy5fc3JjTmFtZXMgPSBbXTtcclxuXHJcbn07XHJcbkJhc2UuY3JlYXRlQ2xhc3MoTmFtZU1hcHBpbmcsIE1hcHBpbmcpO1xyXG5cclxuTmFtZU1hcHBpbmcucGFyc2UgPSBmdW5jdGlvbihzdHJpbmcsIGRhdGFOb2RlKSAge1xyXG4gICAgdmFyIG1hcHBpbmcgPSBuZXcgTmFtZU1hcHBpbmcoZGF0YU5vZGUpO1xyXG4gICAgdmFyIHRva2VuID0gc3RyaW5nLnNwbGl0KFwiLFwiKTtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgdmFyIHBhaXIgPSB0b2tlbltpXS5zcGxpdChcIjpcIik7XHJcbiAgICAgICAgdmFyIGRlc3QgPSBwYWlyWzBdLnRyaW0oKTsgdmFyIHNyYyA9IHBhaXJbMV0udHJpbSgpO1xyXG4gICAgICAgIG1hcHBpbmcuc2V0TmFtZVBhaXIoZGVzdCwgc3JjKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtYXBwaW5nO1xyXG59O1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE5hbWVNYXBwaW5nLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbigpeyB0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggaXMgcmVhZC1vbmx5XCIpO1xyXG4gICAgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX3NyY05hbWVzLmxlbmd0aDsgfVxyXG59KTtcclxuXHJcbk5hbWVNYXBwaW5nLnByb3RvdHlwZS5nZXREZXN0TmFtZSA9IGZ1bmN0aW9uKGlkeCl7XHJcbiAgICByZXR1cm4gdGhpcy5fZGVzdE5hbWVzW2lkeF07XHJcbn07XHJcbk5hbWVNYXBwaW5nLnByb3RvdHlwZS5nZXRTcmNOYW1lID0gZnVuY3Rpb24oaWR4KXtcclxuICAgIHJldHVybiB0aGlzLl9zcmNOYW1lc1tpZHhdO1xyXG59O1xyXG5cclxuTmFtZU1hcHBpbmcucHJvdG90eXBlLmdldFNyY05hbWVGcm9tRGVzdE5hbWUgPSBmdW5jdGlvbihkZXN0TmFtZSl7XHJcbiAgICB2YXIgaWR4ID0gdGhpcy5fZGVzdE5hbWVzLmluZGV4T2YoZGVzdE5hbWUpO1xyXG4gICAgcmV0dXJuIGlkeCA9PSAtMSA/IG51bGwgOiB0aGlzLl9zcmNOYW1lc1tpZHhdO1xyXG59O1xyXG5OYW1lTWFwcGluZy5wcm90b3R5cGUuZ2V0RGVzdE5hbWVGcm9tU3JjTmFtZSA9IGZ1bmN0aW9uKHNyY05hbWUpe1xyXG4gICAgdmFyIGlkeCA9IHRoaXMuX3NyY05hbWVzLmluZGV4T2Yoc3JjTmFtZSk7XHJcbiAgICByZXR1cm4gaWR4ID09IC0xID8gbnVsbCA6IHRoaXMuX2Rlc3ROYW1lc1tpZHhdO1xyXG59O1xyXG5cclxuTmFtZU1hcHBpbmcucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuX3NyY05hbWVzID0gW107XHJcbiAgICB0aGlzLl9kZXN0TmFtZXMgPSBbXTtcclxuICAgIG1hcHBpbmdOb3RpZnlPd25lcih0aGlzKTtcclxufTtcclxuXHJcbk5hbWVNYXBwaW5nLnByb3RvdHlwZS5zZXROYW1lUGFpciA9IGZ1bmN0aW9uKGRlc3ROYW1lLCBzcmNOYW1lKXtcclxuICAgIHZhciBpZHggPSB0aGlzLl9kZXN0TmFtZXMuaW5kZXhPZihkZXN0TmFtZSk7XHJcbiAgICBpZihpZHggIT0gLTEpe1xyXG4gICAgICAgIHRoaXMuX2Rlc3ROYW1lcy5zcGxpY2UoaWR4LDEpO1xyXG4gICAgICAgIHRoaXMuX3NyY05hbWVzLnNwbGljZShpZHgsMSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9kZXN0TmFtZXMucHVzaChkZXN0TmFtZSk7XHJcbiAgICB0aGlzLl9zcmNOYW1lcy5wdXNoKHNyY05hbWUpO1xyXG4gICAgbWFwcGluZ05vdGlmeU93bmVyKHRoaXMpO1xyXG59O1xyXG5cclxuLy9ub2luc3BlY3Rpb24gSlNVbnVzZWRHbG9iYWxTeW1ib2xzXHJcbk5hbWVNYXBwaW5nLnByb3RvdHlwZS5yZW1vdmVOYW1lUGFpciA9IGZ1bmN0aW9uKGRlc3ROYW1lKXtcclxuICAgIHZhciBpZHggPSB0aGlzLl9kZXN0TmFtZXMuaW5kZXhPZihkZXN0TmFtZSk7XHJcbiAgICBpZihpZHggIT0gLTEpe1xyXG4gICAgICAgIHRoaXMuX2Rlc3ROYW1lcy5zcGxpY2UoaWR4LDEpO1xyXG4gICAgICAgIHRoaXMuX3NyY05hbWVzLnNwbGljZShpZHgsMSk7XHJcbiAgICB9XHJcbiAgICBtYXBwaW5nTm90aWZ5T3duZXIodGhpcyk7XHJcbn07XHJcblxyXG5OYW1lTWFwcGluZy5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpcy5fZGVzdE5hbWVzLmxlbmd0aCA9PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBzZWUgT3JkZXJNYXBwaW5nLmFwcGx5RmlsdGVyT25DaGFubmVsTWFwXHJcbiAqIEBwYXJhbSB7Q2hhbm5lbE1hcH0gZGVzdE1hcFxyXG4gKiBAcGFyYW0ge0NoYW5uZWxNYXB9IHNvdXJjZU1hcFxyXG4gKiBAcGFyYW0ge0MuREFUQV9GSUxURVJfVFlQRX0gZmlsdGVyVHlwZVxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gKi9cclxuTmFtZU1hcHBpbmcucHJvdG90eXBlLmFwcGx5RmlsdGVyT25DaGFubmVsTWFwID0gZnVuY3Rpb24oZGVzdE1hcCwgc291cmNlTWFwLCBmaWx0ZXJUeXBlLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIGk7XHJcbiAgICBpZihmaWx0ZXJUeXBlID09IEMuREFUQV9GSUxURVJfVFlQRS5SRU1PVkUpe1xyXG4gICAgICAgIGZvcihpIGluIHNvdXJjZU1hcC5tYXApXHJcbiAgICAgICAgICAgIGlmKHRoaXMuX3NyY05hbWVzLmluZGV4T2YoaSkgPT0gLTEpXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhkZXN0TWFwLCBpLCBzb3VyY2VNYXAsIGkpO1xyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgICBpZihmaWx0ZXJUeXBlID09IEMuREFUQV9GSUxURVJfVFlQRS5SRU5BTUUpe1xyXG4gICAgICAgICAgICBmb3IoaSBpbiBzb3VyY2VNYXAubWFwKVxyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fc3JjTmFtZXMuaW5kZXhPZihpKSA9PSAtMSlcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhkZXN0TWFwLCBpLCBzb3VyY2VNYXAsIGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IoaSBpbiB0aGlzLl9kZXN0TmFtZXMpe1xyXG4gICAgICAgICAgICBjYWxsYmFjayhkZXN0TWFwLCB0aGlzLl9kZXN0TmFtZXNbaV0sIHNvdXJjZU1hcCwgdGhpcy5fc3JjTmFtZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW5hbWVzOiBMb29rLXVwIHRoZSBkZXN0aW5hdGlvbiBuYW1lIGFuZCByZXR1cm4gdGhlIHNvdXJjZSBuYW1lXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5OYW1lTWFwcGluZy5wcm90b3R5cGUuZ2V0UmVuYW1lU3JjTmFtZSA9IGZ1bmN0aW9uKG5hbWUpe1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0U3JjTmFtZUZyb21EZXN0TmFtZShuYW1lKSB8fCBuYW1lO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgaW5wdXQgdmFsdWUgYXNzaWduZWQgdG8gb3BlcmF0b3IgYXJndW1lbnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFBvc2l0aW9uIG9mIHRoZSBvcGVyYXRvciBhcmd1bWVudFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdGluYXRpb25OYW1lIE5hbWUgb2YgdGhlIG9wZXJhdG9yIGFyZ3VtZW50XHJcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH1cclxuICovXHJcbk5hbWVNYXBwaW5nLnByb3RvdHlwZS5nZXRTY3JpcHRJbnB1dE5hbWU9IGZ1bmN0aW9uKGluZGV4LCBkZXN0aW5hdGlvbk5hbWUpe1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0U3JjTmFtZUZyb21EZXN0TmFtZShkZXN0aW5hdGlvbk5hbWUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBzZWUgT3JkZXJNYXBwaW5nLmdldFNjcmlwdE91dHB1dE5hbWVcclxuICovXHJcbk5hbWVNYXBwaW5nLnByb3RvdHlwZS5nZXRTY3JpcHRPdXRwdXROYW1lID0gZnVuY3Rpb24oaW5kZXgsIHNyY05hbWUpe1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0RGVzdE5hbWVGcm9tU3JjTmFtZShzcmNOYW1lKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAc2VlIE9yZGVyTWFwcGluZy5nZXRTY3JpcHRPdXRwdXROYW1lSW52XHJcbiAqL1xyXG5OYW1lTWFwcGluZy5wcm90b3R5cGUuZ2V0U2NyaXB0T3V0cHV0TmFtZUludiA9IGZ1bmN0aW9uKGRlc3ROYW1lIC8qLCBvcGVyYXRvck91dHB1dHMgKi8pe1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZGVzdE5hbWVzLmluZGV4T2YoZGVzdE5hbWUpO1xyXG4gICAgaWYoaW5kZXggPT0gLTEpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gdGhpcy5fc3JjTmFtZXNbaW5kZXhdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE5vdGlmeSBhbGwgRGF0YU5vZGVzIHRoYXQgdXNlIHRoZSBtYXBwaW5nIHBhc3NlZCB0byB0aGUgZnVuY3Rpb25cclxuICogQHBhcmFtIHtNYXBwaW5nfSBtYXBwaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXBwaW5nTm90aWZ5T3duZXIobWFwcGluZyl7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbWFwcGluZy5fb3duZXJzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgbWFwcGluZy5fb3duZXJzW2ldLm5vdGlmeShDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XHJcbiAgICB9XHJcbiAgICBCYXNlLl9mbHVzaFJlc3VsdENhbGxiYWNrcygpO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgTmFtZU1hcHBpbmc6IE5hbWVNYXBwaW5nLFxyXG4gICAgT3JkZXJNYXBwaW5nOiBPcmRlck1hcHBpbmcsXHJcbiAgICBNYXBwaW5nOiBNYXBwaW5nXHJcbn07XHJcbiIsInZhciBCYXNlID0gcmVxdWlyZShcIi4uL2Jhc2UuanNcIik7XHJcbnZhciBDID0gcmVxdWlyZShcIi4uL2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XHJcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy91dGlscy5qc1wiKTtcclxudmFyIEV4ZWN1dG9yID0gcmVxdWlyZShcIi4vZXhlY3V0b3IuanNcIik7XHJcbnZhciBSZXN1bHQgPSByZXF1aXJlKFwiLi9yZXN1bHQuanNcIik7XHJcbnZhciBPcGVyYXRvciA9IHJlcXVpcmUoXCIuLi9vcGVyYXRvci9vcGVyYXRvci5qc1wiKTtcclxudmFyIERhdGEgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlL2RhdGEuanNcIik7XHJcbnZhciBEYXRhU2xvdCA9IHJlcXVpcmUoXCIuLi9wcm9jZXNzaW5nL2RhdGEtc2xvdC5qc1wiKTtcclxuXHJcbnZhciBCdWZmZXJFbnRyeSA9IERhdGEuQnVmZmVyRW50cnk7XHJcbnZhciBUZXh0dXJlRW50cnkgPSBEYXRhLlRleHR1cmVFbnRyeTtcclxudmFyIEltYWdlRGF0YVRleHR1cmVFbnRyeSA9IERhdGEuSW1hZ2VEYXRhVGV4dHVyZUVudHJ5O1xyXG5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIEMuUHJvY2Vzc05vZGVcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG52YXIgQVNZTkNfUFJPQ0VTU19TVEFURSA9IHtcclxuICAgIElETEUgOiAwLFxyXG4gICAgUlVOTklORyA6IDEsXHJcbiAgICBSRVNDSEVEVUxFRCA6IDIsXHJcbiAgICBJTklUOiAzXHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIE9wdGltaXplZCByZXByZXNlbnRhdGlvbiBmb3IgdGhlIHByb2Nlc3NpbmcgZ3JhcGguIE9ubHkgY3JlYXRlZCBmb3IgQ2hhbm5lbE5vZGVzIHdpdGggb3BlcmF0b3JzLlxyXG4gKiBJcyBjb25uZWN0ZWQgZGlyZWN0bHkgdG8gb3RoZXIgUHJvY2Vzc05vZGVzLCBpZ25vcmluZyBjaGFubmVscyB0aGF0IGFyZSBub3QgcmVsZXZhbnQgZm9yIHByb2Nlc3NpbmdcclxuICogQHBhcmFtIHtDaGFubmVsTm9kZX0gY2hhbm5lbE5vZGVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIHtHcmFwaE5vZGV9XHJcbiAqL1xyXG52YXIgUHJvY2Vzc05vZGUgPSBmdW5jdGlvbihjaGFubmVsTm9kZSl7XHJcbiAgICB0aGlzLm93bmVyID0gY2hhbm5lbE5vZGU7XHJcbiAgICB0aGlzLm9wZXJhdG9yID0gY2hhbm5lbE5vZGUub3BlcmF0b3I7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnB1dCBjaGFubmVscyBmb3IgdGhlIG9wZXJhdG9yXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIENoYW5uZWw+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmlucHV0Q2hhbm5lbHMgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE91dHB1dHMgb2Ygb3BlcmF0b3JcclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgRGF0YVNsb3Q+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm91dHB1dERhdGFTbG90cyA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge2V4cG9ydHMuQy5QUk9DRVNTX1NUQVRFfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnN0YXR1cyA9IEMuUFJPQ0VTU19TVEFURS5NT0RJRklFRDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtBU1lOQ19QUk9DRVNTX1NUQVRFfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmFzeW5jUHJvY2Vzc1N0YXRlID0gQVNZTkNfUFJPQ0VTU19TVEFURS5JTklUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGlyZWN0IENoaWxkcmVuIHdpdGhvdXQgdHJhbnNpdGl2ZSBjaGlsZHJlbiBvZiBjaGlsZHJlblxyXG4gICAgICogVE9ETzogVXNlIFNldCgpP1xyXG4gICAgICogQHR5cGUge0FycmF5LjxQcm9jZXNzTm9kZT59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoaWxkcmVuIHdpdGggdHJhbnNpdGl2ZSBkZXBlbmRlbmNpZXNcclxuICAgICAqIFRPRE86IFVzZSBTZXQoKT9cclxuICAgICAqIEB0eXBlIHtBcnJheS48UHJvY2Vzc05vZGU+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRlc2NlbmRhbnRzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjaywgdGhlIGV4ZWN1dG9yIG5lZWRzIHRvIGNhbGwgd2hlbiB0aGUgY29tcHV0YXRpb24gaXMgcmVhZHlcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2JpbmRlZEFzeW5jQ2FsbGJhY2sgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5kZXggb2YgYXJyYXkgbWF0Y2hlcyBwbGF0Zm9ybSBpZCAoQy5QTEFURk9STSlcclxuICAgICAqIEB0eXBlIHtBcnJheS48RXhlY3V0b3I+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmV4ZWN1dGVycyA9IFtdO1xyXG5cclxuICAgIGNvbnN0cnVjdFByb2Nlc3NOb2RlKHRoaXMsIGNoYW5uZWxOb2RlKTtcclxuXHJcbiAgICBpZihPcGVyYXRvci5pc09wZXJhdG9yQXN5bmModGhpcy5vcGVyYXRvcikpe1xyXG4gICAgICAgIHRoaXMuX2JpbmRlZEFzeW5jQ2FsbGJhY2sgPSB0aGlzLnJlY2VpdmVBc3luY1Byb2Nlc3NpbmcuYmluZCh0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblByb2Nlc3NOb2RlLnByb3RvdHlwZS5vblhmbG93Q2hhbm5lbENoYW5nZSA9IGZ1bmN0aW9uKGNoYW5uZWwsIHN0YXRlKXtcclxuICAgIGlmIChPcGVyYXRvci5pc09wZXJhdG9yQXN5bmModGhpcy5vcGVyYXRvcikpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT0gQy5QUk9DRVNTX1NUQVRFLkxPQURJTkcgfHwgdGhpcy5hc3luY1Byb2Nlc3NTdGF0ZSAhPSBBU1lOQ19QUk9DRVNTX1NUQVRFLklOSVQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlBST0NFU1NfU1RBVEUuTU9ESUZJRUQ7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgaWYgKHN0YXRlID09IEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX1ZBTFVFICYmIHRoaXMuc3RhdHVzID4gQy5QUk9DRVNTX1NUQVRFLlVOUFJPQ0VTU0VEKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gQy5QUk9DRVNTX1NUQVRFLlVOUFJPQ0VTU0VEO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gQy5QUk9DRVNTX1NUQVRFLk1PRElGSUVEO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm5vdGlmeU91dHB1dENoYW5nZWQoc3RhdGUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuUHJvY2Vzc05vZGUucHJvdG90eXBlLnN0YXJ0QXN5bmNQcm9jZXNzaW5nID0gZnVuY3Rpb24oKXtcclxuICAgIGlmKHRoaXMuYXN5bmNQcm9jZXNzU3RhdGUgPT0gQVNZTkNfUFJPQ0VTU19TVEFURS5JRExFIHx8IHRoaXMuYXN5bmNQcm9jZXNzU3RhdGUgPT0gQVNZTkNfUFJPQ0VTU19TVEFURS5JTklUKXtcclxuICAgICAgICB0aGlzLmFzeW5jUHJvY2Vzc1N0YXRlID0gQVNZTkNfUFJPQ0VTU19TVEFURS5SVU5OSU5HO1xyXG4gICAgICAgIHZhciBleGVjdXRlciA9IGdldE9yQ3JlYXRlRXhlY3V0ZXIodGhpcywgQy5QTEFURk9STS5BU1lOQyk7XHJcbiAgICAgICAgZXhlY3V0ZXIucnVuKHRoaXMuX2JpbmRlZEFzeW5jQ2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgICB0aGlzLmFzeW5jUHJvY2Vzc1N0YXRlID0gQVNZTkNfUFJPQ0VTU19TVEFURS5SRVNDSEVEVUxFRDtcclxuICAgIH1cclxufTtcclxuUHJvY2Vzc05vZGUucHJvdG90eXBlLnJlY2VpdmVBc3luY1Byb2Nlc3NpbmcgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5zdGF0dXMgPSBDLlBST0NFU1NfU1RBVEUuUFJPQ0VTU0VEO1xyXG4gICAgdGhpcy5ub3RpZnlPdXRwdXRDaGFuZ2VkKEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX1NJWkVfVFlQRSk7XHJcbiAgICBpZih0aGlzLmFzeW5jUHJvY2Vzc1N0YXRlID09IEFTWU5DX1BST0NFU1NfU1RBVEUuUkVTQ0hFRFVMRUQpe1xyXG4gICAgICAgIHRoaXMuYXN5bmNQcm9jZXNzU3RhdGUgPSBBU1lOQ19QUk9DRVNTX1NUQVRFLklETEU7XHJcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlBST0NFU1NfU1RBVEUuTU9ESUZJRUQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgICB0aGlzLmFzeW5jUHJvY2Vzc1N0YXRlID0gQVNZTkNfUFJPQ0VTU19TVEFURS5JRExFO1xyXG4gICAgfVxyXG4gICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcclxufTtcclxuXHJcblxyXG5cclxuUHJvY2Vzc05vZGUucHJvdG90eXBlLm5vdGlmeU91dHB1dENoYW5nZWQgPSBmdW5jdGlvbihzdGF0ZSl7XHJcbiAgICBmb3IodmFyIG5hbWUgaW4gdGhpcy5vdXRwdXREYXRhU2xvdHMpe1xyXG4gICAgICAgIHRoaXMub3V0cHV0RGF0YVNsb3RzW25hbWVdLm5vdGlmeU9uQ2hhbmdlKHN0YXRlKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5Qcm9jZXNzTm9kZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpe1xyXG4gICAgZm9yKHZhciBuYW1lIGluIHRoaXMuaW5wdXRDaGFubmVscyl7XHJcbiAgICAgICAgdGhpcy5pbnB1dENoYW5uZWxzW25hbWVdICYmIHRoaXMuaW5wdXRDaGFubmVsc1tuYW1lXS5yZW1vdmVMaXN0ZW5lcih0aGlzKTtcclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0uY2xlYXIoKTtcclxuICAgIH1cclxufTtcclxuXHJcblByb2Nlc3NOb2RlLnByb3RvdHlwZS51cGRhdGVTdGF0ZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICBpZih0aGlzLnN0YXR1cyA9PSBDLlBST0NFU1NfU1RBVEUuTU9ESUZJRUQpe1xyXG4gICAgICAgIHRoaXMuc3RhdHVzID0gQy5QUk9DRVNTX1NUQVRFLlVOUFJPQ0VTU0VEO1xyXG5cclxuICAgICAgICBYTUwzRC5kZWJ1Zy5hc3NlcnQoIXRoaXMub3duZXIubG9hZGluZywgXCJUaGlzIHNob3VsZCBuZXZlciBoYXBwZW5cIik7XHJcblxyXG4gICAgICAgIGlmKHRoaXMub3duZXIubG9hZGluZylcclxuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlBST0NFU1NfU1RBVEUuTE9BRElORztcclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IE1hdGgubWluKHRoaXMuc3RhdHVzLCB0aGlzLmNoaWxkcmVuW2ldLnVwZGF0ZVN0YXRlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHRoaXMuc3RhdHVzID4gQy5QUk9DRVNTX1NUQVRFLkxPQURJTkcgJiYgaXNJbnB1dExvYWRpbmcodGhpcy5vcGVyYXRvciwgdGhpcy5pbnB1dENoYW5uZWxzKSlcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gQy5QUk9DRVNTX1NUQVRFLkxPQURJTkc7XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLnN0YXR1cyA+IEMuUFJPQ0VTU19TVEFURS5JTlZBTElEICYmXHJcbiAgICAgICAgICAgICAgICAhY2hlY2tJbnB1dCh0aGlzLCB0aGlzLm9wZXJhdG9yLCB0aGlzLm93bmVyLm93bmVyLl9jb21wdXRlSW5wdXRNYXBwaW5nLCB0aGlzLmlucHV0Q2hhbm5lbHMpKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlBST0NFU1NfU1RBVEUuSU5WQUxJRDtcclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMuc3RhdHVzID09IEMuUFJPQ0VTU19TVEFURS5VTlBST0NFU1NFRCAmJiBPcGVyYXRvci5pc09wZXJhdG9yQXN5bmModGhpcy5vcGVyYXRvcikpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSB0aGlzLmFzeW5jUHJvY2Vzc1N0YXRlID09IEFTWU5DX1BST0NFU1NfU1RBVEUuSU5JVCA/IEMuUFJPQ0VTU19TVEFURS5MT0FESU5HXHJcbiAgICAgICAgICAgICAgICAgICAgOiBDLlBST0NFU1NfU1RBVEUuUFJPQ0VTU0VEO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEFzeW5jUHJvY2Vzc2luZygpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnN0YXR1cztcclxufTtcclxuXHJcblByb2Nlc3NOb2RlLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24oKXtcclxuXHJcbiAgICBpZih0aGlzLnN0YXR1cyA9PSBDLlBST0NFU1NfU1RBVEUuVU5QUk9DRVNTRUQpe1xyXG4gICAgICAgIHZhciBleGVjdXRlciA9IGdldE9yQ3JlYXRlRXhlY3V0ZXIodGhpcywgdGhpcy5vd25lci5wbGF0Zm9ybSk7XHJcbiAgICAgICAgZXhlY3V0ZXIucnVuKCk7XHJcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlBST0NFU1NfU1RBVEUuUFJPQ0VTU0VEO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7UHJvY2Vzc05vZGV9IHByb2Nlc3NOb2RlXHJcbiAqIEBwYXJhbSB7Q2hhbm5lbE5vZGV9IGNoYW5uZWxOb2RlXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25zdHJ1Y3RQcm9jZXNzTm9kZShwcm9jZXNzTm9kZSwgY2hhbm5lbE5vZGUpe1xyXG4gICAgdmFyIGRhdGFOb2RlID0gY2hhbm5lbE5vZGUub3duZXI7XHJcbiAgICBzeW5jaHJvbml6ZUlucHV0Q2hhbm5lbHMocHJvY2Vzc05vZGUsIGNoYW5uZWxOb2RlLCBkYXRhTm9kZSk7XHJcbiAgICBzeW5jaHJvbml6ZUNoaWxkcmVuQW5kRGVzY2VuZGFudHMocHJvY2Vzc05vZGUuY2hpbGRyZW4sIHByb2Nlc3NOb2RlLmRlc2NlbmRhbnRzLCBwcm9jZXNzTm9kZS5pbnB1dENoYW5uZWxzKTtcclxuICAgIHN5bmNocm9uaXplT3V0cHV0KHByb2Nlc3NOb2RlLm9wZXJhdG9yLCBwcm9jZXNzTm9kZS5vdXRwdXREYXRhU2xvdHMpO1xyXG59XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHByb2Nlc3NOb2RlXHJcbiAqIEBwYXJhbSBjaGFubmVsTm9kZVxyXG4gKiBAcGFyYW0gZGF0YU5vZGVcclxuICovXHJcbmZ1bmN0aW9uIHN5bmNocm9uaXplSW5wdXRDaGFubmVscyhwcm9jZXNzTm9kZSwgY2hhbm5lbE5vZGUsIGRhdGFOb2RlKXtcclxuICAgIHZhciBvcGVyYXRvciA9IHByb2Nlc3NOb2RlLm9wZXJhdG9yLCBpbnB1dE1hcHBpbmcgPSBkYXRhTm9kZS5fY29tcHV0ZUlucHV0TWFwcGluZztcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvcGVyYXRvci5wYXJhbXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIHZhciBzb3VyY2VOYW1lID0gb3BlcmF0b3IucGFyYW1zW2ldLnNvdXJjZTtcclxuICAgICAgICB2YXIgZGF0YU5hbWUgPSBpbnB1dE1hcHBpbmcgPyBpbnB1dE1hcHBpbmcuZ2V0U2NyaXB0SW5wdXROYW1lKGksIHNvdXJjZU5hbWUpIDogc291cmNlTmFtZTtcclxuICAgICAgICBpZihkYXRhTmFtZSl7XHJcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gY2hhbm5lbE5vZGUuaW5wdXRDaGFubmVscy5nZXRDaGFubmVsKGRhdGFOYW1lKTtcclxuICAgICAgICAgICAgaWYoY2hhbm5lbCkgY2hhbm5lbC5hZGRMaXN0ZW5lcihwcm9jZXNzTm9kZSk7XHJcbiAgICAgICAgICAgIHByb2Nlc3NOb2RlLmlucHV0Q2hhbm5lbHNbc291cmNlTmFtZV0gPSBjaGFubmVsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaXNJbnB1dExvYWRpbmcob3BlcmF0b3IsIGlucHV0Q2hhbm5lbHMpe1xyXG4gICAgZm9yKHZhciBpIGluIG9wZXJhdG9yLnBhcmFtcyl7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gb3BlcmF0b3IucGFyYW1zW2ldO1xyXG4gICAgICAgIHZhciBjaGFubmVsID0gaW5wdXRDaGFubmVsc1tlbnRyeS5zb3VyY2VdO1xyXG4gICAgICAgIGlmKCFjaGFubmVsKSBjb250aW51ZTtcclxuICAgICAgICB2YXIgZGF0YUVudHJ5ID0gY2hhbm5lbC5nZXREYXRhRW50cnkoKTtcclxuICAgICAgICBpZighZGF0YUVudHJ5KSBjb250aW51ZTtcclxuICAgICAgICBpZihkYXRhRW50cnkuaXNMb2FkaW5nICYmIGRhdGFFbnRyeS5pc0xvYWRpbmcoKSkgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrSW5wdXQocHJvY2Vzc05vZGUsIG9wZXJhdG9yLCBpbnB1dE1hcHBpbmcsIGlucHV0Q2hhbm5lbHMpe1xyXG4gICAgdmFyIGRhdGFOb2RlID0gcHJvY2Vzc05vZGUub3duZXIub3duZXI7XHJcbiAgICBmb3IodmFyIGkgaW4gb3BlcmF0b3IucGFyYW1zKXtcclxuICAgICAgICB2YXIgZW50cnkgPSBvcGVyYXRvci5wYXJhbXNbaV07XHJcbiAgICAgICAgdmFyIGRhdGFOYW1lID0gaW5wdXRNYXBwaW5nID8gaW5wdXRNYXBwaW5nLmdldFNjcmlwdElucHV0TmFtZShpLCBlbnRyeS5zb3VyY2UpIDogZW50cnkuc291cmNlO1xyXG4gICAgICAgIGlmKCFlbnRyeS5vcHRpb25hbCAmJiAhZGF0YU5hbWUpe1xyXG4gICAgICAgICAgICBCYXNlLm5vdGlmeUVycm9yKFwiWGZsb3c6IG9wZXJhdG9yIFwiICsgb3BlcmF0b3IubmFtZSArIFwiOiBNaXNzaW5nIGlucHV0IGFyZ3VtZW50IGZvciBcIlxyXG4gICAgICAgICAgICAgICAgKyBlbnRyeS5zb3VyY2UsIGRhdGFOb2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihkYXRhTmFtZSl7XHJcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gaW5wdXRDaGFubmVsc1tlbnRyeS5zb3VyY2VdO1xyXG4gICAgICAgICAgICBpZighY2hhbm5lbCl7XHJcbiAgICAgICAgICAgICAgICBpZighaW5wdXRNYXBwaW5nKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIEJhc2Uubm90aWZ5RXJyb3IoXCJYZmxvdzogb3BlcmF0b3IgXCIgKyBvcGVyYXRvci5uYW1lICsgXCI6IElucHV0IG9mIG5hbWUgJ1wiICsgZGF0YU5hbWUgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiJyBub3QgZm91bmQuIFVzZWQgZm9yIHBhcmFtZXRlciBcIiArIGVudHJ5LnNvdXJjZSwgZGF0YU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBkYXRhRW50cnkgPSBjaGFubmVsLmdldERhdGFFbnRyeSgpO1xyXG5cclxuICAgICAgICAgICAgaWYoIWNoYW5uZWwuY3JlYXRvclByb2Nlc3NOb2RlKXtcclxuICAgICAgICAgICAgICAgIGlmKCFlbnRyeS5vcHRpb25hbCAmJiAoIWRhdGFFbnRyeSB8fCBkYXRhRW50cnkuaXNFbXB0eSgpKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgQmFzZS5ub3RpZnlFcnJvcihcIlhmbG93OiBvcGVyYXRvciBcIiArIG9wZXJhdG9yLm5hbWUgKyBcIjogSW5wdXQgZm9yIFwiICsgZW50cnkuc291cmNlICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyBjb250YWlucyBubyBkYXRhLicsIGRhdGFOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoZGF0YUVudHJ5ICYmIGRhdGFFbnRyeS50eXBlICE9IGVudHJ5LnR5cGUpe1xyXG4gICAgICAgICAgICAgICAgQmFzZS5ub3RpZnlFcnJvcihcIlhmbG93OiBvcGVyYXRvciBcIiArIG9wZXJhdG9yLm5hbWUgKyBcIjogSW5wdXQgZm9yIFwiICsgZW50cnkuc291cmNlICtcclxuICAgICAgICAgICAgICAgICAgICBcIiBoYXMgd3JvbmcgdHlwZS4gRXhwZWN0ZWQ6IFwiICsgQy5nZXRUeXBlTmFtZShlbnRyeS50eXBlKVxyXG4gICAgICAgICAgICAgICAgICAgICsgXCIsIGJ1dCBnb3Q6IFwiICsgIEMuZ2V0VHlwZU5hbWUoZGF0YUVudHJ5LnR5cGUpLCBkYXRhTm9kZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3luY2hyb25pemVDaGlsZHJlbkFuZERlc2NlbmRhbnRzKGNoaWxkcmVuLCBkZXNjZW5kYW50cywgaW5wdXRDaGFubmVscyl7XHJcbiAgICB2YXIgY2hhbm5lbDtcclxuICAgIGZvcih2YXIgbmFtZSBpbiBpbnB1dENoYW5uZWxzKXtcclxuICAgICAgICBjaGFubmVsID0gaW5wdXRDaGFubmVsc1tuYW1lXTtcclxuICAgICAgICBpZihjaGFubmVsICYmIGNoYW5uZWwuY3JlYXRvclByb2Nlc3NOb2RlKXtcclxuICAgICAgICAgICAgdXRpbHMuc2V0LmFkZChjaGlsZHJlbiwgY2hhbm5lbC5jcmVhdG9yUHJvY2Vzc05vZGUpO1xyXG4gICAgICAgICAgICB1dGlscy5zZXQuYWRkKGRlc2NlbmRhbnRzLCBjaGFubmVsLmNyZWF0b3JQcm9jZXNzTm9kZS5kZXNjZW5kYW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdXRpbHMuc2V0LnJlbW92ZShjaGlsZHJlbiwgZGVzY2VuZGFudHMpO1xyXG4gICAgdXRpbHMuc2V0LmFkZChkZXNjZW5kYW50cywgY2hpbGRyZW4pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzeW5jaHJvbml6ZU91dHB1dChvcGVyYXRvciwgb3V0cHV0cyl7XHJcbiAgICB2YXIgYXN5bmMgPSBPcGVyYXRvci5pc09wZXJhdG9yQXN5bmMob3BlcmF0b3IpO1xyXG4gICAgZm9yKHZhciBpIGluIG9wZXJhdG9yLm91dHB1dHMpe1xyXG4gICAgICAgIHZhciBkYXRhRW50cnkgPSBvcGVyYXRvci5vdXRwdXRzW2ldO1xyXG5cclxuICAgICAgICB2YXIgZW50cnksIGFzeW5jRW50cnk7XHJcbiAgICAgICAgdmFyIHR5cGUgPSBkYXRhRW50cnkudHlwZTtcclxuICAgICAgICBpZih0eXBlICE9IEMuREFUQV9UWVBFLlRFWFRVUkUpe1xyXG4gICAgICAgICAgICBlbnRyeSA9IG5ldyBCdWZmZXJFbnRyeSh0eXBlLCBudWxsKTtcclxuICAgICAgICAgICAgaWYoYXN5bmMpIGFzeW5jRW50cnkgPSBuZXcgQnVmZmVyRW50cnkodHlwZSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIGVudHJ5ID0gd2luZG93LmRvY3VtZW50ID8gbmV3IFRleHR1cmVFbnRyeShudWxsKSA6IG5ldyBJbWFnZURhdGFUZXh0dXJlRW50cnkobnVsbCk7XHJcbiAgICAgICAgICAgIGlmKGFzeW5jKSBhc3luY0VudHJ5ID0gd2luZG93LmRvY3VtZW50ID8gbmV3IFRleHR1cmVFbnRyeShudWxsKSA6IG5ldyBJbWFnZURhdGFUZXh0dXJlRW50cnkobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG91dHB1dHNbZGF0YUVudHJ5Lm5hbWVdID0gbmV3IERhdGFTbG90KGVudHJ5LCAwKTtcclxuICAgICAgICBpZihhc3luYykgb3V0cHV0c1tkYXRhRW50cnkubmFtZV0uYXN5bmNEYXRhRW50cnkgPSBhc3luY0VudHJ5O1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRPckNyZWF0ZUV4ZWN1dGVyKG5vZGUsIHBsYXRmb3JtKXtcclxuICAgIGlmKCFub2RlLmV4ZWN1dGVyc1twbGF0Zm9ybV0pe1xyXG4gICAgICAgIG5vZGUuZXhlY3V0ZXJzW3BsYXRmb3JtXSA9IG5ldyBFeGVjdXRvcihub2RlLCBwbGF0Zm9ybSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9kZS5leGVjdXRlcnNbcGxhdGZvcm1dO1xyXG59XHJcblxyXG5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIFJlcXVlc3ROb2RlXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vKipcclxuICpcclxuICogRklYTUU6IFJlcXVlc3ROb2RlcyBhcmUgbmV2ZXIgZGVsZXRlZC5cclxuICogQHBhcmFtIHtDaGFubmVsTm9kZX0gY2hhbm5lbE5vZGVcclxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gZmlsdGVyXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIFJlcXVlc3ROb2RlID0gZnVuY3Rpb24oY2hhbm5lbE5vZGUsIGZpbHRlcil7XHJcbiAgICB0aGlzLm93bmVyID0gY2hhbm5lbE5vZGU7XHJcbiAgICB0aGlzLmZpbHRlciA9IGZpbHRlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0PEMuUExBVEZPUk0sIGV4cG9ydHMuUmVzdWx0Pn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXN1bHRzID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7ZXhwb3J0cy5DLlBST0NFU1NfU1RBVEV9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3RhdHVzID0gQy5QUk9DRVNTX1NUQVRFLk1PRElGSUVEO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBDaGFubmVsPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jaGFubmVscyA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHNlZSBQcm9jZXNzTm9kZS5jaGlsZHJlblxyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAc2VlIFByb2Nlc3NOb2RlLmV4ZWN1dGVyc1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmV4ZWN1dGVycyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHNlZSBQcm9jZXNzTm9kZS5vdXRPZlN5bmNcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLm91dE9mU3luYyA9IHRydWU7XHJcbn07XHJcblxyXG5SZXF1ZXN0Tm9kZS5wcm90b3R5cGUuc3luY2hyb25pemUgPSBmdW5jdGlvbigpe1xyXG4gICAgaWYodGhpcy5vdXRPZlN5bmMpe1xyXG4gICAgICAgIHRoaXMub3V0T2ZTeW5jID0gZmFsc2U7XHJcbiAgICAgICAgc3luY2hyb25pemVSZXF1ZXN0Q2hhbm5lbHModGhpcywgdGhpcy5vd25lcik7XHJcbiAgICAgICAgc3luY2hyb25pemVDaGlsZHJlbkFuZERlc2NlbmRhbnRzKHRoaXMuY2hpbGRyZW4sIFtdLCB0aGlzLmNoYW5uZWxzKTtcclxuICAgIH1cclxufTtcclxuXHJcblJlcXVlc3ROb2RlLnByb3RvdHlwZS51cGRhdGVTdGF0ZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLnN5bmNocm9uaXplKCk7XHJcbiAgICBpZih0aGlzLnN0YXR1cyA9PSBDLlBST0NFU1NfU1RBVEUuTU9ESUZJRUQpe1xyXG4gICAgICAgIHRoaXMuc3RhdHVzID0gQy5QUk9DRVNTX1NUQVRFLlVOUFJPQ0VTU0VEO1xyXG5cclxuICAgICAgICBpZih0aGlzLm93bmVyLmxvYWRpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlBST0NFU1NfU1RBVEUuTE9BRElORztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IE1hdGgubWluKHRoaXMuc3RhdHVzLCB0aGlzLmNoaWxkcmVuW2ldLnVwZGF0ZVN0YXRlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzO1xyXG59O1xyXG5cclxuUmVxdWVzdE5vZGUucHJvdG90eXBlLmdldFJlc3VsdCA9IGZ1bmN0aW9uKHJlc3VsdFR5cGUpe1xyXG4gICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xyXG5cclxuICAgIC8vIFRPRE86IFRoaXMgY291bGQgYmUgaW4gZ2V0UmVxdWVzdENvbXB1dGVSZXN1bHRcclxuICAgIGlmKHRoaXMuc3RhdHVzID09IEMuUFJPQ0VTU19TVEFURS5VTlBST0NFU1NFRCl7XHJcbiAgICAgICAgaWYocmVzdWx0VHlwZSA9PSBDLlJFU1VMVF9UWVBFLkNPTVBVVEUpe1xyXG4gICAgICAgICAgICB2YXIgZXhlY3V0ZXIgPSBnZXRPckNyZWF0ZUV4ZWN1dGVyKHRoaXMsIHRoaXMub3duZXIucGxhdGZvcm0pO1xyXG4gICAgICAgICAgICBpZighZXhlY3V0ZXIuaXNQcm9jZXNzZWQoKSlcclxuICAgICAgICAgICAgICAgIGV4ZWN1dGVyLnJ1bigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0YXR1cyA9IEMuUFJPQ0VTU19TVEFURS5QUk9DRVNTRUQ7XHJcbiAgICB9XHJcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcclxuICAgIGlmIChyZXN1bHRUeXBlID09IEMuUkVTVUxUX1RZUEUuQ09NUFVURSkge1xyXG4gICAgICAgIHJlc3VsdCA9IGdldFJlcXVlc3RDb21wdXRlUmVzdWx0KHRoaXMpO1xyXG4gICAgfSBlbHNlIGlmIChyZXN1bHRUeXBlID09IEMuUkVTVUxUX1RZUEUuVlMpIHtcclxuICAgICAgICByZXN1bHQgPSBnZXRSZXF1ZXN0VlNSZXN1bHQodGhpcyk7XHJcbiAgICB9XHJcbiAgICByZXN1bHQubG9hZGluZyA9ICh0aGlzLnN0YXR1cyA9PSBDLlBST0NFU1NfU1RBVEUuTE9BRElORyk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuUmVxdWVzdE5vZGUucHJvdG90eXBlLnNldFN0cnVjdHVyZU91dE9mU3luYyA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLm91dE9mU3luYyA9IHRydWU7XHJcbiAgICB0aGlzLnN0YXR1cyA9IEMuUFJPQ0VTU19TVEFURS5NT0RJRklFRDtcclxuICAgIGZvcih2YXIgdHlwZSBpbiB0aGlzLnJlc3VsdHMpe1xyXG4gICAgICAgIHRoaXMucmVzdWx0c1t0eXBlXS5fbm90aWZ5Q2hhbmdlZChDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XHJcbiAgICB9XHJcbiAgICBmb3IodmFyIG5hbWUgaW4gdGhpcy5jaGFubmVscyl7XHJcbiAgICAgICAgdGhpcy5jaGFubmVsc1tuYW1lXS5yZW1vdmVMaXN0ZW5lcih0aGlzKTtcclxuICAgIH1cclxuICAgIHRoaXMuY2hhbm5lbHMgPSBbXTtcclxuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuICAgIHRoaXMuZXhlY3V0ZXJzID0gW107XHJcbn07XHJcblxyXG5SZXF1ZXN0Tm9kZS5wcm90b3R5cGUub25YZmxvd0NoYW5uZWxDaGFuZ2UgPSBmdW5jdGlvbihjaGFubmVsLCBzdGF0ZSl7XHJcbiAgICBpZihjaGFubmVsLmNyZWF0b3JQcm9jZXNzTm9kZSlcclxuICAgICAgICB0aGlzLnN0YXR1cyA9IEMuUFJPQ0VTU19TVEFURS5NT0RJRklFRDtcclxuICAgIHZhciBub3RpZnlTdGF0ZSA9IChzdGF0ZSA9PSBDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9WQUxVRSA/IEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfREFUQV9WQUxVRVxyXG4gICAgICAgICAgICA6IEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfREFUQV9TSVpFKTtcclxuXHJcbiAgICBmb3IodmFyIHR5cGUgaW4gdGhpcy5yZXN1bHRzKXtcclxuICAgICAgICB0aGlzLnJlc3VsdHNbdHlwZV0uX25vdGlmeUNoYW5nZWQobm90aWZ5U3RhdGUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuUmVxdWVzdE5vZGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnNldFN0cnVjdHVyZU91dE9mU3luYygpO1xyXG4gICAgZGVsZXRlIHRoaXMub3duZXI7XHJcbn07XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHJlcXVlc3ROb2RlXHJcbiAqIEBwYXJhbSBjaGFubmVsTm9kZVxyXG4gKi9cclxuZnVuY3Rpb24gc3luY2hyb25pemVSZXF1ZXN0Q2hhbm5lbHMocmVxdWVzdE5vZGUsIGNoYW5uZWxOb2RlKXtcclxuICAgIHZhciBuYW1lcyA9IHJlcXVlc3ROb2RlLmZpbHRlcjtcclxuICAgIGlmKCFuYW1lcyl7XHJcbiAgICAgICAgbmFtZXMgPSBjaGFubmVsTm9kZS5vdXRwdXRDaGFubmVscy5nZXROYW1lcygpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcclxuICAgICAgICB2YXIgY2hhbm5lbCA9IGNoYW5uZWxOb2RlLm91dHB1dENoYW5uZWxzLmdldENoYW5uZWwobmFtZSk7XHJcbiAgICAgICAgaWYoY2hhbm5lbCl7XHJcbiAgICAgICAgICAgIHJlcXVlc3ROb2RlLmNoYW5uZWxzW25hbWVdID0gY2hhbm5lbDtcclxuICAgICAgICAgICAgY2hhbm5lbC5hZGRMaXN0ZW5lcihyZXF1ZXN0Tm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHtSZXF1ZXN0Tm9kZX0gcmVxdWVzdE5vZGVcclxuICogQHJldHVybnMge1Jlc3VsdH1cclxuICovXHJcbmZ1bmN0aW9uIGdldFJlcXVlc3RDb21wdXRlUmVzdWx0KHJlcXVlc3ROb2RlKVxyXG57XHJcbiAgICBpZighcmVxdWVzdE5vZGUucmVzdWx0c1tDLlJFU1VMVF9UWVBFLkNPTVBVVEVdKVxyXG4gICAgICAgIHJlcXVlc3ROb2RlLnJlc3VsdHNbQy5SRVNVTFRfVFlQRS5DT01QVVRFXSA9IG5ldyBSZXN1bHQuQ29tcHV0ZVJlc3VsdCgpO1xyXG5cclxuICAgIHZhciByZXN1bHQgPSByZXF1ZXN0Tm9kZS5yZXN1bHRzW0MuUkVTVUxUX1RZUEUuQ09NUFVURV07XHJcbiAgICByZXN1bHQuX2RhdGFFbnRyaWVzID0ge307IHJlc3VsdC5fb3V0cHV0TmFtZXMgPSBbXTtcclxuXHJcbiAgICBmb3IodmFyIG5hbWUgaW4gcmVxdWVzdE5vZGUuY2hhbm5lbHMpe1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHJlcXVlc3ROb2RlLmNoYW5uZWxzW25hbWVdLmdldERhdGFFbnRyeSgpO1xyXG4gICAgICAgIHJlc3VsdC5fZGF0YUVudHJpZXNbbmFtZV0gPSBlbnRyeSAmJiAhZW50cnkuaXNFbXB0eSgpID8gZW50cnkgOiBudWxsO1xyXG4gICAgICAgIHJlc3VsdC5fb3V0cHV0TmFtZXMucHVzaChuYW1lKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVxdWVzdE5vZGVcclxuICogQHJldHVybnMge2V4cG9ydHMuVlNEYXRhUmVzdWx0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UmVxdWVzdFZTUmVzdWx0KHJlcXVlc3ROb2RlKVxyXG57XHJcbiAgICB2YXIgZXhlY3V0ZXIgPSBnZXRPckNyZWF0ZUV4ZWN1dGVyKHJlcXVlc3ROb2RlLCBDLlBMQVRGT1JNLkdMU0wpO1xyXG4gICAgaWYoIXJlcXVlc3ROb2RlLnJlc3VsdHNbQy5SRVNVTFRfVFlQRS5WU10pXHJcbiAgICAgICAgcmVxdWVzdE5vZGUucmVzdWx0c1tDLlJFU1VMVF9UWVBFLlZTXSA9IG5ldyBSZXN1bHQuVlNEYXRhUmVzdWx0KCk7XHJcbiAgICB2YXIgcmVzdWx0ID0gcmVxdWVzdE5vZGUucmVzdWx0c1tDLlJFU1VMVF9UWVBFLlZTXTtcclxuXHJcbiAgICB2YXIgcHJvZ3JhbSA9IGV4ZWN1dGVyLmdldFZlcnRleFNoYWRlcigpO1xyXG4gICAgcmVzdWx0Ll9wcm9ncmFtID0gcHJvZ3JhbTtcclxuICAgIHJlc3VsdC5fcHJvZ3JhbURhdGEgPSBleGVjdXRlci5wcm9ncmFtRGF0YTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIFJlcXVlc3ROb2RlOiBSZXF1ZXN0Tm9kZSxcclxuICAgIFByb2Nlc3NOb2RlOiBQcm9jZXNzTm9kZVxyXG59O1xyXG5cclxuIiwidmFyIEJhc2UgPSByZXF1aXJlKFwiLi4vYmFzZS5qc1wiKTtcclxucmVxdWlyZShcIi4uLy4uL3V0aWxzL2FycmF5LmpzXCIpO1xyXG5cclxudmFyIHF1ZXVlUmVzdWx0Q2FsbGJhY2sgPSBCYXNlLl9xdWV1ZVJlc3VsdENhbGxiYWNrO1xyXG5cclxuLyoqXHJcbiAqIENvbnRlbnQgb2YgdGhpcyBmaWxlOlxyXG4gKiBSZXN1bHQgY2xhc3NlcyBvZiBhbiBYZmxvdyBncmFwaCB3aGljaCBhcmUgcmVjZWl2ZWQgdGhyb3VnaCBSZXF1ZXN0cy5cclxuICovXHJcblxyXG4vKipcclxuICogQWJzdHJhY3QgUmVzdWx0IHN0cnVjdHVyZSBjb250YWluaW5nIGEgKHByb2Nlc3NlZCkgcmVzdWx0IG9mIHRoZSBYZmxvdyBncmFwaC5cclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG52YXIgUmVzdWx0ID0gZnVuY3Rpb24oKXtcclxuICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xyXG4gICAgLyoqIFZhbGlkIGlzIGZhbHNlIGlmIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgcHJvY2Vzc2luZyBvZiB0aGUgcmVzdWx0ICovXHJcbiAgICB0aGlzLnZhbGlkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcclxuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtmdW5jdGlvbihSZXN1bHQsIEMuUkVTVUxUX1NUQVRFKX0gY2FsbGJhY2tcclxuICovXHJcblJlc3VsdC5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihjYWxsYmFjayl7XHJcbiAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtmdW5jdGlvbihSZXN1bHQsIEMuUkVTVUxUX1NUQVRFKX0gY2FsbGJhY2tcclxuICovXHJcblJlc3VsdC5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihjYWxsYmFjayl7XHJcbiAgICBBcnJheS5lcmFzZSh0aGlzLl9saXN0ZW5lcnMsIGNhbGxiYWNrKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFJlc3VsdCwgQy5SRVNVTFRfU1RBVEUpfSBjYWxsYmFja1xyXG4gKi9cclxuUmVzdWx0LnByb3RvdHlwZS5fYWRkUmVxdWVzdCA9IGZ1bmN0aW9uKHJlcXVlc3Qpe1xyXG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFJlc3VsdCwgQy5SRVNVTFRfU1RBVEUpfSBjYWxsYmFja1xyXG4gKi9cclxuUmVzdWx0LnByb3RvdHlwZS5fcmVtb3ZlUmVxdWVzdCA9IGZ1bmN0aW9uKHJlcXVlc3Qpe1xyXG4gICAgQXJyYXkuZXJhc2UodGhpcy5fcmVxdWVzdHMsIHJlcXVlc3QpO1xyXG59O1xyXG5cclxuXHJcblJlc3VsdC5wcm90b3R5cGUuX25vdGlmeUNoYW5nZWQgPSBmdW5jdGlvbihzdGF0ZSl7XHJcbiAgICB0aGlzLnZhbGlkID0gZmFsc2U7XHJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fcmVxdWVzdHMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIHRoaXMuX3JlcXVlc3RzW2ldLl9vblJlc3VsdENoYW5nZWQoc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgcXVldWVSZXN1bHRDYWxsYmFjayh0aGlzLCBzdGF0ZSk7XHJcbn1cclxuXHJcblJlc3VsdC5wcm90b3R5cGUuX29uUG9zdHBvbmVkUmVzdWx0Q2hhbmdlZCA9IGZ1bmN0aW9uKHN0YXRlKXtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1tpXSh0aGlzLCBzdGF0ZSk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVSZXN1bHQgY29udGFpbnMgYSBuYW1lZCBtYXAgb2YgdHlwZWQgdmFsdWVzLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMge1Jlc3VsdH1cclxuICovXHJcbnZhciBDb21wdXRlUmVzdWx0ID0gZnVuY3Rpb24oKXtcclxuICAgIFJlc3VsdC5jYWxsKHRoaXMpO1xyXG4gICAgdGhpcy5fb3V0cHV0TmFtZXMgPSBbXTtcclxuICAgIC8qKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsRGF0YUVudHJ5Pn0gKi9cclxuICAgIHRoaXMuX2RhdGFFbnRyaWVzID0ge307XHJcbn07XHJcbkJhc2UuY3JlYXRlQ2xhc3MoQ29tcHV0ZVJlc3VsdCwgUmVzdWx0KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wdXRlUmVzdWx0LnByb3RvdHlwZSwgXCJvdXRwdXROYW1lc1wiLCB7XHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpe1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm91dHB1dE5hbWVzIGlzIHJlYWRvbmx5XCIpO1xyXG4gICAgfSxcclxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX291dHB1dE5hbWVzOyB9XHJcbn0pO1xyXG5cclxuQ29tcHV0ZVJlc3VsdC5wcm90b3R5cGUuZ2V0T3V0cHV0RGF0YSA9IGZ1bmN0aW9uKG5hbWUpe1xyXG4gICAgcmV0dXJuIHRoaXMuX2RhdGFFbnRyaWVzW25hbWVdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZyxEYXRhRW50cnk+fVxyXG4gKi9cclxuQ29tcHV0ZVJlc3VsdC5wcm90b3R5cGUuZ2V0T3V0cHV0TWFwID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGF0YUVudHJpZXM7XHJcbn07XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBWU0RhdGFSZXN1bHQgaXMgdXNlZCB0byBhbmFseXNlIHRoZSBvdXRwdXQgb2YgYSBWZXJ0ZXhTaGFkZXJcclxuICogTm90ZSB0aGF0IHRoZSBWU0RhdGFSZXN1bHQgaXMgbm90IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIFZlcnRleFNoYWRlciBkaXJlY3RseS5cclxuICogRm9yIHRoYXQsIHRoZSBWZXJ0ZXhTaGFkZXIgc3RydWN0dXJlIG11c3QgYmUgY3JlYXRlZCBmcm9tIFZlcnRleFNoYWRlclJlcXVlc3RcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIHtSZXN1bHR9XHJcbiAqL1xyXG52YXIgVlNEYXRhUmVzdWx0ID0gZnVuY3Rpb24oKXtcclxuICAgIFJlc3VsdC5jYWxsKHRoaXMpO1xyXG4gICAgdGhpcy5fcHJvZ3JhbSA9IG51bGw7XHJcbiAgICB0aGlzLl9wcm9ncmFtRGF0YSA9IG51bGw7XHJcbn07XHJcbkJhc2UuY3JlYXRlQ2xhc3MoVlNEYXRhUmVzdWx0LCBSZXN1bHQpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZTRGF0YVJlc3VsdC5wcm90b3R5cGUsIFwib3V0cHV0TmFtZXNcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbih2KXtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaGFkZXJPdXRwdXROYW1lcyBpcyByZWFkb25seVwiKTtcclxuICAgIH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9wcm9ncmFtLmdldE91dHB1dE5hbWVzKCk7IH1cclxufSk7XHJcblxyXG5WU0RhdGFSZXN1bHQucHJvdG90eXBlLmlzT3V0cHV0VW5pZm9ybSA9IGZ1bmN0aW9uKG5hbWUpe1xyXG4gICAgcmV0dXJuIHRoaXMuX3Byb2dyYW0uaXNPdXRwdXRVbmlmb3JtKG5hbWUpO1xyXG59XHJcblZTRGF0YVJlc3VsdC5wcm90b3R5cGUuaXNPdXRwdXROdWxsID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgICByZXR1cm4gdGhpcy5fcHJvZ3JhbS5pc091dHB1dE51bGwobmFtZSk7XHJcbn1cclxuVlNEYXRhUmVzdWx0LnByb3RvdHlwZS5nZXRPdXRwdXRUeXBlID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgICByZXR1cm4gdGhpcy5fcHJvZ3JhbS5nZXRPdXRwdXRUeXBlKG5hbWUpO1xyXG59XHJcblZTRGF0YVJlc3VsdC5wcm90b3R5cGUuZ2V0VmVydGV4U2hhZGVyID0gZnVuY3Rpb24odnNDb25maWcpe1xyXG4gICAgcmV0dXJuIHRoaXMuX3Byb2dyYW0uY3JlYXRlVmVydGV4U2hhZGVyKHRoaXMuX3Byb2dyYW1EYXRhLCB2c0NvbmZpZyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgQ29tcHV0ZVJlc3VsdDogIENvbXB1dGVSZXN1bHQsXHJcbiAgICBWU0RhdGFSZXN1bHQ6IFZTRGF0YVJlc3VsdFxyXG59O1xyXG4iLCJ2YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi9iYXNlLmpzXCIpO1xyXG52YXIgQyA9IHJlcXVpcmUoXCIuLy4uL2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XHJcblxyXG52YXIgaW5pdEFub255bW91c09wZXJhdG9yID0gcmVxdWlyZShcIi4uL29wZXJhdG9yL29wZXJhdG9yLmpzXCIpLmluaXRBbm9ueW1vdXNPcGVyYXRvcjtcclxuXHJcbnZhciBzaGFkZXJDb25zdGFudCA9IHt9O1xyXG5zaGFkZXJDb25zdGFudFtDLlNIQURFUl9DT05TVEFOVF9LRVkuT0JKRUNUX0lEXSA9IFwib2JqZWN0SURcIjtcclxuc2hhZGVyQ29uc3RhbnRbQy5TSEFERVJfQ09OU1RBTlRfS0VZLlNDUkVFTl9UUkFOU0ZPUk1dID0gXCJzY3JlZW5UcmFuc2Zvcm1cIjtcclxuc2hhZGVyQ29uc3RhbnRbQy5TSEFERVJfQ09OU1RBTlRfS0VZLlNDUkVFTl9UUkFOU0ZPUk1fTk9STUFMXSA9IFwic2NyZWVuVHJhbnNmb3JtTm9ybWFsXCI7XHJcbnNoYWRlckNvbnN0YW50W0MuU0hBREVSX0NPTlNUQU5UX0tFWS5WSUVXX1RSQU5TRk9STV0gPSBcInZpZXdUcmFuc2Zvcm1cIjtcclxuc2hhZGVyQ29uc3RhbnRbQy5TSEFERVJfQ09OU1RBTlRfS0VZLlZJRVdfVFJBTlNGT1JNX05PUk1BTF0gPSBcInZpZXdUcmFuc2Zvcm1Ob3JtYWxcIjtcclxuc2hhZGVyQ29uc3RhbnRbQy5TSEFERVJfQ09OU1RBTlRfS0VZLldPUkxEX1RSQU5TRk9STV0gPSBcIndvcmxkVHJhbnNmb3JtXCI7XHJcbnNoYWRlckNvbnN0YW50W0MuU0hBREVSX0NPTlNUQU5UX0tFWS5XT1JMRF9UUkFOU0ZPUk1fTk9STUFMXSA9IFwid29ybGRUcmFuc2Zvcm1Ob3JtYWxcIjtcclxuXHJcbnZhciBzZXRTaGFkZXJDb25zdGFudCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUpe1xyXG4gICAgc2hhZGVyQ29uc3RhbnRbdHlwZV0gPSBuYW1lO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgb3V0cHV0IGNvbmZpZ3VyYXRpb24gb2YgYSBWZXJ0ZXhTaGFkZXIgZ2VuZXJhdGVkIGJ5IFhmbG93XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIFZTQ29uZmlnID0gZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSB7fTtcclxuICAgIHRoaXMuX2Jsb2NrZWROYW1lcyA9IFtdO1xyXG4gICAgdGhpcy5fYWRkSW5wdXQgPSB7fTtcclxuICAgIHRoaXMuX2FkZE91dHB1dCA9IHt9O1xyXG4gICAgdGhpcy5fY29kZUZyYWdtZW50cyA9IFtdO1xyXG4gICAgdGhpcy5fb3V0cHV0Q2hhbm5lbGluZyA9IHt9O1xyXG59O1xyXG5cclxuVlNDb25maWcucHJvdG90eXBlLmFkZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIG9wdGlvbmFsKXtcclxuICAgIGlmKHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV0pe1xyXG4gICAgICAgIGlmKHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV0udHlwZSAhPSB0eXBlKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmllcyB0byBhZGQgdHdvIGF0dHJpYnV0ZXMgd2l0aCBkaWZmZXJlbnQgdHlwZXMgb2YgbmFtZSAnXCIgKyBuYW1lICsgJ1wiJyk7XHJcbiAgICAgICAgdGhpcy5fYXR0cmlidXRlc1tuYW1lXS5vcHRpb25hbCA9IHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV0ub3B0aW9uYWwgJiYgb3B0aW9uYWw7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fYXR0cmlidXRlc1tuYW1lXSA9IHt0eXBlOiB0eXBlLCBvcHRpb25hbDogb3B0aW9uYWwsIGNoYW5uZWxpbmc6IFtdfTtcclxufTtcclxuXHJcblZTQ29uZmlnLnByb3RvdHlwZS5jaGFubmVsQXR0cmlidXRlID0gZnVuY3Rpb24oaW5wdXROYW1lLCBvdXRwdXROYW1lLCBjb2RlKXtcclxuICAgIHRoaXMuX2F0dHJpYnV0ZXNbaW5wdXROYW1lXS5jaGFubmVsaW5nLnB1c2goIHsgb3V0cHV0TmFtZSA6IG91dHB1dE5hbWUsIGNvZGUgOiBjb2RlIH0pO1xyXG59O1xyXG5cclxuVlNDb25maWcucHJvdG90eXBlLmFkZElucHV0UGFyYW1ldGVyID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgdW5pZm9ybSl7XHJcbiAgICBpZih0aGlzLl9hZGRJbnB1dFtuYW1lXSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICB0aGlzLl9hZGRJbnB1dFtuYW1lXSA9IHsgdHlwZTogdHlwZSwgdW5pZm9ybTogdW5pZm9ybSB9O1xyXG4gICAgdGhpcy5fYmxvY2tlZE5hbWVzLnB1c2gobmFtZSk7XHJcbn07XHJcblZTQ29uZmlnLnByb3RvdHlwZS5hZGRPdXRwdXRQYXJhbWV0ZXIgPSBmdW5jdGlvbih0eXBlLCBuYW1lKXtcclxuICAgIGlmKHRoaXMuX2FkZE91dHB1dFtuYW1lXSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICB0aGlzLl9hZGRPdXRwdXRbbmFtZV0gPSB7IHR5cGU6IHR5cGUgfTtcclxuICAgIHRoaXMuX2Jsb2NrZWROYW1lcy5wdXNoKG5hbWUpO1xyXG59O1xyXG5WU0NvbmZpZy5wcm90b3R5cGUuYWRkQ29kZUZyYWdtZW50ID0gZnVuY3Rpb24oY29kZUZyYWdtZW50KXtcclxuICAgIHRoaXMuX2NvZGVGcmFnbWVudHMucHVzaChjb2RlRnJhZ21lbnQpO1xyXG59O1xyXG5cclxuVlNDb25maWcucHJvdG90eXBlLmFkZEJsb2NrZWROYW1lID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgICB0aGlzLl9ibG9ja2VkTmFtZXMucHVzaChuYW1lKTtcclxufTtcclxuXHJcblZTQ29uZmlnLnByb3RvdHlwZS5nZXRCbG9ja2VkTmFtZXMgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMuX2Jsb2NrZWROYW1lcztcclxufTtcclxuXHJcblZTQ29uZmlnLnByb3RvdHlwZS5nZXRGaWx0ZXIgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2F0dHJpYnV0ZXMpO1xyXG59O1xyXG5WU0NvbmZpZy5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBrZXkgPSBcIlwiO1xyXG4gICAgZm9yKHZhciBuYW1lIGluIHRoaXMuX2F0dHJpYnV0ZXMpe1xyXG4gICAgICAgIHZhciBhdHRyID0gdGhpcy5fYXR0cmlidXRlc1tuYW1lXTtcclxuICAgICAgICBrZXkgKz0gXCI7XCIgKyBhdHRyLnR5cGUgKyBcIixcIiArIG5hbWUgKyBcIixcIiArIGF0dHIub3B0aW9uYWw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ga2V5O1xyXG59O1xyXG5cclxudmFyIGNfdnNfb3BlcmF0b3JfY2FjaGUgPSB7fTtcclxuXHJcblZTQ29uZmlnLnByb3RvdHlwZS5nZXRPcGVyYXRvciA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoKTtcclxuICAgIGlmKGNfdnNfb3BlcmF0b3JfY2FjaGVba2V5XSlcclxuICAgICAgICByZXR1cm4gY192c19vcGVyYXRvcl9jYWNoZVtrZXldO1xyXG5cclxuICAgIHZhciBvdXRwdXRzID0gW10sIHBhcmFtcyA9IFtdLCBnbHNsQ29kZSA9IFwiXFx0Ly8gVlMgQ29ubmVjdG9yXFxuXCI7XHJcbiAgICB2YXIgbmFtZSA9IFwiVlNDb25uZWN0XCI7XHJcbiAgICBmb3IodmFyIGF0dHJpYnV0ZU5hbWUgaW4gdGhpcy5fYXR0cmlidXRlcyl7XHJcbiAgICAgICAgdmFyIGF0dHIgPSB0aGlzLl9hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xyXG4gICAgICAgIHZhciB0eXBlID0gQy5nZXRUeXBlTmFtZShhdHRyLnR5cGUpO1xyXG4gICAgICAgIG91dHB1dHMucHVzaCggeyB0eXBlOiB0eXBlLCBuYW1lOiBhdHRyaWJ1dGVOYW1lfSApO1xyXG4gICAgICAgIHBhcmFtcy5wdXNoKCB7IHR5cGU6IHR5cGUsIHNvdXJjZTogYXR0cmlidXRlTmFtZSwgb3B0aW9uYWw6IGF0dHIub3B0aW9uYWx9ICk7XHJcbiAgICAgICAgbmFtZSArPSBcIlRcIiArIHR5cGUgKyBcIk5cIiArIGF0dHJpYnV0ZU5hbWUgKyBcIk9cIiArIGF0dHIub3B0aW9uYWwgKyBcIi5cIjtcclxuICAgIH1cclxuICAgIHZhciBvcGVyYXRvciA9IGluaXRBbm9ueW1vdXNPcGVyYXRvcihuYW1lLFxyXG4gICAge1xyXG4gICAgICAgIG91dHB1dHM6IG91dHB1dHMsXHJcbiAgICAgICAgcGFyYW1zOiAgcGFyYW1zLFxyXG4gICAgICAgIGV2YWx1YXRlX2dsc2w6IGdsc2xDb2RlXHJcbiAgICB9KTtcclxuICAgIGNfdnNfb3BlcmF0b3JfY2FjaGVba2V5XSA9IG9wZXJhdG9yO1xyXG4gICAgcmV0dXJuIG9wZXJhdG9yO1xyXG59O1xyXG5cclxudmFyIFZlcnRleFNoYWRlciA9IGZ1bmN0aW9uKHByb2dyYW1EYXRhKXtcclxuICAgIHRoaXMuX3Byb2dyYW1EYXRhID0gcHJvZ3JhbURhdGE7XHJcbiAgICB0aGlzLl9nbHNsQ29kZSA9IG51bGw7XHJcbiAgICB0aGlzLl9pbnB1dE5hbWVzID0gW107XHJcbiAgICB0aGlzLl9vdXRwdXROYW1lcyA9IFtdO1xyXG4gICAgdGhpcy5faW5wdXRJbmZvID0ge307XHJcbiAgICB0aGlzLl9vdXRwdXRJbmZvID0ge307XHJcbn07XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmVydGV4U2hhZGVyLnByb3RvdHlwZSwgXCJpbnB1dE5hbWVzXCIsIHtcclxuICAgIHNldDogZnVuY3Rpb24odil7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXROYW1lcyBpcyByZWFkb25seVwiKTtcclxuICAgIH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9pbnB1dE5hbWVzOyB9XHJcbn0pO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlcnRleFNoYWRlci5wcm90b3R5cGUsIFwib3V0cHV0TmFtZXNcIiwge1xyXG4gICAgc2V0OiBmdW5jdGlvbih2KXtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdXRwdXROYW1lcyBpcyByZWFkb25seVwiKTtcclxuICAgIH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9vdXRwdXROYW1lczsgfVxyXG59KTtcclxuXHJcblZlcnRleFNoYWRlci5wcm90b3R5cGUuaXNJbnB1dFVuaWZvcm0gPSBmdW5jdGlvbihuYW1lKXtcclxuICAgIHJldHVybiB0aGlzLl9pbnB1dEluZm9bbmFtZV0udW5pZm9ybTtcclxufTtcclxuVmVydGV4U2hhZGVyLnByb3RvdHlwZS5nZXRJbnB1dERhdGEgPSBmdW5jdGlvbihuYW1lKXtcclxuICAgIHJldHVybiB0aGlzLl9wcm9ncmFtRGF0YS5nZXREYXRhRW50cnkodGhpcy5faW5wdXRJbmZvW25hbWVdLmluZGV4KTtcclxufTtcclxuXHJcblZlcnRleFNoYWRlci5wcm90b3R5cGUuaXNPdXRwdXROdWxsID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgICByZXR1cm4gdGhpcy5fb3V0cHV0SW5mb1tuYW1lXS5pdGVyYXRpb24gPT0gQy5JVEVSQVRJT05fVFlQRS5OVUxMO1xyXG59O1xyXG5WZXJ0ZXhTaGFkZXIucHJvdG90eXBlLmlzT3V0cHV0RnJhZ21lbnRVbmlmb3JtID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgICByZXR1cm4gdGhpcy5fb3V0cHV0SW5mb1tuYW1lXS5pdGVyYXRpb24gPT0gQy5JVEVSQVRJT05fVFlQRS5PTkU7XHJcbn07XHJcblZlcnRleFNoYWRlci5wcm90b3R5cGUuZ2V0VW5pZm9ybU91dHB1dERhdGEgPSBmdW5jdGlvbihuYW1lKXtcclxuICAgIHJldHVybiB0aGlzLl9wcm9ncmFtRGF0YS5nZXREYXRhRW50cnkodGhpcy5fb3V0cHV0SW5mb1tuYW1lXS5pbmRleCk7XHJcbn07XHJcblZlcnRleFNoYWRlci5wcm90b3R5cGUuZ2V0T3V0cHV0VHlwZSA9IGZ1bmN0aW9uKG5hbWUpe1xyXG4gICAgcmV0dXJuIHRoaXMuX291dHB1dEluZm9bbmFtZV0udHlwZTtcclxufTtcclxuVmVydGV4U2hhZGVyLnByb3RvdHlwZS5nZXRPdXRwdXRTb3VyY2VOYW1lID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgICByZXR1cm4gdGhpcy5fb3V0cHV0SW5mb1tuYW1lXS5zb3VyY2VOYW1lO1xyXG59O1xyXG5WZXJ0ZXhTaGFkZXIucHJvdG90eXBlLmdldEdMU0xDb2RlID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLl9nbHNsQ29kZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgc2hhZGVyQ29uc3RhbnQ6IHNoYWRlckNvbnN0YW50LFxyXG4gICAgc2V0U2hhZGVyQ29uc3RhbnQ6IHNldFNoYWRlckNvbnN0YW50LFxyXG4gICAgVlNDb25maWc6IFZTQ29uZmlnLFxyXG4gICAgVmVydGV4U2hhZGVyOiBWZXJ0ZXhTaGFkZXJcclxufTtcclxuIiwidmFyIHNldCA9IHt9O1xyXG5cclxuXHJcbnNldC5hZGQgPSBmdW5jdGlvbihzZXRBcnJheSwgc2V0VG9BZGQpe1xyXG4gICAgaWYoQXJyYXkuaXNBcnJheShzZXRUb0FkZCkpe1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZXRUb0FkZC5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIGlmKHNldEFycmF5LmluZGV4T2Yoc2V0VG9BZGRbaV0pID09IC0xKVxyXG4gICAgICAgICAgICAgICAgc2V0QXJyYXkucHVzaChzZXRUb0FkZFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgICBpZihzZXRBcnJheS5pbmRleE9mKHNldFRvQWRkKSA9PSAtMSlcclxuICAgICAgICAgICAgc2V0QXJyYXkucHVzaChzZXRUb0FkZCk7XHJcbiAgICB9XHJcbn1cclxuc2V0LnJlbW92ZSA9IGZ1bmN0aW9uKHNldEFycmF5LCBzZXRUb1JlbW92ZSl7XHJcbiAgICB2YXIgaWR4O1xyXG4gICAgaWYoQXJyYXkuaXNBcnJheShzZXRUb1JlbW92ZSkpe1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZXRUb1JlbW92ZS5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIGlmKCAoaWR4ID0gc2V0QXJyYXkuaW5kZXhPZihzZXRUb1JlbW92ZVtpXSkpICE9IC0xKVxyXG4gICAgICAgICAgICAgICAgc2V0QXJyYXkuc3BsaWNlKGlkeCwxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICAgIGlmKCAoaWR4ID0gc2V0QXJyYXkuaW5kZXhPZihzZXRUb1JlbW92ZSkpICE9IC0xKVxyXG4gICAgICAgICAgICBzZXRBcnJheS5zcGxpY2UoaWR4LDEpO1xyXG4gICAgfVxyXG59XHJcblxyXG5zZXQuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oZGVzdCwgc2V0QSwgc2V0Qil7XHJcbiAgICB2YXIgc2l6ZSA9IHNldEEubGVuZ3RoO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSl7XHJcbiAgICAgICAgaWYoc2V0Qi5pbmRleE9mKHNldEFbaV0pICE9IC0xKVxyXG4gICAgICAgICAgICBkZXN0LnB1c2goc2V0QVtpXSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbnNldC5pc0ludGVyc2VjdGluZyA9IGZ1bmN0aW9uKHNldEEsIHNldEIpe1xyXG4gICAgdmFyIGkgPSBzZXRBLmxlbmd0aDtcclxuICAgIHdoaWxlKGktLSl7XHJcbiAgICAgICAgaWYoc2V0Qi5pbmRleE9mKHNldEFbaV0pICE9IC0xKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuc2V0LmlzU3Vic2V0ID0gZnVuY3Rpb24oc21hbGxlclNldCwgbGFyZ2VyU2V0KXtcclxuICAgIHZhciBpID0gc21hbGxlclNldC5sZW5ndGg7XHJcbiAgICB3aGlsZShpLS0pe1xyXG4gICAgICAgIGlmKGxhcmdlclNldC5pbmRleE9mKHNtYWxsZXJTZXRbaV0pID09IC0xKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE5hbWVzZXQgVXRpbGl0aWVzIGZvciBYZmxvd1xyXG4gKi9cclxudmFyIG5hbWVzZXQgPSB7fTtcclxuXHJcbm5hbWVzZXQuYWRkID0gZnVuY3Rpb24obmFtZVNldCwgdG9BZGQpe1xyXG4gICAgaWYoIXRvQWRkKSByZXR1cm47XHJcbiAgICBpZih0eXBlb2YgdG9BZGQgPT0gXCJzdHJpbmdcIil7XHJcbiAgICAgICAgaWYobmFtZVNldC5pbmRleE9mKHRvQWRkKSA9PSAtMSlcclxuICAgICAgICAgICAgbmFtZVNldC5wdXNoKHRvQWRkKTtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgaWYobmFtZVNldC5pbmRleE9mKHRvQWRkW2ldKSA9PSAtMSlcclxuICAgICAgICAgICAgICAgIG5hbWVTZXQucHVzaCh0b0FkZFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5uYW1lc2V0LnJlbW92ZSA9IGZ1bmN0aW9uKG5hbWVTZXQsIHRvUmVtb3ZlKXtcclxuICAgIGlmKCF0b1JlbW92ZSkgcmV0dXJuO1xyXG4gICAgaWYodHlwZW9mIHRvUmVtb3ZlID09IFwic3RyaW5nXCIpe1xyXG4gICAgICAgIHZhciByZW1vdmVJZHggPSBuYW1lU2V0LmluZGV4T2YodG9SZW1vdmUpO1xyXG4gICAgICAgIGlmKHJlbW92ZUlkeCAhPSAtMSlcclxuICAgICAgICAgICAgbmFtZVNldC5zcGxpY2UocmVtb3ZlSWR4LCAxKTtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRvUmVtb3ZlLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIHJlbW92ZUlkeCA9IG5hbWVTZXQuaW5kZXhPZih0b1JlbW92ZVtpXSk7XHJcbiAgICAgICAgICAgIGlmKHJlbW92ZUlkeCAhPSAtMSlcclxuICAgICAgICAgICAgICAgIG5hbWVTZXQuc3BsaWNlKHJlbW92ZUlkeCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5uYW1lc2V0LmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKG5hbWVTZXRBLCBuYW1lU2V0Qil7XHJcbiAgICB2YXIgaSA9IG5hbWVTZXRBLmxlbmd0aDtcclxuICAgIHdoaWxlKGktLSl7XHJcbiAgICAgICAgaWYobmFtZVNldEIuaW5kZXhPZihuYW1lU2V0QVtpXSkgPT0gLTEpe1xyXG4gICAgICAgICAgICBuYW1lU2V0QS5zcGxpY2UoaSwxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG52YXIgYmluYXJ5U2VhcmNoID0gZnVuY3Rpb24oa2V5cywga2V5LCBtYXhJbmRleCl7XHJcbiAgICB2YXIgbWluID0gMCwgbWF4ID0gbWF4SW5kZXggLSAxO1xyXG4gICAgd2hpbGUobWluIDw9IG1heCl7XHJcbiAgICAgICAgdmFyIGkgPSBNYXRoLmZsb29yKChtaW4gKyBtYXgpIC8gMik7XHJcbiAgICAgICAgaWYoa2V5c1tpXSA9PSBrZXkpe1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihrZXlzW2ldIDwga2V5KVxyXG4gICAgICAgICAgICBtaW4gPSBpICsgMTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIG1heCA9IGkgLSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1heDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBzZXQ6IHNldCxcclxuICAgIG5hbWVzZXQ6IG5hbWVzZXQsXHJcbiAgICBiaW5hcnlTZWFyY2g6IGJpbmFyeVNlYXJjaFxyXG59XHJcbiIsIlxyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2luaXQuanNcIik7Il19
