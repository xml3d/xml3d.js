/**
Copyright (c) 2010-2015
              DFKI, Saarland University, and other contributors

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
 so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

@version: 5.1.2
**/
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.1
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER

exports.glMatrix = require("./gl-matrix/common.js");
exports.mat2 = require("./gl-matrix/mat2.js");
exports.mat2d = require("./gl-matrix/mat2d.js");
exports.mat3 = require("./gl-matrix/mat3.js");
exports.mat4 = require("./gl-matrix/mat4.js");
exports.quat = require("./gl-matrix/quat.js");
exports.vec2 = require("./gl-matrix/vec2.js");
exports.vec3 = require("./gl-matrix/vec3.js");
exports.vec4 = require("./gl-matrix/vec4.js");
},{"./gl-matrix/common.js":2,"./gl-matrix/mat2.js":3,"./gl-matrix/mat2d.js":4,"./gl-matrix/mat3.js":5,"./gl-matrix/mat4.js":6,"./gl-matrix/quat.js":7,"./gl-matrix/vec2.js":8,"./gl-matrix/vec3.js":9,"./gl-matrix/vec4.js":10}],2:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

// Constants
glMatrix.EPSILON = 0.000001;
glMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
glMatrix.RANDOM = Math.random;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    GLMAT_ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}

module.exports = glMatrix;

},{}],3:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2x2 Matrix
 * @name mat2
 */
var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.fromRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
mat2.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 


module.exports = mat2;

},{"./common.js":2}],4:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */
var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
mat2d.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
mat2d.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

module.exports = mat2d;

},{"./common.js":2}],5:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 3x3 Matrix
 * @name mat3
 */
var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
mat3.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);

    out[0] = c;
    out[1] = s;
    out[2] = 0;

    out[3] = -s;
    out[4] = c;
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
mat3.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;

    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};


module.exports = mat3;

},{"./common.js":2}],6:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 4x4 Matrix
 * @name mat4
 */
var mat4 = {};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
mat4.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.fromRotation = function(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t;
    
    if (Math.abs(len) < glMatrix.EPSILON) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    
    // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromXRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    
    // Perform axis-specific matrix multiplication
    out[0]  = 1;
    out[1]  = 0;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromYRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    
    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = 0;
    out[2]  = -s;
    out[3]  = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromZRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    
    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = s;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScale = function (out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2,
        sx = s[0],
        sy = s[1],
        sz = s[2];

    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {
  // Quaternion math
  var x = q[0], y = q[1], z = q[2], w = q[3],
      x2 = x + x,
      y2 = y + y,
      z2 = z + z,

      xx = x * x2,
      xy = x * y2,
      xz = x * z2,
      yy = y * y2,
      yz = y * z2,
      zz = z * z2,
      wx = w * x2,
      wy = w * y2,
      wz = w * z2,
      
      sx = s[0],
      sy = s[1],
      sz = s[2],

      ox = o[0],
      oy = o[1],
      oz = o[2];
      
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;
        
  return out;
};

mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspectiveFromFieldOfView = function (out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&
        Math.abs(eyey - centery) < glMatrix.EPSILON &&
        Math.abs(eyez - centerz) < glMatrix.EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};


module.exports = mat4;

},{"./common.js":2}],7:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");
var mat3 = require("./mat3.js");
var vec3 = require("./vec3.js");
var vec4 = require("./vec4.js");

/**
 * @class Quaternion
 * @name quat
 */
var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
quat.sqlerp = (function () {
  var temp1 = quat.create();
  var temp2 = quat.create();
  
  return function (out, a, b, c, d, t) {
    quat.slerp(temp1, a, d, t);
    quat.slerp(temp2, b, c, t);
    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));
    
    return out;
  };
}());

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[5]-m[7])*fRoot;
        out[1] = (m[6]-m[2])*fRoot;
        out[2] = (m[1]-m[3])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

module.exports = quat;

},{"./common.js":2,"./mat3.js":5,"./vec3.js":9,"./vec4.js":10}],8:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */
var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
vec2.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

module.exports = vec2;

},{"./common.js":2}],9:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */
var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
vec3.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.hermite = function (out, a, b, c, d, t) {
  var factorTimes2 = t * t,
      factor1 = factorTimes2 * (2 * t - 3) + 1,
      factor2 = factorTimes2 * (t - 2) + t,
      factor3 = factorTimes2 * (t - 1),
      factor4 = factorTimes2 * (3 - 2 * t);
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.bezier = function (out, a, b, c, d, t) {
  var inverseFactor = 1 - t,
      inverseFactorTimesTwo = inverseFactor * inverseFactor,
      factorTimes2 = t * t,
      factor1 = inverseFactorTimesTwo * inverseFactor,
      factor2 = 3 * t * inverseFactorTimesTwo,
      factor3 = 3 * factorTimes2 * inverseFactor,
      factor4 = factorTimes2 * t;
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    var z = (glMatrix.RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
vec3.angle = function(a, b) {
   
    var tempA = vec3.fromValues(a[0], a[1], a[2]);
    var tempB = vec3.fromValues(b[0], b[1], b[2]);
 
    vec3.normalize(tempA, tempA);
    vec3.normalize(tempB, tempB);
 
    var cosine = vec3.dot(tempA, tempB);

    if(cosine > 1.0){
        return 0;
    } else {
        return Math.acos(cosine);
    }     
};

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

module.exports = vec3;

},{"./common.js":2}],10:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */
var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
vec4.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = x * len;
        out[1] = y * len;
        out[2] = z * len;
        out[3] = w * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = glMatrix.RANDOM();
    out[1] = glMatrix.RANDOM();
    out[2] = glMatrix.RANDOM();
    out[3] = glMatrix.RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

module.exports = vec4;

},{"./common.js":2}],11:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && !isFinite(value)) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) {
    return a === b;
  }
  var aIsArgs = isArguments(a),
      bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  var ka = objectKeys(a),
      kb = objectKeys(b),
      key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":16}],12:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],13:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],14:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],15:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],16:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":15,"_process":14,"inherits":13}],17:[function(require,module,exports){
/**
 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseAssign = require('lodash._baseassign'),
    createAssigner = require('lodash._createassigner'),
    keys = require('lodash.keys');

/**
 * A specialized version of `_.assign` for customizing assigned values without
 * support for argument juggling, multiple sources, and `this` binding `customizer`
 * functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 */
function assignWith(object, source, customizer) {
  var index = -1,
      props = keys(source),
      length = props.length;

  while (++index < length) {
    var key = props[index],
        value = object[key],
        result = customizer(value, source[key], key, object, source);

    if ((result === result ? (result !== value) : (value === value)) ||
        (value === undefined && !(key in object))) {
      object[key] = result;
    }
  }
  return object;
}

/**
 * Assigns own enumerable properties of source object(s) to the destination
 * object. Subsequent sources overwrite property assignments of previous sources.
 * If `customizer` is provided it is invoked to produce the assigned values.
 * The `customizer` is bound to `thisArg` and invoked with five arguments:
 * (objectValue, sourceValue, key, object, source).
 *
 * **Note:** This method mutates `object` and is based on
 * [`Object.assign`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign).
 *
 * @static
 * @memberOf _
 * @alias extend
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {*} [thisArg] The `this` binding of `customizer`.
 * @returns {Object} Returns `object`.
 * @example
 *
 * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
 * // => { 'user': 'fred', 'age': 40 }
 *
 * // using a customizer callback
 * var defaults = _.partialRight(_.assign, function(value, other) {
 *   return _.isUndefined(value) ? other : value;
 * });
 *
 * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
 * // => { 'user': 'barney', 'age': 36 }
 */
var assign = createAssigner(function(object, source, customizer) {
  return customizer
    ? assignWith(object, source, customizer)
    : baseAssign(object, source);
});

module.exports = assign;

},{"lodash._baseassign":18,"lodash._createassigner":24,"lodash.keys":28}],18:[function(require,module,exports){
/**
 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseCopy = require('lodash._basecopy'),
    keys = require('lodash.keys');

/**
 * The base implementation of `_.assign` without support for argument juggling,
 * multiple sources, and `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return source == null
    ? object
    : baseCopy(source, keys(source), object);
}

module.exports = baseAssign;

},{"lodash._basecopy":19,"lodash.keys":20}],19:[function(require,module,exports){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property names to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @returns {Object} Returns `object`.
 */
function baseCopy(source, props, object) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    object[key] = source[key];
  }
  return object;
}

module.exports = baseCopy;

},{}],20:[function(require,module,exports){
/**
 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var getNative = require('lodash._getnative'),
    isArguments = require('lodash.isarguments'),
    isArray = require('lodash.isarray');

/** Used to detect unsigned integer values. */
var reIsUint = /^\d+$/;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeKeys = getNative(Object, 'keys');

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * A fallback implementation of `Object.keys` which creates an array of the
 * own enumerable property names of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function shimKeys(object) {
  var props = keysIn(object),
      propsLength = props.length,
      length = propsLength && object.length;

  var allowIndexes = !!length && isLength(length) &&
    (isArray(object) || isArguments(object));

  var index = -1,
      result = [];

  while (++index < propsLength) {
    var key = props[index];
    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
var keys = !nativeKeys ? shimKeys : function(object) {
  var Ctor = object == null ? undefined : object.constructor;
  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
      (typeof object != 'function' && isArrayLike(object))) {
    return shimKeys(object);
  }
  return isObject(object) ? nativeKeys(object) : [];
};

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  if (object == null) {
    return [];
  }
  if (!isObject(object)) {
    object = Object(object);
  }
  var length = object.length;
  length = (length && isLength(length) &&
    (isArray(object) || isArguments(object)) && length) || 0;

  var Ctor = object.constructor,
      index = -1,
      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
      result = Array(length),
      skipIndexes = length > 0;

  while (++index < length) {
    result[index] = (index + '');
  }
  for (var key in object) {
    if (!(skipIndexes && isIndex(key, length)) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keys;

},{"lodash._getnative":21,"lodash.isarguments":22,"lodash.isarray":23}],21:[function(require,module,exports){
/**
 * lodash 3.9.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = getNative;

},{}],22:[function(require,module,exports){
/**
 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Native method references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as an `arguments` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  return isObjectLike(value) && isArrayLike(value) &&
    hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
}

module.exports = isArguments;

},{}],23:[function(require,module,exports){
/**
 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var arrayTag = '[object Array]',
    funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/* Native method references for those with the same name as other `lodash` methods. */
var nativeIsArray = getNative(Array, 'isArray');

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(function() { return arguments; }());
 * // => false
 */
var isArray = nativeIsArray || function(value) {
  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
};

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = isArray;

},{}],24:[function(require,module,exports){
/**
 * lodash 3.1.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var bindCallback = require('lodash._bindcallback'),
    isIterateeCall = require('lodash._isiterateecall'),
    restParam = require('lodash.restparam');

/**
 * Creates a function that assigns properties of source object(s) to a given
 * destination object.
 *
 * **Note:** This function is used to create `_.assign`, `_.defaults`, and `_.merge`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return restParam(function(object, sources) {
    var index = -1,
        length = object == null ? 0 : sources.length,
        customizer = length > 2 ? sources[length - 2] : undefined,
        guard = length > 2 ? sources[2] : undefined,
        thisArg = length > 1 ? sources[length - 1] : undefined;

    if (typeof customizer == 'function') {
      customizer = bindCallback(customizer, thisArg, 5);
      length -= 2;
    } else {
      customizer = typeof thisArg == 'function' ? thisArg : undefined;
      length -= (customizer ? 1 : 0);
    }
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"lodash._bindcallback":25,"lodash._isiterateecall":26,"lodash.restparam":27}],25:[function(require,module,exports){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * A specialized version of `baseCallback` which only supports `this` binding
 * and specifying the number of arguments to provide to `func`.
 *
 * @private
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function bindCallback(func, thisArg, argCount) {
  if (typeof func != 'function') {
    return identity;
  }
  if (thisArg === undefined) {
    return func;
  }
  switch (argCount) {
    case 1: return function(value) {
      return func.call(thisArg, value);
    };
    case 3: return function(value, index, collection) {
      return func.call(thisArg, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(thisArg, accumulator, value, index, collection);
    };
    case 5: return function(value, other, key, object, source) {
      return func.call(thisArg, value, other, key, object, source);
    };
  }
  return function() {
    return func.apply(thisArg, arguments);
  };
}

/**
 * This method returns the first argument provided to it.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = bindCallback;

},{}],26:[function(require,module,exports){
/**
 * lodash 3.0.9 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used to detect unsigned integer values. */
var reIsUint = /^\d+$/;

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if the provided arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
      ? (isArrayLike(object) && isIndex(index, object.length))
      : (type == 'string' && index in object)) {
    var other = object[index];
    return value === value ? (value === other) : (other !== other);
  }
  return false;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = isIterateeCall;

},{}],27:[function(require,module,exports){
/**
 * lodash 3.6.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as an array.
 *
 * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
 *
 * @static
 * @memberOf _
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.restParam(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function restParam(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        rest = Array(length);

    while (++index < length) {
      rest[index] = args[start + index];
    }
    switch (start) {
      case 0: return func.call(this, rest);
      case 1: return func.call(this, args[0], rest);
      case 2: return func.call(this, args[0], args[1], rest);
    }
    var otherArgs = Array(start + 1);
    index = -1;
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = rest;
    return func.apply(this, otherArgs);
  };
}

module.exports = restParam;

},{}],28:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20,"lodash._getnative":29,"lodash.isarguments":30,"lodash.isarray":31}],29:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],30:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],31:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],32:[function(require,module,exports){
/**
 * lodash 3.1.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseAssign = require('lodash._baseassign'),
    baseCreate = require('lodash._basecreate'),
    isIterateeCall = require('lodash._isiterateecall');

/**
 * Creates an object that inherits from the given `prototype` object. If a
 * `properties` object is provided its own enumerable properties are assigned
 * to the created object.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} prototype The object to inherit from.
 * @param {Object} [properties] The properties to assign to the object.
 * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
 * @returns {Object} Returns the new object.
 * @example
 *
 * function Shape() {
 *   this.x = 0;
 *   this.y = 0;
 * }
 *
 * function Circle() {
 *   Shape.call(this);
 * }
 *
 * Circle.prototype = _.create(Shape.prototype, {
 *   'constructor': Circle
 * });
 *
 * var circle = new Circle;
 * circle instanceof Circle;
 * // => true
 *
 * circle instanceof Shape;
 * // => true
 */
function create(prototype, properties, guard) {
  var result = baseCreate(prototype);
  if (guard && isIterateeCall(prototype, properties, guard)) {
    properties = undefined;
  }
  return properties ? baseAssign(result, properties) : result;
}

module.exports = create;

},{"lodash._baseassign":33,"lodash._basecreate":39,"lodash._isiterateecall":40}],33:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18,"lodash._basecopy":34,"lodash.keys":35}],34:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],35:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20,"lodash._getnative":36,"lodash.isarguments":37,"lodash.isarray":38}],36:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],37:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],38:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],39:[function(require,module,exports){
/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(prototype) {
    if (isObject(prototype)) {
      object.prototype = prototype;
      var result = new object;
      object.prototype = undefined;
    }
    return result || {};
  };
}());

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = baseCreate;

},{}],40:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],41:[function(require,module,exports){
/**
 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var assign = require('lodash.assign'),
    restParam = require('lodash.restparam');

/**
 * Used by `_.defaults` to customize its `_.assign` use.
 *
 * @private
 * @param {*} objectValue The destination object property value.
 * @param {*} sourceValue The source object property value.
 * @returns {*} Returns the value to assign to the destination object.
 */
function assignDefaults(objectValue, sourceValue) {
  return objectValue === undefined ? sourceValue : objectValue;
}

/**
 * Creates a `_.defaults` or `_.defaultsDeep` function.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Function} Returns the new defaults function.
 */
function createDefaults(assigner, customizer) {
  return restParam(function(args) {
    var object = args[0];
    if (object == null) {
      return object;
    }
    args.push(customizer);
    return assigner.apply(undefined, args);
  });
}

/**
 * Assigns own enumerable properties of source object(s) to the destination
 * object for all destination properties that resolve to `undefined`. Once a
 * property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
 * // => { 'user': 'barney', 'age': 36 }
 */
var defaults = createDefaults(assign, assignDefaults);

module.exports = defaults;

},{"lodash.assign":17,"lodash.restparam":42}],42:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],43:[function(require,module,exports){
module.exports = require( './lib/' );

},{"./lib/":44}],44:[function(require,module,exports){
module.exports = function () {

    var now = require("performance-now");

    function find(arr, predicate) {
            if (arr == null) {
                throw new TypeError('Array.prototype.find called on null or undefined');
            }
            if (typeof predicate !== 'function') {
                throw new TypeError('predicate must be a function');
            }
            var list = Object(arr);
            var length = list.length >>> 0;
            var value;

            for (var i = 0; i < length; i++) {
                value = list[i];
                if (predicate.call(null, value, i, list)) {
                    return value;
                }
            }
            return undefined;
    };

    var SimpleTextureManager = function (opt) {
        opt = opt || {};
        this._units = [];
        for (var i = 0; i < (opt.units || 8); i++) {
            this._units[i] = {slot: i, use: 0};
        }
    };

    SimpleTextureManager.NOT_FOUND = -1;
    SimpleTextureManager.FULL = -2;

    SimpleTextureManager.prototype = {

        _set: function (slot, newEntry) {
            var oldEntry = this._units[slot];
            if (oldEntry.dispose) {
                oldEntry.dispose(oldEntry, this);
            }
            if (newEntry) {
                this._units[slot] = newEntry;
                this._units[slot].slot = slot;
            } else {
                this._units[slot] = {slot: slot, use: 0};
            }
        },

        bind: function (id, opt) {
            opt = opt || {};
            var fixed = !!opt.fixed;
            var dispose = typeof opt.dispose == "function" ? opt.dispose : null;

            // Check if texture is already bound
            var result = this.get(id);
            if (result !== SimpleTextureManager.NOT_FOUND) {
                return result;
            }

            var candidates = this._units.filter(function (unit) {
                return !unit.fixed;
            });
            //console.log("Candidates,", candidates, candidates.length);

            if (!candidates.length) {
                return SimpleTextureManager.FULL;
            }

            var selected = candidates.reduce(function (prev, curr) {
                return prev ? (curr.use < prev.use ? curr : prev) : curr;
            }, null);
            //console.log("Selected entry", selected);

            var slot = selected.slot;
            this._set(slot, {
                fixed: fixed, use: now(), id: id, dispose: dispose
            });
            return slot;

        },

        dispose: function (id) {
            var entry = this.getEntry(id);
            this._set(entry.slot, null);
        },
        /**
         * Returns if the texture of the given id is bound to an unit
         * @param id
         * @returns {boolean}
         */
        has: function (id) {
            return !!this.getEntry(id);
        },
        /**
         * Returns the current texture unit for the id or SimpleTextureManager.NOT_FOUND
         * if the texture is currently not bound
         * @param id
         * @returns {*}
         */
        get: function (id) {
            var result = this.getEntry(id);
            if(result) {
                result.use = now();
                return result.slot;
            }
            return SimpleTextureManager.NOT_FOUND;
        },

        use: function (id) {
            var result = this.getEntry(id);
            if(result) {
                result.use = now();
            }
        },

        getEntry: function (id) {
            return find(this._units, function (entry) {
                return entry.id === id;
            });
        }

    };


    return {
        SimpleTextureManager: SimpleTextureManager
    };
}();

},{"performance-now":45}],45:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var getNanoSeconds, hrtime, loadTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - loadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    loadTime = getNanoSeconds();
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

}).call(this,require('_process'))
},{"_process":14}],46:[function(require,module,exports){
(function() {
  'use strict';

  if (self.fetch) {
    return
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)

    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var list = this.map[name]
    if (!list) {
      list = []
      this.map[name] = list
    }
    list.push(value)
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    var values = this.map[normalizeName(name)]
    return values ? values[0] : null
  }

  Headers.prototype.getAll = function(name) {
    return this.map[normalizeName(name)] || []
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = [normalizeValue(value)]
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    Object.getOwnPropertyNames(this.map).forEach(function(name) {
      this.map[name].forEach(function(value) {
        callback.call(thisArg, value, name, this)
      }, this)
    }, this)
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    reader.readAsArrayBuffer(blob)
    return fileReaderReady(reader)
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    reader.readAsText(blob)
    return fileReaderReady(reader)
  }

  var support = {
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob();
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  function Body() {
    this.bodyUsed = false


    this._initBody = function(body) {
      this._bodyInit = body
      if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (!body) {
        this._bodyText = ''
      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
        // Only support ArrayBuffers for POST method.
        // Receiving ArrayBuffers happens via Blobs, instead.
      } else {
        throw new Error('unsupported BodyInit type')
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        return this.blob().then(readBlobAsArrayBuffer)
      }

      this.text = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text')
        } else {
          return Promise.resolve(this._bodyText)
        }
      }
    } else {
      this.text = function() {
        var rejected = consumed(this)
        return rejected ? rejected : Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body
    if (Request.prototype.isPrototypeOf(input)) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = input
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this)
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function headers(xhr) {
    var head = new Headers()
    var pairs = xhr.getAllResponseHeaders().trim().split('\n')
    pairs.forEach(function(header) {
      var split = header.trim().split(':')
      var key = split.shift().trim()
      var value = split.join(':').trim()
      head.append(key, value)
    })
    return head
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this._initBody(bodyInit)
    this.type = 'default'
    this.status = options.status
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = options.statusText
    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
    this.url = options.url || ''
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request
      if (Request.prototype.isPrototypeOf(input) && !init) {
        request = input
      } else {
        request = new Request(input, init)
      }

      var xhr = new XMLHttpRequest()

      function responseURL() {
        if ('responseURL' in xhr) {
          return xhr.responseURL
        }

        // Avoid security warnings on getResponseHeader when not allowed by CORS
        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
          return xhr.getResponseHeader('X-Request-URL')
        }

        return;
      }

      xhr.onload = function() {
        var status = (xhr.status === 1223) ? 204 : xhr.status
        if (status < 100 || status > 599) {
          reject(new TypeError('Network request failed'))
          return
        }
        var options = {
          status: status,
          statusText: xhr.statusText,
          headers: headers(xhr),
          url: responseURL()
        }
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})();

},{}],47:[function(require,module,exports){
var Set = require("../xflow/utils/utils.js").set;
var DataNode = require("../xflow/interface/graph.js").DataNode;
var Base = require("../xflow/base.js");

function AssetError(message, node){
    this.message = message;
    this.node = node;
}

var Asset = function(refNode){
    this.name = null;
    this.srcAsset = null;
    this.children = [];
    this.subAssets = [];
    this.pickFilter = null;
    this.parents = [];
    this.listener = [];
    this.loading = false;
    this.refNode = refNode || null;
    this.material = null;
    this.transform = null;

    this.assetResult = null;
    this.loadLevel = 0;
    this.progressLevel = Infinity;
};

Asset.prototype.checkValidity = function(){
    if(this.isSubtreeLoading())
        return;
    checkRecursive(this);
};
function checkRecursive(asset){
    if(asset.srcAsset){
        checkRecursive(asset.srcAsset);
    }
    var localNames = [];
    for(var i = 0; i < asset.children.length; ++i){
        var child = asset.children[i], name = child.name;
        if(name && localNames.indexOf(name) != -1){
            throw new AssetError("Two subdata elements with the same name: '" + name + "'", child.refNode);
        }
        if(name) localNames.push(name);
    }
    for(var i = 0; i < asset.subAssets.length; ++i){
        checkRecursive(asset.subAssets[i]);
    }
}


Asset.prototype.setLoading = function(loading){
    if(loading != this.loading){
        this.loading = loading;
        updateLoadingState(this);
        invalidateAsset(this);

    }
};

Asset.prototype.isSubtreeLoading = function(){
    return this.progressLevel == 0;
};
Asset.prototype.getProgressLevel = function(){
    return this.progressLevel;
};

Asset.prototype.setName = function(name){
    this.name = name;
    invalidateAsset(this);
};

Asset.prototype.setMaterial = function(material){
    this.material = material;
    invalidateAsset(this);
};

Asset.prototype.setTransform = function(transform){
    this.transform = transform;
    if (this.refNode.localName.toLowerCase() !== "model") {
        invalidateAsset(this);
    }
};

Asset.prototype.appendChild = function(child){
    this.children.push(child);
    child.assetParent = this;
    updateLoadingState(this);
    invalidateAsset(this);

};

Asset.prototype.setPickFilter = function(pickFilterString){
    if(typeof pickFilterString == "string"){
        this.pickFilter = new AssetPickFilter();
        this.pickFilter.parse(pickFilterString);
    }
    else
        this.pickFilter = null;
    invalidateAsset(this);
};

Asset.prototype.appendSubAsset = function(subAsset){
    subAsset._addParent(this);
    this.subAssets.push(subAsset);
    updateLoadingState(this);
    invalidateAsset(this);

};

Asset.prototype.setSrcAsset = function(asset){
    if(this.srcAsset)
        this.srcAsset._removeParent(this);

    this.srcAsset = asset;

    if(this.srcAsset)
        this.srcAsset._addParent(this);
    updateLoadingState(this);
    invalidateAsset(this);

};

Asset.prototype.clearChildren = function(){
    var i = this.children.length;
    while(i--) this.children[i].assetParent = null;
    this.children = [];
    updateLoadingState(this);
    invalidateAsset(this);

};
Asset.prototype.clearSubAssets = function(){
    var i = this.subAssets.length;
    while(i--) {
        this.subAssets[i]._removeParent(this);
    }
    this.subAssets.length = 0;
    updateLoadingState(this);
    invalidateAsset(this);

};

Asset.prototype._addParent = function(asset){
    this.parents.push(asset);
};
Asset.prototype._removeParent = function(asset){
    var idx = this.parents.indexOf(asset);
    if(idx != -1)
        this.parents.splice(idx, 1);
};

Asset.prototype._callLoadListeners = function(newLevel, oldLevel){
    var listeners = this.listener;
    for(var i = 0; i < listeners.length; ++i){
        listeners[i].onAssetLoadChange && listeners[i].onAssetLoadChange(this, newLevel, oldLevel);
    }
};


Asset.prototype.addChangeListener = function(listener){
    Set.add(this.listener, listener);
};
Asset.prototype.removeChangeListener = function(listener){
    Set.remove(this.listener, listener);
    if (!this.listener.length) {
        this.dispose();
    }
};

Asset.prototype.dispose = function() {
    this.assetResult.dispose();
    this.clearSubAssets();
    this.clearChildren();
};

Asset.prototype.getResult = function(){
    if(!this.assetResult){
        this.assetResult = new AssetResult();
        this.assetResult.construct(this);
    }
    return this.assetResult;
};

function invalidateAsset(asset){
    if(asset.assetResult){
        asset.assetResult = null;
    }
    var listeners = asset.listener;
    for(var i = 0; i < listeners.length; ++i){
        listeners[i].onAssetChange && listeners[i].onAssetChange(this);
    }
    var i = asset.parents.length;
    while(i--){
        invalidateAsset(asset.parents[i]);
    }
}


function updateLoadingState(asset){
    var progressLevel = asset.loading ? asset.loadLevel : Infinity;
    if(progressLevel && asset.srcAsset){
        progressLevel = Math.min(progressLevel, Math.max(asset.srcAsset.loadLevel, asset.srcAsset.progressLevel));
    }
    var i = asset.subAssets.length;
    while(progressLevel && i--){
        progressLevel = Math.min(progressLevel, Math.max(asset.subAssets[i].loadLevel, asset.subAssets[i].progressLevel));
    }
    var i = asset.children.length;
    while(progressLevel && i--){
        progressLevel = Math.min(progressLevel, asset.children[i].progressLevel);
    }
    var oldLevel = asset.progressLevel;
    asset.progressLevel = progressLevel;

    if(oldLevel != asset.progressLevel){
        asset._callLoadListeners(asset.progressLevel, oldLevel);
        for(var i = 0; i < asset.parents.length; ++i)
            updateLoadingState(asset.parents[i]);
    }
}


//----------------------------------------------------------------------------------------------------------------------
// SubData
//----------------------------------------------------------------------------------------------------------------------

var SubData = function(xflowNodeOut, xflowNodeIn, refNode){
    this.xflowNodeOut = xflowNodeOut;
    this.xflowNodeIn = xflowNodeIn;
    this.refNode = refNode || null;
    this.name = null;
    this.matchFilter = null;
    this.classNames = [];
    this.postDataflow = null;
    this.postCompute = null;
    this.postFilter = null;
    this.includes = [];
    this.material = null;
    this.transform = null;
    this.meshType = null;
    this.visible = true;
    this.assetParent = null;
    this.loading = false;
    this.loadLevel = 0;
    this.progressLevel = Infinity;
    xflowNodeIn.addLoadListener(this.onXflowLoadEvent.bind(this));
    this._updateLoadingState();
};

SubData.prototype.setLoading = function(loading){
    if(loading != this.loading){
        this.loading = loading;
        this._updateLoadingState();
        invalidateParent(this);

    }
};

SubData.prototype._updateLoadingState = function(){
    var progressLevel = this.loading ? this.loadLevel : Infinity;
    progressLevel = Math.min(progressLevel, this.xflowNodeIn.getProgressLevel());
    var oldLevel = this.progressLevel;
    this.progressLevel = progressLevel;

    if(oldLevel != this.progressLevel){
        this.assetParent && updateLoadingState(this.assetParent);
        invalidateParent(this);
    }
};
SubData.prototype.onXflowLoadEvent = function(){
    this._updateLoadingState();
};

SubData.prototype.isSubtreeLoading = function(){
    return this.loading;
};

SubData.prototype.isMesh = function(){
    return !!this.meshType;
};

SubData.prototype.setName = function(name){
    this.name = name;
    invalidateParent(this);
};

SubData.prototype.setMatchFilter = function(matchString){
    if(typeof matchString == "string"){
        this.matchFilter = new AssetPickFilter();
        this.matchFilter.parse(matchString);
    }
    else
        this.matchFilter = null;
    invalidateParent(this);
};

SubData.prototype.setClassNames = function(classNames){
    this.classNames = classNames;
    invalidateParent(this);
};
SubData.prototype.setClassNamesString = function(classNamesString){
    if(!classNamesString)
        this.setClassNames([]);
    else{
        var array = classNamesString.split(/\s+/);
        var i = array.length;
        while(i--) array[i] = array[i].trim();
        this.setClassNames(array);
    }
};


SubData.prototype.setPostDataflow = function(postDataflow){
    this.postDataflow = postDataflow;
    invalidateParent(this);
};

SubData.prototype.setPostCompute = function(postCompute){
    this.postCompute = postCompute;
    invalidateParent(this);
};

SubData.prototype.setPostFilter = function(postFilter){
    this.postFilter = postFilter;
    invalidateParent(this);
};

SubData.prototype.setIncludes = function(includes){
    this.includes = includes;
    invalidateParent(this);
};

SubData.prototype.setMaterial = function(material){
    this.material = material;
    invalidateParent(this);
};

SubData.prototype.setTransform = function(transform){
    this.transform = transform;
    invalidateParent(this);
};

SubData.prototype.setMeshType = function(meshType){
    this.meshType = meshType;
    invalidateParent(this);
};

SubData.prototype.setVisibility = function(isVisible) {
    this.visible = isVisible;
    invalidateParent(this);
};
function invalidateParent(subData){
    if(subData.assetParent){
        invalidateAsset(subData.assetParent);
    }
}

//----------------------------------------------------------------------------------------------------------------------
// AssetResult
//----------------------------------------------------------------------------------------------------------------------

var AssetResult = function(){
    this.parentResult = null;
    this.name = null;
    this.namedEntries = {};
    this.allEntries = [];
    this.matchEntries = [];
    this.namedSubResults = {};
    this.allSubResults = [];

    this.material = null;
    this.transform = null;
    this.pickFilter = null;
};

AssetResult.prototype.construct = function(asset){
    constructAssetTable(this, asset);
};

AssetResult.prototype.dispose = function() {
    for (var i = 0; i < this.allEntries.length; i++) {
        this.allEntries[i].dispose();
    }

    for (var i = 0; i < this.allSubResults.length; i++) {
        this.allSubResults[i].dispose();
    }
};

AssetResult.prototype.getDataTree = function(){
    return rec_getDataTree(this);
};


function constructAssetTable(table, asset){
    table.name = asset.name;

    var srcAsset = asset.srcAsset, srcResult = srcAsset && srcAsset.getResult();
    if(srcResult){
        copySrcTable(table, srcAsset.getResult(), asset.pickFilter);
    }
    else
        table.pickFilter = asset.pickFilter;

    if(asset.material) table.material = asset.material;
    if(asset.transform) table.transform = combineTransform(table.transform, asset.transform);


    var subAssets = asset.subAssets;
    var i = subAssets.length;
    while(i--){
        var result = subAssets[i].getResult();
        mergeSubAssetResult(table, result);
    }
    var matchChildren = [];
    var children = asset.children;
    for(var i = 0; i < children.length; ++i){
        var child = children[i];
        var name = child.name;
        var entry;
        if(child.name && child.matchFilter){
            XML3D.debug.logWarning("Asset entry defines both name and match attribute. Match attribute will be ignored", child.refNode);
        }
        if(name){
            if(!table.namedEntries[name]){
                entry = new AssetTableEntry(child);
                applyMatchEntries(entry, table.matchEntries);
                table.namedEntries[name] = entry;
                table.allEntries.push(entry);
            }
            else
                entry = table.namedEntries[name];
        }
        else if(child.matchFilter){
            matchChildren.push(child);
            continue;
        }
        else{
            entry = new AssetTableEntry(child);
            applyMatchEntries(entry, table.matchEntries);
            table.allEntries.push(entry);
        }
        entry.pushPostEntry(child);
    }
    for(var i = 0; i < matchChildren.length; ++i){
        var child = matchChildren[i];
        var matchEntry = {filter: child.matchFilter, subdata: child};
        table.matchEntries.push(matchEntry);
        for(var j = 0; j < table.allEntries.length; ++j){
            applyMatchEntry(table.allEntries[j], matchEntry);
        }
    }
}

function applyMatchEntries(destEntry, matchEntries){
    for(var i = 0; i < matchEntries.length; ++i){
        applyMatchEntry(destEntry, matchEntries[i]);
    }
}

function applyMatchEntry(destEntry, matchEntry){
    var child = matchEntry.subdata;
    if(child.isMesh() == destEntry.isMesh() && matchEntry.filter.check(destEntry)){
        destEntry.pushPostEntry(child);
    }
}


function copySrcTable(table, srcTable, pickFilter){

    if(srcTable.matchEntries.length > 0){
        var i = table.allEntries.length;
        while(i--){
            var entry = table.allEntries[i];
            if(!entry.name || !srcTable.namedEntries[entry.name]){
                applyMatchEntries(entry, srcTable.matchEntries);
            }
        }
    }

    var i = srcTable.allEntries.length;
    while(i--){
        var srcEntry = srcTable.allEntries[i];
        var destEntry, newlyCreated = false;
        if(srcEntry.name && table.namedEntries[srcEntry.name]){
            destEntry = table.namedEntries[srcEntry.name];
        }
        else{
            destEntry = new AssetTableEntry();
            newlyCreated = true;
            table.allEntries.push(destEntry);
        }
        destEntry.pushTableEntry(srcEntry);
        if(newlyCreated)
            applyMatchEntries(destEntry, table.matchEntries);

        if(destEntry.name) table.namedEntries[destEntry.name] = destEntry;
    }

    table.matchEntries.push.apply(table.matchEntries, srcTable.matchEntries);


    var i = srcTable.allSubResults.length;
    while(i--){
        mergeSubAssetResult(table, srcTable.allSubResults[i]);
    }

    if(pickFilter && srcTable.pickFilter){
        table.pickFilter = new AssetPickFilter();
        table.pickFilter.intersection(pickFilter, srcTable.pickFilter);
    }
    else{
        table.pickFilter = pickFilter || srcTable.pickFilter;
    }
    if(srcTable.material) table.material = srcTable.material;
    if(srcTable.transform) table.transform = combineTransform(table.transform, srcTable.transform);
}


function mergeSubAssetResult(table, srcSubTable){
    var destSubTable;
    if(srcSubTable.name && table.namedSubResults[srcSubTable.name]){
        destSubTable = table.namedSubResults[srcSubTable.name];
    }
    else{
        destSubTable = new AssetResult();
        destSubTable.parentResult = table;
        destSubTable.name = srcSubTable.name;
        table.allSubResults.push(destSubTable);
        if(destSubTable.name) table.namedSubResults[destSubTable.name] = destSubTable;
    }
    copySrcTable(destSubTable, srcSubTable, destSubTable.pickFilter);
}

function rec_getDataTree(table){
    var node = {
        meshes: [],
        groups: [],
        transform: table.transform,
        material: table.material,
        postTransformXflowNode: null
    };

    for(var i = 0; i < table.allEntries.length; ++i){
        var entry = table.allEntries[i];
        if(entry.meshType && (!table.pickFilter || table.pickFilter.check(entry)) ){
            updateAccumulatedNode(table, entry);
            node.meshes.push({
                xflowNode: entry.accumulatedXflowNode,
                type: entry.meshType,
                material: entry.material,
                transform: entry.transform,
                visible: entry.visible,
                refNode: entry.refNode
            });
        }
    }
    var postTransformEntry = table.namedEntries["_postTransform"];
    if(postTransformEntry){
        updateAccumulatedNode(table, postTransformEntry);
        node.postTransformXflowNode = postTransformEntry.accumulatedXflowNode;
    }
    for(var i = 0; i < table.allSubResults.length; ++i){
        var subNode = rec_getDataTree(table.allSubResults[i]);
        node.groups.push(subNode);
    }
    return node;
}

function updateAccumulatedNode(table, entry){
    if(!entry.outOfSync)
        return;

    if(entry.accumulatedXflowNode){
        entry.accumulatedXflowNode.setCompute("");
        entry.accumulatedXflowNode.setFilter("");
        entry.accumulatedXflowNode.dataflowNode = null;
        entry.accumulatedXflowNode.setLoading(false);
    }
    else{
        entry.accumulatedXflowNode = new AssetDataNode(false);
    }

    var dataNode = entry.postQueue.length == 1 ? entry.accumulatedXflowNode : new AssetDataNode(false);
    for(var i = 0; i < entry.postQueue.length; ++i){
        var includes = entry.postQueue[i].includes;
        for(var j = 0; j < includes.length; ++j){
            var addEntry = getIncludeEntry(table, includes[j]);
            dataNode.appendChild(addEntry.accumulatedXflowNode);
        }
        if(entry.postQueue[i].xflowNode)
            dataNode.appendChild(entry.postQueue[i].xflowNode);
    }
    var node = dataNode, parentNode = null;
    for(var i = 0; i < entry.postQueue.length; ++i){
        var postEntry = entry.postQueue[i];
        if(!node) node = (i == entry.postQueue.length - 1 ? entry.accumulatedXflowNode : new AssetDataNode(false));
        node.setCompute(postEntry.compute);
        node.setFilter(postEntry.filter);
        node.dataflowNode = postEntry.dataflow;
        node.setLoading(postEntry.dataflowLoading);
        if(parentNode) node.appendChild(parentNode);
        parentNode = node;
        node = null;
    }
    entry.outOfSync = false;
}


var c_accum_entries = [],
    c_accum_names = [];

function getIncludeEntry(table, includeString){
    var segments = includeString.split(".");
    for(var i = 0; i < segments.length -1; ++i){
        var seg = segments[i];
        if(seg == "parent"){
            if(!table.parentResult)
                throw new Error("Includes entry '" + includeString + "' (token "+ i +") accesses non existent parent.");
            table = table.parentResult;
        }
        else{
            if(!table.namedSubResults[seg])
                throw new Error("Includes entry '" + includeString + "' (token "+ i +") accesses non existent sub result '" + seg + "'");
            table = table.namedSubResults[seg];
        }
    }
    var entryKey = segments[segments.length - 1];
    var entry = table.namedEntries[entryKey];
    if(!entry){
        throw new Error("Includes entry '" + includeString + "' accesses non existent asset entry '" + entryKey + "'" );
    }

    c_accum_names.push(includeString);
    if(c_accum_entries.indexOf(entry) != -1){
        var path = c_accum_names.join(" > ");
        throw new Error("Recursive include dependencies detected: " + path);
    }
    c_accum_entries.push(entry);

    updateAccumulatedNode(table, entry);
    c_accum_entries.pop();
    c_accum_names.pop();
    return entry;
}




function AssetTableEntry (subData){
    this.name = null;
    this.classNames = [];
    this.meshType = null;

    this.postQueue = [];
    this.material = null;
    this.transform = null;
    this.visible = true;

    this.accumulatedXflowNode = null;
    this.outOfSync = true;
    this.refNode = null;
    if(subData){
        this.name = subData.name;
        Set.add(this.classNames, subData.classNames);
    }
}

AssetTableEntry.prototype.isMesh = function(){
    return !!this.meshType;
};

/**
 * Clears child<->parent relationships for all Xflow nodes that were created for this Asset instance specifically (eg through overrides)
 */
AssetTableEntry.prototype.dispose = function() {
    clearAssetRelatedChildren(this.accumulatedXflowNode);
    this.accumulatedXflowNode.clear();
};

/**
 * This function clears parent->child and dataFlowNode relationships for all xflow nodes
 * that were generated for the AssetTableEntry that it's called from initially. It won't clear
 * relationships for any normal DataNodes that are part of non-asset-related Xflow graphs (ie. dataflow graphs)
 * @param dataNode
 */
function clearAssetRelatedChildren(dataNode) {
    if (dataNode._children === undefined) {
        return; //Input leaf node, nothing to do here
    }
    for (var i = 0; i < dataNode._children.length; i++) {
        clearAssetRelatedChildren(dataNode._children[i]);
    }
    if (dataNode.isAssetDataNode) {
        dataNode.clear();
        dataNode._channelNode.setStructureOutOfSync();
    }
}


AssetTableEntry.prototype.pushTableEntry = function(srcEntry){
    this.name = srcEntry.name;
    Set.add(this.classNames, srcEntry.classNames);
    if(srcEntry.meshType) this.meshType = srcEntry.meshType;
    if(srcEntry.visible !== undefined) this.visible = srcEntry.visible;

    if(srcEntry.transform) this.transform = combineTransform(this.transform, srcEntry.transform);
    if(srcEntry.material) this.material = srcEntry.material;

    this.postQueue.push.apply(this.postQueue, srcEntry.postQueue);
};


AssetTableEntry.prototype.pushPostEntry = function(subData){
    this.name = subData.name;
    this.postQueue.push({
        dataflow: subData.postDataflow,
        dataflowLoading: subData.loading,
        compute: subData.postCompute,
        filter: subData.postFilter,
        includes: subData.includes,
        xflowNode: subData.xflowNodeIn
    });
    this.refNode = subData.refNode;
    this.accumulatedXflowNode = subData.xflowNodeOut;
    Set.add(this.classNames, subData.classNames);
    if(subData.meshType) this.meshType = subData.meshType;
    if(subData.material) this.material = subData.material;
    if(subData.visible !== undefined) this.visible = subData.visible;
    if(subData.transform) this.transform = combineTransform(this.transform, subData.transform);
};


function combineTransform(oldTransform, newTransform){
    // TODO: Better multiply transformations here
    return newTransform;
}


function AssetPickFilter(){
    this.all = false;
    this.names = [];
    this.classNames = [];
}

AssetPickFilter.prototype.parse = function(string){
    var entries = string.split(",");
    var i = entries.length;
    while(i--){
        var entry = entries[i].trim();
        if(entry == "*"){
            this.all = true;
        }
        else if(entry.indexOf(".") == 0){
            var classNames = entry.split(".");
            var j = classNames.length;
            while(j--){
                if(!classNames[j].trim())
                    classNames.splice(j,1);
            }
            this.classNames.push(classNames);
        }
        else{
            Set.add(this.names, entry);
        }
    }
};

AssetPickFilter.prototype.intersection = function(setA, setB){
    Set.intersection(this.names, setA.names, setB.names);
    Set.intersection(this.classNames, setA.classNames, setB.classNames);
};

AssetPickFilter.prototype.check = function(entry){
    if(this.all)
        return true;
    if(entry.classNames.length > 0){
        var i = this.classNames.length;
        while(i--){
            if(Set.isSubset(this.classNames[i], entry.classNames))
                return true;
        }
    }
    return (entry.name && this.names.indexOf(entry.name) != -1);
};

/**
 * This is just a small wrapper to identify Xflow nodes that were created by an Asset, eg as part of overrides
 * that need to be cleaned up later if the corresponding model tag is destroyed
 * @param isDataFlow
 * @constructor
 */
var AssetDataNode = function(isDataFlow) {
    DataNode.call(this, isDataFlow);
    this.isAssetDataNode = true;
};

Base.createClass(AssetDataNode, DataNode);

module.exports = {
    Asset: Asset,
    SubData: SubData,
    AssetResult: AssetResult
};

},{"../xflow/base.js":186,"../xflow/interface/graph.js":189,"../xflow/utils/utils.js":238}],48:[function(require,module,exports){
var Events = require("../interface/notification.js");
var config = require("../interface/elements.js").config;
var Resource = require("../resource");

/**
 * A normal adapter that doesn't need to be connected to a DOM node
 * @constructor
 * @param {XML3D.base.AdapterFactory} factory - the factory this adapter was created from
 */
var Adapter = function(factory) {
    this.factory = factory;
};

/**
 * Connect an adapterHandle to a certain key.
 * This will enable the ConnectedAdapterNotifcations for notifyChanged.
 * @param {string} key - the key that will also be provided in connectAdapterChanged callback
 * @param {XML3D.base.AdapterHandle} adapterHandle handle of adapter to be added
 */
Adapter.prototype.connectAdapterHandle = function(key, adapterHandle) {
    if (!this.connectedAdapterHandles) {
        this.connectedAdapterHandles = {};
        this._bindedAdapterHandleCallback = adapterHandleCallback.bind(this);
    }

    this.disconnectAdapterHandle(key);

    if (adapterHandle) {
        this.connectedAdapterHandles[key] = adapterHandle;
        this.connectedAdapterHandles[key].addListener(this._bindedAdapterHandleCallback);
    }
    else
        delete this.connectedAdapterHandles[key];

};

/**
 * Disconnects the adapter handle from the given key.
 * @param {string} key - the key that was provided when this adapter handle was connected
 */
Adapter.prototype.disconnectAdapterHandle = function(key) {
    if (this.connectedAdapterHandles && this.connectedAdapterHandles[key]) {
        this.connectedAdapterHandles[key].removeListener(this._bindedAdapterHandleCallback);
        delete this.connectedAdapterHandles[key];
    }
};

/**
 * Disconnects all adapter handles.
 */
Adapter.prototype.clearAdapterHandles = function() {
    for (var i in this.connectedAdapterHandles) {
        this.connectedAdapterHandles[i].removeListener(this._bindedAdapterHandleCallback);
    }

    this.connectedAdapterHandles = null;
};

/**
 * Get the connected AdapterHandle of a certain key.
 * This will only return AdapterHandles previously added via connectAdapterHandle
 * @param {string} key
 * @return {?AdapterHandle} the adapter of that key, or null if not available
 */
Adapter.prototype.getConnectedAdapterHandle = function(key) {
    return this.connectedAdapterHandles && this.connectedAdapterHandles[key];
};

/**
 * Get the connected adapter of a certain key.
 * This will only return adapters of AdapterHandles previously added via connectAdapter
 * @param {string} key
 * @return {?XML3D.base.Adapter} the adapter of that key, or null if not available
 */
Adapter.prototype.getConnectedAdapter = function(key) {
    var handle = this.getConnectedAdapterHandle(key);
    return handle && handle.getAdapter();
};

/**
 * This function is called, when the adapater is detached from the node.
 * At this point, the adapater should disconnect from any other adapter and prepare to be properly garbage collected
 */
Adapter.prototype.dispose = function() {
};


/**
 * Internal function that converts an AdapterHandleNotification to a ConnectedAdapterNotification
 * @private
 * @param {Events.AdapterHandleNotification} evt
 */
function adapterHandleCallback(evt) {
    for (var key in this.connectedAdapterHandles) {
        if (this.connectedAdapterHandles[key] == evt.adapterHandle) {
            var subEvent = new Events.ConnectedAdapterNotification(evt, key);
            this.notifyChanged(subEvent);
        }
    }
}


/**
 * An Adapter connected to a DOMNode (possibly of an external document)
 * @constructor
 * @param {AdapterFactory} factory the AdapterFactory this adapter was created from
 * @param {Object} node - DOM node of this Adapter
 */
var NodeAdapter = function(factory, node) {
    Adapter.call(this, factory);
    this.node = node;
};
XML3D.createClass(NodeAdapter, Adapter);

/**
 * called by the factory after adding the adapter to the node
 */
NodeAdapter.prototype.init = function() {
};

/**
 * Notifiction due to a change in DOM, related adapters and so on.
 * @param {Events.Notification} e
 */
NodeAdapter.prototype.notifyChanged = function(e) {

};

/**
 * @param {string|XML3D.URI} uri Uri to referred adapterHandle
 * @param {Object=} aspectType Optional: the type of adapter (use same adapter type by default)
 * @param {number=} canvasId Optional: the canvas id of the adapter (use canvas id of this adapter by default)
 * @returns an AdapterHandle to the referred Adapter of the same aspect and canvasId
 */
NodeAdapter.prototype.getAdapterHandle = function(uri, aspectType, canvasId) {
    canvasId = canvasId === undefined ? this.factory.canvasId : canvasId;
    return Resource.getAdapterHandle(this.node.ownerDocument._documentURL || this.node.ownerDocument.URL,
        uri, aspectType || this.factory.aspect, canvasId, this.node.nodeName);
};
/**
 * notifies all adapter that refer to this adapter through AdapterHandles.
 * @param {number?} type The type of change
 */
NodeAdapter.prototype.notifyOppositeAdapters = function(type) {
    type = type || Events.ADAPTER_HANDLE_CHANGED;
    return Resource.notifyNodeAdapterChange(this.node,
        this.factory.aspect, this.factory.canvasId, type);
};

/**
 * Depth-first traversal over element hierarchy
 * @param {function(NodeAdapter)} callback
 */
NodeAdapter.prototype.traverse = function(callback) {
    callback(this);
    var child = this.node.firstElementChild;
    while (child) {
        var adapter = this.factory.getAdapter(child);
        adapter && adapter.traverse(callback);
        child = child.nextElementSibling;
    }
};


/**
 * @interface
 */
var IFactory = function() {
};
IFactory.prototype.createAdapter = function() {};


/**
 * An adapter factory is responsible for creating adapter from a certain data source.
 * Note that any AdapterFactory is registered with Resource
 * @constructor
 * @implements {IFactory}
 * @param {Object} aspect The aspect this factory serves (e.g. XML3D.data or XML3D.webgl)
 * @param {string|Array.<string>} mimetypes The mimetype this factory is compatible to
 * @param {number} canvasId The id of the corresponding canvas handler. 0, if not dependent on any GLCanvasHandler
 */
var AdapterFactory = function(aspect, mimetypes, canvasId) {
    this.aspect = aspect;
    this.canvasId = canvasId || 0;
    this.mimetypes = typeof mimetypes == "string" ? [ mimetypes] : mimetypes;
};

 /** Implemented by subclass
 * Create adapter from an object (node in case of an xml, and object in case of json)
 * @param {object} obj
 * @returns {?Adapter} created adapter or null if no adapter can be created
 */
AdapterFactory.prototype.createAdapter = function(obj) {
    return null;
};

/**
 * Checks if the adapter factory supports specified mimetype. Can be overridden by subclass.
 * @param {String} mimetype
 * @return {Boolean} true if the adapter factory supports specified mimetype
 */
AdapterFactory.prototype.supportsMimetype = function(mimetype) {
    return this.mimetypes.indexOf(mimetype) != -1;
};

/**
 * A NodeAdaperFactory is a AdapterFactory, that works specifically for DOM nodes / elements.
 * @constructor
 * @param {Object} aspect The aspect this factory serves (e.g. XML3D.data or XML3D.webgl)
 * @param {number} canvasId The id of the corresponding canvas handler. 0, if not dependent on any GLCanvasHandler
 */
var NodeAdapterFactory = function(aspect, canvasId) {
    AdapterFactory.call(this, aspect, ["text/xml", "application/xml"], canvasId);
};
XML3D.createClass(NodeAdapterFactory, AdapterFactory);

/**
 * This function first checks, if an adapter has been already created for the corresponding node
 * If yes, this adapter is returned, otherwise, a new adapter is created and returned.
 * @param {Object} node
 * @returns {Adapter} The adapter of the node
 */
NodeAdapterFactory.prototype.getAdapter = function(node) {
    if(node && node._configured === undefined)
        config.element(node);
    if (!node || node._configured === undefined)
        return null;

    var elemHandler = node._configured;
    var key = this.aspect + "_" + this.canvasId;
    var adapter = elemHandler.adapters[key];
    if (adapter !== undefined)
        return adapter;

    // No adapter found, try to create one
    adapter = this.createAdapter(node);
    if (adapter) {
        elemHandler.adapters[key] = adapter;
        adapter.init();
    }
    return adapter;
};

module.exports = {
NodeAdapter : NodeAdapter,
AdapterFactory : AdapterFactory,
NodeAdapterFactory : NodeAdapterFactory
};

},{"../interface/elements.js":72,"../interface/notification.js":74,"../resource":165}],49:[function(require,module,exports){
var Events = require("../interface/notification.js");

"use strict";
/**
 * An adapter handle is a connection piece for an adapter that is referred through a uri (e.g. id reference)
 * AdapterHandles are always fetched from the Resource object
 * @constructor
 */
var AdapterHandle = function(url) {
    this.url = url;
    this.adapter = null;
    this.listeners = [];
    this.status = 0; // STATUS.LOADING
};

/**
 * Enumaeration of states for the adapter handle
 * @enum {number}
 */
AdapterHandle.STATUS = {
    LOADING: 0,
    NOT_FOUND: 1,
    READY: 2
};

/**
 * @returns {Boolean} true iff an adapter is available
 */
AdapterHandle.prototype.hasAdapter = function() {
    return this.adapter != null;
};

/**
 * @returns {?XML3D.base.Adapter} the adapter connected to the handle. Can be null
 */
AdapterHandle.prototype.getAdapter = function() {
    return this.adapter;
};

/**
 * Note: this function should only be called by Resource
 * @param {XML3D.base.Adapter} adapter The adapter connected to the AdapterHandler
 * @param {AdapterHandle.STATUS} status
 */
AdapterHandle.prototype.setAdapter = function(adapter, status) {
    this.adapter = adapter;
    this.status = status;
    this.notifyListeners(Events.ADAPTER_HANDLE_CHANGED);
};

/**
 * This function is called to notify all listeners of this AdapterHandle about some change.
 * @param {number} type A type number with the type of change (usually Events.ADAPTER_HANDLE_CHANGED)
 */
AdapterHandle.prototype.notifyListeners = function(type) {
    var event = new Events.AdapterHandleNotification(this, type);
    var i = this.listeners.length;
    while (i--) {
        this.listeners[i](event);
    }
};

/**
 * Add a listener to the AdapterHandle that is notified about changes.
 * Listeners cannot be inserted twice.
 * @param {Function} listener - Function to be called when something concering the adapter changes
 */
AdapterHandle.prototype.addListener = function(listener) {
    var idx = this.listeners.indexOf(listener);
    if (idx == -1)
        this.listeners.push(listener);
};

/**
 * Remove a listener from the AdapterHandle
 * @param {Function} listener
 */
AdapterHandle.prototype.removeListener = function(listener) {
    var idx = this.listeners.indexOf(listener);
    if (idx != -1)
        this.listeners.splice(idx, 1);
};

module.exports = AdapterHandle;
},{"../interface/notification.js":74}],50:[function(require,module,exports){
/*jslint white: false, onevar: false, undef: true, nomen: true, eqeqeq: true, plusplus: true, bitwise: true, regexp: true, newcap: true, immed: true, sub: true, nomen: false */

/**
* This file contains code that may be under the following license:
*
* SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
* Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
*
* See http://oss.sgi.com/projects/FreeB/ for more information.
*
* All code in this file which is NOT under the SGI FREE SOFTWARE LICENSE B
* is free and unencumbered software released into the public domain.
*
* Anyone is free to copy, modify, publish, use, compile, sell, or
* distribute this software, either in source code form or as a compiled
* binary, for any purpose, commercial or non-commercial, and by any
* means.
*
* In jurisdictions that recognize copyright laws, the author or authors
* of this software dedicate any and all copyright interest in the
* software to the public domain. We make this dedication for the benefit
* of the public at large and to the detriment of our heirs and
* successors. We intend this dedication to be an overt act of
* relinquishment in perpetuity of all present and future rights to this
* software under copyright law.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
* OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/

var GLU = {};
/**
* Unproject a screen point.
*
* @param {number} winX the window point for the x value.
* @param {number} winY the window point for the y value.
* @param {number} winZ the window point for the z value.
* @param {Array.<number>} model the model-view matrix.
* @param {Array.<number>} proj the projection matrix.
* @param {Array.<number>} view the viewport coordinate array.
* @param {Array.<number>} objPos the model point result.
* @return {boolean} true if the unproject operation was successful, false otherwise.
*/
GLU.unProject = function(winX, winY, winZ, model, proj, view, objPos) {

    /** @type {Array.<number>} */
    var inp = [
        winX,
        winY,
        winZ,
        1.0
    ];

    /** @type {Array.<number>} */
    var finalMatrix = [];

    GLU.multMatrices(model, proj, finalMatrix);
    if (!GLU.invertMatrix(finalMatrix, finalMatrix)) {
        return (false);
    }

    /* Map x and y from window coordinates */
    inp[0] = (inp[0] - view[0]) / view[2];
    inp[1] = (inp[1] - view[1]) / view[3];

    /* Map to range -1 to 1 */
    inp[0] = inp[0] * 2 - 1;
    inp[1] = inp[1] * 2 - 1;
    inp[2] = inp[2] * 2 - 1;

    /** @type {Array.<number>} */
    var out = [];

    GLU.multMatrixVec(finalMatrix, inp, out);

    if (out[3] === 0.0) {
        return false;
    }

    out[0] /= out[3];
    out[1] /= out[3];
    out[2] /= out[3];

    objPos[0] = out[0];
    objPos[1] = out[1];
    objPos[2] = out[2];

    return true;
};

/**
* Multiply the matrix by the specified vector.
*
* @param {Array.<number>} matrix the matrix.
* @param {Array.<number>} inp the vector.
* @param {Array.<number>} out the output.
*/
GLU.multMatrixVec = function(matrix, inp, out) {
    for (var i = 0; i < 4; i = i + 1) {
        out[i] =
            inp[0] * matrix[0 * 4 + i] +
            inp[1] * matrix[1 * 4 + i] +
            inp[2] * matrix[2 * 4 + i] +
            inp[3] * matrix[3 * 4 + i];
    }
};

/**
* Multiply the specified matrices.
*
* @param {Array.<number>} a the first matrix.
* @param {Array.<number>} b the second matrix.
* @param {Array.<number>} r the result.
*/
GLU.multMatrices = function(a, b, r) {
    for (var i = 0; i < 4; i = i + 1) {
        for (var j = 0; j < 4; j = j + 1) {
            r[i * 4 + j] =
                a[i * 4 + 0] * b[0 * 4 + j] +
                a[i * 4 + 1] * b[1 * 4 + j] +
                a[i * 4 + 2] * b[2 * 4 + j] +
                a[i * 4 + 3] * b[3 * 4 + j];
        }
    }
};

/**
* Invert a matrix.
*
* @param {Array.<number>} m the matrix.
* @param {Array.<number>} invOut the inverted output.
* @return {boolean} true if successful, false otherwise.
*/
GLU.invertMatrix = function(m, invOut) {
    /** @type {Array.<number>} */
    var inv = [];

    inv[0] = m[5] * m[10] * m[15] - m[5] * m[11] * m[14] - m[9] * m[6] * m[15] +
        m[9] * m[7] * m[14] + m[13] * m[6] * m[11] - m[13] * m[7] * m[10];
    inv[4] = -m[4] * m[10] * m[15] + m[4] * m[11] * m[14] + m[8] * m[6] * m[15] -
        m[8] * m[7] * m[14] - m[12] * m[6] * m[11] + m[12] * m[7] * m[10];
    inv[8] = m[4] * m[9] * m[15] - m[4] * m[11] * m[13] - m[8] * m[5] * m[15] +
        m[8] * m[7] * m[13] + m[12] * m[5] * m[11] - m[12] * m[7] * m[9];
    inv[12] = -m[4] * m[9] * m[14] + m[4] * m[10] * m[13] + m[8] * m[5] * m[14] -
        m[8] * m[6] * m[13] - m[12] * m[5] * m[10] + m[12] * m[6] * m[9];
    inv[1] = -m[1] * m[10] * m[15] + m[1] * m[11] * m[14] + m[9] * m[2] * m[15] -
        m[9] * m[3] * m[14] - m[13] * m[2] * m[11] + m[13] * m[3] * m[10];
    inv[5] = m[0] * m[10] * m[15] - m[0] * m[11] * m[14] - m[8] * m[2] * m[15] +
        m[8] * m[3] * m[14] + m[12] * m[2] * m[11] - m[12] * m[3] * m[10];
    inv[9] = -m[0] * m[9] * m[15] + m[0] * m[11] * m[13] + m[8] * m[1] * m[15] -
        m[8] * m[3] * m[13] - m[12] * m[1] * m[11] + m[12] * m[3] * m[9];
    inv[13] = m[0] * m[9] * m[14] - m[0] * m[10] * m[13] - m[8] * m[1] * m[14] +
        m[8] * m[2] * m[13] + m[12] * m[1] * m[10] - m[12] * m[2] * m[9];
    inv[2] = m[1] * m[6] * m[15] - m[1] * m[7] * m[14] - m[5] * m[2] * m[15] +
        m[5] * m[3] * m[14] + m[13] * m[2] * m[7] - m[13] * m[3] * m[6];
    inv[6] = -m[0] * m[6] * m[15] + m[0] * m[7] * m[14] + m[4] * m[2] * m[15] -
        m[4] * m[3] * m[14] - m[12] * m[2] * m[7] + m[12] * m[3] * m[6];
    inv[10] = m[0] * m[5] * m[15] - m[0] * m[7] * m[13] - m[4] * m[1] * m[15] +
        m[4] * m[3] * m[13] + m[12] * m[1] * m[7] - m[12] * m[3] * m[5];
    inv[14] = -m[0] * m[5] * m[14] + m[0] * m[6] * m[13] + m[4] * m[1] * m[14] -
        m[4] * m[2] * m[13] - m[12] * m[1] * m[6] + m[12] * m[2] * m[5];
    inv[3] = -m[1] * m[6] * m[11] + m[1] * m[7] * m[10] + m[5] * m[2] * m[11] -
        m[5] * m[3] * m[10] - m[9] * m[2] * m[7] + m[9] * m[3] * m[6];
    inv[7] = m[0] * m[6] * m[11] - m[0] * m[7] * m[10] - m[4] * m[2] * m[11] +
        m[4] * m[3] * m[10] + m[8] * m[2] * m[7] - m[8] * m[3] * m[6];
    inv[11] = -m[0] * m[5] * m[11] + m[0] * m[7] * m[9] + m[4] * m[1] * m[11] -
        m[4] * m[3] * m[9] - m[8] * m[1] * m[7] + m[8] * m[3] * m[5];
    inv[15] = m[0] * m[5] * m[10] - m[0] * m[6] * m[9] - m[4] * m[1] * m[10] +
        m[4] * m[2] * m[9] + m[8] * m[1] * m[6] - m[8] * m[2] * m[5];

    /** @type {number} */
    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    if (det === 0) {
        return false;
    }

    det = 1.0 / det;

    for (var i = 0; i < 16; i = i + 1) {
        invOut[i] = inv[i] * det;
    }

    return true;
};

module.exports = GLU;
},{}],51:[function(require,module,exports){
// Domain Public by Eric Wendelin http://eriwen.com/ (2008)
//                  Luke Smith http://lucassmith.name/ (2008)
//                  Loic Dachary <loic@dachary.org> (2008)
//                  Johan Euphrosine <proppy@aminche.com> (2008)
//                  Oyvind Sean Kinsey http://kinsey.no/blog (2010)
//                  Victor Homyakov <victor-homyakov@users.sourceforge.net> (2010)


/**
 * Main function giving a function stack trace with a forced or passed in
 * Error
 *
 * @cfg {Error} e The error to create a stacktrace from (optional)
 * @cfg {Boolean} guess If we should try to resolve the names of anonymous
 * functions
 * @return {Array} of Strings with functions, lines, files, and arguments
 * where possible
 */
var printStackTrace = function (options) {
    options = options || {
        guess : true
    };
    var ex = options.e || null, guess = !!options.guess;
    var p = new printStackTrace.implementation(), result = p.run(ex);
    return (guess) ? p.guessAnonymousFunctions(result) : result;
};

printStackTrace.implementation = function() {};

printStackTrace.implementation.prototype = {
    /**
     * @param {Error} ex The error to create a stacktrace from (optional)
     * @param {String} mode Forced mode (optional, mostly for unit tests)
     */
    run : function(ex, mode) {
        ex = ex || this.createException();
        // examine exception properties w/o debugger
        // for (var prop in ex) {alert("Ex['" + prop + "']=" + ex[prop]);}
        mode = mode || this.mode(ex);
        if (mode === 'other') {
            return this.other(arguments.callee);
        } else {
            return this[mode](ex);
        }
    },

    createException : function() {
        try {
            this.undef();
        } catch (e) {
            return e;
        }
    },

    /**
     * Mode could differ for different exception, e.g. exceptions in Chrome
     * may or may not have arguments or stack.
     *
     * @return {String} mode of operation for the exception
     */
    mode : function(e) {
        if (e['arguments'] && e.stack) {
            return 'chrome';
        } else if (e.stack && e.sourceURL) {
            return 'safari';
        } else if (typeof e.message === 'string' && typeof window !== 'undefined' && window.opera) {
            // e.message.indexOf("Backtrace:") > -1 -> opera
            // !e.stacktrace -> opera
            if (!e.stacktrace) {
                return 'opera9'; // use e.message
            }
            // 'opera#sourceloc' in e -> opera9, opera10a
            if (e.message.indexOf('\n') > -1 && e.message.split('\n').length > e.stacktrace.split('\n').length) {
                return 'opera9'; // use e.message
            }
            // e.stacktrace && !e.stack -> opera10a
            if (!e.stack) {
                return 'opera10a'; // use e.stacktrace
            }
            // e.stacktrace && e.stack -> opera10b
            if (e.stacktrace.indexOf("called from line") < 0) {
                return 'opera10b'; // use e.stacktrace, format differs from
                                    // 'opera10a'
            }
            // e.stacktrace && e.stack -> opera11
            return 'opera11'; // use e.stacktrace, format differs from
                                // 'opera10a', 'opera10b'
        } else if (e.stack) {
            return 'firefox';
        }
        return 'other';
    },

    /**
     * Given a context, function name, and callback function, overwrite it
     * so that it calls printStackTrace() first with a callback and then
     * runs the rest of the body.
     *
     * @param {Object} context of execution (e.g. window)
     * @param {String} functionName to instrument
     * @param {Function} function to call with a stack trace on invocation
     */
    instrumentFunction : function(context, functionName, callback) {
        context = context || window;
        var original = context[functionName];
        context[functionName] = function instrumented() {
            callback.call(this, printStackTrace().slice(4));
            return context[functionName]._instrumented.apply(this, arguments);
        };
        context[functionName]._instrumented = original;
    },

    /**
     * Given a context and function name of a function that has been
     * instrumented, revert the function to it's original (non-instrumented)
     * state.
     *
     * @param {Object} context of execution (e.g. window)
     * @param {String} functionName to de-instrument
     */
    deinstrumentFunction : function(context, functionName) {
        if (context[functionName].constructor === Function && context[functionName]._instrumented
                && context[functionName]._instrumented.constructor === Function) {
            context[functionName] = context[functionName]._instrumented;
        }
    },

    /**
     * Given an Error object, return a formatted Array based on Chrome's
     * stack string.
     *
     * @param e - Error object to inspect
     * @return Array<String> of function calls, files and line numbers
     */
    chrome : function(e) {
        var stack = (e.stack + '\n').replace(/^\S[^\(]+?[\n$]/gm, '').replace(/^\s+(at eval )?at\s+/gm, '').replace(/^([^\(]+?)([\n$])/gm,
                '{anonymous}()@$1$2').replace(/^Object.<anonymous>\s*\(([^\)]+)\)/gm, '{anonymous}()@$1').split('\n');
        stack.pop();
        return stack;
    },

    /**
     * Given an Error object, return a formatted Array based on Safari's
     * stack string.
     *
     * @param e - Error object to inspect
     * @return Array<String> of function calls, files and line numbers
     */
    safari : function(e) {
        return e.stack.replace(/\[native code\]\n/m, '').replace(/^@/gm, '{anonymous}()@').split('\n');
    },

    /**
     * Given an Error object, return a formatted Array based on Firefox's
     * stack string.
     *
     * @param e - Error object to inspect
     * @return Array<String> of function calls, files and line numbers
     */
    firefox : function(e) {
        return e.stack.replace(/(?:\n@:0)?\s+$/m, '').replace(/^[\(@]/gm, '{anonymous}()@').split('\n');
    },

    opera11 : function(e) {
        var ANON = '{anonymous}', lineRE = /^.*line (\d+), column (\d+)(?: in (.+))? in (\S+):$/;
        var lines = e.stacktrace.split('\n'), result = [];

        for ( var i = 0, len = lines.length; i < len; i += 2) {
            var match = lineRE.exec(lines[i]);
            if (match) {
                var location = match[4] + ':' + match[1] + ':' + match[2];
                var fnName = match[3] || "global code";
                fnName = fnName.replace(/<anonymous function: (\S+)>/, "$1").replace(/<anonymous function>/, ANON);
                result.push(fnName + '@' + location + ' -- ' + lines[i + 1].replace(/^\s+/, ''));
            }
        }

        return result;
    },

    opera10b : function(e) {
        // "<anonymous function: run>([arguments not
        // available])@file://localhost/G:/js/stacktrace.js:27\n" +
        // "printStackTrace([arguments not
        // available])@file://localhost/G:/js/stacktrace.js:18\n" +
        // "@file://localhost/G:/js/test/functional/testcase1.html:15"
        var lineRE = /^(.*)@(.+):(\d+)$/;
        var lines = e.stacktrace.split('\n'), result = [];

        for ( var i = 0, len = lines.length; i < len; i++) {
            var match = lineRE.exec(lines[i]);
            if (match) {
                var fnName = match[1] ? (match[1] + '()') : "global code";
                result.push(fnName + '@' + match[2] + ':' + match[3]);
            }
        }

        return result;
    },

    /**
     * Given an Error object, return a formatted Array based on Opera 10's
     * stacktrace string.
     *
     * @param e - Error object to inspect
     * @return Array<String> of function calls, files and line numbers
     */
    opera10a : function(e) {
        // " Line 27 of linked script
        // file://localhost/G:/js/stacktrace.js\n"
        // " Line 11 of inline#1 script in
        // file://localhost/G:/js/test/functional/testcase1.html: In
        // function foo\n"
        var ANON = '{anonymous}', lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
        var lines = e.stacktrace.split('\n'), result = [];

        for ( var i = 0, len = lines.length; i < len; i += 2) {
            var match = lineRE.exec(lines[i]);
            if (match) {
                var fnName = match[3] || ANON;
                result.push(fnName + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\s+/, ''));
            }
        }

        return result;
    },

    // Opera 7.x-9.2x only!
    opera9 : function(e) {
        // " Line 43 of linked script
        // file://localhost/G:/js/stacktrace.js\n"
        // " Line 7 of inline#1 script in
        // file://localhost/G:/js/test/functional/testcase1.html\n"
        var ANON = '{anonymous}', lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
        var lines = e.message.split('\n'), result = [];

        for ( var i = 2, len = lines.length; i < len; i += 2) {
            var match = lineRE.exec(lines[i]);
            if (match) {
                result.push(ANON + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\s+/, ''));
            }
        }

        return result;
    },

    // Safari 5-, IE 9-, and others
    other : function(curr) {
        var ANON = '{anonymous}', fnRE = /function\s*([\w\-$]+)?\s*\(/i, stack = [], fn, args, maxStackSize = 10;
        while (curr && curr['arguments'] && stack.length < maxStackSize) {
            fn = fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON;
            args = Array.prototype.slice.call(curr['arguments'] || []);
            stack[stack.length] = fn + '(' + this.stringifyArguments(args) + ')';
            curr = curr.caller;
        }
        return stack;
    },

    /**
     * Given arguments array as a String, subsituting type names for
     * non-string types.
     *
     * @param {Arguments} args
     * @return {Array} of Strings with stringified arguments
     */
    stringifyArguments : function(args) {
        var result = [];
        var slice = Array.prototype.slice;
        for ( var i = 0; i < args.length; ++i) {
            var arg = args[i];
            if (arg === undefined) {
                result[i] = 'undefined';
            } else if (arg === null) {
                result[i] = 'null';
            } else if (arg.constructor) {
                if (arg.constructor === Array) {
                    if (arg.length < 3) {
                        result[i] = '[' + this.stringifyArguments(arg) + ']';
                    } else {
                        result[i] = '[' + this.stringifyArguments(slice.call(arg, 0, 1)) + '...' + this.stringifyArguments(slice.call(arg, -1)) + ']';
                    }
                } else if (arg.constructor === Object) {
                    result[i] = '#object';
                } else if (arg.constructor === Function) {
                    result[i] = '#function';
                } else if (arg.constructor === String) {
                    result[i] = '"' + arg + '"';
                } else if (arg.constructor === Number) {
                    result[i] = arg;
                }
            }
        }
        return result.join(',');
    },

    sourceCache : {},

    /**
     * @return the text from a given URL
     */
    ajax : function(url) {
        var req = this.createXMLHTTPObject();
        if (req) {
            try {
                req.open('GET', url, false);
                // req.overrideMimeType('text/plain');
                // req.overrideMimeType('text/javascript');
                req.send(null);
                // return req.status == 200 ? req.responseText : '';
                return req.responseText;
            } catch (e) {
            }
        }
        return '';
    },

    /**
     * Try XHR methods in order and store XHR factory.
     *
     * @return <Function> XHR function or equivalent
     */
    createXMLHTTPObject : function() {
        var xmlhttp, XMLHttpFactories = [ function() {
            return new XMLHttpRequest();
        }, function() {
            return new ActiveXObject('Msxml2.XMLHTTP');
        }, function() {
            return new ActiveXObject('Msxml3.XMLHTTP');
        }, function() {
            return new ActiveXObject('Microsoft.XMLHTTP');
        } ];
        for ( var i = 0; i < XMLHttpFactories.length; i++) {
            try {
                xmlhttp = XMLHttpFactories[i]();
                // Use memoization to cache the factory
                this.createXMLHTTPObject = XMLHttpFactories[i];
                return xmlhttp;
            } catch (e) {
            }
        }
    },

    /**
     * Given a URL, check if it is in the same domain (so we can get the
     * source via Ajax).
     *
     * @param url <String> source url
     * @return False if we need a cross-domain request
     */
    isSameDomain : function(url) {
        return typeof location !== "undefined" && url.indexOf(location.hostname) !== -1; // location
                                                                                            // may
                                                                                            // not
                                                                                            // be
                                                                                            // defined,
                                                                                            // e.g.
                                                                                            // when
                                                                                            // running
                                                                                            // from
                                                                                            // nodejs.
    },

    /**
     * Get source code from given URL if in the same domain.
     *
     * @param url <String> JS source URL
     * @return <Array> Array of source code lines
     */
    getSource : function(url) {
        // TODO reuse source from script tags?
        if (!(url in this.sourceCache)) {
            this.sourceCache[url] = this.ajax(url).split('\n');
        }
        return this.sourceCache[url];
    },

    guessAnonymousFunctions : function(stack) {
        for ( var i = 0; i < stack.length; ++i) {
            var reStack = /\{anonymous\}\(.*\)@(.*)/, reRef = /^(.*?)(?::(\d+))(?::(\d+))?(?: -- .+)?$/, frame = stack[i], ref = reStack.exec(frame);

            if (ref) {
                var m = reRef.exec(ref[1]);
                if (m) { // If falsey, we did not get any file/line
                            // information
                    var file = m[1], lineno = m[2], charno = m[3] || 0;
                    if (file && this.isSameDomain(file) && lineno) {
                        var functionName = this.guessAnonymousFunction(file, lineno, charno);
                        stack[i] = frame.replace('{anonymous}', functionName);
                    }
                }
            }
        }
        return stack;
    },

    guessAnonymousFunction : function(url, lineNo, charNo) {
        var ret;
        try {
            ret = this.findFunctionName(this.getSource(url), lineNo);
        } catch (e) {
            ret = 'getSource failed with url: ' + url + ', exception: ' + e.toString();
        }
        return ret;
    },

    findFunctionName : function(source, lineNo) {
        // FIXME findFunctionName fails for compressed source
        // (more than one function on the same line)
        // TODO use captured args
        // function {name}({args}) m[1]=name m[2]=args
        var reFunctionDeclaration = /function\s+([^(]*?)\s*\(([^)]*)\)/;
        // {name} = function ({args}) TODO args capture
        // /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*function(?:[^(]*)/
        var reFunctionExpression = /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*function\b/;
        // {name} = eval()
        var reFunctionEvaluation = /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*(?:eval|new Function)\b/;
        // Walk backwards in the source lines until we find
        // the line which matches one of the patterns above
        var code = "", line, maxLines = Math.min(lineNo, 20), m, commentPos;
        for ( var i = 0; i < maxLines; ++i) {
            // lineNo is 1-based, source[] is 0-based
            line = source[lineNo - i - 1];
            commentPos = line.indexOf('//');
            if (commentPos >= 0) {
                line = line.substr(0, commentPos);
            }
            // TODO check other types of comments? Commented code may lead to false positive
            if (line) {
                code = line + code;
                m = reFunctionExpression.exec(code);
                if (m && m[1]) {
                    return m[1];
                }
                m = reFunctionDeclaration.exec(code);
                if (m && m[1]) {
                    //return m[1] + "(" + (m[2] || "") + ")";
                    return m[1];
                }
                m = reFunctionEvaluation.exec(code);
                if (m && m[1]) {
                    return m[1];
                }
            }
        }
        return '(?)';
    }
};

module.exports = printStackTrace;
},{}],52:[function(require,module,exports){

var StateMachine = {

    //---------------------------------------------------------------------------

    VERSION: "2.2.0",

    //---------------------------------------------------------------------------

    Result: {
      SUCCEEDED:    1, // the event transitioned successfully from one state to another
      NOTRANSITION: 2, // the event was successfull but no state transition was necessary
      CANCELLED:    3, // the event was cancelled by the caller in a beforeEvent callback
      ASYNC:        4 // the event is asynchronous and the caller is in control of when the transition occurs
    },

    Error: {
      INVALID_TRANSITION: 100, // caller tried to fire an event that was innapropriate in the current state
      PENDING_TRANSITION: 200, // caller tried to fire an event while an async transition was still pending
      INVALID_CALLBACK:   300 // caller provided callback function threw an exception
    },

    WILDCARD: '*',
    ASYNC: 'async',

    //---------------------------------------------------------------------------

    create: function(cfg, target) {

      var initial   = (typeof cfg.initial == 'string') ? { state: cfg.initial } : cfg.initial; // allow for a simple string, or an object with { state: 'foo', event: 'setup', defer: true|false }
      var fsm       = target || cfg.target  || {};
      var events    = cfg.events || [];
      var callbacks = cfg.callbacks || {};
      var map       = {};

      var add = function(e) {
        var from = (e.from instanceof Array) ? e.from : (e.from ? [e.from] : [StateMachine.WILDCARD]); // allow 'wildcard' transition if 'from' is not specified
        map[e.name] = map[e.name] || {};
        for (var n = 0 ; n < from.length ; n++)
          map[e.name][from[n]] = e.to || from[n]; // allow no-op transition if 'to' is not specified
      };

      if (initial) {
        initial.event = initial.event || 'startup';
        add({ name: initial.event, from: 'none', to: initial.state });
      }

      for(var n = 0 ; n < events.length ; n++)
        add(events[n]);

      for(var name in map) {
        if (map.hasOwnProperty(name))
          fsm[name] = StateMachine.buildEvent(name, map[name]);
      }

      for(var name in callbacks) {
        if (callbacks.hasOwnProperty(name))
          fsm[name] = callbacks[name]
      }

      fsm.current = 'none';
      fsm.is      = function(state) { return this.current == state; };
      fsm.can     = function(event) { return !this.transition && (map[event].hasOwnProperty(this.current) || map[event].hasOwnProperty(StateMachine.WILDCARD)); }
      fsm.cannot  = function(event) { return !this.can(event); };
      fsm.error   = cfg.error || function(name, from, to, args, error, msg, e) { throw e || msg; }; // default behavior when something unexpected happens is to throw an exception, but caller can override this behavior if desired (see github issue #3 and #17)

      if (initial && !initial.defer)
        fsm[initial.event]();

      return fsm;

    },

    //===========================================================================

    doCallback: function(fsm, func, name, from, to, args) {
      if (func) {
        try {
          return func.apply(fsm, [name, from, to].concat(args));
        }
        catch(e) {
          return fsm.error(name, from, to, args, StateMachine.Error.INVALID_CALLBACK, "an exception occurred in a caller-provided callback function", e);
        }
      }
    },

    beforeEvent: function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onbefore' + name],                     name, from, to, args); },
    afterEvent:  function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onafter'  + name] || fsm['on' + name], name, from, to, args); },
    leaveState:  function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onleave'  + from],                     name, from, to, args); },
    enterState:  function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onenter'  + to]   || fsm['on' + to],   name, from, to, args); },
    changeState: function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onchangestate'],                       name, from, to, args); },


    buildEvent: function(name, map) {
      return function() {

        var from  = this.current;
        var to    = map[from] || map[StateMachine.WILDCARD] || from;
        var args  = Array.prototype.slice.call(arguments); // turn arguments into pure array

        if (this.transition)
          return this.error(name, from, to, args, StateMachine.Error.PENDING_TRANSITION, "event " + name + " inappropriate because previous transition did not complete");

        if (this.cannot(name))
          return this.error(name, from, to, args, StateMachine.Error.INVALID_TRANSITION, "event " + name + " inappropriate in current state " + this.current);

        if (false === StateMachine.beforeEvent(this, name, from, to, args))
          return StateMachine.Result.CANCELLED;

        if (from === to) {
          StateMachine.afterEvent(this, name, from, to, args);
          return StateMachine.Result.NOTRANSITION;
        }

        // prepare a transition method for use EITHER lower down, or by caller if they want an async transition (indicated by an ASYNC return value from leaveState)
        var fsm = this;
        this.transition = function() {
          fsm.transition = null; // this method should only ever be called once
          fsm.current = to;
          StateMachine.enterState( fsm, name, from, to, args);
          StateMachine.changeState(fsm, name, from, to, args);
          StateMachine.afterEvent( fsm, name, from, to, args);
        };
        this.transition.cancel = function() { // provide a way for caller to cancel async transition if desired (issue #22)
          fsm.transition = null;
          StateMachine.afterEvent(fsm, name, from, to, args);
        };

        var leave = StateMachine.leaveState(this, name, from, to, args);
        if (false === leave) {
          this.transition = null;
          return StateMachine.Result.CANCELLED;
        }
        else if ("async" === leave) {
          return StateMachine.Result.ASYNC;
        }
        else {
          if (this.transition)
            this.transition(); // in case user manually called transition() but forgot to return ASYNC
          return StateMachine.Result.SUCCEEDED;
        }

      };
    }

}; // StateMachine

//===========================================================================

/*if ("function" === typeof define) {
define(function(require) { return StateMachine; });
}
else {*/
window.StateMachine = StateMachine;
/*}*/

module.exports = StateMachine;


},{}],53:[function(require,module,exports){
var DOMTransformFetcher = require("../transform-fetcher.js");
var DataAdapter = require("./data.js");
var Base = require("../../xflow/base.js");
var DataNode = require("../../xflow/interface/graph.js").DataNode;
var getComputeDataflowUrl = require("../../xflow/interface/graph.js").getComputeDataflowUrl;
var Asset = require("../../asset/asset.js").Asset;
var SubData = require("../../asset/asset.js").SubData;
var Events = require("../../interface/notification.js");
var dispatchCustomEvent = require("../../utils/misc.js").dispatchCustomEvent;
var Resource = require("../../resource");

var NodeAdapter = require("../../base/adapter.js").NodeAdapter;
var createClass = XML3D.createClass;
var AdapterHandle = require("../../base/adapterhandle.js");


var AssetAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);

    /**
     *  @type Asset
     **/
    this.asset = new Asset(this.node);
    if (node.localName.toLowerCase() !== "model") {
        this.transformFetcher = new DOMTransformFetcher(this, "transform", "transform");
    }
};

createClass(AssetAdapter, NodeAdapter);

AssetAdapter.prototype.init = function () {
    this.asset.addChangeListener(this);
    this.asset.setName(this.node.getAttribute("name"));
    updateAdapterHandle(this, "src", this.node.getAttribute("src"));
    updatePickFilter(this);
    updateChildren(this);
    setMaterialUrl(this, this.asset);
    this.transformFetcher && this.transformFetcher.update();
};

AssetAdapter.prototype.onAssetLoadChange = function (asset, newLevel, oldLevel) {
    if (newLevel == Infinity) {
        dispatchCustomEvent(this.node, 'load', false, true, null);
    } else if (newLevel > oldLevel) {
        dispatchCustomEvent(this.node, 'progress', false, true, null);
    }
};

AssetAdapter.prototype.getAssetComplete = function () {
    return this.asset.getProgressLevel() == Infinity;
};
AssetAdapter.prototype.getAssetProgressLevel = function () {
    return this.asset.getProgressLevel();
};

AssetAdapter.prototype.getAsset = function () {
    return this.asset;
};

function updateChildren(adapter) {
    adapter.asset.clearChildren();
    adapter.asset.clearSubAssets();
    for (var child = adapter.node.firstElementChild; child !== null; child = child.nextElementSibling) {
        var subadapter = adapter.factory.getAdapter(child);
        if (subadapter && subadapter.getAsset) {
            adapter.asset.appendSubAsset(subadapter.getAsset());
        }
        if (subadapter && subadapter.assetEntry) {
            adapter.asset.appendChild(subadapter.assetEntry);
        }
    }
}

function updateAdapterHandle(adapter, key, url) {
    var adapterHandle = adapter.getAdapterHandle(url), status = (adapterHandle && adapterHandle.status);

    if (status === AdapterHandle.STATUS.NOT_FOUND) {
        XML3D.debug.logError("Could not find element of url '" + adapterHandle.url + "' for " + key, adapter.node);
    }
    adapter.connectAdapterHandle(key, adapterHandle);
    adapter.connectedAdapterChanged(key, adapterHandle ? adapterHandle.getAdapter() : null, status);
}

function updateAssetLoadState(dataAdapter) {
    var loading = false, handle;

    handle = dataAdapter.getConnectedAdapterHandle("src");
    if (handle && handle.status === AdapterHandle.STATUS.LOADING) {
        loading = true;
    }
    dataAdapter.asset.setLoading(loading);
}

function updatePickFilter(adapter) {
    if (!adapter.node.hasAttribute("pick"))
        adapter.asset.setPickFilter(null); else {
        var value = adapter.node.getAttribute("pick");
        adapter.asset.setPickFilter(value);
    }
}

AssetAdapter.prototype.connectedAdapterChanged = function (attributeName, adapter) {
    if (attributeName == "src")
        this.asset.setSrcAsset(adapter && adapter.getAsset() || null);
    updateAssetLoadState(this);
};

AssetAdapter.prototype.onTransformChange = function (attrName, matrix) {
    this.asset.setTransform(matrix);
};

AssetAdapter.prototype.attributeChangedCallback = function(name, oldValue, newValue) {
        switch (name) {
            case "name":
                this.asset.setName(newValue);
                break;
            case "material":
                setMaterialUrl(this, this.asset);
                break;
            case "style":
            case "transform":
                this.transformFetcher && this.transformFetcher.update();
                break;
            case "src":
                updateAdapterHandle(this, "src", newValue);
                break;
            case "pick":
                updatePickFilter(this);
                break;
        }
};


AssetAdapter.prototype.notifyChanged = function (evt) {
    if (evt.type == Events.ADAPTER_HANDLE_CHANGED) {
        this.connectedAdapterChanged(evt.key, evt.adapter);
        if (evt.handleStatus == AdapterHandle.STATUS.NOT_FOUND) {
            XML3D.debug.logError("Could not find <asset> element of url '" + evt.url + "' for " + evt.key);
        }
    } else if (evt.type == Events.NODE_INSERTED) {
        updateChildren(this);

    } else if (evt.type == Events.NODE_REMOVED) {
        updateChildren(this);

    }  else if (evt.type == Events.THIS_REMOVED) {
        this.clearAdapterHandles();
        this.asset.removeChangeListener(this);
    }
};

var AssetDataAdapter = function (factory, node) {
    this.assetData = true;
    DataAdapter.call(this, factory, node);

    // Node handles for src and proto
    this.assetEntry = null;
    this.outputXflowNode = null;
};
createClass(AssetDataAdapter, DataAdapter);

AssetDataAdapter.prototype.init = function () {
    DataAdapter.prototype.init.call(this);
    this.outputXflowNode = new AssetDataNode(false);
    this.assetEntry = new SubData(this.outputXflowNode, this.getXflowNode(), this.node);
    this.assetEntry.setName(this.node.getAttribute("name"));
    updateClassNames(this);
    updatePostCompute(this);
    this.assetEntry.setPostFilter(this.node.getAttribute("filter"));
    updateIncludes(this.assetEntry, this.node.getAttribute("includes"));
};

AssetDataAdapter.prototype.connectedAdapterChanged = function (attributeName, adapter) {
    if (attributeName == "postDataflow") {
        this.assetEntry.setPostDataflow(adapter && adapter.getXflowNode() || null);
        updateSubDataLoadState(this);
    } else {
        DataAdapter.prototype.connectedAdapterChanged.call(this, attributeName, adapter);
    }
};

AssetDataAdapter.prototype.attributeChangedCallback = function (name, oldValue, newValue) {
    DataAdapter.prototype.attributeChangedCallback.call(this, name, oldValue, newValue);
    switch (name) {
        case "name":
            this.assetEntry.setName(newValue);
            break;
        case "compute":
            updatePostCompute(this);
            break;
        case "class":
            updateClassNames(this);
            break;
        case "filter":
            this.assetEntry.setPostFilter(newValue);
            break;
        case "includes":
            updateIncludes(newValue);
            break;
    }
};

AssetDataAdapter.prototype.notifyChanged = function (evt) {
    DataAdapter.prototype.notifyChanged.call(this, evt);

};

AssetDataAdapter.prototype.onTransformChange = function (attrName, matrix) {
    this.assetEntry.setTransform(matrix);
};

function updateIncludes(assetEntry, includeString) {
    if (!includeString)
        assetEntry.setIncludes([]); else
        assetEntry.setIncludes(includeString.trim().split(/\s*,\s*/));
}

function updateClassNames(adapter) {
    var classNames = adapter.node.getAttribute("class");
    adapter.assetEntry.setClassNamesString(classNames)
}

function updatePostCompute(adapter) {
    var computeString = adapter.node.getAttribute("compute");
    var dataflowUrl = getComputeDataflowUrl(computeString);
    if (dataflowUrl) {
        updateAdapterHandle(adapter, "postDataflow", dataflowUrl);
    } else {
        adapter.disconnectAdapterHandle("postDataflow");
        updateSubDataLoadState(adapter);
    }
    adapter.assetEntry.setPostCompute(computeString);
}

function updateSubDataLoadState(dataAdapter) {
    var loading = false, handle;

    handle = dataAdapter.getConnectedAdapterHandle("postDataflow");
    if (handle && handle.status === AdapterHandle.STATUS.LOADING) {
        loading = true;
    }
    dataAdapter.assetEntry.setLoading(loading);
}


/**
 *
 * @param adapter
 * @param {Asset} dest
 */
function setMaterialUrl(adapter, dest) {
    var node = adapter.node;
    var materialURL = node.getAttribute("material");
    if (materialURL) {
        var materialAbsoluteURL = Resource.getAbsoluteURI(node.ownerDocument._documentURL || node.ownerDocument.URL, materialURL);
        dest.setMaterial(materialAbsoluteURL.toString());
    } else {
        dest.setMaterial(null);
    }
}

var AssetMeshAdapter = function (factory, node) {
    AssetDataAdapter.call(this, factory, node);
    this.transformFetcher = new DOMTransformFetcher(this, "transform", "transform");
};
createClass(AssetMeshAdapter, AssetDataAdapter, {

    init: function () {
        AssetDataAdapter.prototype.init.call(this);
        setMaterialUrl(this, this.assetEntry);
        this.assetEntry.setMeshType(this.node.getAttribute("type") || "triangles");
        this.assetEntry.setMatchFilter(this.node.getAttribute("match"));
        this.transformFetcher.update();
        this.updateVisibility();
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        AssetDataAdapter.prototype.attributeChangedCallback.call(this, name, oldValue, newValue);
        switch (name) {
            case "material":
                setMaterialUrl(this, this.assetEntry);
                break;
            case "match":
                this.assetEntry.setMatchFilter(newValue);
                break;
            case "style":
            case "transform":
                this.transformFetcher.update();
                this.updateVisibility();
                break;
            case "type":
                this.assetEntry.setMeshType(newValue || "triangles")
        }
    },

    notifyChanged: function (evt) {
        AssetDataAdapter.prototype.notifyChanged.call(this, evt);
    },

    updateVisibility: function () {
        if (!this.node.style) {
            this.node.style = window.getComputedStyle(this.node);
        }
        var none = this.node.style.display == "none";
        this.assetEntry && this.assetEntry.setVisibility(!none);
    }
});

/**
 * This is just a small wrapper to identify Xflow nodes that were created by an Asset, eg as part of overrides
 * that need to be cleaned up later if the corresponding model tag is destroyed
 * @param isDataFlow
 * @constructor
 */
var AssetDataNode = function(isDataFlow) {
    DataNode.call(this, isDataFlow);
    this.isAssetDataNode = true;
};

Base.createClass(AssetDataNode, DataNode);

module.exports = {
    AssetAdapter: AssetAdapter, AssetMeshAdapter: AssetMeshAdapter, AssetDataAdapter: AssetDataAdapter
};

},{"../../asset/asset.js":47,"../../base/adapter.js":48,"../../base/adapterhandle.js":49,"../../interface/notification.js":74,"../../resource":165,"../../utils/misc.js":182,"../../xflow/base.js":186,"../../xflow/interface/graph.js":189,"../transform-fetcher.js":66,"./data.js":56}],54:[function(require,module,exports){
var ComputeRequest = require("../../xflow/interface/request.js").ComputeRequest;
var setShaderConstant = require("../../xflow/processing/vs-connect.js").setShaderConstant;
var registerErrorCallback = require("../../xflow/base.js").registerErrorCallback;
var XC = require("../../xflow/interface/constants.js");
var URI = require("../../utils/uri.js").URI;

var NodeAdapter = require("../../base/adapter.js").NodeAdapter;
var createClass = XML3D.createClass;

/**
 * @extends NodeAdapter
 * @abstract
 *
 * @param factory
 * @param node
 */
var BaseDataAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
    this.xflowDataNode = null;
};
createClass(BaseDataAdapter, NodeAdapter);


BaseDataAdapter.prototype.getXflowNode = function () {
    return this.xflowDataNode;
};

BaseDataAdapter.prototype.getComputeRequest = function (filter, callback) {
    return new ComputeRequest(this.xflowDataNode, filter, callback);
};

BaseDataAdapter.prototype.getComputeResult = function (filter) {
    return this.xflowDataNode._getResult(XC.RESULT_TYPE.COMPUTE, filter);
};

BaseDataAdapter.prototype.getOutputNames = function () {
    return this.xflowDataNode.getOutputNames();
};

BaseDataAdapter.prototype.getOutputChannelInfo = function (name) {
    return this.xflowDataNode.getOutputChannelInfo(name);
};

setShaderConstant(XC.SHADER_CONSTANT_KEY.OBJECT_ID, "objectID");
setShaderConstant(XC.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM, "modelViewProjectionMatrix");
setShaderConstant(XC.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM_NORMAL, "modelViewProjectionNormalMatrix");
setShaderConstant(XC.SHADER_CONSTANT_KEY.VIEW_TRANSFORM, "modelViewMatrix");
setShaderConstant(XC.SHADER_CONSTANT_KEY.VIEW_TRANSFORM_NORMAL, "modelViewMatrixN");
setShaderConstant(XC.SHADER_CONSTANT_KEY.WORLD_TRANSFORM, "modelMatrix");
registerErrorCallback(function(message, xflowNode){
    message = "Xflow: " + message;
    var userData = xflowNode ? xflowNode.userData : null;
    if (userData && userData.ownerDocument) {
        if (userData.ownerDocument === document) {
            XML3D.debug.logError(message, userData);
        }
        else if (userData.id) {
            var uri = new URI("#" + userData.id);
            uri = uri.getAbsoluteURI(userData.ownerDocument._documentURL || userData.ownerDocument.URL);
            XML3D.debug.logError(message, "External Node: " + uri);
        }
        else {
            XML3D.debug.logError(message, "External Document: " + userData.ownerDocument.URL);
        }
    }
    else if (typeof userData == "string") {
        XML3D.debug.logError(message, userData);
    }
    else {
        XML3D.debug.logError(message);
    }
});

module.exports = BaseDataAdapter;

},{"../../base/adapter.js":48,"../../utils/uri.js":184,"../../xflow/base.js":186,"../../xflow/interface/constants.js":187,"../../xflow/interface/request.js":190,"../../xflow/processing/vs-connect.js":237}],55:[function(require,module,exports){
var Events = require("../../interface/notification.js");
var NodeAdapter = require("../../base/adapter.js").NodeAdapter;

/**
 * DataAdapter handling a <compute> element
 * @param {AdapterFactory} factory
 * @param {Element} node
 * @constructor
 */
var ComputeDataAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
};
XML3D.createClass(ComputeDataAdapter, NodeAdapter);

ComputeDataAdapter.prototype.getComputeCode = function () {
    return this.node.value;
};

/**
 * @param evt notification of type XML3D.Notification
 */
ComputeDataAdapter.prototype.notifyChanged = function (evt) {
    switch (evt.type) {
        case Events.VALUE_MODIFIED:
        case Events.NODE_INSERTED:
        case Events.NODE_REMOVED:
            var parent = this.node.parentNode;
            if (parent) {
                var parentAdapter = this.factory.getAdapter(parent);
                parentAdapter && parentAdapter.updateXflowNode();
            }
    }
};

module.exports = ComputeDataAdapter;

},{"../../base/adapter.js":48,"../../interface/notification.js":74}],56:[function(require,module,exports){
var BaseDataAdapter = require("./base.js");
var DataNode = require("../../xflow/interface/graph.js").DataNode;
var XC = require("../../xflow/interface/constants.js");
var Events = require("../../interface/notification.js");
var dispatchCustomEvent = require("../../utils/misc.js").dispatchCustomEvent;
var AdapterHandle = require("../../base/adapterhandle.js");
var Base = require("../../xflow/base.js");

/**
 * The DataAdapter implements the
 * DataCollector concept and serves as basis of all DataAdapter classes. In
 * general, a DataAdapter is associated with an element node which uses
 * generic data and should be instantiated via
 * XML3DDataAdapterFactory to ensure proper functionality.
 *
 * @extends Adapter
 * @constructor
 *
 * @param factory
 * @param node
 */
var DataAdapter = function (factory, node) {
    BaseDataAdapter.call(this, factory, node);
    // Node handles for src and proto
    this.xflowDataNode = null;
    this.externalScripts = {};
};
XML3D.createClass(DataAdapter, BaseDataAdapter);

DataAdapter.prototype.init = function () {
    this.xflowDataNode = new DataNode(false);
    this.xflowDataNode.addLoadListener(this.onXflowLoadEvent.bind(this));
    this.xflowDataNode.userData = this.node;

    this.srcDataNode = new DataNode(false);
    this.xflowDataNode.appendChild(this.srcDataNode);

    // Setting platform and node type information for a data sequence
    this.xflowDataNode.setPlatform(this.node.getAttribute("platform"));

    this.updateAdapterHandle("src", this.node.getAttribute("src"));
    if(!this.assetData){
        this.xflowDataNode.setFilter(this.node.getAttribute("filter"));
        updateCompute(this);
    }
    recursiveDataAdapterConstruction(this);
};

DataAdapter.prototype.updateAdapterHandle = function(key, url) {
    var oldAdapterHandle = this.getConnectedAdapterHandle(key);

    var adapterHandle = this.getAdapterHandle(url),
        status = (adapterHandle && adapterHandle.status);

    if(oldAdapterHandle == adapterHandle)
        return;
    if (status === AdapterHandle.STATUS.NOT_FOUND) {
        XML3D.debug.logError("Could not find element of url '" + adapterHandle.url + "' for " + key, this.node);
    }
    this.connectAdapterHandle(key, adapterHandle);
    this.connectedAdapterChanged(key, adapterHandle ? adapterHandle.getAdapter() : null, status);
};

DataAdapter.prototype.onXflowLoadEvent = function(node, newLevel, oldLevel){
    if(newLevel == Infinity){
        dispatchCustomEvent(this.node, 'load', false, true, null);
    }
    else if(newLevel > oldLevel){
        dispatchCustomEvent(this.node, 'progress', false, true, null);
    }
};
DataAdapter.prototype.getDataComplete = function(){
    return this.xflowDataNode.getProgressLevel() == Infinity;
};
DataAdapter.prototype.getDataProgressLevel = function(){
    return this.xflowDataNode.getProgressLevel();
};

    /** Recursively passing platform information to children of a data node
     *  Requires that the children and the parents of data nodes are defined
     *
     * @param {DataNode} parentNode
     */
function recursiveDataNodeAttrInit(parentNode) {
    var children = parentNode._children, NChildren, i;

    if (children && children.length > 0) {
        NChildren = children.length;

        for (i = NChildren; i--;) {
            if (children[i] instanceof DataNode) {
                children[i].setPlatform(parentNode._platform);
                recursiveDataNodeAttrInit(children[i]);
            }
        }
    }
}

function recursiveDataAdapterConstruction(adapter) {
    for (var child = adapter.node.firstElementChild; child !== null; child = child.nextElementSibling) {
        var subadapter = adapter.factory.getAdapter(child);
        if (subadapter) {
            if (subadapter.getXflowNode) {
                adapter.xflowDataNode.appendChild(subadapter.getXflowNode());
            } else if (subadapter.getScriptType) {
                var scriptId = subadapter.node.name;
                if (!scriptId) {
                    XML3D.debug.logError("Parsing error: Externally referenced operators must have a 'name' attribute matching the name they were registered with. ", subadapter.node);
                    scriptId = "unknown_operator";
                }
                adapter.externalScripts[scriptId] = subadapter;
                if (subadapter.connectedAdapterHandle) {
                    adapter.connectAdapterHandle(scriptId, subadapter.connectedAdapterHandle);
                }
                adapter.xflowDataNode.setLoading(true);
            }
            // Passes _platform values to children nodes starting from the node
            // where these attributes are first defined
            if (adapter.xflowDataNode._platform !== null) {
                recursiveDataNodeAttrInit(adapter.xflowDataNode);
            }
        }
    }
}

/**
 * The notifyChanged() method is called by the XML3D data structure to
 * notify the DataAdapter about data changes (DOM mustation events) in its
 * associating node. When this method is called, all observers of the
 * DataAdapter are notified about data changes via their notifyDataChanged()
 * method.
 *
 * @param evt notification of type XML3D.Notification
 */
DataAdapter.prototype.notifyChanged = function (evt) {
    if (evt.type === Events.ADAPTER_HANDLE_CHANGED) {
        this.connectedAdapterChanged(evt.key, evt.adapter, evt.handleStatus);
        if (evt.handleStatus === AdapterHandle.STATUS.NOT_FOUND) {
            XML3D.debug.logError("Could not find <data> element of url '" + evt.url + "' for " + evt.key, this.node);
        }

    } else if (evt.type === Events.NODE_INSERTED) {
        var insertedNode = evt.affectedNode;
        var adapter = this.factory.getAdapter(insertedNode);
        if (!adapter) {
            return;
        }

        var insertedXflowNode = adapter.getXflowNode();
        var sibling = insertedNode, followUpAdapter = null;

        do {
            sibling = sibling.nextSibling;
        } while (sibling && !(followUpAdapter = this.factory.getAdapter(sibling)));

        if (followUpAdapter) {
            this.xflowDataNode.insertBefore(insertedXflowNode, followUpAdapter.getXflowNode());
        } else {
            this.xflowDataNode.appendChild(insertedXflowNode);
        }

    } else if (evt.type === Events.NODE_REMOVED) {
        var adapter = this.factory.getAdapter(evt.affectedNode);
        if (!adapter) {
            return;
        }

        var removedXflowNode = adapter.getXflowNode();
        this.xflowDataNode.removeChild(removedXflowNode);

    } else if (evt.type === Events.THIS_REMOVED) {
        this.clearAdapterHandles();
        this.xflowDataNode.clear();
        delete this.srcDataNode;
        delete this.node;
    }
};

DataAdapter.prototype.attributeChangedCallback = function (name, oldValue, newValue) {
    if (name === "filter" && !this.assetData) {
        this.xflowDataNode.setFilter(newValue);
    } else if (name === "compute" && !this.assetData) {
        updateCompute(this);
    } else if (name === "src") {
        this.updateAdapterHandle(name, newValue);
    } else if (name === "platform") {
        updatePlatform(this);
    }
};

DataAdapter.prototype.connectedAdapterChanged = function (key, adapter /*, status */) {
    if (key === "src") {
        this.srcDataNode.sourceNode = adapter ? adapter.getXflowNode() : null;
    } else if (key === "dataflow") {
        this.xflowDataNode.dataflowNode = adapter ? adapter.getXflowNode() : null;
    } else if (this.externalScripts[key]) {
        window.eval(adapter.script);
        this.xflowDataNode.notify(XC.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    }
    // Cycle the load state to force a load event even if the new sourceNode is cached
    this.xflowDataNode.setLoading(true);
    updateLoadState(this);
};

/**
 * Returns String representation of this DataAdapter
 */
DataAdapter.prototype.toString = function () {
    return "DataAdapter";
};

function updateCompute(dataAdapter) {
    var xflowNode = dataAdapter.xflowDataNode;
    xflowNode.setCompute(dataAdapter.node.getAttribute("compute"));
    if (xflowNode.computeDataflowUrl) {
        dataAdapter.updateAdapterHandle("dataflow", xflowNode.computeDataflowUrl);
    }
    else {
        dataAdapter.disconnectAdapterHandle("dataflow");
        updateLoadState(dataAdapter);
    }
}

function updatePlatform(dataAdapter) {
    var xflowNode = dataAdapter.xflowDataNode;

    xflowNode.setPlatform(dataAdapter.node.getAttribute("platform"));
    recursiveDataNodeAttrInit(xflowNode);
}

function updateLoadState(dataAdpater) {
    var loading = false, handle;

    handle = dataAdpater.getConnectedAdapterHandle("src");
    if (handle && handle.status === AdapterHandle.STATUS.LOADING) {
        loading = true;
    }

    handle = dataAdpater.getConnectedAdapterHandle("dataflow");
    if (handle && handle.status === AdapterHandle.STATUS.LOADING) {
        loading = true;
    }

    for (var name in dataAdpater.externalScripts) {
        handle = dataAdpater.getConnectedAdapterHandle(name);
        if (handle && handle.status === AdapterHandle.STATUS.LOADING) {
            loading = true;
        }
    }

    dataAdpater.xflowDataNode.setLoading(loading);
}


module.exports = DataAdapter;



},{"../../base/adapterhandle.js":49,"../../interface/notification.js":74,"../../utils/misc.js":182,"../../xflow/base.js":186,"../../xflow/interface/constants.js":187,"../../xflow/interface/graph.js":189,"./base.js":54}],57:[function(require,module,exports){
var BaseDataAdapter = require("./base.js");
var DataNode = require("../../xflow/interface/graph.js").DataNode;
var XC = require("../../xflow/interface/constants.js");
var Events = require("../../interface/notification.js");
var AdapterHandle = require("../../base/adapterhandle.js");
var Base = require("../../xflow/base.js");

/**
 * DataAdapter handling a <dataflow> element
 * @param factory
 * @param node
 * @constructor
 */
var DataflowDataAdapter = function (factory, node) {
    BaseDataAdapter.call(this, factory, node);
    this.xflowDataNode = null;
    this.externalScripts = {};
};
XML3D.createClass(DataflowDataAdapter, BaseDataAdapter);

DataflowDataAdapter.prototype.init = function () {
    this.xflowDataNode = new DataNode(false);
    this.dataflowRefs = [];
    updateDataflowXflowNode(this, this.node);
};

DataflowDataAdapter.prototype.updateAdapterHandle = function(key, url) {
    var oldAdapterHandle = this.getConnectedAdapterHandle(key);

    var adapterHandle = this.getAdapterHandle(url),
        status = (adapterHandle && adapterHandle.status);

    if(oldAdapterHandle == adapterHandle)
        return;
    if (status === AdapterHandle.STATUS.NOT_FOUND) {
        XML3D.debug.logError("Could not find element of url '" + adapterHandle.url + "' for " + key, this.node);
    }
    this.connectAdapterHandle(key, adapterHandle);
    this.connectedAdapterChanged(key, adapterHandle ? adapterHandle.getAdapter() : null, status);
};


/**
 * @param evt notification of type XML3D.Notification
 */
DataflowDataAdapter.prototype.notifyChanged = function (evt) {
    if (evt.type === Events.ADAPTER_HANDLE_CHANGED) {
        //TODO: Handle ADAPTER_HANDLE_CHANGED
        if (this.externalScripts[evt.key]) {
            window.eval(evt.adapter.script);
            setLoadingStateForMatchingXflowNodes(this.xflowDataNode, evt.key, false);
            this.xflowDataNode.notify(XC.RESULT_STATE.CHANGED_STRUCTURE);
            Base._flushResultCallbacks();
        }
    }

    switch (evt.type) {
        case Events.ADAPTER_HANDLE_CHANGED:
            this.connectedAdapterChanged(evt.key, evt.adapter, evt.handleStatus);
            if (evt.handleStatus === AdapterHandle.STATUS.NOT_FOUND) {
                XML3D.debug.logError("Could not find dataflow of url '" + evt.url, this.node);
            }
            break;

        case Events.NODE_INSERTED:
        case Events.NODE_REMOVED:
            updateDataflowXflowNode(this);
            break;

        case Events.VALUE_MODIFIED:
            var attr = evt.mutation.attributeName;
            if (attr === "out") {
                updateDataflowOut(this);
            } else if (attr === "platform") {
                updateDataflowXflowNode(this, this.node);
            }
            break;
    }
};

/**
 * Traverse all subnodes of a dataflow and set the loading state of
 * all nodes with a compute operator that relies on the matching external script name.
 * A compute node will only be executed if its loading state is 'false' and none of its children are 'loading', so
 * this ensures we don't do the compute operations until the external operators have been loaded.
 * @param {DataNode} node the current node to check for instances of the given operator
 * @param {string} name the name of the external operator to check for
 * @param {boolean} loading whether the operator has finished loading or not
 */
function setLoadingStateForMatchingXflowNodes(node, name, loading) {
    if (node._computeOperator === name) {
        node.setLoading(loading);
    }
    if (node._children) {
        var i = node._children.length;
        while (i--) {
            setLoadingStateForMatchingXflowNodes(node._children[i], name, loading);
        }
    }
}

DataflowDataAdapter.prototype.updateXflowNode = function () {
    updateDataflowXflowNode(this, this.node);
};

DataflowDataAdapter.prototype.connectedAdapterChanged = function (key, adapter, status) {
    var xflowNode = this.dataflowRefs[key];
    if (xflowNode) {
        xflowNode.dataflowNode = adapter ? adapter.getXflowNode() : null;
        xflowNode.setLoading(status === AdapterHandle.STATUS.LOADING);
    }
};

function updateDataflowOut(adapter) {
    var out = adapter.node.getAttribute("out");
    if (out) {
        adapter.xflowDataNode.setFilter("keep(" + out + ")");
    } else {
        adapter.xflowDataNode.setFilter("");
    }
}

function updateDataflowXflowNode(adapter, node) {
    // Getting platform and node type information for a Dataflow node
    var platform = node.getAttribute("platform");

    adapter.xflowDataNode.setCompute("");
    adapter.clearAdapterHandles();
    adapter.dataflowRefs = [];
    adapter.externalScripts = {};
    updateDataflowOut(adapter);

    var child = node.lastElementChild, firstNode = true, prevNode = null, currentNode = adapter.xflowDataNode, subAdapter, xflowNode;

    do {
        subAdapter = adapter.factory.getAdapter(child);
        if (!subAdapter) {
            continue;
        }

        if (subAdapter.getXflowNode) {
            xflowNode = subAdapter.getXflowNode();

            if (prevNode) {
                currentNode.insertBefore(xflowNode, prevNode);
            } else {
                currentNode.appendChild(xflowNode);
            }
            prevNode = xflowNode;
        } else if (subAdapter.getComputeCode) {
            var statements = subAdapter.getComputeCode().split(";");
            var j = statements.length;

            while (j--) {
                var compute = statements[j].trim();
                if (!compute) {
                    continue;
                }

                if (firstNode) {
                    firstNode = false;
                } else {
                    xflowNode = new DataNode(false);
                    if (prevNode) {
                        currentNode.insertBefore(xflowNode, prevNode);
                    } else {
                        currentNode.appendChild(xflowNode);
                    }
                    currentNode = xflowNode;
                    prevNode = null;
                }
                currentNode.userData = child;

                currentNode.setPlatform(platform);

                currentNode.setCompute(statements[j].trim());

                if (currentNode.computeDataflowUrl) {
                    var idx = adapter.dataflowRefs.length;
                    adapter.dataflowRefs.push(currentNode);
                    adapter.updateAdapterHandle(idx, currentNode.computeDataflowUrl);
                }
            }
        } else if (subAdapter.getScriptType) {
            var scriptId = subAdapter.node.name;
            if (!scriptId) {
                XML3D.debug.logError("Parsing error: Externally referenced operators must have a 'name' attribute matching the name they were registered with. ", subAdapter.node);
                scriptId = "unknown_operator";
            }
            adapter.externalScripts[scriptId] = subAdapter;
            if (subAdapter.connectedAdapterHandle) {
                adapter.connectAdapterHandle(scriptId, subAdapter.connectedAdapterHandle);
            }
        }

    } while (child = child.previousElementSibling);

    for (var name in adapter.externalScripts) {
        // Ensure XFlow doesn't execute any compute nodes that depend on external scripts until they're loaded
        setLoadingStateForMatchingXflowNodes(adapter.xflowDataNode, name, true);
    }
}


module.exports = DataflowDataAdapter;

},{"../../base/adapterhandle.js":49,"../../interface/notification.js":74,"../../xflow/base.js":186,"../../xflow/interface/constants.js":187,"../../xflow/interface/graph.js":189,"./base.js":54}],58:[function(require,module,exports){
var NodeAdapterFactory = require("../../base/adapter.js").NodeAdapterFactory;
var Asset = require("./asset.js");
var Misc = require("./misc.js");
var ScriptDataAdapter = require("./script.js");
var TextureDataAdapter = require("./texture.js");
var TransformDataAdapter = require("./transform.js");
var ValueDataAdapter = require("./values.js");
var DataAdapter = require("./data.js");
var ComputeDataAdapter = require("./compute.js");
var DataflowDataAdapter = require("./dataflow.js");
// Register JSON Handler
require("./json/factory.js");
// Register JavaScript Handler (required for external shade.js Javascript resources)
require("./javascript/factory.js");

/**
 * Constructor of XML3DDataAdapterFactory
 * XML3DDataAdapterFactory creates DataAdapter instances for elements using generic data (<mesh>, <data>, <float>,...).
 * Additionally, it manages all DataAdapter instances so that for each node there is always just one DataAdapter. When
 * it creates a DataAdapter, it calls its init method.
 *
 * @constructor
 * @extends AdapterFactory
 */

var XML3DDataAdapterFactory = function () {
    NodeAdapterFactory.call(this, "data");
};
XML3D.createClass(XML3DDataAdapterFactory, NodeAdapterFactory);

var reg = {
    'mesh': Misc.SinkDataAdapter,
    'material': Misc.SinkDataAdapter,
    'shader': Misc.SinkDataAdapter, // TODO(ksons): Remove in 5.1
    'light': Misc.SinkDataAdapter,
    'view': Misc.SinkDataAdapter,
    'float': ValueDataAdapter,
    'float2': ValueDataAdapter,
    'float3': ValueDataAdapter,
    'float4': ValueDataAdapter,
    'float4x4': ValueDataAdapter,
    'int': ValueDataAdapter,
    'int4': ValueDataAdapter,
    'bool': ValueDataAdapter,
    'byte': ValueDataAdapter,
    'string': ValueDataAdapter,
    'ubyte': ValueDataAdapter,
    'img': Misc.ImgDataAdapter,
    'texture': TextureDataAdapter,
    'data': DataAdapter,
    'proto': DataAdapter,
    'dataflow': DataflowDataAdapter,
    'compute': ComputeDataAdapter,
    'video': Misc.VideoDataAdapter,
    'script': ScriptDataAdapter,
    'transform': TransformDataAdapter,
    'asset': Asset.AssetAdapter,
    'assetdata': Asset.AssetDataAdapter,
    'assetmesh': Asset.AssetMeshAdapter,
    'model': Asset.AssetAdapter
};

/**
 * Creates a DataAdapter associated with the given node.
 *
 * @param node
 *            element node which uses generic data. The supported elements
 *            are listed in the class description above.
 * @returns DataAdapter instance
 */
XML3DDataAdapterFactory.prototype.createAdapter = function (node) {
    //XML3D.debug.logDebug("Creating adapter: " + node.localName);
    var adapterContructor = reg[node.localName];
    if (adapterContructor !== undefined) {
        return new adapterContructor(this, node);
    }
    XML3D.debug.logWarning("Not supported as data element: " + node.localName);
    return null;
};

module.exports =  XML3DDataAdapterFactory;

},{"../../base/adapter.js":48,"./asset.js":53,"./compute.js":55,"./data.js":56,"./dataflow.js":57,"./javascript/factory.js":59,"./json/factory.js":60,"./misc.js":61,"./script.js":62,"./texture.js":63,"./transform.js":64,"./values.js":65}],59:[function(require,module,exports){

var JavaScriptFormatHandler = function () {
    XML3D.resource.FormatHandler.call(this);
};
XML3D.createClass(JavaScriptFormatHandler, XML3D.resource.FormatHandler);

JavaScriptFormatHandler.prototype.isFormatSupported = function (response) {
    var contentType = response.headers.get("Content-Type");
    return !!contentType && contentType.match(/\/javascript/);
};


JavaScriptFormatHandler.prototype.getFormatData = function (response) {
    return response.text();
};

JavaScriptFormatHandler.prototype.getAdapter = function(xflowNode, aspect, canvasId) {
    if (aspect === "data") {
        return new ScriptDataAdapter(xflowNode);
    }
    throw new Error("Unsupported aspect '"+aspect+"' encountered in JavaScript format handler.");
};

XML3D.resource.registerFormatHandler(new JavaScriptFormatHandler());


var ScriptDataAdapter = function (script) {
    this.script = script;
};

ScriptDataAdapter.prototype.getScriptType = function () {
    return "application/javascript";
};

ScriptDataAdapter.prototype.getScript= function () {
    return this.script;
};

},{}],60:[function(require,module,exports){
var XC = require("../../../xflow/interface/constants.js");
var InputNode = require("../../../xflow/interface/graph.js").InputNode;
var DataNode = require("../../../xflow/interface/graph.js").DataNode;
var BufferEntry = require("../../../xflow/interface/data.js").BufferEntry;
var AdapterFactory = require("../../../base/adapter.js").AdapterFactory;

var XML3DJSONFormatHandler = function() {
    XML3D.resource.FormatHandler.call(this);
};
XML3D.createClass(XML3DJSONFormatHandler, XML3D.resource.FormatHandler);

XML3DJSONFormatHandler.prototype.isFormatSupported = function(response) {
    if (response.headers.has("Content-Type")) {
        var contentType = response.headers.get("Content-Type");
        return contentType.match(/\/json/);
    }
    if (response.url.match(/\.json/)) {
        return true;
    }
};


XML3DJSONFormatHandler.prototype.getFormatData = function(response) {
    return response.json().then(function(json) {
        if (json.format != "xml3d-json")
            throw new Error("Unknown JSON format: " + json.format);
        if (json.version != "0.4.0")
          throw new Error("Unknown JSON version: " + json.version);

        return json;
    });
};

XML3DJSONFormatHandler.prototype.getAdapter = function(data, aspect, canvasId) {
    if (aspect === "data" || aspect === "scene") {
        return new JSONDataAdapter(createXflowNode(data, aspect));
    }
    throw new Error("Unsupported aspect '"+aspect+"' encountered in JSON format handler.");
};

XML3D.resource.registerFormatHandler(new XML3DJSONFormatHandler());


var empty = function() {};

var TYPED_ARRAY_MAP = {
    "int" : Int32Array,
    "int4" : Int32Array,
    "float" : Float32Array,
    "float2" : Float32Array,
    "float3" : Float32Array,
    "float4" : Float32Array,
    "float4x4" : Float32Array,
    "bool" : Uint8Array,
    "byte" : Int8Array,
    "ubyte" : Uint8Array,
    "string": Array
};

var isLittleEndian = (function () {
    var buf = new ArrayBuffer(4);
    var dv = new DataView(buf);
    var view = new Int32Array(buf);
    view[0] = 0x01020304;
    var littleEndian = (dv.getInt32(0, true) === 0x01020304);
    return function () { return littleEndian; }
})();

function realTypeOf(obj) {
    return Object.prototype.toString.call(obj).slice(8, -1);
}

function createXflowValue(dataNode, dataType, name, key, value) {
    var v = new (TYPED_ARRAY_MAP[dataType])(value);
    var type = XC.DATA_TYPE.fromString(dataType);
    var buffer = new BufferEntry(type, v);

    var inputNode = new InputNode();
    inputNode.data = buffer;
    inputNode.name = name;
    inputNode.key = key;
    dataNode.appendChild(inputNode);
}

function createXflowValueFromBuffer(dataNode, dataType, name, key, arrayBuffer, byteOffset, byteLength) {
    var ArrayType = TYPED_ARRAY_MAP[dataType];
    var v = new (ArrayType)(arrayBuffer, byteOffset, byteLength/ArrayType.BYTES_PER_ELEMENT);
    var type = XC.DATA_TYPE.fromString(dataType);
    var buffer = new BufferEntry(type, v);

    var inputNode = new InputNode();
    inputNode.data = buffer;
    inputNode.name = name;
    inputNode.key = key;
    dataNode.appendChild(inputNode);
}

function createXflowInputs(dataNode, name, jsonData){
    var v = null;

    if (!TYPED_ARRAY_MAP[jsonData.type])
        return;

    for(var i = 0; i < jsonData.seq.length; ++i) {
        var entry = jsonData.seq[i];
        var value = entry.value;
        var key = entry.key;

        if (realTypeOf(value) === 'Object' && value.url) {
            if (!isLittleEndian()) {
                // FIXME add big-endian -> little-endian conversion
                throw new Error("Big-endian binary data are not supported yet");
            }
            XML3D.resource.fetch(value.url)
                .then(function (response) {
                    return response.arrayBuffer();
                }).then(function(arrayBuffer) {
                    createXflowValueFromBuffer(dataNode, jsonData.type, name, key, arrayBuffer, value.byteOffset, value.byteLength);
                });
        } else {
            createXflowValue(dataNode, jsonData.type, name, key, value);
        }
    }
}

function createXflowNode(jsonData, aspect){

    var node = new DataNode(false);
    node.userData = "External Json"; // TODO: Try to add document URL here (how to get it?)

    var entries;
    if (aspect === "scene")
        entries = jsonData.material;
    else
        entries = jsonData.data;

    for(var name in entries) {
        createXflowInputs(node, name, entries[name]);
    }
    return node;
}

/**
 * @implements IDataAdapter
 */
var JSONDataAdapter = function(xflowNode) {
    this.xflowDataNode = xflowNode;
};

JSONDataAdapter.prototype.getXflowNode = function(){
    return this.xflowDataNode;
};

},{"../../../base/adapter.js":48,"../../../xflow/interface/constants.js":187,"../../../xflow/interface/data.js":188,"../../../xflow/interface/graph.js":189}],61:[function(require,module,exports){
var DataAdapter = require("./data.js");
var Events = require("../../interface/notification.js");
var URI = require("../../utils/uri.js").URI;
var Util = require("../../utils/misc.js");
var Resource = require("../../resource/coordinator.js");

var NodeAdapter = require("../../base/adapter.js").NodeAdapter;
var createClass = XML3D.createClass;

/**
 * SinkDataAdapter represents the sink in the data hierarchy (no parents).
 * @constructor
 * @extends {DataAdapter}
 * @param factory
 * @param node
 */
var SinkDataAdapter = function(factory, node) {
    DataAdapter.call(this, factory, node);
};
createClass(SinkDataAdapter, DataAdapter, {

    /**
     * Indicates whether this DataAdapter is a SinkAdapter (has no parent
     * DataAdapter).
     *
     * @returns true if this DataAdapter is a SinkAdapter, otherwise false.
     */
    isSinkAdapter: function () {
        return true;
    },

    /**
     * Returns String representation of this DataAdapter
     */
    toString: function () {
        return "XML3D.data.SinkDataAdapter";
    }
});


    var ImgDataAdapter = function(factory, node) {
        NodeAdapter.call(this, factory, node);
        this.textureEntry = null;
        this.image = null;
        if (node.src)
            this.createImageFromURL(node.src);
    };
    createClass(ImgDataAdapter, NodeAdapter, {

        /**
         * Creates a new image object
         *
         * @param {string} url
         */
        createImageFromURL: function (url) {
            var that = this;
            var uri = new URI(url).getAbsoluteURI(this.node.ownerDocument._documentURL || this.node.ownerDocument.URL);
            var onload = function (e, image) {
                if (that.textureEntry) {
                    that.textureEntry.setImage(image, true);
                }
            };
            var onerror = function (e, image) {
                XML3D.debug.logError("Could not load image URI=" + image.src);
            };
            this.image = Resource.getImage(uri, onload, onerror);
            if (that.textureEntry) {
                that.textureEntry.setImage(this.image, true);
            }
        },

        /**
         * @param {Xflow.TextureEntry} entry
         */
        setTextureEntry: function (entry) {
            this.textureEntry = entry;
            if (this.image) {
                this.textureEntry.setImage(this.image, true);
            }
        },

        attributeChangedCallback: function (name, oldValue, newValue) {
            if (name == "src") {
                this.createImageFromURL(newValue);
            }
        },

        notifyChanged: function (evt) {
        },

        getValue: function (cb, obj) {
            return this.image;
        },

        getOutputs: function () {
            var result = {};
            result['image'] = this;
            return result;
        },

        resolveScript: function () {
            return null;
        }
    });

    var VideoDataAdapter = function(factory, node) {
        DataAdapter.call(this, factory, node);
        this.textureEntry = null;
        this.video = null;
        this._ticking = false;
        this._boundTick = this._tick.bind(this);
        if (node.src)
            this.createVideoFromURL(node.src);
    };
    createClass(VideoDataAdapter, NodeAdapter);

    /**
     * Creates a new video object
     *
     * @param {string} url
     */
    VideoDataAdapter.prototype.createVideoFromURL = function(url) {
        var that = this;
        var uri = new URI(url).getAbsoluteURI(this.node.ownerDocument._documentURL || this.node.ownerDocument.URL);
        this.video = Resource.getVideo(uri, this.node.autoplay, this.node.loop, this.node.muted,
            {
                canplay : function(event, video) {
                    Util.dispatchCustomEvent(that.node, 'canplay', true, true, null);
                    that._startVideoRefresh();
                },
                ended : function(event, video) {
                    Util.dispatchCustomEvent(that.node, 'ended', true, true, null);
                },
                load : function(event, video) {
                    Util.dispatchEvent(that.node, 'load');
                },
                error : function(event, video) {
                    Util.dispatchCustomEvent(that.node, 'error', true, true, null);
                    XML3D.debug.logError("Could not load video URI="+video.src);
                }
            }
        );
        if (this.textureEntry)
            this.textureEntry.setImage(this.video, true);
    };

    VideoDataAdapter.prototype.play = function() {
        if (this.video)
            this.video.play();
    };

    VideoDataAdapter.prototype.pause = function() {
        if (this.video)
            this.video.pause();
    };

    VideoDataAdapter.prototype._startVideoRefresh = function() {
        if (!this._ticking)
            this._tick();
    };

    VideoDataAdapter.prototype._tick = function() {
        this._ticking = true;
        window.requestAnimationFrame(this._boundTick);
        // FIXME Do this only when currentTime is changed (what about webcam ?)
        if (this.textureEntry) {
            this.textureEntry.setImage(this.video);
        }
    };

    /**
     * @param {Xflow.TextureEntry} entry
     */
    VideoDataAdapter.prototype.setTextureEntry = function(entry) {
        this.textureEntry = entry;
        if (this.video) {
            this.textureEntry.setImage(this.video, true);
        }
    };

    VideoDataAdapter.prototype.notifyChanged = function(evt) {
    };

    VideoDataAdapter.prototype.attributeChangedCallback = function (name, oldValue, newValue) {
        if (name == "src") {
            this.createVideoFromURL(newValue);
        }
    };

    VideoDataAdapter.prototype.getValue = function(cb, obj) {
        return this.video;
    };

    VideoDataAdapter.prototype.getOutputs = function() {
        var result = {};
        result['video'] = this;
        return result;
    };

    // Export
    module.exports = {
        ImgDataAdapter: ImgDataAdapter,
        VideoDataAdapter: VideoDataAdapter,
        SinkDataAdapter: SinkDataAdapter
    };


},{"../../base/adapter.js":48,"../../interface/notification.js":74,"../../resource/coordinator.js":161,"../../utils/misc.js":182,"../../utils/uri.js":184,"./data.js":56}],62:[function(require,module,exports){
var Events = require("../../interface/notification.js");
var createClass = XML3D.createClass;
var NodeAdapter = require("../../base/adapter.js").NodeAdapter;

var ScriptDataAdapter = function(factory, node) {
    NodeAdapter.call(this, factory, node);
    this.connectedAdapterHandle = null;
    if (node.src) {
        this.connectedAdapterHandle = this.getAdapterHandle(node.src);
        this.connectAdapterHandle(node.name, this.connectedAdapterHandle);
    }
};

createClass(ScriptDataAdapter, NodeAdapter, {

    getScriptType: function () {
        return this.node.type;
    },

    getScript: function () {
        if (this.node.src) {
            return this.externalScript;
        } else {
            return this.node.value;
        }
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        this.notifyOppositeAdapters();
    },

    notifyChanged: function (evt) {
        switch (evt.type) {
            case Events.NODE_INSERTED:
            case Events.NODE_REMOVED:
            case Events.VALUE_MODIFIED:
                this.notifyOppositeAdapters();
                break;

            case Events.ADAPTER_HANDLE_CHANGED:
                this.externalScript = evt.adapter.script;
                this.notifyOppositeAdapters();
                break;
        }
    }
});

module.exports = ScriptDataAdapter;

},{"../../base/adapter.js":48,"../../interface/notification.js":74}],63:[function(require,module,exports){
var TextureEntry = require("../../xflow/interface/data.js").TextureEntry;
var InputNode = require("../../xflow/interface/graph.js").InputNode;
var XC = require("../../xflow/interface/constants.js");
var Events = require("../../interface/notification.js");
var NodeAdapter = require("../../base/adapter.js").NodeAdapter;
var GL = require("../../renderer/webgl/constants.js");

var defaults = require('lodash.defaults');
var assign = require('lodash.assign');


var TextureDataAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
};

XML3D.createClass(TextureDataAdapter, NodeAdapter, {

    init: function () {
        this.xflowInputNode = this.createXflowNode();
        this.xflowInputNode.data = this.createTextureEntry();
    },

    createTextureEntry: function () {
        var node = this.node;
        var entry = new TextureEntry(null);
        initTextureSamplingParameters(entry.getSamplerConfig(), node.getAttribute("wrap"), node.getAttribute("filter"), node.getAttribute("anisotropy"));

        var imageAdapter = this.factory.getAdapter(this.node.firstElementChild);
        if (imageAdapter) {
            imageAdapter.setTextureEntry(entry);
        }
        return entry;
    },

    shouldGenerateMipMaps: shouldGenerateMipMaps,

    /**
     *
     * @returns {InputNode}
     */
    createXflowNode: function () {
        var xnode = new InputNode();
        xnode.name = this.node.name;
        xnode.paramName = this.node.param ? this.node.name : null;
        xnode.key = this.node.key;
        return xnode;
    },

    setScriptValue: function () {
        XML3D.debug.logError("Texture currently does not support setScriptValue()");
    },

    getOutputs: function () {
        var result = {};
        result[this.node.name] = this;
        return result;
    },

    getValue: function () {
        return this.value;
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        switch (name) {
            case "name":
                this.xflowInputNode.name = newValue;
                break;
            case "param":
                this.xflowInputNode.paramName = newValue ? this.node.name : null;
                break;
            case "key":
                this.xflowInputNode.key = newValue;
                break;
            case "wrap":
            case "filter":
            case "samples":
                this.xflowInputNode.data = this.createTextureEntry();
                break;
        }
    },

    notifyChanged: function () { /* Nothing to do */
    },

    /**
     * @return {Element}
     */
    getXflowNode: function () {
        return this.xflowInputNode;
    }

});

var wrapToGL = {
    "clamp":  GL.CLAMP_TO_EDGE,
    "repeat": GL.REPEAT
};

var filterToGL = {
    "nearest": GL.NEAREST,
    "linear": GL.LINEAR,
    "nearest-mipmap-nearest": GL.NEAREST_MIPMAP_NEAREST,
    "linear-mipmap-nearest": GL.LINEAR_MIPMAP_NEAREST,
    "nearest-mipmap-linear": GL.NEAREST_MIPMAP_LINEAR,
    "linear-mipmap-linear": GL.LINEAR_MIPMAP_LINEAR
};

function shouldGenerateMipMaps(minFilter, magFilter) {
    return (minFilter != GL.NEAREST && minFilter != GL.LINEAR) || (magFilter != GL.NEAREST && magFilter != GL.LINEAR);
}

function parseTextureSamplingParameters(wrap, filter, anisotropy) {
    var result = {}, args;

    if(wrap) {
        args = wrap.split(/(\s+)/);
        result.wrapS = wrapToGL[args[0]];
        result.wrapT = wrapToGL[args[args.length - 1]];
    }

    if(filter) {
        args = filter.split(/(\s+)/);
        result.minFilter = filterToGL[args[0]];
        result.magFilter = filterToGL[args[args.length - 1]];
    }

    if(anisotropy) {
        var number = parseFloat(anisotropy);
        if (isNaN(number)) {
            number = anisotropy == "max" ? Infinity : undefined
        } else {
            number = Math.min(1.0, number)
        }
        result.anisotropy = number;
    }

    return result;
}

function initTextureSamplingParameters(config, wrap, filter, samples) {
    var params = parseTextureSamplingParameters(wrap, filter, samples);
    defaults(params, {
        wrapS: GL.CLAMP_TO_EDGE,
        wrapT: GL.CLAMP_TO_EDGE,
        minFilter: GL.LINEAR_MIPMAP_LINEAR,
        magFilter: GL.LINEAR,
        textureType: XC.TEX_TYPE.TEXTURE_2D,
        anisotropy: 1
    });
    assign(config, params);
    config.generateMipMap = shouldGenerateMipMaps(config.minFilter, config.magFilter);
}

// Export
module.exports = TextureDataAdapter;

},{"../../base/adapter.js":48,"../../interface/notification.js":74,"../../renderer/webgl/constants.js":120,"../../xflow/interface/constants.js":187,"../../xflow/interface/data.js":188,"../../xflow/interface/graph.js":189,"lodash.assign":17,"lodash.defaults":41}],64:[function(require,module,exports){
var Events = require("../../interface/notification.js");
var NodeAdapter = require("../../base/adapter.js").NodeAdapter;
var mat4 = require("gl-matrix").mat4;
var vec3 = require("gl-matrix").vec3;

var TransformDataAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
    this.isValid = true;
    this.needsUpdate = true;
};

XML3D.createClass(TransformDataAdapter, NodeAdapter);

var IDENT_MAT = mat4.create();

TransformDataAdapter.prototype.init = function () {
    // Create all matrices, no valid values yet
    this.matrix = mat4.create();
    this.transform = {
        translate: mat4.create(),
        scale: mat4.create(),
        scaleOrientation: mat4.create(),
        scaleOrientationInv: mat4.create(),
        center: mat4.create(),
        centerInverse: mat4.create(),
        rotation: mat4.create()
    };
    this.needsUpdate = true;
    this.checkForImproperNesting();
};

TransformDataAdapter.prototype.updateMatrix = function () {
    var n = this.node;
    var transform = this.transform;
    var centerVec = n.center.data;
    var so = n.scaleOrientation.data;
    var ro = n.rotation.data;

    mat4.fromRotation(transform.scaleOrientation, so[3], so);
    mat4.fromRotation(transform.rotation, ro[3], ro);

    mat4.translate(transform.translate, IDENT_MAT, n.translation.data);
    mat4.translate(transform.center, IDENT_MAT, centerVec);
    mat4.translate(transform.centerInverse, IDENT_MAT, vec3.negate(centerVec, centerVec));
    mat4.scale(transform.scale, IDENT_MAT, n.scale.data);
    mat4.invert(transform.scaleOrientationInv, transform.scaleOrientation);

    multiplyComponents(transform, this.matrix);
    this.needsUpdate = false;
};

function multiplyComponents(transform, matrix) {
    // M = T * C
    mat4.multiply(matrix, transform.translate, transform.center);
    // M = T * C * R
    mat4.multiply(matrix, matrix, transform.rotation);
    // M = T * C * R * SO
    mat4.multiply(matrix, matrix, transform.scaleOrientation);
    // M = T * C * R * SO * S
    mat4.multiply(matrix, matrix, transform.scale);
    // M = T * C * R * SO * S * -SO
    mat4.multiply(matrix, matrix, transform.scaleOrientationInv);
    // M = T * C * R * SO * S * -SO * -C
    mat4.multiply(matrix, matrix, transform.centerInverse);
}

TransformDataAdapter.prototype.getMatrix = function () {
    this.needsUpdate && this.updateMatrix();
    return this.matrix;
};

TransformDataAdapter.prototype.attributeChangedCallback = function (name, oldValue, newValue) {
   this.needsUpdate = true;
   this.notifyOppositeAdapters(Events.ADAPTER_VALUE_CHANGED);
};

TransformDataAdapter.prototype.notifyChanged = function (e) {
    if (e.type == Events.NODE_REMOVED) {
        this.dispose();
        this.notifyOppositeAdapters(Events.ADAPTER_HANDLE_CHANGED);
    }
};
TransformDataAdapter.prototype.dispose = function () {
    this.isValid = false;
};

TransformDataAdapter.prototype.checkForImproperNesting = function () {
    for (var i = 0; i < this.node.childNodes.length; i++) {
        if (this.node.childNodes[i].localName === "transform") {
            XML3D.debug.logError("Parsing error: Transform elements cannot be nested!", this.node);
        }
    }
};

// Export to XML3D.data namespace
module.exports = TransformDataAdapter;




},{"../../base/adapter.js":48,"../../interface/notification.js":74,"gl-matrix":1}],65:[function(require,module,exports){
var BufferEntry = require("../../xflow/interface/data.js").BufferEntry;
var InputNode = require("../../xflow/interface/graph.js").InputNode;
var XC = require("../../xflow/interface/constants.js");
var Events = require("../../interface/notification.js");
var NodeAdapter = require("../../base/adapter.js").NodeAdapter;

/**
 * Constructor of XML3D.data.ValueDataAdapter
 *
 * @extends XML3D.data.DataAdapter
 * @constructor
 *
 * @param factory
 * @param {Element} node
 */
var ValueDataAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
    this.xflowInputNode = null;
    this.type = XC.DATA_TYPE.fromString(node.localName);
};
XML3D.createClass(ValueDataAdapter, NodeAdapter);

ValueDataAdapter.prototype.init = function()
{
    var config = this.node._configured, value;
    if(this.node.textContent == "[value set by script]"){
        value = config.scriptValue;
    }
    else{
        delete config.scriptValue;
        value = this.node.value;
    }

    if (this.type === XC.DATA_TYPE.STRING) {
        value = value ? value.split(",") : [];
    }
    var buffer = new BufferEntry(this.type, value);

    this.xflowInputNode = new InputNode(null);
    this.xflowInputNode.name = this.node.name;
    this.xflowInputNode.data = buffer;
    this.xflowInputNode.key = this.node.key;
    this.xflowInputNode.paramName = this.node.param ? this.node.name : null;
    this.checkForImproperNesting();
};

ValueDataAdapter.prototype.getXflowNode = function () {
    return this.xflowInputNode;
};

/**
 *
 */
ValueDataAdapter.prototype.notifyChanged = function (evt) {
    if (evt.type == Events.VALUE_MODIFIED) {
        var attr = evt.mutation.attributeName;
        if (!attr) {
            delete this.node._configured.scriptValue;
            var value = this.node.value;
            if (this.type === XC.DATA_TYPE.STRING) {
                value = value ? value.split(",") : [];
            }
            this.xflowInputNode.data.setValue(value);
        }
    }
};

ValueDataAdapter.prototype.attributeChangedCallback = function (name, oldValue, newValue) {
    if (name == "name") {
        this.xflowInputNode.name = newValue;
    } else if (name == "key") {
        this.xflowInputNode.key = newValue;
    } else if (name == "param") {
        this.xflowInputNode.paramName = newValue ? this.node.name : null;
    }
};


ValueDataAdapter.prototype.setScriptValue = function (value) {
    // TODO: Add Type check
    if (this.type === XC.DATA_TYPE.STRING) {
        value = value ? value.split(",") : [];
    }
    this.xflowInputNode.data.setValue(value);
};

/**
 * Returns String representation of this DataAdapter
 */
ValueDataAdapter.prototype.toString = function () {
    return "XML3D.data.ValueDataAdapter";
};

ValueDataAdapter.prototype.checkForImproperNesting = function() {
    for (var i=0; i < this.node.childNodes.length; i++) {
        if (XC.DATA_TYPE.fromString(this.node.childNodes[i].localName)) {
            XML3D.debug.logError("Parsing error: Value elements cannot be nested!", this.node);
        }
    }
};

// Export
module.exports = ValueDataAdapter;

},{"../../base/adapter.js":48,"../../interface/notification.js":74,"../../xflow/interface/constants.js":187,"../../xflow/interface/data.js":188,"../../xflow/interface/graph.js":189}],66:[function(require,module,exports){
var ComputeRequest = require("../xflow/interface/request.js").ComputeRequest;
var Events = require("../interface/notification.js");
var CSS = require("../utils/css.js");
var mat4 = require("gl-matrix").mat4;

var DOMTransformFetcher = function (owner, attrName, dataName, onlyDataTransform) {
    this.owner = owner;
    this.node = owner.node;
    this.attrName = attrName;
    this.dataName = dataName;
    this.adapterHandle = null;
    this.xflowRequest = null;
    this.onlyDataTransform = onlyDataTransform || false;
    this._bindedCallback = this._onChange.bind(this);
};
DOMTransformFetcher.prototype.clear = function () {
    this.xflowRequest && this.xflowRequest.clear();
    this.xflowRequest = null;
    this.adapterHandle && this.adapterHandle.removeListener(this._bindedCallback);
};

DOMTransformFetcher.prototype.dispose = function() {
    this.clear();
    delete this.owner;
    delete this.node;
};

DOMTransformFetcher.prototype.update = function () {
    var newHandle = this.owner.getAdapterHandle(this.node.getAttribute(this.attrName), "data", 0);
    if (newHandle != this.adapterHandle) {
        this.clear();
        this.adapterHandle = newHandle;
        if (newHandle)
            newHandle.addListener(this._bindedCallback)
    }
    this.updateMatrix();
};

DOMTransformFetcher.prototype.updateMatrix = function () {
    this.owner.onTransformChange(this.attrName, this.getMatrix());
};

DOMTransformFetcher.prototype.getMatrix = ( function () {
    var IDENTITY = mat4.create();

    return function () {
        if (!this.onlyDataTransform) {
            var cssMatrix = CSS.getCSSMatrix(this.node);
            if (cssMatrix) {
                return CSS.convertCssToMat4(cssMatrix).data;
            }
        }
        var adapter;
        if (this.adapterHandle && (adapter = this.adapterHandle.getAdapter())) {
            if (adapter.getXflowNode) {
                if (!this.xflowRequest)
                    this.xflowRequest = new ComputeRequest(adapter.getXflowNode(), [this.dataName], this._bindedCallback);
                var dataResult = this.xflowRequest.getResult();
                var transformData = (dataResult.getOutputData(this.dataName) && dataResult.getOutputData(this.dataName).getValue());
                if (transformData)
                    return transformData;
            }
            if (adapter.getMatrix) {
                return adapter.getMatrix();
            }
        }
        return this.onlyDataTransform ? null : IDENTITY;
    };
}());

DOMTransformFetcher.prototype._onChange = function (evt) {
    if (evt.type == Events.ADAPTER_VALUE_CHANGED) {
        this.owner.onTransformChange(this.attrName, evt.adapterHandle.getAdapter().getMatrix());
    } else { // If the adapter changed, we need to re-evaluate the matrix
        this.updateMatrix();
    }
};

module.exports = DOMTransformFetcher;

},{"../interface/notification.js":74,"../utils/css.js":179,"../xflow/interface/request.js":190,"gl-matrix":1}],67:[function(require,module,exports){
var assign = require("lodash.assign");
var create = require("lodash.create");

if (window.XML3D !== undefined) {
    throw new Error("Tried to define the XML3D namespace a second time. Please ensure xml3d.js is only loaded once!");
}
/** @namespace * */
var XML3D = XML3D || {};
var Xflow = Xflow || {};
window.XML3D = XML3D;
window.Xflow = Xflow;

XML3D.version = '5.1.2';
/** @const */
XML3D.xml3dNS = 'http://www.xml3d.org/2009/xml3d';
/** @const */
XML3D.xhtmlNS = 'http://www.w3.org/1999/xhtml';
/** @const */
XML3D.webglNS = 'http://www.xml3d.org/2009/xml3d/webgl';
XML3D._xml3d = document.createElementNS(XML3D.xml3dNS, "xml3d");
XML3D._parallel = XML3D._parallel != undefined ? XML3D._parallel : false;
XML3D.xhtml = !!(document.doctype && new XMLSerializer().serializeToString(document.doctype).match(/xhtml/i));

XML3D.createElement = function(tagName) {
    XML3D.debug.logWarning("This function is deprecated and will be removed in the next major release. Use document.createElement instead.");
    return document.createElement(tagName);
};

XML3D.extend = assign;

/**
 *
 * @param {Object} obj Constructor
 * @param {Object} parent Parent class
 * @param {Object=} methods Methods to add to the class
 * @return {Object!}
 */
XML3D.createClass = function(obj, parent, methods) {
    if(!parent) {
        assign(obj.prototype, methods);
    } else {
        obj.prototype = create(parent.prototype, methods);
    }
    return obj;
};

XML3D.debug = require("./utils/debug.js");
XML3D.util = require("./utils/misc.js");
XML3D.options = require("./utils/options.js");
XML3D.materials = require("./renderer/webgl/materials/urn/registery.js");
XML3D.resource = {};
XML3D.extend(XML3D.resource, require("./resource"));
XML3D.extend(XML3D.resource, require("./utils/uri.js"));
XML3D.resource.Asset = require("./asset/asset.js").Asset;
XML3D.resource.SubData = require("./asset/asset.js").SubData;

XML3D.webcl = require("./utils/webcl.js").webcl;
XML3D.math = require("gl-matrix");
require("./math/math.js")(XML3D.math);

XML3D.Mat2 = require("./types/mat2.js");
XML3D.Mat3 = require("./types/mat3.js");
XML3D.Mat4 = require("./types/mat4.js");
XML3D.Vec2 = require("./types/vec2.js");
XML3D.Vec3 = require("./types/vec3.js");
XML3D.Vec4 = require("./types/vec4.js");
XML3D.AxisAngle = require("./types/axisangle.js");
XML3D.Quat = require("./types/quat.js");
XML3D.Ray = require("./types/ray.js");
XML3D.Box = require("./types/box.js");

XML3D.extend(window, require("./types/data-observer.js"));

Xflow.registerOperator = require("./xflow/operator/operator.js").registerOperator;
Xflow.constants = require("./xflow/interface/constants.js");
XML3D.extend(Xflow, require("./xflow/interface/graph.js"));
XML3D.extend(Xflow, require("./xflow/interface/data.js"));
Xflow.ComputeRequest = require("./xflow/interface/request.js").ComputeRequest;

XML3D.asset = require("./asset/asset.js");

XML3D.webgl = {};
XML3D.webgl.BaseRenderTree = require("./renderer/webgl/render-trees/base.js");
XML3D.webgl.BaseRenderPass = require("./renderer/webgl/render-passes/base.js");

require("./resource/xml3dformathandler.js");

require("./xflow/operator/default");

module.exports = {
    XML3D : XML3D,
    Xflow : Xflow
};

},{"./asset/asset.js":47,"./math/math.js":76,"./renderer/webgl/materials/urn/registery.js":133,"./renderer/webgl/render-passes/base.js":139,"./renderer/webgl/render-trees/base.js":150,"./resource":165,"./resource/xml3dformathandler.js":166,"./types/axisangle.js":167,"./types/box.js":168,"./types/data-observer.js":169,"./types/mat2.js":170,"./types/mat3.js":171,"./types/mat4.js":172,"./types/quat.js":173,"./types/ray.js":174,"./types/vec2.js":175,"./types/vec3.js":176,"./types/vec4.js":177,"./utils/debug.js":181,"./utils/misc.js":182,"./utils/options.js":183,"./utils/uri.js":184,"./utils/webcl.js":185,"./xflow/interface/constants.js":187,"./xflow/interface/data.js":188,"./xflow/interface/graph.js":189,"./xflow/interface/request.js":190,"./xflow/operator/default":208,"./xflow/operator/operator.js":227,"gl-matrix":1,"lodash.assign":17,"lodash.create":32}],68:[function(require,module,exports){
var XML3D = require("./global.js").XML3D;
var Config = require("./interface/elements.js").config;
var sendAdapterEvent = require("./utils/misc.js").sendAdapterEvent;
var Options = require("./utils/options.js");
var CSS = require("./utils/css.js");
var ConfigureRenderer = require("./renderer/renderer/configure.js");
var WebglSupported = require("./renderer/webgl/base/utils.js").supported;
var Util = require("./utils/misc.js");
require("./interface/dom.js");
require("./utils/debug.js");

(function () {
    if (navigator.userAgent.match(/(iPad|iPhone|iPod touch)/i)) {
        var m = document.createElement("meta");
        m.name = "format-detection";
        m.content = "telephone=no";
        document.head.appendChild(m)
    }
}());

function displayWebGLNotSupportedInfo(xml3dElement){

    if(xml3dElement.hasAttribute("onunsupported")){
        var callback = new Function("event", xml3dElement.getAttribute("onunsupported"));
        xml3dElement.addEventListener('unsupported', callback, false);
    }
    var doDefault = XML3D.util.dispatchCustomEvent(xml3dElement, 'unsupported', false, true, null);
    if(doDefault){
        // Place xml3dElement inside an invisible div
        var hideDiv = document.createElement('div');

        xml3dElement.parentNode.insertBefore(hideDiv, xml3dElement);
        hideDiv.appendChild(xml3dElement);
        //hideDiv.style.display = "none";

        var infoDiv = document.createElement('div');
        if(xml3dElement.hasAttribute("class")){
            infoDiv.setAttribute("class", xml3dElement.getAttribute("class"));
        }

        infoDiv.setAttribute("style", xml3dElement.getAttribute("style"));
        infoDiv.style.border = "2px solid red";
        infoDiv.style.fontFamily = "verdana,sans-serif";
        infoDiv.style.color = "red";
        infoDiv.style.padding = "10px";
        infoDiv.style.backgroundColor = "rgba(255, 0, 0, 0.3)";

        var width = xml3dElement.getAttribute("width");
        if (width !== null) {
            infoDiv.style.width = width;
        }

        var height = xml3dElement.getAttribute("height");
        if (height !== null) {
            infoDiv.style.height = height;
        }

        var hElement = document.createElement("h3");
        var hTxt = document.createTextNode("Sorry, your browser doesn't appear to support XML3D.");
        hElement.appendChild(hTxt);

        var pElement = document.createElement("p");
        pElement.appendChild(document.createTextNode("Please visit "));
        var link = document.createElement("a");
        link.setAttribute("href", "http://www.xml3d.org/help");
        link.appendChild(document.createTextNode("http://www.xml3d.org/help"));
        pElement.appendChild(link);
        pElement.appendChild(document.createTextNode(" for more information."));
        infoDiv.appendChild(hElement);
        infoDiv.appendChild(pElement);

        hideDiv.parentNode.insertBefore(infoDiv, hideDiv);
    }

}

/*  a list of elements that are currently initialized. More specifically,
 *  they're currently in a call to the method below.
 *
 *  Why?
 *  In webgl we actually reattach the xml3d element in the DOM. Thus, when
 *  we're in the middle of working on a onNodeInserted event, there will probably
 *  come right another event which we actually don't care for.
 *  So we use this list to keep track of which elements are currently initializing.
 */
var curXML3DInitElements = [];

/**
 * @param {Element} xml3dElement
 */
function initXML3DElement(xml3dElement) {
    if(curXML3DInitElements.indexOf(xml3dElement) > -1)
        return;

    // Make sure the xml3d element is still in the DOM
    var parent = xml3dElement.parentNode;
    while (parent && !Util.elementIs(parent, "body")) {
        parent = parent.parentNode;
    }
    if (!parent || !Util.elementIs(parent, "body")) {
        return;
    }

    curXML3DInitElements.push(xml3dElement);

    var debug = XML3D.debug.setup();

    if (!WebglSupported()) {
        debug && XML3D.debug.logWarning("Could not initialise WebGL, sorry :-(");
        displayWebGLNotSupportedInfo(xml3dElement);
        curXML3DInitElements.splice(curXML3DInitElements.indexOf(xml3dElement), 1);
        return;
    }

    XML3D.debug.logInfo("Configuring", xml3dElement.querySelectorAll("*").length, "elements");

    try {
        Config.configure(xml3dElement);
    } catch (e) {
        debug && XML3D.debug.logException(e);
        curXML3DInitElements.splice(curXML3DInitElements.indexOf(xml3dElement), 1);
        return;
    }
    try {
        ConfigureRenderer(xml3dElement);
    } catch (e) {
        debug && XML3D.debug.logException(e);
        curXML3DInitElements.splice(curXML3DInitElements.indexOf(xml3dElement), 1);
        return;
    }

    // initialize all attached adapters
    sendAdapterEvent(xml3dElement, {onConfigured : []});

    curXML3DInitElements.splice(curXML3DInitElements.indexOf(xml3dElement), 1);
    clearObserver();
}

/**
 * @param {Element} xml3dElement
 */
function destroyXML3DElement(xml3dElement)
{
    if(curXML3DInitElements.indexOf(xml3dElement) > -1)
        return;

    if (!xml3dElement._configured) {
        return; //Already destroyed or never initialized
    }

    var canvas = xml3dElement._configured.canvas;

    xml3dElement._configured.destroy();
    xml3dElement._configured = undefined;

    if(!canvas || !Util.elementIs(canvas, "canvas"))
        return; // an element we didn't create, skip deletion

    if (!xml3dElement.parentNode) {
        // The xml3d element was removed directly rather than as a result of a parent container being removed,
        // here we should also remove the hiding div
        var div = canvas.nextElementSibling;
        if (Util.elementIs(div, "div") && div.getAttribute("class") == "_xml3d_hideDiv") {
            div.parentNode && div.parentNode.removeChild(div);
        }
    }

    canvas.parentNode && canvas.parentNode.removeChild(canvas);
}

/**
 * @param {Event} evt
 */
function onNodeInserted(evt) {

    if(Util.elementIs(evt.target, "xml3d")) {
        initXML3DElement(evt.target);
    }
}

/**
 * @param {Event} evt
 */
function onNodeRemoved(evt) {

    if(Util.elementIs(evt.target, "xml3d")) {
        destroyXML3DElement(evt.target);
    }
}

var observer = null;

function onLoad() {

    Options.setOptionsFromQuery();

    CSS.init();

    var debug = XML3D.debug.setup();
    debug && XML3D.debug.logInfo("xml3d.js version: " + XML3D.version);

    /**
     * Find all the XML3D tags in the document
     * @type {NodeList}
     */
    var xml3ds = document.querySelectorAll("xml3d");

    debug && XML3D.debug.logInfo("Found " + xml3ds.length + " xml3d node(s)");

    for(var i = 0; i < xml3ds.length; i++) {
        initXML3DElement(xml3ds[i]);
    }

    // TODO(ksons): Remove this, no MutationObserver no XML3D
    if(!MutationObserver){
        document.addEventListener('DOMNodeInserted', onNodeInserted, false);
        document.addEventListener('DOMNodeRemoved', onNodeRemoved, false);
    }
    else{
        observer = new MutationObserver(resolveMutations);
        observer.observe(document.documentElement, { childList: true, subtree: true, attributes: true, attributeFilter: [ "class", "id", "style" ] } );
    }
}

function onUnload() {
    if (XML3D.document)
        XML3D.document.onunload();
}



function resolveMutations(mutations){
    for(var i = 0; i < mutations.length; ++i){
        var mutation = mutations[i];
        if(mutation.type == 'childList'){
            mapFunctionOnXML3DElements(mutation.addedNodes, initXML3DElement);
            mapFunctionOnXML3DElements(mutation.removedNodes, destroyXML3DElement);

        } else if (mutation.type == 'attributes') {
            var mutationTarget = mutation.target;
            if (mutation.attributeName === "id" || mutation.attributeName === "class") {
                mutationTarget = mutation.target.parentNode; // Start CSS re-eval at parent to honor sibling selectors
                if (!mutationTarget) {
                    continue; // Target was removed from the DOM before this event was processed
                }
            }
            var cssTarget = mutationTarget._configured ? mutationTarget : mutationTarget.querySelector("xml3d");
            if(cssTarget && cssTarget._configured) { // xml3d is a child node
                var adaptersNames = Object.keys(cssTarget._configured.adapters).filter(function(a) {
                    return a.indexOf("scene") == 0;
                });
                adaptersNames.map(function(name){return cssTarget._configured.adapters[name];}).forEach(function(renderAdapter) {
                    renderAdapter.traverse(function(adapter) {
                        adapter.styleChangedCallback();
                    })

                });

            }

        }
    }
}

function mapFunctionOnXML3DElements(elementList, fun) {
    Array.forEach(elementList, function(element) {
        if (!element.getElementsByTagNameNS) {
            // These elements are leaf nodes (eg. TEXT) so we can ignore them
            return;
        }
        if (Util.elementIs(element, "xml3d")) {
            fun(element);
            // An XML3D element can't have further XML3D elements as children
            return;
        }
        // For cases where an XML3D element might be inside the subtree of the added node
        var xml3dElems = element.getElementsByTagName("xml3d");
        xml3dElems = xml3dElems.length ? xml3dElems : element.getElementsByTagNameNS(XML3D.xml3dNS, "xml3d");

        Array.forEach(xml3dElems, fun);
    });
}

XML3D.flushCSSChanges = function(){
    if(observer){
        resolveMutations(observer.takeRecords());
    }
};

function clearObserver(){
    if(observer){
        observer.takeRecords();
    }
}

if (document.readyState === "complete" || document.readyState === "interactive") {
    onLoad();
} else {
    document.addEventListener('DOMContentLoaded', onLoad, false);
}

window.addEventListener('unload', onUnload, false);
window.addEventListener('reload', onUnload, false);

module.exports = XML3D;


},{"./global.js":67,"./interface/dom.js":71,"./interface/elements.js":72,"./renderer/renderer/configure.js":91,"./renderer/webgl/base/utils.js":118,"./utils/css.js":179,"./utils/debug.js":181,"./utils/misc.js":182,"./utils/options.js":183}],69:[function(require,module,exports){
var Resource = require("../resource");

var string2bool = function(string) {
    if (!string) {
        return false;
    }
    switch (string.toLowerCase()) {
    case "true":
    case "1":
        return true;
    case "false":
    case "0":
        return false;
    default:
        return Boolean(string);
    }
};
var handlers = {};

function getStorage(elem){
    return elem._configured.storage;
}

var AttributeHandler = function(elem) {
};

handlers.IDHandler = function(id) {
    id = id.toLowerCase();
    this.setFromAttribute = function(value, prevValue, elem) {
        Resource.notifyNodeIdChange(elem, prevValue, value);
    };
    this.desc = {
        get : function() {
            return this.getAttribute(id) || "";
        },
        set : function(value) {
            this.setAttribute(id, value);
        }
    };
};

handlers.StringAttributeHandler = function(id, params) {
    id = id.toLowerCase();
    var defaultValue = params ? params.defaultValue: "";
    this.desc = {
        get : function() {
            return this.getAttribute(id) || defaultValue;
        },
        set : function(value) {
            this.setAttribute(id, value || defaultValue);
        }
    };
};

handlers.EnumAttributeHandler = function(id, enumObj) {
    AttributeHandler.call(this);
    id = id.toLowerCase();

    this.init = function(elem, storage){
        storage[id] = enumObj.defaultValue;
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };
    this.setFromAttribute = function(v, prevValue, elem, storage) {
        var value = v.toLowerCase();
        storage[id] = (value && enumObj.values[value] !== undefined) ? enumObj.values[value] : enumObj.defaultValue;
        return false;
    };
    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            return enumObj.values[storage[id]];
        },
        set : function(v) {
                // Attribute is set to whatever comes in
            this.setAttribute(id, v);
            var storage = getStorage(this);
            var value = typeof v == 'string' ? v.toLowerCase() : undefined;
            if (value && enumObj.values[value] !== undefined)
                storage[id] = enumObj.values[value];
            else
                storage[id] = enumObj.defaultValue;
        }
    };
};
handlers.EnumAttributeHandler.prototype = new AttributeHandler();
handlers.EnumAttributeHandler.prototype.constructor = handlers.EnumAttributeHandler;

handlers.EventAttributeHandler = function(id) {
    AttributeHandler.call(this);
    id = id.toLowerCase();
    var eventType = id.substring(2);

    this.init = function(elem, storage){
        storage[id] = null;
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };

    this.setFromAttribute = function(value, prevValue, elem, storage) {
        if(storage[id] != null)
            elem.removeEventListener(eventType, storage[id]);
        if(!value){
            storage[id] = null;
        }
        else{
            storage[id] = eval("crx = function " + id + "(event){\n  " + value + "\n}");
            if (XML3D.xhtml) {
                // only XHTML documents require this polyfill for mouse event attributes
                elem.addEventListener(eventType, storage[id], false);
            }
        }
        return false;
    };
    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            return storage[id];
        },
        set : function(value) {
            var storage = getStorage(this);
            if(XML3D.xhtml && storage[id]) this.removeEventListener(eventType, storage[id]);
            storage[id] = (typeof value == 'function') ? value : undefined;
            if(XML3D.xhtml && storage[id]) this.addEventListener(eventType, storage[id], false);
            return false;
        }
    };
};

handlers.EventAttributeHandler.prototype = new AttributeHandler();
handlers.EventAttributeHandler.prototype.constructor = handlers.EventAttributeHandler;

handlers.IntAttributeHandler = function(id, defaultValue) {
    id = id.toLowerCase();
    this.init = function(elem, storage){
        storage[id] = defaultValue;
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };

    this.setFromAttribute = function(value, prevValue, elem, storage) {
        var v = value.match(/^\d+/);
        if (!v || isNaN(+v[0])) {
            XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, elem);
            elem.setAttribute(id, prevValue);
            storage[id] = defaultValue;
        } else {
            storage[id] =  +v[0];
        }
        if(elem._configured.canvas)
            elem._configured.canvas[id] = storage[id];
        return false;
    };

    this.desc = {
        get : function(){
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            return storage[id];
        },
        set : function(value) {
            var storage = getStorage(this);
            var v = +value;
            if (isNaN(v)) {
                XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, this);
                storage[id] = defaultValue;
            } else {
                storage[id] =  Math.floor(v);
            }
            this.setAttribute(id, storage[id] + '');
        }
    };
};
handlers.IntAttributeHandler.prototype = new AttributeHandler();
handlers.IntAttributeHandler.prototype.constructor = handlers.IntAttributeHandler;

handlers.FloatAttributeHandler = function(id, defaultValue) {
    id = id.toLowerCase();
    this.init = function(elem, storage){
        storage[id] = defaultValue;
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };

    this.setFromAttribute = function(value, prevValue, elem, storage) {
        var v = +value;
        if (isNaN(v)) {
            XML3D.debug.logWarning("Invalid attribute value: " + value, elem);
            elem.setAttribute(id, prevValue);
            storage[id] = defaultValue;
        } else {
            storage[id] =  v;
        }
        return false;
    };

    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            return storage[id];
        },
        set : function(value) {
            var storage = getStorage(this);
            var v = +value;
            if (isNaN(v)) {
                XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, this);
                storage[id] = defaultValue;
            } else {
                storage[id] =  v;
            }
            this.setAttribute(id, storage[id] + '');
        }
    };
};

handlers.BoolAttributeHandler = function(id, defaultValue) {
    id = id.toLowerCase();
    this.init = function(elem, storage){
        storage[id] = defaultValue;
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };
    this.setFromAttribute = function(value, prevValue, elem, storage) {
        storage[id] = string2bool(value);
        return false;
    };

    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            return storage[id];
        },
        set : function(value) {
            var storage = getStorage(this);
            storage[id] = Boolean(value);
            this.setAttribute(id, storage[id] + '');
        }
    };
};

handlers.Vec3AttributeHandler = function(id, defaultValue) {
    var that = this;
    id = id.toLowerCase();

    this.init = function(elem, storage){
        storage[id] = null;
    };

    this.setFromAttribute = function(value, prevValue, elem, storage, init) {
        if (!storage[id]) {
            storage[id] = XML3D.math.vec3.create();
        }
        var v = storage[id];
        var m = /^\s*(\S+)\s+(\S+)\s+(\S+)\s*$/.exec(value);
        if (!m  || isNaN(+m[1]) || isNaN(+m[2]) || isNaN(+m[3])) {
            v[0] = defaultValue[0];
            v[1] = defaultValue[1];
            v[2] = defaultValue[2];
            !init && XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, elem);
        } else {
            v[0] = +m[1];
            v[1] = +m[2];
            v[2] = +m[3];
        }
        return false;
    };

    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            if (!storage[id]) {
                that.setFromAttribute(this.getAttribute(id), null, this, storage, true);
            }
            return new XML3D.Vec3(storage[id]);
        },
        set : function(value) {
            var storage = getStorage(this);
            if (!storage[id]) {
                that.setFromAttribute(this.getAttribute(id), null, this, storage, true);
            }
            var v = storage[id];
            var val = value.data ? value.data : value;
            if (val.length !== 3 || isNaN(val[0]) || isNaN(val[1]) || isNaN(val[2])) {
                XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, this);
                v = defaultValue;
            } else {
                v[0] = val[0]; v[1] = val[1]; v[2] = val[2];
            }
            this.setAttribute(id, XML3D.math.vec3.toDOMString(v));
        }
    };
};

// Note: All vec4 attributes are considered to be axis-angle, NOT quaternions!
handlers.AxisAngleAttributeHandler = function(id, defaultValue) {
    var that = this;
    id = id.toLowerCase();

    this.init = function(elem, storage){
        storage[id] = null;
    };

    this.setFromAttribute = function(value, prevValue, elem, storage, init) {
        if (!storage[id]) {
            storage[id] = XML3D.math.vec4.create();
        }
        var v = storage[id];
        var m = /^\s*(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s*$/.exec(value);
        if (!m  || isNaN(+m[1]) || isNaN(+m[2]) || isNaN(+m[3]) || isNaN(+m[4])) {
            XML3D.math.vec4.copy(v, defaultValue);
            !init && XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, elem);
        } else {
            XML3D.math.vec4.set(v, +m[1], +m[2], +m[3], +m[4]);
        }
        return false;
    };

    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            if (!storage[id]) {
                that.setFromAttribute(this.getAttribute(id), null, this, storage, true);
            }
            return new XML3D.AxisAngle(storage[id]);
        },
        set : function(value) {
            var storage = getStorage(this);
            if (!storage[id]) {
                that.setFromAttribute(this.getAttribute(id), null, this, storage, true);
            }
            var v = storage[id];
            var val = value.data ? value.data : value;
            if (val.length !== 4 || isNaN(val[0]) || isNaN(val[1]) || isNaN(val[2]) || isNaN(val[3])) {
                XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, this);
                XML3D.math.vec4.copy(v, defaultValue);
            } else {
                XML3D.math.quat.copy(v, val);
            }
            this.setAttribute(id, XML3D.math.vec4.toDOMString(v));
        }
    };
};

var mixedContent = function(handler) {
    handler.init = function(elem, storage){
        elem._configured.registerMixed();
    };
    handler.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            if (!storage.value) {
                storage.value = handler.parse(this);
            }
            return storage.value;
        },
        set : function(value) {
            // Throw error?
            throw Error("Can't set " + this.nodeName + "::value: it's readonly");
        }
    };
    handler.resetValue = function(storage) { storage.value = null; };
};

var getContent = function(elem) {
    var str = "";
    var k = elem.firstChild;
    while (k) {
        str += k.nodeType == 3 ? k.textContent : " ";
        k = k.nextSibling;
    }
    return str;
};

handlers.FloatArrayValueHandler = function(id) {
    mixedContent(this);
};

handlers.FloatArrayValueHandler.prototype.parse = function(elem) {
    var exp = /([+\-0-9eE\.]+)/g;
    var str = getContent(elem);
    var m = str.match(exp);
    return m ? new Float32Array(m) : new Float32Array();
};

handlers.Float2ArrayValueHandler = handlers.FloatArrayValueHandler;
handlers.Float3ArrayValueHandler = handlers.FloatArrayValueHandler;
handlers.Float4ArrayValueHandler = handlers.FloatArrayValueHandler;
handlers.Float4x4ArrayValueHandler = handlers.FloatArrayValueHandler;

handlers.IntArrayValueHandler = function(id) {
    mixedContent(this);
};
handlers.IntArrayValueHandler.prototype.parse = function(elem) {
    var exp = /([+\-0-9]+)/g;
    var str = getContent(elem);
    var m = str.match(exp);
    return m ? new Int32Array(m) : new Int32Array();
};

handlers.BoolArrayValueHandler = function(id) {
    mixedContent(this);
};
handlers.BoolArrayValueHandler.prototype.parse = function(elem) {
    var exp = /(true|false|0|1)/ig;
    var str = getContent(elem);
    var m = str.match(exp);
    if (!m)
        return new Uint8Array();
    m = m.map(string2bool);
    return m ? new Uint8Array(m) : new Uint8Array();
};

handlers.StringValueHandler = function(id) {
    mixedContent(this);
};
handlers.StringValueHandler.prototype.parse = function(elem) {
    return elem.textContent;
};

handlers.CanvasStyleHandler = function(id, d) {
    id = id.toLowerCase();
    this.init = function(elem, storage){
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };

    this.setFromAttribute = function(value, prevValue, elem, storage) {
        elem._configured.canvas.setAttribute(id, value);
    };

    this.desc = {
        get: function() { return this._configured.canvas.style; },
        set: function(value) {}
    };

};

handlers.CanvasClassHandler = function(id) {
    id = id.toLowerCase();
    this.init = function(elem, storage){
        var canvas = elem._configured.canvas;
        canvas.className = "_xml3d"; // Class name always defined for xml3d canvas
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };

    this.setFromAttribute = function(value, prevValue, elem, storage) {
        var canvas = elem._configured.canvas;
        canvas.setAttribute(id, value + " _xml3d");
    };

    this.desc = {
        // TODO: Should we not strip the _xml3d class here?
        get: function() {
            if (!this._configured) {
                return "";
            }
            return this._configured.canvas.className;
        },
        set: function(value) {
            if (this._configured) {
                this._configured.canvas.className = value;
            }
        }
    };
};

module.exports = handlers;

},{"../resource":165}],70:[function(require,module,exports){
var methods = require("./methods.js");
var handlers = require("./attributes.js");
var properties = require("./properties.js");

// MeshTypes
var MeshTypes = {};
MeshTypes["triangles"] = 0;
MeshTypes[0] = "triangles";
MeshTypes["trianglestrips"] = 1;
MeshTypes[1] = "trianglestrips";
MeshTypes["lines"] = 2;
MeshTypes[2] = "lines";
MeshTypes["linestrips"] = 3;
MeshTypes[3] = "linestrips";
MeshTypes["points"] = 4;
MeshTypes[4] = "points";
MeshTypes["derived"] = 5;
MeshTypes[5] = "derived";
// TextureTypes
var TextureTypes = {};
TextureTypes["2d"] = 0;
TextureTypes[0] = "2d";
TextureTypes["1d"] = 1;
TextureTypes[1] = "1d";
TextureTypes["3d"] = 2;
TextureTypes[2] = "3d";

// PlatformTypes
var PlatformTypes = {};
PlatformTypes["auto"] = 1;
PlatformTypes[1] = "auto";
PlatformTypes["js"] = 2;
PlatformTypes[2] = "js";
PlatformTypes["gl"] = 3;
PlatformTypes[3] = "gl";
PlatformTypes["cl"] = 4;
PlatformTypes[4] = "cl";
// DataFieldType
var DataFieldType = {};
DataFieldType["float "] = 0;
DataFieldType[0] = "float ";
DataFieldType["float2 "] = 1;
DataFieldType[1] = "float2 ";
DataFieldType["float3"] = 2;
DataFieldType[2] = "float3";
DataFieldType["float4"] = 3;
DataFieldType[3] = "float4";
DataFieldType["float4x4"] = 4;
DataFieldType[4] = "float4x4";
DataFieldType["int"] = 10;
DataFieldType[10] = "int";
DataFieldType["int4"] = 11;
DataFieldType[11] = "int4";
DataFieldType["bool"] = 20;
DataFieldType[20] = "bool";
DataFieldType["texture"] = 30;
DataFieldType[30] = "texture";
// DataChannelOrigin
var DataChannelOrigin = {};
DataChannelOrigin["origin_value "] = 0;
DataChannelOrigin[0] = "origin_value ";
DataChannelOrigin["origin_child"] = 1;
DataChannelOrigin[1] = "origin_child";
DataChannelOrigin["origin_source"] = 2;
DataChannelOrigin[2] = "origin_source";
DataChannelOrigin["origin_compute"] = 3;
DataChannelOrigin[3] = "origin_compute";
DataChannelOrigin["origin_proto"] = 4;
DataChannelOrigin[4] = "origin_proto";

var classInfo = {};

/**
 * Properties and methods for <xml3d>
 **/
classInfo['xml3d'] = {
    id : {a: handlers.IDHandler},
    className : {a: handlers.CanvasClassHandler, id: 'class'},
    style : {a: handlers.CanvasStyleHandler},
    onclick : {a: handlers.EventAttributeHandler},
    ondblclick : {a: handlers.EventAttributeHandler},
    onmousedown : {a: handlers.EventAttributeHandler},
    onmouseup : {a: handlers.EventAttributeHandler},
    onmouseover : {a: handlers.EventAttributeHandler},
    onmousemove : {a: handlers.EventAttributeHandler},
    onmouseout : {a: handlers.EventAttributeHandler},
    onkeypress : {a: handlers.EventAttributeHandler},
    onkeydown : {a: handlers.EventAttributeHandler},
    onkeyup : {a: handlers.EventAttributeHandler},
    onload: {a: handlers.EventAttributeHandler},
    onframedrawn: {a: handlers.EventAttributeHandler},
    complete: {p: properties.xml3dComplete},
    height : {a: handlers.IntAttributeHandler, params: 600},
    width : {a: handlers.IntAttributeHandler, params: 800},
    getElementByPoint : {m: methods.xml3dGetElementByPoint},
    generateRay : {m: methods.xml3dGenerateRay},
    getElementByRay : {m: methods.xml3dGetElementByRay},
    getWorldBoundingBox : {m: methods.getWorldBoundingBox},
    getLocalBoundingBox : {m: methods.getLocalBoundingBox},
    getRenderInterface : {m: methods.xml3dGetRenderInterface},
    view : {a: handlers.StringAttributeHandler, params: {defaultValue: "view"}}
    };

classInfo['compute'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    value: {a: handlers.StringValueHandler}
    };

/**
 * Properties and methods for <data>
 **/
classInfo['data'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    compute: {a: handlers.StringAttributeHandler},
    platform: {a: handlers.EnumAttributeHandler, params: {values: PlatformTypes, defaultValues: 1}},
    filter: {a: handlers.StringAttributeHandler},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    getOutputNames: {m: methods.XML3DNestedDataContainerTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DNestedDataContainerTypeGetOutputChannelInfo},
    getResult: {m: methods.XML3DNestedDataContainerTypeGetResult},
    src: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <dataflow>
 **/
classInfo['dataflow'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    platform: {a: handlers.EnumAttributeHandler, params: {values: PlatformTypes, defaultValues: 1}},
    out: {a: handlers.StringAttributeHandler},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    getOutputNames: {m: methods.XML3DNestedDataContainerTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DNestedDataContainerTypeGetOutputChannelInfo},
    getResult: {m: methods.XML3DNestedDataContainerTypeGetResult}
    };
/**
 * Properties and methods for <data>
 **/
classInfo['asset'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.AssetComplete},
    progressLevel: {p: properties.AssetProgressLevel},
    src: {a: handlers.StringAttributeHandler},
    name: {a: handlers.StringAttributeHandler},
    pick: {a: handlers.StringAttributeHandler},
    transform: {a: handlers.StringAttributeHandler},
    material: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <defs>
 **/
classInfo['defs'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'}
    };
/**
 * Properties and methods for <group>
 **/
classInfo['group'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onclick: {a: handlers.EventAttributeHandler},
    ondblclick: {a: handlers.EventAttributeHandler},
    onmousedown: {a: handlers.EventAttributeHandler},
    onmouseup: {a: handlers.EventAttributeHandler},
    onmouseover: {a: handlers.EventAttributeHandler},
    onmousemove: {a: handlers.EventAttributeHandler},
    onmouseout: {a: handlers.EventAttributeHandler},
    onkeypress: {a: handlers.EventAttributeHandler},
    onkeydown: {a: handlers.EventAttributeHandler},
    onkeyup: {a: handlers.EventAttributeHandler},
    getWorldMatrix: {m: methods.XML3DGraphTypeGetWorldMatrix},
    getLocalMatrix: {m: methods.XML3DGraphTypeGetLocalMatrix},
    getWorldBoundingBox : {m: methods.getWorldBoundingBox},
    getLocalBoundingBox : {m: methods.getLocalBoundingBox},
    transform: {a: handlers.StringAttributeHandler},
    material: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <mesh>
 **/
classInfo['mesh'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onclick: {a: handlers.EventAttributeHandler},
    ondblclick: {a: handlers.EventAttributeHandler},
    onmousedown: {a: handlers.EventAttributeHandler},
    onmouseup: {a: handlers.EventAttributeHandler},
    onmouseover: {a: handlers.EventAttributeHandler},
    onmousemove: {a: handlers.EventAttributeHandler},
    onmouseout: {a: handlers.EventAttributeHandler},
    onkeypress: {a: handlers.EventAttributeHandler},
    onkeydown: {a: handlers.EventAttributeHandler},
    onkeyup: {a: handlers.EventAttributeHandler},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    type: {a: handlers.EnumAttributeHandler, params: {values: MeshTypes, defaultValue: 0}},
    compute: {a: handlers.StringAttributeHandler},
    transform: {a: handlers.StringAttributeHandler},
    material: {a: handlers.StringAttributeHandler},
    getWorldMatrix: {m: methods.XML3DGraphTypeGetWorldMatrix},
    getLocalMatrix: {m: methods.XML3DGraphTypeGetLocalMatrix},
    getWorldBoundingBox : {m: methods.getWorldBoundingBox},
    getLocalBoundingBox : {m: methods.getLocalBoundingBox},
    getOutputNames: {m: methods.meshGetOutputNames},
    getOutputChannelInfo: {m: methods.meshGetOutputChannelInfo},
    getResult: {m: methods.meshGetResult},
    src: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <model>
 **/
classInfo['model'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onclick: {a: handlers.EventAttributeHandler},
    ondblclick: {a: handlers.EventAttributeHandler},
    onmousedown: {a: handlers.EventAttributeHandler},
    onmouseup: {a: handlers.EventAttributeHandler},
    onmouseover: {a: handlers.EventAttributeHandler},
    onmousemove: {a: handlers.EventAttributeHandler},
    onmouseout: {a: handlers.EventAttributeHandler},
    onkeypress: {a: handlers.EventAttributeHandler},
    onkeydown: {a: handlers.EventAttributeHandler},
    onkeyup: {a: handlers.EventAttributeHandler},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.AssetComplete},
    progressLevel: {p: properties.AssetProgressLevel},
    getWorldMatrix: {m: methods.XML3DGraphTypeGetWorldMatrix},
    getLocalMatrix: {m: methods.XML3DGraphTypeGetLocalMatrix},
    getWorldBoundingBox : {m: methods.getWorldBoundingBox},
    getLocalBoundingBox : {m: methods.getLocalBoundingBox},
    src: {a: handlers.StringAttributeHandler},
    pick: {a: handlers.StringAttributeHandler},
    transform: {a: handlers.StringAttributeHandler},
    material: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <transform>
 **/
classInfo['transform'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    translation: {a: handlers.Vec3AttributeHandler, params: [0, 0, 0]},
    scale: {a: handlers.Vec3AttributeHandler, params: [1, 1, 1]},
    rotation: {a: handlers.AxisAngleAttributeHandler, params: [0, 0, 1, 0]},
    center: {a: handlers.Vec3AttributeHandler, params: [0, 0, 0]},
    scaleOrientation: {a: handlers.AxisAngleAttributeHandler, params: [0, 0, 1, 0]}
    };
/**
 * Properties and methods for <material>
 **/
classInfo['material'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    compute: {a: handlers.StringAttributeHandler},
    getOutputNames: {m: methods.XML3DShaderProviderTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DShaderProviderTypeGetOutputChannelInfo},
    getResult: {m: methods.XML3DShaderProviderTypeGetResult},
    model: {a: handlers.StringAttributeHandler},
    src: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <light>
 **/
classInfo['light'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onclick: {a: handlers.EventAttributeHandler},
    ondblclick: {a: handlers.EventAttributeHandler},
    onmousedown: {a: handlers.EventAttributeHandler},
    onmouseup: {a: handlers.EventAttributeHandler},
    onmouseover: {a: handlers.EventAttributeHandler},
    onmousemove: {a: handlers.EventAttributeHandler},
    onmouseout: {a: handlers.EventAttributeHandler},
    onkeypress: {a: handlers.EventAttributeHandler},
    onkeydown: {a: handlers.EventAttributeHandler},
    onkeyup: {a: handlers.EventAttributeHandler},
    global: {a: handlers.BoolAttributeHandler, params: false},
    getWorldMatrix: {m: methods.XML3DGraphTypeGetWorldMatrix},
    getLocalMatrix: {m: methods.XML3DGraphTypeGetLocalMatrix},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    compute: {a: handlers.StringAttributeHandler},
    getOutputNames: {m: methods.XML3DShaderProviderTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DShaderProviderTypeGetOutputChannelInfo},
    getResult: {m: methods.XML3DShaderProviderTypeGetResult},
    src: {a: handlers.StringAttributeHandler},
    model: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <lightshader>
 * // TODO(ksons): Remove in XML3D 5.1
 **/
classInfo['lightshader'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    compute: {a: handlers.StringAttributeHandler},
    getOutputNames: {m: methods.XML3DShaderProviderTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DShaderProviderTypeGetOutputChannelInfo},
    getResult: {m: methods.XML3DShaderProviderTypeGetResult},
    script: {a: handlers.StringAttributeHandler},
    src: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <script>
 **/
classInfo['script'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    value: {a: handlers.StringValueHandler},
    src: {a: handlers.StringAttributeHandler},
    name: {a: handlers.StringAttributeHandler},
    type: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <assetmesh>
 **/
classInfo['assetmesh'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    match: {a: handlers.StringAttributeHandler},
    type: {a: handlers.EnumAttributeHandler, params: {values: MeshTypes, defaultValue: 0}},
    compute: {a: handlers.StringAttributeHandler},
    filter: {a: handlers.StringAttributeHandler},
    includes: {a: handlers.StringAttributeHandler},
    material: {a: handlers.StringAttributeHandler},
    transform: {a: handlers.StringAttributeHandler},
    platform: {a: handlers.EnumAttributeHandler, params: {values: PlatformTypes, defaultValue: 1}},
    getOutputNames: {m: methods.XML3DNestedDataContainerTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DNestedDataContainerTypeGetOutputChannelInfo},
    getResult: {m: methods.XML3DNestedDataContainerTypeGetResult},
    src: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <assetdata>
 **/
classInfo['assetdata'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    compute: {a: handlers.StringAttributeHandler},
    filter: {a: handlers.StringAttributeHandler},
    includes: {a: handlers.StringAttributeHandler},
    platform: {a: handlers.EnumAttributeHandler, params: {values: PlatformTypes, defaultValue: 1}},
    getOutputNames: {m: methods.XML3DNestedDataContainerTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DNestedDataContainerTypeGetOutputChannelInfo},
    getResult: {m: methods.XML3DNestedDataContainerTypeGetResult},
    src: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <float>
 **/
classInfo['float'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.FloatArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };
/**
 * Properties and methods for <float2>
 **/
classInfo['float2'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.Float2ArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };
/**
 * Properties and methods for <float3>
 **/
classInfo['float3'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.Float3ArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };
/**
 * Properties and methods for <float4>
 **/
classInfo['float4'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.Float4ArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };
/**
 * Properties and methods for <float4x4>
 **/
classInfo['float4x4'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.Float4x4ArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };
/**
 * Properties and methods for <int>
 **/
classInfo['int'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.IntArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };
/**
 * Properties and methods for <int4>
 **/
classInfo['int4'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.IntArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };
/**
 * Properties and methods for <bool>
 **/
classInfo['bool'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.BoolArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };

/**
 * Properties and methods for <string>
 **/
classInfo['string'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.StringValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
};

/**
 * Properties and methods for <texture>
 **/
classInfo['texture'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    type: {a: handlers.EnumAttributeHandler, params: {values: TextureTypes, defaultValue: 0}},
    filter: {a: handlers.StringAttributeHandler},
    wrap: {a: handlers.StringAttributeHandler},
    anisotropy: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <img>
 **/
classInfo['img'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    src: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <video>
 **/
classInfo['video'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    src: {a: handlers.StringAttributeHandler},
    autoplay: {a: handlers.BoolAttributeHandler, params: false},
    muted: {a: handlers.BoolAttributeHandler, params: false},
    play: {m: methods.videoPlay},
    pause: {m: methods.videoPause}
    };
/**
 * Properties and methods for <view>
 **/
classInfo['view'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onclick: {a: handlers.EventAttributeHandler},
    ondblclick: {a: handlers.EventAttributeHandler},
    onmousedown: {a: handlers.EventAttributeHandler},
    onmouseup: {a: handlers.EventAttributeHandler},
    onmouseover: {a: handlers.EventAttributeHandler},
    onmousemove: {a: handlers.EventAttributeHandler},
    onmouseout: {a: handlers.EventAttributeHandler},
    onkeypress: {a: handlers.EventAttributeHandler},
    onkeydown: {a: handlers.EventAttributeHandler},
    onkeyup: {a: handlers.EventAttributeHandler},
    getWorldMatrix: {m: methods.XML3DGraphTypeGetWorldMatrix},
    getLocalMatrix: {m: methods.XML3DGraphTypeGetLocalMatrix},
    getProjectionMatrix:{m: methods.viewGetProjectionMatrix},
    getViewMatrix: {m: methods.viewGetViewMatrix}
    };

module.exports = {
    classInfo : classInfo,
    MeshTypes : MeshTypes,
    TextureTypes : TextureTypes,
    PlatformTypes : PlatformTypes,
    DataFieldTypes : DataFieldType,
    DataChannelOrigin : DataChannelOrigin
};

},{"./attributes.js":69,"./methods.js":73,"./properties.js":75}],71:[function(require,module,exports){
var config = require("./elements.js").config;
var classInfo = require("./configuration.js").classInfo;

var doc = {};
var nativeGetElementById = document.getElementById;
doc.getElementById = function(id) {
    var elem = nativeGetElementById.call(this, id);
    if (elem) {
        return elem;
    } else {
        var elems = this.getElementsByTagName("*");
        for ( var i = 0; i < elems.length; i++) {
            var node = elems[i];
            if (node.getAttribute("id") === id) {
                return node;
            }
        }
    }
    return null;
};
var nativeCreateElementNS = document.createElementNS;
doc.createElementNS = function(ns, name) {
    var r = nativeCreateElementNS.call(this, ns, name);
    if (ns == XML3D.xml3dNS || classInfo[name.toLowerCase()]) {
        config.element(r);
    }
    return r;
};
var nativeCreateElement = document.createElement;
doc.createElement = function(name) {
    var r = nativeCreateElement.call(this, name);
    if (classInfo[name.toLowerCase()] ) {
        config.element(r);
    }
    return r;
};

XML3D.extend(window.document, doc);

},{"./configuration.js":70,"./elements.js":72}],72:[function(require,module,exports){
var events = require("./notification.js");
var ClassInfo = require("./configuration.js").classInfo;
var Resource = require("../resource");

var MutationObserver = (window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver),
    mutObserver;

if(MutationObserver){
    mutObserver = new MutationObserver(handleMutations);
} else {
    XML3D.debug.logError("XML3D requires MutationObservers, which your browser does not support. Please consider upgrading to a newer version.");
    mutObserver = {
        takeRecords:function(){return []},
        observe: function(a,b) {}
    }
}

XML3D.flushDOMChanges = function(){
    var records = mutObserver.takeRecords();
    records.length && handleMutations(records);
};

function handleMutations(mutations) {
    for(var i = 0; i < mutations.length; ++i){
        var mutationRecord = mutations[i];
        if (mutationRecord.type === 'attributes') {
            handleAttributeChanged(mutationRecord);
        } else if (mutationRecord.type === 'childList') {
            handleChildListChanged(mutationRecord);
        } else if(mutationRecord.type == 'characterData'){
            handleCharacterDataChanged(mutationRecord);
        }
    }
}

function handleCharacterDataChanged(mutation) {
    var target = mutation.target;
    while(!target._configured && target.parentElement) {
        target = target.parentElement;
    }
    var elementHandler = target._configured;
    if (!elementHandler) {
        return;
    }
    var n = new events.NotificationWrapper(mutation, events.VALUE_MODIFIED, target);
    if (elementHandler.handlers.value !== undefined) {
        elementHandler.handlers.value.resetValue(elementHandler.storage);
    }
    elementHandler.notify(n);
}

function handleChildListChanged(mutation) {
    var addedNodes = mutation.addedNodes;
    for (var i = 0; i < addedNodes.length; i++) {
        if (addedNodes[i].nodeType === Node.TEXT_NODE){
            // This may have been the value of eg. a float3 element, we should treat it as a characterDataChanged event
            handleCharacterDataChanged(mutation);
            continue;
        }
        handleNodeInserted(addedNodes[i], mutation);
    }

    var removedNodes = mutation.removedNodes;
    for (var i=0; i < removedNodes.length; i++) {
        if (removedNodes[i].nodeType === Node.TEXT_NODE){
            continue; // characterDataChanged events were already handled in addedNodes
        }
        handleNodeRemoved(removedNodes[i], mutation);
    }
}

function handleNodeInserted(node, mutation) {
    if (!node.parentNode) {
        return; //Node may have been subsequently removed again in a mutation event that we haven't processed yet
    }
    var targetHandler = mutation.target._configured;
    if (!targetHandler) {
        return;
    }
    config.element(node);
    addRecursive(node);
    var n = new events.NotificationWrapper(mutation, events.NODE_INSERTED, node);
    targetHandler.notify(n);
}

function handleNodeRemoved(node, mutation) {
    var targetHandler = mutation.target._configured;
    if (!targetHandler) {
        return;
    }
    var n = new events.NotificationWrapper(mutation, events.NODE_REMOVED, node);
    targetHandler.notify(n);
    if(node._configured) {
        n.type = events.THIS_REMOVED;
        removeRecursive(node, n);
    } else if (node.nodeType === Node.TEXT_NODE){
        // This may have been the value of eg. a float3 element, we should also treat it as a characterDataChanged event
        handleCharacterDataChanged(mutation);
    }
}

function removeRecursive(element, evt) {
    if(element._configured) {
        Resource.notifyNodeIdChange(element, element.id, null);
        element._configured.notify(evt);
        delete element._configured;
    }
    var child = element.firstElementChild;
    while(child) {
        removeRecursive(child, evt);
        child = child.nextElementSibling;
    }
}

function addRecursive(element){
    var n = element.firstElementChild;
    while(n) {
        addRecursive(n);
        n = n.nextElementSibling;
    }
    // We call this here in addition to nodeInsertedIntoDocument, since the later is not supported by Firefox
    Resource.notifyNodeIdChange(element, null, element.id);
}

/**
 *
 * @param {MutationRecord} mutation
 */
function handleAttributeChanged(mutation) {
    var target = mutation.target;
    var elementHandler = target._configured;
    if (!elementHandler) {
        return;
    }

    var attributeHandler = elementHandler.handlers[mutation.attributeName] || elementHandler.handlers[mutation.attributeName.toLowerCase()];
    if (attributeHandler && attributeHandler.setFromAttribute) {
        var newValue = target.getAttribute(mutation.attributeName);
        var notified = attributeHandler.setFromAttribute(newValue, mutation.oldValue, target, elementHandler.storage);
        XML3D.debug.assert(!notified, "We assume no attribute handler notifies adapters anymore.");
    }
    elementHandler.attributeChangedCallback(mutation);
}


var ElementHandler = function(elem) {
    if (!elem) {
        return;
    }
    this.element = elem;
    this.handlers = null;
    this.storage = {};
    this.adapters = {};
    mutObserver.observe(elem, { childList: true,  attributes: true, attributeOldValue: true} );

};

ElementHandler.prototype.registerAttributes = function(config) {
    var elem = this.element;

    var isHTML = (elem instanceof HTMLElement);
    var keyPrefix = (isHTML ? "_html" : "_xml");
    var handlerKey = keyPrefix + "handlers",
        protoKey = keyPrefix + "proto";

    var canProto = !!elem.__proto__;

    if(!config._cache) config._cache = {};

    if(!config._cache[handlerKey]){
        // Create handlers and prototype only once per configuration
        var proto;
        if(canProto){
            var F = function () {
            };
            F.prototype = elem.__proto__;
            proto = new F();
        }

        var handlers = {};
        for ( var prop in config) {
            if(prop =="_cache") continue;
            if (config[prop] === undefined) {
                if(proto) delete proto[prop];
            } else {
                if (config[prop].a !== undefined) {
                    var attrName = config[prop].id || prop;
                    var handler = new config[prop].a(attrName, config[prop].params);
                    handlers[attrName.toLowerCase()] = handler;
                    if(proto) {
                        try {
                            Object.defineProperty(proto, prop, handler.desc);
                        } catch (e) {
                            XML3D.debug.logWarning("Can't configure " + elem.nodeName + "::" + prop);
                        }
                    }

                } else if (config[prop].m !== undefined) {
                    if(proto) proto[prop] = config[prop].m;
                } else if (config[prop].p !== undefined) {
                    if(proto){
                        try {
                            Object.defineProperty(proto, prop, config[prop].p);
                        } catch (e) {
                            XML3D.debug.logWarning("Can't configure " + elem.nodeName + "::" + prop);
                        }
                    }
                }else
                    XML3D.debug.logError("Can't configure " + elem.nodeName + "::" + prop);
            }
        }
        config._cache[handlerKey] = handlers;
        config._cache[protoKey] = proto;
    }
    // Set and initialize handlers for element
    this.handlers = config._cache[handlerKey];
    if(canProto){
        elem.__proto__ = config._cache[protoKey];
        for ( var prop in config) {
            if(prop =="_cache") continue;
            if(config[prop] && config[prop].a !== undefined){
                var attrName = config[prop].id || prop;
                var handler = this.handlers[attrName.toLowerCase()];
                handler.init && handler.init(elem, this.storage);
                delete elem[prop];
            }
        }
    }
    else{
        for ( var prop in config) {
            if(prop =="_cache") continue;
            if (config[prop] === undefined) {
                delete elem[prop];
            }
            else if (config[prop].a !== undefined){
                var attrName = config[prop].id || prop;
                var handler = this.handlers[attrName.toLowerCase()];
                handler.init && handler.init(elem, this.storage);
                try {
                    Object.defineProperty(elem, prop, handler.desc);
                } catch (e) {
                    XML3D.debug.logWarning("Can't configure " + elem.nodeName + "::" + prop);
                }
            }else if (config[prop].m !== undefined) {
                elem[prop] = config[prop].m;
            } else if (config[prop].p !== undefined) {
                try {
                    Object.defineProperty(elem, prop, config[prop].p);
                } catch (e) {
                    XML3D.debug.logWarning("Can't configure " + elem.nodeName + "::" + prop);
                }
            }
        }
    }

    return elem;
};


ElementHandler.prototype.registerMixed = function() {
    mutObserver.observe(this.element, { childList: true,  attributes: true, attributeOldValue: true, characterData: true, subtree: true} );
};

/**
 * @param evt
 */
ElementHandler.prototype.notify =  function(evt) {
    var adapters = this.adapters;
    for(var a in adapters) {
        try {
            adapters[a].notifyChanged(evt);
        } catch (e) {
            XML3D.debug.logException(e);
        }
    }
};

/**
 * @param {MutationRecord} mutation
 */
ElementHandler.prototype.attributeChangedCallback =  function(mutation) {
    var adapters = this.adapters;
    for(var a in adapters) {
        XML3D.debug.assert(adapters[a].attributeChangedCallback, "Adapter implements 'attributeChangedCallback': " + this.element.nodeName + " (" + a + ")");
        try {
            adapters[a].attributeChangedCallback(mutation.attributeName, mutation.oldValue, this.element.getAttribute(mutation.attributeName), mutation.attributeNamespace);
        } catch (e) {
            XML3D.debug.logException(e);
        }
    }
};

/*
 * Get called, if the related node gets removed from the DOM
 */
ElementHandler.prototype.remove = function(evt) {
    for(var h in this.adapters) {
        var adapter = this.adapters[h];
        if(adapter.dispose)
            adapter.dispose();
        if(adapter.clearAdapterHandles)
            adapter.clearAdapterHandles();
    }
    this.adapters = {};
    for(var h in this.handlers) {
        var handler = this.handlers[h];
        if(handler.remove)
            handler.remove();
    }

};

ElementHandler.prototype.toString = function() {
    return "ElementHandler ("+this.element.nodeName + ", id: "+this.element.id+")";
};

var delegateProperties = ["clientHeight", "clientLeft", "clientTop", "clientWidth",
    "offsetHeight", "offsetLeft", "offsetTop", "offsetWidth"];
function delegateProp(name, elem, canvas) {
    var desc = {
        configurable : true,
        get : function() {
            return canvas[name];
        }
    };
    try {
        Object.defineProperty(elem, name, desc);
    } catch (e){
        XML3D.debug.logWarning("Can't configure " + elem.nodeName + "::" + name);
    }
}

var XML3DHandler = function(elem) {
    ElementHandler.call(this, elem);
    var c = document.createElement("canvas");
    c.width = 800;
    c.height = 600;
    this.canvas = c;
    this.canvasHandler = { destroy:function() {} };

    for(var i in delegateProperties) {
        delegateProp(delegateProperties[i], elem, c);
    }

    elem.getBoundingClientRect = function() {
        return c.getBoundingClientRect();
    };

    this.destroy = function() {
        for(var i in delegateProperties) {
            delete elem[delegateProperties[i]];
        }
        this.canvasHandler.destroy();
    }
};

XML3D.createClass(XML3DHandler, ElementHandler);


var config = {};

/**
 * @param {Element} element
 * @return {undefined}
 */
config.element = function(element) {
    if (element._configured === undefined ) {
        var classInfo = ClassInfo[element.localName];
        if (classInfo === undefined) {
            XML3D.debug.logInfo("Unrecognised element " + element.localName);
        } else {
            element._configured = element.localName == "xml3d" ?
                new XML3DHandler(element)
                : new ElementHandler(element);
            element._configured.registerAttributes(classInfo);
            // Fix difference in Firefox (undefined) and Chrome (null)
            try{
                if (element.style == undefined)
                    element.style = null;
            }
            catch(e){
                // Firefox throws exception here...
            }

            var n = element.firstElementChild;

            Resource.notifyNodeIdChange(element, null, element.getAttribute("id"));

            while(n) {
                config.element(n);
                n = n.nextElementSibling;
            }
        }
    }
};

/**
 * @param {Element} element
 * @return {undefined}
 */
config.configure = function(element) {
    if (Array.isArray(element)) {
        element.forEach(function(el) {
            config.element(el);
        });
    } else {
        config.element(element);
    }
};


module.exports = {
    ElementHandler : ElementHandler,
    XML3DHandler : XML3DHandler,
    config : config
};

},{"../resource":165,"./configuration.js":70,"./notification.js":74}],73:[function(require,module,exports){
var sendAdapterEvent = require("../utils/misc.js").sendAdapterEvent;
var callAdapterFunc = require("../utils/misc.js").callAdapterFunc;
var CSS = require("../utils/css.js");
var Resource = require("../resource");

var Vec3 = require("../types/vec3.js");
var Mat4 = require("../types/mat4.js");
var vec3 = require("gl-matrix").vec3;

var methods = {};

methods.xml3dGetElementByRay = function(ray, hitPoint, hitNormal) {
    XML3D.flushDOMChanges();
    XML3D.flushCSSChanges();
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].getElementByRay) {
            return adapters[adapter].getElementByRay(ray, hitPoint, hitNormal);
        }
    }
    return null;
};

methods.viewGetViewMatrix = function() {
    XML3D.flushDOMChanges();
    var adapters = this._configured.adapters || {};
    for ( var adapter in adapters) {
        if (adapters[adapter].getViewMatrix) {
            return adapters[adapter].getViewMatrix();
        }
    }
    // Fallback implementation
    var result = new XML3D.Mat4();
    var cssMatrix = CSS.getCSSMatrix(this);
    if(cssMatrix) {
        CSS.convertCssToMat4(cssMatrix, result);
    }
    return result.invert();
};

methods.viewGetProjectionMatrix = function() {
    XML3D.flushDOMChanges();
    var adapters = this._configured.adapters || {};
    for ( var adapter in adapters) {
        if (adapters[adapter].getProjectionMatrix) {
            return adapters[adapter].getProjectionMatrix();
        }
    }
    return null;
};

methods.xml3dGetElementByPoint = function(x, y, hitPoint, hitNormal) {
    XML3D.flushDOMChanges();
    XML3D.flushCSSChanges();
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].getElementByPoint) {
            return adapters[adapter].getElementByPoint(x, y, hitPoint, hitNormal);
        }
    }
    return null;
};

methods.xml3dGenerateRay = function(x, y) {
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].generateRay) {
            return adapters[adapter].generateRay(x, y);
        }
    }
    return new XML3D.Ray();
};

/**
 * return the bounding box of the owning space in world space
 */
methods.getWorldBoundingBox = function() {
    XML3D.flushDOMChanges();
    // Visibility influences bounding box
    XML3D.flushCSSChanges();
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].getWorldBoundingBox) {
            return adapters[adapter].getWorldBoundingBox();
        }
    }
    return new XML3D.Box();
};

/**
 * return the bounding box of the owning space in local space (object BB)
 */
methods.getLocalBoundingBox = function() {
    XML3D.flushDOMChanges();
    // Visibility influences bounding box
    XML3D.flushCSSChanges();
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].getLocalBoundingBox) {
            return adapters[adapter].getLocalBoundingBox();
        }
    }
    return new XML3D.Box();
};

methods.xml3dGetRenderInterface = function() {
    XML3D.flushDOMChanges();
    var adapters = this._configured.adapters || {};
    for ( var adapter in adapters) {
        if (adapters[adapter].getRenderInterface) {
            return adapters[adapter].getRenderInterface();
        }
    }
    return {};
};


methods.XML3DGraphTypeGetWorldMatrix = function() {
    XML3D.flushDOMChanges();
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].getWorldMatrix) {
            return adapters[adapter].getWorldMatrix();
        }
    }
    return new Mat4();
};

methods.XML3DGraphTypeGetLocalMatrix = function() {
    XML3D.flushDOMChanges();
    var adapters = this._configured.adapters || {};
    for ( var adapter in adapters) {
        if (adapters[adapter].getLocalMatrix) {
            return adapters[adapter].getLocalMatrix();
        }
    }
    return new Mat4();
};

methods.videoPlay = function() {
    sendAdapterEvent(this, {play: []});
};

methods.videoPause = function() {
    sendAdapterEvent(this, {pause: []});
};

methods.XML3DNestedDataContainerTypeGetOutputNames =
methods.XML3DShaderProviderTypeGetOutputNames =
methods.meshGetOutputNames = function() {
    XML3D.flushDOMChanges();
    var dataAdapter = Resource.getAdapter(this, "data");
    if(dataAdapter){
        return dataAdapter.getOutputNames();
    }
    return null;
};

methods.XML3DNestedDataContainerTypeGetResult =
methods.XML3DShaderProviderTypeGetResult =
methods.meshGetResult = function(filter) {
    XML3D.flushDOMChanges();
    var dataAdapter = Resource.getAdapter(this, "data");
    if(dataAdapter){
        var result = dataAdapter.getComputeResult(filter);
        if(!result) return null;
        return new window.XML3DDataResult(result);
    }
    return null;
};

methods.XML3DNestedDataContainerTypeGetOutputChannelInfo =
    methods.XML3DShaderProviderTypeGetOutputChannelInfo =
        methods.meshGetOutputChannelInfo = function (name) {
            XML3D.flushDOMChanges();
            var dataAdapter = Resource.getAdapter(this, "data");
            if (dataAdapter) {
                var result = dataAdapter.getOutputChannelInfo(name);
                if (!result) return null;
                return new window.XML3DDataChannelInfo(result.type, result.origin, result.originalName,
                    result.seqLength, result.seqMinKey, result.seqMaxKey);
            }
            return null;
        };

function createValues(result, names) {
    var values = {};
    for (var i in names) {
        var name = names[i];
        var data = result.getOutputData(name) && result.getOutputData(name).getValue();
        if (data)
            values[name] = data;
    }
    return values;
}

/** Register data listener for data fields specified by names.
 *
 * @param names   single name or array of names that are monitored.
 * @param callback function that is called when selected data are changed.
 * @return {Boolean}
 */
methods.dataAddOutputFieldListener = function(names, callback) {
    XML3D.flushDOMChanges();
    if (!names)
        return false;

    // check if names is a single string, and convert it to array then
    var typeOfNames = Object.prototype.toString.call(names).slice(8, -1);
    if (typeOfNames === "String") {
        names = [names];
    }
    if (names.length == 0)
        return false;

    var request = callAdapterFunc(this, {
        getComputeRequest : [names, function(request, changeType) {
            callback(createValues(request.getResult(), names));
        }
        ]});
    if (request.length == 0)
        return false;
    var result = request[0].getResult();
    var values = createValues(result, names);
    if (Object.keys(values).length)
        callback(values);
    return true;
};

methods.XML3DDataSourceTypeSetScriptValue = function(data){
    var configData = this._configured;

    if(!configData)
        return;

    if(this.textContent != "[value set by script]")
        this.textContent = "[value set by script]";
    XML3D.flushDOMChanges();
    configData.scriptValue = data;

    var dataAdapter = Resource.getAdapter(this, "data");
    if(dataAdapter)
        dataAdapter.setScriptValue(data);

};

module.exports = methods;

},{"../resource":165,"../types/mat4.js":172,"../types/vec3.js":176,"../utils/css.js":179,"../utils/misc.js":182,"gl-matrix":1}],74:[function(require,module,exports){

/**
 * Types of change events
 * @enum {number}
 */
var events = {
      NODE_INSERTED: 0,
      VALUE_MODIFIED:  1,
      NODE_REMOVED: 2,
      THIS_REMOVED: 3,
      ADAPTER_HANDLE_CHANGED: 4,
      ADAPTER_VALUE_CHANGED: 5
};

//-----------------------------------------------------------------------------
//Class Notification
//-----------------------------------------------------------------------------
events.Notification = function(type) {
    this.type = type;
};
events.Notification.prototype.toString = function() {
    return "Notification (type:" + this.type + ")";
};
//-----------------------------------------------------------------------------
events.NotificationWrapper = function(mutation, type, affectedNode) {
    this.mutation = mutation;
    this.type = type;
    this.affectedNode = affectedNode;
};
XML3D.createClass(events.NotificationWrapper, events.Notification);
events.NotificationWrapper.prototype.toString = function() {
    return "NotificationWrapper (type:" + this.type + ", wrapped: "+ this.mutation +")";
};

//-----------------------------------------------------------------------------

/**
 * @param {AdapterHandle} handle
 * @param {int} type
 * @constructor
 */
events.AdapterHandleNotification = function (handle, type) {
    this.adapterHandle = handle;
    this.type = type;
};
XML3D.createClass(events.AdapterHandleNotification, events.Notification);
events.AdapterHandleNotification.prototype.toString = function () {
    return "AdapterHandleNotification (type:" + this.type + ")";
};
//-----------------------------------------------------------------------------

events.ConnectedAdapterNotification = function(adapterHandleNotification, key) {
    this.adapter = adapterHandleNotification.adapterHandle.getAdapter();
    this.key = key;
    this.url = adapterHandleNotification.adapterHandle.url;
    this.type = adapterHandleNotification.type;
    this.handleStatus = adapterHandleNotification.adapterHandle.status;
};
XML3D.createClass(events.ConnectedAdapterNotification, events.Notification);
events.ConnectedAdapterNotification.prototype.toString = function() {
    return "ConnectedAdapterNotification (type:" + this.type + ", key: " + this.key + ")";
};

module.exports = events;
},{}],75:[function(require,module,exports){
var properties = {};

properties.XML3DNestedDataContainerTypeComplete = {
    get: function(){
        XML3D.flushDOMChanges();
        var adapters = this._configured.adapters || {};
        for (var adapter in adapters) {
            if (adapters[adapter].getDataComplete) {
                return adapters[adapter].getDataComplete();
            }
        }
        return false;
    },
    set: function(){}
};

properties.AssetComplete = {
    get: function(){
        XML3D.flushDOMChanges();
        var adapters = this._configured.adapters || {};
        for (var adapter in adapters) {
            if (adapters[adapter].getAssetComplete) {
                return adapters[adapter].getAssetComplete();
            }
        }
        return false;
    },
    set: function(){}
};


properties.AssetProgressLevel = {
    get: function(){
        XML3D.flushDOMChanges();
        var adapters = this._configured.adapters || {};
        for (var adapter in adapters) {
            if (adapters[adapter].getAssetProgressLevel) {
                return adapters[adapter].getAssetProgressLevel();
            }
        }
        return false;
    },
    set: function(){}
};

properties.xml3dComplete = {
    get: function(){
        XML3D.flushDOMChanges();
        var adapters = this._configured.adapters || {};
        for (var adapter in adapters) {
            if (adapters[adapter].getComplete) {
                return adapters[adapter].getComplete();
            }
        }
        return false;
    },
    set: function(){}
};

module.exports = properties;

},{}],76:[function(require,module,exports){
module.exports = function (math) {

// Additional methods in glMatrix style
    math.vec3.reciprocal = function (dest, vec) {
        if (!dest) {
            dest = vec;
        }

        dest[0] = 1 / vec[0];
        dest[1] = 1 / vec[1];
        dest[2] = 1 / vec[2];
        return dest;
    };

    var toDOMString = function(data) {
        return Array.prototype.join.call(data, ' ');
    };

    math.vec2.toDOMString = toDOMString;

    math.vec2.fromDOMString = function(str) {
        var s = str.split(' ');
        if (s.length !== 2 || isNaN(+s[0]) || isNaN(+s[1])) {
            throw "Could not parse '"+str+"' into a valid vec2 object";
        }
        return math.vec2.fromValues(+s[0], +s[1]);
    };

    math.vec3.toDOMString = toDOMString;

    math.vec3.fromDOMString = function(str) {
        var s = str.split(' ');
        if (s.length !== 3 || isNaN(+s[0]) || isNaN(+s[1]) || isNaN(+s[2])) {
            throw "Could not parse '"+str+"' into a valid vec3 object";
        }
        return math.vec3.fromValues(+s[0], +s[1], +s[2]);
    };


    math.vec4.toDOMString = toDOMString;

    math.vec4.fromDOMString = function(str) {
        var s = str.split(' ');
        if (s.length !== 4 || isNaN(+s[0]) || isNaN(+s[1]) || isNaN(+s[2]) || isNaN(+s[3])) {
            throw "Could not parse '"+str+"' into a valid vec4 or quat object";
        }
        return math.vec4.fromValues(+s[0], +s[1], +s[2], +s[3]);
    };

    math.quat.toDOMString = toDOMString;

    math.quat.fromDOMString = math.vec4.fromDOMString;

    math.mat3.toDOMString = toDOMString;

    math.mat3.fromDOMString = function(str) {
        var s = str.split(' ');
        if (s.length !== 9) {
            throw "Could not parse '"+str+"' into a valid mat3 object";
        }
        var mat = math.mat3.create();
        for (var i=0; i<9; i++) {
            mat[i] = +s[i];
            if (isNaN(mat[i])) {
                throw "Could not parse '"+str+"' into a valid mat3 object";
            }
        }
        return mat;
    };

    math.mat4.toDOMString = toDOMString;

    math.mat4.fromDOMString = function(str) {
        var s = str.split(' ');
        if (s.length !== 16) {
            throw "Could not parse '"+str+"' into a valid mat4 object";
        }
        var mat = math.mat4.create();
        for (var i=0; i<16; i++) {
            mat[i] = +s[i];
            if (isNaN(mat[i])) {
                throw "Could not parse '"+str+"' into a valid mat4 object";
            }
        }
        return mat;
    };


    math.mat4.multiplyOffsetVec3 = function (mat, matOffset, vec, vecOffset, dest) {
        if (!dest) {
            dest = vec;
        }
        if (!vecOffset) {
            vecOffset = 0;
        }

        var x = vec[vecOffset + 0], y = vec[vecOffset + 1], z = vec[vecOffset + 2];

        dest[0] = mat[matOffset + 0] * x + mat[matOffset + 4] * y + mat[matOffset + 8] * z + mat[matOffset + 12];
        dest[1] = mat[matOffset + 1] * x + mat[matOffset + 5] * y + mat[matOffset + 9] * z + mat[matOffset + 13];
        dest[2] = mat[matOffset + 2] * x + mat[matOffset + 6] * y + mat[matOffset + 10] * z + mat[matOffset + 14];

        return dest;
    };


    math.mat4.multiplyOffsetDirection = function (mat, matOffset, vec, vecOffset, dest) {
        if (!dest) {
            dest = vec;
        }
        if (!vecOffset) {
            vecOffset = 0;
        }

        var x = vec[vecOffset + 0], y = vec[vecOffset + 1], z = vec[vecOffset + 2], w;

        dest[0] = mat[matOffset + 0] * x + mat[matOffset + 4] * y + mat[matOffset + 8] * z;
        dest[1] = mat[matOffset + 1] * x + mat[matOffset + 5] * y + mat[matOffset + 9] * z;
        dest[2] = mat[matOffset + 2] * x + mat[matOffset + 6] * y + mat[matOffset + 10] * z;

        return dest;
    };

    math.mat4.multiplyOffset = function (dest, destOffset, mat, offset1, mat2, offset2) {
        var a00 = mat2[offset2 + 0], a01 = mat2[offset2 + 1], a02 = mat2[offset2 + 2], a03 = mat2[offset2 + 3];
        var a10 = mat2[offset2 + 4], a11 = mat2[offset2 + 5], a12 = mat2[offset2 + 6], a13 = mat2[offset2 + 7];
        var a20 = mat2[offset2 + 8], a21 = mat2[offset2 + 9], a22 = mat2[offset2 + 10], a23 = mat2[offset2 + 11];
        var a30 = mat2[offset2 + 12], a31 = mat2[offset2 + 13], a32 = mat2[offset2 + 14], a33 = mat2[offset2 + 15];

        var b00 = mat[offset1 + 0], b01 = mat[offset1 + 1], b02 = mat[offset1 + 2], b03 = mat[offset1 + 3];
        var b10 = mat[offset1 + 4], b11 = mat[offset1 + 5], b12 = mat[offset1 + 6], b13 = mat[offset1 + 7];
        var b20 = mat[offset1 + 8], b21 = mat[offset1 + 9], b22 = mat[offset1 + 10], b23 = mat[offset1 + 11];
        var b30 = mat[offset1 + 12], b31 = mat[offset1 + 13], b32 = mat[offset1 + 14], b33 = mat[offset1 + 15];

        dest[destOffset + 0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
        dest[destOffset + 1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
        dest[destOffset + 2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
        dest[destOffset + 3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
        dest[destOffset + 4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
        dest[destOffset + 5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
        dest[destOffset + 6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
        dest[destOffset + 7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
        dest[destOffset + 8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
        dest[destOffset + 9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
        dest[destOffset + 10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
        dest[destOffset + 11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
        dest[destOffset + 12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
        dest[destOffset + 13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
        dest[destOffset + 14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
        dest[destOffset + 15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;
    };

    math.quat.slerpOffset = function (quat, offset1, quat2, offset2, t, dest, destOffset, shortest) {
        if (!dest) {
            dest = quat;
        }

        var ix1 = offset1, iy1 = offset1 + 1, iz1 = offset1 + 2, iw1 = offset1 + 3;
        var ix2 = offset2, iy2 = offset2 + 1, iz2 = offset2 + 2, iw2 = offset2 + 3;
        var ixd = destOffset, iyd = destOffset + 1, izd = destOffset + 2, iwd = destOffset + 3;

        var cosAngle = quat[ix1] * quat2[ix2] + quat[iy1] * quat2[iy2] + quat[iz1] * quat2[iz2] + quat[iw1] * quat2[iw2];

        var c1, c2;

        // Linear interpolation for close orientations
        if ((1.0 - Math.abs(cosAngle)) < 0.01) {
            c1 = 1.0 - t;
            c2 = t;
        } else {
            // Spherical interpolation
            var angle = Math.acos(Math.abs(cosAngle));
            var sinAngle = Math.sin(angle);
            c1 = Math.sin(angle * (1.0 - t)) / sinAngle;
            c2 = Math.sin(angle * t) / sinAngle;
        }

        // Use the shortest path
        if (shortest && (cosAngle < 0.0))
            c1 = -c1;

        dest[ixd] = c1 * quat[ix1] + c2 * quat2[ix2];
        dest[iyd] = c1 * quat[iy1] + c2 * quat2[iy2];
        dest[izd] = c1 * quat[iz1] + c2 * quat2[iz2];
        dest[iwd] = c1 * quat[iw1] + c2 * quat2[iw2];
    };

    math.quat.fromAxisAngle = function(axis, angle) {
        var q = math.quat.create();
        if (axis.length === 4 && angle === undefined) {
            math.quat.setAxisAngle(q, axis, axis[3]);
        } else {
            math.quat.setAxisAngle(q, axis, angle);
        }
        return math.quat.normalize(q,q);
    };

    /**
     * Transforms the vec3 with a mat4.
     * 4th vector component is implicitly '0'
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the vector to transform
     * @param {mat4} m matrix to transform with
     * @returns {vec3} out
     */
    math.vec3.transformDirection = function(out, a, m) {
        var x = a[0], y = a[1], z = a[2];
        out[0] = (m[0] * x + m[4] * y + m[8] * z);
        out[1] = (m[1] * x + m[5] * y + m[9] * z);
        out[2] = (m[2] * x + m[6] * y + m[10] * z);
        return out;
    };

    math.quat.setFromMat3 = function(dest, m) {
        var tr = m[0] + m[4] + m[8];

        if (tr > 0) {
            var s = Math.sqrt(tr + 1.0) * 2; // s=4*dest[3]
            dest[0] = (m[7] - m[5]) / s;
            dest[1] = (m[2] - m[6]) / s;
            dest[2] = (m[3] - m[1]) / s;
            dest[3] = 0.25 * s;
        } else if ((m[0] > m[4]) && (m[0] > m[8])) {
            var s = Math.sqrt(1.0 + m[0] - m[4] - m[8]) * 2; // s=4*qx
            dest[3] = (m[7] - m[5]) / s;
            dest[0] = 0.25 * s;
            dest[1] = (m[1] + m[3]) / s;
            dest[2] = (m[2] + m[6]) / s;
        } else if (m[4] > m[8]) {
            var s = Math.sqrt(1.0 + m[4] - m[0] - m[8]) * 2; // s=4*qy
            dest[3] = (m[2] - m[6]) / s;
            dest[0] = (m[1] + m[3]) / s;
            dest[1] = 0.25 * s;
            dest[2] = (m[5] + m[7]) / s;
        } else {
            var s = Math.sqrt(1.0 + m[8] - m[0] - m[4]) * 2; // s=4*qz
            dest[3] = (m[3] - m[1]) / s;
            dest[0] = (m[2] + m[6]) / s;
            dest[1] = (m[5] + m[7]) / s;
            dest[2] = 0.25 * s;
        }
        return dest;
    };

    math.quat.setFromBasis = function(dest, X,Y,Z) {
        var lx = 1.0 / XML3D.math.vec3.length(X);
        var ly = 1.0 / XML3D.math.vec3.length(Y);
        var lz = 1.0 / XML3D.math.vec3.length(Z);
        var m = XML3D.math.mat3.create();
        m[0] = X[0] * lx;
        m[1] = Y[0] * ly;
        m[2] = Z[0] * lz;
        m[3] = X[1] * lx;
        m[4] = Y[1] * ly;
        m[5] = Z[1] * lz;
        m[6] = X[2] * lx;
        m[7] = Y[2] * ly;
        m[8] = Z[2] * lz;
        return XML3D.math.quat.setFromMat3(dest, m);
    };

    math.vec4.fromQuat = function(q) {
        var dest = XML3D.math.vec4.create();
        if (q[3] > 1) {
            XML3D.math.quat.normalize(q,q);
        }
        var s = Math.sqrt(1-q[3]*q[3]);
        var angle = 2*Math.acos(q[3]);
        if (s < 0.0001) {
            // Axis is practically 0 so we return the identity axis angle
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 1;
            dest[3] = 0;
        } else {
            dest[0] = q[0] / s;
            dest[1] = q[1] / s;
            dest[2] = q[2] / s;
            dest[3] = angle;
        }
        return dest;
    };


};

},{}],77:[function(require,module,exports){
var NodeAdapter = require("../../../base/adapter.js").NodeAdapter;

var RenderAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
};

XML3D.createClass(RenderAdapter, NodeAdapter, {

    getParentRenderAdapter: function () {
        return this.factory.getAdapter(this.node.parentNode, RenderAdapter);
    },

    /**
     * @param element
     */
    initElement: function (element) {
        this.factory.getAdapter(element);
        this.initChildElements(element);
    },

    /**
     * @param {Element} element
     */
    initChildElements: function (element) {
        var child = element.firstElementChild;
        while (child) {
            this.initElement(child);
            child = child.nextElementSibling;
        }
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
    },

    styleChangedCallback: function () {
    },

    getScene: function () {
        return this.factory.renderer.scene;
    }
});

module.exports = RenderAdapter;

},{"../../../base/adapter.js":48}],78:[function(require,module,exports){
var RenderAdapter = require("./base.js");

//Adapter for <defs>
var DefsRenderAdapter = function (factory, node) {
    RenderAdapter.call(this, factory, node);
};
XML3D.createClass(DefsRenderAdapter, RenderAdapter);

module.exports = DefsRenderAdapter;

},{"./base.js":77}],79:[function(require,module,exports){
var NodeAdapterFactory = require("../../../base/adapter.js").NodeAdapterFactory;

/**
 * @constructor
 * @implements {XML3D.base.IFactory}
 * @extends XML3D.base.NodeAdapterFactory
 * @param {number} canvasId
 */
var RenderAdapterFactory = function (canvasId) {
    NodeAdapterFactory.call(this, "scene", canvasId);
    this.type = "RenderAdapterFactory";
};
XML3D.createClass(RenderAdapterFactory, NodeAdapterFactory);

var registry = {
        xml3d: require("./xml3d.js"),
        view: require("./view.js"),
        defs: require("./defs.js"),
        mesh: require("./mesh.js"),
        model: require("./model.js"),
        material: require("./material.js"),
        shader: require("./material.js"), // TODO(ksons): Remove in 5.1
        group: require("./group.js"),
        light: require("./light.js"),
        lightshader: require("./lightshader.js") // TODO(ksons): Remove in 5.1
    };

/**
 * @param node
 * @return {XML3D.base.Adapter|null}
 */
RenderAdapterFactory.prototype.createAdapter = function (node) {
    var adapterConstructor = registry[node.localName];
    if (adapterConstructor !== undefined) {
        return new adapterConstructor(this, node);
    }
    return null;
};

RenderAdapterFactory.prototype.setScene = function (scene) {
    this.scene = scene;
};

RenderAdapterFactory.prototype.getScene = function () {
    return this.scene;
};

RenderAdapterFactory.prototype.setRenderer = function (renderer) {
    this.renderer = renderer;
};

RenderAdapterFactory.prototype.getRenderer = function () {
    return this.renderer;
};

// Export
module.exports = RenderAdapterFactory;

},{"../../../base/adapter.js":48,"./defs.js":78,"./group.js":80,"./light.js":81,"./lightshader.js":82,"./material.js":83,"./mesh.js":84,"./model.js":85,"./view.js":87,"./xml3d.js":88}],80:[function(require,module,exports){
var SceneElementAdapter = require("./scene-element.js");
var Events = require("../../../interface/notification.js");
var mat4 = require("gl-matrix").mat4;

var GroupRenderAdapter = function (factory, node) {
    SceneElementAdapter.call(this, factory, node, true, true);
    this.createRenderNode();
};

XML3D.createClass(GroupRenderAdapter, SceneElementAdapter, {

    createRenderNode: function () {
        var parent = this.getParentRenderAdapter();
        var parentNode = parent.getRenderNode && parent.getRenderNode();
        this.renderNode = this.getScene().createRenderGroup({
            parent: parentNode, name: this.node.id
        });
        this.updateLocalMatrix();
        this.updateMaterialHandler();
        this.updateVisibility();
        this.renderNode.setWorldSpaceBoundingBox(new XML3D.Box());
    },

    /* Interface methods */
    getWorldBoundingBox: function () {
        var bbox = new XML3D.Box();
        this.renderNode.getWorldSpaceBoundingBox(bbox);
        return bbox;
    },

    getLocalBoundingBox: (function () {
        var localMat = mat4.create();
        var childBB = new XML3D.Box();

        return function () {
            var bbox = new XML3D.Box();
            Array.prototype.forEach.call(this.node.childNodes, function (c) {
                if (c.getLocalBoundingBox) {
                    childBB = c.getLocalBoundingBox();
                    bbox.extend(childBB);
                }
            });
            this.renderNode.getLocalMatrix(localMat);
            bbox.transformAxisAligned(localMat);
            return bbox;
        }
    })(),

    getLocalMatrix: function () {
        var m = new XML3D.Mat4();
        this.renderNode.getLocalMatrix(m.data);
        return m;
    },

    getWorldMatrix: function () {
        var m = new XML3D.Mat4();
        this.renderNode.getWorldMatrix(m.data);
        return m;
    }
});

module.exports = GroupRenderAdapter;

},{"../../../interface/notification.js":74,"./scene-element.js":86,"gl-matrix":1}],81:[function(require,module,exports){
var SceneElementAdapter = require("./scene-element.js");

var Events = require("../../../interface/notification.js");
var LightConfiguration = require("../scene/configuration.js");
var Resource = require("../../../resource");

var DEFAULT_LIGHT_MODEL = "urn:xml3d:light:directional";
/**
 * Adapter for <light>
 * @constructor
 * @param {RenderAdapterFactory} factory
 * @param {Element} node
 */
var LightRenderAdapter = function (factory, node) {
    SceneElementAdapter.call(this, factory, node, false, true);
    this.dataAdapter = Resource.getAdapter(node, "data");
    this.createRenderNode();
};

XML3D.createClass(LightRenderAdapter, SceneElementAdapter, {

    createRenderNode: function () {
        var parentAdapter = this.getParentRenderAdapter();
        var parentNode = parentAdapter.getRenderNode && parentAdapter.getRenderNode();
        this.renderNode = this.factory.getScene().createRenderLight({
            configuration: this.createLightConfiguration(),
            parent: parentNode
        });
        this.updateVisibility();
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        SceneElementAdapter.prototype.attributeChangedCallback.call(this, name, oldValue, newValue);

        switch (name) {
            case "intensity": // TODO(ksons): remove in 5.1
                XML3D.debug.logWarning("The <light> attribute intensity is deprecated in XML3D 5.0.", this.node);
                break;
            case "model":
                this.renderNode.remove();
                this.createRenderNode();
                break;
        }
    },

    updateVisibility: function () {
        var none = this.style.getPropertyValue("display").trim() == "none";
        this.renderNode.setLocalVisible(!none);
    },


    notifyChanged: function (evt) {
        switch (evt.type) {
            case Events.NODE_REMOVED:
                return;
            case Events.THIS_REMOVED:
                this.dispose();
                return;
        }
    },

    createLightConfiguration: function () {
        var model = this.node.hasAttribute("model") ? this.node.getAttribute("model") : DEFAULT_LIGHT_MODEL;
        var opt = {
            name: this.node.id
        };
        return new LightConfiguration(model, this.dataAdapter.getXflowNode(), opt);
    },

    dispose: function () {
        this.getRenderNode().remove();
        this.clearAdapterHandles();
    },

    /**
     * @return {XML3D.Mat4}
     */
    getWorldMatrix: function () {
        var m = new XML3D.Mat4();
        this.renderNode.getWorldMatrix(m.data);
        return m;
    }
});

// Export
module.exports = LightRenderAdapter;


},{"../../../interface/notification.js":74,"../../../resource":165,"../scene/configuration.js":97,"./scene-element.js":86}],82:[function(require,module,exports){
var RenderAdapter = require("./base.js");

/**
 * Adapter for <lightshader>
 * TODO(ksons): Remove in 5.1
 * @constructor
 * @param {RenderAdapterFactory} factory
 * @param {Element} node
 * @extends RenderAdapter
 */
var LightShaderRenderAdapter = function (factory, node) {
    RenderAdapter.call(this, factory, node);
    XML3D.debug.logWarning("The <lightshader> element is deprecated in XML3D 5.0.", node);
};

// Export
module.exports = LightShaderRenderAdapter;


},{"./base.js":77}],83:[function(require,module,exports){
var RenderAdapter = require("./base.js");
var Events = require("../../../interface/notification.js");
var URI = require("../../../utils/uri.js").URI;
var AdapterHandle = require("../../../base/adapterhandle.js");
var Resource = require("../../../resource");

/**
 * @param factory
 * @param {Element} node
 * @extends RenderAdapter
 * @constructor
 */
var MaterialRenderAdapter = function (factory, node) {
    RenderAdapter.call(this, factory, node);
    this._dataAdapter = Resource.getAdapter(node, "data");
    /** @type MaterialConfiguration | null **/
    this._materialConfiguration = null;
    this._materialModel = null;

    this.updateMaterialConfiguration();
};

XML3D.createClass(MaterialRenderAdapter, RenderAdapter,  {

    getMaterialConfiguration: function() {
        return this._materialConfiguration;
    },

    updateMaterialConfiguration: function () {
        // First find the model
        this.updateMaterialModel();
        if (!this._materialModel) {
            this._materialConfiguration = null;
        } else {
            this._materialConfiguration = this.getScene().createMaterialConfiguration(this._materialModel, this._dataAdapter.getXflowNode(), {name: this.node.id});
        }
        this.notifyOppositeAdapters();
    },

    updateMaterialModel: function () {
        this._materialModel = null;

        var uri = this.getMaterialModel();
        if (uri.scheme == "urn") {
            this.disconnectAdapterHandle("model");
            this._materialModel = { "type": "urn", "urn": uri };
            return;
        }

        this.connectAdapterHandle("model", this.getAdapterHandle(uri, "data", 0));
        var adapter = this.getConnectedAdapter("model");
        if (adapter && adapter.getScriptType) {
            this._materialModel = { type: adapter.getScriptType(), script: adapter.getScript() };
        }
    },

    getMaterialModel: function () {
        return new URI(this.node.getAttribute("model"));
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        if (name == "model") {
            this.updateMaterialConfiguration();
        }
    },

    notifyChanged: function (evt) {
        switch (evt.type) {
            case Events.ADAPTER_HANDLE_CHANGED:
                if (evt.handleStatus == AdapterHandle.STATUS.NOT_FOUND) {
                    XML3D.debug.logError("Could not find material for url '" + evt.url + "'");

                }
                this.updateMaterialConfiguration();
                break;
        }
    }
});

// Export
module.exports = MaterialRenderAdapter;


},{"../../../base/adapterhandle.js":49,"../../../interface/notification.js":74,"../../../resource":165,"../../../utils/uri.js":184,"./base.js":77}],84:[function(require,module,exports){
var SceneElementAdapter = require("./scene-element.js");

var Events = require("../../../interface/notification.js");
var encodeZIndex = require("../../../utils/misc.js").encodeZIndex;
var Resource = require("../../../resource");

var DEFAULT_PRIMITIVE_TYPE = "triangles";

/**
 * @constructor
 */
var MeshRenderAdapter = function (factory, node) {
    SceneElementAdapter.call(this, factory, node, true, true);
    this.createRenderNode();
};

XML3D.createClass(MeshRenderAdapter, SceneElementAdapter, {

    createRenderNode: function () {
        var parent = this.getParentRenderAdapter();
        var parentNode = parent.getRenderNode && parent.getRenderNode();

        this.renderNode = this.getScene().createRenderObject({
            parent: parentNode,
            node: this.node,
            configuration: this.createMeshConfiguration(),
            name: this.node.id
        });
        this.updateZIndex();
        this.updateVisibility();
        this.updateLocalMatrix();
        this.updateMaterialHandler();
    },

    createMeshConfiguration: function () {
        return {
            data: Resource.getAdapter(this.node, "data").getXflowNode(),
            type: this.node.hasAttribute("type") ? this.node.getAttribute("type") : DEFAULT_PRIMITIVE_TYPE
        }
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        SceneElementAdapter.prototype.attributeChangedCallback.call(this, name, oldValue, newValue);
        if (name == "type") {
            this.renderNode.remove();
            this.createRenderNode();
        }
    },

    updateZIndex: function() {
        var zIndex = this.style.getPropertyValue("z-index");
        zIndex = encodeZIndex(zIndex, true);

        var parent = this.getParentRenderAdapter();
        while (parent) {
            if (parent.style) {
                var parentZ = parent.style.getPropertyValue("z-index");
                parentZ = encodeZIndex(parentZ, false);
                if (parentZ != "")
                    zIndex = parentZ + ":" + zIndex;
            }
            parent = parent.getParentRenderAdapter();
        }

        this.renderNode.setZIndex(zIndex);
    },

    /**
     * @param {Events.Notification} evt
     */
    notifyChanged: function (evt) {
        SceneElementAdapter.prototype.notifyChanged.call(this, evt);
    },

    // Interface methods

    /**
     * @return {XML3D.Box}
     */
    getLocalBoundingBox: function () {
        var bbox = new XML3D.Box();
        if (this.renderNode && this.renderNode.visible) {
            this.renderNode.getObjectSpaceBoundingBox(bbox);
        }
        return bbox;
    },

    /**
     * @return {XML3D.Box}
     */
    getWorldBoundingBox: function () {
        var bbox = new XML3D.Box();
        if (this.renderNode && this.renderNode.visible) {
            this.renderNode.getWorldSpaceBoundingBox(bbox);
        }
        return bbox;
    },

    /**
     * @return {mat4}
     */
    getWorldMatrix: function () {
        var m = new XML3D.Mat4(), obj = this.renderNode;
        if (obj) {
            obj.getWorldMatrix(m.data);
        }
        return m;
    }
});

// Export
module.exports = MeshRenderAdapter;


},{"../../../interface/notification.js":74,"../../../resource":165,"../../../utils/misc.js":182,"./scene-element.js":86}],85:[function(require,module,exports){
var SceneElementAdapter = require("./scene-element.js");
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;
var Events = require("../../../interface/notification.js");
var AdapterHandle = require("../../../base/adapterhandle.js");
var encodeZIndex = require("../../../utils/misc.js").encodeZIndex;
var mat4 = require("gl-matrix").mat4;
var Resource = require("../../../resource");


var ModelRenderAdapter = function (factory, node) {
    SceneElementAdapter.call(this, factory, node, false, true);
    this.asset = null;
    this.postTransformXflowRequests = [];
    this.postTransformRenderGroups = [];
    this.createRenderNode();
    this._bindedRequestCallback = this.onXflowRequestChange.bind(this);
    this.transformFetcher.update();
};

var c_IDENTITY = mat4.create();

XML3D.createClass(ModelRenderAdapter, SceneElementAdapter, {

    createRenderNode: function () {
        var dataAdapter = Resource.getAdapter(this.node, "data");
        this.asset = dataAdapter.getAsset();

        this.asset.addChangeListener(this);

        var parent = this.getParentRenderAdapter();
        var parentNode = parent.getRenderNode && parent.getRenderNode();

        this.renderNode = this.getScene().createRenderGroup({
            parent: parentNode, name: this.node.id
        });
        this.renderNode.setLocalMatrix(c_IDENTITY);
        this.createModelRenderNodes();
        this.updateVisibility();
    },

    clearModelRenderNodes: function () {
        this.clearAdapterHandles();
        this._subRenderNodes = [];
        var i = this.postTransformXflowRequests.length;
        while (i--) {
            this.postTransformXflowRequests[i].clear();
        }
        rec_removeRenderNodes(this.renderNode, true);
        this.postTransformXflowRequests.length = 0;
        this.postTransformRenderGroups.length = 0;
    },

    createModelRenderNodes: function () {
        this.clearModelRenderNodes();
        if (!this.asset.isSubtreeLoading()) {
            try {
                this.asset.checkValidity();
                var assetResult = this.asset.getResult();
                var dataTree = assetResult.getDataTree();
                rec_createRenderNodes(this, this.renderNode, dataTree);
                this.updateZIndex();
            } catch (e) {
                XML3D.debug.logError("Asset Error: " + e.message, e.node || this.node);
                this.clearModelRenderNodes();
            }
        }
    },

    getMaterialConfiguration: function (materialURI, index) {
        var result = null;
        if (materialURI) {
            var adapterHandle = this.getAdapterHandle(materialURI);
            this.connectAdapterHandle("material_" + index, adapterHandle);

            switch (adapterHandle.status) {

                case AdapterHandle.STATUS.NOT_FOUND:
                    XML3D.debug.logError("Could not find <material> of url '" + adapterHandle.url + "' ", this.node);
                    break;
                case AdapterHandle.STATUS.READY:
                    var adapter = adapterHandle.getAdapter();
                    if (adapter && adapter.getMaterialConfiguration) {
                        result = adapter.getMaterialConfiguration();
                    }
                    break;
                case AdapterHandle.STATUS.LOADING:
                    break;
            }

        }
        return result;
    },

    updateVisibility: function() {
        var none = this.style.getPropertyValue("display").trim() == "none";
        var hidden  = this.style.getPropertyValue("visibility").trim() == "hidden";
        var visible = !(none || hidden);
        var propagate = function(node) {
            if (node.setLocalVisible) {
                 node.setLocalVisible(visible)
            }
            if (node.children) {
                node.children.forEach(propagate);
            }
        };
        propagate(this.renderNode);
    },

    updateZIndex: function() {
        var zIndex = this.style.getPropertyValue("z-index");
        zIndex = encodeZIndex(zIndex, true);

        var parent = this.getParentRenderAdapter();
        while (parent) {
            if (parent.style) {
                var parentZ = parent.style.getPropertyValue("z-index");
                parentZ = encodeZIndex(parentZ, false);
                if (parentZ != "")
                    zIndex = parentZ + ":" + zIndex;
            }
            parent = parent.getParentRenderAdapter();
        }

        var propagate = function(node) {
            if (node.setZIndex) {
                node.setZIndex(zIndex);
            }
            if (node.children) {
                node.children.forEach(propagate);
            }
        };
        propagate(this.renderNode);
    },


    /**
     * @param evt
     */
    notifyChanged: function (evt) {
        SceneElementAdapter.prototype.notifyChanged.call(this, evt);
        switch (evt.type) {
            case Events.ADAPTER_HANDLE_CHANGED:
                var splits = evt.key.split("_");
                if (splits[0] == "material") {
                    var renderNodeId = +splits[1];
                    // We identify the corresponding rendernode by the handler key
                    // This is a workaround that should be removed if there are
                    // custom callbacks for
                    var renderNode = this._subRenderNodes[renderNodeId];
                    XML3D.debug.assert(renderNode);
                    if (evt.handleStatus == AdapterHandle.STATUS.NOT_FOUND) {
                        renderNode.setMaterial(null);
                    } else {
                        var adapter = evt.adapter;
                        if (adapter && adapter.getMaterialConfiguration) {
                            renderNode.setMaterial(adapter.getMaterialConfiguration());
                        }
                    }
                    this.factory.renderer.requestRedraw("Material model changed.");
                }
        }
    },

    onAssetChange: function () {
         if (!this.renderNode) {
            //This model hasn't even been initialized yet so we defer building the render nodes to that step
            //This can happen for ex. when changing the "src" attribute before the model is appended into the DOM
            return;
        }

        this.createModelRenderNodes();
    },

    onXflowRequestChange: function (request) {
        var index = this.postTransformXflowRequests.indexOf(request);
        if (index != -1) {
            this.updatePostTransform(this.postTransformRenderGroups[index], request);
        }
    },

    updatePostTransform: function (renderNode, xflowRequest) {
        var dataResult = xflowRequest.getResult();
        var transformData = (dataResult.getOutputData("transform") && dataResult.getOutputData("transform").getValue());
        if (!transformData) {
            XML3D.debug.logWarning("Post Transform entry does not contain any 'transform' value.", this.node);
            renderNode.setLocalMatrix(c_IDENTITY);
            return;
        }
        renderNode.setLocalMatrix(transformData);
    },

    dispose: function () {
        this.asset.removeChangeListener(this);
        this.clearModelRenderNodes();
        this.getRenderNode().remove();
        this.clearAdapterHandles();
    }
});

function rec_removeRenderNodes(node, keepCurrentNode) {
    if (!node) {
        return;
    }
    if (!keepCurrentNode)
        node.remove();
    var children = node.getChildren();
    var i = children.length;
    while (i--) {
        rec_removeRenderNodes(children[i], false);
    }
}

function rec_createRenderNodes(adapter, parentNode, dataTreeNode) {

    if (dataTreeNode.postTransformXflowNode) {
        var request = new ComputeRequest(dataTreeNode.postTransformXflowNode, ["transform"], adapter._bindedRequestCallback);
        parentNode = adapter.getScene().createRenderGroup({
            parent: parentNode, visible: true, name: undefined
        });
        adapter.postTransformXflowRequests.push(request);
        adapter.postTransformRenderGroups.push(parentNode);
        adapter.updatePostTransform(parentNode, request);
    }

    var groupNode = adapter.getScene().createRenderGroup({
        parent: parentNode,
        visible: true,
        name: adapter.node.id
    });
    groupNode.setLocalMatrix(dataTreeNode.transform || c_IDENTITY);
    groupNode.setMaterial(adapter.getMaterialConfiguration(dataTreeNode.material, adapter._subRenderNodes.length));
    adapter._subRenderNodes.push(groupNode);

    var meshSets = dataTreeNode.meshes, i;
    for (i = 0; i < meshSets.length; ++i) {
        var renderNode = adapter.getScene().createRenderObject({
            parent: groupNode,
            node: meshSets[i].refNode || adapter.node,
            configuration: {
                data: meshSets[i].xflowNode, type: meshSets[i].type
            },
            name: adapter.node.id,
            visible: meshSets[i].visible
        });
        renderNode.setLocalMatrix(meshSets[i].transform || c_IDENTITY);
        renderNode.setMaterial(adapter.getMaterialConfiguration(meshSets[i].material, adapter._subRenderNodes.length));
        adapter._subRenderNodes.push(renderNode);
    }
    var groups = dataTreeNode.groups;
    for (i = 0; i < groups.length; ++i) {
        rec_createRenderNodes(adapter, groupNode, groups[i]);
    }
}


// Interface methods

XML3D.extend(ModelRenderAdapter.prototype, {
    /**
     * @return {XML3D.Box}
     */
    getLocalBoundingBox: function () {
        var bbox = new XML3D.Box();
        if (this.renderNode) {
            this.renderNode.getObjectSpaceBoundingBox(bbox);
        }
        return bbox;
    },

    /**
     * @return {XML3D.Box}
     */
    getWorldBoundingBox: function () {
        var bbox = new XML3D.Box();
        if (this.renderNode) {
            this.renderNode.getWorldSpaceBoundingBox(bbox);
        }
        return bbox;
    },

    /**
     * @return {mat4}
     */
    getWorldMatrix: function () {
        var m = new XML3D.Mat4(), obj = this.renderNode;
        if (obj) {
            obj.getWorldMatrix(m.data);
        }
        return m;
    }
});

// Export
module.exports = ModelRenderAdapter;


},{"../../../base/adapterhandle.js":49,"../../../interface/notification.js":74,"../../../resource":165,"../../../utils/misc.js":182,"../../../xflow/interface/request.js":190,"./scene-element.js":86,"gl-matrix":1}],86:[function(require,module,exports){
var RenderAdapter = require("./base.js");
var DOMTransformFetcher = require("../../../data/transform-fetcher.js");
var Events = require("../../../interface/notification.js");
var AdapterHandle = require("../../../base/adapterhandle.js");

/**
 * The SceneElementAdapter adapter is the base adapter for all scene elements,
 * i.e. <group>, <view>, <mesh>, <light> and <model>. These are also
 * those element that create an object inside the {@link Scene} data structure
 *
 * @param {RenderAdapterFactory} factory
 * @param {HTMLElement} node
 * @param handleMaterial
 * @constructor
 * @extends RenderAdapter
 * @see @link http://xml3d.org/xml3d/specification/5.0/#scene-elements
 */
var SceneElementAdapter = function (factory, node, handleMaterial) {
    RenderAdapter.call(this, factory, node);
    this.renderNode = null;

    /**
     * Living object: Holds the style of the associated node
     * @type {CSSStyleDeclaration}
     */
    this.style = window.getComputedStyle(node);

    this.materialHandler = null;
    this.handleMaterial = handleMaterial || false;
    this.transformFetcher = new DOMTransformFetcher(this, "transform", "transform");
};

XML3D.createClass(SceneElementAdapter, RenderAdapter, {

    updateMaterialHandler: function () {
        var materialURI = getMaterialURI(this.node);
        if (!materialURI) {
            this.disconnectAdapterHandle("material");
            this.materialHandler = null;
        } else {
            this.materialHandler = this.getAdapterHandle(materialURI);
            this.connectAdapterHandle("material", this.materialHandler);
        }
        this.referencedMaterialChanged();
    },

    referencedMaterialChanged: function () {
        if (!this.materialHandler) {
            this.getRenderNode().setMaterial(null);
            return;
        }
        var status = this.materialHandler.status;
        if (status === AdapterHandle.STATUS.NOT_FOUND) {
            XML3D.debug.logError("Could not find element of url '" + this.materialHandler.url + "' for material", this.node);
            this.getRenderNode().setMaterial(null);
            return;
        }
        var adapter = this.materialHandler.getAdapter();
        if (adapter && adapter.getMaterialConfiguration) {
            this.getRenderNode().setMaterial(adapter.getMaterialConfiguration());
        } else {
            this.getRenderNode().setMaterial(null);
        }
    },

    onConfigured: function () {
    },

    getRenderNode: function () {
        if (!this.renderNode) {
            this.renderNode = this.createRenderNode ? this.createRenderNode() : null;
        }
        return this.renderNode;
    },

    updateVisibility: function () {
        var none = this.style.getPropertyValue("display").trim() == "none";
        var hidden = this.style.getPropertyValue("visibility").trim() == "hidden";
        this.renderNode.setLocalVisible(!(none || hidden));
    },


    updateZIndex: function() {
        //This function is overridden by the leaf nodes (mesh, model), otherwise it should do nothing
    },

    dispose: function() {
        this.getRenderNode().remove();
        this.transformFetcher && this.transformFetcher.dispose();
        this.clearAdapterHandles();
    },

    styleChangedCallback: function() {
        this.updateZIndex();
        this.updateVisibility();
    },

    updateLocalMatrix: function () {
        this.transformFetcher && this.transformFetcher.update();
    },

    onTransformChange: function (attrName, matrix) {
        if (attrName == "transform") {
            this.renderNode.setLocalMatrix(matrix);
        }

    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        RenderAdapter.prototype.attributeChangedCallback.call(this, name, oldValue, newValue);

        if (name == "transform") {
            this.transformFetcher && this.transformFetcher.update();
        } else if (name == "style") {
            this.transformFetcher && this.transformFetcher.updateMatrix();
        } else if (name == "material" && this.handleMaterial) {
            this.updateMaterialHandler();
            this.factory.renderer.requestRedraw("Transformable material changed.");
        }
    },

    notifyChanged: function (evt) {
        switch (evt.type) {
            case Events.ADAPTER_HANDLE_CHANGED:
                var key = evt.key;
                if (key == "material") {
                    this.updateMaterialHandler();
                    this.factory.renderer.requestRedraw("Material reference changed.");
                }
                break;
            case Events.THIS_REMOVED:
                this.dispose();
                break;
            case Events.NODE_INSERTED:
                this.initElement(evt.affectedNode);
                break;
            default:
                XML3D.debug.logDebug("Unhandled event in SceneElementAdapter:", evt);
        }
    }
});



function getMaterialURI(node) {
    var materialURI = node.getAttribute("material");
    if (!materialURI) {
        var styleValue = node.getAttribute('style');
        if (styleValue) {
            var pattern = /material\s*:\s*url\s*\(\s*(\S+)\s*\)/i;
            var result = pattern.exec(styleValue);
            if (result)
                materialURI = result[1];
        }
    }
    return materialURI;
}

module.exports = SceneElementAdapter;

},{"../../../base/adapterhandle.js":49,"../../../data/transform-fetcher.js":66,"../../../interface/notification.js":74,"./base.js":77}],87:[function(require,module,exports){
var SceneElementAdapter = require("./scene-element.js");
var CameraConfiguration = require("../scene/configuration.js");
var Resource = require("../../../resource");

var DEFAULT_CAMERA_MODEL = "urn:xml3d:view:perspective";

/**
 * Adapter for <view>
 * @param {RenderAdapterFactory} factory
 * @param {Element} node
 * @extends SceneElementAdapter
 * @constructor
 */
var ViewRenderAdapter = function (factory, node) {
    SceneElementAdapter.call(this, factory, node, false, false);
    this.dataAdapter = Resource.getAdapter(node, "data");
    this.createRenderNode();
};
XML3D.createClass(ViewRenderAdapter, SceneElementAdapter, {

    createRenderNode: function () {
        var parent = this.getParentRenderAdapter();
        var parentNode = parent.getRenderNode ? parent.getRenderNode() : this.factory.renderer.scene.createRootNode();
        this.renderNode = this.factory.renderer.scene.createRenderView({
            camera: this.createCameraConfiguration(), parent: parentNode
        });
        this.updateLocalMatrix();
    },

    createCameraConfiguration: function () {
        var model = this.node.hasAttribute("model") ? this.node.getAttribute("model") : DEFAULT_CAMERA_MODEL;
        return new CameraConfiguration(model, this.dataAdapter.getXflowNode(), {name: this.node.id});
    },


    /* Interface method */
    getViewMatrix: function () {
        var m = new XML3D.Mat4();
        this.renderNode.getWorldToViewMatrix(m.data);
        return m;
    },

    /**
     * returns view2world matrix
     * @return {mat4}
     */
    getWorldMatrix: function () {
        var m = new XML3D.Mat4();
        this.renderNode.getViewToWorldMatrix(m.data);
        return m;
    },

    getProjectionMatrix: function () {
        var m = new XML3D.Mat4();
        this.renderNode.getProjectionMatrix(m.data);
        return m;
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        SceneElementAdapter.prototype.attributeChangedCallback.call(this, name, oldValue, newValue);
        switch (name) {
            case "model":
                this.renderNode.remove();
                this.createRenderNode();
                break;
        }
    }
});

// Export
module.exports = ViewRenderAdapter;

},{"../../../resource":165,"../scene/configuration.js":97,"./scene-element.js":86}],88:[function(require,module,exports){
var RenderAdapter = require("./base.js");
var Utils = require("../utils.js");
var Events = require("../../../interface/notification.js");
var dispatchCustomEvent = require("../../../utils/misc.js").dispatchCustomEvent;
var ResourceCounter = require("../../../resource/counter.js");

var XML3DRenderAdapter = function (factory, node) {
    RenderAdapter.call(this, factory, node);
    this.fireLoadEventAfterDraw = false;
    this.firstLoadFired = false;
};
XML3D.createClass(XML3DRenderAdapter, RenderAdapter, {

    activeViewChanged: function () {
        var viewElement = getOrCreateActiveView(this.node);
        var adapter = this.factory.getAdapter(viewElement);
        this.factory.getScene().setActiveView(adapter.getRenderNode());
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        if (name == "view") {
            this.activeViewChanged();
        }
    },

    notifyChanged: function (evt) {
        switch (evt.type) {
            case Events.NODE_INSERTED:
                // This also initializes the children
                this.initElement(evt.mutation.target);
                return;
        }
    },


    /*
     * This function is called when scene DOM is loaded and all adapters are attached
     */
    onConfigured: function () {
        this.activeViewChanged();

        // emit load event when all resources currently loading are completed
        var callback = this.onLoadComplete.bind(this);
        // register callback for canvasId == 0 i.e. global resources
        ResourceCounter.addLoadCompleteListener(0, callback);
        // register callback for canvasId of this node
        ResourceCounter.addLoadCompleteListener(this.factory.canvasId, callback);
        this.onLoadComplete();
    },

    /* Interface methods */

    onLoadComplete: function (canvasId) {
        if (ResourceCounter.isLoadComplete(0) && ResourceCounter.isLoadComplete(this.factory.canvasId)) {
            this.fireLoadEventAfterDraw = true;
        }
    },

    onFrameDrawn: function () {
        if (this.fireLoadEventAfterDraw) {
            this.fireLoadEventAfterDraw = false;
            this.firstLoadFired = true;
            dispatchCustomEvent(this.node, 'load', false, true, null);
        }
    },


    getComplete: function () {
        if (this.fireLoadEventAfterDraw) return false;
        if (!this.firstLoadFired) return false;
        return ResourceCounter.isLoadComplete(0) && ResourceCounter.isLoadComplete(this.factory.canvasId);
    },

    getWorldBoundingBox: function () {
        var bbox = new XML3D.Box();
        Array.prototype.forEach.call(this.node.childNodes, function (c) {
            if (c.getWorldBoundingBox) {
                bbox.extend(c.getWorldBoundingBox());
            }
        });
        return bbox;
    }
})
;
//XML3D element is the root with no transform of its own so by definition it's always in world space
XML3DRenderAdapter.prototype.getLocalBoundingBox = XML3DRenderAdapter.prototype.getWorldBoundingBox;

/**
 *
 * @param {number} x x coordinate in screen space
 * @param {number} y y coordinate in screen space
 * @param {XML3D.Vec3?} hitPoint
 * @param {XML3D.Vec3?} hitNormal
 * @returns {*}
 */
XML3DRenderAdapter.prototype.getElementByPoint = function (x, y, hitPoint, hitNormal) {
    var relativeMousePos = Utils.convertPageCoords(this.node, x, y);

    var relX = relativeMousePos.x;
    var relY = relativeMousePos.y;

    var renderer = this.factory.getRenderer();
    var object = renderer.getRenderObjectFromPickingBuffer(relX, relY);
    if (object) {
        if (hitPoint) {
            var vec = renderer.getWorldSpacePositionByPoint(relX, relY, object);
            XML3D.math.vec3.copy(hitPoint.data, vec);
        }
        if (hitNormal) {
            var vec = renderer.getWorldSpaceNormalByPoint(relX, relY, object);
            XML3D.math.vec3.copy(hitNormal.data, vec);
        }
    } else {
        if (hitPoint) {
            hitPoint.x = NaN;
            hitPoint.y = NaN;
            hitPoint.z = NaN;
        }
        if (hitNormal) {
            hitNormal.x = NaN;
            hitNormal.y = NaN;
            hitNormal.z = NaN;
        }
    }
    return object ? object.node : null;
};

XML3DRenderAdapter.prototype.getRenderInterface = function () {
    return this.factory.getRenderer().getRenderInterface();
};

XML3DRenderAdapter.prototype.generateRay = function (x, y) {
    var relativeMousePos = Utils.convertPageCoords(this.node, x, y);
    return this.factory.getRenderer().generateRay(relativeMousePos.x, relativeMousePos.y);
};

XML3DRenderAdapter.prototype.getElementByRay = (function () {
    var c_viewMat = XML3D.math.mat4.create();
    var c_projMat = XML3D.math.mat4.create();

    return function (xml3dRay, hitPoint, hitNormal) {
        var renderer = this.factory.getRenderer();
        renderer.calculateMatricesForRay(xml3dRay, c_viewMat, c_projMat);
        var hitObject = renderer.getRenderObjectByRay(xml3dRay, c_viewMat, c_projMat);
        if (hitObject !== null && (hitPoint || hitNormal)) {
            if (hitPoint) {
                var vec = renderer.getWorldSpacePositionByRay(xml3dRay, hitObject, c_viewMat, c_projMat);
                XML3D.math.vec3.copy(hitPoint.data, vec);
            }
            if (hitNormal) {
                var vec = renderer.getWorldSpaceNormalByRay(xml3dRay, hitObject, c_viewMat, c_projMat);
                XML3D.math.vec3.copy(hitNormal.data, vec);
            }
        } else {
            if (hitPoint) {
                hitPoint.x = NaN;
                hitPoint.y = NaN;
                hitPoint.z = NaN;
            }
            if (hitNormal) {
                hitNormal.x = NaN;
                hitNormal.y = NaN;
                hitNormal.z = NaN;
            }
        }
        return hitObject !== null ? hitObject.node : null;
    }
})();


/**
 * Returns the active view element corresponding to the given xml3d element.
 *
 * @param {!Object} xml3d
 * @return {Object} the active view element
 */
function getOrCreateActiveView(xml3d) {
    // try to resolve reference
    var view = xml3d.querySelector(xml3d.view) || xml3d.querySelector("view");
    if (!view) {
        // didn't find any: create new one
        XML3D.debug.logWarning("xml3d element has no view defined: creating one.");

        view = xml3d.ownerDocument.createElement("view");
        xml3d.appendChild(view);
        xml3d.removeAttribute("view");
    }
    return view;
};

module.exports = XML3DRenderAdapter;



},{"../../../interface/notification.js":74,"../../../resource/counter.js":162,"../../../utils/misc.js":182,"../utils.js":111,"./base.js":77}],89:[function(require,module,exports){
var XC = require("../../../xflow/interface/constants.js");
var DataNode = require("../../../xflow/interface/graph.js").DataNode;
var InputNode = require("../../../xflow/interface/graph.js").InputNode;
var BufferEntry = require("../../../xflow/interface/data.js").BufferEntry;
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;
var Frustum = require("../tools/frustum.js").Frustum;
var mat4 = require("gl-matrix").mat4;
var assert = require('assert');



var ProjectiveCameraData = {
    "projectionMatrix": {
        type: XC.DATA_TYPE.FLOAT4X4, default: mat4.perspective(mat4.create(), (45 * Math.PI / 180), 1, 0.001, 10000)
    }
};

var PerspectiveCameraData = {
    "fovVertical": {type: XC.DATA_TYPE.FLOAT3, 'default': [(45 * Math.PI / 180)]},
    "fovHorizontal": {type: XC.DATA_TYPE.FLOAT3, 'default': undefined},
    "near": {type: XC.DATA_TYPE.FLOAT3, 'default': undefined},
    "far": {type: XC.DATA_TYPE.FLOAT3, 'default': undefined},
    "aspect": {type: XC.DATA_TYPE.FLOAT, 'default': undefined},
    "worldBoundingBox": {type: XC.DATA_TYPE.FLOAT, 'default': undefined}
};

/**
 * @param {DataNode|null} dataNode
 * @param scene
 * @param owner
 * @param {string} model
 * @param defaults
 * @constructor
 */
var AbstractCameraModel = function (dataNode, scene, owner, model, defaults) {
    assert.equal(typeof owner.viewFrustumChanged, 'function');
    assert.equal(typeof model, 'string');
    assert(defaults);
    assert(scene);

    this.owner = owner;
    this.model = model;
    this.scene = scene;
    this.parameters = Object.keys(defaults);

    if (dataNode) {
        var data = new DataNode();
        data.insertBefore(createXflowData(defaults), null);
        data.insertBefore(dataNode, null);
        this.dataNode = data;
    } else {
        this.dataNode = createXflowData(defaults);
    }
    this.dataNode.insertBefore(this.scene.data.data, null);

    this.cameraParameterRequest = new ComputeRequest(this.dataNode, this.parameters, this.cameraParametersChanged.bind(this));
    this.cameraParametersChanged(this.cameraParameterRequest, null);
};

AbstractCameraModel.prototype = {
    cameraParametersChanged: function (request, changeType) {
        if (changeType) {
            this.owner.viewFrustumChanged(changeType);
        }
    },

    destroy: function() {
        this.cameraParameterRequest.clear();
        this.dataNode.clear();
    }
};


/**
 * @param dataNode
 * @param {Scene} scene
 * @param {RenderView} owner
 * @constructor
 * @extends AbstractCameraModel
 */
var ProjectiveCameraModel = function (dataNode, scene, owner) {
    AbstractCameraModel.call(this, dataNode, scene, owner, "projective", ProjectiveCameraData);
};

XML3D.createClass(ProjectiveCameraModel, AbstractCameraModel, {
    getProjectionMatrix: function (aspect) {
        var result = this.cameraParameterRequest.getResult();
        var projectionMatrix = result.getOutputData("projectionMatrix").getValue();
        return projectionMatrix;
    },

    // TODO(ksons): Compute frustum from projection matrix
    getFrustum: function () {
        return null;
    }
});

/**
 * Perspective Camera Model
 * @param dataNode
 * @param scene
 * @param owner
 * @extends AbstractCameraModel
 * @constructor
 */
var PerspectiveCameraModel = function (dataNode, scene, owner) {
    AbstractCameraModel.call(this, dataNode, scene, owner, "perspective", PerspectiveCameraData);
    this.frustum = new Frustum(0.01, 1000, 0, 0.78, 1);
};

XML3D.createClass(PerspectiveCameraModel, AbstractCameraModel, {

    _updateFrustum: function () {
        var result = this.cameraParameterRequest.getResult();

        var fovv, fovh, near, far;

        var fovhEntry = result.getOutputData("fovHorizontal");
        if (fovhEntry) {
            fovh = fovhEntry.getValue()[0];
        } else {
            fovv = result.getOutputData("fovVertical").getValue()[0];
        }

        var nearEntry = result.getOutputData("near");
        if (nearEntry) {
            near = nearEntry.getValue()[0];
        }

        var farEntry = result.getOutputData("far");
        if (farEntry) {
            far = farEntry.getValue()[0];
        }

        var aspect = result.getOutputData("aspect").getValue()[0];

        if (near == undefined || far == undefined) {
            var boundingBox = new XML3D.Box(result.getOutputData("worldBoundingBox").getValue())
            var nearFar = this.owner.getClippingPlanes(boundingBox);

            near = near == undefined ? nearFar.near : near;
            far = far == undefined ? nearFar.far : far;
        }

        this.frustum.setFrustum(near, far, fovh, fovv, aspect /*, orthographic = false */);
    },

    getProjectionMatrix: function () {
        this._updateFrustum();
        return this.frustum.getProjectionMatrix(mat4.create());
    },

    getFrustum: function () {
        this._updateFrustum();
        return this.frustum;
    }
});

function createXflowData(config) {
    var data = new DataNode();
    for (var name in config) {
        var entry = config[name];
        if (entry['default']) {
            createXflowValue(data, name, entry.type, entry['default']);
        }
    }
    return data;
}

function createXflowValue(dataNode, name, type, value) {
    var buffer = new BufferEntry(type, new XC.TYPED_ARRAY_MAP[type](value));
    var inputNode = new InputNode();
    inputNode.data = buffer;
    inputNode.name = name;
    dataNode.appendChild(inputNode);
}




module.exports = {
    AbstractCameraModel: AbstractCameraModel, PerspectiveCameraModel: PerspectiveCameraModel, ProjectiveCameraModel: ProjectiveCameraModel
};

},{"../../../xflow/interface/constants.js":187,"../../../xflow/interface/data.js":188,"../../../xflow/interface/graph.js":189,"../../../xflow/interface/request.js":190,"../tools/frustum.js":109,"assert":11,"gl-matrix":1}],90:[function(require,module,exports){
var MouseEvents = require("./events/mouse.js");
var TouchEvents = require("./events/touch.js");

var c_globalCanvasId = 0;

/**
 * @param {Element} xml3dElement
 * @constructor
 */
function AbstractCanvasHandler(xml3dElement, canvas) {
    this._xml3dElement = xml3dElement;
    this._canvas = canvas;
    this.id = ++c_globalCanvasId; // global canvas id starts at 1

    this._mouseHandler = new MouseEvents.MouseEventHandler(xml3dElement, this);
    this._registerCanvasListeners(this._mouseHandler, MouseEvents.EVENTS);
    if(this.hasTouchEvents()) {
        this._touchHandler = new TouchEvents.TouchEventHandler(xml3dElement, this);
        this._registerCanvasListeners(this._touchHandler, TouchEvents.EVENTS);
    }
}

/**
 * @returns {boolean}
 */
AbstractCanvasHandler.prototype.hasTouchEvents = function() {
    return 'ontouchstart' in window;
};

AbstractCanvasHandler.prototype.getCanvas = function() {
   return this._canvas;
};

AbstractCanvasHandler.prototype.dispatchEvent = function(event) {
    this._xml3dElement.dispatchEvent(event);
};

AbstractCanvasHandler.prototype._registerCanvasListeners = function (handler, events) {
    var canvas = this._canvas;
    events.forEach(function (name) {
        canvas.addEventListener(name, function (e) {
            handler[name] && handler[name].call(handler, e);
            e.stopPropagation();
        });
    });
};

AbstractCanvasHandler.prototype.dispatchCustomEvent = function(type, detail) {
    detail = detail || null;
    var event = document.createEvent('CustomEvent');
    event.initCustomEvent(type, true, true, detail);
    this._xml3dElement.dispatchEvent(event);
};

AbstractCanvasHandler.prototype.dispatchResizeEvent = function (dimensions) {
    this.dispatchCustomEvent("resize", dimensions);
};

/**
 * Dispatches a FrameDrawnEvent to listeners
 *
 * @param start
 * @param end
 * @param stats
 * @return
 */
AbstractCanvasHandler.prototype.dispatchFrameDrawnEvent = function (start, end, stats) {
    stats = stats || {
        count: {
            primitives: 0, objects: 0
        }
    };
    var data = {
        timeStart: start, timeEnd: end, renderTimeInMilliseconds: end - start, count: stats.count
    };
    this.dispatchCustomEvent("framedrawn", data);
};

module.exports = AbstractCanvasHandler;

},{"./events/mouse.js":92,"./events/touch.js":93}],91:[function(require,module,exports){
var factory = require("./renderer-factory.js");

var configure = function(xml3ds) {
    if (!(xml3ds instanceof Array))
        xml3ds = [xml3ds];

    xml3ds.forEach(function(xml3dElement) {
        if (xml3dElement._configured.canvasHandler.renderer) {
            // This element has already been configured
            return;
        }
        XML3D.debug.logDebug("Configuring Renderer for", xml3dElement.id);
        var renderer = factory.createRenderer(xml3dElement)

    });
};

module.exports = configure;
},{"./renderer-factory.js":96}],92:[function(require,module,exports){
var Options = require("../../../utils/options.js");

var OPTION_MOUSEMOVE_PICKING = "renderer-mousemove-picking";
var OPTION_MOVEMENT_AWARE_CLICK_HANDLER = "renderer-movement-aware-click-handler";
Options.register(OPTION_MOUSEMOVE_PICKING, true);
Options.register(OPTION_MOVEMENT_AWARE_CLICK_HANDLER, false);

var EVENTS = ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mousemove", "mouseout", "wheel"];

/**
 *
 * @param {Element} defaultTarget
 * @param {AbstractCanvasHandler} canvasHandler
 * @constructor
 */
var MouseEventHandler = function(defaultTarget, canvasHandler) {
    this._defaultTarget = defaultTarget;
    this._canvasHandler = canvasHandler;
    this._lastMousePosition =  {x: 0, y: 0};
};

var supportsEventConstructors = (function() {
    try {
        new MouseEvent("click", {});
        return true;
    } catch (e){
        return false;
    }
})();

MouseEventHandler.prototype =  {

    /**
     * @param {MouseEvent} event  The original event
     * @param {Element} target  target to dispatch on
     * @param {object?}     opt    Options
     */
    dispatchMouseEvent: function (event, target, opt) {
        opt = opt || {};
        target = target || this._defaultTarget;
        var x = opt.x !== undefined ? opt.x : event.clientX;
        var y = opt.y !== undefined ? opt.y : event.clientY;
        var noCopy = opt.noCopy || false;
        // Copy event to avoid DOM dispatch errors (cannot dispatch event more
        // than once)
        if (!noCopy) {
            event = this.copyMouseEvent(event);
        }
        this.initExtendedMouseEvent(event, x, y);

        target.dispatchEvent(event);
    },

    /**
     * @param {MouseEvent|WheelEvent} event the event to copy
     * @return {MouseEvent} the new event
     */
    copyMouseEvent: function (event) {
        var evt;
        if (supportsEventConstructors) {
            if (event.toString() === "[object WheelEvent]") {
                evt = new WheelEvent(event.type, event);
            } else {
                evt = new MouseEvent(event.type, event);
            }
        } else {
            //These event APIs are deprecated but still required by IE, which doesn't support event constructors yet
            if (event.toString() === "[object WheelEvent]") {
                evt = document.createEvent("WheelEvent");
                evt.initWheelEvent(event.type, event.bubbles, event.cancelable, event.view, event.detail,
                    event.screenX, event.screenY, event.clientX, event.clientY, event.button, event.relatedTarget, "",
                    event.deltaX, event.deltaY, event.deltaZ, event.deltaMode);
            } else {
                evt = document.createEvent("MouseEvent");
                evt.initMouseEvent(event.type, event.bubbles, event.cancelable, event.view, event.detail,
                    event.screenX, event.screenY, event.clientX, event.clientY, event.ctrlKey, event.altKey,
                    event.shiftKey, event.metaKey, event.button, event.relatedTarget);
            }
        }
        if (event.dataTransfer)
            evt.data = {url: event.dataTransfer.getData("URL"), text: event.dataTransfer.getData("Text")};
        // override preventDefault to actually prevent the default of the original event
        evt.preventDefault = function () {
            event.preventDefault();
        };
        return evt;
    },

    createMouseEvent: function (type, opts) {
        opts = opts || {};
        var dict = {
            bubbles		: opts.bubbles !== undefined ? opts.bubbles : true,
            cancelable 	: opts.cancelable !== undefined ? opts.cancelable : true,
            view 		: opts.view || window,
            detail 		: opts.detail !== undefined ? opts.detail : 0,
            screenX		: opts.screenX !== undefined ? opts.screenX : 0,
            screenY		: opts.screenY !== undefined ? opts.screenY : 0,
            clientX		: opts.clientX !== undefined ? opts.clientX : 0,
            clientY		: opts.clientY !== undefined ? opts.clientY : 0,
            ctrl 		: opts.ctrl !== undefined ? opts.ctrl : false,
            alt 		: opts.alt !== undefined ? opts.alt : false,
            shift 		: opts.shift !== undefined ? opts.shift : false,
            meta 		: opts.meta !== undefined ? opts.meta : false,
            button 		: opts.button !== undefined ? opts.button : 0,
            relatedTarget : opts.relatedTarget
        };
        if (supportsEventConstructors) {
            return new MouseEvent(type, dict);
        } else {
            var evt = document.createEvent("MouseEvent");
            evt.initMouseEvent(type, dict.bubbles, dict.cancelable, dict.view, dict.detail,
                dict.screenX, dict.screenY, dict.clientX, dict.clientY, dict.ctrlKey, dict.altKey,
                dict.shiftKey, dict.metaKey, dict.button, dict.relatedTarget);
            return evt;
        }
    },

    /**
     * Adds position and normal attributes to the given event.
     *
     * @param {Event} event
     * @param {number} x
     * @param {number} y
     * @return {XML3D.Vec3}
     */
    initExtendedMouseEvent: function (event, x, y) {
        var handler = this._canvasHandler;

        (function () {
            var cachedPosition = undefined;
            var cachedNormal = undefined;

            Object.defineProperty(event, "normal", {
                get : function() {
                    if (!cachedNormal) {
                        var norm = (handler.getWorldSpaceNormalByPoint(x, y));
                        cachedNormal = norm || null;
                    }
                    return cachedNormal;
                }
            });

            Object.defineProperty(event, "position", {
                get : function() {
                    if (!cachedPosition) {
                        var pos = handler.getWorldSpacePositionByPoint(x, y);
                        cachedPosition = pos || null;
                    }
                    return cachedPosition;
                }
            });
        })();
    },

    /**
     * @param {MouseEvent} evt
     * @param {object?} opt
     */
    dispatchMouseEventOnPickedObject: function (evt, opt) {
        opt = opt || {};
        var pos = this.getMousePosition(evt);

        var picked = null;
        if (!opt.omitUpdate)
            picked = this._canvasHandler.getPickObjectByPoint(pos.x, pos.y);

        this.dispatchMouseEvent(evt, picked && picked.node, pos);
    },

    getMousePosition: function (evt) {
        return this._canvasHandler.getMousePosition(evt)
    },


    /**
     * @param {MouseEvent} evt
     */
    mouseup: function (evt) {
        this.dispatchMouseEventOnPickedObject(evt);
    },

    /**
     * @param {MouseEvent} evt
     */
    mousedown: function (evt) {
        this._lastMousePosition = this.getMousePosition(evt);
        this.dispatchMouseEventOnPickedObject(evt);
    },


    /**
     * @param {MouseEvent} evt
     */
    click: function (evt) {
        if (Options.getValue("renderer-movement-aware-click-handler") === true) {
            var pos = this.getMousePosition(evt);
            if (Math.abs(pos.x - this._lastMousePosition.x) > 4 || Math.abs(pos.y - this._lastMousePosition.y) > 4)
                return;
        }
        this.dispatchMouseEventOnPickedObject(evt);
    },

    /**
     * @param {MouseEvent} evt
     */
    dblclick: function (evt) {
        this.dispatchMouseEventOnPickedObject(evt);
    },

    /**
     * This method is called each time a mouseMove event is triggered on the
     * canvas.
     *
     * This method also triggers mouseover and mouseout events of objects in the
     * scene.
     *
     * @param {MouseEvent} evt
     */
    mousemove: function (evt) {
        var pos = this.getMousePosition(evt);

        var doMouseMovePick = Options.getValue(OPTION_MOUSEMOVE_PICKING);

        this.dispatchMouseEventOnPickedObject(evt, {omitUpdate: !doMouseMovePick});
        if (!doMouseMovePick)
            return;

        var curObj = this._canvasHandler.getPickedObject();

        // trigger mouseover and mouseout
        if (curObj !== this.lastPickObj) {
            if (this.lastPickObj) {
                // The mouse has left the last object
                this.dispatchMouseEvent(this.createMouseEvent("mouseout", {
                    clientX: pos.x, clientY: pos.y, button: evt.button
                }), this.lastPickObj);
            }
            if (curObj) {
                // The mouse is now over a different object, so call the new
                // object's mouseover method
                this.dispatchMouseEvent(this.createMouseEvent("mouseover", {
                    clientX: pos.x, clientY: pos.y, button: evt.button
                }), curObj);
            }

            this.lastPickObj = curObj;
        }
    },

    /**
     * @param {MouseEvent} evt
     */
    mouseout: function (evt) {
        var pos = this.getMousePosition(evt);
        this.dispatchMouseEvent(evt, this.lastPickObj, pos);
    },

    /**
     * @param {MouseEvent} evt
     */
    mouseover: function (evt) {
        var doMouseMovePick = Options.getValue(OPTION_MOUSEMOVE_PICKING);
        this.dispatchMouseEventOnPickedObject(evt, {omitUpdate: !doMouseMovePick});
    },

    /**
     * @param {WheelEvent} evt
     */
    wheel: function (evt) {
        this.dispatchMouseEventOnPickedObject(evt, { type: "wheel" });
    }


};

module.exports = {
    EVENTS: EVENTS, MouseEventHandler: MouseEventHandler
};

},{"../../../utils/options.js":183}],93:[function(require,module,exports){
/**
 *
 * @param {Element} defaultTarget
 * @param {AbstractCanvasHandler} canvasHandler
 * @constructor
 */
var TouchEventHandler = function (defaultTarget, canvasHandler) {
    this._defaultTarget = defaultTarget;
    this._canvasHandler = canvasHandler;
};


var EVENTS = ["touchstart", "touchmove", "touchend", "touchcancel"];
var ua = /iPhone|iP[oa]d/.test(navigator.userAgent) ? 'iOS' : /Android/.test(navigator.userAgent) ? 'Android' : 'PC';

TouchEventHandler.prototype = {

    copyTouchEvent: function (event, options) {
        var touchEventData = this.copyTouchEventData(event, options);
        return this.createTouchEvent(touchEventData);
    },


    copyTouchEventData: function (event, options) {
        return {
            type: options.type || event.type,
            timeStamp: Date.now(),
            bubbles: event.bubbles,
            cancelable: event.cancelable,
            detail: event.detail,
            screenX: event.screenX,
            screenY: event.screenY,
            pageX: event.pageX,
            pageY: event.pageY,
            clientX: event.clientX,
            clientY: event.clientY,
            ctrlKey: event.ctrlKey,
            altKey: event.altKey,
            shiftKey: event.shiftKey,
            metaKey: event.metaKey,
            scale: event.scale,
            rotation: event.rotation,
            view: event.view,
            touches: event.touches,
            changedTouches: event.changedTouches,
            targetTouches: event.targetTouches
        };
    },

    createTouchEvent: function (data) {
        var touchEvent;

        try {
            touchEvent = document.createEvent('TouchEvent');
        } catch (e) {
            XML3D.debug.logWarning("Create Touch Event failed, creating UI instead");
            touchEvent = document.createEvent('UIEvent');
        }

        if (touchEvent && touchEvent.initTouchEvent) {
            if (touchEvent.initTouchEvent.length == 0 && ua !== "iOS") { //chrome
                touchEvent.initTouchEvent(data.touches, data.targetTouches, data.changedTouches, data.type, data.view, data.screenX, data.screenY, data.clientX, data.clientY);
            } else if (touchEvent.initTouchEvent.length == 12) { //firefox
                touchEvent.initTouchEvent(data.type, data.bubbles, data.cancelable, data.view, data.detail, data.ctrlKey, data.altKey, data.shiftKey, data.metaKey, data.touches, data.targetTouches, data.changedTouches);
            } else { //iOS length = 18
                touchEvent.initTouchEvent(data.type, data.bubbles, data.cancelable, data.view, data.detail, data.screenX, data.screenY, data.pageX, data.pageY, data.ctrlKey, data.altKey, data.shiftKey, data.metaKey, data.touches, data.targetTouches, data.changedTouches, data.scale, data.rotation);
            }
        }
        return touchEvent;
    },

    /**
     * @param {Event} evt
     * @param {object?} opt
     */
    dispatchTouchEventOnPickedObject: function (evt, opt) {
        opt = opt || {};
        var touchEvent = this.copyTouchEvent(evt, opt);
        touchEvent.preventDefault = function () {
            evt.preventDefault();
        };
        this._defaultTarget.dispatchEvent(touchEvent);
    },

    touchstart: function (evt) {
        this.dispatchTouchEventOnPickedObject(evt);
    },

    touchend: function (evt) {
        this.dispatchTouchEventOnPickedObject(evt);
    },

    touchmove: function (evt) {
        this.dispatchTouchEventOnPickedObject(evt);
    },

    touchcancel: function (evt) {
        this.dispatchTouchEventOnPickedObject(evt);
    }

};


module.exports = {
    EVENTS: EVENTS, TouchEventHandler: TouchEventHandler
};

},{}],94:[function(require,module,exports){
function LightManager() {
    this._lights = [];
    this._models = {};

    /**
     * Updating light parameters can lead to updating the (lazy) scene structure, which
     * in turn updates the lights. If we are in updating the lights, flag is set to true.
     * @type {boolean}
     * @private
     */
    this._inUpdate = false;
}

LightManager.prototype = {
    add: function (light) {
        this._lights.push(light);
        this._addModel(light.model);
    },

    remove: function (light) {
        var index = this._lights.indexOf(light);
        if (index != -1) {
            this._lights.splice(index, 1);
        }
        this._removeModel(light.model);
    },

    fillGlobalParameters: function (globals, force) {
        for (var id in this._models) {
            var entry = this._models[id];
            /* Fill globals only if this was not already done before */
            if (entry.changed || force) {
                var prefix = id + "Light";
                for (var param in entry.parameters) {
                    var name = prefix + param.charAt(0).toUpperCase() + param.slice(1);
                    globals[name] = entry.parameters[param];
                }
                entry.changed = false;
            }
        }
    },

    lightValueChanged: function (light) {
        if (this._inUpdate)
            return;
        this._inUpdate = true;

        var lights = light ? [light] : this._lights;
        var that = this;

        lights.forEach(function(light) {
            var model = light.model;
            var entry = that.getModelEntry(model.id);
            var offset = entry.lightModels.indexOf(model);
            if (offset < 0) {
                //These changes are for a light that no longer exists so we can ignore them
                //This can happen for ex. during a delayed change notification that isn't fired until after a remove()
                return;
            }
            model.fillLightParameters(entry.parameters, offset);
            model.getLightData(entry.parameters, offset);
            entry.changed = true;
        });
        this._inUpdate = false;
    },

    getModelEntry: function (id) {
        return this._models[id];
    },

    getModels: function (id) {
        return Object.keys(this._models);
    },

    getModelCount: function (id) {
        var model = this.getModelEntry(id);
        return model ? model.lightModels.length : 0;
    },

    _addModel: function (model) {
        var entry = this._models[model.id];
        if (!entry) {
            entry = this._models[model.id] = {lightModels: [], parameters: {}};
        }
        entry.lightModels.push(model);
        this._lightStructureChanged(entry);
    },

    _removeModel: function (model) {
        var entry = this.getModelEntry(model.id);
        var index = entry.lightModels.indexOf(model);
        if (index != -1) {
            entry.lightModels.splice(index, 1);
        }
        this._lightStructureChanged(entry);
    },

    _lightStructureChanged: function (entry) {
        this._inUpdate = true;
        var length = entry.lightModels.length;
        if (!length) {
            entry.parameters = {};
            return;
        }
        var model = entry.lightModels[0];
        entry.parameters = model.allocateParameterArray(length);
        entry.lightModels.forEach(function (lightModel, offset) {
            lightModel.fillLightParameters(entry.parameters, offset)
            lightModel.getLightData(entry.parameters, offset);
        });
        entry.changed = true;
        this._inUpdate = false;

    }
};

module.exports = LightManager;

},{}],95:[function(require,module,exports){
var Frustum = require("../tools/frustum.js").Frustum;
var XC = require("../../../xflow/interface/constants.js");
var DataNode = require("../../../xflow/interface/graph.js").DataNode;
var InputNode = require("../../../xflow/interface/graph.js").InputNode;
var BufferEntry = require("../../../xflow/interface/data.js").BufferEntry;
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;
var mat4 = require("gl-matrix").mat4;
var vec3 = require("gl-matrix").vec3;
var quat = require("gl-matrix").quat;

var PointLightData = {
    "intensity": {type: XC.DATA_TYPE.FLOAT3, 'default': [1, 1, 1]},
    "attenuation": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, 1]},
    "position": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, 0]},
    "shadowBias": {type: XC.DATA_TYPE.FLOAT, 'default': [0.0001]},
    "direction": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, -1]},
    "castShadow": {type: XC.DATA_TYPE.BOOL, 'default': [false]},
    "on": {type: XC.DATA_TYPE.BOOL, 'default': [true]},
    "matrix": {type: XC.DATA_TYPE.FLOAT4X4, 'default': [1, 0, 0, 0,   0, 1, 0, 0,    0, 0, 1, 0,  0, 0, 0, 1]},
    "nearFar": {type: XC.DATA_TYPE.FLOAT2, 'default': [1.0, 100.0]}
};

var SpotLightData = {
    "intensity": {type: XC.DATA_TYPE.FLOAT3, 'default': [1, 1, 1]},
    "attenuation": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, 1]},
    "position": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, 0]},
    "direction": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, -1]},
    "cutoffAngle": {type: XC.DATA_TYPE.FLOAT, 'default': [Math.PI / 4]},
    "softness": {type: XC.DATA_TYPE.FLOAT, 'default': [0.0]},
    "shadowBias": {type: XC.DATA_TYPE.FLOAT, 'default': [0.0001]},
    "castShadow": {type: XC.DATA_TYPE.BOOL, 'default': [false]},
    "matrix": {type: XC.DATA_TYPE.FLOAT4X4, 'default': [1, 0, 0, 0,   0, 1, 0, 0,    0, 0, 1, 0,  0, 0, 0, 1]},
    "on": {type: XC.DATA_TYPE.BOOL, 'default': [true]}
};

var DirectionalLightData = {
    "intensity": {type: XC.DATA_TYPE.FLOAT3, 'default': [1, 1, 1]},
    "direction": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, -1]},
    "shadowBias": {type: XC.DATA_TYPE.FLOAT, 'default': [0.0001]},
    "position": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, 0]},
    "castShadow": {type: XC.DATA_TYPE.BOOL, 'default': [false]},
    "on": {type: XC.DATA_TYPE.BOOL, 'default': [true]},
    "matrix": {type: XC.DATA_TYPE.FLOAT4X4, 'default': [1, 0, 0, 0,   0, 1, 0, 0,    0, 0, 1, 0,  0, 0, 0, 1]}
};


function createXflowData(config) {
    var data = new DataNode();
    for (var name in config) {
        var entry = config[name];
        createXflowValue(data, name, entry.type, entry['default']);
    }
    return data;
}

function createXflowValue(dataNode, name, type, value) {
    var buffer = new BufferEntry(type, new XC.TYPED_ARRAY_MAP[type](value));
    var inputNode = new InputNode();
    inputNode.data = buffer;
    inputNode.name = name;
    dataNode.appendChild(inputNode);
}

/**
 * Base class for light models
 * @param {string} id Unique id that identifies the light model
 * @param {RenderLight} light
 * @param {DataNode} dataNode
 * @param {Object} config Configuration that contains the light model's parameters and default values
 * @constructor
 */
var LightModel = function (id, light, dataNode, config) {
    this.id = id;
    this.light = light;
    this.configuration = config;
    this.parameters = Object.keys(config);
    /**
     * If the light has not data, just use the default parameters
     */
    if (dataNode) {
        var data = new DataNode();
        data.insertBefore(createXflowData(config), null);
        data.insertBefore(dataNode, null);
        this.dataNode = data;
    } else {
        this.dataNode = createXflowData(config);
    }

    // Horizontal opening angle of the light camera. Derived from cutoffAngle in case of spot light
    this.fovy =  Math.PI/2.0;

    this.lightParameterRequest = new ComputeRequest(this.dataNode, this.parameters, this.lightParametersChanged.bind(this));
    this.lightParametersChanged(this.lightParameterRequest, null);
};

LightModel.prototype = {
    /**
     * Copies the light parameters in an array of the same size
     * @param {Object} target Name to typed array map containing the data
     * @param {number} offset Slot in the array to be filled
     */
    fillLightParameters: function (target, offset) {
        var result = this.lightParameterRequest.getResult();
        this.parameters.forEach(function (name) {
            var entry = result.getOutputData(name);
            var size = XC.DATA_TYPE_TUPLE_SIZE[entry.type];
            var value = entry.getValue();
            target[name].set(value.subarray(0, size), offset * size);
        });
        this.transformParameters(target, offset);
    },

    allocateParameterArray: function (size) {
        var parameterArrays = {};
        var config = this.configuration;
        this.parameters.forEach(function (name) {
            var type = config[name].type;
            var tupleSize = XC.DATA_TYPE_TUPLE_SIZE[type];
            parameterArrays[name] = new XC.TYPED_ARRAY_MAP[type](tupleSize * size);
        });
        return parameterArrays;
    },

    getParameter: function(name) {
        if(name in this.configuration) {
            // No other checks required because parameters are always defined
            return this.lightParameterRequest.getResult().getOutputData(name).getValue();
        }
        return null;
    },

    lightParametersChanged: function (request, changeType) {
        if (changeType) {
            this.light.lightValueChanged();
        }
    },

    _expandNearFar:function(nfobject){
        var expand = Math.max((nfobject.far - nfobject.near) * 0.30, 0.05);
        nfobject.near -= expand;
        nfobject.far  += expand;
    },

    getLightData: function (target, offset) {
        var matrix = target["matrix"].subarray(offset * 16, offset * 16 + 16);
        this.getLightViewProjectionMatrix(matrix);
    },

    getLightViewProjectionMatrix: function (target) {
        var LVM = mat4.create();
        var LPM = mat4.create();
        this.getLightViewMatrix(LVM);
        this.getLightProjectionMatrix(LPM);
        XML3D.math.mat4.multiply(target, LPM, LVM);
    },

    getLightProjectionMatrix: function (target) {
        this.light.getFrustum(1).getProjectionMatrix(target);
    },

    getLightViewMatrix: (function() {
        var tmp = mat4.create();

        return function (mat) {
            var p_dir = this.getParameter("direction");
            var p_pos = this.getParameter("position");

            // Get the world matrix from the light in the transformation hierarchy
            // world => light
            this.light.getWorldMatrix(mat);

            // Derive rotation from the direction and standard direction (-z => no rotation)
            var q_rot = XML3D.math.quat.rotationTo(quat.create(),c_standardDirection, p_dir);
            // Create matrix from rotation and translation
            mat4.fromRotationTranslation(tmp, q_rot, p_pos);
            // Add to world matrix\
            mat4.mul(mat, mat, tmp);

            // Invert:  light => world
            mat4.invert(mat, mat);
        }
    })()

};

var c_tmpWorldMatrix = mat4.create();
var c_standardDirection = vec3.fromValues(0,0,-1);


function transformPose(light, position, direction) {
    light.getWorldMatrix(c_tmpWorldMatrix);
    if (position) {
        vec3.transformMat4(position, position, c_tmpWorldMatrix);
    }
    if (direction) {
        XML3D.math.vec3.transformDirection(direction, direction, c_tmpWorldMatrix);
        vec3.normalize(direction, direction);
    }
}

function transformDefault(target, offset, light) {
    target["on"][offset] = light.visible;
}


/**
 * Implement XML3D's predefined point light model urn:xml3d:light:point
 * @param {DataNode} dataNode
 * @param {RenderLight} light
 * @extends LightModel
 * @constructor
 */
var PointLightModel = function (dataNode, light) {
    LightModel.call(this, "point", light, dataNode, PointLightData);
};

XML3D.createClass(PointLightModel, LightModel, {
    getFrustum: function (aspect, sceneBoundingBox) {
        var orthogonal = false;
        var entry = this.light.scene.lights.getModelEntry(this.id);

        if (sceneBoundingBox.isEmpty()) {
            entry.parameters["nearFar"][0] = 1.0;
            entry.parameters["nearFar"][1] = 110.0;
            return new Frustum(1.0, 110.0, 0, this.fovy, aspect, orthogonal)
        }


        var t_mat = mat4.create();
        this.getLightViewMatrix(t_mat);
        sceneBoundingBox.transformAxisAligned(t_mat);

        var nf = {
            near: -sceneBoundingBox.max.z, far: -sceneBoundingBox.min.z
        };
        // Expand the view frustum a bit to ensure 2D objects parallel to the camera are rendered
        this._expandNearFar(nf);

        if (nf.far < 1.0) {
            nf.far = 110;
        }

        entry.parameters["nearFar"][0] = 1.0;
        entry.parameters["nearFar"][1] = nf.far;

        return new Frustum(1.0, nf.far, 0, this.fovy, aspect, orthogonal);
    },

    transformParameters: function (target, offset) {
        var position = target["position"].subarray(offset * 3, offset * 3 + 3);
        transformPose(this.light, position, null);
        transformDefault(target, offset, this.light);
    }
});




/**
 * Implement XML3D's predefined spot light model urn:xml3d:light:spot
 * @param {DataNode} dataNode
 * @param {RenderLight} light
 * @extends LightModel
 * @constructor
 */
var SpotLightModel = function (dataNode, light) {
    LightModel.call(this, "spot", light, dataNode, SpotLightData);
};


XML3D.createClass(SpotLightModel, LightModel, {
    getFrustum: function (aspect, sceneBoundingBox) {

        if (sceneBoundingBox.isEmpty()) {
            return new Frustum(1.0, 110.0, 0, this.fovy, aspect, false)
        }

        var t_mat = mat4.create();
        this.getLightViewMatrix(t_mat);
        sceneBoundingBox.transformAxisAligned(t_mat);

        var nf = {
            near: -sceneBoundingBox.max.z, far: -sceneBoundingBox.min.z
        };
        // Expand the view frustum a bit to ensure 2D objects parallel to the camera are rendered
        this._expandNearFar(nf);

        if (nf.far < 1.0) {
            nf.far = 110;
        }

        return new Frustum(1.0, nf.far, 0, this.fovy, aspect, false);
    },

    transformParameters: function (target, offset) {
        var position = target["position"].subarray(offset * 3, offset * 3 + 3);
        var direction = target["direction"].subarray(offset * 3, offset * 3 + 3);
        // Transform position and direction from object to world space
        transformPose(this.light, position, direction);
        transformDefault(target, offset, this.light);
    },

    lightParametersChanged: function (request, changeType) {
        this.fovy = this.getParameter("cutoffAngle")[0] * 2;
        LightModel.prototype.lightParametersChanged.call(this, request, changeType);
    }
});




/**
 * Implement XML3D's predefined spot light model urn:xml3d:light:directional
 * @param {DataNode} dataNode
 * @param {RenderLight} light
 * @extends LightModel
 * @constructor
 */
var DirectionalLightModel = function (dataNode, light) {
    LightModel.call(this, "directional", light, dataNode, DirectionalLightData);
};

XML3D.createClass(DirectionalLightModel, LightModel, {
    getFrustum: function(aspect, sceneBoundingBox) {
        var orthogonal = true;

        if (sceneBoundingBox.isEmpty()) {
            return new Frustum(1.0, 110.0, 0, this.fovy, aspect, orthogonal)
        }

        var t_mat = mat4.create();
        this.getLightViewMatrix(t_mat);
        sceneBoundingBox.transformAxisAligned(t_mat);

        var nf = {  near: -sceneBoundingBox.max.z,
                    far:  -sceneBoundingBox.min.z};
        // Expand the view frustum a bit to ensure 2D objects parallel to the camera are rendered
        this._expandNearFar(nf);

        if (nf.far < 1.0) {
            nf.far = 110;
        }

        return new Frustum(1.0, nf.far, 0, this.fovy, aspect, orthogonal);
    },

    transformParameters: function (target, offset) {
        var direction = target["direction"].subarray(offset * 3, offset * 3 + 3);
        transformPose(this.light, null, direction);
        transformDefault(target, offset, this.light);
    },



    getLightViewMatrix: function (mat) {
        var manager = this.light.scene.lights;
        var entry = manager.getModelEntry(this.id);
        var p_dir = entry.parameters["direction"];
        var p_pos = entry.parameters["position"];

        var bb = new XML3D.Box();
        this.light.scene.getBoundingBox(bb);
        var off = vec3.create();
        var bbCenter = bb.center();
        var bbSize = bb.size();
        var d = bbSize.length(); //diameter of bounding sphere of the scene
        vec3.scale(off, p_dir, -0.55 * d); //enlarge a bit on the radius of the scene
        p_pos = vec3.add(p_pos, bbCenter.data, off);
        entry.parameters["position"] = p_pos;


        //create new transformation matrix depending on the updated parameters
        mat4.identity(mat);
        var lookat_mat = mat4.create();
        var top_vec = vec3.fromValues(0.0, 1.0, 0.0);
        if ((p_dir[0] == 0.0) && (p_dir[2] == 0.0)) //check if top_vec colinear with direction
            top_vec = vec3.fromValues(0.0, 0.0, 1.0);
        var up_vec = vec3.create();
        var dir_len = vec3.len(p_dir);
        vec3.scale(up_vec, p_dir, -vec3.dot(top_vec, p_dir) / (dir_len * dir_len));
        vec3.add(up_vec, up_vec, top_vec);
        vec3.normalize(up_vec, up_vec);
        mat4.lookAt(lookat_mat, vec3.fromValues(0.0, 0.0, 0.0), p_dir, up_vec);
        mat4.invert(lookat_mat, lookat_mat);
        mat4.translate(mat, mat, p_pos);
        mat4.multiply(mat, mat, lookat_mat);

        bb = new XML3D.Box();
        this.light.scene.getBoundingBox(bb);
        bb.transformAxisAligned(mat);
        bbSize = bb.size().data;
        var max = (bbSize[0] > bbSize[1]) ? bbSize[0] : bbSize[1];
        max = 0.55 * (max);//enlarge 10percent to make sure nothing gets cut off
        this.fovy = max <= 0 ? Math.PI : Math.atan(max)*2.0;

        entry.parameters["direction"] = p_dir;
        entry.parameters["position"]  = p_pos;

        mat4.invert(mat, mat);
    }

});

module.exports = {
    PointLightModel: PointLightModel, SpotLightModel: SpotLightModel, DirectionalLightModel: DirectionalLightModel

};

},{"../../../xflow/interface/constants.js":187,"../../../xflow/interface/data.js":188,"../../../xflow/interface/graph.js":189,"../../../xflow/interface/request.js":190,"../tools/frustum.js":109,"gl-matrix":1}],96:[function(require,module,exports){
var GLRenderer = require("../webgl/renderer.js");
var GLCanvasHandler = require("../webgl/canvas-handler.js");

var RendererFactory = function () {
    this.createRenderer = function (xml3dElement) {
        var canvas = xml3dElement._configured.canvas;
        var canvasHandler = new GLCanvasHandler(xml3dElement, canvas);
        var renderer = new GLRenderer(xml3dElement, canvasHandler);
        canvasHandler.setRenderer(renderer);
        xml3dElement._configured.canvasHandler = canvasHandler;
        window.requestAnimationFrame(canvasHandler.tick);
        return renderer;
    }
};
module.exports = new RendererFactory();








},{"../webgl/canvas-handler.js":119,"../webgl/renderer.js":152}],97:[function(require,module,exports){
var uniqueObjectId = require("../../webgl/base/utils.js").getUniqueCounter();
/**
 * A configuration connects a model (material, light, camera) with a data node containing
 * the parameters for the model
 * The Configuration is immutable
 *
 * @param model The model (e.g. identified by an URN)
 * @param {Xflow.DataNode} dataNode  The parameters of this model instance
 * @param {{}} opt
 * @constructor
 */
var Configuration = function(model, dataNode, opt) {
    opt = opt || {};

    this.id = uniqueObjectId();

    /**
     * @type {{type: string}}
     */
    this.model = model;

    /**
     * Data Node of the renderObject
     * @type {Xflow.DataNode}
     */
    this.dataNode = dataNode;

    /**
     * A name for debug purposes
     * @type {string|null}
     */
    this.name = opt.name || null;
};

module.exports = Configuration;

},{"../../webgl/base/utils.js":118}],98:[function(require,module,exports){
module.exports = {
    NODE_TYPE: {
        GROUP: "group", OBJECT: "object", LIGHT: "light", VIEW: "view"
    },

    EVENT_TYPE: {
        VIEW_CHANGED: "view_changed",
        LIGHT_STRUCTURE_CHANGED: "light_structure_changed",
        LIGHT_VALUE_CHANGED: "light_value_changed",
        SCENE_SHAPE_CHANGED: "scene_shape_changed",
        SCENE_STRUCTURE_CHANGED: "scene_structure_changed",
        DRAWABLE_STATE_CHANGED: "drawable_state_changed",
        OPACITY_STATE_CHANGED: "opacity_state_changed"

    }
};

},{}],99:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;

var DrawableClosure = function (context, type) {
    EventEmitter.call(this);
    this.context = context;
    this._type = type;
    this._valid = false;
    // Do not limit the number of listeners
    this.setMaxListeners(0);
};

DrawableClosure.TYPES = {
    MESH: "mesh", VOLUME: "volume"
};

DrawableClosure.READY_STATE = {
    COMPLETE: "complete", INCOMPLETE: "incomplete"
};

XML3D.createClass(DrawableClosure, EventEmitter, {
    getType: function () {
        return this._type;
    }, isValid: function () {
        return this._valid;
    }, setShaderComposer: function (shaderComposer) {
        // implemented by subclass
    }, update: function (scene) {
        // implemented by subclass
    }
});

module.exports = DrawableClosure;


},{"events":12}],100:[function(require,module,exports){
var DEFAULT_PAGE_SIZE = 1 << 12;

/**
 * @constructor
 */
var Pager = function (opt) {
    opt = opt || {};

    this.pageSize = opt.pageSize || DEFAULT_PAGE_SIZE;

    /** @type Array<Float32Array> */
    this.pages = [];
    /** @type number */
    this.nextOffset = 0;
    /** @type Array<*> */
    this.freeEntries = [];
    // Add a first page
    this.addPage();
};

XML3D.extend(Pager.prototype, {
    addPage: function () {
        var page = new Float32Array(this.pageSize);
        this.pages.push(page);
        this.nextOffset = 0;
        XML3D.debug.logInfo("Adding page", this.pages.length, "(", this.pageSize * Float32Array.BYTES_PER_ELEMENT * this.pages.length / 1024, "kB)");
    },

    getPageEntry: function (size) {
        if (!size)
            throw new Error("No size given for page entry");
        return this.reusePageEntry(size) || this.createPageEntry(size);
    },

    /**
     * @param {number} size Requested size in number of floats
     * @returns {{ page: Float32Array, offset: number, size: number }}
     */
    reusePageEntry: function (size) {
        var sameSizeEntries = this.freeEntries[size];
        if (sameSizeEntries && sameSizeEntries.length) {
            return sameSizeEntries.pop();
        }
        return null;
    },

    /**
     * @param {number} size  Size in number of floats
     * @returns {{ page: Float32Array, offset: number, size: number }}
     */
    createPageEntry: function (size) {
        if (this.nextOffset + size > this.pageSize) {
            this.addPage();
            return this.getPageEntry(size);
        }
        var page = this.pages[this.pages.length - 1];
        var localOffset = this.nextOffset;
        this.nextOffset += size;
        return {page: page, offset: localOffset, size: size};
    },

    /**
     *
     * @param {{ page: Float32Array, offset: number, size: number }} entryInfo
     */
    freePageEntry: function (entryInfo) {
        var sameSizeEntries = this.freeEntries[entryInfo.size];
        if (!sameSizeEntries) {
            sameSizeEntries = this.freeEntries[entryInfo.size] = [];
        }
        sameSizeEntries.push(entryInfo);
    }
});

module.exports = Pager;


},{}],101:[function(require,module,exports){
var RenderNode = require("./rendernode.js");
var Constants = require("./constants.js");
var Frustum = require("../tools/frustum.js").Frustum;
var vec3 = require("gl-matrix").vec3;
var mat4 = require("gl-matrix").mat4;

var NODE_TYPE = Constants.NODE_TYPE;
var EVENT_TYPE = Constants.EVENT_TYPE;

/** @const */
var WORLD_MATRIX_OFFSET = 0;
/** @const */
var LOCAL_MATRIX_OFFSET = WORLD_MATRIX_OFFSET + 16;
/** @const */
var WORLD_BB_OFFSET = LOCAL_MATRIX_OFFSET + 16;
/** @const */
var ENTRY_SIZE = WORLD_BB_OFFSET + 6;


   /** @const */
    var CLIPPLANE_NEAR_MIN = 0.01;

    /** @const */
    var DEFAULT_FIELDOFVIEW = 45 / 180 * Math.PI;
/**
 *
 * @constructor
 * @extends {RenderNode}
 */
var RenderGroup = function (scene, pageEntry, opt) {
    RenderNode.call(this, NODE_TYPE.GROUP, scene, pageEntry, opt);
    opt = opt || {};

    /**
     * The material attached to this group
     * @type {MaterialConfiguration|null}
     */
    this._material = opt.material || null;
    this.boundingBoxDirty = false;
    this.setWorldSpaceBoundingBox(XML3D.Box.EMPTY_BOX);
};
RenderGroup.ENTRY_SIZE = ENTRY_SIZE;

XML3D.createClass(RenderGroup, RenderNode);

XML3D.extend(RenderGroup.prototype, {
    getLocalMatrix: function (dest) {
        var o = this.offset + LOCAL_MATRIX_OFFSET;
        for (var i = 0; i < 16; i++, o++) {
            dest[i] = this.page[o];
        }
    },

    setLocalMatrix: function (source) {
        var o = this.offset + LOCAL_MATRIX_OFFSET;
        for (var i = 0; i < 16; i++, o++) {
            this.page[o] = source[i];
        }
        this.setTransformDirty();
        this.setBoundingBoxDirty();
    },

    getWorldSpaceBoundingBox: function (bbox) {
        if (this.boundingBoxDirty) {
            this.updateWorldSpaceBoundingBox();
        }
        var o = this.offset + WORLD_BB_OFFSET;
        bbox.data[0] = this.page[o];
        bbox.data[1] = this.page[o + 1];
        bbox.data[2] = this.page[o + 2];
        bbox.data[3] = this.page[o + 3];
        bbox.data[4] = this.page[o + 4];
        bbox.data[5] = this.page[o + 5];
    },

    setWorldSpaceBoundingBox: function (bbox) {
        var o = this.offset + WORLD_BB_OFFSET;
        this.page[o] = bbox.data[0];
        this.page[o + 1] = bbox.data[1];
        this.page[o + 2] = bbox.data[2];
        this.page[o + 3] = bbox.data[3];
        this.page[o + 4] = bbox.data[4];
        this.page[o + 5] = bbox.data[5];
    },


    updateWorldSpaceBoundingBox: (function () {
        var childBB = new XML3D.Box();

        return function () {
            var localBB = new XML3D.Box();

            for (var i = 0, j = this.children.length; i < j; i++) {
                var obj = this.children[i];
                obj.getWorldSpaceBoundingBox(childBB);
                localBB.extend(childBB);
            }
            this.setWorldSpaceBoundingBox(localBB);
            this.boundingBoxDirty = false;
        }
    })(),

    addChild: function (child) {
        this.children.push(child);
        this.setBoundingBoxDirty();
        this.scene.emit(EVENT_TYPE.SCENE_STRUCTURE_CHANGED, child, false);
    },

    removeChild: function (child) {
        var index = this.children.indexOf(child);
        if (index != -1) {
            this.children.splice(index, 1);
        }
        this.scene.emit(EVENT_TYPE.SCENE_STRUCTURE_CHANGED, child, true);
    },

    getChildren: function () {
        return this.children;
    },

    updateWorldMatrix: function (sourceMat4) {
        var page = this.page;
        var offset = this.offset;
        XML3D.math.mat4.multiplyOffset(page, offset + WORLD_MATRIX_OFFSET, page, offset + LOCAL_MATRIX_OFFSET, sourceMat4, 0);
        this.transformDirty = false;
    },

    setTransformDirty: function () {
        if (this.transformDirty) {
            //We can be sure all child nodes are already set to transformDirty from here
            return;
        }
        this.transformDirty = true;
        var children = this.children;
        for(var i = 0, l = children.length; i < l; i++) {
            children[i].setTransformDirty();
        }
    },

    /**
     * @param {MaterialConfiguration|null} material
     */
    setMaterial: function (material) {
        if(this._material === material)
            return;
        this._material = material;
        this.children.forEach(function (obj) {
            obj.parentMaterialChanged && obj.parentMaterialChanged();
        });
    },

    parentMaterialChanged: function () {
        if (this._material) {
            // Local material overrides anything coming from upstream
            return;
        }
        this.children.forEach(function (obj) {
            obj.parentMaterialChanged && obj.parentMaterialChanged();
        });
    },

    /**
     * @returns {MaterialConfiguration}
     */
    getMaterial: function () {
        return this._material || this.parent.getMaterial();
    },

    /**
     * A group propagates its visibility
     */
    visibilityChanged: function () {
        var children = this.children;
        for (var i = 0, l = children.length; i < l; i++) {
            children[i].evaluateVisibility();
        }
    },



    setBoundingBoxDirty: function () {
        this.boundingBoxDirty = true;
        if (this.parent) {
            this.parent.setBoundingBoxDirty();
        }
    },

    findRayIntersections: (function () {
        var bbox = new XML3D.Box();

        return function (ray, intersections) {
            this.getWorldSpaceBoundingBox(bbox);
            if (ray.intersects(bbox)) {
                for (var i = 0; i < this.children.length; i++) {
                    this.children[i].findRayIntersections(ray, intersections);
                }
            }
        }
    })()

});

// Export
module.exports = RenderGroup;


},{"../tools/frustum.js":109,"./constants.js":98,"./rendernode.js":103,"gl-matrix":1}],102:[function(require,module,exports){
var RenderNode = require("./rendernode.js");
var Constants = require("./constants.js");
var LightModels = require("../lights/light-models.js");

var NODE_TYPE = Constants.NODE_TYPE;
var EVENT_TYPE = Constants.EVENT_TYPE;

var tmp_worldMatrix = XML3D.math.mat4.create();

var SHADOWMAP_OFFSET_MATRIX = new Float32Array([0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0]);

/** @const */
var CLIPPLANE_NEAR_MIN = 1.0;

/** @const */
var ENTRY_SIZE = 16;

var c_BoundingBox = new XML3D.Box();


function createLightModel(type, data, light) {
    switch (type) {
        case "urn:xml3d:light:point":
            return new LightModels.PointLightModel(data, light);
        case "urn:xml3d:light:spot":
            return new LightModels.SpotLightModel(data, light);
        case "urn:xml3d:light:directional":
            return new LightModels.DirectionalLightModel(data, light);
        default:
            XML3D.debug.logWarning("Unknown light model: ", type, ". Using directional instead.");
            return new LightModels.DirectionalLightModel(data, light);
    }
}

/**
 * @constructor
 * @param {Scene} scene
 * @param {Object} pageEntry
 * @param {Object} opt
 * @extends {RenderNode}
 */
var RenderLight = function (scene, pageEntry, opt) {
    RenderNode.call(this, NODE_TYPE.LIGHT, scene, pageEntry, opt);
    opt = opt || {};
    var configuration = opt.configuration || {};
    this.setLightType(configuration.model, configuration.dataNode);
};
RenderLight.ENTRY_SIZE = ENTRY_SIZE;

XML3D.createClass(RenderLight, RenderNode);
XML3D.extend(RenderLight.prototype, {

    setLightType: function (modelId, data) {
        if (this.model) {
            if (this.model.id == modelId) {
                return; // Nothing changed
            }
            this.scene.lights.remove(this);
            this.lightStructureChanged(true);
        }
        this.model = createLightModel(modelId, data, this);
        this.scene.lights.add(this);
        this.lightStructureChanged(false);
    },

    setLocalMatrix: function (source) {
        XML3D.debug.logError("RenderLight::setLocalMatrix not implemented");
    },


    getFrustum: function (aspect) {
        this.scene.getBoundingBox(c_BoundingBox);
        return this.model.getFrustum(aspect, c_BoundingBox);
    },

    lightValueChanged: function () {
        if (this.model) { // FIXME: Complex dependency
            this.scene.emit(EVENT_TYPE.LIGHT_VALUE_CHANGED, this);
        }
    },

    lightStructureChanged: function (removed) {
        this.scene.emit(EVENT_TYPE.LIGHT_STRUCTURE_CHANGED, this, removed);
    },

    updateWorldMatrix: function () {
        if (this.parent) {
            this.parent.getWorldMatrix(tmp_worldMatrix);
            this.setWorldMatrix(tmp_worldMatrix);
            // We change position / direction of the light
            this.lightValueChanged();
        }
    },

    visibilityChanged: function (newVal) {
        // Visibility is a light parameter
        this.lightValueChanged();
    },

    setTransformDirty: function () {
        this.updateWorldMatrix();
    },


    remove: function () {
        this.parent.removeChild(this);
        this.scene.lights.remove(this);
        this.lightStructureChanged(true);
    },


    getWorldSpaceBoundingBox: function (bbox) {
        bbox.setEmpty();
    }
});

module.exports = RenderLight;



},{"../lights/light-models.js":95,"./constants.js":98,"./rendernode.js":103}],103:[function(require,module,exports){
/** @const */
var WORLD_MATRIX_OFFSET = 0;

/**
 * @constructor
 * @param type
 * @param {Scene} scene
 * @param {Object} pageEntry
 * @param {Object} opt
 */
var RenderNode = function (type, scene, pageEntry, opt) {
    opt = opt || {};

    this.scene = scene;
    this.type = type;
    this.name = opt.name || "";
    this.page = pageEntry.page;
    this.offset = pageEntry.offset;
    this.entrySize = pageEntry.size;
    this.transformDirty = true;
    this.children = [];
    this.parent = null;

    this.setParent(opt.parent || scene.rootNode);

    this.localVisible = opt.visible !== undefined ? opt.visible : true;
    // The global visibility depends on visibility of parents
    this.visible = true;
    this.evaluateVisibility();
};

XML3D.extend(RenderNode.prototype, {

    getChildren: function () {
        return this.children;
    },

    evaluateVisibility: function() {
        var oldVisible = this.visible;
        if(this.parent && !this.parent.visible) {
            this.visible = false;
        } else {
            this.visible = this.localVisible;
        }
        if(oldVisible !== this.visible) {
            this.visibilityChanged();
            this.scene.requestRedraw && this.scene.requestRedraw("Visibility changed.");
        }
    },

    setLocalVisible: function(newVisible) {
        if (this.localVisible === newVisible) {
            return;
        }
        this.localVisible = newVisible;
        this.evaluateVisibility();
    },

    // Needs to be overwritten
    visibilityChanged: function() {},

    getParent: function () {
        return this.parent;
    },

    setParent: function (parent) {
        this.parent = parent;
        if (parent && parent.addChild) {
            parent.addChild(this);
        }
        // Reevaluate visibility, which might change due to
        // invisibility of parent
        this.evaluateVisibility();
    },

    traverse: function (callback) {
        callback(this);
        this.children.forEach(function (child) {
            child.traverse(callback);
        })
    },

    /**
     * @param {Mat4} source
     * @param {number} offset
     */
    setMat4InPage: function(source, offset) {
        var o = this.offset + offset;
        for(var i = 0; i < 16; i++, o++) {
            this.page[o] = source[i];
        }
    },

    /**
     * @param {Mat4} dest
     * @param {number} offset
     */
    getMat4FromPage: function(dest, offset) {
        var o = this.offset + offset;
        for(var i = 0; i < 16; i++, o++) {
            dest[i] = this.page[o];
        }
    },

    getWorldMatrix: function (dest) {
        if (this.transformDirty) {
            this.parent.getWorldMatrix(dest);
            this.updateWorldMatrix(dest);
        }
        this.getMat4FromPage(dest, WORLD_MATRIX_OFFSET);
    },

    setWorldMatrix: function (source) {
        this.setMat4InPage(source, WORLD_MATRIX_OFFSET);
        this.transformDirty = false;
        if (this.setBoundingBoxDirty) {
            this.setBoundingBoxDirty();
        }
    },

    setTransformDirty: function () {
        this.transformDirty = true;
    },

    remove: function () {
        this.parent.removeChild(this);
        this.scene.pager.freePageEntry({page: this.page, offset: this.offset, size: this.entrySize});
    },

    findRayIntersections: function (/* ray, closestIntersection*/) {
        //This function is overridden by groups and drawables
    }

});

module.exports = RenderNode;

},{}],104:[function(require,module,exports){
var SystemNotifier = require("../../webgl/system/system-notifier.js");
var RenderNode = require("./rendernode.js");
var DrawableClosure= require("./drawableclosure.js");
var C = require("./constants.js");
var Scene= require("./scene.js");
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;
var mat4 = require("gl-matrix").mat4;

// Entry:
/** @const */
var WORLD_MATRIX_OFFSET = 0;
/** @const */
var LOCAL_MATRIX_OFFSET = WORLD_MATRIX_OFFSET + 16;
/** @const */
var OBJECT_BB_OFFSET = LOCAL_MATRIX_OFFSET + 16;
/** @const */
var WORLD_BB_OFFSET = OBJECT_BB_OFFSET + 6;
/** @const */
var MODELVIEW_MATRIX_OFFSET = WORLD_BB_OFFSET + 6;
/** @const */
var MODELVIEWPROJECTION_MATRIX_OFFSET = MODELVIEW_MATRIX_OFFSET + 16;
/** @const */
var MODEL_MATRIX_N_OFFSET = MODELVIEWPROJECTION_MATRIX_OFFSET + 16;
/** @const */
var MODELVIEW_MATRIX_N_OFFSET = MODEL_MATRIX_N_OFFSET + 16;
/** @const */
var ENTRY_SIZE = MODELVIEW_MATRIX_N_OFFSET + 16;

//noinspection JSClosureCompilerSyntax,JSClosureCompilerSyntax
/**
 * Represents a renderable object in the scene.
 * The RenderObject has these responsibilities:
 *  1. Keep track of the transformation hierarchy and bounding boxes
 *  2. Connect the DrawableClosure with the ShaderClosure
 *
 *  The {@link DrawableClosure} is a DrawableObject plus it's data
 *  The {@link ShaderClosure} is a ProgramObject plus it's data
 *  The concrete ShaderClosure can vary per DrawableObject and change
 *  due to scene or object changes. Thus we have to keep track of the
 *  related {@link IShaderComposer}.
 *
 * @constructor
 * @implements {IRenderObject}
 * @param {Scene} scene
 * @param {Object} pageEntry
 * @param {Object} opt
 */
var RenderObject = function (scene, pageEntry, opt) {
    RenderNode.call(this, C.NODE_TYPE.OBJECT, scene, pageEntry, opt);
    opt = opt || {};

    /**
     * Keep reference to DOM Element need e.g. for picking
     * @type {Element}
     */
    this.node = opt.node;

    /**
     * Object related data
     * @type {{data: DataNode|null, type: string}}
     */
    this.configuration = opt.configuration || {data: null, type: "triangles"};

    /**
     * Can we rely on current WorldMatrix?
     * @type {boolean}
     */
    this.transformDirty = true;

    /**
     * Can we rely on current Bounding Boxes?
     * @type {boolean}
     */
    this.boundingBoxDirty = true;

    /**
     * The drawable closure transforms object data and type into
     * a drawable entity
     * @type {DrawableClosure}
     */
    this.drawable = this.createDrawable();

    this._material = opt.material || null;
    this._zIndex = opt.zIndex || "0";
    this._actualMaterial = null;
    this.pickId = -1;
    this.initMaterial();

    /** {Object?} **/
    this.override = null;
};
RenderObject.ENTRY_SIZE = ENTRY_SIZE;

RenderObject.IDENTITY_MATRIX = mat4.create();

XML3D.createClass(RenderObject, RenderNode, {
    createDrawable: function () {
        var result = this.scene.createDrawable(this);
        if (result) {
            var that = this;
            result.on(C.EVENT_TYPE.DRAWABLE_STATE_CHANGED, function (newState, oldState) {
                if (newState === DrawableClosure.READY_STATE.COMPLETE) {
                    that.scene.moveFromQueueToReady(that);
                } else if (newState === DrawableClosure.READY_STATE.INCOMPLETE && oldState === DrawableClosure.READY_STATE.COMPLETE) {
                    that.scene.moveFromReadyToQueue(that);
                }
            });
            result.updateTypeRequest();
            result.calculateBoundingBox();
            result.on(C.EVENT_TYPE.SCENE_SHAPE_CHANGED, function (evt) {
                that.scene.emit(C.EVENT_TYPE.SCENE_SHAPE_CHANGED);
            });
            result.on(C.EVENT_TYPE.OPACITY_STATE_CHANGED, function(oldValue, newValue) {
                that.override = that.override || {};
                that.override.opacity = newValue;
            });
        }
        return result;
    },

    getLocalMatrix: function (dest) {
        this.getMat4FromPage(dest, LOCAL_MATRIX_OFFSET);
    },

    setLocalMatrix: function (source) {
        this.setMat4InPage(source, LOCAL_MATRIX_OFFSET);
        this.setTransformDirty();
        this.setBoundingBoxDirty();
    },

    dispose: function () {
        this.scene.remove(this);
    },

    onTransformDataChange: function () {
        this.setTransformDirty();
    },

    getModelViewMatrix: function (dest) {
        this.getMat4FromPage(dest, MODELVIEW_MATRIX_OFFSET);
    },

    getModelMatrixN: function (dest) {
        var o = this.offset + MODEL_MATRIX_N_OFFSET;
        dest[0] = this.page[o];
        dest[1] = this.page[o + 1];
        dest[2] = this.page[o + 2];
        dest[3] = this.page[o + 4];
        dest[4] = this.page[o + 5];
        dest[5] = this.page[o + 6];
        dest[6] = this.page[o + 8];
        dest[7] = this.page[o + 9];
        dest[8] = this.page[o + 10];
    },

    getModelViewMatrixN: function (dest) {
        var o = this.offset + MODELVIEW_MATRIX_N_OFFSET;
        dest[0] = this.page[o];
        dest[1] = this.page[o + 1];
        dest[2] = this.page[o + 2];
        dest[3] = this.page[o + 4];
        dest[4] = this.page[o + 5];
        dest[5] = this.page[o + 6];
        dest[6] = this.page[o + 8];
        dest[7] = this.page[o + 9];
        dest[8] = this.page[o + 10];
    },


    getModelViewProjectionMatrix: function (dest) {
        this.getMat4FromPage(dest, MODELVIEWPROJECTION_MATRIX_OFFSET);
    },

    updateWorldSpaceMatrices: function (view, projection) {
        if (this.transformDirty) {
            this.updateWorldMatrix();
        }
        this.updateModelViewMatrix(view);
        this.updateModelMatrixN();
        this.updateModelViewMatrixN();
        this.updateModelViewProjectionMatrix(projection);
    },

    updateWorldMatrix: (function () {
        var tmp_mat = mat4.create();
        return function () {
            this.parent.getWorldMatrix(tmp_mat);
            var page = this.page;
            var offset = this.offset;
            XML3D.math.mat4.multiplyOffset(tmp_mat, 0, page, offset + LOCAL_MATRIX_OFFSET, tmp_mat, 0);
            this.setWorldMatrix(tmp_mat);
            this.boundingBoxDirty = true;
            this.transformDirty = false;
        }
    })(),

    /** Relies on an up-to-date transform matrix **/
    updateModelViewMatrix: function (view) {
        if (this.transformDirty) {
            this.updateWorldMatrix();
        }
        var page = this.page;
        var offset = this.offset;
        XML3D.math.mat4.multiplyOffset(page, offset + MODELVIEW_MATRIX_OFFSET, page, offset + WORLD_MATRIX_OFFSET, view, 0);
    },

    updateModelMatrixN: (function () {
        var c_tmpMatrix = mat4.create();
        return function () {
            this.getWorldMatrix(c_tmpMatrix);
            mat4.invert(c_tmpMatrix, c_tmpMatrix);
            var normalMatrix = c_tmpMatrix ? mat4.transpose(c_tmpMatrix, c_tmpMatrix) : RenderObject.IDENTITY_MATRIX;
            this.setMat4InPage(normalMatrix, MODEL_MATRIX_N_OFFSET);
        }
    })(),

    /** Relies on an up-to-date view matrix **/
    updateModelViewMatrixN: (function () {
        var c_tmpMatrix = mat4.create();
        return function () {
            this.getModelViewMatrix(c_tmpMatrix);
            mat4.invert(c_tmpMatrix, c_tmpMatrix);
            var normalMatrix = c_tmpMatrix ? mat4.transpose(c_tmpMatrix, c_tmpMatrix) : RenderObject.IDENTITY_MATRIX;
            this.setMat4InPage(normalMatrix, MODELVIEW_MATRIX_N_OFFSET);
        }
    })(),


    /** Relies on an up-to-date view matrix **/
    updateModelViewProjectionMatrix: function (projection) {
        var page = this.page;
        var offset = this.offset;
        XML3D.math.mat4.multiplyOffset(page, offset + MODELVIEWPROJECTION_MATRIX_OFFSET, page, offset + MODELVIEW_MATRIX_OFFSET, projection, 0);
    },

    setTransformDirty: function () {
        this.transformDirty = true;
        this.setBoundingBoxDirty();
        this.scene.emit(C.EVENT_TYPE.SCENE_SHAPE_CHANGED);
        this.scene.requestRedraw("Transformation changed");
    },

    setObjectSpaceBoundingBox: function (box) {
        var o = this.offset + OBJECT_BB_OFFSET;
        this.page[o] = box.data[0];
        this.page[o + 1] = box.data[1];
        this.page[o + 2] = box.data[2];
        this.page[o + 3] = box.data[3];
        this.page[o + 4] = box.data[4];
        this.page[o + 5] = box.data[5];
        this.setBoundingBoxDirty();
    },

    getObjectSpaceBoundingBox: function (box) {
        var o = this.offset + OBJECT_BB_OFFSET;
        box.data[0] = this.page[o];
        box.data[1] = this.page[o + 1];
        box.data[2] = this.page[o + 2];
        box.data[3] = this.page[o + 3];
        box.data[4] = this.page[o + 4];
        box.data[5] = this.page[o + 5];
    },

    setBoundingBoxDirty: function () {
        this.boundingBoxDirty = true;
        this.parent.setBoundingBoxDirty();
    },

    setWorldSpaceBoundingBox: function (bbox) {
        var o = this.offset + WORLD_BB_OFFSET;
        this.page[o] = bbox.data[0];
        this.page[o + 1] = bbox.data[1];
        this.page[o + 2] = bbox.data[2];
        this.page[o + 3] = bbox.data[3];
        this.page[o + 4] = bbox.data[4];
        this.page[o + 5] = bbox.data[5];
    },

    getWorldSpaceBoundingBox: function (bbox) {
        if (this.boundingBoxDirty) {
            this.updateWorldSpaceBoundingBox();
        }
        var o = this.offset + WORLD_BB_OFFSET;
        bbox.data[0] = this.page[o];
        bbox.data[1] = this.page[o + 1];
        bbox.data[2] = this.page[o + 2];
        bbox.data[3] = this.page[o + 3];
        bbox.data[4] = this.page[o + 4];
        bbox.data[5] = this.page[o + 5];

    },

    updateWorldSpaceBoundingBox: (function () {
        var c_box = new XML3D.Box();
        var c_trans = mat4.create();

        return function () {
            if(!this.visible) {
                c_box.setEmpty();
            } else {
                this.getObjectSpaceBoundingBox(c_box);
                this.getWorldMatrix(c_trans);
                c_box.transformAxisAligned(c_trans);
            }
            this.setWorldSpaceBoundingBox(c_box);
            this.boundingBoxDirty = false;
        }
    })(),

    visibilityChanged: function () {
        this.setBoundingBoxDirty();
    },

    getProgram: function () {
        return this.drawable.getProgram();
    },

    hasTransparency: function () {
        if (this.override && this.override.opacity !== undefined) {
            return this.override.opacity[0] < 1;
        }
        var program = this.getProgram();
        return program ? program.hasTransparency() : false;
    },

    updateForRendering: function () {
        SystemNotifier.setNode(this.node);
        try {
            this.drawable && this.drawable.update(this.scene);
        } catch (e) {
            XML3D.debug.logError("Mesh Error: " + e.message, this.node);
        }
        SystemNotifier.setNode(null);
    },

    findRayIntersections: (function () {
        var bbox = new XML3D.Box();
        var opt = {dist: 0};

        return function (ray, intersections) {
            this.getWorldSpaceBoundingBox(bbox);
            if (ray.intersects(bbox, opt)) {
                intersections.push(this);
            }
        }
    })(),

        /**
     * @param {MaterialConfiguration|null} material
     */
    setMaterial: function (material) {
        if(this._material === material) {
            return;
        }
        this._material = material;
        if (material) {
            this._actualMaterial = material;
        } else {
            this._actualMaterial = this.parent.getMaterial();
        }
        this.materialChanged();
    },

    setZIndex: function(zIndex){
        this._zIndex = zIndex;
    },

    parentMaterialChanged: function () {
        if (this._material) {
            // Local material overrides the change from above
            return;
        }
        this.initMaterial();
    },

    initMaterial: function () {
        if (this._material) {
            this._actualMaterial = this._material;
        } else {
            this._actualMaterial = this.parent.getMaterial();
        }
        this.materialChanged();
    },

    materialChanged: function() {
        XML3D.debug.logDebug("material changed", this._actualMaterial);
        if (this.drawable) {
            var composer = this.scene.shaderFactory.createComposerFromMaterialConfiguration(this._actualMaterial);
            this.drawable.setShaderComposer(composer);
        }
    },

    remove: function() {
        this.parent.removeChild(this);
        this.scene.pager.freePageEntry({page: this.page, offset: this.offset, size: this.entrySize});
        if (this.drawable) {
            this.drawable.destroy();
        }
    }

});


// Export
module.exports = RenderObject;


},{"../../../xflow/interface/request.js":190,"../../webgl/system/system-notifier.js":158,"./constants.js":98,"./drawableclosure.js":99,"./rendernode.js":103,"./scene.js":107,"gl-matrix":1}],105:[function(require,module,exports){
var RenderNode = require("./rendernode.js");
var CameraModels = require("../cameras/camera-models.js");
var Constants = require("./constants.js");
var Frustum = require("../tools/frustum.js").Frustum;
var vec3 = require("gl-matrix").vec3;
var mat4 = require("gl-matrix").mat4;

/** @const */
var CLIPPLANE_NEAR_MIN = 0.01;

var NODE_TYPE = Constants.NODE_TYPE;
var EVENT_TYPE = Constants.EVENT_TYPE;

/** @const */
var VIEW_TO_WORLD_MATRIX_OFFSET = 0;
/** @const */
var WORLD_TO_VIEW_MATRIX_OFFSET = 16;
/** @const */
var PROJECTION_MATRIX_OFFSET = 32;
/** @const */
var ENTRY_SIZE = PROJECTION_MATRIX_OFFSET + 16;

var DEFAULT_CAMERA_CONFIGURATION = { model: "urn:xml3d:view:perspective", dataNode: null };

/**
 *
 * @constructor
 * @extends {RenderNode}
 */
var RenderView = function (scene, pageEntry, opt) {
    RenderNode.call(this, NODE_TYPE.VIEW, scene, pageEntry, opt);
    opt = opt || {};

    this.lastAspectRatio = 1;
    this.projectionDirty = true;

    this.camera = createCamera(opt.camera ? opt.camera : DEFAULT_CAMERA_CONFIGURATION, scene, this);
    this.localMatrix = mat4.create();
    this.worldSpacePosition = vec3.create();
    this.viewDirty = true;
    this.frustum = null;
};
RenderView.ENTRY_SIZE = ENTRY_SIZE;

XML3D.createClass(RenderView, RenderNode);

XML3D.extend(RenderView.prototype, {

    setLocalMatrix: function (source) {
        this.localMatrix = source;
        this.setTransformDirty();
    },

    getFrustum: function () {
        return this.frustum;
    },

    updateViewMatrix: (function () {
        var tmp_mat4 = mat4.create();
        var tmp_parent = mat4.create();

        return function () {
            mat4.copy(tmp_mat4, this.localMatrix);
            this.parent.getWorldMatrix(tmp_parent);
            mat4.multiply(tmp_mat4, tmp_parent, tmp_mat4);
            vec3.set(this.worldSpacePosition, tmp_mat4[12], tmp_mat4[13], tmp_mat4[14]);
            this.setViewToWorldMatrix(tmp_mat4);
            mat4.invert(tmp_mat4, tmp_mat4);
            this.setWorldToViewMatrix(tmp_mat4);
            this.viewDirty = false;
            // View frustum might have changed due to clipping planes
            this.viewFrustumChanged();
        }
    })(),

    setWorldToViewMatrix: function (source) {
        this.setMat4InPage(source, WORLD_TO_VIEW_MATRIX_OFFSET);
    },

    setViewToWorldMatrix: function (source) {
        this.setMat4InPage(source, VIEW_TO_WORLD_MATRIX_OFFSET);
    },

    setProjectionMatrix: function (source) {
        this.setMat4InPage(source, PROJECTION_MATRIX_OFFSET);
        this.projectionDirty = false;
    },

    setTransformDirty: function () {
        this.viewDirty = true;
        this.scene.requestRedraw("view pose changed");
    },

    getViewToWorldMatrix: function (dest) {
        if (this.viewDirty) {
            this.updateViewMatrix();
        }
        this.getMat4FromPage(dest, VIEW_TO_WORLD_MATRIX_OFFSET);
    },

    getWorldToViewMatrix: function (dest) {
        if (this.viewDirty) {
            this.updateViewMatrix();
        }
        this.getMat4FromPage(dest, WORLD_TO_VIEW_MATRIX_OFFSET);
    },

    getProjectionMatrix: function (dest, aspect) {
        if (this.projectionDirty || Math.abs(aspect - this.lastAspectRatio) > 0.001 ) {
            // Set projectionMatrix
            this.frustum = this.camera.getFrustum(aspect);
            if(this.frustum) {
                this.setProjectionMatrix(this.frustum.getProjectionMatrix(mat4.create()));
            } else {
                this.setProjectionMatrix(this.camera.getProjectionMatrix())
            }
            this.lastAspectRatio = aspect;
        }
        this.getMat4FromPage(dest, PROJECTION_MATRIX_OFFSET);
    },

    getWorldSpacePosition: function () {
        return this.worldSpacePosition;
    },

    getWorldSpaceBoundingBox: function (bbox) {
        bbox.setEmpty();
    },

    viewFrustumChanged: function() {
        this.projectionDirty = true;
        this.scene.requestRedraw("view frustum changed");
    },

    getClippingPlanes: function(bb) {
        if(!bb) {
            bb = new XML3D.Box();
            this.scene.getBoundingBox(bb);
        }
        if (bb.isEmpty()) {
            return {near: 1, far: 10};
        }
        var w2v = mat4.create();
        this.getWorldToViewMatrix(w2v);
        bb.transformAxisAligned(w2v);

        var near = -bb.max.z, far = -bb.min.z, expand = Math.max((far - near) * 0.005, 0.05);

        // Expand the view frustum a bit to ensure 2D objects parallel to the camera are rendered
        near = Math.max(near - expand, expand, CLIPPLANE_NEAR_MIN);
        far = Math.max(far + expand, near + expand);
        return {near: near, far: far};
    },

    remove: function() {
        this.camera.destroy();
    }
});

/**
 * @param {Configuration} configuration
 * @param {Scene} scene
 * @param {RenderView} owner
 * @returns {Object}
 */
function createCamera(configuration, scene, owner) {

    switch(configuration.model) {
        case "urn:xml3d:view:perspective":
            return new CameraModels.PerspectiveCameraModel(configuration.dataNode, scene, owner);
        case "urn:xml3d:view:projective":
            return new CameraModels.ProjectiveCameraModel(configuration.dataNode, scene, owner);
        default:
            XML3D.debug.logWarning("Unknown camera model:", configuration.model);
            return new CameraModels.PerspectiveCameraModel(configuration.dataNode, scene, owner);
    }


}

// Export
module.exports = RenderView;


},{"../cameras/camera-models.js":89,"../tools/frustum.js":109,"./constants.js":98,"./rendernode.js":103,"gl-matrix":1}],106:[function(require,module,exports){
var DataNode = require("../../../xflow/interface/graph.js").DataNode;
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;
var XC = require("../../../xflow/interface/constants.js");
var BufferEntry = require("../../../xflow/interface/data.js").BufferEntry;
var InputNode = require("../../../xflow/interface/graph.js").InputNode;

var SceneParameters = ["width", "height", "aspect", "worldBoundingBox"];

/**
 *
 * @constructor
 */
var SceneData = function() {
    this.data = new DataNode(false);

    var width = createInputNode(this.data, "width", XC.DATA_TYPE.FLOAT, new Float32Array([600]));
    var height = createInputNode(this.data, "height", XC.DATA_TYPE.FLOAT, new Float32Array([800]));
    var worldBoundingBox = createInputNode(this.data, "worldBoundingBox", XC.DATA_TYPE.FLOAT, new XML3D.Box().data);

    var request = new ComputeRequest(this.data, SceneParameters, null);
    var result = this.result = request.getResult();

    defineFloatProperty(this, "width", result, width);
    defineFloatProperty(this, "height", result, height);

    Object.defineProperty(this, "worldBoundingBox", {
        get: function () {
            return result.getOutputData("worldBoundingBox").getValue();
        }, set: function (value) {
            worldBoundingBox.data.setValue(value);
        }
    });

    Object.defineProperty(this, "aspect", { writeable: false, get: function() {
        return result.getOutputData("aspect").getValue()[0];
    }});

    this.data.setCompute("aspect = xflow.div(width, height)");

};

function defineFloatProperty(obj, name, result, field) {
    Object.defineProperty(obj, name, {
        get: function () {
            return result.getOutputData(name).getValue()[0];
        },
        set: function (value) {
            field.data.setValue(new Float32Array([value]));
        }
    });
}


function createInputNode(dataNode, name, type, value) {
    var inputNode = new InputNode();
    inputNode.data = new BufferEntry(type, value);
    inputNode.name = name;
    dataNode.appendChild(inputNode);
    return inputNode;
}


module.exports = SceneData;

},{"../../../xflow/interface/constants.js":187,"../../../xflow/interface/data.js":188,"../../../xflow/interface/graph.js":189,"../../../xflow/interface/request.js":190}],107:[function(require,module,exports){
var Pager = require("./pager.js");
var RenderObject = require("./renderobject.js");
var RenderView = require("./renderview.js");
var RenderGroup = require("./rendergroup.js");
var RenderLight = require("./renderlight.js");
var MaterialConfiguration = require("./configuration.js");
var LightManager = require("../lights/light-manager.js");
var C = require("./constants.js");
var InputNode = require("../../../xflow/interface/graph.js").InputNode;
var DataNode = require("../../../xflow/interface/graph.js").DataNode;
var BufferEntry = require("../../../xflow/interface/data.js").BufferEntry;
var SceneData = require("./scene-data.js");
var XC = require("../../../xflow/interface/constants.js");
var URI = require("../../../utils/uri.js").URI;
var EventEmitter = require('events').EventEmitter;
var mat4 = require("gl-matrix").mat4;
var assert = require("assert");
/**
 * @extends {EventEmitter}
 * @constructor
 */
var Scene = function () {
    EventEmitter.call(this);
    this.boundingBox = new XML3D.Box();
    this.lights = new LightManager();
    this.pager = new Pager();

    /** @type RenderView */
    this.activeView = null;

    /** @type MaterialConfiguration */
    this._defaultMaterial = null;

    this.rootNode = this.createRootNode();

    var data = this.data = new SceneData();

    Object.defineProperty(this, "width", {
        get: function() { return data.width; },
        set: function(width) { data.width = width; }
    });

    Object.defineProperty(this, "height", {
        get: function() { return data.height; },
        set: function(height) { data.height = height; }
    });

};

XML3D.createClass(Scene, EventEmitter, {
    /**
     * @returns {RenderView}
     */
    getActiveView: function () {
        return this.activeView;
    }, /**
     * @param {RenderView} view
     */
    setActiveView: function (view) {
        if (view != this.activeView) {
            assert(view, "Active view must not be null");
            this.activeView = view;
            this.emit(C.EVENT_TYPE.VIEW_CHANGED, this.activeView);
        }
    },
    /**
     * @param {object?} opt
     * @returns {RenderObject}
     */
    createRenderObject: function (opt) {
        var pageEntry = this.pager.getPageEntry(RenderObject.ENTRY_SIZE);
        return new RenderObject(this, pageEntry, opt);
    },

    createRenderGroup: function (opt) {
        var pageEntry = this.pager.getPageEntry(RenderGroup.ENTRY_SIZE);
        return new RenderGroup(this, pageEntry, opt);
    },

    createRenderView: function (opt) {
        var pageEntry = this.pager.getPageEntry(RenderView.ENTRY_SIZE);
        return new RenderView(this, pageEntry, opt);
    },

    createRenderLight: function (opt) {
        var pageEntry = this.pager.getPageEntry(RenderLight.ENTRY_SIZE);
        return new RenderLight(this, pageEntry, opt);
    },

    createMaterialConfiguration: function(model, data, opt) {
        return new MaterialConfiguration(model, data, opt);
    },

    createRootNode: function () {
        var pageEntry = this.pager.getPageEntry(RenderGroup.ENTRY_SIZE);
        var root = new RenderGroup(this, pageEntry, {
            material: this.getDefaultMaterial(), name: "@scene"
        });
        root.setWorldMatrix(mat4.create());
        root.setLocalMatrix(mat4.create());
        root.transformDirty = false;
        return root;
    },

    updateBoundingBox: function () {
        if (this.rootNode.boundingBoxDirty) {
            this.rootNode.getWorldSpaceBoundingBox(this.boundingBox);
            this.data.worldBoundingBox = this.boundingBox.data;
        }
    },

    getBoundingBox: function (bb) {
        this.updateBoundingBox();
        bb.copy(this.boundingBox);
    },

    createDrawable: function (/*obj*/) {
        throw new Error("Scene::createDrawable not implemented");
    },

    requestRedraw: function (/*reason*/) {
        throw new Error("Scene::requestRedraw not implemented");
    },

    traverse: function (callback) {
        this.rootNode.traverse(callback);
    },

    /**
     * Returns all objects intersected by the given ray, based on their bounding boxes
     * @param ray
     * @returns {Array} An array of RenderObjects that were hit by this ray
     */
    findRayIntersections: function (ray) {
        var intersections = [];
        this.rootNode.findRayIntersections(ray, intersections);
        return intersections;
    },

    getDefaultMaterial: function() {
        if(!this._defaultMaterial) {
            var inputNode = new InputNode();
            inputNode.data = new BufferEntry(XC.DATA_TYPE.FLOAT3, new Float32Array([1, 0, 0]));
            inputNode.name = "diffuseColor";

            var data = new DataNode(false);
            data.appendChild(inputNode);

            this._defaultMaterial = this.createMaterialConfiguration(
                {"type": "urn", "urn": new URI("urn:xml3d:material:matte")},
                data,
                {name: "default"}
            );
        }
        return this._defaultMaterial;
    },

    handleResizeEvent: function (width, height) {
        this.width = width;
        this.height = height;
    }



});

module.exports = Scene;

},{"../../../utils/uri.js":184,"../../../xflow/interface/constants.js":187,"../../../xflow/interface/data.js":188,"../../../xflow/interface/graph.js":189,"../lights/light-manager.js":94,"./configuration.js":97,"./constants.js":98,"./pager.js":100,"./rendergroup.js":101,"./renderlight.js":102,"./renderobject.js":104,"./renderview.js":105,"./scene-data.js":106,"assert":11,"events":12,"gl-matrix":1}],108:[function(require,module,exports){
var DataChangeNotifier = require("../../../xflow/interface/data.js").DataChangeNotifier;

/**
 *
 * @constructor
 */
var DataChangeListener = function () {
    DataChangeNotifier.addListener(this.dataEntryChanged);
};

/**
 *
 * @param {Xflow.DataEntry} entry
 * @param {Xflow.DATA_ENTRY_STATE} notification
 */
DataChangeListener.prototype.dataEntryChanged = function (entry, notification) {
    if (entry.userData.webglData) {
        for (var i in entry.userData.webglData) {
            var oldChanged = entry.userData.webglData[i].changed;
            entry.userData.webglData[i].changed = Math.max(oldChanged, notification);
        }
    }
};

module.exports = DataChangeListener;

},{"../../../xflow/interface/data.js":188}],109:[function(require,module,exports){
var vec3 = require("gl-matrix").vec3;
var tmp1 = vec3.create();
var tmp2 = vec3.create();
var assert = require("assert");

/**
 *
 * @param {number} nearPlane
 * @param {number} farPlane
 * @param {number} fovx
 * @param {number} fovy
 * @param {number} aspect
 * @param {boolean} orthographic
 * @constructor
 */
var Frustum = function (nearPlane, farPlane, fovx, fovy, aspect, orthographic) {
    this.setFrustum(nearPlane, farPlane, fovx, fovy, aspect, orthographic);
};

XML3D.extend(Frustum.prototype, {
    /**
     *
     * @param nearPlane
     * @param farPlane
     * @param fovx Horizontal field of view in radians
     * @param fovy Vertical field of view in radians
     * @param aspect
     * @param {bool?} orthographic
     */
    setFrustum: function (nearPlane, farPlane, fovx, fovy, aspect , orthographic) {
        assert(nearPlane > 0 && farPlane > 0, "Near or far plane undefined or non-positive");
        assert(!(fovx && fovy), "fovx and fovy cannot both be non-zero.");
        assert(aspect > 0, "aspect cannot both be non-zero.");

        if (fovx) {
            this.right = nearPlane * Math.tan(fovx / 2);
            this.left = -this.right;
            this.top = ((this.right - this.left) / aspect) / 2;
            this.bottom = -this.top;
        } else {
            this.top = nearPlane * Math.tan(0.5 * fovy);
            this.bottom = -this.top;
            this.right = (this.top - this.bottom) * aspect / 2;
            this.left = -this.right;
        }
        this.nearPlane = nearPlane;
        this.farPlane = farPlane;

        this.orthographic = orthographic == undefined ? false : orthographic;
    },

    getProjectionMatrix: function (matrix) {
        var limitMax = Number.MAX_VALUE;
        var rightPlusLeft = this.right + this.left;
        var rightMinusLeft = this.right - this.left;

        var topPlusBottom = this.top + this.bottom;
        var topMinusBottom = this.top - this.bottom;

        var farPlusNear = this.farPlane + this.nearPlane;
        var farMinusNear = this.farPlane - this.nearPlane;

        if ((Math.abs(rightMinusLeft) < 1 && Math.abs(rightPlusLeft) > limitMax * Math.abs(rightMinusLeft)) || (Math.abs(topMinusBottom) < 1 && Math.abs(topPlusBottom) > limitMax * Math.abs(topMinusBottom)) || (Math.abs(farMinusNear) < 1 && Math.abs(farPlusNear) > limitMax * Math.abs(farMinusNear))) {
            throw new Error("Bad viewing frustum: projection matrix cannot be computed.");
        }

        var A, B, C, D, E, F;
        var m = matrix.data ? matrix.data : matrix;

        if (this.orthographic) {
            var tx = -rightPlusLeft / rightMinusLeft;
            var ty = -topPlusBottom / topMinusBottom;
            var tz = -farPlusNear / farMinusNear;

            if ((Math.abs(rightMinusLeft) < 1 && 2 > limitMax * Math.abs(rightMinusLeft)) || (Math.abs(topMinusBottom) < 1 && 2 > limitMax * Math.abs(topMinusBottom)) || (Math.abs(farMinusNear) < 1 && 2 > limitMax * Math.abs(farMinusNear))) {
                throw new Error("Bad viewing frustum:  projection matrix cannot be computed.");
            }

            A = 2 / rightMinusLeft;
            B = 2 / topMinusBottom;
            C = -2 / farMinusNear;

            XML3D.math.mat4.identity(m);
            m[0] = A;
            m[5] = B;
            m[10] = C;
            m[12] = tx;
            m[13] = ty;
            m[14] = tz;
            m[15] = 1.0;
        } else {
            A = rightPlusLeft / rightMinusLeft;
            B = topPlusBottom / topMinusBottom;
            C = -farPlusNear / farMinusNear;

            var farTimesNear = -2 * this.farPlane * this.nearPlane;
            if (Math.abs(farMinusNear) < 1 && Math.abs(farTimesNear) > limitMax * Math.abs(farMinusNear)) {
                throw new Error("Bad viewing frustum: projection matrix cannot be computed.");
            }

            D = farTimesNear / farMinusNear;

            var twoTimesNear = 2 * this.nearPlane;

            if ((Math.abs(rightMinusLeft) < 1 && Math.abs(twoTimesNear) > limitMax * Math.abs(rightMinusLeft)) || (Math.abs(topMinusBottom) < 1 && Math.abs(twoTimesNear) > limitMax * Math.abs(topMinusBottom))) {
                throw new Error("Bad viewing frustum: projection matrix cannot be computed.");
            }

            E = twoTimesNear / rightMinusLeft;
            F = twoTimesNear / topMinusBottom;

            XML3D.math.mat4.identity(m);
            m[0] = E;
            m[5] = F;
            m[8] = A;
            m[9] = B;
            m[10] = C;
            m[11] = -1;
            m[14] = D;
            m[15] = 0;
        }
        return matrix;
    },

    getPlanes: (function () {

        var c_a = vec3.create();
        var c_b = vec3.create();
        var c_c = vec3.create();
        var c_d = vec3.create();

        var c_e = vec3.create();
        var c_f = vec3.create();
        var c_g = vec3.create();
        var c_o = vec3.create();


        return function (planes, M) {
            vec3.transformMat4(c_a, [this.left, this.bottom, -this.nearPlane], M);
            vec3.transformMat4(c_b, [this.left, this.top, -this.nearPlane], M);
            vec3.transformMat4(c_c, [this.right, this.top, -this.nearPlane], M);
            vec3.transformMat4(c_d, [this.right, this.bottom, -this.nearPlane], M);
            if (!this.orthographic) {
                var s = this.farPlane / this.nearPlane;
                var farLeft = s * this.left;
                var farRight = s * this.right;
                var farTop = s * this.top;
                var farBottom = s * this.bottom;
                vec3.transformMat4(c_e, [farLeft, farBottom, -this.farPlane], M);
                vec3.transformMat4(c_f, [farLeft, farTop, -this.farPlane], M);
                vec3.transformMat4(c_g, [farRight, farTop, -this.farPlane], M);
                vec3.transformMat4(c_o, [0, 0, 0], M);
                planes[0].setFromPoints(c_o, c_c, c_b);
                planes[1].setFromPoints(c_o, c_d, c_c);
                planes[2].setFromPoints(c_o, c_a, c_d);
                planes[3].setFromPoints(c_o, c_b, c_a);
                planes[4].setFromPoints(c_a, c_d, c_c);
                planes[5].setFromPoints(c_e, c_f, c_g);
            } else {
                vec3.transformMat4(c_e, [this.left, this.bottom, -this.farPlane], M);
                vec3.transformMat4(c_f, [this.left, this.top, -this.farPlane], M);
                vec3.transformMat4(c_g, [this.right, this.top, -this.farPlane], M);
                vec3.transformMat4(c_o, [this.right, this.bottom, -this.farPlane], M);
                planes[0].setFromPoints(c_c, c_g, c_f);
                planes[1].setFromPoints(c_d, c_o, c_g);
                planes[2].setFromPoints(c_a, c_e, c_o);
                planes[3].setFromPoints(c_b, c_f, c_e);
                planes[4].setFromPoints(c_a, c_d, c_c);
                planes[5].setFromPoints(c_e, c_f, c_g);
            }
        };
    }())


});


var Plane = function () {
    this.distance = 0;
    this.normal = vec3.create();
};

XML3D.extend(Plane.prototype, {
    setFromPoints: function (point1, point2, point3) {
        vec3.cross(this.normal, vec3.sub(tmp2, point3, point1), vec3.sub(tmp1, point2, point1));
        vec3.normalize(this.normal, this.normal);
        this.distance = -vec3.dot(this.normal, point1);
    },

    set: function (x, y, z, distance) {
        vec3.set(this.normal, x, y, z);
        vec3.normalize(this.normal, this.normal);
        this.distance = distance;
    }
});

var FrustumTest = function (frustum, cameraMatrix) {
    this.frustumPlanes = [new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()];
    if (frustum && cameraMatrix) {
        this.set(frustum, cameraMatrix);
    }
};


XML3D.extend(FrustumTest.prototype, {
    /**
     *
     * @param {Frustum} frustum
     * @param {mat4} matrix
     */
    set: function (frustum, matrix) {
        frustum.getPlanes(this.frustumPlanes, matrix);

    }, /**
     * @param bbox
     * @returns {boolean}
     */
    isBoxVisible:  function (bbox) {
            if (bbox.isEmpty())
                return false;

            for (var i = 0; i < this.frustumPlanes.length; i++) {
                var plane = this.frustumPlanes[i];
                var normal = plane.normal;
                var bbx = normal[0] >= 0.0 ? bbox.data[3] : bbox.data[0];
                var bby = normal[1] >= 0.0 ? bbox.data[4] : bbox.data[1];
                var bbz = normal[2] >= 0.0 ? bbox.data[5] : bbox.data[2];

                // Compute the distance
                var distance = bbx * normal[0] + bby * normal[1] + bbz * normal[2] + plane.distance;
                assert(!isNaN(distance));

                // if highest point is below plane then all below.
                if (distance < 0.0) {
                    return false;
                }
            }
            return true;
    }

});

module.exports = {
    Plane: Plane,
    Frustum: Frustum,
    FrustumTest: FrustumTest
};

},{"assert":11,"gl-matrix":1}],110:[function(require,module,exports){
var vec3 = require("gl-matrix").vec3;

/**
 *
 * @constructor
 */
var ObjectSorter = function () {

};

var c_bbox = new XML3D.Box();
var c_center = vec3.create();

XML3D.extend(ObjectSorter.prototype, {
    /**
     * @param {Array} sourceObjectArray
     * @param {XML3D.Mat4?} viewMatrix Matrix to apply to objects world space extend before sorting
     */
    sortObjects: function (sourceObjectArray, viewMatrix) {
        var presortOpaque = {}, presortTransparent = {}, obj, zLayer, i, l, n;

        // Sort by transparency and z-index
        for (i = 0, l = sourceObjectArray.length; i < l; i++) {
            obj = sourceObjectArray[i];
            if (obj.inFrustum === false) {
                continue;
            }
            if (obj.hasTransparency()) {
                if (!presortTransparent[obj._zIndex]) {
                    presortTransparent[obj._zIndex] = [obj];
                } else {
                    presortTransparent[obj._zIndex].push(obj);
                }
            } else {
                if (!presortOpaque[obj._zIndex]) {
                    presortOpaque[obj._zIndex] = [obj];
                } else {
                    presortOpaque[obj._zIndex].push(obj);
                }
            }
        }

        // Separate the scene into z-layers according to z-index
        var zLayers = Object.keys(presortOpaque).concat(Object.keys(presortTransparent));
        zLayers = zLayers.sort(function(a,b) {
            return a.localeCompare(b);
        }).filter(function(item, pos, ary) {
            // Remove duplicates
            return !pos || item != ary[pos - 1];
        });

        // Sort opaque z-buckets by shader
        var opaque = {};
        for (i=0; i<zLayers.length; i++) {
            zLayer = zLayers[i];
            opaque[zLayer] = {};
            for (n in presortOpaque[zLayer]) {
                obj = presortOpaque[zLayer][n];
                var program = obj.getProgram();
                opaque[zLayer][program.id] = opaque[zLayer][program.id] || [];
                opaque[zLayer][program.id].push(obj);
            }
        }

        // Sort opaque shader buckets by depth for early z fails
        for (zLayer in zLayers) {
            for (var progId in opaque[zLayer]) {
                var withinShader = opaque[zLayer][progId];
                var sortedArray = new Array(withinShader.length);
                for (i = 0; i < withinShader.length; i++) {
                    obj = withinShader[i];
                    obj.getWorldSpaceBoundingBox(c_bbox);
                    c_bbox.center(c_center);
                    viewMatrix && vec3.transformMat4(c_center, c_center, viewMatrix);
                    sortedArray[i] = {
                        obj: obj, depth: c_center.z
                    };
                }
                sortedArray.sort(function (a, b) {
                    return b.depth - a.depth;
                });
                opaque[zLayer][progId] = sortedArray.map(function (e) {
                    return e.obj;
                });
            }
        }

        //Sort transparent z-buckets back to front
        var transparent = {};
        for (var ind in zLayers) {
            zLayer = zLayers[ind];
            var tlayer = [];
            for (n in presortTransparent[zLayer]) {
                obj = presortTransparent[zLayer][n];
                obj.getWorldSpaceBoundingBox(c_bbox);
                c_bbox.center(c_center);
                viewMatrix && vec3.transformMat4(c_center, c_center, viewMatrix);
                tlayer.push([obj, c_center.z]);
            }

            tlayer.sort(function (a, b) {
                return a[1] - b[1];
            });

            for (i = 0; i < tlayer.length; i++) {
                tlayer[i] = tlayer[i][0];
            }

            transparent[zLayer] = tlayer;
        }

        // zLayers contains all unique z-index values in the scene, partitioning it into z-buckets
        return {
            opaque: opaque, transparent: transparent, zLayers : zLayers
        }
    }

});


module.exports = ObjectSorter;



},{"gl-matrix":1}],111:[function(require,module,exports){
/** Calculate the offset of the given element and return it.
 *
 *  @param {Object} element
 *  @return {{top:number, left:number}} the offset
 *
 *  This code is taken from http://javascript.info/tutorial/coordinates .
 *  We don't want to do it with the offsetParent way, because the xml3d
 *  element is actually invisible and thus offsetParent will return null
 *  at least in WebKit. Also it's slow. So we use getBoundingClientRect().
 *  However it returns the box relative to the window, not the document.
 *  Thus, we need to incorporate the scroll factor. And because IE is so
 *  awesome some workarounds have to be done and the code gets complicated.
 */
function calculateOffset(element) {
    var box = element.getBoundingClientRect();
    var body = document.body;
    var docElem = document.documentElement;

    // get scroll factor (every browser except IE supports page offsets)
    var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
    var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;

    // the document (`html` or `body`) can be shifted from left-upper corner in IE. Get the shift.
    var clientTop = docElem.clientTop || body.clientTop || 0;
    var clientLeft = docElem.clientLeft || body.clientLeft || 0;

    var top = box.top + scrollTop - clientTop;
    var left = box.left + scrollLeft - clientLeft;

    // for Firefox an additional rounding is sometimes required
    return {top: Math.round(top), left: Math.round(left)};
}


module.exports = {

    /** Convert a given mouse page position to be relative to the given target element.
     *  Most probably the page position are the MouseEvent's pageX and pageY attributes.
     *
     *  @param {!Object} xml3dEl the xml3d element to which the coords need to be translated
     *  @param {!number} pageX the x-coordinate relative to the page
     *  @param {!number} pageY the y-coordinate relative to the page
     *  @return {{x: number, y: number}} the converted coordinates
     */
    convertPageCoords: function (xml3dEl, pageX, pageY) {
        var off = calculateOffset(xml3dEl);

        return {x: pageX - off.left, y: pageY - off.top};
    }
};

},{}],112:[function(require,module,exports){
var TextureManager = require("texture-manager").SimpleTextureManager;
var GLTexture = require("./texture.js").GLTexture;
var GLCubeMap = require("./texture.js").GLCubeMap;
var GLCanvasTarget = require("./rendertarget.js").GLCanvasTarget;
var ProgramFactory = require("./../shader/programfactory.js");
var XC = require("../../../xflow/interface/constants.js");
var GL = require("../constants.js");

var CONTEXT_OPTIONS = {
    alpha: true, premultipliedAlpha: false, antialias: true, stencil: true, preserveDrawingBuffer: true
};

/**
 * @param {HTMLCanvasElement!} canvas
 */
function getContextForCanvas(canvas) {
    try {
        return canvas.getContext('experimental-webgl', CONTEXT_OPTIONS);
    } catch (e) {
        return null;
    }
}

/**
 * Context that includes all GL related resources / handlers
 * @param {HTMLCanvasElement!} canvas
 * @param {number} id
 * @constructor
 */
var GLContext = function (canvas, id) {
    this.gl = getContextForCanvas(canvas);
    this.id = id;
    this.canvasTarget = new GLCanvasTarget(this, canvas.clientWidth, canvas.clientHeight);
    this.programFactory = new ProgramFactory(this);
    this.textureManager = new TextureManager({ units: this.gl.getParameter(GL.MAX_COMBINED_TEXTURE_IMAGE_UNITS )});
    this.stats = {
        materials: 0, meshes: 0
    };
    this.extensions = populateExtensions(this.gl);

};

var EXTENSIONS = GLContext.EXTENSIONS = {};
EXTENSIONS.STANDARD_DERIVATES = 'OES_standard_derivatives';
EXTENSIONS.MULTIPLE_RENDER_TARGETS = 'WEBGL_draw_buffers';
EXTENSIONS.DEPTH_TEXTURE = 'WEBGL_depth_texture';
EXTENSIONS.FLOAT_COLOR_BUFFER = 'WEBGL_color_buffer_float';
EXTENSIONS.FLOAT_TEXTURES = 'OES_texture_float';
EXTENSIONS.FLOAT_TEXTURES_LINEAR = "OES_texture_float_linear";
EXTENSIONS.UINT32_INDICES = 'OES_element_index_uint'; //Also defined in xflow/utils/utils.js

XML3D.extend(GLContext.prototype, {
    getXflowEntryWebGlData: function (entry) {
        return getXflowEntryWebGlData(entry, this.id);
    },

    requestRedraw: function (reason) {
        //handler.redraw(reason, forcePicking);
    },

    handleResizeEvent: function (width, height) {
        this.canvasTarget = new GLCanvasTarget(this, width, height);
    },

    getStatistics: function () {
        return this.stats;
    },

    getExtensionByName: function (name) {
        return this.extensions[name];
    } ,

    createTexture: function() {
        return new GLTexture(this);
    } ,
    createCubeMap: function() {
        return new GLCubeMap(this);
    }
});


function getXflowEntryWebGlData(entry, canvasId){
    if(!entry) return null;
    if(!entry.userData.webglData)
        entry.userData.webglData = {};
    if(!entry.userData.webglData[canvasId])
        entry.userData.webglData[canvasId] = {
            changed : XC.DATA_ENTRY_STATE.CHANGED_NEW
        };
    return entry.userData.webglData[canvasId];
}

/**
 * @param {WebGLRenderingContext} gl
 * @returns {{}}
 */
function populateExtensions(gl) {
    var result = {};
    for (var name in EXTENSIONS) {
        var extensionName = EXTENSIONS[name];
        var ext = gl.getExtension(extensionName);
        if (!ext) {
            XML3D.debug.logInfo(extensionName, "is not supported on your graphics card");
        } else {
            result[extensionName] = ext;
        }
    }
    return result;
}

module.exports = GLContext;



},{"../../../xflow/interface/constants.js":187,"../constants.js":120,"./../shader/programfactory.js":156,"./rendertarget.js":116,"./texture.js":117,"texture-manager":43}],113:[function(require,module,exports){
var FullscreenQuad = function (context) {
    this.gl = context.gl;
    this.createGLAssets();
};

XML3D.extend(FullscreenQuad.prototype, {

    createGLAssets: function () {
        var gl = this.gl;
        this.posBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0]), gl.STATIC_DRAW);
    },

    draw: function (program) {
        var gl = this.gl;
        var posAttr = program.attributes["position"];
        gl.enableVertexAttribArray(posAttr.location);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer);
        gl.vertexAttribPointer(posAttr.location, 3, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        gl.disableVertexAttribArray(posAttr.location);
    }

});

module.exports = FullscreenQuad;


},{}],114:[function(require,module,exports){
var GL = require("../constants.js");

/**
 *
 * @param context
 * @constructor
 */
var GLMesh = function (context) {
    this.context = context;
    this.buffers = {};
    this.uniformOverride = {};
    this.minIndex = 0;
    this.maxIndex = 0;
    this.isIndexed = false;
    this.vertexCount = null;
    this.minAttributeCount = -1;
    this.context.getStatistics().meshes++;
    this.glType = null;
    this.multiDraw = false;
};

XML3D.extend(GLMesh.prototype, {
    setIndexRange: function (minIndex, maxIndex) {
        this.minIndex = minIndex;
        this.maxIndex = maxIndex;
    },

    setPrimitiveType: function(type) {
        this.glType = type;
        this.multiDraw = (this.glType == GL.LINE_STRIP || this.glType == GL.TRIANGLE_STRIP);
    },

    checkBufferCompatible: function (name, xflowDataBuffer) {
        var cnt = xflowDataBuffer.getIterateCount();
        this.minAttributeCount = (this.minAttributeCount == -1 ? cnt : Math.min(this.minAttributeCount, cnt));

        if (this.isIndexed) {
            if (cnt <= this.maxIndex) {
                throw new Error("Index range of [" + this.minIndex + ", " + this.maxIndex + "] " + " goes beyond element count " + cnt + " of attribute '" + name + "'");
            }
        } else if (this.vertexCount !== null) {
            if (cnt < this.vertexCount)
                throw new Error("VertexCount " + this.vertexCount + " is larger than element count " + cnt + " of attribute '" + name + "'");
        }
    },

    removeBuffer: function (name) {
        delete this.buffers[name];
    },

    setBuffer: function (name, buffer) {
        this.buffers[name] = buffer;
        this.isIndexed = this.isIndexed || name == "index";
    },

    clear: function () {
        this.buffers = {};
        this.uniformOverride = {};
        this.minIndex = this.maxIndex = 0;
        this.isIndexed = false;
        this.minAttributeCount = -1;
    },

    getUniformOverride: function(name) {
        return this.uniformOverride[name];
    },

    setUniformOverride: function (name, value) {
        if (value === undefined)
            delete this.uniformOverride[name];
        this.uniformOverride[name] = value;
    },

    setVertexCount: function (vertexCount) {
        this.vertexCount = vertexCount;
    },

    isReadyToRender: function () {
        return this.minAttributeCount > 0;
    },

    /**
     * @returns {number}
     */
    getElementCount: function () {
        try {
            return this.buffers.index.length;
        } catch (e) {
            //XML3D.debug.logError("Could not calculate element count.", e);
            return 0;
        }
    }, /**
     * @returns {number}
     */
    getVertexCount: function () {
        try {
            return (this.vertexCount != null ? this.vertexCount : this.minAttributeCount );
        } catch (e) {
            //XML3D.debug.logError("Could not calculate vertex count.", e);
            return 0;
        }
    },

    /**
     * @param {AbstractShaderClosure} program
     * @private
     */
    _bindVertexBuffers: function(program) {
        var gl = this.context.gl, sAttributes = program.attributes, buffers = this.buffers, i, name;

        var keys = Object.keys(sAttributes);
        var keyLength = keys.length;

        for (i = 0; i < keyLength; i++) {
            name = keys[i];
            var buffer = buffers[name];
            var location = sAttributes[name].location;

            if (!buffer) {
                continue;
            }
            gl.enableVertexAttribArray(location);
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.vertexAttribPointer(location, buffer.tupleSize, buffer.glType, false, 0, 0);
        }
    },

    _unbindVertexBuffers: function (program) {
        var gl = this.context.gl, sAttributes = program.attributes;
        for (var name in sAttributes) {
            var shaderAttribute = sAttributes[name];
            gl.disableVertexAttribArray(shaderAttribute.location);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    },

    /**
     * @param {AbstractShaderClosure} program
     * @returns {number}
     */
    draw: function (program) {
        var gl = this.context.gl, sAttributes = program.attributes, buffers = this.buffers, triCount = 0, offset, j;

        //Bind vertex buffers
        this._bindVertexBuffers(program);

        //Draw the object
        if (this.isIndexed) {
            var indexBuffer = buffers.index;
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexBuffer);

            if (this.multiDraw && this.vertexCount) {
                offset = 0;
                for (j = 0; j < this.vertexCount.length; j++) {
                    var count = this.vertexCount[j];
                    gl.drawElements(this.glType, count, indexBuffer.glType, offset * indexBuffer.bytesPerElement);
                    offset += count;
                }
            } else {
                gl.drawElements(this.glType, this.getElementCount(), indexBuffer.glType, 0);
            }
            triCount = this.getElementCount() / 3;
        } else { // not indexed
            if (this.multiDraw && this.vertexCount) {
                offset = 0;
                for (j = 0; j < this.vertexCount.length; j++) {
                    var count = this.vertexCount[j];
                    gl.drawArrays(this.glType, offset, count);
                    offset += count;
                }
            } else {
                gl.drawArrays(this.glType, 0, this.getVertexCount());
                triCount = this.getVertexCount();
            }
        }

        //Unbind vertex buffers
        this._unbindVertexBuffers(program);


        if (program.undoUniformVariableOverride)
            program.undoUniformVariableOverride(this.uniformOverride);

        return triCount;
    }


});

module.exports = GLMesh;

},{"../constants.js":120}],115:[function(require,module,exports){

var utils = require("./utils.js");
var SystemNotifier = require("../system/system-notifier.js");
var GL = require("../constants.js");

//noinspection JSValidateJSDoc
/**
 * @param {WebGLRenderingContext} gl
 * @param {Number} type
 * @param {string} shaderSource
 * @return {WebGLShader}
 */
var createWebGLShaderFromSource = function (gl, type, shaderSource) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, shaderSource);
    gl.compileShader(shader);

    if (gl.getShaderParameter(shader, GL.COMPILE_STATUS) == 0) {
        var message = gl.getShaderInfoLog(shader);
        var errorString = "";
        if (type == GL.VERTEX_SHADER)
            errorString = "Vertex shader failed to compile: \n"; else
            errorString = "Fragment shader failed to compile: \n";

        errorString += message + "\n--------\n";
        errorString += "Shader Source:\n--------\n";
        errorString += XML3D.debug.formatSourceCode(shaderSource);
        gl.getError();
        SystemNotifier.sendEvent('glsl', {
                glslType: "compile_error",
                shaderType: type == GL.VERTEX_SHADER ? "vertex" : "fragment",
                code: shaderSource,
                message: message
            });

        throw new Error(errorString)
    }
    return shader;
};

//noinspection JSValidateJSDoc
/**
 * @param {WebGLRenderingContext} gl
 * @param vertexSources
 * @param fragmentSources
 * @returns {WebGLProgram}
 */
var createProgramFromSources = function (gl, vertexSources, fragmentSources) {
    var shd, s, src;
    var shaders = [];
    for (s in vertexSources) {
        src = vertexSources[s];
        shd = createWebGLShaderFromSource(gl, GL.VERTEX_SHADER, src);
        shaders.push(shd);
    }
    for (s in fragmentSources) {
        src = fragmentSources[s];
        shd = createWebGLShaderFromSource(gl, GL.FRAGMENT_SHADER, src);
        shaders.push(shd);
    }
    return createProgramFromShaders(gl, shaders);
};

//noinspection JSValidateJSDoc
/**
 * @param {WebGLRenderingContext} gl
 * @param {Object} shaders
 * @return {WebGLProgram}
 */
var createProgramFromShaders = function (gl, shaders) {
    var program = gl.createProgram();
    for (var s in shaders) {
        var shader = shaders[s];
        gl.attachShader(program, shader);
    }
    gl.linkProgram(program);
    if (gl.getProgramParameter(program, GL.LINK_STATUS) == 0) {
        var message = gl.getProgramInfoLog(program);
        var errorString = "Shader linking failed: \n";
        errorString += message;
        errorString += "\n--------\n";
        gl.getError();
        SystemNotifier.sendEvent('glsl', {glslType: "link_error", message: message});
        throw new Error(errorString);
    }
    return program;
};

var tally = function (gl, handle, programObject) {
    var i;
    // Tally shader attributes
    var numAttributes = gl.getProgramParameter(handle, gl.ACTIVE_ATTRIBUTES);
    for (i = 0; i < numAttributes; i++) {
        var att = gl.getActiveAttrib(handle, i);
        if (!att)
            continue;
        var attInfo = {};
        attInfo.name = att.name;
        attInfo.size = att.size;
        attInfo.glType = att.type;
        attInfo.location = gl.getAttribLocation(handle, att.name);
        programObject.attributes[att.name] = attInfo;
    }


    // Tally shader uniforms and samplers
    var numUniforms = gl.getProgramParameter(handle, gl.ACTIVE_UNIFORMS);
    for (i = 0; i < numUniforms; i++) {
        var uni = gl.getActiveUniform(handle, i);
        if (!uni)
            continue;
        var uniInfo = {};
        uniInfo.name = uni.name;
        uniInfo.size = uni.size;
        uniInfo.glType = uni.type;
        uniInfo.location = gl.getUniformLocation(handle, uni.name);

        var name = uniInfo.name;

        // Remove array identifier from name, this is handled by size
        if (name.substring(name.length - 3) == "[0]") {
            name = name.substring(0, name.length - 3); // Remove [0]
        }

        if (uni.type == gl.SAMPLER_2D || uni.type == gl.SAMPLER_CUBE) {
            // Set all texture units to 0, needs to be Int32Array
            uniInfo.cachedUnits = new Int32Array(uniInfo.size);
            uniInfo.textures = [];
            // Caches this information
            utils.setUniform(gl, uniInfo, uniInfo.cachedUnits);

            programObject.samplers[name] = uniInfo;
        } else
            programObject.uniforms[name] = uniInfo;
    }

};

var uniqueObjectId = utils.getUniqueCounter();

/**
 * @constructor
 * @param {WebGLRenderingContext} gl
 * @param {{ fragment: string, vertex: string }} sources
 */
var ProgramObject = function (gl, sources) {
    this.gl = gl;
    this.sources = sources;

    this.id = uniqueObjectId();
    this.attributes = {};
    this.uniforms = {};
    this.samplers = {};
    this.handle = null;

    this.create();
};

XML3D.extend(ProgramObject.prototype, {
    create: function () {
        XML3D.debug.logDebug("Create shader program: ", this.id);
        this.handle = createProgramFromSources(this.gl, [this.sources.vertex], [this.sources.fragment]);
        if (!this.handle)
            return;
        SystemNotifier.sendEvent('glsl', {glslType: "success"});
        this.bind();
        tally(this.gl, this.handle, this);
    },

    bind: function () {
        if (!this.handle) {
            XML3D.debug.logError("Trying to bind invalid GLProgram.");
        }
        this.gl.useProgram(this.handle);

        /**
         * Some of the dependent textures may have changed their texture units
         */
        for (var name in this.samplers) {
            var sampler = this.samplers[name];
            if(sampler.textures.length) {
                this.setSamplerFromTextures(sampler);
            }
        }
    },

    unbind: function () {
    }, isValid: function () {
        return !!this.handle;
    }, setUniformVariables: function (envNames, sysNames, inputCollection) {
        var i, base, override, name;
        if (envNames && inputCollection.envBase) {
            i = envNames.length;
            base = inputCollection.envBase;
            override = inputCollection.envOverride;
            while (i--) {
                name = envNames[i];
                this.setUniformVariable(name, override && override[name] !== undefined ? override[name] : base[name]);
            }
        }
        if (sysNames && inputCollection.sysBase) {
            i = sysNames.length;
            base = inputCollection.sysBase;
            while (i--) {
                name = sysNames[i];
                this.setUniformVariable(name, base[name]);
            }
        }
    }, setUniformVariable: function (name, value) {
        if (value === undefined) return;
        if (this.uniforms[name]) {
            utils.setUniform(this.gl, this.uniforms[name], value);
        } else if (this.samplers[name]) {
            this.setUniformSampler(this.samplers[name], value);
        }
    },

    /**
     * Sets the texture units from the textures associated with the sampler
     * @param sampler
     * @returns {boolean}
     */
    setSamplerFromTextures: function (sampler) {
        var textures = sampler.textures;
        var cachedUnits = sampler.cachedUnits;
        var textureUnitsChanged = false;

        for (var i = 0, ii = textures.length; i < ii; i++) {
            var unit = textures[i].unit;

            // If texture is not bound to a texture unit (-1), bind it now
            if (unit == -1) {
                unit = textures[i]._bind();
            }
            if (unit != cachedUnits[i]) {
                cachedUnits[i] = unit;
                textureUnitsChanged = true;
            }
        }
        if (textureUnitsChanged) {
            XML3D.debug.logDebug("Setting new texture units:", sampler.name, cachedUnits);
            utils.setUniform(this.gl, sampler, cachedUnits);
        }
    },

    setSamplerFromArray: function(sampler, arr) {
        var cachedUnits = sampler.cachedUnits;
        var textureUnitsChanged = false;

       for (var i = 0, ii = arr.length; i < ii; i++) {
            var unit = arr[i];
            if (unit != cachedUnits[i]) {
                cachedUnits[i] = unit;
                textureUnitsChanged = true;
            }
        }
        if (textureUnitsChanged) {
            utils.setUniform(this.gl, sampler, cachedUnits);
            XML3D.debug.logDebug("Setting global texture units:", sampler.name, cachedUnits, this.id);
        }
    },

    /**
     *
     * @param {Object} sampler
     * @param {Array.<GLTexture>|Int32Array} value
     */
    setUniformSampler: function (sampler, value) {
        XML3D.debug.assert(value && sampler);
        // Textures are always an array value
        XML3D.debug.assert(Array.isArray(value), "Program::setUniformSampler: Unexpected value.");
        // We have at least one entry
        XML3D.debug.assert(value.length, "Program::setUniformSampler: No entry in value.");

        /**
         * Value can either be an array of GLTextures that know their current texture unit,
         * otherwise a typed array containing the texture units we have to bind.
         * @type {boolean}
         */
        var hasTextures = value[0].unit != undefined;

        if(hasTextures) {
            sampler.textures = value;
            this.setSamplerFromTextures(sampler);
        } else {
            this.setSamplerFromArray(sampler, value);
        }
    }
});

module.exports = ProgramObject;


},{"../constants.js":120,"../system/system-notifier.js":158,"./utils.js":118}],116:[function(require,module,exports){
/**
 * @interface
 */
var IRenderTarget = function () {
};
IRenderTarget.prototype.bind = function () {
};
IRenderTarget.prototype.unbind = function () {
};
IRenderTarget.prototype.getWidth = function () {
};
IRenderTarget.prototype.getHeight = function () {
};
IRenderTarget.prototype.getScale = function () {
};
IRenderTarget.prototype.resize = function (width, height) {
};

/**
 * Wrapper to handle screen context as render target
 * @constructor
 * @param {GLContext} context
 * @param {Number} width
 * @param {Number} height
 * @implements IRenderTarget
 */
var GLCanvasTarget = function (context, width, height) {
    this.context = context;
    this.width = width;
    this.height = height;
};

var empty = function () {
};

XML3D.extend(GLCanvasTarget.prototype, {
    getWidth: function () {
        return this.width;
    }, getHeight: function () {
        return this.height;
    }, getScale: function () {
        return 1;
    }, bind: function() {
        this.context.gl.viewport(0, 0, this.width, this.height);
    }, unbind: empty, resize: empty
});

/**
 * @param context
 * @param opt
 * @constructor
 * @implements IRenderTarget
 */
var GLRenderTarget = function (context, opt) {
    this.context = context;
    this.width = opt.width || 800;
    this.height = opt.height || 600;
    this.scale = opt.scale || 1;
    this.opt = this.fillOptions(opt);
    this.handle = null;
    this.colorTarget = {handle: null, isTexture: false};
    this.depthTarget = {handle: null, isTexture: false};
    this.stencilTarget = {handle: null, isTexture: false};
    this.valid = false;
};

XML3D.extend(GLRenderTarget.prototype, {
    getWidth: function () {
        return this.width;
    }, getHeight: function () {
        return this.height;
    }, getScale: function () {
        return this.scale;
    }, bind: function () {
        if (!this.handle) {
            this.createFrameBuffer(this.opt.colorFormat, this.opt.depthFormat, this.opt.stencilFormat);
        }
        if (this.valid) {
            var gl = this.context.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.handle);
            gl.viewport(0, 0, this.width, this.height);
        }
    }, unbind: function () {
        var gl = this.context.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }, resize: function (width, height) {
        this.dispose();
        this.width = width;
        this.height = height;
        this.bind();
    }, createFrameBuffer: function (colorFormat, depthFormat, stencilFormat) {
        var gl = this.context.gl;

        this.handle = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.handle);
        colorFormat && this.createColorTarget(colorFormat);
        depthFormat && this.createDepthTarget(depthFormat);
        stencilFormat && this.createStencilTarget(stencilFormat);
        this.checkStatus();
    }, createColorTarget: function (colorFormat) {
        var gl = this.context.gl;
        if (this.opt.colorAsRenderbuffer) {
            var ct = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, ct);
            gl.renderbufferStorage(gl.RENDERBUFFER, colorFormat, this.width, this.height);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);

            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, ct);

            this.colorTarget = {
                handle: ct, isTexture: false
            };
        } else {
            //opt.generateMipmap = opt.generateColorsMipmap;
            var ctex = this.context.createTexture();
            ctex.createTex2DFromData(colorFormat, this.width, this.height, gl.RGBA, this.opt.colorType || gl.UNSIGNED_BYTE, this.opt);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, ctex.handle, 0);
            this.colorTarget = {
                handle: ctex, isTexture: true
            };
        }
    }, createDepthTarget: function (depthFormat) {
        var gl = this.context.gl;
        this.opt.isDepth = true;
        if (this.opt.depthAsRenderbuffer) {
            var dt = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, dt);
            gl.renderbufferStorage(gl.RENDERBUFFER, depthFormat, this.width, this.height);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);

            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, dt);

            this.depthTarget = {
                handle: dt, isTexture: false
            }
        } else {
            //opt.generateMipmap = opt.generateDepthMipmap;
            var dtex = this.context.createTexture();
            dtex.createTex2DFromData(depthFormat, this.width, this.height, gl.DEPTH_COMPONENT, gl.FLOAT, this.opt);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, dtex.handle, 0);

            this.depthTarget = {
                handle: dtex, isTexture: true
            }
        }
    }, createStencilTarget: function (stencilFormat) {
        var gl = this.context.gl;
        if (this.opt.stencilAsRenderbuffer) {
            var st = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, st);
            gl.renderbufferStorage(gl.RENDERBUFFER, stencilFormat, this.width, this.height);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);

            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, st);

            this.stencilTarget = {
                handle: st, isTexture: false
            }
        } else {
            //opt.generateMipmap = opt.generateStencilMipmap;
            var stex = this.context.createTexture();
            stex.createTex2DFromData(stencilFormat, this.width, this.height, gl.STENCIL_COMPONENT, gl.UNSIGNED_BYTE, this.opt);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.TEXTURE_2D, stex.handle, 0);

            this.stencilTarget = {
                handle: stex, isTexture: true
            }
        }
    }, checkStatus: function () {
        var gl = this.context.gl;

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.handle);
        //Finalize framebuffer creation
        var fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

        switch (fbStatus) {
            case gl.FRAMEBUFFER_COMPLETE:
                break;
            case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                break;
            case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                break;
            case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                break;
            case gl.FRAMEBUFFER_UNSUPPORTED:
                XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
                break;
            default:
                XML3D.debug.logError("Incomplete framebuffer: " + fbStatus);
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        this.valid = (fbStatus == gl.FRAMEBUFFER_COMPLETE);
        return this.valid;
    }, fillOptions: function (options) {
        var gl = this.context.gl;
        var opt = {
            wrapS: gl.CLAMP_TO_EDGE,
            wrapT: gl.CLAMP_TO_EDGE,
            minFilter: gl.NEAREST,
            magFilter: gl.NEAREST,
            depthMode: gl.LUMINANCE,
            depthCompareMode: gl.COMPARE_R_TO_TEXTURE,
            depthCompareFunc: gl.LEQUAL,
            colorsAsRenderbuffer: false,
            depthAsRenderbuffer: false,
            stencilAsRenderbuffer: false,
            isDepth: false
        };

        for (var item in options) {
            opt[item] = options[item];
        }
        return opt;
    }, dispose: function () {
        if (!this.handle)
            return;

        var gl = this.context.gl;
        gl.deleteFramebuffer(this.handle);

        if (this.colorTarget !== null) {
            if (this.colorTarget.isTexture)
                this.colorTarget.handle.dispose(); else
                gl.deleteRenderBuffer(this.colorTarget.handle);
        }
        if (this.depthTarget !== null) {
            if (this.depthTarget.isTexture)
                this.depthTarget.handle.dispose(); else
                gl.deleteRenderBuffer(this.depthTarget.handle);
        }
        if (this.stencilTarget !== null) {
            if (this.stencilTarget.isTexture)
                this.stencilTarget.handle.dispose(); else
                gl.deleteRenderBuffer(this.stencilTarget.handle);
        }
    }
});

var GLScaledRenderTarget = function (context, maxDimension, opt) {
    GLRenderTarget.call(this, context, opt);
    this.scaleToMaxDimension(maxDimension);
};

XML3D.createClass(GLScaledRenderTarget, GLRenderTarget);
XML3D.extend(GLScaledRenderTarget.prototype, {
    scaleToMaxDimension: function (maxDimension) {
        var hDiff = this.height - maxDimension;
        var wDiff = this.width - maxDimension;

        if (hDiff > 0 || wDiff > 0) {
            var scale;
            if (hDiff > wDiff) {
                scale = maxDimension / this.height;
            } else {
                scale = maxDimension / this.width;
            }
            this.width = Math.floor(this.width * scale);
            this.height = Math.floor(this.height * scale);
            this.scale = scale;
        }
    }
});


    /**
     * @param context
     * @param opt
     * @constructor
     * @implements IRenderTarget
     */
    var GLCubeMapRenderTarget = function (context, opt) {
        var gl = context.gl;
        this.context = context;
        this.width = opt.width || 800;
        this.height = this.width;
        this.scale = opt.scale || 1;
        this.opt = this.fillOptions(opt);
        this.handle = null;
        this.ctex = null;
        this.dtex = null;
        this.stex = null;
        this.colorTarget = null;
        this.depthTarget =  null;
        this.stencilTarget = null;
        this.valid = false;
        this.glSides = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                        gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
                        gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];
        this.framebuffers = [];
    };

    XML3D.extend(GLCubeMapRenderTarget.prototype, {
        getWidth: function() {
            return this.width;
        },
        getHeight: function() {
            return this.height;
        },
        getScale: function() {
            return this.scale;
        },
        bind: function (side) {
            if (this.framebuffers.length <= 0) {
                this.createFrameBuffers(this.opt.colorFormat, this.opt.depthFormat, this.opt.stencilFormat);
            }
            if (this.valid) {
                var gl = this.context.gl;
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[side]);
                gl.viewport(0, 0, this.width, this.height);
            }
        },
        unbind: function () {
            var gl = this.context.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        },
        resize: function(width, height) {
            this.dispose();
            this.width = width;
            this.height = height;
            this.bind();
        },
        createFrameBuffers: function (colorFormat, depthFormat, stencilFormat) {
            var gl = this.context.gl;

            if(colorFormat) { //TODO check if renderbuffers instead of textures...
                this.ctex = this.context.createCubeMap();
                this.ctex.createTex2DFromData(colorFormat, this.width, this.height, gl.RGBA, this.opt.colorType || gl.UNSIGNED_BYTE, this.opt);
                this.colorTarget = { handle: this.ctex,  isTexture: true};
            }
            if(depthFormat) {
                this.opt.isDepth = true;

                if (this.opt.depthAsRenderbuffer) {
                } else {
                    this.dtex = this.context.createCubeMap();
                    this.dtex.createTex2DFromData(depthFormat, this.width, this.height, gl.DEPTH_COMPONENT, gl.FLOAT, this.opt);
                    this.depthTarget = { handle: this.dtex,  isTexture: true};
                }
            }
            if(stencilFormat) {
                this.stex = this.context.createCubeMap();
                this.stex.createTex2DFromData(stencilFormat, this.width, this.height, gl.STENCIL_COMPONENT, gl.UNSIGNED_BYTE, this.opt);
                this.stencilTarget = { handle: this.stex, isTexture: true};
            }

            for(var i = 0; i < this.glSides.length; ++i) {
                this.framebuffers[i] = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[i]);
                colorFormat && this.createColorTarget(colorFormat, i);
                depthFormat && this.createDepthTarget(depthFormat, i);
                stencilFormat && this.createStencilTarget(stencilFormat, i);
                this.checkStatus(i);
            }
        },
        createColorTarget: function (colorFormat, side) {
            var gl = this.context.gl;
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, this.glSides[side], this.ctex.handle, 0);
        },
        createDepthTarget: function (depthFormat, side) {
            var gl = this.context.gl;

            if (this.opt.depthAsRenderbuffer) {
                if (!this.dtex) this.dtex = [];
                this.dtex[side] = gl.createRenderbuffer();
                gl.bindRenderbuffer(gl.RENDERBUFFER, this.dtex[side]);
                gl.renderbufferStorage(gl.RENDERBUFFER, depthFormat, this.width, this.height);
                gl.bindRenderbuffer(gl.RENDERBUFFER, null);

                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.dtex[side]);
                if (!this.depthTarget) this.depthTarget = [];
                this.depthTarget[side] = {
                    handle: this.dtex[side],
                    isTexture: false
                }
            }
            else
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT0, this.glSides[side], this.dtex.handle, 0);
        },
        createStencilTarget: function (stencilFormat, side) {
            var gl = this.context.gl;

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, this.glSides[side], this.stex.handle, 0);
        },
        checkStatus: function (side) {
            var gl = this.context.gl;

            gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[side]);
            //Finalize framebuffer creation
            var fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

            switch (fbStatus) {
                case gl.FRAMEBUFFER_COMPLETE:
                    break;
                case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                    break;
                case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                    break;
                case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                    XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                    break;
                case gl.FRAMEBUFFER_UNSUPPORTED:
                    XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
                    break;
                default:
                    XML3D.debug.logError("Incomplete framebuffer: " + fbStatus);
            }

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            this.valid = (fbStatus == gl.FRAMEBUFFER_COMPLETE);
            return this.valid;
        },
        fillOptions: function (options) {
            var gl = this.context.gl;
            var opt = {
                wrapS: gl.CLAMP_TO_EDGE,
                wrapT: gl.CLAMP_TO_EDGE,
                minFilter: gl.NEAREST,
                magFilter: gl.NEAREST,
                depthMode: gl.LUMINANCE,
                depthCompareMode: gl.COMPARE_R_TO_TEXTURE,
                depthCompareFunc: gl.LEQUAL,
                colorsAsRenderbuffer: false,
                depthAsRenderbuffer: false,
                stencilAsRenderbuffer: false,
                isDepth: false
            };

            for (var item in options) {
                opt[item] = options[item];
            }

            return opt;
        },
        dispose: function () {
            if (this.framebuffers.length <= 0)
                return;

            var gl = this.context.gl;
            for(var side in this.framebuffers)
                gl.deleteFramebuffer(this.framebuffers[side]);

            if (this.colorTarget.handle !== null) {
                    this.colorTarget.handle.dispose();
            }
            if (this.depthTarget !== null) {
                this.depthTarget.handle.dispose();
            }
            if (this.stencilTarget !== null) {
                    this.stencilTarget.handle.dispose();
            }

            this.framebuffers = [];
        }
    });

module.exports = {
    GLCanvasTarget: GLCanvasTarget,
    GLRenderTarget: GLRenderTarget,
    GLScaledRenderTarget: GLScaledRenderTarget,
    GLCubeMapRenderTarget: GLCubeMapRenderTarget
};



},{}],117:[function(require,module,exports){
var utils = require("./utils.js");
var StateMachine = require("../../../contrib/state-machine.js");
var SamplerConfig = require("../../../xflow/interface/data.js").SamplerConfig;
var XC = require("../../../xflow/interface/constants.js");
var uniqueObjectId = utils.getUniqueCounter();

/**
 * @type {WebGLRenderingContext}
 */
var GL = require("../constants.js");

//noinspection JSValidateJSDoc
/**
 * @param {GLContext} context
 * @constructor
 */
var GLTexture = function (context) {
    SamplerConfig.call(this);

    /**
     * @type {GLContext}
     */
    this.context = context;

    /**
     * @type {number}
     */
    this.id = uniqueObjectId();

    /**
     * Unit the texture is currently bound to (or -1 if bound to no unit)
     * @type {number}
     */
    this.unit = -1;

    this.setDefaults();

    this.width = 0;
    this.height = 0;
    this.handle = null;

    this.textureType = context.gl.TEXTURE_2D;

    this.textureUnitCallback = this.lostTextureUnit.bind(this);
};

XML3D.createClass(GLTexture, SamplerConfig);

GLTexture.State = {
    NONE: "none", LOADING: "loading", READY: "ready", ERROR: "error"
};


var getOrCreateFallbackTexture = (function () {

    var c_fallbackTexture = null;

    return function (context) {
        if (!c_fallbackTexture) {
            c_fallbackTexture = new GLTexture(context);
            var size = 16;
            var texels = new Uint8Array(size * size * 3);
            for (var i = 0; i < texels.length; i++) {
                texels[i] = 128;
            }
            c_fallbackTexture.createTex2DFromData(GL.RGB, size, size, GL.RGB, GL.UNSIGNED_BYTE, {
                texels: texels, wrapS: GL.REPEAT, wrapT: GL.REPEAT, minFilter: GL.LINEAR, magFilter: GL.LINEAR
            });
        }
        return c_fallbackTexture;
    }
}());

var isPowerOfTwo = function (dimension) {
    return (dimension & (dimension - 1)) == 0;
};
var nextHighestPowerOfTwo = function (x) {
    --x;
    for (var i = 1; i < 32; i <<= 1) {
        x = x | x >> i;
    }
    return x + 1;
};

/**
 * Scale up the texture to the next highest power of two dimensions.
 * @returns {HTMLCanvasElement}
 */
var scaleImage = function (image, width, height) {
    /**
     * @type {HTMLCanvasElement}
     */
    var canvas = document.createElement("canvas");
    canvas.width = nextHighestPowerOfTwo(width);
    canvas.height = nextHighestPowerOfTwo(height);

    var context = canvas.getContext("2d");
    if (image instanceof HTMLElement) {
        context.drawImage(image, 0, 0, canvas.width, canvas.height);
    } else {
        var tmpCanvas = document.createElement("canvas");
        tmpCanvas.width = width;
        tmpCanvas.height = height;
        var tmpContext = tmpCanvas.getContext("2d");
        var imageData = tmpContext.createImageData(width, height);
        imageData.data.set(image.data);
        tmpContext.putImageData(imageData, 0, 0);

        context.drawImage(tmpCanvas, 0, 0, canvas.width, canvas.height);
    }

    return canvas;
};

var glTextureFormatFromXflow = function (format, gl) {
    switch (format) {
        case XC.TEXTURE_FORMAT.ALPHA:
            return gl.ALPHA;
        case XC.TEXTURE_FORMAT.RGB:
            return gl.RGB;
        case XC.TEXTURE_FORMAT.RGBA:
            return gl.RGBA;
        case XC.TEXTURE_FORMAT.LUMINANCE:
            return gl.LUMINANCE;
        case XC.TEXTURE_FORMAT.LUMINANCE_ALPHA:
            return gl.LUMINANCE_ALPHA;
        default:
            throw new Error("Unsupported Texture Format!");
    }
};

var glTextureTypeFromXflow = function (type, gl) {
    switch (type) {
        case XC.TEXTURE_TYPE.FLOAT:
            return gl.FLOAT;
        case XC.TEXTURE_TYPE.UBYTE:
            return gl.UNSIGNED_BYTE;
        case XC.TEXTURE_TYPE.USHORT_4_4_4_4:
            return gl.UNSIGNED_SHORT_4_4_4_4;
        case XC.TEXTURE_TYPE.USHORT_5_5_5_1:
            return gl.UNSIGNED_SHORT_5_5_5_1;
        case XC.TEXTURE_TYPE.USHORT_5_6_5:
            return gl.GL_UNSIGNED_SHORT_5_6_5;
        default:
            throw new Error("Unsupported Texture Type!");
    }
};

XML3D.extend(GLTexture.prototype, {
    /**
     * @param {Xflow.TextureEntry} textureEntry
     */
    updateFromTextureEntry: function (textureEntry) {
        if (!textureEntry.isLoading()) {
            this.set(textureEntry.getSamplerConfig());
            var img = textureEntry.asGLTextureValue();
            if (!img)
                return this.failed();
            this.createOrUpdateTexture(img);
        } else {
            this.loads();
        }
    }, /**
     * We need to scale texture when one of the wrap modes is not CLAMP_TO_EDGE and
     * one of the texture dimensions is not power of two.
     * Otherwise rendered texture will be just black.
     * @param {number} width
     * @param {number} height
     * @returns {boolean}
     */
    needsScale: function (width, height) {
        return (this.generateMipMap || this.wrapS != GL.CLAMP_TO_EDGE || this.wrapT != GL.CLAMP_TO_EDGE) && (!isPowerOfTwo(width) || !isPowerOfTwo(height))
    },


    _bind: function () {
        var gl = this.context.gl;
        var textureManager = this.context.textureManager;
        var unit = this.unit = textureManager.bind(this.id, { dispose: this.textureUnitCallback });
        if (unit == -2) {
            XML3D.debug.logError("All available texture units are full.");
        } else {
            gl.activeTexture(GL.TEXTURE0 + unit);
            gl.bindTexture(this.textureType, this.handle);
        }
        return unit;
    },

    unbind: function (unit) {
        // Do nothing, texture manager will handle this
    },

    destroy: function () {
        var gl = this.context.gl;
        var textureManager = this.context.textureManager;
        textureManager.dispose(this.id);
        gl.deleteTexture(this.handle);
    },

    canBind: function () {
        return this.current == GLTexture.State.READY;
    },

    createOrUpdateTexture: function (texelSource) {

        if (!this.handle) {
            this.handle = this.context.gl.createTexture();
        }

        this.updateTextureFromData(texelSource);
    },

    updateTextureFromData: function (texelSource) {
        var gl = this.context.gl;
        this._bind();

        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.flipY);
        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_S, this.wrapS);
        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_T, this.wrapT);
        gl.texParameteri(this.textureType, gl.TEXTURE_MIN_FILTER, this.minFilter);
        gl.texParameteri(this.textureType, gl.TEXTURE_MAG_FILTER, this.magFilter);

        var type = glTextureTypeFromXflow(texelSource.texelType, gl);
        var format = glTextureFormatFromXflow(texelSource.texelFormat, gl);

        var width = texelSource.width;
        this.width = width;
        var height = texelSource.height;
        this.height = height;

        if (this.generateMipMap && this.needsScale(width, height)) {
            if (type === gl.FLOAT)
                throw new Error("Should generate MipMaps but texture data is float and not power of two in size!");
            else
                texelSource = scaleImage(texelSource, width, height);
        }

        if (texelSource instanceof HTMLElement) {
            gl.texImage2D(gl.TEXTURE_2D, 0, format, format, type, texelSource);
        } else {
            if (texelSource.data instanceof Uint8ClampedArray) {
                // WebGL does not support Uint8ClampedArray, which is (correctly) used by async. Xflow. We just build a new view
                // on top of the underlying array buffer which should be relatively fast
                gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, new Uint8Array(texelSource.data.buffer));
            } else {
                gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, texelSource.data);
            }
        }

        if (this.generateMipMap)
            gl.generateMipmap(this.textureType);

        this.created();
    },

    createTex2DFromData: function (internalFormat, width, height, sourceFormat, sourceType, opt) {
        var gl = this.context.gl;

        var opt = opt || {};
        var texels = opt.texels;

        if (!texels) {
            if (sourceType == gl.FLOAT) {
                texels = new Float32Array(width * height * 4);
            } else {
                texels = new Uint8Array(width * height * 4);
            }
        }
        this.width = width;
        this.height = height;
        this.handle = gl.createTexture();
        this._bind();

        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, opt.flipY);
        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_S, opt.wrapS);
        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_T, opt.wrapT);
        gl.texParameteri(this.textureType, gl.TEXTURE_MIN_FILTER, opt.minFilter);
        gl.texParameteri(this.textureType, gl.TEXTURE_MAG_FILTER, opt.magFilter);

        if (!opt.isDepth) {
            if (texels instanceof Uint8ClampedArray) {
                gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, sourceFormat, sourceType, new Uint8Array(texels.buffer));
            } else {
                gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, sourceFormat, sourceType, texels);
            }
        } else {
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, sourceFormat, sourceType, null);
        }

        if (opt.generateMipmap) {
            gl.generateMipmap(this.textureType);
        }
        this.created();
    },

    lostTextureUnit: function() {
        this.unit = -1;
    }

});

StateMachine.create({
    target: GLTexture.prototype,
    initial: GLTexture.State.NONE,
    events: [{name: 'created', from: '*', to: GLTexture.State.READY}, {
        name: 'failed', from: '*', to: GLTexture.State.ERROR
    }, {name: 'loads', from: '*', to: GLTexture.State.LOADING}]
});

//noinspection JSValidateJSDoc
/**
 * @param {GLContext} context
 * @constructor
 */
var GLCubeMap = function (context) {
    GLTexture.call(this, context, context.gl.TEXTURE_CUBE_MAP);
    var gl = context.gl;
    this.textureType = context.gl.TEXTURE_CUBE_MAP;
    this.glSides = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];

};
XML3D.createClass(GLCubeMap, GLTexture, {
    updateTextureFromData: function (texelSource) {
        debug.log("updateTextureFromData not implemented for CubeMapping!");
    },

    createTex2DFromData: function (internalFormat, width, height, sourceFormat, sourceType, opt) {
        var gl = this.context.gl;

        var opt = opt || {};
        var texels = opt.texels;

        if (!texels) {
            if (sourceType == gl.FLOAT) {
                texels = new Float32Array(width * height * 4);
            } else {
                texels = new Uint8Array(width * height * 4);
            }
        }
        this.width = width;
        this.height = height;
        this.handle = gl.createTexture();
        this._bind();

        // gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_S, opt.wrapS);
        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_T, opt.wrapT);
        gl.texParameteri(this.textureType, gl.TEXTURE_MIN_FILTER, opt.minFilter);
        gl.texParameteri(this.textureType, gl.TEXTURE_MAG_FILTER, opt.magFilter);

        for(var i = 0; i < this.glSides.length; ++i) {
            if (!opt.isDepth) {
                if (texels instanceof Uint8ClampedArray) {
                    gl.texImage2D(this.glSides[i], 0, internalFormat, width, height, 0, sourceFormat, sourceType, new Uint8Array(texels.buffer));
                } else {
                    gl.texImage2D(this.glSides[i], 0, internalFormat, width, height, 0, sourceFormat, sourceType, texels);
                }
            } else {
                gl.texImage2D(this.glSides[i], 0, internalFormat, width, height, 0, sourceFormat, sourceType, null);
            }
        }

        if (opt.generateMipmap) {
            gl.generateMipmap(this.textureType);
        }
        this.created();
    }
});

GLCubeMap.State = {
    NONE: "none", LOADING: "loading", READY: "ready", ERROR: "error"
};

StateMachine.create({
    target: GLCubeMap.prototype,
    initial: GLCubeMap.State.NONE,
    events: [{name: 'created', from: '*', to: GLCubeMap.State.READY}, {
        name: 'failed', from: '*', to: GLCubeMap.State.ERROR
    }, {name: 'loads', from: '*', to: GLCubeMap.State.LOADING}]
});


module.exports = {
    GLTexture: GLTexture,
    GLCubeMap: GLCubeMap
};



},{"../../../contrib/state-machine.js":52,"../../../xflow/interface/constants.js":187,"../../../xflow/interface/data.js":188,"../constants.js":120,"./utils.js":118}],118:[function(require,module,exports){

module.exports = {
    /**
     * Set uniforms for active program
     * @param {WebGLRenderingContext} gl
     * @param u
     * @param value
     * @param {boolean=} transposed
     */
    setUniform: function (gl, u, value, transposed) {

        //noinspection FallthroughInSwitchStatementJS
        switch (u.glType) {
            case 35670: //gl.BOOL
                if (value && value.length !== undefined) {
                    // Transform a Unit8Array into a JS Array
                    gl.uniform1iv(u.location, Array.prototype.map.call(value, function(v) { return v; }));
                } else {
                    gl.uniform1i(u.location, value || 0);
                }
                break;
            case 5124:  //gl.INT
            case 35678: //gl.SAMPLER_2D
            case 35680: //gl.SAMPLER_CUBE
                if (value && value.length !== undefined) {
                    gl.uniform1iv(u.location, value);
                } else {
                    gl.uniform1i(u.location, value || 0);
                }
                break;

            case 35671: // gl.BOOL_VEC2
            case 35667:
                gl.uniform2iv(u.location, value);
                break; // gl.INT_VEC2

            case 35672: // gl.BOOL_VEC3
            case 35668:
                gl.uniform3iv(u.location, value);
                break; // gl.INT_VEC3

            case 35673: // gl.BOOL_VEC4
            case 35669:
                gl.uniform4iv(u.location, value);
                break; // gl.INT_VEC4

            case 5126:
                if (value.length != null)
                    gl.uniform1fv(u.location, value); else
                    gl.uniform1f(u.location, value);
                break; // gl.FLOAT
            case 35664:
                gl.uniform2fv(u.location, value);
                break; // gl.FLOAT_VEC2
            case 35665:
                gl.uniform3fv(u.location, value);
                break; // gl.FLOAT_VEC3
            case 35666:
                gl.uniform4fv(u.location, value);
                break; // gl.FLOAT_VEC4

            case 35674:
                gl.uniformMatrix2fv(u.location, transposed || false, value);
                break;// gl.FLOAT_MAT2
            case 35675:
                gl.uniformMatrix3fv(u.location, transposed || false, value);
                break;// gl.FLOAT_MAT3
            case 35676:
                gl.uniformMatrix4fv(u.location, transposed || false, value);
                break;// gl.FLOAT_MAT4

            default:
                XML3D.debug.logError("Unknown uniform type " + u.glType);
                break;
        }
    },

    getUniqueCounter: function () {
        var c_counter = 0;
        return function () {
            return c_counter++;
        }
    },

    checkError: function (gl, text) {
        var error = gl.getError();
        if (error !== gl.NO_ERROR) {
            var textErr = "" + error;
            switch (error) {
                case 1280:
                    textErr = "1280 ( GL_INVALID_ENUM )";
                    break;
                case 1281:
                    textErr = "1281 ( GL_INVALID_VALUE )";
                    break;
                case 1282:
                    textErr = "1282 ( GL_INVALID_OPERATION )";
                    break;
                case 1283:
                    textErr = "1283 ( GL_STACK_OVERFLOW )";
                    break;
                case 1284:
                    textErr = "1284 ( GL_STACK_UNDERFLOW )";
                    break;
                case 1285:
                    textErr = "1285 ( GL_OUT_OF_MEMORY )";
                    break;
            }
            var msg = "GL error " + textErr + " occured.";
            if (text !== undefined)
                msg += " " + text;
            XML3D.debug.trace(msg);
        }
    },

    supported: function () {
        var canvas = document.createElement("canvas");
        try {
            return !!(window.WebGLRenderingContext && (canvas.getContext('experimental-webgl')));
        } catch (e) {
            return false;
        }
    }

};


},{}],119:[function(require,module,exports){
var AbstractCanvasHandler = require("../renderer/canvas-handler.js");
var Options = require("../../utils/options.js");
var Util = require("../../utils/misc.js");

var MAXFPS = 30;

var OPTION_CONTINUOUS = "renderer-continuous";
Options.register(OPTION_CONTINUOUS, false);

/**
 * GLCanvasHandler class.
 * Registers and handles the events that happen on the canvas element.
 *
 * @param xml3dElem
 *            the root xml3d node, containing the XML3D scene structure
 * @constructor
 * @extends AbstractCanvasHandler
 */
function GLCanvasHandler(xml3dElem, canvas) {
    AbstractCanvasHandler.call(this, xml3dElem, canvas);
    this.renderInterface = {};

    this.lastPickObj = null;

    // Initialized later
    this.lastKnownDimensions = {width: 0, height: 0};

    this.initialize();
}

XML3D.createClass(GLCanvasHandler, AbstractCanvasHandler);

GLCanvasHandler.prototype.setRenderer = function (renderer) {
    this.renderer = renderer;
};

GLCanvasHandler.prototype.initialize = function () {
     this.configureCanvas();

    // This function is called at regular intervals by requestAnimationFrame to
    // determine if a redraw
    // is needed
    var that = this;
    this.tick = function () {

        if(!that.renderer)
            return;

        XML3D.updateXflowObserver();
        XML3D.flushDOMChanges();

        if (that.canvasSizeChanged() || that.renderer.needsRedraw() || Options.getValue(OPTION_CONTINUOUS)) {
            that.draw();
        }

        window.requestAnimationFrame(that.tick, MAXFPS);
    };

      // Block the right-click context menu on the canvas unless it's explicitly toggled
    var cm = this._xml3dElement.getAttribute("contextmenu");
    if (!cm || cm == "false") {
        this._canvas.addEventListener("contextmenu", function (e) {
            e.preventDefault && e.preventDefault();
            e.stopPropagation && e.stopPropagation();
        }, false);
    }
};

GLCanvasHandler.prototype.configureCanvas = function () {
    var xml3dElement = this._xml3dElement;
    var canvas = this._canvas;

    var parent = xml3dElement.parentNode;
    if (!Util.elementIs(parent, "div") || parent.getAttribute("class") !== "_xml3d_hideDiv") {
        // Place xml3dElement inside an invisble div
        var hideDiv = parent.ownerDocument.createElement('div');
        hideDiv.setAttribute("class", "_xml3d_hideDiv");
        //hideDiv.style.display = "none";
        parent.insertBefore(hideDiv, xml3dElement);
        hideDiv.appendChild(xml3dElement);

        // Create canvas and append it where the xml3d element was before
        parent.insertBefore(canvas, hideDiv);
    } else {
        // The invisible div already exists (probably from an earlier configuration)
        parent.parentNode.insertBefore(canvas, parent);
    }

    var style = canvas.ownerDocument.defaultView.getComputedStyle(xml3dElement);
    if (!canvas.style.backgroundColor) {
        var bgcolor = style.getPropertyValue("background-color");
        if (bgcolor && bgcolor != "transparent")
            canvas.style.backgroundColor = bgcolor;
    }
    // Need to be set for correct canvas size
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    this.lastKnownDimensions = {width: canvas.width, height: canvas.height};
    return canvas;
};

/**
 * Binds the picking buffer and passes the request for a picking pass to the
 * renderer
 *
 * @param {number} canvasX
 * @param {number} canvasY
 * @return {Drawable|null} newly picked object
 */
GLCanvasHandler.prototype.getPickObjectByPoint = function (canvasX, canvasY) {
    // TODO
    //if (!this.renderOptions.pickingEnabled)
    //    return null;
    return this.renderer.getRenderObjectFromPickingBuffer(canvasX, canvasY);
};

/**
 *
 * @returns {HTMLElement}
 */
GLCanvasHandler.prototype.getPickedObject = function() {
    return this.renderer.pickedObject ? this.renderer.pickedObject.node : null;
};

/**
 * @param {number} canvasX
 * @param {number} canvasY
 * @return {vec3|null} The world space normal on the object's surface at the given coordinates
 */
GLCanvasHandler.prototype.getWorldSpaceNormalByPoint = function (canvasX, canvasY) {
    return this.renderer.getWorldSpaceNormalByPoint(canvasX, canvasY);
};

/**
 * @param {number} canvasX
 * @param {number} canvasY
 * @return {vec3|null} The world space position on the object's surface at the given coordinates
 */
GLCanvasHandler.prototype.getWorldSpacePositionByPoint = function (canvasX, canvasY) {
    return this.renderer.getWorldSpacePositionByPoint(canvasX, canvasY);
};

GLCanvasHandler.prototype.canvasSizeChanged = function () {
    var canvas = this._canvas;
    if (canvas.clientWidth !== this.lastKnownDimensions.width || canvas.clientHeight !== this.lastKnownDimensions.height) {

        this.lastKnownDimensions.width = canvas.width = canvas.clientWidth;
        this.lastKnownDimensions.height = canvas.height = canvas.clientHeight;
        this.renderer.handleResizeEvent(canvas.width, canvas.height);
        this.dispatchResizeEvent({width: canvas.width, height: canvas.height});
        return true;
    }
    return false;
};

var c_timer = window.performance || Date;

/**
 * Called by tick() to redraw the scene if needed
 */
GLCanvasHandler.prototype.draw = function () {
    XML3D.flushDOMChanges();
    try {
        var start = c_timer.now();
        var stats = this.renderer.renderToCanvas();
        var end = c_timer.now();


        var factory = XML3D.xml3dFormatHandler.getFactory("scene", this.id);
        var xml3dAdapter = factory.getAdapter(this._xml3dElement);
        xml3dAdapter.onFrameDrawn();
        this.dispatchFrameDrawnEvent(start, end, stats);

    } catch (e) {
         // Avoid endless rendering due to error. Without a change, the renderer will not get back into normal operation
        this.renderer.needsDraw = false;
        XML3D.debug.logException(e);
    }

};

GLCanvasHandler.prototype.getMousePosition = function (evt) {
    var rct = this._canvas.getBoundingClientRect();
    return {
        x: (evt.clientX - rct.left), y: (evt.clientY - rct.top)
    };
};

GLCanvasHandler.prototype.destroy = function() {
    this.renderer.dispose();
    this.renderer = null;
};

module.exports =  GLCanvasHandler;


},{"../../utils/misc.js":182,"../../utils/options.js":183,"../renderer/canvas-handler.js":90}],120:[function(require,module,exports){
// 01.10.2015: Workaround for Safari bug on iOS 9 (https://bugs.webkit.org/show_bug.cgi?id=148449)
module.exports = WebGLRenderingContext.ONE ? WebGLRenderingContext : WebGLRenderingContext.prototype;

},{}],121:[function(require,module,exports){
var GLProgramObject = require("../base/program.js");
var XflowUtils= require("../xflow/utils.js");

/**
 * A ShaderClosure connects a mesh-specific GLProgram with it's Xflow data
 * @param {GLContext} context
 * @constructor
 */
var AbstractShaderClosure = function (context) {
    /**
     * @private
     * @type {GLProgramObject|null}
     */
    this.program = null;
    this.context = context;
    /**
     * A flag used by shadercomposer to sort out obsolete shaderclosures
     * @type {boolean}
     */
    this.obsolete = false;
    this.id = "";

    this.uniformCollection = {
        envBase: {}, envOverride: null, sysBase: null
    };

    /**
     * Stores, if the underlying shader has semi-transparencies
     * and thus needs to considered for alpha-blending
     * @type {boolean}
     */
    this.isTransparent = false;

    /**
     * The source of a shader
     * @private
     * @type {{vertex: string, fragment: string}}
     */
    this.source = {
        vertex: "", fragment: ""
    }
};

Object.defineProperties(AbstractShaderClosure.prototype, {
        attributes: {
            writeable: false, get: function () {
                return this.program ? this.program.attributes : {}
            }
        }, uniforms: {
            writeable: false, get: function () {
                return this.program ? this.program.uniforms : {}
            }
        }, samplers: {
            writeable: false, get: function () {
                return this.program ? this.program.samplers : {}
            }
        }
    });
XML3D.createClass(AbstractShaderClosure, null, {

    equals: function (that) {
        return this.source.vertex === that.source.vertex && this.source.fragment === that.source.fragment;
    },

    hasTransparency: function () {
        return this.isTransparent;
    },

    compile: function () {
        if (!this.source.fragment || !this.source.vertex) {
            XML3D.debug.logError("No source found for material", this);
            return;
        }

        var programObject = new GLProgramObject(this.context.gl, this.source);
        this.program = programObject;
        this.id = programObject.id;
    },

    bind: function () {
        this.program.bind();
    },

    unbind: function () {
        this.program.unbind();
    },

    isValid: function () {
        return this.program.isValid();
    },

    /**
     * @param {Xflow.ComputeResult} xflowResult
     */
    updateUniformsFromComputeResult: function (xflowResult) {
        var map = xflowResult.getOutputMap();

        var envBase = this.uniformCollection.envBase = {};
        this.setDefaultUniforms(this.uniformCollection.envBase);

        for (var name in map) {
            envBase[name] = XflowUtils.getGLUniformValueFromXflowDataEntry(map[name], this.context);
        }
        var names = Object.keys(envBase);
        this.setUniformVariables(names, null, this.uniformCollection);

        this.isTransparent = this.getTransparencyFromInputData(map);
    },

    setUniformVariables: function (envNames, sysNames, uniformCollection) {
        this.program.setUniformVariables(envNames, sysNames, uniformCollection);
    },

    setSystemUniformVariables: function (sysNames, sysValues) {
        this.uniformCollection.sysBase = sysValues;
        this.setUniformVariables(null, sysNames, this.uniformCollection);
    },

    changeUniformVariableOverride: function (prevOverride, newOverride) {
        var overrideNames = prevOverride ? Object.keys(prevOverride) : [];
        if (newOverride) overrideNames.push.apply(overrideNames, Object.keys(newOverride));
        this.uniformCollection.envOverride = newOverride;
        this.setUniformVariables(overrideNames, null, this.uniformCollection);
    }
});

module.exports = AbstractShaderClosure;


},{"../base/program.js":115,"../xflow/utils.js":159}],122:[function(require,module,exports){
var GLScene = require("../scene/glscene.js");
var GLLights = require("../scene/gllights.js");
var MaterialEvents = require("../materials/events.js");
var EventEmitter = require("events").EventEmitter;
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;
var XC = require("../../../xflow/interface/constants.js");

/**
 * @interface
 */
var IShaderComposer = function () {
};

/**
 * @enum
 */
IShaderComposer.UpdateState = {
    SHADER_UPDATED: 1, SHADER_COMPILED: 2, SHADER_UNCHANGED: 3
};

IShaderComposer.State = {
    OK: 1, NO_SCRIPT: 2, NO_PROGRAM: 3
};

/**
 * @param {scene} scene
 * @param {{}=} opt
 */
IShaderComposer.prototype.update = function (scene, opt) {
};

/**
 *
 * @returns AbstractShaderClosure|null
 */
IShaderComposer.prototype.getShaderClosure = function (scene) {
    return null;
};

/**
 * @returns {Array.<string>}
 */
IShaderComposer.prototype.getRequestFields = function () {
    return [];
};

/**
 * @returns {{}}
 */
IShaderComposer.prototype.getShaderAttributes = function () {
    return {};
};

/**
 * @constructor
 * @extends EventEmitter
 */
var AbstractShaderComposer = function (context, shaderInfo) {
    EventEmitter.call(this);
    this.context = context;
    this.shaderClosures = [];
    this.dataChanged = false;
    this.updateLightValues = false;
    this.request = null;
    this.setMaxListeners(0);
};

XML3D.createClass(AbstractShaderComposer, EventEmitter, {

    // Implemented by subclass
    setShaderInfo: null,


    updateRequest: function (xflowDataNode) {
        if (this.request) this.request.clear();

        this.request = new ComputeRequest(xflowDataNode, this.getRequestFields(), this.onShaderRequestChange.bind(this));
        this.setShaderRecompile();
    },

    onShaderInfoChanged: function (shaderInfo) {
        this.setShaderInfo(shaderInfo);
        this.setShaderRecompile();
        this.context.requestRedraw("Material model changed");
    },

    onShaderRequestChange: function (request, changeType) {
        this.dataChanged = true;
        if (changeType == XC.RESULT_STATE.CHANGED_STRUCTURE)
            this.setShaderRecompile();
        this.context.requestRedraw("Material data changed");
    },

    /**
     * @param {Scene} scene
     * @param {{}=} opt
     */
    update: function (scene, opt) {
        opt = opt || {};
        var that = this;

        // Clean up shaderClosures that are not used!
        var i = this.shaderClosures.length;
        while (i--) {
            if (this.shaderClosures[i].obsolete) this.shaderClosures.splice(i, 1);
        }

        if (!this.shaderClosures.length)
            return;

        if (this.dataChanged) {
            var result = this.getShaderDataResult();
            this.shaderClosures.forEach(function (shader) {
                that.updateClosureFromComputeResult(shader, result);
            });
            this.dataChanged = false;
        }

        if (this.updateLightValues) {
            this.shaderClosures.forEach(function (shader) {
                that.updateClosureFromLightParameters(shader, scene);
            });
        }
    },

    /**
     * @param {AbstractShaderClosure} shaderClosure
     * @param {Xflow.ComputeResult} result
     */
    updateClosureFromComputeResult: function (shaderClosure, result) {
        if (!result || !result.getOutputMap) {
            return;
        }
        shaderClosure.bind();
        shaderClosure.updateUniformsFromComputeResult(result);
    },

    updateClosureFromLightParameters: function (shaderClosure, scene) {
        shaderClosure.bind();
        shaderClosure.setSystemUniformVariables(GLLights.ALL_PARAMETERS, scene.systemUniforms);
    },

    updateSystemUniforms: function (names, scene) {
        this.shaderClosures.forEach(function (shader) {
            shader.bind();
            shader.setSystemUniformVariables(names, scene.systemUniforms);
        });
    },


    createShaderClosure: function () {
        throw new Error("AbstractComposer::createShaderClosure needs to be overridden");
    },

    createObjectDataRequest: function (objectDataNode, callback) {
        throw new Error("AbstractComposer::createObjectDataRequest needs to be overridden");
    },

    distributeObjectShaderData: function (objectRequest, attributeCallback, uniformCallback) {
        throw new Error("AbstractComposer::distributeObjectShaderData needs to be overridden");
    },

    getShaderClosure: function (scene, vsRequest) {
        var shader = this.createShaderClosure();

        try {
            shader.createSources(scene, this.getShaderDataResult(), vsRequest)
        } catch (e) {
            throw new Error("Shader: " + e.message)
        }

        for (var i = 0; i < this.shaderClosures.length; i++) {
            if (this.shaderClosures[i].equals(shader)) {
                this.shaderClosures[i].obsolete = false;
                return this.shaderClosures[i];
            }
        }

        this.initializeShaderClosure(shader, scene);
        return shader;
    },

    initializeShaderClosure: function (shaderClosure, scene) {
        shaderClosure.compile();

        scene.emit(MaterialEvents.MATERIAL_INITIALIZED);
        this.updateClosureFromComputeResult(shaderClosure, this.getShaderDataResult());
        this.updateClosureFromLightParameters(shaderClosure, scene);
        this.shaderClosures.push(shaderClosure);
    },

    setShaderRecompile: function () {

        for (var i = 0; i < this.shaderClosures.length; ++i) {
            this.shaderClosures[i].obsolete = true;
        }
        this.emit(MaterialEvents.MATERIAL_STRUCTURE_CHANGED);
        this.dataChanged = true;
        this.updateLightValues = true;
    },


    /**
     * @returns {Xflow.ComputeResult|null}
     */
    getShaderDataResult: function () {
        return this.request ? this.request.getResult() : null;
    }


});


/**
 * @implements IShaderComposer
 * @constructor
 */
var DefaultComposer = function (context) {
    this.context = context;
};
XML3D.createClass(DefaultComposer, AbstractShaderComposer, {
    update: function () {
    },

    getShaderClosure: function (scene, vsRequest) {
        return this.context.programFactory.getFallbackProgram();
    },

    getShaderAttributes: function () {
        return {color: null, normal: null /* for picking */};
    },

    getRequestFields: function () {
        return ["diffuseColor", "useVertexColor"];
    },

    createObjectDataRequest: function (objectDataNode, callback) {
        return new ComputeRequest(objectDataNode, ["position", "color", "normal", "diffuseColor", "useVertexColor"], callback);
    },

    distributeObjectShaderData: function (objectRequest, attributeCallback, uniformCallback) {
        var result = objectRequest.getResult();

        var dataMap = result.getOutputMap(), requestFields = this.getRequestFields();
        for (var name in dataMap) {
            if (requestFields.indexOf(name) != -1)
                uniformCallback(name, dataMap[name]); else
                attributeCallback(name, dataMap[name]);
        }
    }
});


module.exports = {
    AbstractShaderComposer: AbstractShaderComposer,
    DefaultComposer: DefaultComposer
}


},{"../../../xflow/interface/constants.js":187,"../../../xflow/interface/request.js":190,"../materials/events.js":123,"../scene/gllights.js":154,"../scene/glscene.js":155,"events":12}],123:[function(require,module,exports){
module.exports = {
    MATERIAL_STRUCTURE_CHANGED: "material_structure_changed",
    MATERIAL_INITIALIZED: "material_initialized"
};

},{}],124:[function(require,module,exports){
var AbstractShaderClosure = require("./../abstractshaderclosure.js");
var JSShaderComposer = require("./jsshadercomposer.js");
var SystemNotifier = require("../../system/system-notifier.js");
var getJSSystemConfiguration = require("./jssystemconfiguration.js");
var XC = require("../../../../xflow/interface/constants.js");
var Options = require("../../../../utils/options.js");


var c_jsShaderCache = {};


function convertEnvName(name) {
    return ("_env_" + name).replace(/_+/g, "_");
}

function addDefaultChanneling(vsConfig, inputName) {
    var outputName = convertEnvName(inputName);
    vsConfig.channelAttribute(inputName, outputName, null);
}


function channelVsAttribute(vsConfig, inputName, spaceInfo) {
    if (!spaceInfo || !spaceInfo[inputName]) {
        addDefaultChanneling(vsConfig, inputName);
        return;
    }

    var i = spaceInfo[inputName].length;
    while (i--) {
        var entry = spaceInfo[inputName][i];
        var outputName = convertEnvName(entry.name), code = null;
        switch (entry.space) {
            case Shade.SPACE_VECTOR_TYPES.OBJECT:
                break;
            case Shade.SPACE_VECTOR_TYPES.VIEW_POINT:
                vsConfig.addInputParameter(XC.DATA_TYPE.FLOAT4X4, "modelViewMatrix", true);
                code = outputName + " = ( modelViewMatrix * vec4(#I{" + inputName + "}, 1.0) ).xyz;";
                break;
            case Shade.SPACE_VECTOR_TYPES.VIEW_NORMAL:
                vsConfig.addInputParameter(XC.DATA_TYPE.FLOAT3X3, "modelViewMatrixN", true);
                code = outputName + " = normalize( modelViewMatrixN * #I{" + inputName + "} );";
                break;
            case Shade.SPACE_VECTOR_TYPES.WORLD_POINT:
                vsConfig.addInputParameter(XC.DATA_TYPE.FLOAT4X4, "modelMatrix", true);
                code = outputName + " = ( modelMatrix * vec4(#I{" + inputName + "}, 1.0) ).xyz;";
                break;
            case Shade.SPACE_VECTOR_TYPES.WORLD_NORMAL:
                vsConfig.addInputParameter(XC.DATA_TYPE.FLOAT3X3, "modelMatrixN", true);
                code = outputName + " = normalize( modelMatrixN * #I{" + inputName + "} );";
                break;
            default:
                throw new Error("Can't handle Space Type: " + entry.space);
        }
        vsConfig.channelAttribute(inputName, outputName, code);
    }
}


/**
 * @param {XC.DATA_TYPE} xflowType
 */
var convertXflow2ShadeType = function (xflowType, source) {
    var result = {}
    switch (xflowType) {
        case XC.DATA_TYPE.BOOL:
            result.type = Shade.TYPES.BOOLEAN;
            break;
        case XC.DATA_TYPE.INT:
            result.type = Shade.TYPES.INT;
            break;
        case XC.DATA_TYPE.FLOAT:
            result.type = Shade.TYPES.NUMBER;
            break;
        case XC.DATA_TYPE.FLOAT2:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.FLOAT2;
            break;
        case XC.DATA_TYPE.FLOAT3:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.FLOAT3;
            break;
        case XC.DATA_TYPE.FLOAT4:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.FLOAT4;
            break;
        case XC.DATA_TYPE.FLOAT3X3:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.MATRIX3;
            break;
        case XC.DATA_TYPE.FLOAT4X4:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.MATRIX4;
            break;
        case XC.DATA_TYPE.TEXTURE:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.TEXTURE;
            break;
        case XC.DATA_TYPE.UNKNOWN:
        default:
            throw new Error("Unknown Xflow DataType: " + xflowType);
    }
    result.source = source;
    return result;
}

/**
 * @param context
 * @param sourceTemplate
 * @param dataCallback
 * @constructor
 */
var JSShaderClosure = function (context, sourceTemplate, extractedParams) {
    AbstractShaderClosure.call(this, context);
    this.sourceTemplate = sourceTemplate;
    this.extractedParams = extractedParams;
    this.uniformSetter = function () {
    };
    this.uniformConverter = [];
};

XML3D.createClass(JSShaderClosure, AbstractShaderClosure, {
    /**
     *
     * @param {GLScene} scene
     * @param {Xflow.ComputeResult} shaderResult
     * @param objectData
     */
    createSources: function (scene, shaderResult, vsRequest) {

        var vsDataResult = vsRequest.getResult();

        var systemParameters = getSystemParameters(this.context, scene.systemUniforms);
        var environmentParameters = {};



        var shaderEntries = shaderResult && shaderResult.getOutputMap(), vsShaderOutput = vsDataResult && vsDataResult.outputNames;

        for (var i = 0; i < this.extractedParams.length; ++i) {
            var paramName = this.extractedParams[i];
            if (vsShaderOutput && vsShaderOutput.indexOf(paramName) != -1) {
                environmentParameters[paramName] = convertXflow2ShadeType(vsDataResult.getOutputType(paramName), vsDataResult.isOutputUniform(paramName) ? Shade.SOURCES.UNIFORM : Shade.SOURCES.VERTEX);
            } else if (shaderEntries && shaderEntries[paramName]) {
                environmentParameters[paramName] = convertXflow2ShadeType(shaderEntries[paramName].type, Shade.SOURCES.UNIFORM);
            }
        }

        var contextData = {
            "this": { "type": "object", "kind": "any", "info": systemParameters },
            "global.shade": [{"extra": {"type": "object", "kind": "any", "global": true, "info": environmentParameters }}]
        };

        XML3D.debug.logDebug("CONTEXT:", contextData);

        var options = {
            propagateConstants: true,
            validate: true,
            sanitize: true,
            transformSpaces: Options.getValue("shadejs-transformSpaces"),
            extractUniformExpressions: Options.getValue("shadejs-extractUniformExpressions")
        };
        var compileOptions = {
            useStatic: true, uniformExpressions: options.uniformExpressions
        };
        var implementation = scene.deferred ? "xml3d-glsl-deferred" : "xml3d-glsl-forward";

        var jsShaderKey = implementation + ";" + JSON.stringify(options) + ";" + JSON.stringify(environmentParameters) + ";" + this.sourceTemplate;

        var cacheEntry;
        if (!(cacheEntry = c_jsShaderCache[jsShaderKey])) {
            try {
                var workSet = new Shade.WorkingSet();
                workSet.parse(this.sourceTemplate, {loc: true});
                workSet.analyze(contextData, implementation, options);
                var spaceInfo = workSet.getProcessingData('spaceInfo');
                var glslShader = workSet.compileFragmentShader(compileOptions);

                cacheEntry = {
                    source: glslShader.source, uniformSetter: glslShader.uniformSetter, spaceInfo: spaceInfo
                };
                cacheEntry.hasTransparentShaderClosure = workSet.getProcessingData("isTransparent");

                this.uniformSetter = glslShader.uniformSetter;
                this.source = {
                    fragment: glslShader.source, vertex: this.createVertexShader(vsRequest, vsDataResult, spaceInfo)
                }

                if (scene.deferred) {
                    cacheEntry.signatures = workSet.getProcessingData("colorClosureSignatures");
                }
                if (Options.getValue("shadejs-cache"))
                    c_jsShaderCache[jsShaderKey] = cacheEntry;
            } catch (e) {
                SystemNotifier.sendEvent('shadejs', {
                    shadejsType: "error", event: e, code: this.sourceTemplate
                });

                var errorMessage = "Shade.js Compile Error:\n" + e.message + "\n------------\n" + "Shader Source:" + "\n------------\n" + XML3D.debug.formatSourceCode(this.sourceTemplate);
                throw new Error(errorMessage);
            }
        }
        this.source = {
            fragment: cacheEntry.source, vertex: this.createVertexShader(vsRequest, vsDataResult, cacheEntry.spaceInfo)
        };
        this.hasTransparentShaderClosure = cacheEntry.hasTransparentShaderClosure;

        this.uniformSetter = cacheEntry.uniformSetter;
        if (scene.deferred) {
            scene.colorClosureSignatures.push.apply(scene.colorClosureSignatures, cacheEntry.signatures);
        }

        // TODO: Handle errors.
        XML3D.debug.logDebug(this.source.vertex);
        XML3D.debug.logDebug(this.source.fragment);

        SystemNotifier.sendEvent('shadejs', {
            shadejsType: "success", vertexShader: this.source.vertex, fragmentShader: this.source.fragment
        });

        return true;
    },

    createVertexShader: function (vsRequest, vsDataResult, spaceInfo) {
        var vsConfig = vsRequest.getConfig();
        var names = vsDataResult.outputNames;
        for (var i = 0; i < names.length; ++i) {
            channelVsAttribute(vsConfig, names[i], spaceInfo);
        }
        vsConfig.addInputParameter(XC.DATA_TYPE.FLOAT4X4, "modelViewProjectionMatrix", true);
        vsConfig.addCodeFragment("gl_Position = modelViewProjectionMatrix * vec4(#I{position}, 1.0);");
        return vsRequest.getVertexShader().getGLSLCode();
    },

    setUniformVariables: function (envNames, sysNames, inputCollection) {
        this.uniformSetter(envNames, sysNames, inputCollection, this.program.setUniformVariable.bind(this.program));
    },

    getTransparencyFromInputData: function (dataMap) {
        // TODO: Compute Transparency
        return this.hasTransparentShaderClosure;
    },

    /* Default values are compiled into shade.js */
    setDefaultUniforms: function () {
    }

});

/**
 * @param {GLContext} context
 * @param {{}} globals
 * @returns {{}}
 */
function getSystemParameters(context, globals) {
    var result = getJSSystemConfiguration(context);

    // Update light parameters which vary in their size depending on number of lights defined
    ["point", "directional", "spot"].forEach(function(model) {
        var on = model + "LightOn";
        result["MAX_" + model.toUpperCase() + "LIGHTS"].staticValue = globals[on] && globals[on].length;
    });

    for (var global in globals) {
        var entry = result[global];
        if(entry && entry.staticSize) {
            var aLength = globals[global].length;
            if (aLength) {
                var tupleSize = getTupleSize(entry);
                entry.staticSize = aLength / tupleSize;
            } else {
                // Do not allow a array of size 0, remove entry instead
                // TODO(ksons): Remove once we can check array size in shade.js
                delete result[global];
            }
        }

    }
    return result;
}

/**
 * @param {{}} desc Object type descriptor
 * @returns {number}
 */
function getTupleSize(desc) {
    if(desc.type == "array") {
        var elements = desc.elements;
        if (elements.type == "object") {
            switch(elements.kind) {
                case "texture":
                case "float": return 1;
                case "float2": return 2;
                case "float3": return 3;
                case "float4": return 4;
                case "matrix4": return 16;
                default: throw ("Unknown array element kind:" + elements.kind);
            }
        }
    }
    return 1;
}

module.exports = JSShaderClosure;


},{"../../../../utils/options.js":183,"../../../../xflow/interface/constants.js":187,"../../system/system-notifier.js":158,"./../abstractshaderclosure.js":121,"./jsshadercomposer.js":125,"./jssystemconfiguration.js":126}],125:[function(require,module,exports){
var AbstractShaderComposer = require("./../abstractshadercomposer.js").AbstractShaderComposer;
var JSShaderClosure = require("./jsshaderclosure.js");
var VSConfig = require("../../../../xflow/processing/vs-connect.js").VSConfig;
var VertexShaderRequest = require("../../../../xflow/interface/request.js").VertexShaderRequest;
var XC = require("../../../../xflow/interface/constants.js");

/**
 *
 * @param {GLContext} context
 * @param {MaterialConfiguration} config
 * @extends AbstractShaderComposer
 * @constructor
 */
var JSShaderComposer = function (context, config) {
    AbstractShaderComposer.call(this, context, config);

    if (!window.Shade)
        throw new Error("shade.js library not found");

    this.context = context;

    /** @type string*/
    this.sourceTemplate = config.model.script;

    /**
     * @private
     * @type {Array.<string>}
     */
    this.extractedParams = [];

    /**
     * @private
     * @type {Xflow.ComputeRequest|null}
     */
    this.request = null;

    this.setShaderInfo(config);
};

JSShaderComposer.convertSysName = function (name) {
    return name;
};

XML3D.createClass(JSShaderComposer, AbstractShaderComposer, {
    setShaderInfo: function (config) {
        try {
            var ast = Shade.parse(this.sourceTemplate, {loc: true});
            this.extractedParams = Shade.extractParameters(ast, {implementation: "xml3d-glsl-forward"}).shaderParameters;
            // FIXME: Shader.js should always request position (in case
        } catch (e) {
            // We ignore errors here. They will reoccur when updating connected mesh closures
            this.extractedParams = [];
        }
        if (this.extractedParams.indexOf("position") == -1) this.extractedParams.push("position");

        // The composer is interested in changes of all possible shader parameters (extracted)
        // the instances (closures) will only set those, that occur in the instance
        if (this.extractedParams.length) {
            this.updateRequest(config.dataNode);
        }
    },

    getRequestFields: function () {
        return this.extractedParams;
    },

    getShaderAttributes: function () {
        return {color: null, normal: null, texcoord: null};
    },

    createShaderClosure: function () {
        return new JSShaderClosure(this.context, this.sourceTemplate, this.extractedParams);
    },

    createObjectDataRequest: function (objectDataNode, callback) {

        var vsConfig = new VSConfig();
        var names = this.extractedParams.slice();
        //if(names.indexOf("position") == -1) names.push("position");
        vsConfig.addAttribute(XC.DATA_TYPE.FLOAT3, "position", true);
        for (var i = 0; i < names.length; ++i) {
            var name = names[i];
            if (name == "position") continue;
            var xflowInfo = objectDataNode.getOutputChannelInfo(name);
            if (xflowInfo) {
                vsConfig.addAttribute(xflowInfo.type, name, true);
            }
        }
        return new VertexShaderRequest(objectDataNode, vsConfig, callback);
    },

    distributeObjectShaderData: function (objectRequest, attributeCallback, uniformCallback) {
        var vertexShader = objectRequest.getVertexShader();
        var inputNames = vertexShader.inputNames;
        var i, name, entry;

        for (i = 0; i < inputNames.length; ++i) {
            name = inputNames[i];
            entry = vertexShader.getInputData(name);
            if (vertexShader.isInputUniform(name))
                uniformCallback(name, entry); else
                attributeCallback(name, entry);
        }
        var outputNames = vertexShader.outputNames;
        for (i = 0; i < outputNames.length; ++i) {
            name = outputNames[i];
            if (vertexShader.isOutputFragmentUniform(name)) {
                uniformCallback(vertexShader.getOutputSourceName(name), vertexShader.getUniformOutputData(name));
            }
        }
    }

});


module.exports = JSShaderComposer;



},{"../../../../xflow/interface/constants.js":187,"../../../../xflow/interface/request.js":190,"../../../../xflow/processing/vs-connect.js":237,"./../abstractshadercomposer.js":122,"./jsshaderclosure.js":124}],126:[function(require,module,exports){
var GLContext = require("../../base/context.js");
var singleton = null;

var SYSTEM_CONTEXT_TEMPLATE =  {
        "coords": {"type": "object", "kind": "float3", "source": "uniform"},
        "cameraPosition": {"type": "object", "kind": "float3", "source": "uniform"},
        "viewMatrix": {"type": "object", "kind": "matrix4", "source": "uniform"},
        "viewInverseMatrix": {"type": "object", "kind": "matrix4", "source": "uniform"},
        "modelMatrix": {"type": "object", "kind": "matrix4", "source": "uniform"},
        "modelViewMatrix": {"type": "object", "kind": "matrix4", "source": "uniform"},
        "modelViewProjectionMatrix": {"type": "object", "kind": "matrix4", "source": "uniform"},
        "modelMatrixN": {"type": "object", "kind": "matrix3", "source": "uniform"},
        "modelViewMatrixN": {"type": "object", "kind": "matrix3", "source": "uniform"},

        "MAX_POINTLIGHTS": {"type": "int", "source": "constant", "staticValue": 5},
        "pointLightOn": {"type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"},
        "pointLightAttenuation": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightIntensity": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightPosition": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightCastShadow": {
            "type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightShadowBias": {
            "type": "array", "elements": {"type": "number"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightShadowMap": {
            "type": "array", "elements": {"type": "object", "kind": "texture"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightMatrix": {
            "type": "array",
            "elements": {"type": "object", "kind": "matrix4"},
            "staticSize": 5,
            "source": "uniform"
        },
        "pointLightProjection": {
            "type": "array",
            "elements": {"type": "object", "kind": "matrix4"},
            "staticSize": 5,
            "source": "uniform"
        },
        "pointLightNearFar": {
            "type": "array",
            "elements": {"type": "object", "kind": "float2"},
            "staticSize": 5,
            "source": "uniform"
        },

        "MAX_DIRECTIONALLIGHTS": {"type": "int", "source": "constant", "staticValue": 5},
        "directionalLightOn": {"type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"},
        "directionalLightIntensity": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "directionalLightDirection": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "directionalLightCastShadow": {
            "type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"
        },
        "directionalLightShadowBias": {
            "type": "array", "elements": {"type": "number"}, "staticSize": 5, "source": "uniform"
        },
        "directionalLightShadowMap": {
            "type": "array", "elements": {"type": "object", "kind": "texture"}, "staticSize": 5, "source": "uniform"
        },
        "directionalLightMatrix": {
            "type": "array",
            "elements": {"type": "object", "kind": "matrix4"},
            "staticSize": 5,
            "source": "uniform"
        },

        "MAX_SPOTLIGHTS": {"type": "int", "source": "constant", "staticValue": 5},
        "spotLightOn": {"type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"},
        "spotLightAttenuation": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightIntensity": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightPosition": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightDirection": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightCosCutoffAngle": {
            "type": "array", "elements": {"type": "number"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightCosSoftCutoffAngle": {
            "type": "array", "elements": {"type": "number"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightCastShadow": {
            "type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightShadowBias": {
            "type": "array", "elements": {"type": "number"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightShadowMap": {
            "type": "array", "elements": {"type": "object", "kind": "texture"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightMatrix": {
            "type": "array",
            "elements": {"type": "object", "kind": "matrix4"},
            "staticSize": 5,
            "source": "uniform"
        },
        "ssaoMap": {"type": "object", "kind": "texture", "source": "uniform"},
        "environment": {"type": "object", "kind": "texture", "source": "uniform"}
};

function createSystemConfiguration(context) {
    var result = SYSTEM_CONTEXT_TEMPLATE;
    var ext = context.getExtensionByName(GLContext.EXTENSIONS.STANDARD_DERIVATES);
    if (ext) {
        result.fwidth = {type: Shade.TYPES.FUNCTION};
        result.dx = {type: Shade.TYPES.FUNCTION};
        result.dy = {type: Shade.TYPES.FUNCTION};
    }
    return result;
}


module.exports = function (context) {
    if (!singleton) {
        singleton = createSystemConfiguration(context);
    }
    return singleton;
};




},{"../../base/context.js":112}],127:[function(require,module,exports){
var JSShaderComposer = require("./js/jsshadercomposer.js");
var URNShaderComposer = require("./urn/urnshadercomposer.js");
var DefaultComposer = require("./abstractshadercomposer.js").DefaultComposer;

/**
 * @param {GLContext} context
 * @constructor
 */
var ShaderComposerFactory = function (context) {
    this.context = context;
    /** @type {Object.<number, IShaderComposer>} */
    this.composers = {};
    this.defaultComposer = new DefaultComposer(context);
    this.lightValuesDirty = true;
};


XML3D.extend(ShaderComposerFactory.prototype, {
    /**
     *
     * @param {MaterialConfiguration} materialConfiguration
     * @returns {IShaderComposer}
     */
    createComposerFromMaterialConfiguration: function (materialConfiguration) {
        if (!materialConfiguration) {
            return this.defaultComposer;
        }
        var result = this.composers[materialConfiguration.id];
        if (!result) {
            try {
                var modelType = materialConfiguration.model.type;
                switch (modelType) {
                    case "urn":
                        result = new URNShaderComposer(this.context, materialConfiguration);
                        break;
                    case "text/javascript":
                    case "application/javascript":
                    case "text/shade-javascript":
                        result = new JSShaderComposer(this.context, materialConfiguration);
                        break;
                    default:
                        XML3D.debug.logError("Can not create shader of type:", modelType, materialConfiguration.model)
                }

            } catch (e) {
                XML3D.debug.logError("No shader could be created for '" + materialConfiguration.name + "':", e.message);
                result = this.defaultComposer;
            }
            if (result) {
                this.composers[materialConfiguration.id] = result;
                this.context.getStatistics().materials++;
            }
            return result || this.defaultComposer;
        }
        return result;
    },

    getTemplateById: function (id) {
        return this.composers[id];
    },

    update: function (scene) {
        for (var i in this.composers) {
            this.composers[i].update(scene, {updateLightValues: this.lightValuesDirty});
        }
        this.lightValuesDirty = false;
    },

    setLightStructureDirty: function () {
        this.setShaderRecompile();
    },

    setShaderRecompile: function () {
        for (var i in this.composers) {
            this.composers[i].setShaderRecompile();
        }
    },

    updateSystemUniforms: function (names, scene) {
        for (var i in this.composers) {
            this.composers[i].updateSystemUniforms(names, scene);
        }
    },

    setLightValueChanged: function () {
        for (var i in this.composers) {
            this.composers[i].updateLightValues = true;
        }
    }

});

module.exports = ShaderComposerFactory;



},{"./abstractshadercomposer.js":122,"./js/jsshadercomposer.js":125,"./urn/urnshadercomposer.js":136}],128:[function(require,module,exports){
var EVENT_TYPE = require("../../renderer/scene/constants.js").EVENT_TYPE;
var Targets = require("../base/rendertarget");

var LightPass = require("../render-passes/light-pass");
var PointLightPass = require("../render-passes/pointlight-pass");

/**
 * @param {GLContext} context
 * @param {GLScene} scene
 * @constructor
 */
var ShadowMapService = function (context, scene) {
    this.context = context;
    scene.on(EVENT_TYPE.LIGHT_STRUCTURE_CHANGED, this.onLightStructureChanged.bind(this));
    scene.on(EVENT_TYPE.LIGHT_VALUE_CHANGED, this.onLightValueChanged.bind(this));
    scene.on(EVENT_TYPE.SCENE_SHAPE_CHANGED, this.onSceneShapeChanged.bind(this));

    this.shadowMapInfos = [];
    this.dirty = true;
};

XML3D.extend(ShadowMapService.prototype, {
    onLightStructureChanged: function (light, removed) {
        var shadowMapInfos = this.shadowMapInfos;
        if (removed) {
            removeLight(shadowMapInfos, light);
        } else {
            if (lightNeedsShadowMap(light)) {
                addLight(shadowMapInfos, light);
                this.requestRendering("light added");
            }
        }
    },

    onLightValueChanged: function () {
        this.requestRendering("light value changed");
    },

    onSceneShapeChanged: function () {
        this.requestRendering("scene shape changed");
    },

    requestRendering: function(/*reason*/) {
        this.dirty = true;
    },

    updateForRendering: function() {
        if(this.dirty) {
            var shadowMaps = this.shadowMapInfos;
            for (var i = 0; i < shadowMaps.length; i++) {
                shadowMaps[i].pass.renderScene();
            }
            this.dirty = false;
        }
    },

    fillGlobalParameters: function(globals) {
        var shadowUnits = mergeShadowParameters(this.shadowMapInfos);
        XML3D.extend(globals, shadowUnits);
    }

});

function lightNeedsShadowMap(light) {
    return !!light.model.getParameter("castShadow")[0];
}

function addLight(shadowMapInfos, light) {
    var context = light.scene.context;
    var passInfo = createPassInfo(light, context);
    shadowMapInfos.push(passInfo);
}


function removeLight(shadowMapInfos, light) {
    for (var i = 0; i < shadowMapInfos.length; i++) {
        if (shadowMapInfos[i].light === light) {
            shadowMapInfos.splice(index, 1);
            // TODO: Free pass and other resources, free texture slot
            return;
        }
    }
}

function createPassInfo(light, context) {
    var size = Math.max(context.canvasTarget.width, context.canvasTarget.height) * 2;
    var params = {
        width: size,
        height: size,
        colorFormat: context.gl.RGBA,
        depthFormat: context.gl.DEPTH_COMPONENT16,
        stencilFormat: null,
        depthAsRenderbuffer: true
    };

    var pass = light.model.id == "point" ? createPointLightPass(light, context, params) : createLightPass(light, context, params);
    pass.init(context);

    // Bind target in order to create texture map
    pass.output.bind();

    // TODO: Better way to fix the texture unit?
    var unitEntry = context.textureManager.getEntry(pass.output.colorTarget.handle.id);
    unitEntry.fixed = true;

    pass.output.unbind();

    return {
        light: light, pass: pass, slot: unitEntry.slot
    };
}


function createLightPass(light, context, params) {
    var lightFramebuffer = new Targets.GLRenderTarget(context, params);
    return new LightPass({context: context}, lightFramebuffer, light);
}

function createPointLightPass(light, context, params) {
    var lightFramebuffer = new Targets.GLCubeMapRenderTarget(context, params);
    return new PointLightPass({context: context}, lightFramebuffer, light);
}

function mergeShadowParameters(shadowMapInfos) {
    var result = {};
    ["spot", "point", "directional"].forEach(function(model) {
        var sameModel = shadowMapInfos.filter(function(info) { return info.light.model.id == model; });
        result[model + "LightShadowMap"] = sameModel.map(function (info) {
            return info.slot;
        });
    });
    return result;
}

module.exports = ShadowMapService;

},{"../../renderer/scene/constants.js":98,"../base/rendertarget":116,"../render-passes/light-pass":142,"../render-passes/pointlight-pass":146}],129:[function(require,module,exports){
XML3D.materials.register("diffuse", {

    vertex : [
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec3 color;",
        "attribute vec2 texcoord;",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "uniform mat4 modelViewProjectionMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat3 modelViewMatrixN;",
        "uniform vec3 eyePosition;",

        "void main(void) {",
        "    vec3 pos = position;",
        "    vec3 norm = normal;",

        "    gl_Position = modelViewProjectionMatrix * vec4(pos, 1.0);",
        "    fragNormal = normalize(modelViewMatrixN * norm);",
        "    fragVertexPosition = (modelViewMatrix * vec4(pos, 1.0)).xyz;",
        "    fragEyeVector = normalize(fragVertexPosition);",
        "    fragTexCoord = texcoord;",
        "    fragVertexColor = color;",
        "}"
    ].join("\n"),

    fragment : [
        "uniform float ambientIntensity;",
        "uniform vec3 diffuseColor;",
        "uniform vec3 emissiveColor;",
        "uniform float opacity;",
        "uniform mat4 viewMatrix;",
        "uniform bool useVertexColor;",

        "#if HAS_EMISSIVETEXTURE",
        "uniform sampler2D emissiveTexture;",
        "#endif",
        "#if HAS_DIFFUSETEXTURE",
        "uniform sampler2D diffuseTexture;",
        "#endif",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "#if MAX_POINTLIGHTS > 0",
        "uniform vec3 pointLightAttenuation[MAX_POINTLIGHTS];",
        "uniform vec3 pointLightPosition[MAX_POINTLIGHTS];",
        "uniform vec3 pointLightIntensity[MAX_POINTLIGHTS];",
        "uniform bool pointLightOn[MAX_POINTLIGHTS];",
        "#endif",

        "#if MAX_DIRECTIONALLIGHTS > 0",
        "uniform vec3 directionalLightDirection[MAX_DIRECTIONALLIGHTS];",
        "uniform vec3 directionalLightIntensity[MAX_DIRECTIONALLIGHTS];",
        "uniform bool directionalLightOn[MAX_DIRECTIONALLIGHTS];",
        "#endif",

        "#if MAX_SPOTLIGHTS > 0",
        "uniform vec3 spotLightAttenuation[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightPosition[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightIntensity[MAX_SPOTLIGHTS];",
        "uniform bool spotLightOn[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightDirection[MAX_SPOTLIGHTS];",
        "uniform float spotLightCosCutoffAngle[MAX_SPOTLIGHTS];",
        "uniform float spotLightCosSoftCutoffAngle[MAX_SPOTLIGHTS];",
        "uniform float spotLightSoftness[MAX_SPOTLIGHTS];",
        "#endif",

        "void main(void) {",
        "  float alpha =  max(0.0, opacity);",
        "  vec3 objDiffuse = diffuseColor;",
        "  if(useVertexColor)",
        "    objDiffuse *= fragVertexColor;",
        "  #if HAS_DIFFUSETEXTURE",
        "    vec4 texDiffuse = texture2D(diffuseTexture, fragTexCoord);",
        "    alpha *= texDiffuse.a;",
        "    objDiffuse *= texDiffuse.rgb;",
        "  #endif",
        "  if (alpha < 0.05) discard;",

        "  #if HAS_EMISSIVETEXTURE",
        "    vec3 color = emissiveColor * texture2D(emissiveTexture, fragTexCoord).rgb + (ambientIntensity * objDiffuse);",
        "  #else",
        "    vec3 color = emissiveColor + (ambientIntensity * objDiffuse);",
        "  #endif",

        "  #if MAX_POINTLIGHTS > 0",
        "    for (int i=0; i<MAX_POINTLIGHTS; i++) {",
        "      if (!pointLightOn[i])",
        "         continue;",
        "      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
        "      vec3 L = lPosition.xyz - fragVertexPosition;",
        "      float dist = length(L);",
        "      L = normalize(L);",
        "      float atten = 1.0 / (pointLightAttenuation[i].x + pointLightAttenuation[i].y * dist + pointLightAttenuation[i].z * dist * dist);",
        "      vec3 Idiff = pointLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
        "      color = color + atten*Idiff;",
        "    }",
        "  #endif",

        "#if MAX_DIRECTIONALLIGHTS > 0",
        "  for (int i=0; i<MAX_DIRECTIONALLIGHTS; i++) {",
        "      if (!directionalLightOn[i])",
        "         continue;",
        "    vec4 lDirection = viewMatrix * vec4(directionalLightDirection[i], 0.0);",
        "    vec3 L =  normalize(-lDirection.xyz);",
        "    vec3 Idiff = directionalLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
        "    color = color + Idiff;",
        "  }",
        "#endif",

        "#if MAX_SPOTLIGHTS > 0",
        "  for (int i=0; i<MAX_SPOTLIGHTS; i++) {",
        "      if (!spotLightOn[i])",
        "         continue;",
        "    vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
        "    vec3 L = lPosition.xyz - fragVertexPosition;",
        "    float dist = length(L);",
        "    L = normalize(L);",
        "    float atten = 1.0 / (spotLightAttenuation[i].x + spotLightAttenuation[i].y * dist + spotLightAttenuation[i].z * dist * dist);",
        "    vec3 Idiff = spotLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
        "    vec4 lDirection = viewMatrix * vec4(-spotLightDirection[i], 0.0);",
        "    vec3 D = normalize(lDirection.xyz);",
        "    float angle = dot(L, D);",
        "    if(angle > spotLightCosCutoffAngle[i]) {",
        "       float softness = 1.0;",
        "       if (angle < spotLightCosSoftCutoffAngle[i])",
        "           softness = (angle - spotLightCosCutoffAngle[i]) /  (spotLightCosSoftCutoffAngle[i] -  spotLightCosCutoffAngle[i]);",
        "       color += atten * softness * Idiff;",
        "    }",
        "  }",
        "#endif",

        "  gl_FragColor = vec4(color, alpha);",
        "}"
    ].join("\n"),

    addDirectives: function(directives, lights, params) {
        ["point", "directional", "spot"].forEach(function (type) {
            var numLights = lights.getModelCount(type);
            directives.push("MAX_" + type.toUpperCase() + "LIGHTS " + numLights);
        });
        directives.push("HAS_DIFFUSETEXTURE " + ('diffuseTexture' in params ? "1" : "0"));
        directives.push("HAS_EMISSIVETEXTURE " + ('emissiveTexture' in params ? "1" : "0"));
    },
    hasTransparency: function(params) {
        return params.opacity && params.opacity.getValue()[0] < 1;
    },
    uniforms: {
        diffuseColor    : [1.0, 1.0, 1.0],
        emissiveColor   : [0.0, 0.0, 0.0],
        opacity         : 1.0,
        ambientIntensity: 0.0,
        useVertexColor : false
    },
    samplers: {
        diffuseTexture : null,
        emissiveTexture : null
    },
    attributes: {
        normal : {
            required: true
        },
        texcoord: null,
        color: null
    }
});

},{}],130:[function(require,module,exports){
XML3D.materials.register("matte", {

    vertex: [
        "attribute vec3 position;",
        "attribute vec3 color;",

        "varying vec3 fragVertexColor;",

        "uniform mat4 modelViewProjectionMatrix;",

        "void main(void) {",
        "   fragVertexColor = color;",
        "   gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment: [
        "uniform vec3 diffuseColor;",
        "uniform bool useVertexColor;",

        "varying vec3 fragVertexColor;",

        "void main(void) {",
        "    vec3 color = diffuseColor;",
        "    if (useVertexColor)",
        "       color *=  fragVertexColor;",
        "    gl_FragColor = vec4(color, 1.0);",
        "}"
    ].join("\n"),

    uniforms: {
        diffuseColor : [1.0, 1.0, 1.0],
        useVertexColor: false
    },
    attributes: {
        color: null,
        normal: null // For picking
    }
});

XML3D.materials.register("flat", XML3D.materials.getScript("matte"));

},{}],131:[function(require,module,exports){
XML3D.materials.register("phong", {

    vertex : [
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec3 color;",
        "attribute vec2 texcoord;",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "#if (HAS_POINTLIGHT_SHADOWMAPS || HAS_DIRECTIONALLIGHT_SHADOWMAPS || HAS_SPOTLIGHT_SHADOWMAPS)",
        "varying vec3 fragWorldPosition;", //needed by any of the light types
        "#endif",

        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewProjectionMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat3 modelViewMatrixN;",
        "uniform vec3 eyePosition;",

        "void main(void) {",
        "    vec3 pos = position;",
        "    vec3 norm = normal;",
        "    gl_Position = modelViewProjectionMatrix * vec4(pos, 1.0);",
        "    fragNormal = normalize(modelViewMatrixN * norm);",
        "    fragVertexPosition = (modelViewMatrix * vec4(pos, 1.0)).xyz;",
        "    fragEyeVector = normalize(fragVertexPosition);",
        "    fragTexCoord = texcoord;",
        "    fragVertexColor = color;",
        "#if (HAS_POINTLIGHT_SHADOWMAPS || HAS_DIRECTIONALLIGHT_SHADOWMAPS || HAS_SPOTLIGHT_SHADOWMAPS)",
        "    fragWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;",
        "#endif",
        "}"
    ].join("\n"),

    fragment : [
        "uniform float ambientIntensity;",
        "uniform vec3 diffuseColor;",
        "uniform vec3 emissiveColor;",
        "uniform float shininess;",
        "uniform vec3 specularColor;",
        "uniform float opacity;",
        "uniform mat4 viewMatrix;",
        "uniform bool useVertexColor;",
		"uniform vec3 coords;",

        "#if HAS_EMISSIVETEXTURE",
        "uniform sampler2D emissiveTexture;",
        "#endif",
        "#if HAS_DIFFUSETEXTURE",
        "uniform sampler2D diffuseTexture;",
        "#endif",
        "#if HAS_SPECULARTEXTURE",
        "uniform sampler2D specularTexture;",
        "#endif",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "#if (HAS_POINTLIGHT_SHADOWMAPS || HAS_DIRECTIONALLIGHT_SHADOWMAPS || HAS_SPOTLIGHT_SHADOWMAPS)",
        "varying vec3 fragWorldPosition;",  //if there is Shadow we need world position and unpacking function
        "float unpackDepth( const in vec4 rgba_depth ) {",
        "  const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
        "  float depth = dot( rgba_depth, bit_shift );",
        "  return depth;",
        "}",
        "#endif",

        "#if MAX_POINTLIGHTS > 0",
        "uniform vec3 pointLightAttenuation[MAX_POINTLIGHTS];",
        "uniform vec3 pointLightPosition[MAX_POINTLIGHTS];",
        "uniform vec3 pointLightIntensity[MAX_POINTLIGHTS];",
        "uniform bool pointLightOn[MAX_POINTLIGHTS];",
        "uniform bool pointLightCastShadow[MAX_POINTLIGHTS];",
            "#if HAS_POINTLIGHT_SHADOWMAPS",
            "uniform samplerCube pointLightShadowMap[MAX_POINTLIGHTS];",
            "uniform float pointLightShadowBias[MAX_POINTLIGHTS];",
            "uniform vec2 pointLightNearFar[MAX_POINTLIGHTS];",
            "float vecToDepth(vec3 vec, float n, float f){",
                "vec3 absVec = abs(vec);" +
                "float maxComp = max(absVec.x, max(absVec.y, absVec.z));",
                "float res = (f+n)/(f-n)-(2.0*f*n)/(f-n)/maxComp;",
                "return res*0.5+0.5;",
            "}",
            "#endif",
        "#endif",

        "#if MAX_SPOTLIGHTS > 0",
        "uniform vec3 spotLightAttenuation[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightPosition[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightIntensity[MAX_SPOTLIGHTS];",
        "uniform bool spotLightOn[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightDirection[MAX_SPOTLIGHTS];",
        "uniform float spotLightCosCutoffAngle[MAX_SPOTLIGHTS];",
        "uniform float spotLightCosSoftCutoffAngle[MAX_SPOTLIGHTS];",
        "uniform float spotLightSoftness[MAX_SPOTLIGHTS];",
        "uniform bool spotLightCastShadow[MAX_SPOTLIGHTS];",
            "#if HAS_SPOTLIGHT_SHADOWMAPS",
            "uniform mat4 spotLightMatrix[ MAX_SPOTLIGHTS ];",//used for shadowmapcoord calculation
            "uniform sampler2D spotLightShadowMap[MAX_SPOTLIGHTS];",
            "uniform float spotLightShadowBias[MAX_SPOTLIGHTS];",
            "#endif",
        "#endif",


        "#if MAX_DIRECTIONALLIGHTS > 0",
        "uniform vec3 directionalLightDirection[MAX_DIRECTIONALLIGHTS];",
        "uniform vec3 directionalLightIntensity[MAX_DIRECTIONALLIGHTS];",
        "uniform bool directionalLightOn[MAX_DIRECTIONALLIGHTS];",
        "uniform bool directionalLightCastShadow[MAX_DIRECTIONALLIGHTS];",
            "#if HAS_DIRECTIONALLIGHT_SHADOWMAPS",
            "uniform mat4 directionalLightMatrix[MAX_DIRECTIONALLIGHTS];",
            "uniform sampler2D directionalLightShadowMap[MAX_DIRECTIONALLIGHTS];",
            "uniform float directionalLightShadowBias[MAX_DIRECTIONALLIGHTS];",
            "#endif",
        "#endif",


		"uniform sampler2D ssaoMap;",

        "void main(void) {",
        //calculate shadowmap coords (vector for pointlight)
        "#if MAX_POINTLIGHTS > 0 && HAS_POINTLIGHT_SHADOWMAPS",
        "    vec3 pointLightShadowMapDirection[MAX_POINTLIGHTS];",
        "    for(int i = 0; i < MAX_POINTLIGHTS; i++) {",
        "       pointLightShadowMapDirection[i] = fragWorldPosition - pointLightPosition[i];",
        "    }",
        "#endif",
        "#if MAX_SPOTLIGHTS > 0 && HAS_SPOTLIGHT_SHADOWMAPS",
        "    vec4 spotLightShadowMapCoord[MAX_SPOTLIGHTS];",
        "    for(int i = 0; i < MAX_SPOTLIGHTS; i++) {",
        "      spotLightShadowMapCoord[i] = spotLightMatrix[i] * vec4(fragWorldPosition, 1.0);",
        "    }",
        "#endif",
        "#if MAX_DIRECTIONALLIGHTS > 0 && HAS_DIRECTIONALLIGHT_SHADOWMAPS",
        "    vec4 directionalLightShadowMapCoord[MAX_DIRECTIONALLIGHTS];",
        "    for(int i = 0; i < MAX_DIRECTIONALLIGHTS; i++) {",
        "      directionalLightShadowMapCoord[i] = directionalLightMatrix[i] * vec4(fragWorldPosition, 1.0);",
        "    }",
        "#endif",

        "  float alpha =  max(0.0, opacity);",
        "  vec3 objDiffuse = diffuseColor;",
        "  if(useVertexColor)",
        "    objDiffuse *= fragVertexColor;",
        "  #if HAS_DIFFUSETEXTURE",
        "    vec4 texDiffuse = texture2D(diffuseTexture, fragTexCoord);",
        "    alpha *= texDiffuse.a;",
        "    objDiffuse *= texDiffuse.rgb;",
        "  #endif",
        "  if (alpha < 0.05) discard;",
        "  #if HAS_EMISSIVETEXTURE",
        "    vec3 color = emissiveColor * texture2D(emissiveTexture, fragTexCoord).rgb + (ambientIntensity * objDiffuse);",
        "  #else",
        "    vec3 color = emissiveColor + (ambientIntensity * objDiffuse);",
        "  #endif",
        "  vec3 objSpecular = specularColor;",
        "  #if HAS_SPECULARTEXTURE",
        "    objSpecular = objSpecular * texture2D(specularTexture, fragTexCoord).rgb;",
        "  #endif",
		"  #if HAS_SSAOMAP",
		"	 float ssao = 1.0 - texture2D(ssaoMap, gl_FragCoord.xy / coords.xy).r;",
        "  #endif",

        "  float shadowInfluence = 0.0;", //used for sampling shadow

		"#if MAX_POINTLIGHTS > 0",
        "  for (int i = 0; i < MAX_POINTLIGHTS; i++) {",
        "    shadowInfluence = 1.0;",
        "    if(pointLightOn[i]){",
        "   #if HAS_POINTLIGHT_SHADOWMAPS",
        "       if(pointLightCastShadow[i]){",
        "           shadowInfluence = 0.0;",
        "           float lsDepth = vecToDepth(pointLightShadowMapDirection[i], pointLightNearFar[i].x, pointLightNearFar[i].y );",
        "		    float depth = unpackDepth( textureCube(pointLightShadowMap[i], pointLightShadowMapDirection[i])) +  pointLightShadowBias[i];",
        "           if(lsDepth < depth)",
        "               shadowInfluence = 1.0;",
        "       }",
        "       if(shadowInfluence > 0.0){",
        "   #endif",
        "       vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
        "       vec3 L = lPosition.xyz - fragVertexPosition;",
        "       float dist = length(L);",
        "       L = normalize(L);",
        "       vec3 R = normalize(reflect(L,fragNormal));",
        "       float atten = 1.0 / (pointLightAttenuation[i].x + pointLightAttenuation[i].y * dist + pointLightAttenuation[i].z * dist * dist);",
        "       vec3 Idiff = pointLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
		"   #if HAS_SSAOMAP",
		"       Idiff *= ssao;",
		"   #endif",
        "       vec3 Ispec = pointLightIntensity[i] * objSpecular * pow(max(dot(R,fragEyeVector),0.0), shininess*128.0);",
        "       color = color + (atten*shadowInfluence*(Idiff + Ispec));",
        "   #if HAS_POINTLIGHT_SHADOWMAPS",
        "       }",  //pointlight visible
        "   #endif",
        "     }", //pointLight on
        "  }", //pointLight loop
        "#endif",

        "#if MAX_SPOTLIGHTS > 0",
        "  for (int i=0; i<MAX_SPOTLIGHTS; i++) {",
        "    shadowInfluence = 1.0;",
        "    if(spotLightOn[i]) {",
        "  #if HAS_SPOTLIGHT_SHADOWMAPS",
        "       if(spotLightCastShadow[i]){",
        "           shadowInfluence = 0.0;",
        "           vec4 lspos = spotLightShadowMapCoord[i];",
        "			vec3 perspectiveDivPos = lspos.xyz / lspos.w * 0.5 + 0.5;",
        "			float lsDepth = perspectiveDivPos.z;",
        "			vec2 lightuv = perspectiveDivPos.xy;",
        "			float depth = unpackDepth(texture2D(spotLightShadowMap[i], lightuv)) + spotLightShadowBias[i];",
        "           if(lsDepth < depth)",
        "               shadowInfluence = 1.0;",
        "       }",
        "       if(shadowInfluence > 0.0){",
        "  #endif",
        "       vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
        "       vec3 L = lPosition.xyz - fragVertexPosition;",
        "       float dist = length(L);",
        "       L = normalize(L);",
        "       vec3 R = normalize(reflect(L,fragNormal));",
        "       float atten = 1.0 / (spotLightAttenuation[i].x + spotLightAttenuation[i].y * dist + spotLightAttenuation[i].z * dist * dist);",
        "       vec3 Idiff = spotLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
        "   #if HAS_SSAOMAP",
        "	    Idiff *= ssao;",
        "   #endif",
        "       vec3 Ispec = spotLightIntensity[i] * objSpecular * pow(max(dot(R,fragEyeVector),0.0), shininess*128.0);",
        "       vec4 lDirection = viewMatrix * vec4(-spotLightDirection[i], 0.0);",
        "       vec3 D = normalize(lDirection.xyz);",
        "       float angle = dot(L, D);",
        "       if(angle > spotLightCosCutoffAngle[i]) {",
        "           float softness = 1.0;",
        "           if (angle < spotLightCosSoftCutoffAngle[i])",
        "               softness = (angle - spotLightCosCutoffAngle[i]) /  (spotLightCosSoftCutoffAngle[i] -  spotLightCosCutoffAngle[i]);",
        "           color += atten*softness*shadowInfluence*(Idiff + Ispec);",
        "       }",
        "   #if HAS_SPOTLIGHT_SHADOWMAPS",
        "       }", //light visible if shadow enabled
        "   #endif",
        "   } ", // spotlight on
        "  }", // light loop
        "#endif",

        "#if MAX_DIRECTIONALLIGHTS > 0",
        "  for (int i=0; i<MAX_DIRECTIONALLIGHTS; i++) {",
        "   shadowInfluence = 1.0;",
        "   if(directionalLightOn[i]){",
        "   #if HAS_DIRECTIONALLIGHT_SHADOWMAPS",
        "       if(directionalLightCastShadow[i]){",
        "           shadowInfluence = 0.0;",
        "           vec4 lspos = directionalLightShadowMapCoord[i];",
        "           vec3 orthogonalDivPos = lspos.xyz / lspos.w *0.5 + 0.5;",
        "           float lsDepth = orthogonalDivPos.z;",
        "           vec2 lightuv = orthogonalDivPos.xy;",
        "               float depth = unpackDepth(texture2D(directionalLightShadowMap[i], lightuv))+directionalLightShadowBias[i];",
        "               if(lsDepth < depth) shadowInfluence = 1.0;",
        "       }",
        "       if(shadowInfluence > 0.0){",
        "   #endif",
        "       vec4 lDirection = viewMatrix * vec4(directionalLightDirection[i], 0.0);",
        "       vec3 L =  normalize(-lDirection.xyz);",
        "       vec3 R = normalize(reflect(L,fragNormal));",
        "       vec3 Idiff = directionalLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
		"   #if HAS_SSAOMAP",
		"       Idiff *= ssao;",
		"   #endif",
        "       vec3 Ispec = directionalLightIntensity[i] * objSpecular * pow(max(dot(R,fragEyeVector),0.0), shininess*128.0);",
        "       color = color + shadowInfluence*((Idiff + Ispec));",
        "   #if HAS_DIRECTIONALLIGHT_SHADOWMAPS",
        "       }", //light visible
        "   #endif",
        "   }", //dirLight on
        "  }", // dirLight loop
        "#endif",
        "  gl_FragColor = vec4(color, alpha);",
        "}"
    ].join("\n"),

    addDirectives: function (directives, lights, params) {
        ["point", "directional", "spot"].forEach(function (type) {
            var numLights = lights.getModelCount(type);
            var castShadows = false;
            if(numLights) {
                castShadows = Array.prototype.some.call(lights.getModelEntry(type).parameters["castShadow"], function (value) {
                    return value;
                });
            }
            directives.push("MAX_" + type.toUpperCase() + "LIGHTS " + numLights);
            directives.push("HAS_" + type.toUpperCase() + "LIGHT_SHADOWMAPS " + (castShadows ? 1 : 0));
        });

        directives.push("HAS_DIFFUSETEXTURE " + ('diffuseTexture' in params ? "1" : "0"));
        directives.push("HAS_SPECULARTEXTURE " + ('specularTexture' in params ? "1" : "0"));
        directives.push("HAS_EMISSIVETEXTURE " + ('emissiveTexture' in params ? "1" : "0"));
        directives.push("HAS_SSAOMAP " + (XML3D.options.getValue("renderer-ssao") ? "1" : "0"));
    },
    hasTransparency: function(params) {
        return params.opacity && params.opacity.getValue()[0] < 1;
    },
    uniforms: {
        diffuseColor    : [1.0, 1.0, 1.0],
        emissiveColor   : [0.0, 0.0, 0.0],
        specularColor   : [0.0, 0.0, 0.0],
        opacity         : 1.0,
        shininess       : 0.2,
        ambientIntensity: 0.0,
        useVertexColor : false
    },

    samplers: {
        diffuseTexture : null,
        emissiveTexture : null,
        specularTexture : null,
        directionalLightShadowMap : null,
        spotLightShadowMap : null,
        pointLightShadowMap : null,
		ssaoMap: null
    },

    attributes: {
        normal : {
            required: true
        },
        texcoord: null,
        color: null
    }
});

},{}],132:[function(require,module,exports){
XML3D.materials.register("point", {

    vertex : [
        "attribute vec3 position;",
        "attribute vec3 color;",
        "attribute vec2 texcoord;",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "uniform mat4 modelViewProjectionMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat3 modelViewMatrixN;",
        "uniform vec3 eyePosition;",
        "uniform vec3 coords;",
        "uniform float pointSize;",

        "void main(void) {",
        "    vec3 pos = position;",

        "    gl_Position = modelViewProjectionMatrix * vec4(pos, 1.0);",
        "    fragVertexPosition = (modelViewMatrix * vec4(pos, 1.0)).xyz;",
        "    fragEyeVector = normalize(fragVertexPosition);",
        "    fragTexCoord = texcoord;",
        "    fragVertexColor = color;",
        "    vec4 pos2 = vec4(fragVertexPosition, 1.0); pos2.x += pointSize;",
        "    gl_PointSize = distance( gl_Position.xy, (projectionMatrix * pos2).xy ) * coords.x / gl_Position.w;",
        "}"
    ].join("\n"),

    fragment : [
        "uniform vec3 diffuseColor;",
        "uniform float opacity;",
        "uniform mat4 viewMatrix;",
        "uniform bool useVertexColor;",
        "uniform vec2 texCoordOffset;",
        "uniform vec2 texCoordSize;",

        "#if HAS_DIFFUSETEXTURE",
        "uniform sampler2D diffuseTexture;",
        "#endif",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "void main(void) {",
        "  float alpha =  max(0.0, opacity);",
        "  vec3 objDiffuse = diffuseColor;",
        "  if(useVertexColor)",
        "    objDiffuse *= fragVertexColor;",
        "  #if HAS_DIFFUSETEXTURE",
        "    vec2 texCoord = fragTexCoord + texCoordOffset + gl_PointCoord*texCoordSize;",
        "    texCoord.y = 1.0 - texCoord.y;",
        "    vec4 texDiffuse = texture2D(diffuseTexture, texCoord);",
        "    alpha *= texDiffuse.a;",
        "    objDiffuse *= texDiffuse.rgb;",
        "  #endif",
        "  if (alpha < 0.05) discard;",
        "  gl_FragColor = vec4(objDiffuse, alpha);",
        "}"
    ].join("\n"),
    addDirectives: function(directives, lights, params) {
        directives.push("HAS_DIFFUSETEXTURE " + ('diffuseTexture' in params ? "1" : "0"));
    },
    hasTransparency: function(params) {
        return params.opacity && params.opacity.getValue()[0] < 1;
    },
    uniforms: {
        diffuseColor    : [1.0, 1.0, 1.0],
        texCoordOffset  : [0, 0],
        texCoordSize    : [1, 1],
        opacity         : 1.0,
        useVertexColor  : false,
        pointSize       : 1.0
    },
    samplers: {
        diffuseTexture: null
    },
    attributes: {
        texcoord: null,
        color: null
    }
});

},{}],133:[function(require,module,exports){
var c_globalScripts = {};

module.exports = {

    register: function (name, script) {
        c_globalScripts[name] = script;
        script.name = name;
    },

    getScript: function (script) {
        return c_globalScripts[script];
    }
};

},{}],134:[function(require,module,exports){
var ShaderDescriptor = function () {
    this.uniforms = {};
    this.samplers = {};
    this.attributes = {};
    this.name = "";
    this.fragment = "";
    this.vertex = "";
};
ShaderDescriptor.prototype.addDirectives = function () {
};
ShaderDescriptor.prototype.hasTransparency = function () {
    return false;
};

module.exports = ShaderDescriptor;

},{}],135:[function(require,module,exports){
var AbstractShaderClosure = require("./../abstractshaderclosure.js");
var SystemNotifier = require("../../system/system-notifier.js");

/**
 * A ShaderClosure connects a mesh-specific GLProgram with it's Xflow data
 * @param {GLContext} context
 * @param descriptor
 * @constructor
 */
var ShaderClosure = function (context, descriptor) {
    AbstractShaderClosure.call(this, context);
    this.descriptor = descriptor;
};

XML3D.createClass(ShaderClosure, AbstractShaderClosure);

XML3D.extend(ShaderClosure.prototype, {

    setDefaultUniforms: function (dest) {
        XML3D.extend(dest, this.descriptor.uniforms);
    },

    createSources: function (scene, shaderData, vsRequest) {

        var objectData = vsRequest && vsRequest.getResult();
        var directives = [];

        var inputData = {};
        shaderData && XML3D.extend(inputData, shaderData.getOutputMap());
        objectData && XML3D.extend(inputData, objectData.getOutputMap());


        for (var attrName in this.descriptor.attributes) {
            var entry = this.descriptor.attributes[attrName];
            if (entry && entry.required && !inputData[attrName]) {
                throw new Error("Mesh is missing '" + attrName + "' attribute.");
            }
        }

        this.descriptor.addDirectives(directives, scene.lights || {}, inputData);
        this.source = {
            fragment: this.addDirectivesToSource(directives, this.descriptor.fragment),
            vertex: this.addDirectivesToSource(directives, this.descriptor.vertex)
        };

        SystemNotifier.sendEvent('urnshader', {
            urnshaderType: "code", vertexShader: this.source.vertex, fragmentShader: this.source.fragment
        });

        return true;
    },

    addDirectivesToSource: function (directives, source) {
        var header = "";
        directives.forEach(function (v) {
            header += "#define " + v + "\n";
        });
        return header + "\n" + source;
    },

    getTransparencyFromInputData: function (dataMap) {
        return this.descriptor.hasTransparency(dataMap);
    }
});

module.exports = ShaderClosure;


},{"../../system/system-notifier.js":158,"./../abstractshaderclosure.js":121}],136:[function(require,module,exports){
var AbstractShaderComposer = require("../abstractshadercomposer.js").AbstractShaderComposer;
var URNShaderClosure= require("./urnshaderclosure.js");
var ShaderDescriptor = require("./shader-descriptor.js");
var ComputeRequest = require("../../../../xflow/interface/request.js").ComputeRequest;
var addFragmentShaderHeader = require("../../shader/shader-utils.js").addFragmentShaderHeader;
require("./diffuse.js");
require("./phong.js");
require("./matte.js");
require("./point.js");
require("./utility.js");

/**
 * @param {string} path
 * @returns {*}
 */
var getShaderDescriptor = function (path) {
    var shaderName = path.substring(path.lastIndexOf(':') + 1);
    return XML3D.materials.getScript(shaderName);
};


/**
 * @implements {IShaderComposer}
 * @extends AbstractShaderComposer
 * @constructor
 */
var URNShaderComposer = function (context, materialConfiguration) {
    AbstractShaderComposer.call(this, context, materialConfiguration);
    this.descriptor = null;
    this.setMaterialConfiguration(materialConfiguration);
};

XML3D.createClass(URNShaderComposer, AbstractShaderComposer, {
    /**
     *
     * @param {MaterialConfiguration} materialConfiguration
     */
    setMaterialConfiguration: function (materialConfiguration) {
        var shaderScriptURI = materialConfiguration.model.urn;
        this.setShaderScript(shaderScriptURI);

        if (this.descriptor) {
            materialConfiguration.dataNode && this.updateRequest(materialConfiguration.dataNode);

            this.descriptor.fragment = addFragmentShaderHeader(this.descriptor.fragment);
        }
    },

    setShaderScript: function (uri) {

        if (!uri) {
            XML3D.debug.logError("Material has no script attached: ", this.adapter.node);
            return;
        }
        if (uri.scheme != "urn") {
            XML3D.debug.logError("Material model reference should start with an URN: ", this.adapter.node);
            return;
        }
        var descriptor = getShaderDescriptor(uri.path);
        if (!descriptor) {
            throw new Error("Unknown URN: " + uri);
        }

        this.descriptor = new ShaderDescriptor();
        XML3D.extend(this.descriptor, descriptor);
    },

    getRequestFields: function () {
        return Object.keys(this.descriptor.uniforms).concat(Object.keys(this.descriptor.samplers));
    },

    /**
     * Get the attributes required by the shader
     * @returns {Object<string, *>}
     */
    getShaderAttributes: function () {
        return this.descriptor.attributes;
    },

    createShaderClosure: function () {
        return new URNShaderClosure(this.context, this.descriptor);
    },

    createObjectDataRequest: function (objectDataNode, callback) {
        var requestNames = ["position"];
        requestNames.push.apply(requestNames, Object.keys(this.descriptor.attributes));
        requestNames.push.apply(requestNames, Object.keys(this.descriptor.uniforms));
        requestNames.push.apply(requestNames, Object.keys(this.descriptor.samplers));
        return new ComputeRequest(objectDataNode, requestNames, callback);
    },

    distributeObjectShaderData: function (objectRequest, attributeCallback, uniformCallback) {
        var result = objectRequest.getResult();

        var dataMap = result.getOutputMap();
        for (var name in dataMap) {

            if (name == "position" || this.descriptor.attributes[name] !== undefined)
                attributeCallback(name, dataMap[name]); else if (this.descriptor.uniforms[name] !== undefined || this.descriptor.samplers[name] !== undefined) {
                uniformCallback(name, dataMap[name]);
            }
        }
    }

});

module.exports = URNShaderComposer;



},{"../../../../xflow/interface/request.js":190,"../../shader/shader-utils.js":157,"../abstractshadercomposer.js":122,"./diffuse.js":129,"./matte.js":130,"./phong.js":131,"./point.js":132,"./shader-descriptor.js":134,"./urnshaderclosure.js":135,"./utility.js":137}],137:[function(require,module,exports){
XML3D.materials.register("pickobjectid", {
    vertex : [
        "attribute vec3 position;",
        "uniform mat4 modelViewProjectionMatrix;",

        "void main(void) {",
        "    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "uniform vec3 id;",

        "void main(void) {",
        "    gl_FragColor = vec4(id, 0.0);",
        "}"
    ].join("\n"),

    uniforms : {}
});

XML3D.materials.register("pickedposition", {
    vertex : [
        "attribute vec3 position;",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewProjectionMatrix;",
        "uniform vec3 bbox[2];",  // min = bbox[0], max = bbox[1]

        "varying vec3 worldCoord;",

        "void main(void) {",
        "    worldCoord = (modelMatrix * vec4(position, 1.0)).xyz;",
        "    vec3 diff = bbox[1] - bbox[0];",
        "    worldCoord = worldCoord - bbox[0];",
        "    worldCoord = worldCoord / diff;",
        "    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "varying vec3 worldCoord;",

        "void main(void) {",
        "    gl_FragColor = vec4(worldCoord, 1.0);",
        "}"
    ].join("\n"),

    uniforms : {}
});


XML3D.materials.register("pickedNormals", {
    vertex : [
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "uniform mat4 modelViewProjectionMatrix;",
        "uniform mat3 modelViewMatrixN;",

        "varying vec3 fragNormal;",

        "void main(void) {",
        "    fragNormal = normalize(modelViewMatrixN * normal);",
        "    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "varying vec3 fragNormal;",

        "void main(void) {",
        "    gl_FragColor = vec4((fragNormal+1.0)/2.0 * (254.0 / 255.0), 1.0);",
        "}"
    ].join("\n"),

    uniforms : {}
});

XML3D.materials.register("light-depth", {

    vertex: [
        "attribute vec3 position;",
        "varying vec4 worldPosition;",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewProjectionMatrix;",

        "void main(void) {",
        "   worldPosition = modelMatrix * vec4(position, 1.0);",
        "   gl_Position   = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment: [
        "varying vec4 worldPosition;",
        "uniform mat4 viewMatrix;",

        "vec4 pack_depth( const in float depth ) {",
        "const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
        "const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
        "vec4 res = fract( depth * bit_shift );",
        "res -= res.xxyz * bit_mask;",
        "return res;",
        "}",


        "void main(void) {",
        "    gl_FragColor = pack_depth( gl_FragCoord.z );",
        "}"
    ].join("\n"),

    uniforms: {}
});

XML3D.materials.register("render-normal", {
    vertex : [
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "uniform mat4 modelViewProjectionMatrix;",
        "uniform mat3 modelMatrixN;",

        "varying vec3 fragNormal;",

        "void main(void) {",
        "    fragNormal = modelMatrixN * normal;",
        "    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "varying vec3 fragNormal;",

        "void main(void) {",
        "   gl_FragColor = vec4((normalize(fragNormal) + 1.0) / 2.0, 1.0);",
        "}"
    ].join("\n"),

    uniforms : {}
});

XML3D.materials.register("render-position", {
    vertex : [
        "attribute vec3 position;",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewProjectionMatrix;",

        "varying vec3 worldCoord;",

        "void main(void) {",
        "    worldCoord = (modelMatrix * vec4(position, 1.0)).xyz;",
        "    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "varying vec3 worldCoord;",

        "void main(void) {",
        "    gl_FragColor = vec4(worldCoord, 1.0);",
        "}"
    ].join("\n"),

    uniforms : {}
});

XML3D.materials.register("boxblur", {
    vertex: [
        "attribute vec3 position;",

        "void main(void) {",
        "   gl_Position = vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment: [
        "uniform sampler2D sInTexture;",
        "uniform vec2 canvasSize;",
        "uniform vec2 blurOffset;",

        "const float blurSize = 1.0/512.0;",

        "void main(void) {",
        "   vec2 texcoord = (gl_FragCoord.xy / canvasSize.xy);",
        "   vec4 sum = vec4(0.0);",
        "   float blurSizeY = blurOffset.y / canvasSize.y;",
        "   float blurSizeX = blurOffset.x / canvasSize.x;",

        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y - 1.5*blurSizeY));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y - 2.0*blurSizeY));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y - blurSizeY));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y + blurSizeY));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y + 2.0*blurSizeY));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y + 1.5*blurSizeY));",

        "   sum += texture2D(sInTexture, vec2(texcoord.x - 1.5*blurSizeX, texcoord.y));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x - 2.0*blurSizeX, texcoord.y));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x - blurSizeX, texcoord.y));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x + blurSizeX, texcoord.y));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x + 2.0*blurSizeX, texcoord.y));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x + 1.5*blurSizeX, texcoord.y));",

        "   gl_FragColor = sum / 12.0;",
        "}"
    ].join("\n"),

    uniforms: {
        canvasSize : [512, 512],
        blurOffset : [1.0, 1.0]
    },

    samplers: {
        sInTexture : null
    }
});

XML3D.materials.register("ssao", {
    vertex : [
        "attribute vec2 position;",

        "void main(void) {",
        "    gl_Position = vec4(position, 0.0, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "#ifdef GL_ES",
        "precision highp float;",
        "#endif",

        "uniform vec2 canvasSize;",
        "uniform sampler2D sPositionTex;",
        "uniform sampler2D sNormalTex;",
        "uniform sampler2D sRandomNormals;",
        "uniform vec2 uRandomTexSize;",
        "uniform float uSampleRadius;",
        "uniform float uScale;",
        "uniform float uBias;",
        "uniform float uIntensity;",
        "uniform vec2 uConstVectors[4];",
        "uniform mat4 viewMatrix;",

        "vec3 getPosition(vec2 uv) {",
        "return texture2D(sPositionTex, uv).xyz;",
        "}",

        "float calcAmbientOcclusion(vec2 screenUV, vec2 uvOffset, vec3 origin, vec3 cnorm) {",
        "   vec3 diff = getPosition(screenUV + uvOffset) - origin;",
        "   vec3 v = normalize(diff);",
        "   float dist = length(diff) * uScale;",
        "   return max(0.0, dot(cnorm, v) - uBias) * (1.0/(1.0 + dist)) * uIntensity;",
        "}",

        "void main(void) {",
        "   vec2 screenUV = gl_FragCoord.xy / canvasSize.xy;",
        "   vec2 rand = normalize(texture2D(sRandomNormals, gl_FragCoord.xy / uRandomTexSize).xy * 2.0 - 1.0 );",
        "   vec3 norm = normalize(texture2D(sNormalTex, screenUV).xyz * 2.0 - 1.0 );",
        "   vec3 origin = getPosition(screenUV);",
        "   float radius = uSampleRadius / (viewMatrix * vec4(origin, 1.0)).z;",
        "   float ao = 0.0;",

        "   const int iterations = 4;",
        "   for (int i = 0; i < iterations; ++i) {",
        "       vec2 coord1 = reflect(uConstVectors[i], rand) * radius;",
        "       vec2 coord2 = vec2(coord1.x*0.707 - coord1.y*0.707, coord1.x*0.707 + coord1.y*0.707);",
        "       ao += calcAmbientOcclusion(screenUV, coord1*0.25, origin, norm);",
        "       ao += calcAmbientOcclusion(screenUV, coord2*0.5, origin, norm);",
        "       ao += calcAmbientOcclusion(screenUV, coord1*0.75, origin, norm);",
        "       ao += calcAmbientOcclusion(screenUV, coord2, origin, norm);",
        "   }",
        "   ao /= (float(iterations) * 4.0);",
        "   gl_FragColor = vec4(ao, ao, ao, 1.0);",
        "}"
    ].join("\n"),

    uniforms: {
        canvasSize      : [512, 512],
        uConstVectors   : [1,0, -1,0, 0,1, 0,-1],
        uRandomTexSize  : [64,64],
        uSampleRadius   : 0.9,
        uScale          : 0.9,
        uBias           : 0.2,
        uIntensity      : 1.0
    },

    samplers: {
        sPositionTex   : null,
        sNormalTex     : null,
        sRandomNormals : null
    },

    attributes: {
    }
});

},{}],138:[function(require,module,exports){
// Note: This context should only be used to access GL constants
var GL = require("./constants.js");
var Targets = require("./base/rendertarget.js");
var FullScreenQuad = require("./base/fullscreenquad.js");
var ForwardRenderTree = require("./render-trees/forward.js");
var ForwardRenderPass = require("./render-passes/forward.js");

/**
 *
 * @param {GLContext} context
 * @param {Scene} scene
 * @constructor
 */
var GLRenderInterface = function (context, scene) {
    this.context = context;
    this.scene = scene;
    this.shaders = {};
    this.options = {
        pickingEnabled: true,
        mouseMovePickingEnabled: true,
        glBlendFuncSeparate: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA, GL.ONE, GL.ONE_MINUS_SRC_ALPHA]
    };
    this.renderTree = null;
};

XML3D.extend(GLRenderInterface.prototype, {
    getRenderTree: function () {
        return (this.renderTree = this.renderTree || new ForwardRenderTree(this.context));
    },

    setRenderTree: function (tree) {
        //TODO cleanup old pipeline
        this.renderTree = tree;
        this.context.requestRedraw("Pipeline changed");
    },

    createRenderTarget: function(opt) {
        return new Targets.GLRenderTarget(this.context, opt);
    },

    createScaledRenderTarget: function(maxDimension, opt) {
        return new Targets.GLScaledRenderTarget(this.context, maxDimension, opt);
    },

    getShaderProgram: function(name) {
        if (!this.shaders[name] || !this.shaders[name].isValid()) {
            this.shaders[name] = this.context.programFactory.getProgramByName(name);
        }

        return this.shaders[name];
    },

    createFullscreenQuad: function() {
        return new FullScreenQuad(this.context);
    },

    createSceneRenderPass: function(target) {
        return new ForwardRenderPass(this, target || this.context.canvasTarget);
    }
});

module.exports = GLRenderInterface;


},{"./base/fullscreenquad.js":113,"./base/rendertarget.js":116,"./constants.js":120,"./render-passes/forward.js":141,"./render-trees/forward.js":151}],139:[function(require,module,exports){
/**
 * @constructor
 */
var BaseRenderPass = function (renderInterface, output, opt) {
    this.renderInterface = renderInterface;
    this.output = output;
    opt = opt || {};
    this.inputs = opt.inputs || {};
    this.id = opt.id || "";
    this.prePasses = [];
    this.postPasses = [];
    this.processed = false;
};

XML3D.extend(BaseRenderPass.prototype, {
    addPrePass: function (pass) {
        if (this.prePasses.indexOf(pass) === -1) {
            this.prePasses.push(pass);
            pass.postPasses.push(this);
        }
    },

    removePrePass: function (pass) {
        var idx = this.prePasses.indexOf(pass);
        if (idx !== -1) {
            this.prePasses.splice(idx, 1);
            pass.postPasses.splice(pass.postPasses.indexOf(this), 1);
        }
    },

    clearPrePasses: function () {
        var i = this.prePasses.length;
        while (i--)
            this.removePrePass(this.prePasses[i]);
    },

    setProcessed: function (processed) {
        if (this.processed && !processed) {
            var i = this.postPasses.length;
            while (i--)
                this.postPasses[i].setProcessed(false);
        }
        this.processed = processed;
    },

    renderTree: function (scene) {
        if (this.processed)
            return;
        this.processed = true;
        var i = this.prePasses.length;
        while (i--)
            this.prePasses[i].renderTree(scene);
        this.render(scene);
    },

    /**
     * Reads pixels from the pass's target
     *
     * @param {number} glX OpenGL Coordinate in the target
     * @param {number} glY OpenGL Coordinate in the target
     * @returns {Uint8Array} pixel data
     */
    readPixelDataFromBuffer: (function () {
        var c_data = new Uint8Array(8);

        return function (glX, glY, target) {
            var gl = this.renderInterface.context.gl;
            var scale = target.getScale();
            var x = glX * scale;
            var y = glY * scale;

            target.bind();
            try {
                gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, c_data);
                target.unbind();
                return c_data;
            } catch (e) {
                XML3D.debug.logException(e);
                target.unbind();
                return null;
            }
        }
    }())

});

module.exports = BaseRenderPass;


},{}],140:[function(require,module,exports){
var BaseRenderPass = require("./base.js");
var FullscreenQuad = require("../base/fullscreenquad.js");

var BoxBlurPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
    this._program = this.renderInterface.context.programFactory.getProgramByName("boxblur");
    this._screenQuad = new FullscreenQuad(this.renderInterface.context);
    this._uniformsDirty = true;
};

XML3D.createClass(BoxBlurPass, BaseRenderPass);

XML3D.extend(BoxBlurPass.prototype, {
    render: (function () {
        return function () {
            var gl = this.renderInterface.context.gl;
            var target = this.output;

            target.bind();
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.disable(gl.DEPTH_TEST);

            this._program.bind();
            this._setNonVolatileShaderUniforms();

            this._screenQuad.draw(this._program);

            this._program.unbind();
            target.unbind();
        }
    }()),

    _setNonVolatileShaderUniforms: (function () {
        var uniforms = {};
        var uniformNames = ["canvasSize", "sInTexture", "blurOffset"];

        return function () {
            if (!this._uniformsDirty)
                return;

            var program = this._program;
            var target = this.output;

            uniforms["canvasSize"] = [target.width, target.height];
            uniforms["sInTexture"] = [this.inputs.buffer.colorTarget.handle];
            uniforms["blurOffset"] = [1.0, 1.0];
            program.setSystemUniformVariables(uniformNames, uniforms);

//                this._uniformsDirty = false;
        }
    })()
});

module.exports = BoxBlurPass;


},{"../base/fullscreenquad.js":113,"./base.js":139}],141:[function(require,module,exports){
var SceneRenderPass = require("./scene-pass.js");
var ObjectSorter = require("../../renderer/tools/objectsorter.js");
var mat4 = require("gl-matrix").mat4;

var ForwardRenderPass = function (renderInterface, output, opt) {
    SceneRenderPass.call(this, renderInterface, output, opt);
    this.sorter = new ObjectSorter();
    this.lastRenderStats = {};
};

XML3D.createClass(ForwardRenderPass, SceneRenderPass);

XML3D.extend(ForwardRenderPass.prototype, {


    render: (function () {
        /**
         * @type mat4
         */
        var c_worldToViewMatrix = mat4.create();
        var c_viewToWorldMatrix = mat4.create();
        var c_projectionMatrix = mat4.create();
        var c_programSystemUniforms = ["viewMatrix", "viewInverseMatrix", "projectionMatrix", "cameraPosition", "coords", "ssaoMap", "width"];

        return function (scene) {
            var gl = this.renderInterface.context.gl, count = {
                    objects: 0,
                    primitives: 0
                }, target = this.output, systemUniforms = scene.systemUniforms, width = target.getWidth(), height = target.getHeight(), aspect = width / height;

            target.bind();
            this.setGLStates();

            scene.updateReadyObjectsFromActiveView(aspect);
            scene.getActiveView().getWorldToViewMatrix(c_worldToViewMatrix);
            scene.getActiveView().getViewToWorldMatrix(c_viewToWorldMatrix);
            scene.getActiveView().getProjectionMatrix(c_projectionMatrix, aspect);

            var sorted = this.sorter.sortObjects(scene.ready, c_worldToViewMatrix);

            systemUniforms["viewMatrix"] = c_worldToViewMatrix;
            systemUniforms["viewInverseMatrix"] = c_viewToWorldMatrix;
            systemUniforms["projectionMatrix"] = c_projectionMatrix;
            systemUniforms["cameraPosition"] = scene.getActiveView().getWorldSpacePosition();
            systemUniforms["coords"] = [target.width, target.height, 1];

            if (this.inputs.ssaoMap)
                systemUniforms["ssaoMap"] = [this.inputs.ssaoMap.colorTarget.handle];

            //Render opaque objects
            for (var i in sorted.zLayers) {
                var zLayer = sorted.zLayers[i];
                gl.clear(gl.DEPTH_BUFFER_BIT);
                for (var program in sorted.opaque[zLayer]) {
                    this.renderObjectsToActiveBuffer(sorted.opaque[zLayer][program], scene, target, systemUniforms, c_programSystemUniforms, {
                        transparent: false,
                        stats: count
                    });
                }
                if (sorted.transparent[zLayer].length) {
                    for (var k = 0; k < sorted.transparent[zLayer].length; k++) {
                        var objectArray = [sorted.transparent[zLayer][k]];
                        this.renderObjectsToActiveBuffer(objectArray, scene, target, systemUniforms, c_programSystemUniforms, {
                            transparent: true,
                            stats: count
                        });
                    }
                }
            }

            scene.lights.changed = false;
            target.unbind();
            this.lastRenderStats.count = count;
        }
    }()),

    getRenderStats: function () {
        return this.lastRenderStats;
    }

});


module.exports = ForwardRenderPass;


},{"../../renderer/tools/objectsorter.js":110,"./scene-pass.js":147,"gl-matrix":1}],142:[function(require,module,exports){
var SceneRenderPass = require("./scene-pass.js");
var ObjectSorter = require("../../renderer/tools/objectsorter.js");
var mat4 = require("gl-matrix").mat4;

/**
 * @param {GLRenderInterface} renderInterface
 * @param {string} output
 * @param {RenderLight} light
 * @param {*} opt
 * @extends {SceneRenderPass}
 * @constructor
 */
var LightPass = function (renderInterface, output, light, opt) {
    SceneRenderPass.call(this, renderInterface, output, opt);
    this.light = light;
    this.program = null;
};

XML3D.createClass(LightPass, SceneRenderPass, {

    init: function (context) {
        this.sorter = new ObjectSorter();
        this.program = context.programFactory.getProgramByName("light-depth");
    },

    renderScene: function() {
        this.render(this.light.scene);
    },

    render: (function () {
        var c_viewMat_tmp = mat4.create();
        var c_projMat_tmp = mat4.create();
        var c_programSystemUniforms = ["viewMatrix", "projectionMatrix"];

        return function (scene) {
            var gl = this.renderInterface.context.gl, target = this.output, width = target.getWidth(), height = target.getHeight(), aspect = width / height, frustum = this.light.getFrustum(aspect), program = this.program;

            target.bind();
            gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            var count = {objects: 0, primitives: 0};

            this.light.model.getLightViewMatrix(c_viewMat_tmp);
            frustum.getProjectionMatrix(c_projMat_tmp, aspect);

            scene.updateReadyObjectsFromMatrices(c_viewMat_tmp, c_projMat_tmp);
            var objects = this.sorter.sortObjects(scene.ready);

            var parameters = {};
            parameters["viewMatrix"] = c_viewMat_tmp;
            parameters["projectionMatrix"] = c_projMat_tmp;

            //Render opaque objects
            for (var i in objects.zLayers) {
                var zLayer = objects.zLayers[i];
                gl.clear(gl.DEPTH_BUFFER_BIT);
                for (var prg in objects.opaque[zLayer]) {
                    this.renderObjectsToActiveBuffer(objects.opaque[zLayer][prg], scene, target, parameters, c_programSystemUniforms, {
                        transparent: false,
                        stats: count,
                        program: program
                    });
                }
            }

            // Do not render transparent objects (considered to not throw shadows
            target.unbind();
            return {count: count};
        }
    }())
});

module.exports = LightPass;


},{"../../renderer/tools/objectsorter.js":110,"./scene-pass.js":147,"gl-matrix":1}],143:[function(require,module,exports){
var BaseRenderPass = require("./base.js");
var vec3 = require("gl-matrix").vec3;
var mat4 = require("gl-matrix").mat4;
var mat3 = require("gl-matrix").mat3;

var PickNormalRenderPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
};

XML3D.createClass(PickNormalRenderPass, BaseRenderPass, {
    render: (function () {
        var c_modelViewProjectionMatrix = mat4.create();
        var c_worldMatrix = mat4.create();
        var c_normalMatrix3 = mat3.create();
        var c_uniformCollection = {
                envBase: {},
                envOverride: null,
                sysBase: {}
            }, c_systemUniformNames = ["modelViewProjectionMatrix", "modelViewMatrixN"];

        return function (object, viewMatrix, projMatrix) {
            var gl = this.renderInterface.context.gl, target = this.output;

            target.bind();
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.BLEND);

            if (viewMatrix && projMatrix) {
                object.updateModelViewMatrix(viewMatrix);
                object.updateModelViewProjectionMatrix(projMatrix);
            }

            object.getModelViewProjectionMatrix(c_modelViewProjectionMatrix);

            object.getWorldMatrix(c_worldMatrix);
            if (!XML3D.math.mat3.normalFromMat4(c_normalMatrix3, c_worldMatrix)) {
                mat3.identity(c_normalMatrix3);
            }

            var program = this.renderInterface.context.programFactory.getPickingNormalProgram();
            program.bind();

            c_uniformCollection.sysBase["modelViewProjectionMatrix"] = c_modelViewProjectionMatrix;
            c_uniformCollection.sysBase["modelViewMatrixN"] = c_normalMatrix3;

            program.setUniformVariables(null, c_systemUniformNames, c_uniformCollection);
            object.mesh.draw(program);

            program.unbind();
            target.unbind();
        }
    }()), /**
     * Read normal from picking buffer
     * @param {number} glX OpenGL Coordinate of color buffer
     * @param {number} glY OpenGL Coordinate of color buffer
     * @returns {Object} Vector with normal data
     */
    readNormalFromPickingBuffer: (function () {
        var c_pickVector = vec3.create();
        var c_one = vec3.fromValues(1, 1, 1);

        return function (glX, glY) {
            var data = this.readPixelDataFromBuffer(glX, glY, this.output);
            if (!data) {
                return null;
            }
            c_pickVector[0] = data[0] / 254;
            c_pickVector[1] = data[1] / 254;
            c_pickVector[2] = data[2] / 254;

            vec3.scale(c_pickVector, c_pickVector, 2);
            return vec3.subtract(vec3.create(), c_pickVector, c_one);
        }
    }())
});


module.exports = PickNormalRenderPass;


},{"./base.js":139,"gl-matrix":1}],144:[function(require,module,exports){
var BaseRenderPass = require("./base.js");
var mat4 = require("gl-matrix").mat4;
var ObjectSorter = require("../../renderer/tools/objectsorter.js");

var PickObjectRenderPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
    this.sorter = new ObjectSorter();
    this.objCount = 0;
};
XML3D.createClass(PickObjectRenderPass, BaseRenderPass);

XML3D.extend(PickObjectRenderPass.prototype, {
    render: function (objects, viewMatrix, projMatrix) {
        var gl = this.renderInterface.context.gl, target = this.output;
        target.bind();
        var sortedObjects = this.sorter.sortObjects(objects, viewMatrix);
        this.objCount = 0;

        gl.enable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.disable(gl.BLEND);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        var program = this.renderInterface.context.programFactory.getPickingObjectIdProgram();
        program.bind();
        for (var j = 0, n = sortedObjects.zLayers.length; j < n; j++) {
            var zLayer = sortedObjects.zLayers[j];
            gl.clear(gl.DEPTH_BUFFER_BIT);
            if (sortedObjects.opaque[zLayer]) {
                for (var prg in sortedObjects.opaque[zLayer]) {
                    this.renderObjects(sortedObjects.opaque[zLayer][prg], program, viewMatrix, projMatrix);
                }
            }
            if (sortedObjects.transparent[zLayer]) {
                this.renderObjects(sortedObjects.transparent[zLayer], program, viewMatrix, projMatrix);
            }
        }
        program.unbind();
        target.unbind();
    },

    renderObjects: (function () {
        var c_mvp = mat4.create(), c_uniformCollection = {
            envBase: {},
            envOverride: null,
            sysBase: {}
        }, c_systemUniformNames = ["id", "modelViewProjectionMatrix"];

        return function (objects, program, viewMatrix, projMatrix) {
            for (var i=0; i < objects.length; i++) {
                var obj = objects[i];
                var mesh = obj.mesh;

                if (!obj.visible)
                    continue;

                if (viewMatrix && projMatrix) {
                    obj.updateModelViewMatrix(viewMatrix);
                    obj.updateModelViewProjectionMatrix(projMatrix);
                }

                obj.getModelViewProjectionMatrix(c_mvp);

                var objId = ++this.objCount;
                obj.pickId = objId;
                var c1 = objId & 255;
                objId = objId >> 8;
                var c2 = objId & 255;
                objId = objId >> 8;
                var c3 = objId & 255;

                c_uniformCollection.sysBase["id"] = [c3 / 255.0, c2 / 255.0, c1 / 255.0];
                c_uniformCollection.sysBase["modelViewProjectionMatrix"] = c_mvp;

                program.setUniformVariables(null, c_systemUniformNames, c_uniformCollection);
                mesh.draw(program);
            }
        };
    }()),

    /**
     * Reads pixels from the screenbuffer to determine picked object or normals.
     *
     * @param {number} x Screen Coordinate of color buffer
     * @param {number} y Screen Coordinate of color buffer
     * @param {Array} objects List of objects that were rendered in the previous picking pass
     * @returns {RenderObject|null} Picked Object
     */
    getRenderObjectFromPickingBuffer: function (x, y, objects) {
        var data = this.readPixelDataFromBuffer(x, y, this.output);

        if (!data)
            return null;

        var result = null;
        var objId = data[0] * 65536 + data[1] * 256 + data[2];

        if (objId > 0) {
            for (var i=0; i < objects.length; i++) {
                if (objects[i].inFrustum && objects[i].pickId === objId) {
                    result = objects[i];
                    break;
                }
            }
        }
        return result;
    }
});

module.exports = PickObjectRenderPass;


},{"../../renderer/tools/objectsorter.js":110,"./base.js":139,"gl-matrix":1}],145:[function(require,module,exports){
var BaseRenderPass = require("./base.js");
var mat4 = require("gl-matrix").mat4;
var vec3 = require("gl-matrix").vec3;

var PickPositionRenderPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
    this.objectBoundingBox = new XML3D.Box();
};
XML3D.createClass(PickPositionRenderPass, BaseRenderPass, {
    render: (function () {

        var c_modelMatrix = mat4.create();
        var c_modelViewProjectionMatrix = mat4.create(), c_uniformCollection = {
                envBase: {},
                envOverride: null,
                sysBase: {}
            }, c_systemUniformNames = ["bbox", "modelMatrix", "modelViewProjectionMatrix"];

        return function (obj, viewMatrix, projMatrix) {
            var gl = this.renderInterface.context.gl, target = this.output;

            target.bind();
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.BLEND);

            if (viewMatrix && projMatrix) {
                obj.updateModelViewMatrix(viewMatrix);
                obj.updateModelViewProjectionMatrix(projMatrix);
            }
            obj.getWorldMatrix(c_modelMatrix);

            obj.getObjectSpaceBoundingBox(this.objectBoundingBox);
            this.objectBoundingBox.transformAxisAligned(c_modelMatrix);

            var program = this.renderInterface.context.programFactory.getPickingPositionProgram();
            program.bind();
            obj.getModelViewProjectionMatrix(c_modelViewProjectionMatrix);

            c_uniformCollection.sysBase["bbox"] = this.objectBoundingBox.data;
            c_uniformCollection.sysBase["modelMatrix"] = c_modelMatrix;
            c_uniformCollection.sysBase["modelViewProjectionMatrix"] = c_modelViewProjectionMatrix;

            program.setUniformVariables(null, c_systemUniformNames, c_uniformCollection);
            obj.mesh.draw(program);

            program.unbind();
            target.unbind();
        };
    }()),

    readPositionFromPickingBuffer: (function () {

        var c_vec3 = vec3.create();

        return function (x, y) {
            var data = this.readPixelDataFromBuffer(x, y, this.output);
            if (data) {

                c_vec3[0] = data[0] / 255;
                c_vec3[1] = data[1] / 255;
                c_vec3[2] = data[2] / 255;

                var size = this.objectBoundingBox.size();
                vec3.mul(c_vec3, c_vec3, size.data);
                return vec3.add(vec3.create(), c_vec3, this.objectBoundingBox.min.data);
            } else {
                return null;
            }
        }
    }())
});

module.exports = PickPositionRenderPass;


},{"./base.js":139,"gl-matrix":1}],146:[function(require,module,exports){
var SceneRenderPass = require("./scene-pass.js");
var ObjectSorter = require("../../renderer/tools/objectsorter.js");
var mat4 = require("gl-matrix").mat4;

/**
 * @param {GLRenderInterface} renderInterface
 * @param {string} output
 * @param {RenderLight} light
 * @param {*} opt
 * @extends {SceneRenderPass}
 * @constructor
 */
var PointLightPass = function (renderInterface, output, light, opt) {
    SceneRenderPass.call(this, renderInterface, output, opt);
    this.light = light;
    this.program = null;
};

XML3D.createClass(PointLightPass, SceneRenderPass, {

    init: function (context) {
        this.sorter = new ObjectSorter();
        this.program = context.programFactory.getProgramByName("light-depth");
    },

    renderScene: function() {
        this.render(this.light.scene);
    },

    render: (function () {
        var c_viewMat_tmp = mat4.create();
        var c_projMat_tmp = mat4.create();
        var c_programSystemUniforms = ["viewMatrix", "projectionMatrix"];

        return function (scene) {

            var gl = this.renderInterface.context.gl, target = this.output, width = target.getWidth(), height = target.getHeight(), aspect = width / height, frustum = this.light.getFrustum(aspect), program = this.program;
            for (var side = 0; side < target.glSides.length; side++) {
                //calculate rotationmatrix for that face
                var mat_rot = new XML3D.Mat4();

                if (side == 0) { //look into +x o
                    mat_rot.m11 = 0;
                    mat_rot.m12 = 0;
                    mat_rot.m13 = -1;
                    mat_rot.m21 = 0;
                    mat_rot.m22 = -1;
                    mat_rot.m23 = 0;
                    mat_rot.m31 = -1;
                    mat_rot.m32 = 0;
                    mat_rot.m33 = 0;

                } else if (side == 1) { //look into -x
                    mat_rot.m11 = 0;
                    mat_rot.m12 = 0;
                    mat_rot.m13 = 1;
                    mat_rot.m21 = 0;
                    mat_rot.m22 = -1;
                    mat_rot.m23 = 0;
                    mat_rot.m31 = 1;
                    mat_rot.m32 = 0;
                    mat_rot.m33 = 0;

                } else if (side == 2) { //look into +y
                    mat_rot.m11 = 1;
                    mat_rot.m12 = 0;
                    mat_rot.m13 = 0;
                    mat_rot.m21 = 0;
                    mat_rot.m22 = 0;
                    mat_rot.m23 = -1;
                    mat_rot.m31 = 0;
                    mat_rot.m32 = 1;
                    mat_rot.m33 = 0;

                } else if (side == 3) { //look into -y
                    mat_rot.m11 = 1;
                    mat_rot.m12 = 0;
                    mat_rot.m13 = 0;
                    mat_rot.m21 = 0;
                    mat_rot.m22 = 0;
                    mat_rot.m23 = 1;
                    mat_rot.m31 = 0;
                    mat_rot.m32 = -1;
                    mat_rot.m33 = 0;

                } else if (side == 4) { //look into +z
                    mat_rot.m11 = 1;
                    mat_rot.m12 = 0;
                    mat_rot.m13 = 0;
                    mat_rot.m21 = 0;
                    mat_rot.m22 = -1;
                    mat_rot.m23 = 0;
                    mat_rot.m31 = 0;
                    mat_rot.m32 = 0;
                    mat_rot.m33 = -1;

                } else if (side == 5) { //look into -z
                    mat_rot.m11 = -1;
                    mat_rot.m12 = 0;
                    mat_rot.m13 = 0;
                    mat_rot.m21 = 0;
                    mat_rot.m22 = -1;
                    mat_rot.m23 = 0;
                    mat_rot.m31 = 0;
                    mat_rot.m32 = 0;
                    mat_rot.m32 = 1;
                }

                target.bind(side);

                gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
                gl.enable(gl.DEPTH_TEST);

                var count = {objects: 0, primitives: 0};

                this.light.model.getLightViewMatrix(c_viewMat_tmp);
                //rotate for the apropriate side of the cubemap
                XML3D.math.mat4.mul(c_viewMat_tmp, mat_rot.data, c_viewMat_tmp);

                frustum.getProjectionMatrix(c_projMat_tmp, aspect);

                scene.updateReadyObjectsFromMatrices(c_viewMat_tmp, c_projMat_tmp);
                var objects = this.sorter.sortObjects(scene.ready);

                var parameters = {};
                parameters["viewMatrix"] = c_viewMat_tmp;
                parameters["projectionMatrix"] = c_projMat_tmp;

                //Render opaque objects
                for (var i in objects.zLayers) {
                    var zLayer = objects.zLayers[i];
                    gl.clear(gl.DEPTH_BUFFER_BIT);
                    for (var prg in objects.opaque[zLayer]) {
                        this.renderObjectsToActiveBuffer(objects.opaque[zLayer][prg], scene, target, parameters, c_programSystemUniforms, {
                            transparent: false,
                            stats: count,
                            program: program
                        });
                    }
                }

                // Do not render transparent objects (considered to not throw shadows
                target.unbind();
            }
            return {count: count};
        }
    }())
});


module.exports = PointLightPass;


},{"../../renderer/tools/objectsorter.js":110,"./scene-pass.js":147,"gl-matrix":1}],147:[function(require,module,exports){
var BaseRenderPass = require("./base.js");
var Options = require("../../../utils/options.js");
var mat4 = require("gl-matrix").mat4;
var mat3 = require("gl-matrix").mat3;

var OPTION_FACECULLING = "renderer-faceculling";
var OPTION_FRONTFACE = "renderer-frontface";

Options.register(OPTION_FACECULLING, "none");
Options.register(OPTION_FRONTFACE, "ccw");

/**
 * @constructor
 */
var SceneRenderPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
    /**
     * @type {function}
     */
    this.setFaceCulling = getGlobalFaceCullingSetter(Options.getValue(OPTION_FACECULLING));
    /**
     * @type {function}
     */
    this.setFrontFace = getGlobalFrontFaceSetter(Options.getValue(OPTION_FRONTFACE));

    var that = this;
    Options.addObserver(OPTION_FACECULLING, function (key, value) {
        that.setFaceCulling = getGlobalFaceCullingSetter(value);
    });
    Options.addObserver(OPTION_FRONTFACE, function (key, value) {
        that.setFrontFace = getGlobalFrontFaceSetter(value);
    });
};

XML3D.createClass(SceneRenderPass, BaseRenderPass, {
    setGLStates: function () {
        var gl = this.renderInterface.context.gl;
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
        this.setFaceCulling(gl);
        this.setFrontFace(gl);
        gl.enable(gl.DEPTH_TEST);
    }, /**
     * @param Array
     */
    renderObjectsToActiveBuffer: (function () {
        var tmpModelMatrix = mat4.create();
        var tmpModelMatrixN = mat3.create();
        var tmpModelView = mat4.create();
        var tmpModelViewProjection = mat4.create();
        var tmpModelViewN = mat3.create();
        var c_objectSystemUniforms = ["modelMatrix", "modelMatrixN", "modelViewMatrix", "modelViewProjectionMatrix", "modelViewMatrixN"];

        return function (objectArray, scene, target, systemUniforms, sceneParameterFilter, opt) {
            var objCount = 0;
            var primitiveCount = 0;
            var stats = opt.stats || {};
            var transparent = opt.transparent === true || false;
            var gl = this.renderInterface.context.gl;
            var program = opt.program || objectArray[0].getProgram();

            if (objectArray.length == 0) {
                return stats;
            }

            if (transparent) {
                gl.enable(gl.BLEND);
                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            }

            // At this point, we guarantee that the RenderObject has a valid shader
            program.bind();

            //Set global data that is shared between all objects using this shader
            program.setSystemUniformVariables(sceneParameterFilter, systemUniforms);

            var prevOverride = null;

            for (var i = 0, n = objectArray.length; i < n; i++) {
                var obj = objectArray[i];
                if (!obj.visible)
                    continue;

                var mesh = obj.mesh;
                XML3D.debug.assert(mesh, "We need a mesh at this point.");

                obj.getWorldMatrix(tmpModelMatrix);
                systemUniforms["modelMatrix"] = tmpModelMatrix;

                obj.getModelMatrixN(tmpModelMatrixN);
                systemUniforms["modelMatrixN"] = tmpModelMatrixN;

                obj.getModelViewMatrix(tmpModelView);
                systemUniforms["modelViewMatrix"] = tmpModelView;

                obj.getModelViewProjectionMatrix(tmpModelViewProjection);
                systemUniforms["modelViewProjectionMatrix"] = tmpModelViewProjection;

                obj.getModelViewMatrixN(tmpModelViewN);
                systemUniforms["modelViewMatrixN"] = tmpModelViewN;

                program.setSystemUniformVariables(c_objectSystemUniforms, systemUniforms);

                program.changeUniformVariableOverride(prevOverride, mesh.uniformOverride);
                prevOverride = mesh.uniformOverride;

                primitiveCount += mesh.draw(program);
                objCount++;
            }

            if (transparent) {
                gl.disable(gl.BLEND);
            }

            program.changeUniformVariableOverride(prevOverride, null);

            program.unbind();
            stats.objects += objCount;
            stats.primitives += primitiveCount;
            return stats;
        }
    }())


});

function getGlobalFrontFaceSetter(mode) {
    if (mode.toLowerCase() == "cw") {
        return function (gl) {
            gl.frontFace(gl.CW);
        };
    }
    return function (gl) {
        gl.frontFace(gl.CCW);
    };
}

function getGlobalFaceCullingSetter(mode) {
    //noinspection FallthroughInSwitchStatementJS
    switch (mode.toLowerCase()) {
        case "back":
            return function (gl) {
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.BACK);
            };
            break;
        case "front":
            return function (gl) {
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.FRONT);
            };
            break;
        case "both":
            return function (gl) {
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.FRONT_AND_BACK);
            };
            break;
        case "none":
        default:
            return function (gl) {
                gl.disable(gl.CULL_FACE);
            };
    }
}

module.exports = SceneRenderPass;

},{"../../../utils/options.js":183,"./base.js":139,"gl-matrix":1}],148:[function(require,module,exports){
var BaseRenderPass = require("./base.js");
var VertexAttributePass = require("./vertexattribute-pass.js");
var GLRenderTarget = require("../base/rendertarget.js").GLRenderTarget;
var FullscreenQuad = require("../base/fullscreenquad.js");
var Options = require("../../../utils/options.js");

var base64RandomNormals = "data:image/png;base64,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"

var OPTION_SSAO_SCALE = "renderer-ssao-scale";
var OPTION_SSAO_INTENSITY = "renderer-ssao-intensity";
var OPTION_SSAO_BIAS = "renderer-ssao-bias";
var OPTION_SSAO_RADIUS = "renderer-ssao-radius";
var FLAGS = {};
FLAGS[OPTION_SSAO_SCALE] = {defaultValue: 1};
FLAGS[OPTION_SSAO_INTENSITY] = {defaultValue: 5};
FLAGS[OPTION_SSAO_BIAS] = {defaultValue: 0.2};
FLAGS[OPTION_SSAO_RADIUS] = {defaultValue: 1};
for (var flag in FLAGS) {
    Options.register(flag, FLAGS[flag].defaultValue);
}

var SSAOPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
    var context = this.renderInterface.context;
    this._program = context.programFactory.getProgramByName("ssao");
    this.randomVectorTexture = this.createRandomVectorTexture(context);
    this.loadRandomVectorImage();
    this._screenQuad = new FullscreenQuad(context);
    this._uniformsDirty = true;
//		if (!this.inputs.positionBuffer)
//			this._positionPass = this.createVertexAttributePass("render-position");
//		if (!this.inputs.normalBuffer)
//			this._normalPass = this.createVertexAttributePass("render-normal");
};

XML3D.createClass(SSAOPass, BaseRenderPass);

XML3D.extend(SSAOPass.prototype, {
    createRandomVectorTexture: function (context) {
        var gl = context.gl;
        var tex = context.createTexture();
        tex.createTex2DFromData(gl.RGBA, 64, 64, gl.RGBA, gl.UNSIGNED_BYTE, {
            wrapS: gl.REPEAT, wrapT: gl.REPEAT, minFilter: gl.LINEAR, magFilter: gl.LINEAR
        });
        tex.isTexture = true;
        return tex;
    },

    loadRandomVectorImage: function () {
        var img = new Image();
        img.src = base64RandomNormals;
        var gl = this.renderInterface.context.gl;
        var texhandle = this.randomVectorTexture.handle;

        img.onload = function () {
            gl.bindTexture(gl.TEXTURE_2D, texhandle);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        }
    },

    createVertexAttributePass: function (programName) {
        var context = this.renderInterface.context;
        var buffer = new GLRenderTarget(context, {
            width: context.canvasTarget.width,
            height: context.canvasTarget.height,
            colorFormat: context.gl.RGBA,
            colorType: context.gl.FLOAT,
            depthFormat: context.gl.DEPTH_COMPONENT16,
            stencilFormat: null,
            depthAsRenderbuffer: true
        });
        return new VertexAttributePass(this.renderInterface, buffer, {
            programName: programName
        });
    },

    render: (function () {
//			if (this._positionPass)
//				this._positionPass.setProcessed(false);

        var viewMatrix = XML3D.math.mat4.create();
        var uniformNames = ["viewMatrix"];
        return function (scene) {
            var gl = this.renderInterface.context.gl;
            var target = this.output;

            target.bind();
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.disable(gl.DEPTH_TEST);

            this._program.bind();
            this._setNonVolatileShaderUniforms();

            var uniforms = {};
            scene.getActiveView().getWorldToViewMatrix(viewMatrix);
            uniforms["viewMatrix"] = viewMatrix;
            this._program.setSystemUniformVariables(uniformNames, uniforms);
            this._screenQuad.draw(this._program);

            this._program.unbind();
            target.unbind();
        }
    }()),

    _setNonVolatileShaderUniforms: (function () {
        var uniformNames = ["canvasSize", "sPositionTex", "sNormalTex", "sRandomNormals", "uRandomTexSize", "uScale", "uBias", "uIntensity", "uSampleRadius", "uConstVectors"];

        return function () {
            if (!this._uniformsDirty)
                return;

            var uniforms = {};
            var program = this._program;
            program.bind();
            var target = this.output;

            uniforms["canvasSize"] = [target.width, target.height];
            uniforms["sPositionTex"] = [this.inputs.positionBuffer.colorTarget.handle];
            uniforms["sNormalTex"] = [this.inputs.normalBuffer.colorTarget.handle];
            uniforms["sRandomNormals"] = [this.randomVectorTexture];
            uniforms["uRandomTexSize"] = [64, 64];
            uniforms["uScale"] = Options.getValue(OPTION_SSAO_SCALE);
            uniforms["uBias"] = Options.getValue(OPTION_SSAO_BIAS);
            uniforms["uIntensity"] = Options.getValue(OPTION_SSAO_INTENSITY);
            uniforms["uSampleRadius"] = Options.getValue(OPTION_SSAO_RADIUS);
            uniforms["uConstVectors"] = [1, 0, -1, 0, 0, 1, 0, -1];

            program.setSystemUniformVariables(uniformNames, uniforms);
            program.unbind();

//                this._uniformsDirty = false;
        }
    })()
});

module.exports = SSAOPass;


},{"../../../utils/options.js":183,"../base/fullscreenquad.js":113,"../base/rendertarget.js":116,"./base.js":139,"./vertexattribute-pass.js":149}],149:[function(require,module,exports){
var SceneRenderPass = require("./scene-pass.js");

var VertexAttributePass = function (renderInterface, output, opt) {
    SceneRenderPass.call(this, renderInterface, output, opt);
    this._program = this.renderInterface.context.programFactory.getProgramByName(opt.programName);
};

XML3D.createClass(VertexAttributePass, SceneRenderPass);

XML3D.extend(VertexAttributePass.prototype, {
    render: function (scene) {
        var gl = this.renderInterface.context.gl;
        var target = this.output;
        var width = target.getWidth();
        var height = target.getHeight();
        var aspect = width / height;

        target.bind();
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.enable(gl.DEPTH_TEST);

        scene.updateReadyObjectsFromActiveView(aspect);

        this.renderObjectsToActiveBuffer(scene.ready, scene, target, scene.systemUniforms, [], {
            transparent: false,
            program: this._program
        });

        target.unbind();
    }
});

module.exports = VertexAttributePass;


},{"./scene-pass.js":147}],150:[function(require,module,exports){
var BaseRenderTree = function (renderInterface) {
    this.mainRenderPass = null;
    this.renderInterface = renderInterface;
};

XML3D.extend(BaseRenderTree.prototype, {
    render: function (scene) {
        this.mainRenderPass.renderTree(scene);
    },

    getRenderStats: function() {
        return {};
    }
});

module.exports = BaseRenderTree;


},{}],151:[function(require,module,exports){
var BaseRenderTree = require("./base.js");
var GLRenderTarget = require("../base/rendertarget.js").GLRenderTarget;
var ForwardRenderPass = require("../render-passes/forward.js");
var BoxBlurPass= require("../render-passes/boxblur.js");
var VertexAttributePass = require("../render-passes/vertexattribute-pass.js");
var SSAOPass = require("../render-passes/ssao-pass.js");
var EVENT_TYPE = require("../../renderer/scene/constants.js").EVENT_TYPE;

/**
 *
 * @param {GLRenderInterface} renderInterface
 * @param {boolean} enableSSAO
 * @param {GLRenderTarget} target
 * @constructor
 */
var ForwardRenderTree = function (renderInterface, enableSSAO, target) {
    BaseRenderTree.call(this, renderInterface);
    var scene = renderInterface.scene;
    this._enableSSAO = enableSSAO;
    this.mainPass = null;
    this.target = target || renderInterface.context.canvasTarget;
    this.createMainPass();
};

XML3D.createClass(ForwardRenderTree, BaseRenderTree);

XML3D.extend(ForwardRenderTree.prototype, {

    createMainPass: function () {
        if (this._enableSSAO) {
            var positionPass = this.createVertexAttributePass("render-position");
            var normalPass = this.createVertexAttributePass("render-normal");
            var ssaoPass = this.createSSAOPass(positionPass.output, normalPass.output);
            ssaoPass.addPrePass(positionPass);
            ssaoPass.addPrePass(normalPass);
            var blurPass = this.createBlurPass(ssaoPass.output);
            blurPass.addPrePass(ssaoPass);
            this._blurPass = blurPass;
            this._ssaoPass = ssaoPass;
            this._positionPass = positionPass;
            this._normalPass = normalPass;
            this.mainPass = new ForwardRenderPass(this.renderInterface, this.target, {
                inputs: {
                    ssaoMap: blurPass.output
                }
            });
            this.mainPass.addPrePass(blurPass);
        } else {
            this.mainPass = new ForwardRenderPass(this.renderInterface, this.target);
        }
        this.mainRenderPass = this.mainPass;
    },

    createVertexAttributePass: function (programName) {
        var context = this.renderInterface.context;
        var buffer = new GLRenderTarget(context, {
            width: context.canvasTarget.width,
            height: context.canvasTarget.height,
            colorFormat: context.gl.RGBA,
            colorType: context.gl.FLOAT,
            depthFormat: context.gl.DEPTH_COMPONENT16,
            stencilFormat: null,
            depthAsRenderbuffer: true
        });
        return new VertexAttributePass(this.renderInterface, buffer, {
            programName: programName
        });
    },

    createSSAOPass: function (positionBuffer, normalBuffer) {
        var context = this.renderInterface.context;
        var ssaoBuffer = new GLRenderTarget(context, {
            width: context.canvasTarget.width,
            height: context.canvasTarget.height,
            colorFormat: context.gl.RGBA,
            depthFormat: context.gl.DEPTH_COMPONENT16,
            stencilFormat: null,
            depthAsRenderbuffer: true
        });

        return new SSAOPass(this.renderInterface, ssaoBuffer, {
            inputs: {
                positionBuffer: positionBuffer, normalBuffer: normalBuffer
            }
        });
    },

    createBlurPass: function (inputBuffer) {
        var context = this.renderInterface.context;
        var blurBuffer = new GLRenderTarget(context, {
            width: inputBuffer.width,
            height: inputBuffer.height,
            colorFormat: context.gl.RGBA,
            depthFormat: context.gl.DEPTH_COMPONENT16,
            stencilFormat: null,
            depthAsRenderbuffer: true
        });

        return new BoxBlurPass(this.renderInterface, blurBuffer, {
            inputs: {
                buffer: inputBuffer
            }
        });
    },

    render: function (scene) {
        if (this._enableSSAO) {
            this._positionPass.setProcessed(false);
            this._normalPass.setProcessed(false);
            this._ssaoPass.setProcessed(false);
            this._blurPass.setProcessed(false);
        }
        this.mainRenderPass.setProcessed(false);
        BaseRenderTree.prototype.render.call(this, scene);
    },

    getRenderStats: function () {
        return this.mainPass.getRenderStats();
    }
});

module.exports = ForwardRenderTree;


},{"../../renderer/scene/constants.js":98,"../base/rendertarget.js":116,"../render-passes/boxblur.js":140,"../render-passes/forward.js":141,"../render-passes/ssao-pass.js":148,"../render-passes/vertexattribute-pass.js":149,"./base.js":150}],152:[function(require,module,exports){
var GLContext = require("./base/context.js");
var GLScene = require("./scene/glscene.js");
var GLScaledRenderTarget = require("./base/rendertarget.js").GLScaledRenderTarget;
var DataChangeListener = require("../renderer/tools/datachangelistener.js");
var RenderInterface = require("./render-interface.js");
var PickObjectRenderPass= require("./render-passes/pick-object.js");
var PickPositionRenderPass = require("./render-passes/pick-position.js");
var PickNormalRenderPass = require("./render-passes/pick-normal.js");
var ForwardRenderTree = require("./render-trees/forward.js");
var GLU = require("../../contrib/glu.js");
var Options = require("../../utils/options.js");
var MAX_PICK_BUFFER_DIMENSION = 512;
var vec3 = require("gl-matrix").vec3;
var quat = require("gl-matrix").quat;
var mat4 = require("gl-matrix").mat4;

var OPTION_SSAO = "renderer-ssao";
var FLAGS = {};
FLAGS[OPTION_SSAO] = {defaultValue: false, recompileOnChange: true};
for (var flag in FLAGS) {
    Options.register(flag, FLAGS[flag].defaultValue);
}

/**
 * Convert the given y-coordinate on the canvas to a y-coordinate appropriate in
 * the GL context. The y-coordinate gets turned upside-down. The lowest possible
 * canvas coordinate is 0, so we need to subtract 1 from the height, too.
 *
 * @param {HTMLCanvasElement} canvas
 * @param {number} y
 * @return {number} the converted y-coordinate
 */
var canvasToGlY = function (canvas, y) {
    return canvas.height - y - 1;
};
/**
 * @interface
 */
var IRenderer = function () {
};

IRenderer.prototype.renderToCanvas = function () {
};
IRenderer.prototype.handleResizeEvent = function (width, height) {
};
IRenderer.prototype.requestRedraw = function (reason) {
};
IRenderer.prototype.needsRedraw = function () {
};
IRenderer.prototype.getWorldSpaceNormalByPoint = function (obj, x, y) {
};
IRenderer.prototype.getWorldSpacePositionByPoint = function (obj, x, y) {
};
IRenderer.prototype.getRenderObjectFromPickingBuffer = function (x, y) {
};
IRenderer.prototype.generateRay = function (x, y) {
};
IRenderer.prototype.dispose = function () {
};

/**
 * @param {Element} element The <xml3d> Element
 * @implements {IRenderer}
 * @constructor
 */
var GLRenderer = function (element, canvasHandler) {

    this._canvasHandler = canvasHandler;
    var canvas = this._canvasHandler.getCanvas();
    this.context = new GLContext(canvas, this._canvasHandler.id);
    this.scene = new GLScene(this.context);

    var factory = XML3D.xml3dFormatHandler.getFactory("scene", this._canvasHandler.id);
    factory.setScene(this.scene);
    factory.setRenderer(this);

    var xml3dAdapter = factory.getAdapter(element);
    xml3dAdapter.traverse(function () {
    });

    /** @type {RenderObject} */
    this.pickedObject = null;

    this.needsDraw = true;
    this.needsPickingDraw = true;
    this.context.requestRedraw = this.requestRedraw.bind(this);

    //Currently used as a helper to calculate view and projection matrices for ray casting, since the scene
    //must be rendered from the point of view of the ray
    this.rayCamera = this.scene.createRenderView();

    this.initGL();
    this.changeListener = new DataChangeListener(this);

    this.renderInterface = this.createRenderInterface();

    this.handleResizeEvent(canvas.clientWidth, canvas.clientHeight);

    Options.addObserver(this.onFlagsChange.bind(this));
};

// Just to satisfy jslint
GLRenderer.prototype.generateRay = function () {
};

XML3D.extend(GLRenderer.prototype, {
    initGL: function () {
        var gl = this.context.gl;

        gl.clearColor(0, 0, 0, 0);
        gl.clearDepth(1);
        gl.clearStencil(0);

        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);

        gl.frontFace(gl.CCW);
        gl.cullFace(gl.BACK);
        gl.disable(gl.CULL_FACE);

        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.disable(gl.BLEND);

        gl.viewport(0, 0, this.width, this.height);

        gl.pixelStorei(gl.PACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.BROWSER_DEFAULT_WEBGL);

    },

    handleResizeEvent: function (width, height) {
        if (width <= 0 || height <= 0) {
            XML3D.debug.logWarning("xml3d element has invalid width or height! Ensure you're not using 'display: none' and that width and height are greater than 0.");
            width = 800;
            height = 600;
        }
        this.width = width;
        this.height = height;
        this.context.handleResizeEvent(width, height);
        this.createDefaultTree();
        this.scene.handleResizeEvent(width, height);
        this.needsDraw = this.needsPickingDraw = true;
    },

    createDefaultTree: function () {
        var tree = new ForwardRenderTree(this.renderInterface, Options.getValue(OPTION_SSAO));
        this.renderInterface.setRenderTree(tree);

        var pickTarget = new GLScaledRenderTarget(this.context, MAX_PICK_BUFFER_DIMENSION, {
            width: this.context.canvasTarget.width,
            height: this.context.canvasTarget.height,
            colorFormat: this.context.gl.RGBA,
            depthFormat: this.context.gl.DEPTH_COMPONENT16,
            stencilFormat: null,
            depthAsRenderbuffer: true
        });
        this.pickObjectPass = new PickObjectRenderPass(this.renderInterface, pickTarget);
        this.pickPositionPass = new PickPositionRenderPass(this.renderInterface, pickTarget);
        this.pickNormalPass = new PickNormalRenderPass(this.renderInterface, pickTarget);
    },

    createRenderInterface: function () {
        return new RenderInterface(this.context, this.scene);
    },

    requestRedraw: function (reason) {
        XML3D.debug.logDebug("Request redraw because:", reason);
        this.needsDraw = true;
        this.needsPickingDraw = true;
    },

    getWorldSpaceNormalByPoint: function (x, y, object) {
        var obj = object || this.pickedObject;
        if (!obj)
            return null;
        y = canvasToGlY(this._canvasHandler.getCanvas(), y);
        this.pickNormalPass.render(obj);
        this.needsPickingDraw = true;
        return this.pickNormalPass.readNormalFromPickingBuffer(x, y);
    },

    getWorldSpacePositionByPoint: function (x, y, object) {
        var obj = object || this.pickedObject;
        if (!obj)
            return null;
        y = canvasToGlY(this._canvasHandler.getCanvas(), y);
        this.pickPositionPass.render(obj);
        this.needsPickingDraw = true;
        return this.pickPositionPass.readPositionFromPickingBuffer(x, y);
    },

    getRenderObjectByRay: function (xml3dRay, viewMat, projMat) {
        var intersectedObjects = this.scene.findRayIntersections(xml3dRay);
        this.pickObjectPass.render(intersectedObjects, viewMat, projMat);
        //Target the middle of the buffer
        var x = Math.floor(this.pickObjectPass.output.getWidth() / 2 / this.pickObjectPass.output.getScale());
        var y = Math.floor(this.pickObjectPass.output.getHeight() / 2 / this.pickObjectPass.output.getScale());
        return this.pickObjectPass.getRenderObjectFromPickingBuffer(x, y, intersectedObjects);

    },

    getWorldSpaceNormalByRay: function (ray, intersectedObject, viewMat, projMat) {
        if (!intersectedObject)
            return null;
        this.pickNormalPass.render(intersectedObject, viewMat, projMat);
        var x = Math.floor(this.pickNormalPass.output.getWidth() / 2 / this.pickNormalPass.output.getScale());
        var y = Math.floor(this.pickNormalPass.output.getHeight() / 2 / this.pickNormalPass.output.getScale());
        return this.pickNormalPass.readNormalFromPickingBuffer(x, y);

    }, getWorldSpacePositionByRay: function (ray, intersectedObject, viewMat, projMat) {
        if (!intersectedObject)
            return null;
        this.pickPositionPass.render(intersectedObject, viewMat, projMat);
        var x = Math.floor(this.pickPositionPass.output.getWidth() / 2 / this.pickPositionPass.output.getScale());
        var y = Math.floor(this.pickPositionPass.output.getHeight() / 2 / this.pickPositionPass.output.getScale());
        return this.pickPositionPass.readPositionFromPickingBuffer(x, y);

    },

    calculateMatricesForRay: function (ray, viewMat, projMat) {
        mat4.multiply(viewMat, mat4.fromTranslation(viewMat, ray.origin.data), this.calculateOrientationForRayDirection(ray));
        this.rayCamera.setLocalMatrix(viewMat);
        this.rayCamera.getWorldToViewMatrix(viewMat);
        var aspect = this.pickObjectPass.output.getWidth() / this.pickObjectPass.output.getHeight();
        this.rayCamera.getProjectionMatrix(projMat, aspect);
    },

    calculateOrientationForRayDirection: (function () {
        var tmpX = vec3.create();
        var tmpY = vec3.create();
        var tmpZ = vec3.create();
        var up = vec3.create();
        var q = quat.create();
        var m = mat4.create();

        return function (ray) {
            vec3.set(up, 0, 1, 0);
            vec3.cross(tmpX, ray.direction.data, up);
            if (!vec3.length(tmpX)) {
                vec3.set(tmpX, 1, 0, 0);
            }
            vec3.cross(tmpY, tmpX, ray.direction.data);
            vec3.negate(tmpZ, ray.direction.data);

            XML3D.math.quat.setFromBasis(q, tmpX, tmpY, tmpZ);
            mat4.fromRotationTranslation(m, q, [0,0,0]);
            return m;
        }
    })(),

    needsRedraw: function () {
        return this.needsDraw;
    },

    renderToCanvas: function () {
        this.prepareRendering();
        this.renderInterface.getRenderTree().render(this.scene);
        var stats = this.renderInterface.getRenderTree().getRenderStats();
        this.needsDraw = false; //Set this late, because redraw might be triggered during rendering (TODO: avoid that!)
        XML3D.debug.logDebug("Rendered to Canvas");
        return stats;
    },

    getRenderObjectFromPickingBuffer: function (x, y) {
        y = canvasToGlY(this._canvasHandler.getCanvas(), y);
        var worldToViewMatrix = mat4.create();
        if (this.needsPickingDraw) {
            this.needsPickingDraw = false;
            this.prepareRendering();
            this.scene.updateReadyObjectsFromActiveView(this.pickObjectPass.output.getWidth() / this.pickObjectPass.output.getHeight());
            this.scene.getActiveView().getWorldToViewMatrix(worldToViewMatrix);
            this.pickObjectPass.render(this.scene.ready, worldToViewMatrix);
            XML3D.debug.logDebug("Rendered Picking Buffer");
        }
        this.pickedObject = this.pickObjectPass.getRenderObjectFromPickingBuffer(x, y, this.scene.ready);
        return this.pickedObject;
    },

    prepareRendering: function () {
        this.scene.update();
    },

    /**
     * Uses gluUnProject() to transform the 2D screen point to a 3D ray.
     * Not tested!!
     *
     * @param {number} canvasX
     * @param {number} canvasY
     */
    generateRay: (function () {

        var c_viewMatrix = mat4.create();
        var c_projectionMatrix = mat4.create();

        return function (canvasX, canvasY) {

            var glY = canvasToGlY(this._canvasHandler.getCanvas(), canvasY);

            // setup input to unproject
            var viewport = new Float32Array(4);
            viewport[0] = 0;
            viewport[1] = 0;
            viewport[2] = this.width;
            viewport[3] = this.height;

            // get view and projection matrix arrays
            var view = this.scene.getActiveView();
            view.getWorldToViewMatrix(c_viewMatrix);
            view.getProjectionMatrix(c_projectionMatrix, viewport[2] / viewport[3]);

            var ray = new XML3D.Ray();

            var nearHit = new Float32Array(3);
            var farHit = new Float32Array(3);

            // do unprojections
            if (false === GLU.unProject(canvasX, glY, 0, c_viewMatrix, c_projectionMatrix, viewport, nearHit)) {
                return ray;
            }

            if (false === GLU.unProject(canvasX, glY, 1, c_viewMatrix, c_projectionMatrix, viewport, farHit)) {
                return ray;
            }

            // calculate ray
            mat4.invert(c_viewMatrix, c_viewMatrix);
            ray.origin = vec3.fromValues(c_viewMatrix[12], c_viewMatrix[13], c_viewMatrix[14]);
            ray.direction = vec3.fromValues(farHit[0] - nearHit[0], farHit[1] - nearHit[1], farHit[2] - nearHit[2]);

            return ray;
        }
    }()),

    dispose: function () {
        this.scene.clear();
    },

    getRenderInterface: function () {
        return this.renderInterface;
    },

    onFlagsChange: function (key) {
        if (key == OPTION_SSAO) {
            this.scene.shaderFactory.setShaderRecompile();
            this.createDefaultTree();
        }
        this.requestRedraw("global option changed");
    }
});

module.exports = GLRenderer;

},{"../../contrib/glu.js":50,"../../utils/options.js":183,"../renderer/tools/datachangelistener.js":108,"./base/context.js":112,"./base/rendertarget.js":116,"./render-interface.js":138,"./render-passes/pick-normal.js":143,"./render-passes/pick-object.js":144,"./render-passes/pick-position.js":145,"./render-trees/forward.js":151,"./scene/glscene.js":155,"gl-matrix":1}],153:[function(require,module,exports){
var XflowMesh = require("../xflow/xflow-mesh.js");

/**
 * @constructor
 */
var DrawableFactory = function () {};

XML3D.extend(DrawableFactory.prototype, {
    createDrawable: function (obj, context) {
        XML3D.debug.logDebug("DrawableFactory::createDrawable", obj);
        try {
            var result = new XflowMesh(context, obj.configuration, {boundingBoxChanged: obj.setObjectSpaceBoundingBox.bind(obj)});
            obj.mesh = result.getMesh();
            return result;
        } catch (e) {
            XML3D.debug.logError(e, obj.node);
            return null;
        }
    }
});

module.exports = DrawableFactory;



},{"../xflow/xflow-mesh.js":160}],154:[function(require,module,exports){
var lightModels = {
    point: {
        parameters: [ "pointLightPosition", "pointLightAttenuation", "pointLightIntensity", "pointLightOn", "pointLightCastShadow", "pointLightMatrix", "pointLightShadowBias", "pointLightNearFar", "pointLightShadowMap"]
    },
    directional: {
        parameters: ["directionalLightDirection", "directionalLightIntensity", "directionalLightOn", "directionalLightCastShadow", "directionalLightMatrix", "directionalLightShadowBias", "directionalLightShadowMap"]
    },
    spot: {
        parameters: ["spotLightAttenuation", "spotLightPosition", "spotLightIntensity", "spotLightDirection", "spotLightOn", "spotLightSoftness", "spotLightCosCutoffAngle", "spotLightCosSoftCutoffAngle", "spotLightCastShadow", "spotLightMatrix", "spotLightShadowBias", "spotLightShadowMap"]
    }
};

var ALL_PARAMETERS = lightModels.point.parameters.concat(lightModels.directional.parameters).concat(lightModels.spot.parameters);

module.exports = {
    ALL_PARAMETERS: ALL_PARAMETERS
};

},{}],155:[function(require,module,exports){
var Scene = require("./../../renderer/scene/scene.js");
var DrawableFactory = require("./drawable-factory.js");
var C = require("./../../renderer/scene/constants.js");
var FrustumTest = require("./../../renderer/tools/frustum.js").FrustumTest;
var ShaderComposerFactory = require("../materials/shadercomposerfactory.js");
var Options = require("../../../utils/options.js");
var ShadowMapService = require("../materials/shadowmap-service");
var mat4 = require("gl-matrix").mat4;

var OPTION_FRUSTUM_CULLING = "renderer-frustum-culling";
var OPTION_SHADEJS_EXTRACT_UNIFORMS = "shadejs-extractUniformExpressions";
var OPTION_SHADEJS_TRANSFORM_SPACES = "shadejs-transformSpaces";
var OPTION_SHADEJS_CACHE = "shadejs-cache";


// All the shader flags
var FLAGS = {};
FLAGS[OPTION_SHADEJS_EXTRACT_UNIFORMS] = {defaultValue: false, recompileOnChange: true};
FLAGS[OPTION_SHADEJS_TRANSFORM_SPACES] = {defaultValue: true, recompileOnChange: true};
FLAGS[OPTION_FRUSTUM_CULLING] = {defaultValue: true, recompileOnChange: false};
FLAGS[OPTION_SHADEJS_CACHE] = {defaultValue: true, recompileOnChange: false};

for (var flag in FLAGS) {
    Options.register(flag, FLAGS[flag].defaultValue);
}


/**
 *
 * @param {GLContext} context
 * @extends {Scene}
 * @constructor
 */
var GLScene = function (context) {
    Scene.call(this);
    this.context = context;
    this.shaderFactory = new ShaderComposerFactory(context);
    this.drawableFactory = new DrawableFactory();

    this.shadowMapService = new ShadowMapService(context, this);
    /**
     * @type {Array.<RenderObject>}
     */
    this.ready = [];
    this.queue = [];
    this.lightsNeedUpdate = true;
    this.systemUniforms = {};
    this.deferred = window['XML3D_DEFERRED'] || false;
    this.colorClosureSignatures = [];
    this.doFrustumCulling = !!Options.getValue(OPTION_FRUSTUM_CULLING);
    this.addListeners();
};

XML3D.createClass(GLScene, Scene);

function removeSafe(arr, obj) {
    var index = arr.indexOf(obj);
    if (index != -1) {
        arr.splice(index, 1);
        return true;
    }
    return false;
}

XML3D.extend(GLScene.prototype, {
    remove: function (obj) {
        removeSafe(this.queue, obj);
        removeSafe(this.ready, obj);
    },

    clear: function () {
        this.ready = [];
        this.queue = [];
        this.activeView.remove();
    },

    moveFromQueueToReady: function (obj) {
        if (removeSafe(this.queue, obj)) {
            this.ready.push(obj);
        }
    },

    moveFromReadyToQueue: function (obj) {
        if (removeSafe(this.ready, obj)) {
            this.queue.push(obj);
        }
    },

    update: function () {
        if (this.lightsNeedUpdate) {
            this.lightsNeedUpdate = false;
            this.updateLightParameters();
            this.lights.lightValueChanged();
        }
        this.updateObjectsForRendering();

        // Render shadow maps if necessary
        this.shadowMapService.updateForRendering();

        // Make sure that shaders are updates AFTER objects
        // Because unused shader closures are cleared on update
        this.updateShaders();
    }, updateLightParameters: function () {
        var parameters = this.systemUniforms;

        this.lights.fillGlobalParameters(parameters);
        this.shadowMapService.fillGlobalParameters(parameters);

        // Derived parameters that are implementation specific.
        // TODO: Put those to an appropriate place
        var spotLightCutoffAngle = parameters["spotLightCutoffAngle"];
        var spotLightSoftness = parameters["spotLightSoftness"];
        if(spotLightCutoffAngle) {
            // Map both parameters into cosinus space
            var spotLightCosSoftCutoffAngle = [];
            var spotLightCosCutoffAngle = [];
            for (var i = 0; i < spotLightCutoffAngle.length; i++) {
                spotLightCosCutoffAngle[i] = Math.cos(spotLightCutoffAngle[i]);
                spotLightCosSoftCutoffAngle[i] = Math.cos(spotLightCutoffAngle[i] * (1.0 - spotLightSoftness[i]));
            }
            parameters["spotLightCosCutoffAngle"] = spotLightCosCutoffAngle;
            parameters["spotLightCosSoftCutoffAngle"] = spotLightCosSoftCutoffAngle;
        }


    },

    updateSystemUniforms: function (names) {
        this.shaderFactory.updateSystemUniforms(names, this);
    },

    updateShaders: function () {
        this.shaderFactory.update(this);
    },

    updateObjectsForRendering: function () {
        this.forEach(function (obj) {
            obj.updateForRendering();
        });
    },

    forEach: function (func, that) {
        this.queue.slice().forEach(func, that);
        this.ready.slice().forEach(func, that);
    },

    updateReadyObjectsFromActiveView: (function () {
        var c_worldToViewMatrix = mat4.create();
        var c_viewToWorldMatrix = mat4.create();
        var c_projMat_tmp = mat4.create();
        var c_bbox = new XML3D.Box();
        var c_frustumTest = new FrustumTest();

        return function (aspectRatio) {
            var activeView = this.getActiveView(), readyObjects = this.ready, i, l, obj;

            // Update all MV matrices
            activeView.getWorldToViewMatrix(c_worldToViewMatrix);

            for (i = 0, l = readyObjects.length; i < l; i++) {
                obj = readyObjects[i];
                obj.updateModelViewMatrix(c_worldToViewMatrix);
                obj.updateModelMatrixN();
                obj.updateModelViewMatrixN();
            }
            this.updateBoundingBox();

            activeView.getProjectionMatrix(c_projMat_tmp, aspectRatio);
            activeView.getViewToWorldMatrix(c_viewToWorldMatrix);

            var frustum = activeView.getFrustum();
            var doFrustumCulling = this.doFrustumCulling && frustum;

            if(doFrustumCulling) {
                c_frustumTest.set(frustum, c_viewToWorldMatrix);
            }

            for (i = 0, l = readyObjects.length; i < l; i++) {
                obj = readyObjects[i];
                obj.updateModelViewProjectionMatrix(c_projMat_tmp);
                obj.getWorldSpaceBoundingBox(c_bbox);
                obj.inFrustum = doFrustumCulling ? c_frustumTest.isBoxVisible(c_bbox) : true;
            }
        }
    }()),
    updateReadyObjectsFromMatrices: function (worldToViewMatrix, projectionMatrix) {
        var readyObjects = this.ready;
        for (var i = 0, l = readyObjects.length; i < l; i++) {
            var obj = readyObjects[i];
            obj.updateModelViewMatrix(worldToViewMatrix);
            obj.updateModelMatrixN();
            obj.updateModelViewProjectionMatrix(projectionMatrix);
        }
    },
    addListeners: function () {
        this.on(C.EVENT_TYPE.SCENE_STRUCTURE_CHANGED, function (child, removed) {
            if (removed) {
                this.removeChildEvent(child);
            } else {
                this.addChildEvent(child);
            }
        });
        this.on(C.EVENT_TYPE.VIEW_CHANGED, function (/*newView*/) {
            this.context.requestRedraw("Active view changed.");
        });
        this.on(C.EVENT_TYPE.LIGHT_STRUCTURE_CHANGED, function (/*event*/) {
            this.lightsNeedUpdate = true;
            this.shaderFactory.setLightStructureDirty();
            this.context.requestRedraw("Light structure changed.");
        });
        this.on(C.EVENT_TYPE.LIGHT_VALUE_CHANGED, function (light) {
            this.lightsNeedUpdate = true;
            this.shaderFactory.setLightValueChanged();
            this.lights.lightValueChanged(light);
            this.context.requestRedraw("Light value changed.");
        });
         this.on(C.EVENT_TYPE.SCENE_SHAPE_CHANGED, function (/* event */) {
            // Need to update light frustum. Defer this until the next render phase
            // TODO(ksons) Only light frustum and shadow maps need update, not the whole scene
             this.lightsNeedUpdate = true;
        });

        Options.addObserver(this.onFlagsChange.bind(this));
    },

    addChildEvent: function (child) {
        if (child.type == C.NODE_TYPE.OBJECT) {
            this.queue.push(child);
            this.context.requestRedraw("Object was added to scene.");
        }
    },

    removeChildEvent: function (child) {
        if (child.type == C.NODE_TYPE.OBJECT) {
            this.remove(child);
            child.dispose();
            this.context.requestRedraw("Object was removed from scene.");
        }
    },


    createDrawable: function (obj) {
        return this.drawableFactory.createDrawable(obj, this.context);
    },

    requestRedraw: function (reason) {
        return this.context.requestRedraw(reason);
    },

    onFlagsChange: function (key, value) {
        if (FLAGS[key] && FLAGS[key].recompileOnChange)
            this.shaderFactory.setShaderRecompile();
        if (key == OPTION_FRUSTUM_CULLING) {
            this.doFrustumCulling = !!value;
        }
    }
});
module.exports = GLScene;


},{"../../../utils/options.js":183,"../materials/shadercomposerfactory.js":127,"../materials/shadowmap-service":128,"./../../renderer/scene/constants.js":98,"./../../renderer/scene/scene.js":107,"./../../renderer/tools/frustum.js":109,"./drawable-factory.js":153,"gl-matrix":1}],156:[function(require,module,exports){
var ShaderUtils = require("./shader-utils.js");
var ShaderDescriptor = require("../materials/urn/shader-descriptor.js");
var URNShaderClosure = require("../materials/urn/urnshaderclosure.js");

var ProgramFactory = function (context) {
    this.context = context;
    this.programs = {
        fallback: null, picking: {
            id: null, normal: null, position: null
        }
    }
};



XML3D.extend(ProgramFactory.prototype, {

    getProgramByName: function (name) {
        var scriptDescriptor = XML3D.materials.getScript(name);
        if (!scriptDescriptor || !scriptDescriptor.vertex) {
            XML3D.debug.logError("Unknown shader: ", name);
            return null;
        }
        var descriptor = new ShaderDescriptor();
        XML3D.extend(descriptor, scriptDescriptor);
        descriptor.fragment = ShaderUtils.addFragmentShaderHeader(descriptor.fragment);
        var shader = new URNShaderClosure(this.context, descriptor);
        shader.createSources({}, null, null);
        shader.compile();
        return shader;
    },

    getFallbackProgram: function () {
        if (!this.programs.fallback) {
            var descriptor = new ShaderDescriptor();
            XML3D.extend(descriptor, XML3D.materials.getScript("matte"));
            descriptor.fragment = ShaderUtils.addFragmentShaderHeader(descriptor.fragment);
            var shader = new URNShaderClosure(this.context, descriptor);
            shader.uniformCollection.envBase.diffuseColor = [1, 0, 0];
            shader.createSources({}, null, null);
            shader.compile();
            this.programs.fallback = shader;
            this.programs.fallback.bind();
            this.programs.fallback.setUniformVariables(["diffuseColor"], null, {envBase: {diffuseColor: [1, 0, 0]}});
            this.programs.fallback.unbind();
        }
        return this.programs.fallback;
    },

    getPickingObjectIdProgram: function () {
        var picking = this.programs.picking;
        if (!picking.id) {
            picking.id = this.getProgramByName("pickobjectid");
        }
        return picking.id;
    },

    getPickingPositionProgram: function () {
        var picking = this.programs.picking;
        if (!picking.position) {
            picking.position = this.getProgramByName("pickedposition");
        }
        return picking.position;
    },

    getPickingNormalProgram: function () {
        var picking = this.programs.picking;
        if (!picking.normal) {
            picking.normal = this.getProgramByName("pickedNormals");
        }
        return picking.normal;
    }

});

module.exports = ProgramFactory;


},{"../materials/urn/shader-descriptor.js":134,"../materials/urn/urnshaderclosure.js":135,"./shader-utils.js":157}],157:[function(require,module,exports){
var FRAGMENT_HEADER = ["#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "#else", "precision mediump float;", "#endif // GL_FRAGMENT_PRECISION_HIGH", "\n"].join("\n");

module.exports = {
    addFragmentShaderHeader: function (fragmentShaderSource) {
        return FRAGMENT_HEADER + fragmentShaderSource;
    }
};

},{}],158:[function(require,module,exports){
var SystemNotifier = {
    node: null,

    setNode: function (node) {
        this.node = node;
    },

    sendEvent: function (type, data) {
        if (this.node) {
            var event = document.createEvent('CustomEvent');
            data.systemtype = type;
            event.initCustomEvent('xml3dsystem', true, true, data);
            this.node.dispatchEvent(event);
        }
    }
};

module.exports = SystemNotifier;

},{}],159:[function(require,module,exports){
var XC = require("../../../xflow/interface/constants.js");
var GL = require("../constants.js");

function convertToJSArray(value) {
    var jsArray = [value.length];
    for (var i = 0; i < value.length; i++) {
        jsArray[i] = value[i];
    }
    return jsArray;
}

/**
 * @param {GLContext} context
 * @param {Uint32Array} data
 * @param {number} maxIndex
 */
var createElementBuffer = function (context, data, maxIndex) {
    var gl = context.gl;
    var bufferData = data;
    var glType = gl.UNSIGNED_INT;

    if (maxIndex < (1 << 8)) {
        glType = gl.UNSIGNED_BYTE;
        bufferData = new Uint8Array(data);
    } else if (maxIndex < (1 << 16)) {
        glType = gl.UNSIGNED_SHORT;
        bufferData = new Uint16Array(data);
    } else if (!context.extensions["OES_element_index_uint"]) {
        XML3D.debug.logError("Trying to use index data with indices larger than 65535, but this is not supported on your platform. Indexing errors will occur.");
        glType = gl.UNSIGNED_SHORT;
        bufferData = new Uint16Array(data);
    }

    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, bufferData, gl.STATIC_DRAW);
    buffer.bytesPerElement = bufferData.BYTES_PER_ELEMENT;
    buffer.length = data.length;
    buffer.glType = glType;
    return buffer;
};

/**
 * @param {GLContext} context
 * @param {Object} data
 */
var createArrayBuffer = function (context, data) {
    var gl = context.gl;

    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
    buffer.length = data.length;
    buffer.glType = getGLTypeFromArray(data);
    return buffer;
};

var getGLTypeFromArray = function (array) {
    if (array instanceof Int8Array)
        return GL.BYTE;
    if (array instanceof Uint8Array)
        return GL.UNSIGNED_BYTE;
    if (array instanceof Int16Array)
        return GL.SHORT;
    if (array instanceof Uint16Array)
        return GL.UNSIGNED_SHORT;
    if (array instanceof Int32Array)
        return GL.INT;
    if (array instanceof Uint32Array)
        return GL.UNSIGNED_INT;
    if (array instanceof Float32Array)
        return GL.FLOAT;
    return GL.FLOAT;
};


module.exports = {
    getGLUniformValueFromXflowDataEntry: function (xflowDataEntry, context) {
        var value;
        if (!xflowDataEntry)
            return null;
        if (xflowDataEntry.type == XC.DATA_TYPE.TEXTURE) {
            var webglData = context.getXflowEntryWebGlData(xflowDataEntry);
            var texture = webglData.texture || context.createTexture();
            if (webglData.changed)
                texture.updateFromTextureEntry(xflowDataEntry);

            webglData.texture = texture;
            webglData.changed = 0;
            value = [texture];
        } else if (xflowDataEntry.type == XC.DATA_TYPE.BOOL) {
            //TODO Can we get Xflow to return boolean arrays as normal JS arrays? WebGL doesn't accept Uint8Arrays here...
            //TODO Alternatively we could set boolean uniforms using uniform1fv together with Float32Arrays, which apparently works too
            value = convertToJSArray(xflowDataEntry.getValue());
        } else {
            value = xflowDataEntry.getValue();
        }

        return value;
    },

    getGLBufferFromXflowDataEntry: function (xflowDataEntry, context, elementBuffer) {
        var webglData = context.getXflowEntryWebGlData(xflowDataEntry);
        var buffer = webglData.buffer;
        var gl = context.gl;

        // Also write min and max values for elementBuffers
        if (webglData.changed && elementBuffer) {
            var indexValue = xflowDataEntry.getValue();
            var minIndex = 100000000, maxIndex = 0;
            var i = indexValue.length;
            while (i--) {
                minIndex = Math.min(minIndex, indexValue[i]);
                maxIndex = Math.max(maxIndex, indexValue[i]);
            }
            webglData.maxIndex = maxIndex;
            webglData.minIndex = minIndex;
        }

        //noinspection FallthroughInSwitchStatementJS
        switch (webglData.changed) {
            case XC.DATA_ENTRY_STATE.CHANGED_VALUE:
                if (elementBuffer) {
                    var bufferData = xflowDataEntry.getValue();
                    switch (buffer.glType) {
                        case gl.UNSIGNED_BYTE:
                            bufferData = new Uint8Array(bufferData);
                            break;
                        case gl.UNSIGNED_SHORT:
                            bufferData = new Uint16Array(bufferData);
                            break;
                        case gl.UNSIGNED_INT:
                            // This is what we expect anyway
                            break;
                        default:
                            XML3D.debug.logError("Unknown GL type for element buffer: ", buffer.glType);
                            return null;
                    }
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
                    gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, bufferData);
                } else {
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.bufferSubData(gl.ARRAY_BUFFER, 0, xflowDataEntry.getValue());
                }
                break;
            case XC.DATA_ENTRY_STATE.CHANGED_NEW:
            case XC.DATA_ENTRY_STATE.CHANGED_SIZE:
            case XC.DATA_ENTRY_STATE.CHANGED_SIZE_TYPE:
                if (elementBuffer) {
                    buffer = createElementBuffer(context, xflowDataEntry.getValue(), webglData.maxIndex);
                } else {
                    buffer = createArrayBuffer(context, xflowDataEntry.getValue());
                }
                buffer.tupleSize = xflowDataEntry.getTupleSize();
                webglData.buffer = buffer;
                break;
        }

        webglData.changed = 0;
        return buffer;
    },

    /**
     * Calculate bounding box from positions and optional indices
     * TODO: Remove FloatArray creation
     * @param {Float32Array} positions
     * @param {Int16Array|null} index
     * @returns {Float32Array}
     */
    calculateBoundingBox: function (positions, index) {
        var box = new XML3D.Box(), i;

        if (!positions || positions.length < 3)
            return box;

        var bbox = box.data;

        if (index) {
            var i0 = index[0] * 3;
            bbox[0] = positions[i0];
            bbox[1] = positions[i0 + 1];
            bbox[2] = positions[i0 + 2];
            bbox[3] = positions[i0];
            bbox[4] = positions[i0 + 1];
            bbox[5] = positions[i0 + 2];

            for (i = 1; i < index.length; i++) {
                var i1 = index[i] * 3;
                var p1 = positions[i1];
                var p2 = positions[i1 + 1];
                var p3 = positions[i1 + 2];

                if (p1 < bbox[0])
                    bbox[0] = p1;
                if (p2 < bbox[1])
                    bbox[1] = p2;
                if (p3 < bbox[2])
                    bbox[2] = p3;
                if (p1 > bbox[3])
                    bbox[3] = p1;
                if (p2 > bbox[4])
                    bbox[4] = p2;
                if (p3 > bbox[5])
                    bbox[5] = p3;
            }
        } else {
            bbox[0] = positions[0];
            bbox[1] = positions[1];
            bbox[2] = positions[2];
            bbox[3] = positions[0];
            bbox[4] = positions[1];
            bbox[5] = positions[2];

            for (i = 3; i < positions.length; i += 3) {
                if (positions[i] < bbox[0])
                    bbox[0] = positions[i];
                if (positions[i + 1] < bbox[1])
                    bbox[1] = positions[i + 1];
                if (positions[i + 2] < bbox[2])
                    bbox[2] = positions[i + 2];
                if (positions[i] > bbox[3])
                    bbox[3] = positions[i];
                if (positions[i + 1] > bbox[4])
                    bbox[4] = positions[i + 1];
                if (positions[i + 2] > bbox[5])
                    bbox[5] = positions[i + 2];
            }
        }
        return box;
    }
};

},{"../../../xflow/interface/constants.js":187,"../constants.js":120}],160:[function(require,module,exports){
var DrawableClosure = require("../../renderer/scene/drawableclosure.js");
var GLMesh = require("../base/mesh.js");
var XflowUtils = require("./utils.js");
var EVENT_TYPE = require("../../renderer/scene/constants.js").EVENT_TYPE;
var MaterialEvents = require("../materials/events.js");
var XC = require("../../../xflow/interface/constants.js");
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;
var assert = require("assert");
var GL = require("../constants.js");

var CHANGE_STATE = {
    NOTHING_CHANGED: 0,
    STRUCTURE_CHANGED: 1,
    TYPE_DATA_CHANGED: 2,
    VS_DATA_CHANGED: 4,
    TYPE_CHANGED: 2 + 1,
    VS_CHANGED: 4 + 1,
    SHADER_CHANGED: 32
};
var SHADER_CLOSURE_NEEDS_UPDATE = CHANGE_STATE.STRUCTURE_CHANGED | CHANGE_STATE.SHADER_CHANGED;

var READY_STATE = DrawableClosure.READY_STATE;


var MESH_PARAMETERS = {
    attributeData: {"position": XC.DATA_TYPE.FLOAT3},
    typeData: {
        "index": XC.DATA_TYPE.INT, "solid": XC.DATA_TYPE.BOOL, "vertexCount": XC.DATA_TYPE.INT, "type": XC.DATA_TYPE.STRING
    }, bboxFix: {
        "boundingBox": XC.DATA_TYPE.FLOAT3
    }, bboxCompute: {
        "position": XC.DATA_TYPE.FLOAT3
    }
};


/**
 * Class that synchronizes data changes from Xflow with a GLMesh instance
 *
 * @param {GLContext} context
 * @param {object} meshConfig
 * @param {object} opt
 * @extends {DrawableClosure}
 * @constructor
 */
var XflowMesh = function (context, meshConfig, opt) {
    DrawableClosure.call(this, context, DrawableClosure.TYPES.MESH);
    assert(meshConfig.data);
    assert(meshConfig.type);
    opt = opt || {};

    this.mesh = new GLMesh(context);

    /**
     * Data Node of the renderObject
     * @type {Xflow.DataNode}
     */
    this.dataNode = meshConfig.data;

    this.primitiveType = meshConfig.type;

    /**
     * Shader Composer that will provide ShaderClosure and Program
     * @type {AbstractShaderComposer}
     */
    this.shaderComposer = null;

    /**
     * Shader Closure used by this mesh
     * @type {AbstractShaderClosure}
     */
    this.shaderClosure = null;

    /**
     * Attributes required to create the GLMesh
     * @type {ComputeRequest}
     */
    this.typeRequest = null;

    /**
     * Are all attributes required by drawable available?
     * @type {boolean}
     */
    this.typeDataValid = true;

    /**
     * Attributes and uniforms values for the shader
     * @type {Xflow.Request}
     */
    this.objectShaderRequest = null;

    /**
     * Bitfield that records the changes reported by Xflow
     * @private
     * @type {number}
     */
    this.changeState = CHANGE_STATE.STRUCTURE_CHANGED;

    /**
     * Callback if bounding box has changed. Gets only called if
     * this.boundingBoxRequired is true.
     * @type {*|function(Float32Array)}
     */
    this.boundingBoxChanged = opt.boundingBoxChanged || function () {
    };

    this.initialize();
};

XML3D.createClass(XflowMesh, DrawableClosure, {
    initialize: function () {
        this.typeDataChanged(this.typeRequest, XC.RESULT_STATE.CHANGED_STRUCTURE);
        this.shaderChanged();
    },

    setShaderComposer: function (shaderComposer) {
        if (!this.bindedShaderChanged) this.bindedShaderChanged = this.shaderChanged.bind(this);

        if (this.shaderComposer)
            this.shaderComposer.removeListener(MaterialEvents.MATERIAL_STRUCTURE_CHANGED, this.bindedShaderChanged);

        this.shaderComposer = shaderComposer;
        if (this.shaderComposer)
            this.shaderComposer.on(MaterialEvents.MATERIAL_STRUCTURE_CHANGED, this.bindedShaderChanged);

        this.changeState |= CHANGE_STATE.SHADER_CHANGED;
    },

    update: function (scene) {
        if (this.changeState === CHANGE_STATE.NOTHING_CHANGED) {
            return;
        }
        XML3D.debug.logDebug("Update mesh closure", this.changeState);

        var oldValid = !!this.shaderClosure && this.typeDataValid, someError = null, typeDataResolved = false;

        try {
            if (this.changeState & SHADER_CLOSURE_NEEDS_UPDATE) {
                this.mesh.clear();
            }

            if (this.changeState & CHANGE_STATE.TYPE_CHANGED) {
                this.updateTypeData();
            }

            typeDataResolved = true;

            if (this.changeState & (SHADER_CLOSURE_NEEDS_UPDATE | CHANGE_STATE.TYPE_CHANGED)) {
                this.updateIndexBuffer();
            }

            if (this.changeState & SHADER_CLOSURE_NEEDS_UPDATE) {
                this.updateObjectShaderRequest();
                this.updateShaderClosure(scene);
                this.updateObjectShaderData();
            } else if (this.changeState & CHANGE_STATE.VS_CHANGED) {
                this.updateObjectShaderData();
            }

            if (this.dataNode.isSubtreeLoading()) {
                this.shaderClosure = null;
                this.typeDataValid = false;
            }
        } catch (e) {
            someError = e;
            if (!typeDataResolved)
                this.typeDataValid = false; else
                this.shaderClosure = null;
        }


        var newValid = !!this.shaderClosure && this.typeDataValid;

        if (oldValid != newValid) {
            this.emit(EVENT_TYPE.DRAWABLE_STATE_CHANGED,
                newValid ? READY_STATE.COMPLETE : READY_STATE.INCOMPLETE,
                oldValid ? READY_STATE.COMPLETE : READY_STATE.INCOMPLETE
            );
        }
        this.changeState = CHANGE_STATE.NOTHING_CHANGED;

        if (someError) throw someError;
    },

    calculateBoundingBox: (function () {
        var c_empty = new XML3D.Box();

        return function () {
            // compute bounding box from positions and indices, if present
            var dataResult = this.typeRequest.getResult();
            var boundingBoxEntry = dataResult.getOutputData("boundingBox");
            if (boundingBoxEntry) {
                this.boundingBoxChanged(XflowUtils.calculateBoundingBox(boundingBoxEntry.getValue(), null));
                return;
            }
            var positionEntry = dataResult.getOutputData("position");
            if (!positionEntry) {
                this.boundingBoxChanged(c_empty);
                return;
            }
            var indexEntry = dataResult.getOutputData("index");
            this.boundingBoxChanged(XflowUtils.calculateBoundingBox(positionEntry.getValue(), indexEntry ? indexEntry.getValue() : null));
        }
    }()), /**
     *
     * @param {ComputeRequest} request
     * @param {XC.RESULT_STATE} state
     */
    typeDataChanged: function (request, state) {
        this.changeState |= state == XC.RESULT_STATE.CHANGED_STRUCTURE ? CHANGE_STATE.STRUCTURE_CHANGED : CHANGE_STATE.TYPE_DATA_CHANGED;
        this.emit(EVENT_TYPE.SCENE_SHAPE_CHANGED);
        this.context.requestRedraw("Mesh Type Data Change");
        XML3D.debug.logDebug("XflowMesh: Type data changed", request, state, this.changeState);
    },

    getMesh: function () {
        return this.mesh;
    },

    updateObjectShaderRequest: function () {
        if (this.objectShaderRequest) this.objectShaderRequest.clear();
        this.objectShaderRequest = null;
        if (this.dataNode.isSubtreeLoading())
            return;

        this.objectShaderRequest = this.shaderComposer.createObjectDataRequest(this.dataNode, this.shaderInputDataChanged.bind(this));
    },

    updateShaderClosure: function (scene) {
        this.shaderClosure = null;
        if (!this.dataNode.isSubtreeLoading() && !this.dataNode.getOutputChannelInfo("position")) {
            throw new Error("Mesh does not have 'position' attribute.");
            //XML3D.debug.logError("Mesh does not have 'position' attribute.", this.mesh, this.getMeshType());
        } else if (!this.dataNode.isSubtreeLoading()) {
            var objectShaderResult = this.objectShaderRequest.getResult();
            if (!objectShaderResult.loading)
                this.shaderClosure = this.shaderComposer.getShaderClosure(scene, this.objectShaderRequest);
        }
    },

    updateIndexBuffer: function () {
        // Add Index buffer, if available
        var dataResult = this.typeRequest.getResult();
        var entry = dataResult.getOutputData("index");
        if (entry && entry.getValue())
            this.handleBuffer("index", entry, true);
    },

    updateObjectShaderData: function () {
        if (!this.shaderClosure) {
            return; // if only the data has changed, it can't get valid after update
        }

        if (!this.bindedHandleBuffer) this.bindedHandleBuffer = this.handleBuffer.bind(this);
        if (!this.bindedHandleUniform) this.bindedHandleUniform = this.handleUniform.bind(this);

        this.shaderComposer.distributeObjectShaderData(this.objectShaderRequest, this.bindedHandleBuffer, this.bindedHandleUniform);

        if (!this.mesh.isReadyToRender()) {
            throw new Error("Mesh has empty vertex attributes.");
        }
    },

    updateTypeData: function () {
        if (!this.typeDataValid && !(this.changeState & CHANGE_STATE.STRUCTURE_CHANGED)) {
            return; // only if structure has changed, it can't get valid after update
        }
        // Be pessimistic. We set this to true if mesh passes all checks;
        this.typeDataValid = false;

        this.updateTypeRequest();

        this.calculateBoundingBox();

        var dataResult = this.typeRequest.getResult();

        var entry = dataResult.getOutputData("vertexCount");
        this.mesh.setVertexCount(entry && entry.getValue() ? entry.getValue() : null);

        var primitiveType = this.primitiveType;
        if(primitiveType == "derived") {
            entry = dataResult.getOutputData("type");
            primitiveType =  entry ? entry.getValue()[0] : null;
        }

        var glType = getGLTypeFromString(primitiveType);
        if(glType == undefined) {
            if (this.primitiveType == "derived") {
                if (this.dataNode.isSubtreeLoading()) {
                    return; // There might be a type coming
                }
                if (primitiveType == null) {
                    throw new Error("Could not derive primitive type");
                }
            }
            throw new Error("Unknown primitive type: " + primitiveType);
        }
        this.mesh.setPrimitiveType(glType);
        this.typeDataValid = true;
    },

    /**
     * @param {string} name
     * @param {Xflow.BufferEntry} xflowDataEntry
     * @param {boolean=} isIndex
     */
    handleBuffer: function (name, xflowDataEntry, isIndex) {
        isIndex = isIndex || false;
        var mesh = this.mesh;

        if (name == "position" && !xflowDataEntry) {
            throw new Error("'position' attribute of mesh is empty.");
        }

        if (!xflowDataEntry) {
            this.mesh.removeBuffer(name);
            return;
        }

        if (xflowDataEntry.type == XC.DATA_TYPE.TEXTURE) {
            XML3D.debug.logError("Texture as mesh parameter is not yet supported");
            return;
        }

        var buffer = XflowUtils.getGLBufferFromXflowDataEntry(xflowDataEntry, this.context, name == "index");
        if (isIndex) {
            this.updateIndexRange(xflowDataEntry);
        } else {
            this.mesh.checkBufferCompatible(name, xflowDataEntry);
        }
        // In every case, set the buffer, because other meshes might have already
        // performed one or more of the tasks above
        mesh.setBuffer(name, buffer);
    },

    updateIndexRange: function (xflowDataEntry) {
        var webglData = this.context.getXflowEntryWebGlData(xflowDataEntry);
        this.mesh.setIndexRange(webglData.minIndex, webglData.maxIndex);
    },

    handleUniform: function (name, xflowDataEntry) {
        var value = XflowUtils.getGLUniformValueFromXflowDataEntry(xflowDataEntry, this.context);
        if (name === 'opacity') {
            this.emit(EVENT_TYPE.OPACITY_STATE_CHANGED, this.mesh.getUniformOverride(name), value);
        }
        this.mesh.setUniformOverride(name, value);
    },

    updateTypeRequest: function () {
        var requestNames = this.getTypeRequestNames(MESH_PARAMETERS);

        if (!this.typeRequest || this.typeRequest.filter != requestNames) {
            if (this.typeRequest) this.typeRequest.clear();
            this.typeRequest = new ComputeRequest(this.dataNode, requestNames, this.typeDataChanged.bind(this));
        }
    },

    getTypeRequestNames: function (meshConfig) {
        var requestNames = [];
        requestNames.push.apply(requestNames, Object.keys(meshConfig.typeData));
        // We always request fixed bounding box values: that way we can react, when those values get available
        requestNames.push.apply(requestNames, Object.keys(meshConfig.bboxFix));
        var computeBBox = !this.checkXflowTypes(this.dataNode, meshConfig.bboxFix);

        if (computeBBox) {
            if (!this.checkXflowTypes(this.dataNode, meshConfig.bboxCompute)) {
                this.typeDataValid = false;
            }
            requestNames.push.apply(requestNames, Object.keys(meshConfig.bboxCompute));
        }
        return requestNames;
    },

    checkXflowTypes: function (dataNode, requirements) {
        for (var name in requirements) {
            var info = dataNode.getOutputChannelInfo(name);
            if (!info) return false;
            if (info.type != requirements[name])
                return false;
        }
        return true;
    },

    /**
     * @param {ComputeRequest} request
     * @param {XC.RESULT_STATE} state
     */
    shaderInputDataChanged: function (request, state) {
        this.changeState |= state != XC.RESULT_STATE.CHANGED_DATA_VALUE ? CHANGE_STATE.STRUCTURE_CHANGED : CHANGE_STATE.VS_DATA_CHANGED;
        // TODO: We don't know if the change of data only influences the surface shading or the actual mesh shape
        this.emit(EVENT_TYPE.SCENE_SHAPE_CHANGED);
        this.context.requestRedraw("Mesh Attribute Data Changed");
        XML3D.debug.logDebug("XflowMesh: Attribute data changed", request, state, this.changeState);
    },

    shaderChanged: function () {
        this.changeState |= CHANGE_STATE.SHADER_CHANGED;
    },

    getProgram: function () {
        return this.shaderClosure;
    },

    destroy: function() {
        this.mesh && this.mesh.clear();
        this.objectShaderRequest && this.objectShaderRequest.clear();
        this.typeRequest && this.typeRequest.clear();
        this.setShaderComposer(null);
        delete this.dataNode;
    }

});

/**
 * @param {string} typeName
 */
var getGLTypeFromString = function (typeName) {
    if (typeName && typeName.toLowerCase)
        typeName = typeName.toLowerCase();
    switch (typeName) {
        case "triangles":
            return GL.TRIANGLES;
        case "tristrips":
            return GL.TRIANGLE_STRIP;
        case "points":
            return GL.POINTS;
        case "lines":
            return GL.LINES;
        case "linestrips":
            return GL.LINE_STRIP;
        default:
            return undefined;
    }
};

module.exports = XflowMesh;


},{"../../../xflow/interface/constants.js":187,"../../../xflow/interface/request.js":190,"../../renderer/scene/constants.js":98,"../../renderer/scene/drawableclosure.js":99,"../base/mesh.js":114,"../constants.js":120,"../materials/events.js":123,"./utils.js":159,"assert":11}],161:[function(require,module,exports){

var AdapterHandle = require("../base/adapterhandle.js");
var URI = require("../utils/uri.js").URI;
var URIResolver = require("../utils/uri.js").URIResolver;
var Options = require("../utils/options.js");
var ResourceCounter = require("./counter.js");
var getDocumentCache = require("./fetcher.js").getDocumentCache;

var OPTION_RESOURCE_CORS = "resource-crossorigin-attribute";
Options.register(OPTION_RESOURCE_CORS, "anonymous");

// Proxy adapters that provide the connections between elements (eg. "src" -> "id")
var c_cachedAdapterHandles = {};

var Resource = {};

/**
 * This function is called when an id of an element changes or if that element is now reachable
 * or not reachable anymore. It will update all AdapterHandles connected to the element.
 * @param {Element} node Element of which id has changed
 * @param {string} previousId Previous id of element
 * @param {string} newId New id of element
 */
Resource.notifyNodeIdChange = function(node, previousId, newId) {
    var uri = new URI();
    if (previousId) {
        uri.fragment = previousId;
        clearHandles(uri);
    }
    if (newId) {
        uri.fragment = newId;
        updateMissingHandles(uri, XML3D.xml3dFormatHandler, node);
    }
};

/**
 * This function is called to notify an AdapterHandler about a change (can be triggered through adapters)
 * Note that this function only works with nodes inside window.document
 * @param {Element} element Element of AdapterHandler. Must be from window.document
 * @param {Object} adapterType Type/Aspect of AdapterHandler (e.g. XML3D.data or XML3D.webgl)
 * @param {number} canvasId GLCanvasHandler id of AdapterHandler, 0 if not depending on GLCanvasHandler
 * @param {number} type Type of Notification. Usually Events.ADAPTER_HANDLE_CHANGED
 */
Resource.notifyNodeAdapterChange = function(element, adapterType, canvasId, type) {
    canvasId = canvasId || 0;
    var uri = "#" + element.id;
    if (c_cachedAdapterHandles[uri] && c_cachedAdapterHandles[uri][adapterType] &&
        c_cachedAdapterHandles[uri][adapterType][canvasId]) {
        c_cachedAdapterHandles[uri][adapterType][canvasId].notifyListeners(type);
    }
};

/**
 * Remove the adapter of all AdapterHandles corresponding to the given URL.
 * This is called e.g. when a node is remove from the document, or an id changes
 * @param {URI} uri The URL of all AdapterHandles to be cleared.
 */
function clearHandles(uri) {
    var url = uri.toString();
    for (var adapterType in c_cachedAdapterHandles[url]) {
        for (var canvasId in c_cachedAdapterHandles[url][adapterType]) {
            var handle = c_cachedAdapterHandles[url][adapterType][canvasId];
            if (handle.hasAdapter()) {
                handle.setAdapter(null, AdapterHandle.STATUS.NOT_FOUND);
            }
        }
    }
}

/**
 * Gets (or creates) the requested adapter for the given element and canvasId.
 *
 * @param {HTMLElement} node - The element the adapter is for
 * @param {String} aspect - The aspect of the adapter, usually 'scene' or 'data'
 * @param {?Number} canvasId - The canvasId of the XML3D element that this adapter will belong to
 * @returns {Adapter|?XML3D.base.Adapter}
 */
Resource.getAdapter = function(node, aspect, canvasId) {
    return XML3D.xml3dFormatHandler.getAdapter(node, aspect, canvasId);
};


/**
 * Get any adapter, internal or external.
 * This function will trigger the loading of documents, if required.
 * An AdapterHandle will be always be returned, expect when an invalid (empty) uri is passed.
 *
 * @param {String} baseURI - the base URI from which to look up the reference
 * @param {URI} uri - The URI used to find the referred AdapterHandle. Can be relative
 * @param {Object} aspect The type of adapter required (e.g. XML3D.data or XML3D.webgl)
 * @param {number=} canvasId Id of GLCanvasHandler handler this adapter depends on, 0 if not depending on any GLCanvasHandler
 * @returns {?AdapterHandle} The requested AdapterHandler. Note: might be null
 */
Resource.getAdapterHandle = function(baseURI, uri, aspect, canvasId) {
    canvasId = canvasId || 0;
    uri = XML3D.resource.getAbsoluteURI(baseURI, uri);

    if (!uri)
        return null;

    if (!c_cachedAdapterHandles[uri])
        c_cachedAdapterHandles[uri] = {};

    if (!c_cachedAdapterHandles[uri][aspect]) {
        c_cachedAdapterHandles[uri][aspect] = {};
    }

    var handle = c_cachedAdapterHandles[uri][aspect][canvasId];
    if (handle)
        return handle;

    return createAdapterHandle(uri, aspect, canvasId);
};

var createAdapterHandle = function(uri, aspect, canvasId) {
    var url = uri.toString();
    var handle = new AdapterHandle(url);
    c_cachedAdapterHandles[url][aspect][canvasId] = handle;

    if (uri.isLocal()) {
        var node = URIResolver.resolveLocal(uri);
        if (node)
            updateHandle(handle, aspect, canvasId, XML3D.xml3dFormatHandler, node);
        else
            handle.setAdapter(null, AdapterHandle.STATUS.NOT_FOUND);
    }
    else {
        ResourceCounter.addPendingResource(uri, canvasId);

        var docURI = uri.toStringWithoutFragment();
        var docData = getDocumentCache(docURI);
        if (docData && docData.document) {
            updateExternalHandles(uri, docData);
        } else {
            var priority = aspect === "scene" ? 1 : 0; //Give materials a higher priority
            XML3D.resource.getDocument(docURI, {priority : priority}).then(function(doc) {
                if (doc) {
                    docData = getDocumentCache(docURI);
                    docData.fragments.push(uri.fragment);
                    updateDocumentHandles(docURI);
                } else {
                    invalidateDocumentHandles(uri);
                }
            }).catch(function(e) {
                XML3D.debug.logError(e);
                invalidateDocumentHandles(uri);
            });
        }
    }
    return handle;
};

/**
 * Update a specific AdapterHandle with the provided data.
 * Internally an adapter will be created with 'data' and added to 'handle'
 * All other argument are required to find the correct factory
 * @param {AdapterHandle} handle The AdapterHandle to be updated
 * @param {Object} adapterType The type / aspect of the adapter (e.g. XML3D.data or XML3D.webgl)
 * @param {number} canvasId Id of corresponding canvas handler. 0 if not dependent of canvas handler
 * @param {FormatHandler} format Format handler of the corresponding document
 * @param {Object} data Data for this handle. Possibly a DOM element
 */
function updateHandle(handle, adapterType, canvasId, format, data) {
    var adapter = format.getAdapter(data, adapterType, canvasId);
    if (adapter) {
        handle.setAdapter(adapter, AdapterHandle.STATUS.READY);
    }
}

/**
 * Update all handles of a part from an external document
 * @param {URI} uri The URI of the document
 * @param {Object} docCache The entry in the c_documentCache for the external document
 */
function updateExternalHandles(uri, docCache) {
    // get part of the resource represented by the fragment
    var data = docCache.handler.getFragmentData(docCache.document, uri.fragment);
    if (data) {
        updateMissingHandles(uri, docCache.handler, data);
    } else {
        invalidateHandles(uri);
    }
}

/**
 * Update all AdapterHandles without adapters of a certain url
 * @param {URI} uri The complete url + fragment
 * @param {FormatHandler} formatHandler Format handler
 * @param {Object} data Data of the document corresponding to the url. Possibly a DOM element
 */
function updateMissingHandles(uri, formatHandler, data) {
    var url = uri.toString();
    for (var adapterType in c_cachedAdapterHandles[url]) {
        for (var canvasId in c_cachedAdapterHandles[url][adapterType]) {
            var handle = c_cachedAdapterHandles[url][adapterType][canvasId];
            if (!handle.hasAdapter()) {
                updateHandle(handle, adapterType, +canvasId, formatHandler, data);
                if(!uri.isLocal())
                    ResourceCounter.resolvePendingResource(uri, canvasId);
            }
        }
    }
}

/**
 * Invalidate all AdapterHandles without adapters of a certain url
 * @param {URI} uri The complete url + fragment
 */
function invalidateHandles(uri) {
    var url = uri.toString();
    for (var adapterType in c_cachedAdapterHandles[url]) {
        for (var canvasId in c_cachedAdapterHandles[url][adapterType]) {
            var handle = c_cachedAdapterHandles[url][adapterType][canvasId];
            handle.setAdapter(null, AdapterHandle.STATUS.NOT_FOUND);
            ResourceCounter.resolvePendingResource(uri, canvasId);
        }
    }
}

/**
 * Invalidate all handles of a document, that could not be loaded.
 * @param {URI} uri The URI of the document
 */
function invalidateDocumentHandles(uri) {
    var url = uri.toStringWithoutFragment();
    var docCache = getDocumentCache(url);
    if (!docCache) {
        // The document was never loaded
        invalidateHandles(uri);
        return;
    }
    var fragments = docCache.fragments;
    docCache.fragments = [];
    for (var i = 0; i < fragments.length; ++i) {
        invalidateHandles(uri);
    }
}

/**
 * Update all existing handles of a received document
 * @param {URI} uri The URI of the document
 */
function updateDocumentHandles(uri) {
    var url = uri.toString();
    var docCache = getDocumentCache(url);
    var fragments = docCache.fragments;
    docCache.fragments = [];
    var tempUri = new URI(uri);
    for (var i = 0; i < fragments.length; ++i) {
        tempUri.fragment = fragments[i];
        updateExternalHandles(tempUri, docCache);
    }
}


/**
 * This function is called to load an Image.
 *
 * @param {URI} uri Image URI
 * @param {function(Event, HTMLImageElement)} loadListener Function called when image was successfully loaded.
 *                                It will be called with event as the first and image as the second parameter.
 * @param {function(Event, HTMLImageElement)} errorListener Function called when image could not be loaded.
 *                                 It will be called with event as the first and image as the second parameter.
 * @return {HTMLImageElement}
 */
Resource.getImage = function(uri, loadListener, errorListener) {
    // we use canvasId 0 to represent images loaded in a document
    ResourceCounter.addPendingResource(uri, 0);

    var image = new Image();
    if(!uri.hasSameOrigin(document.location.href)) {
        image.crossOrigin = Options.getValue(OPTION_RESOURCE_CORS);
    }

    image.onload = function(e) {
        loadListener(e, image);
        ResourceCounter.resolvePendingResource(uri, 0);
    };
    image.onerror = function(e) {
        if (image.crossOrigin) {
            XML3D.debug.logIssue("May have attempted to use a cross-origin texture without proper cross-origin handling.", 164);
        }
        errorListener(e, image);
        ResourceCounter.resolvePendingResource(uri, 0);
    };

    image.src = uri.toString(); // here loading starts
    return image;
};

/**
 * This function is called to load a Video.
 *
 * @param {URI} uri Video URI
 * @param {boolean} autoplay
 * @param {boolean} loop
 * @param {Object} listeners  Dictionary of all listeners to register with video element.
 *                            Listeners will be called with event as the first and video as the second parameter.
 * @return {HTMLVideoElement}
 */
Resource.getVideo = function(uri, autoplay, loop, muted, listeners) {
    // we use canvasId 0 to represent videos loaded in a document
    ResourceCounter.addPendingResource(uri, 0);

    // FIXME: In HTML, we create a configured video, play/pause won't work
    var video = document.createElement("video");
    if (!uri.hasSameOrigin(document.location.href)) {
        video.crossOrigin = Options.getValue(OPTION_RESOURCE_CORS);
    }

    var loadCompleteCallback = function(event) {
        if (video.crossOrigin && event.type === "error") {
            XML3D.debug.logIssue("May have attempted to use a cross-origin texture without proper cross-origin handling.", 164);
        }
        ResourceCounter.resolvePendingResource(uri, 0);
        video.removeEventListener("canplay", loadCompleteCallback, true);
        video.removeEventListener("error", loadCompleteCallback, true);
    };


    video.autoplay = autoplay;
    video.loop = loop;
    video.muted = muted;

    function createCallback(listener) {
        return function(event) {
            listener(event, video);
        };
    }

    for (var eventName in listeners) {
        video.addEventListener(eventName, createCallback(listeners[eventName]), true);
    }

    video.addEventListener("canplay", loadCompleteCallback, true);
    video.addEventListener("error", loadCompleteCallback, true);

    video.src = uri.toString(); // here loading starts
    return video;
};


module.exports = Resource;

},{"../base/adapterhandle.js":49,"../utils/options.js":183,"../utils/uri.js":184,"./counter.js":162,"./fetcher.js":163}],162:[function(require,module,exports){

// External resources that haven't been fetched yet, per canvasId. When this reaches 0 the "load" event is dispatched
var c_pendingResources = {};

var ResourceCounter = {};

ResourceCounter.addPendingResource = function(uri, canvasId) {
    ResourceCounter.getOrCreatePendingResources(canvasId).entries.push(uri.toString());
};

ResourceCounter.resolvePendingResource = function(uri, canvasId) {
    // notify all load complete listeners
    var url = uri.toString();
    var pendingResources = c_pendingResources[canvasId];
    if (pendingResources) {
        Array.erase(pendingResources.entries, url);
        if (pendingResources.entries.length == 0) {
            ResourceCounter.notifyLoadCompleteListeners(pendingResources);
        }
    }
};

ResourceCounter.getOrCreatePendingResources = function(canvasId) {
    var pendingResources = c_pendingResources[canvasId];
    if (!pendingResources) {
        pendingResources = {entries: [], listeners: []};
        c_pendingResources[canvasId] = pendingResources;
    }
    return pendingResources;
};

ResourceCounter.notifyLoadCompleteListeners = function(pendingResources) {
    var listeners = pendingResources.listeners;
    var i = listeners.length;
    while (i--) {
        listeners[i](this);
    }
};

ResourceCounter.isLoadComplete = function(canvasId) {
    return !c_pendingResources[canvasId] || c_pendingResources[canvasId].entries.length == 0;
};

/*
 * Register listener that will be fired when all resources for specified canvasId are loaded.
 * Listener is fired only once.
 *
 * @param {number} canvasId
 * @param {EventListener} listener
 */
ResourceCounter.addLoadCompleteListener = function(canvasId, listener) {
    var pendingResources = ResourceCounter.getOrCreatePendingResources(canvasId);
    var idx = pendingResources.listeners.indexOf(listener);
    if (idx == -1) {
        pendingResources.listeners.push(listener);
    }
};

/**
 *
 * @param {number} canvasId
 * @param {function} listener
 */
ResourceCounter.removeLoadCompleteListener = function(canvasId, listener) {
    var pendingResources = c_pendingResources[canvasId];
    if (pendingResources) {
        var idx = pendingResources.listeners.indexOf(listener);
        if (idx != -1)
            pendingResources.listeners.splice(idx, 1);
    }
};

module.exports = ResourceCounter;


},{}],163:[function(require,module,exports){

require("whatwg-fetch");
var URI = require("../utils/uri.js").URI;

var c_requestHooks = [];    // Request hooks called for each outgoing request
var c_formatHandlers = [];  // All registered FormatHandler plugins
var c_requestQueue = [];    // Requests that haven't been sent out yet
var c_openRequests = 0;     // Number of requests that are currently waiting on a response
var c_cachedDocuments = new Map(); // Already received and processed resources, indexed by URL without the fragment

var Resource = {};

Resource.registerFormatHandler = function(formatHandler) {
    if (formatHandler)
        c_formatHandlers.push(formatHandler);
};

Resource.fetch = function(uriString, opt) {
    opt = initOptions(opt);
    var uri = new URI(uriString);

    for (var i=0; i < c_requestHooks.length; i++) {
        c_requestHooks[i](uri, opt);
    }
    if (opt.abort) {
        return Promise.reject(new RequestAbortedException(uri));
    }

    return doFetch(uri, opt);
};

function doFetch(uri, opt) {
    return new Promise(function(resolve, reject) {
        scheduleRequest({
            opt : opt,
            uri : uri,
            resolve : resolve,
            reject : reject
        });
    });
}

var popRequestQueue = function() {
    var request = c_requestQueue.shift();
    c_openRequests++;

    fetch(request.uri.toString(), request.opt)
        .then(function(response) {
            c_openRequests--;
            request.resolve(response);
        }).catch(function (exception) {
            XML3D.debug.logError("Could not retrieve document at '"+request.uri.toString()+"'. Reason: "+exception);
            c_openRequests--;
            request.reject(exception);
        });
};

Resource.getDocument = function(urlString, opt) {
    opt = initOptions(opt);
    var uri = new URI(urlString);

    for (var i=0; i < c_requestHooks.length; i++) {
        c_requestHooks[i](uri, opt);
    }
    if (opt.abort) {
        Promise.reject(new RequestAbortedException(uri));
    }

    var cache;
    if (opt.allowCaching) {
        if (cache = c_cachedDocuments.get(urlString)) {
            // We can skip the fetch phase and piggy back on the result of the previous fetch, this avoids unnecessary Requests
            return cache.pending ? cache.pending : Promise.resolve(cache.document);
        }

        // There is no pending or complete Request for this url so lets create a cache entry and start one
        cache = {fragments: []};
        c_cachedDocuments.set(urlString, cache); // Resource.parseResponse expects this entry to exist already
    }

    var documentPromise = doFetch(urlString, opt)
        .then(function(response) {
            if (!response.ok) {
                throw new RequestFailedException(response);
            }
            response.originalURL = urlString;
            var cache = { fragments : [] };
            c_cachedDocuments.set(urlString, cache); // Resource.parseResponse expects this entry to exist already
            cache.pending = Resource.parseResponse(response);
            return cache.pending;
        }).then(function(doc) {
            doc._documentURL = urlString;
            var cache = c_cachedDocuments.get(urlString);
            cache.document = doc;
            delete cache.pending;
            return doc;
        }).catch(function(exception) {
            c_cachedDocuments.has(urlString) && delete c_cachedDocuments.get(urlString).pending;
            throw exception;
        });

    if (cache) {
        cache.pending = documentPromise;
    }

    return documentPromise;
};

Resource.parseResponse = function(response) {
    return new Promise(function(resolve, reject) {
        var handlerCandidates = c_formatHandlers.filter(function(handler) {
            return handler.isFormatSupported(response);
        });

        if (response.bodyUsed) {
            XML3D.debug.logError("FormatHandlers should not access the response body in the isFormatSupported function without first cloning the response object!");
            reject(new ResponseBodyUsedException(response));
        }

        if (handlerCandidates.length == 1) {
            //Special case to avoid unnecessary cloning of the response
            handlerCandidates[0].getFormatData(response).then(function(doc) {
                c_cachedDocuments.get(response.originalURL).handler = handlerCandidates[0];
                resolve(doc);
            });
        } else {
            tryFormatHandlers(handlerCandidates, response, function(fh, doc) {
                c_cachedDocuments.get(response.originalURL).handler = fh;
                resolve(doc);
            });
        }
    })
};

function tryFormatHandlers(candidates, response, callback) {
    (function tryNextHandler(index) {
        if (index >= candidates.length) {
            // Reached the end of the array
            throw new TypeError("No FormatHandler could be found for the document "+response.url);
        }
        var fh = candidates[index];
        fh.getFormatData(response.clone()).then(function(doc) {
            callback(fh, doc);
        }).catch(function(e) {
            tryNextHandler(++index);
        })
    })(0);
}

Resource.onRequest = function(callback) {
    c_requestHooks.push(callback);
};

var scheduleRequest = function(obj) {
    if (!c_requestQueue.length) {
        // The request queue was empty before so we're waking up from an idle state
        window.requestAnimationFrame(tickWorkWindow);
    }
    c_requestQueue.push(obj);
    if (obj.opt.priority > 0) {
        // 0 is lowest priority so pushing it to the back is enough, for all other priorities we should to resort the array
        c_requestQueue.sort(prioritySort);
    }
};

var prioritySort = function(a, b) {
    return b.opt.priority - a.opt.priority; //Sort descending, higher priority first
};

var tickWorkWindow = function() {
    // Both of these loops trigger asynchronous work through Promises so working through all queue items shouldn't block the thread for too long
    while (c_requestQueue.length > 0) {
        popRequestQueue();
    }

    if (c_requestQueue.length) {
        // If there's more work to do schedule another call, otherwise idle until more work arrives in the scheduleWork function
        window.requestAnimationFrame(tickWorkWindow);
    }
};

var initOptions = function(opt) {
    opt = opt || {};
    opt.headers = opt.headers || {};
    opt.priority = opt.priority || 0;
    opt.abort = opt.abort || false;
    opt.allowCaching = opt.allowCaching !== undefined ? opt.allowCaching : true;
    return opt;
};

// Add a hook to check for file:// requests to warn the user that a server is needed to use XML3D
Resource.onRequest(function(uri, opt) {
    if (uri.toString().match(/(file:)\/+([A-z]:\/)/)) {
        XML3D.debug.logIssue("Encountered a filesystem request: '" + uri + "'. A local server is needed to use XML3D.", 162);
        opt.abort = true;
    }
});


/**
 * This methods returns an absolute URI compatible with the resource manager.
 * This means: Any reference from an external document will be absolute and any id reference from the current
 * document will remain an id reference.
 * @param {String} baseURI - the base URI that the uri is relative to
 * @param {URI} uri - The URI used to find the referred AdapterHandle. Can be relative
 * @returns {URI} The (sometimes) absolute URI
 */
Resource.getAbsoluteURI = function(baseURI, uri){
    if (!uri)
        return null;

    if (typeof uri == "string") uri = new URI(uri);
    if (baseURI != document.URL || !uri.isLocal()) {
        uri = uri.getAbsoluteURI(baseURI);
    }
    return uri;
};

Resource.getDocumentCache = function(urlString) {
    return c_cachedDocuments.get(urlString);
};


function RequestAbortedException(url) {
    this.name = "RequestAbortedException";
    this.message = "Request was aborted by an onRequest listener: "+url;
    this.url = url;
    this.stack = (new Error()).stack;
}
RequestAbortedException.prototype = Object.create(Error.prototype);
RequestAbortedException.prototype.constructor = RequestAbortedException;

function ResponseBodyUsedException(response) {
    this.name = "ResponseBodyUsedException";
    this.message = "The body of the Response was read prematurely.";
    this.response = response;
    this.stack = (new Error()).stack;
}
ResponseBodyUsedException.prototype = Object.create(Error.prototype);
ResponseBodyUsedException.prototype.constructor = ResponseBodyUsedException;

function RequestFailedException(response) {
    this.name = "RequestFailedException";
    this.message = "The request failed with status code "+response.status;
    this.response = response;
    this.stack = (new Error()).stack;
}
RequestFailedException.prototype = Object.create(Error.prototype);
RequestFailedException.prototype.constructor = RequestFailedException;


module.exports = Resource;


},{"../utils/uri.js":184,"whatwg-fetch":46}],164:[function(require,module,exports){

/**
 * A format handler is provide functionality for detecting format of resources
 * and providing format-specific services.
 * FormatHandlers are registered with XML3D.resource.registerFormatHandler() function.
 * @constructor
 */
var FormatHandler = function() {
};

//noinspection JSUnusedLocalSymbols
/**
 * Returns true if response data format is supported.
 * response is a Response object as defined by the Fetch API.
 * This function should not read the body of the response without cloning it first.
 *
 * @override
 * @param {Object} response
 * @return {Boolean}
 */
FormatHandler.prototype.isFormatSupported = function (response) {
    return false;
};

/**
 * Converts response data to format data.
 * Default implementation returns value of response.
 *
 * @override
 * @param {Object} response
 * @param {function} callback
 * @return {Object}
 */
FormatHandler.prototype.getFormatData = function (response) {
    return Promise.resolve(response);
};

/**
 * Extracts data for a fragment from document data and fragment reference.
 *
 * @override
 * @param {Object} documentData
 * @param {string} fragment Fragment without pound key which defines the part of the document
 * @return {*}
 */
FormatHandler.prototype.getFragmentData = function (documentData, fragment) {
    if (!fragment)
        return documentData;
    return null;
};

/**
 * Returns an Adapter for the given aspect. Should be overridden.
 * @param {Object} data
 * @param {String} aspect
 * @param {?Number} canvasId
 * @returns {Adapter}
 */
FormatHandler.prototype.getAdapter = function(data, aspect, canvasId) {
    return null;
};

module.exports = FormatHandler;

},{}],165:[function(require,module,exports){
var Resource = {};
XML3D.extend(Resource, require("./coordinator.js"));
XML3D.extend(Resource, require("./fetcher.js"));
Resource.FormatHandler = require("./formathandler.js");

module.exports = Resource;

},{"./coordinator.js":161,"./fetcher.js":163,"./formathandler.js":164}],166:[function(require,module,exports){
var XML3DDataAdapterFactory = require("../data/adapter/factory.js");
var RenderAdapterFactory = require("../renderer/renderer/adapter/factory.js");
var config = require("../interface/elements.js").config;

/**
 *
 * @constructor
 * @extends FormatHandler
 */
var XML3DFormatHandler = function () {
    XML3D.resource.FormatHandler.call(this);
    this.renderAdapterFactories = {};
    this.dataAdapterFactory = new XML3DDataAdapterFactory();
};
XML3D.createClass(XML3DFormatHandler, XML3D.resource.FormatHandler);

XML3DFormatHandler.prototype.isFormatSupported = function (response) {
    if (response.headers.has("Content-Type")) {
        var contentType = response.headers.get("Content-Type");
        return contentType.match(/\/xml/);
    }
    if (response.url.match(/\.xml/)) {
        return true;
    }
};

XML3DFormatHandler.prototype.getFormatData = function (response) {
    return response.text().then(function(responseText) {
        var parser = new DOMParser();
        var doc = parser.parseFromString(responseText, "text/xml");

        var xml3dElements = doc.querySelectorAll("xml3d");
        for (var i = 0; i < xml3dElements.length; ++i) {
            config.element(xml3dElements[i]);
        }
        return doc;
    });
};

XML3DFormatHandler.prototype.getFragmentData = function (documentData, fragment) {
    return documentData.querySelector("*[id='" + fragment + "']");
};

XML3DFormatHandler.prototype.getAdapter = function(node, aspect, canvasId) {
    if (aspect === "scene") {
        if (canvasId === undefined) {
            throw new Error("A canvas ID corresponding to an XML3D element must be provided when creating an adapter with the 'scene' aspect");
        }
        if (!this.renderAdapterFactories[canvasId]) {
            this.renderAdapterFactories[canvasId] = new RenderAdapterFactory(canvasId);
        }
        return this.renderAdapterFactories[canvasId].getAdapter(node);
    }
    if (aspect === "data") {
        return this.dataAdapterFactory.getAdapter(node);
    }

    throw new Error("Encountered an unknown aspect '"+aspect+"'");
};

XML3DFormatHandler.prototype.getFactory = function(aspect, canvasId) {
    if (aspect === "scene") {
        if (!this.renderAdapterFactories[canvasId]) {
            this.renderAdapterFactories[canvasId] = new RenderAdapterFactory(canvasId);
        }
        return this.renderAdapterFactories[canvasId];
    }
};

var xml3dFormatHandler = new XML3DFormatHandler();
XML3D.resource.registerFormatHandler(xml3dFormatHandler);
XML3D.xml3dFormatHandler = xml3dFormatHandler;

module.exports = {
    XML3DFormatHandler : XML3DFormatHandler
};

},{"../data/adapter/factory.js":58,"../interface/elements.js":72,"../renderer/renderer/adapter/factory.js":79}],167:[function(require,module,exports){
var vec4 = require("gl-matrix").vec4;
var Vec3 = require("./vec3.js");
var Quat = require("./quat.js");

var AxisAngle = function(vec, y, z, angle) {
    if (this instanceof AxisAngle) {
        this.data = vec4.create();
        if (angle !== undefined) {
            this.data[0] = vec;
            this.data[1] = y;
            this.data[2] = z;
            this.data[3] = angle;
        } else
        if (vec) {
            this.data.set(vec.data ? vec.data : vec);
        } else {
            this.data[2] = 1;
        }
    } else return new AxisAngle(vec, y, z, angle);
};


Object.defineProperty(AxisAngle.prototype, "axis", {
    set: function(vec){
        this.data[0] = vec.data ? vec.data[0] : vec[0];
        this.data[1] = vec.data ? vec.data[1] : vec[1];
        this.data[2] = vec.data ? vec.data[2] : vec[2];
    },
    get: function(){ return Vec3.wrap(this.data) }
});
Object.defineProperty(AxisAngle.prototype, "angle", {
    set: function(a){
        this.data[3] = a;
    },
    get: function(){ return this.data[3]; }
});

AxisAngle.prototype.clone = function() {
   return new AxisAngle(this);
};

AxisAngle.fromQuat = function(q) {
    var out = new AxisAngle();
    out.data.set(XML3D.math.vec4.fromQuat(q.data ? q.data : q));
    return out;
};

AxisAngle.prototype.toDOMString = function() {
    return vec4.toDOMString(this.data);
};

AxisAngle.fromDOMString = function(str) {
    var out = new AxisAngle();
    out.data.set( vec4.fromDOMString(str) );
    return out;
};

AxisAngle.prototype.toQuat = function() {
    var out = new Quat();
    quat.setAxisAngle(out.data, this.data, this.data[3]);
    return out;
};

AxisAngle.wrap = function(vec) {
    var v = AxisAngle();
    v.data = vec.data ? vec.data : vec;
    return v;
};

module.exports = AxisAngle;

},{"./quat.js":173,"./vec3.js":176,"gl-matrix":1}],168:[function(require,module,exports){
var Vec3 = require("./vec3.js");
var vec3 = require("gl-matrix").vec3;

var Box = function(box) {
    if (this instanceof Box) {
        this.data = new Float32Array(6);
        if (box) {
            this.data.set(box.data ? box.data : box);
        } else {
            this.setEmpty();
        }
    } else return new Box(box);
};

Object.defineProperty(Box.prototype, "min", {
    set: function(v){
        var val = v.data ? v.data : v;
        this.data[0] = val[0];
        this.data[1] = val[1];
        this.data[2] = val[2];
    },
    get: function(){
        return Vec3.wrap(this.data.subarray(0,3));
    }
});

Object.defineProperty(Box.prototype, "max", {
    set: function(v){
        var val = v.data ? v.data : v;
        this.data[3] = val[0];
        this.data[4] = val[1];
        this.data[5] = val[2];
    },
    get: function(){
        return Vec3.wrap(this.data.subarray(3,6));
    }
});

Box.prototype.clone = function() {
    return new Box(this);
};

Box.prototype.copy = function(other) {
    this.copyMin(other);
    this.copyMax(other);
    return this;
};

Box.prototype.copyMin = function(other) {
    vec3.copy(this.data, other.data ? other.data : other);
    return this;
};

Box.prototype.copyMax = function(other) {
    vec3.copy(this.data.subarray(3,6), other.data ? other.data.subarray(3,6) : other.subarray(3,6));
    return this;
};

Box.prototype.extend = function(other) {
    var box = other.data ? other.data : other;
    for (var i = 0; i < 3; i++) {
        this.data[i] = Math.min(box[i], this.data[i]);
        this.data[i + 3] = Math.max(box[i + 3], this.data[i + 3]);
    }
    return this;
};

Box.prototype.setEmpty = function() {
    this.data[0] = Number.MAX_VALUE;
    this.data[1] = Number.MAX_VALUE;
    this.data[2] = Number.MAX_VALUE;
    this.data[3] = -Number.MAX_VALUE;
    this.data[4] = -Number.MAX_VALUE;
    this.data[5] = -Number.MAX_VALUE;
    return this;
};

Box.prototype.isEmpty = function() {
    return (this.data[0] > this.data[3] || this.data[1] > this.data[4] || this.data[2] > this.data[5]);
};

Box.prototype.center = function(target) {
    var cen = target || new Vec3();
    cen.x = (this.data[0] + this.data[3]) * 0.5;
    cen.y = (this.data[1] + this.data[4]) * 0.5;
    cen.z = (this.data[2] + this.data[5]) * 0.5;
    return cen;
};

Box.prototype.size = function(target) {
    var size = target || new Vec3();
    size.x = Math.max(this.data[3] - this.data[0], 0);
    size.y = Math.max(this.data[4] - this.data[1], 0);
    size.z = Math.max(this.data[5] - this.data[2], 0);
    return size;
};

Box.prototype.extent = function() {
    return this.size().scale(0.5);
};

Box.prototype.transformAxisAligned = function(mat) {
    if (this.isEmpty()) {
        return this;
    }
    var out = new Float32Array(6);
    var m = mat.data ? mat.data : mat;
    if (m[3] == 0 && m[7] == 0 && m[11] == 0 && m[15] == 1) {

        for (var i = 0; i < 3; i++) {
            out[i] = out[i + 3] = m[12 + i];

            for (var j = 0; j < 3; j++) {
                var a, b;

                a = m[j * 4 + i] * this.data[j];
                b = m[j * 4 + i] * this.data[j + 3];

                if (a < b) {
                    out[i] += a;
                    out[i + 3] += b;
                }
                else {
                    out[i] += b;
                    out[i + 3] += a;
                }
            }
        }
        this.data.set(out);
        return this;
    }
    throw new Error("Matrix is not affine");
};

Box.prototype.transform = function(mat) {
    if (this.isEmpty()) {
        return this;
    }
    vec3.transformMat4(this.min.data, this.min.data, mat.data ? mat.data : mat);
    vec3.transformMat4(this.max.data, this.max.data, mat.data ? mat.data : mat);
    return this;
};

Box.prototype.longestSide = function() {
    if (this.isEmpty()) {
        return 0;
    }
    var x = Math.abs(this.data[3] - this.data[0]);
    var y = Math.abs(this.data[4] - this.data[1]);
    var z = Math.abs(this.data[5] - this.data[2]);
    return Math.max(x, Math.max(y, z));
};

Box.prototype.intersects = function(ray, opt) {
    if (this.isEmpty()) {
        if (opt !== undefined && opt.dist !== undefined) {
            opt.dist = Infinity;
        }
        return false;
    }
    var origin = ray.origin;
    var direction = ray.direction;
    var inverseDirX = 1 / direction.x;
    var inverseDirY = 1 / direction.y;
    var inverseDirZ = 1 / direction.z;

    var t1 = (this.data[0] - origin.x) * inverseDirX;
    var t2 = (this.data[3] - origin.x) * inverseDirX;
    var t3 = (this.data[1] - origin.y) * inverseDirY;
    var t4 = (this.data[4] - origin.y) * inverseDirY;
    var t5 = (this.data[2] - origin.z) * inverseDirZ;
    var t6 = (this.data[5] - origin.z) * inverseDirZ;

    var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
    var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));

    if (opt === undefined || opt.dist === undefined) {
        return tmax > 0 && tmin <= tmax;
    }

    if (tmax < 0 || tmin > tmax) {
        opt.dist = Infinity;
        return false;
    }

    opt.dist = tmin;
    return true;
};

Box.prototype.contains = function(point) {
    var p = point.data ? point.data : point;
    return this.data[0] <= p[0] && p[0] <= this.data[3] &&
           this.data[1] <= p[1] && p[1] <= this.data[4] &&
           this.data[2] <= p[2] && p[2] <= this.data[5];
};

Box.prototype.toString = function() {
    return 'XML3D.Box(' + this.data[0] + ', ' + this.data[1] + ', ' + this.data[2] + ', ' + this.data[3] + ', ' +
        this.data[4] + ', ' + this.data[5] + ')';
};

Box.EMPTY_BOX = new Box();

module.exports = Box;

},{"./vec3.js":176,"gl-matrix":1}],169:[function(require,module,exports){
var XC = require("../xflow/interface/constants.js");
var Resource = require("../resource");

var c_XflowObserverList = [];

var XML3DDataObserver = function(callback){
    this.callback = callback;
    this.observed = [];
};

XML3DDataObserver.prototype.observe = function(node, options){
    if(!node)
        throw new Error("The node to observe is null.");


    if(!node._configured)
        throw new Error("Note to observe is not   (yet). Make sure to pass an XML3D node and to execute " +
            "this function after XML3D has been configured e.g. inside a DOMContentLoaded listener.");


    var dataAdapter = Resource.getAdapter(node, "data");
    if(!dataAdapter)
        throw new Error("Can't observe node. XML3DataObserver can only observe data containers such as <data>, <mesh> or <shader>");

    if(this.observed.length == 0)
        c_XflowObserverList.push(this);

    var entry = {
        node: node,
        changed: false,
        request: null
    };

    var names = options && options['names'];
    var typeOfNames = Object.prototype.toString.call(names).slice(8, -1);
    if (typeOfNames === "String") {
        names = [names];
    }

    entry.request = dataAdapter.getComputeRequest(names, function(request, changeType){
        entry.changed = true;
    });
    // Fetch result to synchronize Xflow structures and connect to callbacks
    // TODO: Find an option to connect request to callback structure without computing result
    entry.request.getResult();

    this.observed.push(entry);
};

XML3DDataObserver.prototype.disconnect = function(){
    for(var i = 0; i < this.observed.length; ++i){
        this.observed[i].request.clear();
    }
    this.observed = [];
    var i = c_XflowObserverList.length;
    while(i--){
        if(c_XflowObserverList[i] == this)
            c_XflowObserverList.splice(i, 1);
    }
};


XML3D.updateXflowObserver = function(){
    for(var i = 0; i < c_XflowObserverList.length; ++i){
        var observer = c_XflowObserverList[i];
        var records = [];
        for(var j = 0; j < observer.observed.length; ++j){
            var entry = observer.observed[j];
            if(entry.changed){
                entry.changed = false;
                var result = entry.request.getResult();
                var dataResult = new XML3DDataResult(result);
                records.push( new XML3DDataRecord(entry.node, dataResult));
            }
        }
        if(records.length > 0 && observer.callback){
            observer.callback(records, observer);
        }
    }
};

var XML3DDataRecord = function(target, result){
    this.target = target;
    this.result = result;
};


var XML3DDataResult = function(result){
    this._entries = {};
    constructDataResult(this, result);
};

XML3DDataResult.prototype.getValue = function(name) {
    if (this._entries[name])
        return this._entries[name].value;
    return null;
};

XML3DDataResult.prototype.getType = function(name) {
    if (this._entries[name])
        return this._entries[name].type;
    return null;
};

XML3DDataResult.prototype.getNames = function(){
    var result = [];
    for(var name in this._entries){
        result.push(name);
    }
    return result;
};

XML3DDataResult.FLOAT  = 0;
XML3DDataResult.FLOAT2 = 1;
XML3DDataResult.FLOAT3 = 2;
XML3DDataResult.FLOAT4 = 3;
XML3DDataResult.FLOAT4X4 = 4;
XML3DDataResult.INT = 10;
XML3DDataResult.INT4 = 11;
XML3DDataResult.BOOL = 20;
XML3DDataResult.TEXTURE = 30;
XML3DDataResult.BYTE = 40;
XML3DDataResult.UBYTE = 50;


function constructDataResult(dataResult, result){
    for(var i = 0; i < result.outputNames.length; ++i){
        var name = result.outputNames[i];
        var entry = result.getOutputData(name);
        var value = entry && entry.getValue();
        if (value !== null) {
            var type = getXML3DDataType(entry.type);
            dataResult._entries[name] = { type: type, value: value};
        }
    }
}

function getXML3DDataType(type){
    switch(type){
        case XC.DATA_TYPE.FLOAT : return XML3DDataResult.FLOAT;
        case XC.DATA_TYPE.FLOAT2 : return XML3DDataResult.FLOAT2;
        case XC.DATA_TYPE.FLOAT3 : return XML3DDataResult.FLOAT3;
        case XC.DATA_TYPE.FLOAT4 : return XML3DDataResult.FLOAT4;
        case XC.DATA_TYPE.FLOAT4X4 : return XML3DDataResult.FLOAT4X4;
        case XC.DATA_TYPE.INT : return XML3DDataResult.INT;
        case XC.DATA_TYPE.INT4 : return XML3DDataResult.INT4;
        case XC.DATA_TYPE.BOOL : return XML3DDataResult.BOOL;
        case XC.DATA_TYPE.TEXTURE : return XML3DDataResult.TEXTURE;
        case XC.DATA_TYPE.BYTE : return XML3DDataResult.BYTE;
        case XC.DATA_TYPE.UBYTE : return XML3DDataResult.UBYTE;
        default: throw new Error("WHAT IS THIS I DON'T EVEN...");
    }
}

var XML3DDataChannelInfo = function(type, origin, originalName, seqLength, seqMinKey, seqMaxKey){
    this.type = getXML3DDataType(type);
    this.origin = origin;
    this.originalName = originalName;
    this.seqLength = seqLength;
    this.seqMinKey = seqMinKey;
    this.seqMaxKey = seqMaxKey;
};

XML3DDataChannelInfo.ORIGIN_CHILD = 1;
XML3DDataChannelInfo.ORIGIN_COMPUTE = 2;
XML3DDataChannelInfo.ORIGIN_PROTO = 3;

module.exports = {
    XML3DDataChannelInfo: XML3DDataChannelInfo,
    XML3DDataResult: XML3DDataResult,
    XML3DDataObserver: XML3DDataObserver
};

},{"../resource":165,"../xflow/interface/constants.js":187}],170:[function(require,module,exports){
var mat2 = require("gl-matrix").mat2;

var Mat2 = function(mat) {
    if (this instanceof Mat2) {
        this.data = mat2.create();
        if (mat) {
            this.data.set(mat.data ? mat.data : mat);
        }
    } else return new Mat2(mat);
};

Object.defineProperty(Mat2.prototype, "m11", {
    set: function(x){ this.data[0] = x; },
    get: function(){ return this.data[0]; }
});
Object.defineProperty(Mat2.prototype, "m12", {
    set: function(x){ this.data[1] = x; },
    get: function(){ return this.data[1]; }
});
Object.defineProperty(Mat2.prototype, "m21", {
    set: function(x){ this.data[2] = x; },
    get: function(){ return this.data[2]; }
});
Object.defineProperty(Mat2.prototype, "m22", {
    set: function(x){ this.data[3] = x; },
    get: function(){ return this.data[3]; }
});

Mat2.prototype.adjoint = function() {
    var out = new Mat2();
    mat2.adjoint(out.data, this.data);
    return out;
};

Mat2.prototype.clone = function() {
   return new Mat2(this);
};

Mat2.prototype.determinant = function() {
    return mat2.determinant(this.data);
};

Mat2.prototype.invert = function() {
    var out = new Mat2();
    mat2.invert(out.data, this.data);
    return out;
};

Mat2.prototype.mul = Mat2.prototype.multiply = function(b) {
    var out = new Mat2();
    mat2.multiply(out.data, this.data, b.data ? b.data : b);
    return out;
};

Mat2.prototype.rotate = function(rad) {
    var out = new Mat2();
    mat2.rotate(out.data, this.data, rad);
    return out;
};

Mat2.prototype.scale = function(vec) {
    var out = new Mat2();
    mat2.scale(out.data, this.data, vec.data ? vec.data : vec);
    return out;
};

Mat2.prototype.transpose = function() {
    var out = new Mat2();
    mat2.transpose(out.data, this.data);
    return out;
};

Mat2.wrap = function(mat) {
    var m = Mat2();
    m.data = mat.data ? mat.data : mat;
    return m;
};

module.exports = Mat2;

},{"gl-matrix":1}],171:[function(require,module,exports){
var mat3 = require("gl-matrix").mat3;

var Mat3 = function(mat) {
    if (this instanceof Mat3) {
        this.data = mat3.create();
        if (mat) {
            this.data.set(mat.data ? mat.data : mat);
        }
    } else return new Mat3(mat);
};

Object.defineProperty(Mat3.prototype, "m11", {
    set: function(x){ this.data[0] = x; },
    get: function(){ return this.data[0]; }
});
Object.defineProperty(Mat3.prototype, "m12", {
    set: function(x){ this.data[1] = x; },
    get: function(){ return this.data[1]; }
});
Object.defineProperty(Mat3.prototype, "m13", {
    set: function(x){ this.data[2] = x; },
    get: function(){ return this.data[2]; }
});
Object.defineProperty(Mat3.prototype, "m21", {
    set: function(x){ this.data[3] = x; },
    get: function(){ return this.data[3]; }
});
Object.defineProperty(Mat3.prototype, "m22", {
    set: function(x){ this.data[4] = x; },
    get: function(){ return this.data[4]; }
});
Object.defineProperty(Mat3.prototype, "m23", {
    set: function(x){ this.data[5] = x; },
    get: function(){ return this.data[5]; }
});
Object.defineProperty(Mat3.prototype, "m31", {
    set: function(x){ this.data[6] = x; },
    get: function(){ return this.data[6]; }
});
Object.defineProperty(Mat3.prototype, "m32", {
    set: function(x){ this.data[7] = x; },
    get: function(){ return this.data[7]; }
});
Object.defineProperty(Mat3.prototype, "m33", {
    set: function(x){ this.data[8] = x; },
    get: function(){ return this.data[8]; }
});


Mat3.prototype.adjoint = function() {
    var out = new Mat3();
    mat3.adjoint(out.data, this.data);
    return out;
};

Mat3.prototype.clone = function() {
   return new Mat3(this);
};

Mat3.prototype.determinant = function() {
    return mat3.determinant(this.data);
};

Mat3.fromMat4 = function(m) {
    var out = new Mat3();
    mat3.fromMat4(out.data, m.data ? m.data : m);
    return out;
};

Mat3.fromQuat = function(q) {
    var out = new Mat3();
    mat3.fromQuat(out.data, q.data ? q.data : q);
    return out;
};

Mat3.prototype.invert = function() {
    var out = new Mat3();
    mat3.invert(out.data, this.data);
    return out;
};

Mat3.prototype.mul = Mat3.prototype.multiply = function(b) {
    var out = new Mat3();
    mat3.multiply(out.data, this.data, b.data ? b.data : b);
    return out;
};

Mat3.normalFromMat4 = function(m) {
    var out = new Mat3();
    mat3.normalFromMat4(out.data, m.data ? m.data : m);
    return out;
};

Mat3.prototype.rotate = function(rad) {
    var out = new Mat3();
    mat3.rotate(out.data, this.data, rad);
    return out;
};

Mat3.prototype.scale = function(vec) {
    var out = new Mat3();
    mat3.scale(out.data, this.data, vec.data ? vec.data : vec);
    return out;
};

Mat3.prototype.transpose = function() {
    var out = new Mat3();
    mat3.transpose(out.data, this.data);
    return out;
};

Mat3.prototype.translate = function(vec) {
    var out = new Mat3();
    mat3.translate(out.data, this.data, vec.data ? vec.data : vec);
    return out;
};

Mat3.wrap = function(mat) {
    var m = Mat3();
    m.data = mat.data ? mat.data : mat;
    return m;
};

module.exports = Mat3;

},{"gl-matrix":1}],172:[function(require,module,exports){
var mat4 = require("gl-matrix").mat4;

var Mat4 = function(mat) {
    if (this instanceof Mat4) {
        this.data = mat4.create();
        if (mat) {
            this.data.set(mat.data ? mat.data : mat);
        }
    } else return new Mat4(mat);
};

Object.defineProperty(Mat4.prototype, "m11", {
    set: function(x){ this.data[0] = x; },
    get: function(){ return this.data[0]; }
});
Object.defineProperty(Mat4.prototype, "m12", {
    set: function(x){ this.data[1] = x; },
    get: function(){ return this.data[1]; }
});
Object.defineProperty(Mat4.prototype, "m13", {
    set: function(x){ this.data[2] = x; },
    get: function(){ return this.data[2]; }
});
Object.defineProperty(Mat4.prototype, "m14", {
    set: function(x){ this.data[3] = x; },
    get: function(){ return this.data[3]; }
});
Object.defineProperty(Mat4.prototype, "m21", {
    set: function(x){ this.data[4] = x; },
    get: function(){ return this.data[4]; }
});
Object.defineProperty(Mat4.prototype, "m22", {
    set: function(x){ this.data[5] = x; },
    get: function(){ return this.data[5]; }
});
Object.defineProperty(Mat4.prototype, "m23", {
    set: function(x){ this.data[6] = x; },
    get: function(){ return this.data[6]; }
});
Object.defineProperty(Mat4.prototype, "m24", {
    set: function(x){ this.data[7] = x; },
    get: function(){ return this.data[7]; }
});
Object.defineProperty(Mat4.prototype, "m31", {
    set: function(x){ this.data[8] = x; },
    get: function(){ return this.data[8]; }
});
Object.defineProperty(Mat4.prototype, "m32", {
    set: function(x){ this.data[9] = x; },
    get: function(){ return this.data[9]; }
});
Object.defineProperty(Mat4.prototype, "m33", {
    set: function(x){ this.data[10] = x; },
    get: function(){ return this.data[10]; }
});
Object.defineProperty(Mat4.prototype, "m34", {
    set: function(x){ this.data[11] = x; },
    get: function(){ return this.data[11]; }
});
Object.defineProperty(Mat4.prototype, "m41", {
    set: function(x){ this.data[12] = x; },
    get: function(){ return this.data[12]; }
});
Object.defineProperty(Mat4.prototype, "m42", {
    set: function(x){ this.data[13] = x; },
    get: function(){ return this.data[13]; }
});
Object.defineProperty(Mat4.prototype, "m43", {
    set: function(x){ this.data[14] = x; },
    get: function(){ return this.data[14]; }
});
Object.defineProperty(Mat4.prototype, "m44", {
    set: function(x){ this.data[15] = x; },
    get: function(){ return this.data[15]; }
});

Mat4.prototype.adjoint = function() {
    var out = new Mat4();
    mat4.adjoint(out.data, this.data);
    return out;
};

Mat4.prototype.clone = function() {
   return new Mat4(this);
};

Mat4.prototype.determinant = function() {
    return mat4.determinant(this.data);
};

Mat4.frustum = function(left, right, bottom, top, near, far) {
    var out = new Mat4();
    mat4.frustum(out.data, left, right, bottom, top, near, far);
    return out;
};

Mat4.prototype.invert = function() {
    var out = new Mat4();
    mat4.invert(out.data, this.data);
    return out;
};

Mat4.lookAt = function(eye, center, up) {
    var out = new Mat4();
    mat4.lookAt(out.data, eye.data ? eye.data : eye, center.data ? center.data : center, up.data ? up.data : up);
    return out;
};

Mat4.prototype.mul = Mat4.prototype.multiply = function(b) {
    var out = new Mat4();
    mat4.multiply(out.data, this.data, b.data ? b.data : b);
    return out;
};

Mat4.ortho = function(left, right, bottom, top, near, far) {
    var out = new Mat4();
    mat4.ortho(out.data, left, right, bottom, top, near, far);
    return out;
};

Mat4.perspective = function(fov, aspect, near, far) {
    var out = new Mat4();
    mat4.perspective(out.data, fov, aspect, near, far);
    return out;
};

Mat4.prototype.rotate = function(rad, axis) {
    var out = new Mat4();
    mat4.rotate(out.data, this.data, rad, axis.data ? axis.data : axis);
    return out;
};

Mat4.prototype.rotateX = function(rad) {
    var out = new Mat4();
    mat4.rotateX(out.data, this.data, rad);
    return out;
};

Mat4.prototype.rotateY = function(rad) {
    var out = new Mat4();
    mat4.rotateY(out.data, this.data, rad);
    return out;
};

Mat4.prototype.rotateZ = function(rad) {
    var out = new Mat4();
    mat4.rotateZ(out.data, this.data, rad);
    return out;
};

Mat4.prototype.scale = function(vec) {
    var out = new Mat4();
    mat4.scale(out.data, this.data, vec.data ? vec.data : vec);
    return out;
};

Mat4.fromQuat = function(q) {
    var out = new Mat4();
    mat4.fromQuat(out.data, q.data ? q.data : q);
    return out;
};

Mat4.fromRotationTranslation = function(q, v) {
    var out = new Mat4();
    mat4.fromRotationTranslation(out.data, q.data ? q.data : q, v.data ? v.data : v);
    return out;
};

Mat4.prototype.transpose = function() {
    var out = new Mat4();
    mat4.transpose(out.data, this.data);
    return out;
};

Mat4.prototype.translate = function(vec) {
    var out = new Mat4();
    mat4.translate(out.data, this.data, vec.data ? vec.data : vec);
    return out;
};

Mat4.wrap = function(mat) {
    var m = Mat4();
    m.data = mat.data ? mat.data : mat;
    return m;
};


module.exports = Mat4;

},{"gl-matrix":1}],173:[function(require,module,exports){
var quat = require("gl-matrix").quat;

var Quat = function(vec, y, z, w) {
    if (this instanceof Quat) {
        this.data = quat.create();
        if (w !== undefined) {
            this.x = vec;
            this.y = y;
            this.z = z;
            this.w = w;
        } else
        if (vec) {
            this.data.set(vec.data ? vec.data : vec);
        } else {
            this.w = 1;
        }
    } else return new Quat(vec, y, z, w);
};

Object.defineProperty(Quat.prototype, "x", {
    set: function(x){
        this.data[0] = x;
    },
    get: function(){ return this.data[0]; }
});
Object.defineProperty(Quat.prototype, "y", {
    set: function(y){
        this.data[1] = y;
    },
    get: function(){ return this.data[1]; }
});
Object.defineProperty(Quat.prototype, "z", {
    set: function(z){
        this.data[2] = z;
    },
    get: function(){ return this.data[2]; }
});
Object.defineProperty(Quat.prototype, "w", {
    set: function(w){
        this.data[3] = w;
    },
    get: function(){ return this.data[3]; }
});

Quat.prototype.add = function(b) {
    var out = new Quat();
    quat.add(out.data, this.data, b.data ? b.data : b);
    return out;
};

Quat.prototype.calculateW = function() {
    var out = new Quat();
    quat.calculateW(out.data, this.data);
    return out;
};

Quat.prototype.clone = function() {
   return new Quat(this);
};

Quat.prototype.conjugate = function() {
    var out = new Quat();
    quat.conjugate(out.data, this.data);
    return out;
};

Quat.prototype.dot = function(b) {
    return quat.dot(this.data, b.data ? b.data : b);
};

Quat.prototype.invert = function() {
    var out = new Quat();
    quat.invert(out.data, this.data);
    return out;
};

Quat.prototype.len = Quat.prototype.length = function() {
    return quat.length(this.data);
};

Quat.prototype.lerp = function(b, t) {
    var out = new Quat();
    quat.lerp(out.data, this.data, b.data ? b.data : b, t);
    return out;
};

Quat.prototype.mul = Quat.prototype.multiply = function(b) {
    var out = new Quat();
    quat.mul(out.data, this.data, b.data ? b.data : b);
    return out;
};

Quat.prototype.normalize = function() {
    var out = new Quat();
    quat.normalize(out.data, this.data);
    return out;
};

Quat.prototype.rotateX = function(rad) {
    var out = new Quat();
    quat.rotateX(out.data, this.data, rad);
    return out;
};

Quat.prototype.rotateY = function(rad) {
    var out = new Quat();
    quat.rotateY(out.data, this.data, rad);
    return out;
};

Quat.prototype.rotateZ = function(rad) {
    var out = new Quat();
    quat.rotateZ(out.data, this.data, rad);
    return out;
};

Quat.prototype.scale = function(s) {
    var out = new Quat();
    quat.scale(out.data, this.data, s);
    return out;
};

Quat.fromAxisAngle = function(axis, rad) {
    var out = new Quat();
    if (rad === undefined) {
        quat.setAxisAngle(out.data, axis.data ? axis.data : axis, axis.data ? axis.data[3] : axis[3]);
    } else {
        quat.setAxisAngle(out.data, axis.data ? axis.data : axis, rad);
    }
    quat.normalize(out.data, out.data);
    return out;
};

Quat.fromBasis = function(x, y, z) {
    var out = new Quat();
    XML3D.math.quat.setFromBasis(out.data, x.data ? x.data : x, y.data ? y.data : y, z.data ? z.data : z);
    quat.normalize(out.data, out.data);
    return out;
};

Quat.fromMat3 = function(m) {
    var out = new Quat();
    quat.fromMat3(out.data, m.data ? m.data : m);
    quat.normalize(out.data, out.data);
    return out;
};

Quat.fromRotationTo = function(from, to) {
    var out = new Quat();
    quat.rotationTo(out.data, from.data ? from.data : from, to.data ? to.data : to);
    quat.normalize(out.data, out.data);
    return out;
};

Quat.prototype.slerp = function(b, t) {
    var out = new Quat();
    quat.slerp(out.data, this.data, b.data ? b.data : b, t);
    return out;
};

Quat.prototype.toDOMString = function() {
    return quat.toDOMString(this.data);
};

Quat.fromDOMString = function(str) {
    var out = new Quat();
    out.data.set( quat.fromDOMString(str) );
    return out;
};

Quat.wrap = function(vec) {
    var v = Quat();
    v.data = vec.data ? vec.data : vec;
    return v;
};

module.exports = Quat;

},{"gl-matrix":1}],174:[function(require,module,exports){
var Vec3 = require("./vec3.js");
var vec3 = require("gl-matrix").vec3;

var Ray = function(ray) {
    if (this instanceof Ray) {
        this.data = new Float32Array(6);
        this.data[5] = -1;
        if (ray) {
            this.data.set( ray.data ? ray.data : ray );
        }
    } else {
        return new Ray(ray);
    }
};

Object.defineProperty(Ray.prototype, "origin", {
    set: function(v){
        var val = v.data ? v.data : v;
        this.data[0] = val[0];
        this.data[1] = val[1];
        this.data[2] = val[2];
    },
    get: function(){
        return Vec3.wrap(this.data.subarray(0,3));
    }
});

Object.defineProperty(Ray.prototype, "direction", {
    set: function(v){
        var val = v.data ? v.data : v;
        vec3.normalize(val, val);
        this.data[3] = val[0];
        this.data[4] = val[1];
        this.data[5] = val[2];
    },
    get: function(){
        return Vec3.wrap(this.data.subarray(3,6));
    }
});

Ray.prototype.setFromOriginDirection = function(origin, direction) {
    this.origin = origin;
    this.direction = direction;
    return this;
};

Ray.prototype.clone = function() {
    return new Ray().copy(this);
};

Ray.prototype.copy = function(other) {
    this.copyOrigin(other);
    this.copyDirection(other);
    return this;
};

Ray.prototype.copyOrigin = function(other) {
    vec3.copy(this.data, other.data ? other.data : other);
    return this;
};

Ray.prototype.copyDirection = function(other) {
    vec3.copy(this.data.subarray(3,6), other.data ? other.data.subarray(3,6) : other.subarray(3,6));
    return this;
};

Ray.prototype.intersects = function(box, opt) {
    return box.intersects(this, opt);
};

Ray.prototype.toString = function() {
    return 'XML3D.Ray(origin: ' + this.data[0] + ', ' + this.data[1] + ', ' + this.data[2] + ', direction: ' + this.data[3] + ', ' +
        this.data[4] + ', ' + this.data[5] + ')';
};

module.exports = Ray;

},{"./vec3.js":176,"gl-matrix":1}],175:[function(require,module,exports){
var vec2 = require("gl-matrix").vec2;

var Vec2 = function(vec, y) {
    if (this instanceof Vec2) {
        this.data = vec2.create();
        if (y !== undefined) {
            this.x = vec;
            this.y = y;
        } else
        if (vec) {
            this.data.set(vec.data ? vec.data : vec);
        }
    } else return new Vec2(vec, y);
};

Object.defineProperty(Vec2.prototype, "x", {
    set: function(x){
        this.data[0] = x;
    },
    get: function(){ return this.data[0]; }
});
Object.defineProperty(Vec2.prototype, "y", {
    set: function(y){
        this.data[1] = y;
    },
    get: function(){ return this.data[1]; }
});

Vec2.prototype.add = function(b) {
    var out = new Vec2();
    vec2.add(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec2.prototype.clone = function() {
    return new Vec2(this);
};

Vec2.prototype.dist = Vec2.prototype.distance = function(b) {
    return vec2.dist(this.data, b.data ? b.data : b);
};

Vec2.prototype.divide = function(b) {
    var out = new Vec2();
    vec2.divide(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec2.prototype.dot = function(b) {
    return vec2.dot(this.data, b.data ? b.data : b);
};

Vec2.prototype.len = Vec2.prototype.length = function() {
    return vec2.length(this.data);
};

Vec2.prototype.lerp = function(b, t) {
    var out = new Vec2();
    vec2.lerp(out.data, this.data, b.data ? b.data : b, t);
    return out;
};

Vec2.prototype.max = function(b) {
    var m = new Vec2();
    vec2.max(m.data, this.data, b.data ? b.data : b);
    return m;
};

Vec2.prototype.min = function(b) {
    var m = new Vec2();
    vec2.max(m.data, this.data, b.data ? b.data : b);
    return m;
};

Vec2.prototype.mul = Vec2.prototype.multiply = function(b) {
    var out = new Vec2();
    var c = b.data ? b.data : b;

    switch (c.length) {
        case 2:
            vec2.mul(out.data, this.data, c);
            break;
        case 4:
            vec2.transformMat2(out.data, this.data, c);
            break;
        case 9:
            vec2.transformMat3(out.data, this.data, c);
            break;
        case 16:
            vec2.transformMat4(out.data, this.data, c);
            break;
        default:
            console.error("Invalid input to Vec2.multiply "+b);
    }

    return out;
};

Vec2.prototype.negate = function() {
    var out = new Vec2();
    vec2.negate(out.data, this.data);
    return out;
};

Vec2.prototype.normalize = function() {
    var out = new Vec2();
    vec2.normalize(out.data, this.data);
    return out;
};

Vec2.random = function(scale) {
    var m = new Vec2();
    vec2.random(m.data, scale);
    return m;
};

Vec2.prototype.scale = function(s) {
    var out = new Vec2();
    vec2.scale(out.data, this.data, s);
    return out;
};

Vec2.prototype.sub = Vec2.prototype.subtract = function(b) {
    var out = new Vec2();
    vec2.sub(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec2.prototype.toDOMString = function() {
    return vec2.toDOMString(this.data);
};

Vec2.fromDOMString = function(str) {
    var out = new Vec2();
    out.data.set( vec2.fromDOMString(str) );
    return out;
};

Vec2.wrap = function(vec) {
    var v = Vec2();
    v.data = vec.data ? vec.data : vec;
    return v;
};

module.exports = Vec2;

},{"gl-matrix":1}],176:[function(require,module,exports){
var vec3 = require("gl-matrix").vec3;

var Vec3 = function(vec, y, z) {
    if (this instanceof Vec3) {
        this.data = vec3.create();
        if (z !== undefined) {
            this.x = vec;
            this.y = y;
            this.z = z;
        } else
        if (vec) {
            this.data.set(vec.data ? vec.data : vec);
        }
    } else return new Vec3(vec, y, z);
};

Object.defineProperty(Vec3.prototype, "x", {
    set: function(x){
        this.data[0] = x;
    },
    get: function(){ return this.data[0]; }
});
Object.defineProperty(Vec3.prototype, "y", {
    set: function(y){
        this.data[1] = y;
    },
    get: function(){ return this.data[1]; }
});
Object.defineProperty(Vec3.prototype, "z", {
    set: function(z){
        this.data[2] = z;
    },
    get: function(){ return this.data[2]; }
});

Vec3.prototype.add = function(b) {
    var out = new Vec3();
    vec3.add(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec3.prototype.clone = function() {
   return new Vec3(this);
};

Vec3.prototype.cross = function(b) {
    var out = new Vec3();
    vec3.cross(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec3.prototype.dist = Vec3.prototype.distance = function(b) {
    return vec3.dist(this.data, b.data ? b.data : b);
};

Vec3.prototype.divide = function(b) {
    var out = new Vec3();
    vec3.divide(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec3.prototype.dot = function(b) {
    return vec3.dot(this.data, b.data ? b.data : b);
};

Vec3.prototype.len = Vec3.prototype.length = function() {
    return vec3.length(this.data);
};

Vec3.prototype.lerp = function(b, t) {
    var out = new Vec3();
    vec3.lerp(out.data, this.data, b.data ? b.data : b, t);
    return out;
};

Vec3.prototype.max = function(b) {
    var m = new Vec3();
    vec3.max(m.data, this.data, b.data ? b.data : b);
    return m;
};

Vec3.prototype.min = function(b) {
    var m = new Vec3();
    vec3.max(m.data, this.data, b.data ? b.data : b);
    return m;
};

Vec3.prototype.mul = Vec3.prototype.multiply = function(b) {
    var out = new Vec3();
    var c = b.data ? b.data : b;

    switch (c.length) {
        case 3:
            vec3.mul(out.data, this.data, c);
            break;
        case 4:
            vec3.transformQuat(out.data, this.data, c);
            break;
        case 9:
            vec3.transformMat3(out.data, this.data, c);
            break;
        case 16:
            vec3.transformMat4(out.data, this.data, c);
            break;
        default:
            console.error("Invalid input to Vec3.multiply "+b);
    }

    return out;
};

Vec3.prototype.negate = function() {
    var out = new Vec3();
    vec3.negate(out.data, this.data);
    return out;
};

Vec3.prototype.normalize = function() {
    var out = new Vec3();
    vec3.normalize(out.data, this.data);
    return out;
};

Vec3.prototype.random = function(scale) {
    var m = new Vec3();
    vec3.random(m.data, scale);
    return m;
};

Vec3.prototype.reciprocal = function() {
    var out = new Vec3();
    XML3D.math.vec3.reciprocal(out.data, this.data);
    return out;
};

Vec3.prototype.scale = function(s) {
    var out = new Vec3();
    vec3.scale(out.data, this.data, s);
    return out;
};

Vec3.prototype.sub = Vec3.prototype.subtract = function(b) {
    var out = new Vec3();
    vec3.sub(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec3.prototype.transformDirection = function(m) {
    var out = new Vec3();
    XML3D.math.vec3.transformDirection(out.data, this.data, m.data ? m.data : m);
    return out;
};

Vec3.prototype.toDOMString = function() {
    return vec3.toDOMString(this.data);
};

Vec3.fromDOMString = function(str) {
    var out = new Vec3();
    out.data.set( vec3.fromDOMString(str) );
    return out;
};

Vec3.wrap = function(vec) {
    var v = Vec3();
    v.data = vec.data ? vec.data : vec;
    return v;
};

module.exports = Vec3;

},{"gl-matrix":1}],177:[function(require,module,exports){
var vec4 = require("gl-matrix").vec4;
var Vec3 = require("./vec3.js");

var Vec4 = function(vec, y, z, w) {
    if (this instanceof Vec4) {
        this.data = vec4.create();
        if (w !== undefined) {
            this.x = vec;
            this.y = y;
            this.z = z;
            this.w = w;
        } else
        if (vec) {
            this.data.set(vec.data ? vec.data : vec);
        }
    } else return new Vec4(vec, y, z, w);
};

Object.defineProperty(Vec4.prototype, "x", {
    set: function(x){
        this.data[0] = x;
    },
    get: function(){ return this.data[0]; }
});
Object.defineProperty(Vec4.prototype, "y", {
    set: function(y){
        this.data[1] = y;
    },
    get: function(){ return this.data[1]; }
});
Object.defineProperty(Vec4.prototype, "z", {
    set: function(z){
        this.data[2] = z;
    },
    get: function(){ return this.data[2]; }
});
Object.defineProperty(Vec4.prototype, "w", {
    set: function(w){
        this.data[3] = w;
    },
    get: function(){ return this.data[3]; }
});

Vec4.prototype.add = function(b) {
    var out = new Vec4();
    vec4.add(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec4.prototype.clone = function() {
   return new Vec4(this);
};

Vec4.prototype.dist = Vec4.prototype.distance = function(b) {
    return vec4.dist(this.data, b.data ? b.data : b);
};

Vec4.prototype.divide = function(b) {
    var out = new Vec4();
    vec4.divide(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec4.prototype.dot = function(b) {
    return vec4.dot(this.data, b.data ? b.data : b);
};

Vec4.prototype.len = Vec4.prototype.length = function() {
    return vec4.length(this.data);
};

Vec4.prototype.lerp = function(b, t) {
    var out = new Vec4();
    vec4.lerp(out.data, this.data, b.data ? b.data : b, t);
    return out;
};

Vec4.prototype.max = function(b) {
    var m = new Vec4();
    vec4.max(m.data, this.data, b.data ? b.data : b);
    return m;
};

Vec4.prototype.min = function(b) {
    var m = new Vec4();
    vec4.max(m.data, this.data, b.data ? b.data : b);
    return m;
};

Vec4.prototype.mul = Vec4.prototype.multiply = function(b) {
    var out = new Vec4();
    var c = b.data ? b.data : b;

    switch (c.length) {
        case 4:
            vec4.mul(out.data, this.data, c);
            break;
        case 16:
            vec4.transformMat4(out.data, this.data, c);
            break;
        default:
            console.error("Invalid input to Vec4.multiply "+b);
    }

    return out;
};

Vec4.prototype.negate = function() {
    var out = new Vec4();
    vec4.negate(out.data, this.data);
    return out;
};

Vec4.prototype.normalize = function() {
    var out = new Vec4();
    vec4.normalize(out.data, this.data);
    return out;
};

Vec4.prototype.random = function(scale) {
    var m = new Vec4();
    vec4.random(m.data, scale);
    return m;
};

Vec4.prototype.scale = function(s) {
    var out = new Vec4();
    vec4.scale(out.data, this.data, s);
    return out;
};

Vec4.prototype.sub = Vec4.prototype.subtract = function(b) {
    var out = new Vec4();
    vec4.sub(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec4.prototype.transformQuat = function(q) {
    var out = new Vec4();
    vec4.transformQuat(out.data, this.data, q.data ? q.data : q);
    return out;
};

Vec4.prototype.toDOMString = function() {
    return vec4.toDOMString(this.data);
};

Vec4.fromDOMString = function(str) {
    var out = new Vec4();
    out.data.set( vec4.fromDOMString(str) );
    return out;
};

Vec4.wrap = function(vec) {
    var v = Vec4();
    v.data = vec.data ? vec.data : vec;
    return v;
};

module.exports = Vec4;

},{"./vec3.js":176,"gl-matrix":1}],178:[function(require,module,exports){
// Add convienent array methods if non-existant
if (!Array.forEach) {
    Array.forEach = function(array, fun, thisp) {
        var len = array.length;
        for ( var i = 0; i < len; i++) {
            if (i in array) {
                fun.call(thisp, array[i], i, array);
            }
        }
    };
}
if (!Array.map) {
    Array.map = function(array, fun, thisp) {
        var len = array.length;
        var res = [];
        for ( var i = 0; i < len; i++) {
            if (i in array) {
                res[i] = fun.call(thisp, array[i], i, array);
            }
        }
        return res;
    };
}
if (!Array.filter) {
    Array.filter = function(array, fun, thisp) {
        var len = array.length;
        var res = [];
        for ( var i = 0; i < len; i++) {
            if (i in array) {
                var val = array[i];
                if (fun.call(thisp, val, i, array)) {
                    res.push(val);
                }
            }
        }
        return res;
    };
}

if (!Array.erase) {
    Array.erase = function(array, object) {
        var erased = false;
        var idx = -1;
        while( (idx = array.indexOf(object) ) != -1){
            array.splice(idx, 1);
            erased = true;
        }
        return erased;
    };
}

if (!Array.set) {
    Array.set = function(array, offset, value) {
        for (var i=0; i < value.length; i++)
            array[offset+i] = value[i];
    };
}

if (!Array.isArray) {
    Array.isArray = function(arg) {
        return Object.prototype.toString.call(arg) == '[object Array]';
    };
}

},{}],179:[function(require,module,exports){
var CSSMatrix = require("./cssMatrix.js");

var css = {};

css.TRANSFORM_PROPERTY = null;

css.init = function () {
    if ('transform' in document.body.style) {
        css.TRANSFORM_PROPERTY = 'transform'
    } else if ('WebkitTransform' in document.body.style) {
        css.TRANSFORM_PROPERTY = '-webkit-transform'
    } else if ('MozTransform' in document.body.style) {
        css.TRANSFORM_PROPERTY = '-moz-transform'
    } else {
        XML3D.debug.logWarning("No supported transform css property found");
    }
};

css.getInlinePropertyValue = function (node, property) {
    var styleValue = node.getAttribute('style');
    if (styleValue) {
        var pattern = new RegExp(property + "\s*:([^;]+)", "i");
        var result = pattern.exec(styleValue);
        if (result)
            return result[1].trim();
    }
    return null;
};

css.getPropertyValue = function (node, property) {
    var value = this.getInlinePropertyValue(node, property);
    if (value)
        return value;

    var style = window.getComputedStyle(node);
    return style.getPropertyValue(property);
};

css.getCSSMatrix = function (node) {
    if (!css.TRANSFORM_PROPERTY || !CSSMatrix)
        return null;

    var style = null;

    if (css.TRANSFORM_PROPERTY != "transform")
        style = css.getInlinePropertyValue(node, "transform");

    if (!style)
        style = css.getPropertyValue(node, css.TRANSFORM_PROPERTY);

    if (!style || style == "none")
        return null;

    var result = null;
    try {
        result = new CSSMatrix(style);
    } catch (e) {
        XML3D.debug.logError("Error parsing transform property: " + style);
    }
    return result;

};


css.convertCssToMat4 = function (cssMatrix, m) {
    var matrix = m || new XML3D.Mat4();
    matrix.m11 = cssMatrix.m11;
    matrix.m12 = cssMatrix.m12;
    matrix.m13 = cssMatrix.m13;
    matrix.m14 = cssMatrix.m14;
    matrix.m21 = cssMatrix.m21;
    matrix.m22 = cssMatrix.m22;
    matrix.m23 = cssMatrix.m23;
    matrix.m24 = cssMatrix.m24;
    matrix.m31 = cssMatrix.m31;
    matrix.m32 = cssMatrix.m32;
    matrix.m33 = cssMatrix.m33;
    matrix.m34 = cssMatrix.m34;
    matrix.m41 = cssMatrix.m41;
    matrix.m42 = cssMatrix.m42;
    matrix.m43 = cssMatrix.m43;
    matrix.m44 = cssMatrix.m44;
    return matrix;
};

(function () {
    var styleElement = document.createElement("style");
    styleElement.textContent = "xml3d * { display: inherit; }" +
        "float,float2,float3,float4,float4x4,int,int4,bool,texture,string,compute { display: none; } " +
        "mesh,model,group { position: absolute; }";
    document.head.appendChild(styleElement);
}());


module.exports = css;


},{"./cssMatrix.js":180}],180:[function(require,module,exports){

/**
 *  class FirminCSSMatrix
 *
 *  The [[FirminCSSMatrix]] class is a concrete implementation of the
 *  `CSSMatrix` interface defined in the [CSS 2D Transforms][2d] and
 *  [CSS 3D Transforms][3d] Module specifications.
 *
 *  [2d]: http://www.w3.org/TR/css3-2d-transforms/
 *  [3d]: http://www.w3.org/TR/css3-3d-transforms/
 *
 *  The implementation was largely copied from the `WebKitCSSMatrix` class, and
 *  the supparting maths libraries in the [WebKit][webkit] project. This is one
 *  reason why much of the code looks more like C++ than JavaScript.
 *
 *  [webkit]: http://webkit.org/
 *
 *  Its API is a superset of that provided by `WebKitCSSMatrix`, largely
 *  because various pieces of supporting code have been added as instance
 *  methods rather than pollute the global namespace. Examples of these include
 *  [[FirminCSSMatrix#isAffine]], [[FirminCSSMatrix#isIdentityOrTranslation]]
 *  and [[FirminCSSMatrix#adjoint]].
 **/

/**
 *  new FirminCSSMatrix(domstr)
 *  - domstr (String): a string representation of a 2D or 3D transform matrix
 *    in the form given by the CSS transform property, i.e. just like the
 *    output from [[FirminCSSMatrix#toString]].
 *
 *  @constructor
 **/
var FirminCSSMatrix = function(domstr) {
    this.m11 = this.m22 = this.m33 = this.m44 = 1;

    this.m12 = this.m13 = this.m14 =
    this.m21 =            this.m23 = this.m24 =
    this.m31 = this.m32 =            this.m34 =
    this.m41 = this.m42 = this.m43            = 0;

    if (typeof domstr == "string") {
        this.setMatrixValue(domstr);
    }
};

/**
 *  FirminCSSMatrix.displayName = "FirminCSSMatrix"
 **/
FirminCSSMatrix.displayName = "FirminCSSMatrix";

/**
 *  FirminCSSMatrix.degreesToRadians(angle) -> Number
 *  - angle (Number): an angle in degrees.
 *
 *  Converts angles in degrees, which are used by the external API, to angles
 *  in radians used in internal calculations.
 **/
FirminCSSMatrix.degreesToRadians = function(angle) {
    return angle * Math.PI / 180;
};

/**
 *  FirminCSSMatrix.determinant2x2(a, b, c, d) -> Number
 *  - a (Number): top-left value of the matrix.
 *  - b (Number): top-right value of the matrix.
 *  - c (Number): bottom-left value of the matrix.
 *  - d (Number): bottom-right value of the matrix.
 *
 *  Calculates the determinant of a 2x2 matrix.
 **/
FirminCSSMatrix.determinant2x2 = function(a, b, c, d) {
    return a * d - b * c;
};

/**
 *  FirminCSSMatrix.determinant3x3(matrix) -> Number
 *  - a1 (Number): matrix value in position [1, 1].
 *  - a2 (Number): matrix value in position [1, 2].
 *  - a3 (Number): matrix value in position [1, 3].
 *  - b1 (Number): matrix value in position [2, 1].
 *  - b2 (Number): matrix value in position [2, 2].
 *  - b3 (Number): matrix value in position [2, 3].
 *  - c1 (Number): matrix value in position [3, 1].
 *  - c2 (Number): matrix value in position [3, 2].
 *  - c3 (Number): matrix value in position [3, 3].
 *
 *  Calculates the determinant of a 3x3 matrix.
 **/
FirminCSSMatrix.determinant3x3 = function(a1, a2, a3, b1, b2, b3, c1, c2, c3) {
    var determinant2x2 = FirminCSSMatrix.determinant2x2;
    return a1 * determinant2x2(b2, b3, c2, c3) -
    b1 * determinant2x2(a2, a3, c2, c3) +
    c1 * determinant2x2(a2, a3, b2, b3);
};

/**
 *  FirminCSSMatrix.determinant4x4(matrix) -> Number
 *  - matrix (FirminCSSMatrix): the matrix to calculate the determinant of.
 *
 *  Calculates the determinant of a 4x4 matrix.
 **/
FirminCSSMatrix.determinant4x4 = function(m) {
    var determinant3x3 = FirminCSSMatrix.determinant3x3,

        // Assign to individual variable names to aid selecting correct elements
    a1 = m.m11, b1 = m.m21, c1 = m.m31, d1 = m.m41,
    a2 = m.m12, b2 = m.m22, c2 = m.m32, d2 = m.m42,
    a3 = m.m13, b3 = m.m23, c3 = m.m33, d3 = m.m43,
    a4 = m.m14, b4 = m.m24, c4 = m.m34, d4 = m.m44;

    return a1 * determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4) -
    b1 * determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4) +
    c1 * determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4) -
    d1 * determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
};

/**
 * FirminCSSMatrix.toMatrixString(transformValue) -> String
 * - transformValue (String): `el.style.WebkitTransform`-style string (like `rotate(18rad) translate3d(50px, 100px, 10px)`)
 *
 * Tranforms a `el.style.WebkitTransform`-style string
 * (like `rotate(18rad) translate3d(50px, 100px, 10px)`)
 * into a `getComputedStyle(el)`-style matrix string
 * (like `matrix3d(0.6603167082440828, -0.7509872467716737, 0, 0, 0.7509872467716737, 0.6603167082440828, 0, 0, 0, 0, 1, 0, 108.11456008937151, 28.482308485824596, 10, 1)`)
 **/
FirminCSSMatrix.toMatrixString = function (transformValue) {
    var rgx = {
        functionSignature: /(\w+)\([^\)]+\)/ig,
        nameAndArguments: /(\w+)\(([^\)]+)\)/i,
        units: /([-\+]?[0-9]+[\.0-9]*)(deg|rad|grad|px|%)*/
    };
    var transformStatements = transformValue.match(/(\w+)\([^\)]+\)/ig);
    var onlyMatrices = transformStatements && transformStatements.every(function (t) { return (/^matrix/).test(t) });
    if (!transformStatements || onlyMatrices) return transformValue;

    var values = function (o) { return o.value };
    var cssFunctionToJsFunction = {
        matrix: function (m, o) {
            var m2 = new FirminCSSMatrix(o.unparsed);

            return m.multiply(m2)
        },
        matrix3d: function (m, o) {
            var m2 = new FirminCSSMatrix(o.unparsed);

            return m.multiply(m2)
        },

        perspective: function (m, o) {
            var m2 = new FirminCSSMatrix();
            m2.m34 -= 1 / o.value[0].value;

            return m.multiply(m2);
        },

        rotate: function (m, o) {
            return m.rotate.apply(m, o.value.map(values))
        },
        rotate3d: function (m, o) {
            return m.rotateAxisAngle.apply(m, o.value.map(values))
        },
        rotateX: function (m, o) {
            return m.rotate.apply(m, [o.value[0].value, 0, 0]);
        },
        rotateY: function (m, o) {
            return m.rotate.apply(m, [0, o.value[0].value, 0]);
        },
        rotateZ: function (m, o) {
            return m.rotate.apply(m, [0, 0, o.value[0].value]);
        },

        scale: function (m, o) {
            return m.scale.apply(m, o.value.map(values));
        },
        scale3d: function (m, o) {
            return m.scale.apply(m, o.value.map(values));
        },
        scaleX: function (m, o) {
            return m.scale.apply(m, o.value.map(values));
        },
        scaleY: function (m, o) {
            return m.scale.apply(m, [0, o.value[0].value, 0]);
        },
        scaleZ: function (m, o) {
            return m.scale.apply(m, [0, 0, o.value[0].value]);
        },

        skew: function (m, o) {
            var mX = new FirminCSSMatrix('skewX(' + o.value[0].unparsed + ')');
            var mY = new FirminCSSMatrix('skewY(' + o.value[1].unparsed + ')');
            var sM = 'matrix(1.00000, '+ mY.b +', '+ mX.c +', 1.000000, 0.000000, 0.000000)';
            var m2 = new FirminCSSMatrix(sM);

            return m.multiply(m2);
        },
        skewX: function (m, o) {
            return m.skewX.apply(m, [o.value[0].value]);
        },
        skewY: function (m, o) {
            return m.skewY.apply(m, [o.value[0].value]);
        },

        translate: function (m, o) {
            return m.translate.apply(m, o.value.map(values));
        },
        translate3d: function (m, o) {
            return m.translate.apply(m, o.value.map(values));
        },
        translateX: function (m, o) {
            return m.translate.apply(m, [o.value[0].value, 0, 0]);
        },
        translateY: function (m, o) {
            return m.translate.apply(m, [0, o.value[0].value, 0]);
        },
        translateZ: function (m, o) {
            return m.translate.apply(m, [0, 0, o.value[0].value]);
        }
    };
    var parseTransformStatement = function (str) {
        var pair = str.match(rgx.nameAndArguments).slice(1);

        return {
            key: pair[0],
            value: pair[1].split(/, ?/).map(function (value) {
                var parts = value.match(/([-\+]?[0-9]+[\.0-9]*)(deg|rad|grad|px|%)*/) || [];

                return {
                    value: parseFloat(parts[1]),
                    units: parts[2],
                    unparsed: value
                };
            }),
            unparsed: str
        };
    };

    var transformOperations = transformStatements.map(parseTransformStatement);
    var startingMatrix = new FirminCSSMatrix();
    var transformedMatrix = transformOperations.reduce(function (matrix, operation) {
        // convert to degrees b/c all CSSMatrix methods expect degrees
        operation.value = operation.value.map(function (operation) {
            if (operation.units == 'rad') {
                operation.value = operation.value * (180 / Math.PI);
                operation.units = 'deg';
            }
            else if (operation.units == 'grad') {
                operation.value = operation.value / (400 / 360); // 400 gradians in 360 degrees
                operation.units = 'deg'
            }

            return operation;
        });

        var jsFunction = cssFunctionToJsFunction[operation.key];
        var result = jsFunction(matrix, operation);

        return result || matrix;
    }, startingMatrix);

    return transformedMatrix.toString();
};

/**
 *  FirminCSSMatrix#a -> Number
 *  The first 2D vector value.
 **/

/**
 *  FirminCSSMatrix#b -> Number
 *  The second 2D vector value.
 **/

/**
 *  FirminCSSMatrix#c -> Number
 *  The third 2D vector value.
 **/

/**
 *  FirminCSSMatrix#d -> Number
 *  The fourth 2D vector value.
 **/

/**
 *  FirminCSSMatrix#e -> Number
 *  The fifth 2D vector value.
 **/

/**
 *  FirminCSSMatrix#f -> Number
 *  The sixth 2D vector value.
 **/

/**
 *  FirminCSSMatrix#m11 -> Number
 *  The 3D matrix value in the first row and first column.
 **/

/**
 *  FirminCSSMatrix#m12 -> Number
 *  The 3D matrix value in the first row and second column.
 **/

/**
 *  FirminCSSMatrix#m13 -> Number
 *  The 3D matrix value in the first row and third column.
 **/

/**
 *  FirminCSSMatrix#m14 -> Number
 *  The 3D matrix value in the first row and fourth column.
 **/

/**
 *  FirminCSSMatrix#m21 -> Number
 *  The 3D matrix value in the second row and first column.
 **/

/**
 *  FirminCSSMatrix#m22 -> Number
 *  The 3D matrix value in the second row and second column.
 **/

/**
 *  FirminCSSMatrix#m23 -> Number
 *  The 3D matrix value in the second row and third column.
 **/

/**
 *  FirminCSSMatrix#m24 -> Number
 *  The 3D matrix value in the second row and fourth column.
 **/

/**
 *  FirminCSSMatrix#m31 -> Number
 *  The 3D matrix value in the third row and first column.
 **/

/**
 *  FirminCSSMatrix#m32 -> Number
 *  The 3D matrix value in the third row and second column.
 **/

/**
 *  FirminCSSMatrix#m33 -> Number
 *  The 3D matrix value in the third row and third column.
 **/

/**
 *  FirminCSSMatrix#m34 -> Number
 *  The 3D matrix value in the third row and fourth column.
 **/

/**
 *  FirminCSSMatrix#m41 -> Number
 *  The 3D matrix value in the fourth row and first column.
 **/

/**
 *  FirminCSSMatrix#m42 -> Number
 *  The 3D matrix value in the fourth row and second column.
 **/

/**
 *  FirminCSSMatrix#m43 -> Number
 *  The 3D matrix value in the fourth row and third column.
 **/

/**
 *  FirminCSSMatrix#m44 -> Number
 *  The 3D matrix value in the fourth row and fourth column.
 **/

[["m11", "a"],
    ["m12", "b"],
    ["m21", "c"],
    ["m22", "d"],
    ["m41", "e"],
    ["m42", "f"]].forEach(function(pair) {
    var key3d = pair[0], key2d = pair[1];

    Object.defineProperty(FirminCSSMatrix.prototype, key2d, {
        set: function(val) {
            this[key3d] = val;
        },

        get: function() {
            return this[key3d];
        },
        enumerable : true,
        configurable : true
    });
});

/**
 *  FirminCSSMatrix#isAffine() -> Boolean
 *
 *  Determines whether the matrix is affine.
 **/
FirminCSSMatrix.prototype.isAffine = function() {
    return this.m13 === 0 && this.m14 === 0 &&
    this.m23 === 0 && this.m24 === 0 &&
    this.m31 === 0 && this.m32 === 0 &&
    this.m33 === 1 && this.m34 === 0 &&
    this.m43 === 0 && this.m44 === 1;
};

/**
 *  FirminCSSMatrix#multiply(otherMatrix) -> FirminCSSMatrix
 *  - otherMatrix (FirminCSSMatrix): the matrix to multiply this one by.
 *
 *  Multiplies the matrix by a given matrix and returns the result.
 **/
FirminCSSMatrix.prototype.multiply = function(otherMatrix) {
    if (!otherMatrix) return null;

    var a = otherMatrix,
    b = this,
    c = new FirminCSSMatrix();

    c.m11 = a.m11 * b.m11 + a.m12 * b.m21 + a.m13 * b.m31 + a.m14 * b.m41;
    c.m12 = a.m11 * b.m12 + a.m12 * b.m22 + a.m13 * b.m32 + a.m14 * b.m42;
    c.m13 = a.m11 * b.m13 + a.m12 * b.m23 + a.m13 * b.m33 + a.m14 * b.m43;
    c.m14 = a.m11 * b.m14 + a.m12 * b.m24 + a.m13 * b.m34 + a.m14 * b.m44;

    c.m21 = a.m21 * b.m11 + a.m22 * b.m21 + a.m23 * b.m31 + a.m24 * b.m41;
    c.m22 = a.m21 * b.m12 + a.m22 * b.m22 + a.m23 * b.m32 + a.m24 * b.m42;
    c.m23 = a.m21 * b.m13 + a.m22 * b.m23 + a.m23 * b.m33 + a.m24 * b.m43;
    c.m24 = a.m21 * b.m14 + a.m22 * b.m24 + a.m23 * b.m34 + a.m24 * b.m44;

    c.m31 = a.m31 * b.m11 + a.m32 * b.m21 + a.m33 * b.m31 + a.m34 * b.m41;
    c.m32 = a.m31 * b.m12 + a.m32 * b.m22 + a.m33 * b.m32 + a.m34 * b.m42;
    c.m33 = a.m31 * b.m13 + a.m32 * b.m23 + a.m33 * b.m33 + a.m34 * b.m43;
    c.m34 = a.m31 * b.m14 + a.m32 * b.m24 + a.m33 * b.m34 + a.m34 * b.m44;

    c.m41 = a.m41 * b.m11 + a.m42 * b.m21 + a.m43 * b.m31 + a.m44 * b.m41;
    c.m42 = a.m41 * b.m12 + a.m42 * b.m22 + a.m43 * b.m32 + a.m44 * b.m42;
    c.m43 = a.m41 * b.m13 + a.m42 * b.m23 + a.m43 * b.m33 + a.m44 * b.m43;
    c.m44 = a.m41 * b.m14 + a.m42 * b.m24 + a.m43 * b.m34 + a.m44 * b.m44;

    return c;
};

/**
 *  FirminCSSMatrix#isIdentityOrTranslation() -> Boolean
 *
 *  Returns whether the matrix is the identity matrix or a translation matrix.
 **/
FirminCSSMatrix.prototype.isIdentityOrTranslation = function() {
    var t = this;
    return t.m11 === 1 && t.m12 === 0 && t.m13 === 0 && t.m14 === 0 &&
    t.m21 === 0 && t.m22 === 1 && t.m23 === 0 && t.m24 === 0 &&
    t.m31 === 0 && t.m31 === 0 && t.m33 === 1 && t.m34 === 0 &&
        /* m41, m42 and m43 are the translation points */   t.m44 === 1;
};

/**
 *  FirminCSSMatrix#adjoint() -> FirminCSSMatrix
 *
 *  Returns the adjoint matrix.
 **/
FirminCSSMatrix.prototype.adjoint = function() {
    var result = new FirminCSSMatrix(), t = this,
    determinant3x3 = FirminCSSMatrix.determinant3x3,

    a1 = t.m11, b1 = t.m12, c1 = t.m13, d1 = t.m14,
    a2 = t.m21, b2 = t.m22, c2 = t.m23, d2 = t.m24,
    a3 = t.m31, b3 = t.m32, c3 = t.m33, d3 = t.m34,
    a4 = t.m41, b4 = t.m42, c4 = t.m43, d4 = t.m44;

    // Row column labeling reversed since we transpose rows & columns
    result.m11 =  determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4);
    result.m21 = -determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4);
    result.m31 =  determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4);
    result.m41 = -determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);

    result.m12 = -determinant3x3(b1, b3, b4, c1, c3, c4, d1, d3, d4);
    result.m22 =  determinant3x3(a1, a3, a4, c1, c3, c4, d1, d3, d4);
    result.m32 = -determinant3x3(a1, a3, a4, b1, b3, b4, d1, d3, d4);
    result.m42 =  determinant3x3(a1, a3, a4, b1, b3, b4, c1, c3, c4);

    result.m13 =  determinant3x3(b1, b2, b4, c1, c2, c4, d1, d2, d4);
    result.m23 = -determinant3x3(a1, a2, a4, c1, c2, c4, d1, d2, d4);
    result.m33 =  determinant3x3(a1, a2, a4, b1, b2, b4, d1, d2, d4);
    result.m43 = -determinant3x3(a1, a2, a4, b1, b2, b4, c1, c2, c4);

    result.m14 = -determinant3x3(b1, b2, b3, c1, c2, c3, d1, d2, d3);
    result.m24 =  determinant3x3(a1, a2, a3, c1, c2, c3, d1, d2, d3);
    result.m34 = -determinant3x3(a1, a2, a3, b1, b2, b3, d1, d2, d3);
    result.m44 =  determinant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3);

    return result;
};

/**
 *  FirminCSSMatrix#inverse() -> FirminCSSMatrix | null
 *
 *  If the matrix is invertible, returns its inverse, otherwise returns null.
 **/
FirminCSSMatrix.prototype.inverse = function() {
    var inv, det, result, i, j;

    if (this.isIdentityOrTranslation()) {
        inv = new FirminCSSMatrix();

        if (!(this.m41 === 0 && this.m42 === 0 && this.m43 === 0)) {
            inv.m41 = -this.m41;
            inv.m42 = -this.m42;
            inv.m43 = -this.m43;
        }

        return inv;
    }

    // Calculate the adjoint matrix
    result = this.adjoint();

    // Calculate the 4x4 determinant
    det = FirminCSSMatrix.determinant4x4(this);

    // If the determinant is zero, then the inverse matrix is not unique
    if (Math.abs(det) < 1e-8) return null;

    // Scale the adjoint matrix to get the inverse
    for (i = 1; i < 5; i++) {
        for (j = 1; j < 5; j++) {
            result[("m" + i) + j] /= det;
        }
    }

    return result;
};

/**
 *  FirminCSSMatrix#rotate(rotX, rotY, rotZ) -> FirminCSSMatrix
 *  - rotX (Number): the rotation around the x axis.
 *  - rotY (Number): the rotation around the y axis. If undefined, the x
 *    component is used.
 *  - rotZ (Number): the rotation around the z axis. If undefined, the x
 *    component is used.
 *
 *  Returns the result of rotating the matrix by a given vector.
 *
 *  If only the first argument is provided, the matrix is only rotated about
 *  the z axis.
 **/
FirminCSSMatrix.prototype.rotate = function(rx, ry, rz) {
    var degreesToRadians = FirminCSSMatrix.degreesToRadians;

    if (typeof rx != "number" || isNaN(rx)) rx = 0;

    if ((typeof ry != "number" || isNaN(ry)) &&
    (typeof rz != "number" || isNaN(rz))) {
        rz = rx;
        rx = 0;
        ry = 0;
    }

    if (typeof ry != "number" || isNaN(ry)) ry = 0;
    if (typeof rz != "number" || isNaN(rz)) rz = 0;

    rx = degreesToRadians(rx);
    ry = degreesToRadians(ry);
    rz = degreesToRadians(rz);

    var tx = new FirminCSSMatrix(),
    ty = new FirminCSSMatrix(),
    tz = new FirminCSSMatrix(),
    sinA, cosA, sinA2;

    rz /= 2;
    sinA = Math.sin(rz);
    cosA = Math.cos(rz);
    sinA2 = sinA * sinA;

    // Matrices are identity outside the assigned values
    tz.m11 = tz.m22 = 1 - 2 * sinA2;
    tz.m12 = tz.m21 = 2 * sinA * cosA;
    tz.m21 *= -1;

    ry /= 2;
    sinA  = Math.sin(ry);
    cosA  = Math.cos(ry);
    sinA2 = sinA * sinA;

    ty.m11 = ty.m33 = 1 - 2 * sinA2;
    ty.m13 = ty.m31 = 2 * sinA * cosA;
    ty.m13 *= -1;

    rx /= 2;
    sinA = Math.sin(rx);
    cosA = Math.cos(rx);
    sinA2 = sinA * sinA;

    tx.m22 = tx.m33 = 1 - 2 * sinA2;
    tx.m23 = tx.m32 = 2 * sinA * cosA;
    tx.m32 *= -1;

    var isIdentity = (this.toString() === (new FirminCSSMatrix).toString());

    return (isIdentity)
    ? tz.multiply(ty).multiply(tx)
    : this.multiply(tx).multiply(ty).multiply(tz);
};

/**
 *  FirminCSSMatrix#rotateAxisAngle(rotX, rotY, rotZ, angle) -> FirminCSSMatrix
 *  - rotX (Number): the rotation around the x axis.
 *  - rotY (Number): the rotation around the y axis. If undefined, the x
 *    component is used.
 *  - rotZ (Number): the rotation around the z axis. If undefined, the x
 *    component is used.
 *  - angle (Number): the angle of rotation about the axis vector, in degrees.
 *
 *  Returns the result of rotating the matrix around a given vector by a given
 *  angle.
 *
 *  If the given vector is the origin vector then the matrix is rotated by the
 *  given angle around the z axis.
 **/
FirminCSSMatrix.prototype.rotateAxisAngle = function(x, y, z, a) {
    if (typeof x != "number" || isNaN(x)) x = 0;
    if (typeof y != "number" || isNaN(y)) y = 0;
    if (typeof z != "number" || isNaN(z)) z = 0;
    if (typeof a != "number" || isNaN(a)) a = 0;
    if (x === 0 && y === 0 && z === 0) z = 1;

    var t   = new FirminCSSMatrix(),
    len = Math.sqrt(x * x + y * y + z * z),
    cosA, sinA, sinA2, csA, x2, y2, z2;

    a     = (FirminCSSMatrix.degreesToRadians(a) || 0) / 2;
    cosA  = Math.cos(a);
    sinA  = Math.sin(a);
    sinA2 = sinA * sinA;

    // Bad vector, use something sensible
    if (len === 0) {
        x = 0;
        y = 0;
        z = 1;
    } else if (len !== 1) {
        x /= len;
        y /= len;
        z /= len;
    }

    // Optimise cases where axis is along major axis
    if (x === 1 && y === 0 && z === 0) {
        t.m22 = t.m33 = 1 - 2 * sinA2;
        t.m23 = t.m32 = 2 * cosA * sinA;
        t.m32 *= -1;
    } else if (x === 0 && y === 1 && z === 0) {
        t.m11 = t.m33 = 1 - 2 * sinA2;
        t.m13 = t.m31 = 2 * cosA * sinA;
        t.m13 *= -1;
    } else if (x === 0 && y === 0 && z === 1) {
        t.m11 = t.m22 = 1 - 2 * sinA2;
        t.m12 = t.m21 = 2 * cosA * sinA;
        t.m21 *= -1;
    } else {
        csA = sinA * cosA;
        x2  = x * x;
        y2  = y * y;
        z2  = z * z;

        t.m11 = 1 - 2 * (y2 + z2) * sinA2;
        t.m12 = 2 * (x * y * sinA2 + z * csA);
        t.m13 = 2 * (x * z * sinA2 - y * csA);
        t.m21 = 2 * (y * x * sinA2 - z * csA);
        t.m22 = 1 - 2 * (z2 + x2) * sinA2;
        t.m23 = 2 * (y * z * sinA2 + x * csA);
        t.m31 = 2 * (z * x * sinA2 + y * csA);
        t.m32 = 2 * (z * y * sinA2 - x * csA);
        t.m33 = 1 - 2 * (x2 + y2) * sinA2;
    }

    return this.multiply(t);
};

/**
 *  FirminCSSMatrix#scale(scaleX, scaleY, scaleZ) -> FirminCSSMatrix
 *  - scaleX (Number): the scaling factor in the x axis.
 *  - scaleY (Number): the scaling factor in the y axis. If undefined, the x
 *    component is used.
 *  - scaleZ (Number): the scaling factor in the z axis. If undefined, 1 is
 *    used.
 *
 *  Returns the result of scaling the matrix by a given vector.
 **/
FirminCSSMatrix.prototype.scale = function(scaleX, scaleY, scaleZ) {
    var transform = new FirminCSSMatrix();

    if (typeof scaleX != "number" || isNaN(scaleX)) scaleX = 1;
    if (typeof scaleY != "number" || isNaN(scaleY)) scaleY = scaleX;
    if (typeof scaleZ != "number" || isNaN(scaleZ)) scaleZ = 1;

    transform.m11 = scaleX;
    transform.m22 = scaleY;
    transform.m33 = scaleZ;

    return this.multiply(transform);
};

/**
 *  FirminCSSMatrix#skewX(skewX) -> FirminCSSMatrix
 *  - skewX (Number): the scaling factor in the x axis.
 *
 *  Returns the result of skewing the matrix by a given vector.
 **/
FirminCSSMatrix.prototype.skewX = function(degrees) {
    var radians = FirminCSSMatrix.degreesToRadians(degrees);
    var transform = new FirminCSSMatrix();

    transform.c = Math.tan(radians);

    return this.multiply(transform);
};

/**
 *  FirminCSSMatrix#skewY(skewY) -> FirminCSSMatrix
 *  - skewY (Number): the scaling factor in the x axis.
 *
 *  Returns the result of skewing the matrix by a given vector.
 **/
FirminCSSMatrix.prototype.skewY = function(degrees) {
    var radians = FirminCSSMatrix.degreesToRadians(degrees);
    var transform = new FirminCSSMatrix();

    transform.b = Math.tan(radians);

    return this.multiply(transform);
};

/**
 *  FirminCSSMatrix#translate(x, y, z) -> FirminCSSMatrix
 *  - x (Number): the x component of the vector.
 *  - y (Number): the y component of the vector.
 *  - z (Number): the z component of the vector. If undefined, 0 is used.
 *
 *  Returns the result of translating the matrix by a given vector.
 **/
FirminCSSMatrix.prototype.translate = function(x, y, z) {
    var t = new FirminCSSMatrix();

    if (typeof x != "number" || isNaN(x)) x = 0;
    if (typeof y != "number" || isNaN(y)) y = 0;
    if (typeof z != "number" || isNaN(z)) z = 0;

    t.m41 = x;
    t.m42 = y;
    t.m43 = z;

    return this.multiply(t);
};

/**
 *  FirminCSSMatrix#setMatrixValue(domstr) -> undefined
 *  - domstr (String): a string representation of a 2D or 3D transform matrix
 *    in the form given by the CSS transform property, i.e. just like the
 *    output from [[FirminCSSMatrix#toString]].
 *
 *  Sets the matrix values using a string representation, such as that produced
 *  by the [[FirminCSSMatrix#toString]] method.
 **/
FirminCSSMatrix.prototype.setMatrixValue = function(domstr) {
    domstr = FirminCSSMatrix.toMatrixString(domstr.trim());
    var mstr   = domstr.match(/^matrix(3d)?\(\s*(.+)\s*\)$/),
    is3d, chunks, len, points, i, chunk;

    if (!mstr) return;

    is3d   = !!mstr[1];
    chunks = mstr[2].split(/\s*,\s*/);
    len    = chunks.length;
    points = new Array(len);

    if ((is3d && len !== 16) || !(is3d || len === 6)) {
        XML3D.debug.logError("Invalid CSS Matrix: ", domstr);
        return;
    }
    try {
        for (i = 0; i < len; i++) {
            chunk = chunks[i];
            points[i] = parseFloat(chunk);
        }
    } catch(e) {
        XML3D.debug.logError("Invalid CSS Matrix: ", domstr);
        return;
    }
    for (i = 0; i < len; i++) {
        var point = is3d ?
        ("m" + (Math.floor(i / 4) + 1)) + (i % 4 + 1) :
        String.fromCharCode(i + 97); // ASCII char 97 == 'a'
        this[point] = points[i];
    }
};

/**
 *  FirminCSSMatrix#toString() -> String
 *
 *  Returns a string representation of the matrix.
 **/
FirminCSSMatrix.prototype.toString = function() {
    var self = this, points, prefix;

    if (this.isAffine()) {
        prefix = "matrix(";
        points = ["a", "b", "c", "d", "e", "f"];
    } else {
        prefix = "matrix3d(";
        points = ["m11", "m12", "m13", "m14",
            "m21", "m22", "m23", "m24",
            "m31", "m32", "m33", "m34",
            "m41", "m42", "m43", "m44"];
    }

    return prefix + points.map(function(p) {
        return self[p].toFixed(6);
    }).join(", ") + ")";
};

module.exports = FirminCSSMatrix;


},{}],181:[function(require,module,exports){
var printStackTrace = require("../contrib/stacktrace-0.4.js");
var Options = require("./options.js");
var assert = require("assert");

(function (ns) {

    var OPTION_LOGLEVEL = "loglevel";
    Options.register(OPTION_LOGLEVEL, "warning");

    ns.exports = {
        ALL: 0,
        DEBUG: 1,
        INFO: 2,
        WARNING: 3,
        ISSUE: 4,
        ERROR: 5,
        EXCEPTION: 6,
        params: {},
        isSetup: false,
        loglevel: 5,
        loglevels: {
            all: 0,
            debug: 1,
            info: 2,
            warning: 3,
            issue: 4,
            error: 5,
            exception: 6
        },

        setup: function () {
            var debug = XML3D.debug;
            if (!debug.isSetup) {
                debug.isSetup = true;
                debug.loglevel = debug.loglevels[Options.getValue(OPTION_LOGLEVEL)] || 3;
                Options.addObserver(function(key, value) {
                    if(key == OPTION_LOGLEVEL) {
                        debug.loglevel = debug.loglevels[value] || 3;
                    }
                })
            }
            return true;
        },
        _setLogLevel: function() {
        },
        doLog: function (logType, args) {
            var params = XML3D.debug.params;
            if (params.xml3d_nolog || logType < XML3D.debug.loglevel) {
                return;
            }
            args = Array.prototype.slice.call(args);
            if (window.console) {
                switch (logType) {
                    case XML3D.debug.INFO:
                        window.console.info.apply(window.console, args);
                        break;
                    case XML3D.debug.WARNING:
                        window.console.warn.apply(window.console, args);
                        break;
                    case XML3D.debug.ERROR:
                        window.console.error.apply(window.console, args);
                        break;
                    case XML3D.debug.EXCEPTION:
                        window.console.error(printStackTrace({e: args[0], guess: true}).join('\n'));
                        break;
                    case XML3D.debug.DEBUG:
                        window.console.debug.apply(window.console, args);
                        break;
                    case XML3D.debug.ISSUE:
                        assert(args[1] !== undefined, "Github issue number must be specified.");
                        var issue = args[0] + "\nMore information can be found at https://github.com/xml3d/xml3d.js/issues/" + args[1];
                        window.console.error(issue);
                        break;
                    default:
                        break;
                }
            }
        },
        logDebug: function () {
            XML3D.debug.doLog(XML3D.debug.DEBUG, arguments);
        },
        logInfo: function () {
            XML3D.debug.doLog(XML3D.debug.INFO, arguments);
        },
        logWarning: function () {
            XML3D.debug.doLog(XML3D.debug.WARNING, arguments);
        },
        logError: function () {
            XML3D.debug.doLog(XML3D.debug.ERROR, arguments);
        },
        logIssue: function() {
            XML3D.debug.doLog(XML3D.debug.ISSUE, arguments);
        },
        logException: function () {
            XML3D.debug.doLog(XML3D.debug.EXCEPTION, arguments);
        },
        assert: assert,
        trace: function (msg, logType) {
            logType = logType !== undefined ? logType : XML3D.debug.ERROR;
            if (window.console.trace) {
                if (msg) {
                    XML3D.debug.doLog(logType, [msg]);
                }
                window.console.trace();
            } else {
                var stack = printStackTrace();
                msg && stack.splice(0, 0, msg);
                XML3D.debug.doLog(logType, stack);
            }
        },
        getNumberWithPadding: function (number, width) {
            var res = "" + number;
            while (res.length < width) res = " " + res;
            return res;
        },
        formatSourceCode: function (source) {
            var result = "";
            var sourceLines = source.split("\n");
            for (var i = 0; i < sourceLines.length; ++i) {
                result += this.getNumberWithPadding(i + 1, 3) + "  " + sourceLines[i] + "\n";
            }
            return result;
        }
    };

}(module));

},{"../contrib/stacktrace-0.4.js":51,"./options.js":183,"assert":11}],182:[function(require,module,exports){
// utils/misc.js

(function(exports) {


    /**
     * This function sends single or multiple adapter functions by calling functions
     * specified in funcs parameter for each adapter associated with the node.
     *
     * funcs parameter is used as a dictionary where each key is used as name of a
     * adapter function to call, and corresponding value is a list of arguments
     * (i.e. must be an array). For example sendAdapterEvent(node, {method : [1,2,3]})
     * will call function 'method' with arguments 1,2,3 for each adapter of the node.
     *
     * @param {Object} node
     * @param {Object} funcs
     * @return {Array} array of all returned values
     */
    exports.callAdapterFunc = function(node, funcs) {
        var result = [];
        if (!node || node._configured === undefined)
            return result;
        var adapters = node._configured.adapters;
        for (var adapter in adapters) {
            for (var func in funcs) {
                var adapterObject = adapters[adapter];
                var eventHandler = adapterObject[func];
                if (eventHandler) {
                    result.push(eventHandler.apply(adapterObject, funcs[func]));
                }
            }
        }
        return result;
    };

    /**
     * This function sends single or multiple adapter events by calling functions
     * specified in events parameter for each adapter associated with the node.
     *
     * events parameter is used as a dictionary where each key is used as name of a
     * adapter function to call, and corresponding value is a list of arguments
     * (i.e. must be an array). For example sendAdapterEvent(node, {method : [1,2,3]})
     * will call function 'method' with arguments 1,2,3 for each adapter of the node.
     *
     * @param {Object} node
     * @param {Object} events
     * @return {Boolean} false if node is not configured.
     */
    exports.sendAdapterEvent = function(node, events) {
        if (!node || node._configured === undefined)
            return false;
        var adapters = node._configured.adapters;
        for (var adapter in adapters) {
            for (var event in events) {
                var eventHandler = adapters[adapter][event];
                if (eventHandler) {
                    eventHandler.apply(adapters[adapter], events[event]);
                }
            }
        }
        return true;
    };

    /**
     *
     * Dispatch custom HTML event
     *
     * @param {Object} target element or document.
     * @param {string} eventType custom event type.
     * @param {boolean} canBubble Whether the event propagates upward. Sets the value for the bubbles property.
     * @param {boolean} cancelable Whether the event is cancelable and so preventDefault can be called. Sets the value
     *                  for the cancelable property.
     * @param {Object} detail A user-defined object that can contain additional information about the event.
     *                        This parameter can be of any type, or null. This value is returned in the detail property of the event.
     */
    exports.dispatchCustomEvent = function(target, eventType, canBubble, cancelable, detail) {
        var event = document.createEvent('CustomEvent');
        event.initCustomEvent(eventType, canBubble, cancelable, detail);
        return target.dispatchEvent(event);
    };

    /** Dispatch HTML event
     *
     * @param {Object} target    element or document
     * @param {string} eventType standard event type e.g. load, click
     */
    exports.dispatchEvent = function(target, eventType) {
        var evt = null;
        if (document.createEvent) {
                evt = document.createEvent("Events");
                evt.initEvent(eventType, true, true);
                return target.dispatchEvent(evt);
            } else if (document.createEventObject) {
                evt = document.createEventObject();
                return target.fireEvent('on' + eventType, evt);
            }
        };

    var tmpCanvas, tmpContext;

    exports.toImageData = function(imageData) {
        if(imageData instanceof ImageData)
            return imageData;
        if(!imageData.data)
            throw new Error("no data property");
        if(!imageData.width)
            throw new Error("no width property");
        if(!imageData.height)
            throw new Error("no height property");
        if(!tmpContext) {
            tmpCanvas = document.createElement('canvas');
            tmpContext = tmpCanvas.getContext('2d');
        }
        var newImageData = tmpContext.createImageData(imageData.width, imageData.height);
        for(var i = 0; i < imageData.data.length; ++i) {
            var v = imageData.data[i];
            if(v > 255)
                v = 255;
            if(v < 0)
                v = 0;
            newImageData.data[i] = v;
        }
        return newImageData;
    };

    exports.elementIs = function(elem, name) {
        return elem && elem.tagName.toLowerCase() === name;
    };

    exports.encodeZIndex = function(zIndex, isLeafNode) {
        if (zIndex === "auto" || zIndex === "" || zIndex === "0") {
            if (isLeafNode) {
                zIndex = "0"; // Always give leaf nodes an implicit stacking context with z-index of 0 to ensure they compare properly with negative z-index leaf nodes
            } else {
                return ""; // Otherwise this group node does not create a new stacking context, so we can return an empty string
            }
        }
        // Pad with enough zeros to cover the maximum/minimum values (2147483647) for correct string compare results in the sorting step
        zIndex = "0000000000" + zIndex;
        zIndex = zIndex.slice(zIndex.length - 10); // 10 is the number of digits in the max value
        return zIndex;
    }

}(module.exports));

},{}],183:[function(require,module,exports){
(function (ns) {

    /**
     * Class to handle options. Currently only used for global options, could
     * be extended to work hierarchically to configure other elements.
     * @constructor
     */
    var Options = function () {
        this._options = {};
        this._listeners = { "*": [] };
    };

    Options.prototype = {
        register: function (key, defaultValue) {
            if (this._options.hasOwnProperty(key))
                throw new Error("Option already registered '" + key + "'");
            this._options[key] = {
                currentValue: defaultValue,
                defaultValue: defaultValue
            };
        },
        resetValue: function (key) {
            if (!this._options.hasOwnProperty(key))
                throw new Error("Invalid configuration key '" + key + "'");
            this._options[key].currentValue = this._options[key].defaultValue;
            this.notifyObservers(key, this._options[key].currentValue);
        },
        setValue: function (key, value) {
            if (!this._options.hasOwnProperty(key))
                throw new Error("Invalid configuration key '" + key + "'");
            this._options[key].currentValue = value;
            this.notifyObservers(key, value);
        },
        getValue: function (key) {
            if (!this._options.hasOwnProperty(key)) {
                throw new Error("Invalid configuration key '" + key + "'");
            }
            return this._options[key].currentValue;
        },
        getKeys: function () {
            return Object.keys(this._options);
        },
        notifyObservers: function (key, value) {
            // Notify specific observers
            if(this._listeners.hasOwnProperty(key)) {
                this._listeners[key].forEach(function(l) {
                   l(key, value);
                });
            }
            // Notify generic observers
            this._listeners["*"].forEach(function(l) {
               l(key, value);
            });
        },
        addObserver: function (key, observer) {
            if(typeof key == 'function') {
                observer = key;
                key = "*"
            }
            if(!this._options.hasOwnProperty(key) && key !== "*") {
                throw new Error("Can't register to unknown option '" + key + "'");
            }
            if(!this._listeners.hasOwnProperty(key)) {
                this._listeners[key] = [];
            }
            this._listeners[key].push(observer);
        },
        removeObserver: function (observer) {
            for(var filter in this._listeners) {
                var listeners = this._listeners[filter];
                var idx = listeners.indexOf(observer);
                if (idx != -1)
                    listeners.splice(idx, 1);
            }

        }
    };

    var GlobalOptions = new Options();

    GlobalOptions.setOptionsFromQuery = function () {
        var p = window.location.search.substr(1).split('&');

        p.forEach(function (e) {
            var keyVal = e.split('=');
            try {
                var key = keyVal[0].toLowerCase();
                if (key.indexOf("xml3d-") === 0) {
                    var value = decodeURIComponent(keyVal[1]);
                    try {
                        value = JSON.parse(value);
                    } catch (e) {
                        // Do nothing
                    }
                    XML3D.options.setValue(key.substr(6), value);
                }
            } catch (e) {
                XML3D.debug && XML3D.debug.logError(e);
            }
        });
    };

    ns.exports = GlobalOptions;

}(module));

},{}],184:[function(require,module,exports){
(function(exports) {
    /**
     * Class URI
     * @constructor
     * @param {string} str The URI as string
     */
    var URI = function (str) {
        str = str || "";
        if (str.indexOf("blob:") == 0) {
            // Based on http://www.w3.org/TR/FileAPI/#url
            var parser = /^(?:([^:\/?\#]+):)?([^\#]*)(?:\#(.*))?/;
            var result = str.match(parser);
            /**  @type {boolean} */
            this.valid = result != null;
            /**  @type {?string} */
            this.scheme = result[1] || null;
            /**  @type {?string} */
            this.authority = null;
            /**  @type {?string} */
            this.path = null;
            /**  @type {?string} */
            this.query = null;
            /**  @type {?string} */
            this.opaqueString = result[2] || null;
            /**  @type {?string} */
            this.fragment = result[3] || null;
        } else {
            // Based on the regex in RFC2396 Appendix B.
            var parser = /^(?:([^:\/?\#]+):)?(?:\/\/([^\/?\#]*))?([^?\#]*)(?:\?([^\#]*))?(?:\#(.*))?/;
            var result = str.match(parser);
            /**  @type {boolean} */
            this.valid = result != null;
            /**  @type {?string} */
            this.scheme = result[1] || null;
            /**  @type {?string} */
            this.authority = result[2] || null;
            /**  @type {?string} */
            this.path = result[3] || null;
            /**  @type {?string} */
            this.query = result[4] || null;
            /**  @type {?string} */
            this.opaqueString = null;
            /**  @type {?string} */
            this.fragment = result[5] || null;
        }
    };

    /**
     * @return {boolean} true if URI is relative to current document
     */
    URI.prototype.isLocal = function () {
        return this.scheme != "blob" && !this.authority && !this.path;
    }

    /**
     * @return {boolean} true if URI is absolute
     */
    URI.prototype.isAbsolute = function () {
        return this.scheme != null;
    }

    /**
     * Get absolute URI relative to the provided document uri
     * @param {string} docUri uri of document from which this uri originates
     * @returns {URI}
     */
    URI.prototype.getAbsoluteURI = function (docUri) {
        if (!this.valid || this.isAbsolute()) {
            return this;
        }

        var docUriObj = new URI(docUri);

        if (this.path) {
            if (this.path.indexOf("/") == 0) {
                docUriObj.path = this.path;
            } else {
                docUriObj.path = docUriObj.path.substr(0, docUriObj.path.lastIndexOf("/") + 1) + this.path;
            }
            docUriObj.query = this.query;
        } else if (this.query) {
            docUriObj.query = this.query;
        }
        docUriObj.fragment = this.fragment;

        return docUriObj;
    }

    /**
     * Returns if this URI has the same origin as the provided reference
     * @param {URI|string} other
     * @returns {boolean}
     */
    URI.prototype.hasSameOrigin = function (other) {
        if (typeof other == 'string')
            other = new URI(other);

        if (this.scheme == "blob" || this.scheme == "data") {
            return true;
        }

        return this.scheme == other.scheme && this.authority == other.authority;
    };


// Restore the URI to it's stringy glory.
    URI.prototype.toString = function () {
        var str = "";
        if (this.scheme == "blob") {
            str = "blob:" + this.opaqueString;
            if (this.fragment) {
                str += "#" + this.fragment;
            }
            return str;
        }
        if (this.scheme) {
            str += this.scheme + ":";
        }
        if (this.authority) {
            str += "//" + this.authority;
        }
        if (this.path) {
            str += this.path;
        }
        if (this.query) {
            str += "?" + this.query;
        }
        if (this.fragment) {
            str += "#" + this.fragment;
        }
        return str;
    };

// Restore the URI to it's stringy glory minus the fragment
    URI.prototype.toStringWithoutFragment = function () {
        var str = "";
        if (this.scheme == "blob") {
            str = "blob:" + this.opaqueString;
            return str;
        }
        if (this.scheme) {
            str += this.scheme + ":";
        }
        if (this.authority) {
            str += "//" + this.authority;
        }
        if (this.path) {
            str += this.path;
        }
        if (this.query) {
            str += "?" + this.query;
        }
        return str;
    };

    /**
     * Class URIResolver
     * @constructor
     */
    var URIResolver = function () {
    };

    /**
     * Resolve a local URI to an element
     * @param {(string|URI)} uri Element to resolve
     * @param {Document=} document Base document to use
     * @return {Element} The resolved element or null if it could not be resolved
     */
    URIResolver.resolveLocal = function (uri, document) {
        if (typeof uri == 'string')
            uri = new URI(uri);
        document = document || window.document;

        if (uri.scheme == 'urn' || uri.scheme == "blob") {
            return null;
        }

        if (!uri.path && uri.fragment) { // local uri
            return document.getElementById(uri.fragment);
        }
        return null;
    };


    /**
     * @deprecated
     */
    URIResolver.resolve = function (uri, document) {
        XML3D.debug.logWarning("You are using deprecated XML3D.URIResolver.resolve. Use XML3D.URIResolver.resolveLocal instead.");
        return URIResolver.resolveLocal(uri, document);
    };

    exports.URI = URI;
    exports.URIResolver = URIResolver;

}(module.exports));

},{}],185:[function(require,module,exports){
//TODO: Helpful API methods concerning WebCL will be added when needed. Please provide feedback!

/**
 * @file WebCL API. Provides useful methods for initialising and utilising the WebCL platform.
 * @version 0.2
 * @author Toni Dahl
 */

(function (namespace, undefined) {

    var platforms = [],
        devices = [],
        ctx = null,

        WebCLNamespaceAvailable = false,
        OpenCLDriversAvailable = false;

    /**
     *     @constant {string} DEFAULT_DEVICE
     *     @default "CPU"
     */
    var DEFAULT_DEVICE = "CPU",

        /**
         *     @readonly
         *     @name CL_ERROR_CODES
         *     @enum {number}
         */
            CL_ERROR_CODES = {
            "SUCCESS": 0,
            "DEVICE_NOT_FOUND": -1,
            "DEVICE_NOT_AVAILABLE": -2,
            "COMPILER_NOT_AVAILABLE": -3,
            "MEM_OBJECT_ALLOCATION_FAILURE": -4,
            "OUT_OF_RESOURCES": -5,
            "OUT_OF_HOST_MEMORY": -6,
            "PROFILING_INFO_NOT_AVAILABLE": -7,
            "MEM_COPY_OVERLAP": -8,
            "IMAGE_FORMAT_MISMATCH": -9,
            "IMAGE_FORMAT_NOT_SUPPORTED": -10,
            "BUILD_PROGRAM_FAILURE": -11,
            "MAP_FAILURE": -12,
            "INVALID_VALUE": -30,
            "INVALID_DEVICE_TYPE": -31,
            "INVALID_PLATFORM": -32,
            "INVALID_DEVICE": -33,
            "INVALID_CONTEXT": -34,
            "INVALID_QUEUE_PROPERTIES": -35,
            "INVALID_COMMAND_QUEUE": -36,
            "INVALID_HOST_PTR": -37,
            "INVALID_MEM_OBJECT": -38,
            "INVALID_IMAGE_FORMAT_DESCRIPTOR": -39,
            "INVALID_IMAGE_SIZE": -40,
            "INVALID_SAMPLER": -41,
            "INVALID_BINARY": -42,
            "INVALID_BUILD_OPTIONS": -43,
            "INVALID_PROGRAM": -44,
            "INVALID_PROGRAM_EXECUTABLE": -45,
            "INVALID_KERNEL_NAME": -46,
            "INVALID_KERNEL_DEFINITION": -47,
            "INVALID_KERNEL": -48,
            "INVALID_ARG_INDEX": -49,
            "INVALID_ARG_VALUE": -50,
            "INVALID_ARG_SIZE": -51,
            "INVALID_KERNEL_ARGS": -52,
            "INVALID_WORK_DIMENSION": -53,
            "INVALID_WORK_GROUP_SIZE": -54,
            "INVALID_WORK_ITEM_SIZE": -55,
            "INVALID_GLOBAL_OFFSET": -56,
            "INVALID_EVENT_WAIT_LIST": -57,
            "INVALID_EVENT": -58,
            "INVALID_OPERATION": -59,
            "INVALID_GL_OBJECT": -60,
            "INVALID_BUFFER_SIZE": -61,
            "INVALID_MIP_LEVEL": -62,
            "INVALID_GLOBAL_WORK_SIZE": -63
        };
    Object.freeze(CL_ERROR_CODES);


    function isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    /**
     * Returns a CL error name corresponding to a CL error code
     *
     * @function XML3D.webcl~getCLErrorName
     * @param {number} errorCode
     * @returns {string}
     */

    function getCLErrorName(errorCode) {
        var prop;

        if (isNumber(errorCode)) {
            for (prop in CL_ERROR_CODES) {
                if (CL_ERROR_CODES[prop] === errorCode) {
                    return prop;
                }
            }
            XML3D.debug.logDebug("Got unknown OpenCL Error Code:", errorCode);
        }

        return "UNKNOWN_ERROR";
    }

    /**
     * Gets an error code from a CL error message (thrown by Nokia WebCL Plugin)
     *
     * @param e
     * @returns {Integer|Boolean}
     */

    function getErrorCodeFromCLError(e) {
        var code = null;

        if (e.name && typeof e.name === "string") {
            if (CL_ERROR_CODES[e.name]) {
                return CL_ERROR_CODES[e.name];
            }
        }
        if (e.message && typeof e.message === "string") {
            code = e.message.match(/-?\d+/g);

            if (code instanceof Array) {
                return parseInt(code[code.length - 1], 10);
            }
        }

        return false;
    }

    /**
     * Creates instance of WebCLError
     *
     * @constructor XML3D.webcl~WebCLError
     * @param {string} [name="WebCLError"] Error name
     * @param {string} [msg="Generic WebCL error."] The desired error message
     */

    function WebCLError(name, msg) {
        if (name && typeof name !== "string") {
            XML3D.debug.logDebug("WebCL API: WebCLError: Error name not type of String");
            name = "";
        }

        if (msg && typeof msg !== "string") {
            XML3D.debug.logDebug("WebCL API: WebCLError: Error message not type of String");
            msg = "";
        }

        this.name = name || "WebCLError";
        this.message = msg || "Generic WebCL error.";
        this.stack = (new Error()).stack;
    }

    WebCLError.prototype = Object.create(Error.prototype);
    WebCLError.prototype.constructor = WebCLError;


    /**
     * Checks if WebCL namespace is available. The namespace can be provided by a WebCL plugin or native implementation.
     *
     * @function XML3D.webcl~hasWebCLNamespace
     * @returns {Boolean}
     */

    function hasWebCLNamespace() {
        WebCLNamespaceAvailable = window.webcl && webcl.getPlatforms;

        return WebCLNamespaceAvailable;

    }

    /**
     * Tests a basic WebCL method to see if the OpenCL drivers are working on users device.
     *
     * @function XML3D.webcl~hasOpenCLDrivers
     * @returns {Boolean}
     */

    function hasOpenCLDrivers() {
        var platArr;
        OpenCLDriversAvailable = true;

        try {
            platArr = webcl.getPlatforms();
        } catch (e) {
            OpenCLDriversAvailable = false;
        }

        if (!platArr || platArr.length === 0) {
            OpenCLDriversAvailable = false;
        }

        return OpenCLDriversAvailable;

    }

    /**
     * Combines WebCL namespace and driver test.
     *
     * @function XML3D.webcl~isAvailable
     * @returns {Boolean}
     */

    function isAvailable() {
        return hasWebCLNamespace() && hasOpenCLDrivers();
    }


    /**
     * Initialises the WebCL API with default values using a predefined device type or a default device type.
     *
     * @function XML3D.webcl~init
     * @param {string} [type="CPU"] Device type
     * @return {Boolean}
     */

    function init(type) {
        // Checking if WebCL is available in the users system
        if (!hasWebCLNamespace()) {
            XML3D.debug.logWarning("WebCL API: Unfortunately your system does not support WebCL. " +
                "WebCL namespace is not available.");
            return false;
        }

        if (!hasOpenCLDrivers()) {
            XML3D.debug.logWarning("WebCL API: Unfortunately your system does not support WebCL. " +
                "OpenCL drivers are not working properly.");
            return false;
        }

        getPlatforms();

        devices = getDevicesByType(type || DEFAULT_DEVICE);

        // Creating default context
        ctx = createContext(devices);

        return true;
    }

    /**
     * Returns all available WebCL device platforms.
     *
     * @function XML3D.webcl~getPlatforms
     * @returns {Array}
     */

    function getPlatforms() {
        if(platforms.length === 0) {
            platforms = webcl.getPlatforms();
        }

        return platforms;
    }

    /**
     * Returns all devices of a chosen type from a selected platform.
     *
     * @param {string} [type="CPU"] Device type
     * @param {IWebCLPlatform} platform
     * @returns {Array|Boolean}
     */

    function getPlatformDevicesByType(type, platform) {
        var deviceArr = [], errCode;

        if (!platform) {
            XML3D.debug.logError("WebCL API: getPlatformDevicesByType(): platform was not defined.");
            return false;
        }

        type = type || DEFAULT_DEVICE;

        try {
            if (type === "CPU") {
                deviceArr = platform.getDevices(webcl.DEVICE_TYPE_CPU);
            } else if (type === "GPU") {
                deviceArr = platform.getDevices(webcl.DEVICE_TYPE_GPU);
            } else if (type === "ALL") {
                deviceArr = platform.getDevices(webcl.DEVICE_TYPE_ALL);
            }

        } catch (e) {
            errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            } else if (errCode !== CL_ERROR_CODES.DEVICE_NOT_FOUND) {
                throw new WebCLError(getCLErrorName(errCode), "Could not get devices.");
            }

            return false;
        }

        return deviceArr;
    }

    /**
     * Gets all devices of a selected type from all available platforms.
     *
     * @function XML3D.webcl~getDevicesByType
     * @param {string} type Device type
     * @returns {Array|Boolean}
     */

    function getDevicesByType(type) {
        var resultArr = [], deviceArr, i;

        getPlatforms();

        for (i = platforms.length; i--;) {
            deviceArr = getPlatformDevicesByType(type, platforms[i]);

            if (deviceArr) {
                deviceArr.forEach(function (v) {
                    resultArr.push(v);
                });
            }
        }
        return resultArr.length === 0 ? false : resultArr;
    }


    /**
     * Gets the platform on where the device is.
     *
     * @function XML3D.webcl~getDevicePlatform
     * @param {IWebCLDevice} device
     * @returns {IWebCLPlatform|Boolean}
     */

    function getDevicePlatform(device) {
        var platform;

        if (!device) {
            XML3D.debug.logError("WebCL API: getDevicePlatform(): device was not defined.");
            return false;
        }

        try {
            platform = device.getInfo(webcl.DEVICE_PLATFORM);
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }

            throw new WebCLError(getCLErrorName(errCode), "Could not get the platform of the device.");
        }

        return platform;
    }

    /**
     *
     * @param clCtx
     * @returns {boolean}
     */

    function getContextDevices(clCtx) {
        var deviceArr = [], errCode;

        if(!clCtx) {
            XML3D.debug.logError("WebCL API: getContextDevices(): clCtx was not defined.");
            return false;
        }

        try {
            deviceArr = clCtx.getInfo(webcl.CONTEXT_DEVICES);
        }catch(e) {
            errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            } else {
                throw new WebCLError(getCLErrorName(errCode), "Could not get devices.");
            }

        }

        return deviceArr.length === 0 ? false : deviceArr;
    }

    /**
     * Creates a WebCL context
     *
     * @function XML3D.webcl~createContext
     * @param {object} [properties]
     * @returns {IWebCLContext}
     */

    function createContext(properties) {
      /*
        var props = {
            devices: getDevicesByType(DEFAULT_DEVICE)
            }, context;

        XML3D.extend(props, properties);*/

        try {
            var context = webcl.createContext(properties);
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }
            throw new WebCLError(getCLErrorName(errCode), "Failed to create a WebCL context.");
        }

        return context;
    }

    /**
     * Gets the default WebCL context.
     *
     * @function XML3D.webcl~getDefaultContext
     * @returns {IWebCLContext}
     */

    function getDefaultContext() {
        return ctx;
    }


    /**
     * Creates a WebCL program from a string of WebCL code.
     *
     * @function XML3D.webcl~createProgram
     * @param {string} codeStr
     * @param {IWebCLContext} clCtx
     * @returns {IWebCLProgram | Boolean}
     */

    function createProgram(codeStr, clCtx) {
        var program;

        clCtx = clCtx || ctx;

        if (!codeStr) {
            XML3D.debug.logError("WebCL API: createProgram(): codeStr was not defined.");
            return false;
        }

        if (!clCtx) {
            XML3D.debug.logError("WebCL API: createProgram(): clCtx was not defined.");
            return false;
        }

        try {
            program = clCtx.createProgram(codeStr);
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }

            throw new WebCLError(getCLErrorName(errCode), "Failed to create a WebCL program.");
        }

        return program;
    }

    /**
     * Builds a WebCL program.
     *
     * @function XML3D.webcl~buildProgram
     * @param {IWebCLProgram} program
     * @param {Array} deviceArr
     * @returns {IWebCLProgram|Boolean}
     */

    function buildProgram(program, deviceArr) {
        deviceArr = deviceArr || devices;

        if (!program) {
            XML3D.debug.logError("WebCL API: buildProgram(): program was not defined.");
            return false;
        }

        try {
            program.build(deviceArr, "");
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }
            throw new WebCLError(getCLErrorName(errCode),
                program.getBuildInfo(deviceArr[0], WebCL.PROGRAM_BUILD_LOG));
        }

        return program;
    }

    /**
     * Creates a WebCL Kernel using a defined program.
     *
     * @function XML3D.webcl~createKernel
     * @param {IWebCLProgram} program
     * @param {string} name
     * @returns {IWebCLKernel|Boolean}
     */

    function createKernel(program, name) {
        var kernel;

        if (!program) {
            XML3D.debug.logError("WebCL API: createKernel(): program was not defined.");
            return false;
        }

        if (!name) {
            XML3D.debug.logError("WebCL API: createKernel(): name was not defined.");
            return false;
        }

        try {
            kernel = program.createKernel(name);
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }
            throw new WebCLError(getCLErrorName(errCode), "Failed to create a WebCL kernel.");
        }

        return kernel;
    }

    /**
     * Creates a WebCL Command Queue for queueing kernels for execution.
     *
     * @function XML3D.webcl~createCommandQueue
     * @param {IWebCLDevice} device
     * @param {IWebCLContext} clCtx
     * @returns {IWebCLCommandQueue|Boolean}
     */

    function createCommandQueue(device, clCtx) {
        var cmdQueue;

        clCtx = clCtx || ctx;

        if(!clCtx) {
            XML3D.debug.logError("WebCL API: createCommandQueue: clCtx was not defined");
            return false;
        }

        try {
            cmdQueue = clCtx.createCommandQueue(device || devices[0], 0);
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }
            throw new WebCLError(getCLErrorName(getErrorCodeFromCLError(e)), "Could not create CommandQueue.");
        }

        return cmdQueue;
    }

    /**
     * Creates an input/output buffer to be used with a WebCL kernel
     *
     * @function XML3D.webcl~createBuffer
     * @param {int} size
     * @param {string} type
     * @param {IWebCLContext} clCtx
     * @returns {IWebCLMemoryObject|Boolean}
     */

    function createBuffer(size, type, clCtx) {
        clCtx = clCtx || ctx;

        if (!size) {
            XML3D.debug.logError("WebCL API: createBuffer(): Buffer size was not defined.");
            return false;
        }else if (!isNumber(size) || size < 0) {
            XML3D.debug.logError("WebCL API: createBuffer(): Buffer size must be a positive number.");
            return false;
        }

        if (!type) {
            XML3D.debug.logError("WebCL API: createBuffer(): Buffer type was not defined.");
            return false;
        }

        if(!clCtx) {
            XML3D.debug.logError("WebCL API: createBuffer(): clCtx was not defined.");
            return false;
        }

        try {
            if (type === "r") {
                return clCtx.createBuffer(webcl.MEM_READ_ONLY, size);
            } else if (type === "w") {
                return clCtx.createBuffer(webcl.MEM_WRITE_ONLY, size);
            } else if (type === "rw") {
                return clCtx.createBuffer(webcl.MEM_READ_WRITE, size);
            } else {
                XML3D.debug.logError("WebCL API: createBuffer(): Unknown buffer type:", type);
                return false;
            }
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }
            throw new WebCLError(getCLErrorName(errCode), "Could not create a WebCL buffer.");
        }
    }

    /**
     * Creates an instance of KernelManager.
     *
     * @name KernelManager
     * @constructor XML3D.webcl~KernelManager
     */

    var KernelManager = function (clCtx, deviceArr) {
        var kernels = {};

        return {

            /**
             * Creates and builds a WebCL program from a code string and creates a WebCL kernel from the program.
             *
             * @function KernelManager~register
             * @param {string} name
             * @param {string} codeStr
             */

            register: function (name, codeStr) {
                if (kernels.hasOwnProperty(name)) {
                    XML3D.debug.logWarning("WebCL API: kernels.register(): Kernel with a same name is already defined.");
                    return false;
                }

                if (typeof name !== "string") {
                    XML3D.debug.logError("WebCL API: kernels.register(): Kernel name was not defined or was not type of String.");
                    return false;
                }

                if (typeof codeStr !== "string") {
                    XML3D.debug.logError("WebCL API: kernels.register(): Kernel code was not defined or was not type of String.");
                    return false;
                }

                var program, kernel;

                program = createProgram(codeStr, clCtx);

                buildProgram(program, deviceArr);

                if (program) {
                    kernel = createKernel(program, name);
                }

                if (kernel) {
                    kernels[name] = kernel;

                    return true;
                }

                return false;

            },

            /**
             * Deallocates and unregisters a kernel.
             *
             * @function KernelManager~unRegister
             * @param {string} name
             */

            unRegister: function (name) {
                if (kernels.hasOwnProperty(name)) {
                    try {
                        kernels[name].release();
                    } catch (e) {
                        var errCode = getErrorCodeFromCLError(e);

                        if (!errCode) {
                            throw e;
                        }

                        throw new WebCLError(getCLErrorName(errCode), "Could not release kernel resources.");
                    }
                    delete kernels[name];

                    return true;
                }

                return false;
            },

            /**
             * Gets a kernel of a specified name.
             *
             * @function KernelManager~getKernel
             * @param {string} name
             * @returns {IWebCLKernel | Boolean}
             */

            getKernel: function (name) {
                if (typeof name !== "string") {
                    return false;
                }

                if (kernels.hasOwnProperty(name)) {
                    return kernels[name];
                }

                return false;
            },

            /**
             * Sets arguments of a specified kernel.
             * The first argument of this function is a registered kernel name, other arguments are the kernel arguments respectively.
             *
             * @function KernelManager~setArgs
             * @param {IWebCLKernel} kernel WebCL kernel
             * @param {...*} args Kernel arguments in the same order as defined in the kernel code
             * @returns {boolean}
             */

            setArgs: function () {
                var args = Array.prototype.slice.call(arguments),
                    kernel, inputArgs, nKernelArgs, i;

                if (args.length < 2) {
                    XML3D.debug.logWarning("WebCL API: setArgs(): No kernel arguments were defined.");
                    return false;
                }

                kernel = args[0];
                inputArgs = args.slice(1);

                if (!kernel) {
                    XML3D.debug.logWarning("WebCL API: setArgs(): WebCL kernel was not defined.");
                    return false;
                }

                nKernelArgs = kernel.getInfo(webcl.KERNEL_NUM_ARGS);

                if (inputArgs.length > nKernelArgs) {
                    XML3D.debug.logWarning("WebCL: setArgs: Input args amount > kernel program args amount! Ignoring extra arguments.");
                } else if (inputArgs.length < nKernelArgs) {
                    XML3D.debug.logError("WebCL: setArgs: Not enough arguments were given to WebCL kernel.");
                    return false;
                }

                XML3D.debug.logDebug("Args for kernel:", kernel.getInfo(webcl.KERNEL_FUNCTION_NAME));

                i = nKernelArgs;

                try {
                    while (i--) {
                        XML3D.debug.logDebug("Arg:", i, inputArgs[i]);
                        kernel.setArg(i, inputArgs[i]);
                    }
                } catch (e) {
                    var errCode = getErrorCodeFromCLError(e);

                    if (!errCode) {
                        throw e;
                    }
                    throw new WebCLError(getCLErrorName(errCode), "Could not set kernel arguments.");
                }

                return true;

            }
        };
    };

    /**
     * Checks if WebCL is available and attaches a context to the given object
     * @param webclObject the object that the context will be attached to
     * @returns {boolean}
     */
    function initWebCLPlatform(webclObject) {
        if (!isAvailable()) {
            return false;
        }

        var clPlatforms = getPlatforms();
        if (!clPlatforms || clPlatforms.length <= 0) {
            return false;
        }

        try {
            // Trying initially to use GPU (for the best performance). Using CPU as a fallback.
            var clDevices = getDevicesByType("GPU") || getDevicesByType("CPU");
            if (!clDevices) {
                return false;
            }
            var clCtx = createContext(clDevices);
            var cmdQueue = createCommandQueue(clDevices[0], clCtx);

            /**
             *  TODO: Maybe we should just store the cl-platform objects in C.cl so they are more easily available and
             *  to avoid long prototype chains. Or we could pass the graph context to each node of the graph.
             *  However, it would be good to allow each Graph object to have at least own context, cmdQueue and kernelManager.
             */
            webclObject.cl = {
                API: webcl,
                kernelManager: new KernelManager(clCtx, clDevices),
                platforms: clPlatforms,
                devices: clDevices,
                ctx: clCtx,
                cmdQueue: cmdQueue
            };
            XML3D.debug.logDebug("Successfully initialized WebCL platform.");
            return true;
        } catch (e) {
            return false;
        }
    }

    /**
     * API
     *
     * @namespace webcl
     * @memberOf XML3D
     */

    namespace['webcl'] = {
        "init": init,
        "createContext": createContext,
        "createProgram": createProgram,
        "buildProgram": buildProgram,
        "createKernel": createKernel,
        "createCommandQueue": createCommandQueue,
        "createBuffer": createBuffer,
        "getDefaultContext": getDefaultContext,
        "getPlatforms": getPlatforms,
        "getDevicesByType": getDevicesByType,
        "getContextDevices": getContextDevices,
        "getDevicePlatform": getDevicePlatform,

        /** @name XML3D.webcl~kernels */
        "kernels": new KernelManager(),
        "KernelManager": KernelManager,

        "hasWebCLNamespace": hasWebCLNamespace,
        "hasOpenCLDrivers": hasOpenCLDrivers,
        "isAvailable": isAvailable,
        "WebCLError": WebCLError,
        "getCLErrorName": getCLErrorName
    };

    initWebCLPlatform(namespace.webcl);
    window.XML3D.webcl = namespace.webcl;

}(module.exports));

},{}],186:[function(require,module,exports){
var assert = require("assert");

// Error Callbacks:
var c_errorCallbacks = [];

var c_listedCallbacks = [];
var c_listedCallbacksData = [];

module.exports = {

    registerErrorCallback: function (callback) {
        c_errorCallbacks.push(callback);
    },

    notifyError: function (message, node) {
        if (c_errorCallbacks.length > 0) {
            var i;
            for (i = 0; i < c_errorCallbacks.length; ++i) {
                c_errorCallbacks[i](message, node);
            }
        } else {
            // TODO: Do Default error printing
        }
    },

    /**
     *
     * @param {Object} ctor Constructor
     * @param {Object} parent Parent class
     * @param {Object=} methods Methods to add to the class
     * @returns {Object}
     */
    createClass: function (ctor, parent, methods) {
        methods = methods || {};
        if (parent) {
            /** @constructor */
            var F = function () {
            };
            F.prototype = parent.prototype;
            ctor.prototype = new F();
            ctor.prototype.constructor = ctor;
            ctor.superclass = parent.prototype;
        }
        for (var m in methods) {
            ctor.prototype[m] = methods[m];
        }
        return ctor;
    },

    extend: function (a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }
    },

    /**
     * Cluster internal notifications to avoid multiple notifications
     * of same type. Mainly for Requests and Results
     *
     * @param requestOrResult Request or Result
     * @param {RESULT_STATE} resultState
     * @private
     */
    _queueResultCallback: function (requestOrResult, resultState) {
        assert(resultState !== undefined);
        var index;
        if (( index = c_listedCallbacks.indexOf(requestOrResult)) == -1) {
            index = c_listedCallbacks.length;
            c_listedCallbacks.push(requestOrResult);
        }
        var prevData = c_listedCallbacksData[index];

        if (!prevData || prevData < resultState) {
            c_listedCallbacksData[index] = resultState;
        }
    },

    _flushResultCallbacks: function () {
        if (c_listedCallbacks.length) {
            var i;
            for (i = 0; i < c_listedCallbacks.length; ++i) {
                c_listedCallbacks[i]._onPostponedResultChanged(c_listedCallbacksData[i]);
            }
            c_listedCallbacks = [];
            c_listedCallbacksData = [];
        }
    }
};







},{"assert":11}],187:[function(require,module,exports){
var C = {};

C.EPSILON = 0.000001;

/**
 * Type of DataEntry
 * @enum
 */
C.DATA_TYPE = {
    UNKNOWN: 0,
    FLOAT: 1,
    FLOAT2: 2,
    FLOAT3: 3,
    FLOAT4: 4,
    FLOAT3X3: 5,
    FLOAT4X4: 10,
    INT: 20,
    INT4: 21,
    BOOL: 30,
    TEXTURE: 40,
    STRING: 45,
    BYTE: 50,
    UBYTE: 60,
    fromString: function(str) {
        if (!str || !str.toUpperCase) {
            return;
        }
        return this[str.toUpperCase()];
    }
};

C.DATA_TYPE_MAP = {
    'float': C.DATA_TYPE.FLOAT,
    'float2': C.DATA_TYPE.FLOAT2,
    'float3': C.DATA_TYPE.FLOAT3,
    'float4': C.DATA_TYPE.FLOAT4,
    'float3x3': C.DATA_TYPE.FLOAT3X3,
    'float4x4': C.DATA_TYPE.FLOAT4X4,
    'int': C.DATA_TYPE.INT,
    'int4': C.DATA_TYPE.INT4,
    'bool': C.DATA_TYPE.BOOL,
    'texture': C.DATA_TYPE.TEXTURE,
    'string' : C.DATA_TYPE.STRING,
    'byte': C.DATA_TYPE.BYTE,
    'ubyte': C.DATA_TYPE.UBYTE
};

// Values are chosen to be in line with DATA_TYPE
C.TEXTURE_TYPE = {
    UNKNOWN: 0, FLOAT: 1, UBYTE: 60, USHORT_5_6_5: 70, USHORT_4_4_4_4: 71, USHORT_5_5_5_1: 72
};

C.TEXTURE_FORMAT = {
    UNKNOWN: 0, ALPHA: 100, RGB: 101, RGBA: 102, LUMINANCE: 103, LUMINANCE_ALPHA: 104
};

C.DATA_TYPE_TUPLE_SIZE = {};
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT] = 1;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT2] = 2;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT3] = 3;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT4] = 4;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT3X3] = 9;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT4X4] = 16;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.INT] = 1;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.INT4] = 4;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.BOOL] = 1;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.TEXTURE] = 1;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.STRING] = 1;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.BYTE] = 1;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.UBYTE] = 1;

C.TYPED_ARRAY_MAP = {};
C.TYPED_ARRAY_MAP[C.DATA_TYPE.FLOAT] = Float32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.FLOAT2] = Float32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.FLOAT3] = Float32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.FLOAT4] = Float32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.FLOAT4X4] = Float32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.INT] = Int32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.INT4] = Int32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.BOOL] = Int8Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.BYTE] = Int8Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.UBYTE] = Uint8Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.STRING] = Array;

// texture formats
// float and ubyte are mapped to DATA_TYPE values above
C.TYPED_ARRAY_MAP[C.TEXTURE_TYPE.USHORT_4_4_4_4] = Uint16Array;
C.TYPED_ARRAY_MAP[C.TEXTURE_TYPE.USHORT_5_6_5] = Uint16Array;
C.TYPED_ARRAY_MAP[C.TEXTURE_TYPE.USHORT_5_5_5_1] = Uint16Array;

C.TEXTURE_FORMAT_TUPLE_SIZE = {};
C.TEXTURE_FORMAT_TUPLE_SIZE[C.TEXTURE_FORMAT.ALPHA] = 1;
C.TEXTURE_FORMAT_TUPLE_SIZE[C.TEXTURE_FORMAT.RGB] = 3;
C.TEXTURE_FORMAT_TUPLE_SIZE[C.TEXTURE_FORMAT.RGBA] = 4;
C.TEXTURE_FORMAT_TUPLE_SIZE[C.TEXTURE_FORMAT.LUMINANCE] = 1;
C.TEXTURE_FORMAT_TUPLE_SIZE[C.TEXTURE_FORMAT.LUMINANCE_ALPHA] = 2;

C.getTypeName = function (type) {
    var i;
    for (i in C.DATA_TYPE_MAP) {
        if (C.DATA_TYPE_MAP[i] === type) {
            return i;
        }
    }
};

/**
 * @enum {number}
 */
C.TEX_FILTER_TYPE = {
    NEAREST: 0x2600, LINEAR: 0x2601, MIPMAP_NEAREST: 0x2700, MIPMAP_LINEAR: 0x2701

};
/**
 * @enum {number}
 */
C.TEX_WRAP_TYPE = {
    CLAMP: 0x812F, REPEAT: 0x2901
};
/**
 * @enum {number}
 */
C.TEX_TYPE = {
    TEXTURE_2D: 0x0DE1
};

C.SHADER_CONSTANT_KEY = {
    WORLD_TRANSFORM: 1,
    VIEW_TRANSFORM: 2,
    SCREEN_TRANSFORM: 3,
    WORLD_TRANSFORM_NORMAL: 4,
    VIEW_TRANSFORM_NORMAL: 5,
    SCREEN_TRANSFORM_NORMAL: 6,
    OBJECT_ID: 7
};

C.VS_ATTRIB_TRANSFORM = {
    NONE: 0, VIEW_POINT: 1, WORLD_POINT: 2, VIEW_NORMAL: 3, WORLD_NORMAL: 4
};


/**
 * Filter Type of DataNode
 * KEEP - Keep only the provided names
 * REMOVE - Remove provided names (ignores name mapping)
 * RENAME - Only apply name mapping
 * @enum
 */
C.DATA_FILTER_TYPE = {
    NONE: 0, RENAME: 1, KEEP: 2, REMOVE: 3
};


/**
 * TODO: Maybe merge this structure with RESULT_STATE to avoid back and forth conversion within notification chain
 * @enum {number}
 */
C.DATA_ENTRY_STATE = {
    CHANGED_VALUE: 1,
    CHANGED_NEW: 2,
    LOAD_START: 3,
    LOAD_END: 4,
    CHANGED_SIZE: 5,
    CHANGED_REMOVED: 6, // Not just the size changed, but also qualifier
    // if we have 0, 1 or many tuples in value
    CHANGED_SIZE_TYPE: 7
};

/** TODO: Merge with C.PLATFORM? **/
C.RESULT_TYPE = {
    COMPUTE: 0, VS: 1
};


/**
 * Type of Modification, used internally only
 * Ordered by importance.
 * @enum
 */
C.RESULT_STATE = {
    NONE: 0, CHANGED_DATA_VALUE: 1, CHANGED_DATA_SIZE: 2, CHANGED_STRUCTURE: 3, // TODO: Felix: Still required?
    IMAGE_LOAD_START: 4, IMAGE_LOAD_END: 5
};


/**
 * Type of Sequence access - used by operators
 * @enum
 */
C.SEQUENCE = {
    NO_ACCESS: 0, PREV_BUFFER: 1, NEXT_BUFFER: 2, LINEAR_WEIGHT: 3
};


C.ITERATION_TYPE = {
    NULL: 0, ONE: 1, MANY: 2
};

/**
 * Type of Information Extraction - used by operators
 * @private
 * @enum
 */
//TODO: This seems to be unused, is it still needed?
C.EXTRACT = {
    NO_EXTRAC: 0, TEX_WIDTH: 1, TEX_HEIGHT: 2
};

C.ORIGIN = {
    CHILD: 1, COMPUTE: 2, PROTO: 3
};

/**
 * Types of platforms to perform computation on
 * @type {enum}
 */
C.PLATFORM = {
    JAVASCRIPT: 0, GLSL: 1, CL: 2, ASYNC: 3
};

/**
 * Possible states of a ProcessNode
 * @type {enum}
 */
C.PROCESS_STATE = {
    MODIFIED: 0, // We don't know (TODO Felix: Find out!)
    LOADING: 1, // Something still loading (blocked)
    INVALID: 3, // Input is invalid (might happen even after operator selection - e.g. because of empty array output etc.)
    UNPROCESSED: 4, // Process node is dirty
    PROCESSED: 5 // All data is up-to-date
};

//window.Xflow.PLATFORM = C.PLATFORM;

module.exports = C;

},{}],188:[function(require,module,exports){
var Base = require("../base.js");
var C = require("./constants.js");
var assign = require('lodash.assign');
require("../../utils/array.js");

/**
 * Content of this file:
 * All Code for handling data entries connected to Xflow including:
 *  - BufferEntries: Typed value buffers (e.g float3 buffer, without name)
 *  - TextureEntries: e.g. images
 *
 *  This file also includes the DataChangeNotifier used to react to changes on Xflow data structures
 */

//----------------------------------------------------------------------------------------------------------------------
// SamplerConfig
//----------------------------------------------------------------------------------------------------------------------

var SAMPLER_DEFAULTS = {
    minFilter : C.TEX_FILTER_TYPE.LINEAR,
    magFilter : C.TEX_FILTER_TYPE.LINEAR,
    wrapS : C.TEX_WRAP_TYPE.CLAMP,
    wrapT : C.TEX_WRAP_TYPE.CLAMP,
    textureType : C.TEX_TYPE.TEXTURE_2D,
    flipY: true,
    anisotropy : 1, // number of max samples for anisotropic filtering
    generateMipMap : 0
};

/**
 * SamplerConfig is used to define sampler properties of a TextureEntry or ImageDataTextureEntry
 * @constructor
 */
var SamplerConfig = function(){
    this.setDefaults();
};

SamplerConfig.prototype.setDefaults = function() {
    assign(this, SAMPLER_DEFAULTS);
};

SamplerConfig.prototype.set = function(other) {
    assign(this, other);
};


//----------------------------------------------------------------------------------------------------------------------
// DataEntry
//----------------------------------------------------------------------------------------------------------------------


/**
 * The abstract base class for all DataEntries connected to an xflow graph.
 * @abstract
 * @param {C.DATA_TYPE} type Type of DataEntry
 */
var DataEntry = function(type){
    this._type = type;
    /** @type {Array.<Function(DataEntry, C.DATA_ENTRY_STATE)>} **/
    this._listeners = [];
    /** Add related custom data (e.g. WebGL buffers) **/
    this.userData = {};
};

Object.defineProperty(DataEntry.prototype, "type", {
    set: function(){
        throw new Error("type is read-only");
    },
    /** @return {C.DATA_TYPE} */
    get: function(){ return this._type; }
});

/**
 * @param {function(DataEntry, C.DATA_ENTRY_STATE)} callback
 */
DataEntry.prototype.addListener = function(callback){
    this._listeners.push(callback);
};

/**
 * @param {function(DataEntry, C.DATA_ENTRY_STATE)} callback
 */
DataEntry.prototype.removeListener = function(callback){
    Array.erase(this._listeners, callback);
};

/**
 */
DataEntry.prototype._notifyChanged = function(){
    notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_VALUE);
};

//----------------------------------------------------------------------------------------------------------------------
// BufferEntry
//----------------------------------------------------------------------------------------------------------------------

/**
 * A typed value buffer basically linking to a typed array.
 * @constructor
 * @extends {DataEntry}
 * @param {C.DATA_TYPE} type
 * @param {Object} value A typed array
 */
var BufferEntry = function(type, value){
    DataEntry.call(this, type);
    this._value = value;
    notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_NEW);
};
Base.createClass(BufferEntry, DataEntry);


/**
 *  Set value of entry. Triggers notification chain
 *  @param {Object} v Value to set (has to be a TypedArray)
 */
BufferEntry.prototype.setValue = function(v){
    this._setValue(v);
    Base._flushResultCallbacks();
};

/**
 * Are there no, one or many values?
 * @param size
 * @param tupleSize
 * @returns {number}
 */
function getSizeType(size, tupleSize){
    if(size >= tupleSize*2)
        return 2;
    else if(size >= tupleSize)
        return 1;
    else
        return 0;
}

BufferEntry.prototype._setValue = function(v){
    var oldSize = (this._value ? this._value.length : 0), newSize = (v ? v.length : 0), tupleSize = this.getTupleSize();
    var notification;
    if(getSizeType(oldSize, tupleSize) != getSizeType(newSize, tupleSize))
        notification = C.DATA_ENTRY_STATE.CHANGED_SIZE_TYPE;
    else if(oldSize != newSize){
        notification = C.DATA_ENTRY_STATE.CHANGED_SIZE;
    }
    else{
        notification = C.DATA_ENTRY_STATE.CHANGED_VALUE;
    }
    this._value = v;
    notifyListeners(this, notification);
};

/** @return {Object} */
BufferEntry.prototype.getValue = function(){
    return this._value;
};

/**
 * Returns the buffer length
 * @return {Object}
 */
BufferEntry.prototype.getLength = function(){
    return this._value ? this._value.length : 0;
};

/**
 * Returns tuple size (e.g 1, 2, 3, 4, 16)
 * @returns {number}
 */
BufferEntry.prototype.getTupleSize = function() {
    return C.DATA_TYPE_TUPLE_SIZE[this._type];
};

/**
 * Return tuple count
 * @return {number}
 */
BufferEntry.prototype.getIterateCount = function(){
    return this.getLength() / this.getTupleSize();
};

/**
 * Is value not set or the length of the buffer 0
 * @returns {boolean}
 */
BufferEntry.prototype.isEmpty = function(){
    return !this._value || !this.getLength();
};


//----------------------------------------------------------------------------------------------------------------------
// TextureEntry
//----------------------------------------------------------------------------------------------------------------------

function TexelSource(sourceOrWidth, height, format, type) {
    if (typeof sourceOrWidth === "object") {
        if (sourceOrWidth.nodeName) {
            var nodeName = sourceOrWidth.nodeName.toLowerCase();
            if (nodeName === "video" && (typeof sourceOrWidth.complete === "undefined")) {
                Object.defineProperties(sourceOrWidth, {
                    width: {
                        get: function () {
                            return this.videoWidth;
                        }
                    },
                    height: {
                        get: function () {
                            return this.videoHeight;
                        }
                    },
                    complete: {
                        get: function () {
                            return !(this.readyState == 0 || this.videoWidth <= 0 || this.videoHeight <= 0);
                        }
                    }
                });
            }
            sourceOrWidth.texelFormat = C.TEXTURE_FORMAT.RGBA;
            sourceOrWidth.texelType = C.TEXTURE_TYPE.UBYTE;
        }
        //assume source is a image data like object
        this._source = sourceOrWidth;
    } else {
        format = format || C.TEXTURE_FORMAT.RGBA;
        type =  type || C.TEXTURE_TYPE.UBYTE;
        //create a new texel source backed by type array
        this._source = {
            width: sourceOrWidth,
            height: height,
            texelFormat: format,
            texelType: type,
            data: new C.TYPED_ARRAY_MAP[type](sourceOrWidth * height * C.TEXTURE_FORMAT_TUPLE_SIZE[format])
        }
    }
}

Object.defineProperties(TexelSource.prototype, {
    imageData: {
        get: function () {
            if (this._source instanceof HTMLElement) {
                var canvas = document.createElement("canvas");
                canvas.width = this._source.width;
                canvas.height = this._source.height;
                var ctx = canvas.getContext("2d");
                ctx.drawImage(this._source, 0, 0);
                var source = ctx.getImageData(0, 0, this._source.width, this._source.height);
                source.texelFormat = this._source.texelFormat;
                source.texelType = this._source.texelType;
                this._source = source;
            }
            return this._source;
        }
    },
    // TODO this is very confusing. asGLTextureData is texelsource.source
    glTextureData: {
        get: function () {
            return this._source;
        }
    },
    complete: {
        get: function () {
            return typeof this._source.complete === "undefined" ? true : this._source.complete;
        }
    },
    width: {
        get: function () {
            return this._source ? this._source.width : -1;
        }
    },
    height: {
        get: function () {
            return this._source ? this._source.height : -1;
        }
    },
    texelFormat: {
        get: function () {
            return this._source ? this._source.texelFormat: C.TEXTURE_FORMAT.UNKNOWN;
        }
    },
    texelType: {
        get: function () {
            return this._source ? this._source.texelType: C.TEXTURE_TYPE.UNKNOWN;
        }
    }
});

/**
 * A data entry for a texture.
 * Note: each TextureEntry includes a samplerConfig.
 * @constructor
 * @extends {DataEntry}
 * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} source //TODO: Which kinds are supported?
 */
var TextureEntry = function(source){
    DataEntry.call(this, C.DATA_TYPE.TEXTURE);
    this._samplerConfig = new SamplerConfig();
    this._loading = false;
    this.setImage(source);

    notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_NEW);
};

Base.createClass(TextureEntry, DataEntry);

Object.defineProperties(TextureEntry.prototype, {
    width: {
        get: function () {
            return this._source ? this._source.width : -1;
        }
    },
    height: {
        get: function () {
            return this._source ? this._source.height : -1;
        }
    },
    texelFormat: {
        get: function () {
            return this._source ? this._source.texelFormat: C.TEXTURE_FORMAT.UNKNOWN;
        }
    },
    texelType: {
        get: function () {
            return this._source ? this._source.texelType: C.TEXTURE_TYPE.UNKNOWN;
        }
    }
});

TextureEntry.prototype.isLoading = function() {
    if (!this._source)
        return false;

    return !this._source.complete;
};

/**
 * @private
 */
TextureEntry.prototype._createImage = function(width, height, format, type, samplerConfig) {
    if (!this._source || this.width != width || this.height != height || this.format != format || this.type != type) {
        var source = new TexelSource(width, height, format, type);

        if (!samplerConfig) {
            samplerConfig = new SamplerConfig();
            samplerConfig.setDefaults();
        }

        this._samplerConfig.set(samplerConfig);
        this._setImage(source);
    } else {
        this._notifyChanged();
    }

    return this._source;
};

/**
 * Set image source of a Texture Entry
 * TODO: This is called even if image is just loaded (on XML3D side). Add a notifyImageLoaded method could
 * be helpful
 *
 * @param {HTMLImageElement|HTMLVideoElement|TexelSource|null} element
 * @param {boolean?} forceLoadCallback trigger load callback if data changes
 */
TextureEntry.prototype.setImage = function (element, forceLoadCallback) {
    this._setImage(element, forceLoadCallback);
    Base._flushResultCallbacks();
};

TextureEntry.prototype._setImage = function (element, forceLoadCallback) {
    if (!element)
        this._setSource(null, forceLoadCallback);
    else if (element instanceof TexelSource)
        this._setSource(element, forceLoadCallback);
    else
        this._setSource(new TexelSource(element), forceLoadCallback);
};

TextureEntry.prototype._setSource = function(s, forceLoadCallback) {
    var prevLoading = this.isLoading();
    this._source = s;
    var loading = this.isLoading();
    if(forceLoadCallback && !loading && !prevLoading){
        notifyListeners(this, C.DATA_ENTRY_STATE.LOAD_START);
        notifyListeners(this, C.DATA_ENTRY_STATE.LOAD_END);
    }
    else if(loading){
        this._loading = true;
        notifyListeners(this, C.DATA_ENTRY_STATE.LOAD_START);
    }
    else if(this._loading){
        this._loading = false;
        notifyListeners(this, C.DATA_ENTRY_STATE.LOAD_END);
    }
    else
        notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_VALUE);
};

TextureEntry.prototype.asGLTextureValue = function () {
    return this._source && this._source.glTextureData;
};

/** @return {ImageData} */
TextureEntry.prototype.getValue = function() {
    if (!this._source)
        return null;
    if (!this.isLoading())
        return this._source.imageData;
    else
        return null;
};

/** @return {SamplerConfig} */
TextureEntry.prototype.getSamplerConfig = function(){
    return this._samplerConfig;
};

/** @return {number} */
TextureEntry.prototype.getLength = function(){
    return 1;
};
TextureEntry.prototype.isEmpty = function(){
    return false;
};

/** @return {number} */
TextureEntry.prototype.getIterateCount = function() {
    return 1;
};

//----------------------------------------------------------------------------------------------------------------------
// ImageDataTextureEntry
//----------------------------------------------------------------------------------------------------------------------

/**
 * Same as TextureEntry, only based on imageData.
 * This class is used for xflow running inside Web Workers (which don't support HTML images)
 * @param imageData
 * @extends{DataEntry}
 * @constructor
 */
var ImageDataTextureEntry = function(imageData){
    DataEntry.call(this, C.DATA_TYPE.TEXTURE);
    this._samplerConfig = new SamplerConfig();
    this._imageData = null;
    this._texelFormat = C.TEXTURE_FORMAT.RGBA;
    this._texelType = C.TEXTURE_TYPE.UBYTE;

    this._updateImageData(imageData);

    notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_NEW);
};

Base.createClass(ImageDataTextureEntry, DataEntry);

Object.defineProperties(ImageDataTextureEntry.prototype, {
    width: {
        get: function () {
            return this._imageData ? this._imageData.width : -1;
        }
    },
    height: {
        get: function () {
            return this._imageData ? this._imageData.height : -1;
        }
    },
    texelFormat: {
        get: function () {
            return this._texelFormat;
        }
    },
    texelType: {
        get: function () {
            return this._texelType;
        }
    }
});



ImageDataTextureEntry.prototype.isLoading = function() {
    return !this._imageData;
};

ImageDataTextureEntry.prototype._updateImageData = function(imageData) {
    this._texelFormat = C.TEXTURE_FORMAT.RGBA;
    this._texelType = C.TEXTURE_TYPE.UBYTE;
    this._imageData = imageData;
};

/** Create new image
 * TODO: Jan: Write source documentation
 * @param width
 * @param height
 * @param format
 * @param type
 * @param samplerConfig
 * @return {HTMLImageElement|HTMLCanvasElement}
 */
ImageDataTextureEntry.prototype._createImage = function(width, height, format, type, samplerConfig) {
    if (!this._imageData || this.getWidth() != width || this.getHeight() != height || this._format != format || this._type != type) {
        if (!width || !height)
            throw new Error("Width or height is not specified");
        this._texelFormat = format;
        this._texelType = type;
        if (!samplerConfig) {
            samplerConfig = new SamplerConfig();
            samplerConfig.setDefaults();
        }
        this._samplerConfig.set(samplerConfig);

        /**
         * @type {{width: *, height: *, data: null|ArrayBufferView}}
         */
        var imageData = {
            width: width,
            height: height,
            data: null
        };
        if(type == C.TEXTURE_TYPE.FLOAT){
            imageData.data = new Float32Array(width*height*4);
        }
        else {
            // FIXME: We should allocate Uint8ClampedArray here instead
            // But Uint8ClampedArray can't be allocated in Chrome inside a Web Worker
            // See bug: http://code.google.com/p/chromium/issues/detail?id=176479
            // As a work around, we allocate Int16Array which results in correct clamping outside of web worker
            if(Uint8Array == Uint8ClampedArray)
                imageData.data = new Int16Array(width*height*4);
            else
                imageData.data = new Uint8ClampedArray(width*height*4);
        }
        this._imageData = imageData;
    }
    this._notifyChanged();
};

/** @param {Object} v */
ImageDataTextureEntry.prototype.setImageData = function(v) {
    this._updateImageData(v);
    notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_VALUE);
    Base._flushResultCallbacks();
};

ImageDataTextureEntry.prototype.getWidth = function() {
    return this._imageData && this._imageData.width || 0;
};

ImageDataTextureEntry.prototype.getHeight = function() {
    return this._imageData && this._imageData.height || 0;
};

/** @return {ImageData} */
ImageDataTextureEntry.prototype.getValue = function() {
    return this._imageData;
};

/** @return {SamplerConfig} */
ImageDataTextureEntry.prototype.getSamplerConfig = function(){
    return this._samplerConfig;
};

/** @return {number} */
ImageDataTextureEntry.prototype.getLength = function(){
    return 1;
};
ImageDataTextureEntry.prototype.isEmpty = function(){
    return false;
};


/** @return {number} */
ImageDataTextureEntry.prototype.getIterateCount = function() {
    return 1;
};

//----------------------------------------------------------------------------------------------------------------------
// DataChangeNotifier
//----------------------------------------------------------------------------------------------------------------------


/**
 * Used to listen to modifications of any DataEntry connected to an Xflow graph.
 * @constructor
 */
var DataChangeNotifier = {
    _listeners: []
};

/**
 * @param {function(DataEntry, C.DATA_ENTRY_STATE)} callback
 */
DataChangeNotifier.addListener = function(callback){
    this._listeners.push(callback);
};

/**
 * @param {function(DataEntry, C.DATA_ENTRY_STATE)} callback
 */
DataChangeNotifier.removeListener = function(callback){
    Array.erase(this._listeners, callback);
};

/**
 * @param {DataEntry} dataEntry
 * @param {C.DATA_ENTRY_STATE} notification
 */
function notifyListeners(dataEntry, notification){
    var i;
    // Global notifications
    for(i = 0; i < DataChangeNotifier._listeners.length; ++i){
        DataChangeNotifier._listeners[i](dataEntry, notification);
    }
    // Internal and external listeners
    for(i = 0; i < dataEntry._listeners.length; ++i){
        dataEntry._listeners[i](dataEntry, notification);
    }
}

module.exports = {
    DataEntry: DataEntry,
    BufferEntry: BufferEntry,
    TextureEntry: TextureEntry,
    ImageDataTextureEntry: ImageDataTextureEntry,
    SamplerConfig: SamplerConfig,
    DataChangeNotifier: DataChangeNotifier
};

},{"../../utils/array.js":178,"../base.js":186,"./constants.js":187,"lodash.assign":17}],189:[function(require,module,exports){
var C = require("./constants.js");
var Mapping = require("./../processing/mapping.js");
require("../../utils/array.js");

var Base = require("../base.js");
var ChannelNode = require("../processing/channel-node.js").ChannelNode;
var Utils = require("../utils/utils.js");

//----------------------------------------------------------------------------------------------------------------------
// GraphNode
//----------------------------------------------------------------------------------------------------------------------

/**
 * Base class for other graph nodes
 * @constructor
 * @abstract
 * @param {Graph} graph Reference to parent graph
 */
var GraphNode = function(){
    /**
     * All nodes that add a dependency to this node
     * @type array<GraphNode>
     **/
    this._parents = [];
};


//----------------------------------------------------------------------------------------------------------------------
// InputNode
//----------------------------------------------------------------------------------------------------------------------

/**
 * An InputNode include an DataEntry, a name and other information
 * This class mirrors XML3D elements such as <float3>, <int> or <texture>
 *
 * @constructor
 * @param {Graph} graph
 * @extends {GraphNode}
 */
var InputNode = function(){
    GraphNode.call(this);
    /**
     * Name of the input node
     * @type {string}
     * @private
     */
    this._name = "";
    /**
     * Sequence key
     * @type {number}
     * @private
     */
    this._key = 0;
    /**
     * DataEntry node that holds the value
     * @type {DataEntry}
     */
    this._data = null;
    /**
     * If this nodes is a parameter within a <dataflow>
     * this is set to the name of the parameter, otherwise null
     * @type {null|String}
     * @private
     */
    this._paramName = null;

    /**
     * Experimental! Apply different override logic in order
     * to propagate global parameters to the source of the graph
     * Could be used for instance for LOD concepts, where the
     * renderer propagates the distance along the graph
     * @type {boolean}
     * @private
     */
    this._paramGlobal = false;

    /**
     *  Cache listener for DataEntry
     *  @see {InputNode.onDataChange}
     */
    this._dataListener = this.onDataChange.bind(this);
};
Base.createClass(InputNode, GraphNode);

/**
 * Propagate events from DataEntry to parent nodes
 * @param {Object} newValue
 * @param {C.DATA_ENTRY_STATE} notification
 */
InputNode.prototype.onDataChange = function(newValue, notification) {
    var downNote;
    switch(notification){
        case C.DATA_ENTRY_STATE.CHANGED_VALUE: downNote = C.RESULT_STATE.CHANGED_DATA_VALUE; break;
        case C.DATA_ENTRY_STATE.LOAD_START: downNote = C.RESULT_STATE.IMAGE_LOAD_START; break;
        case C.DATA_ENTRY_STATE.LOAD_END: downNote = C.RESULT_STATE.IMAGE_LOAD_END; break;
        case C.DATA_ENTRY_STATE.CHANGED_SIZE_TYPE: downNote = C.RESULT_STATE.CHANGED_STRUCTURE; break;
        case C.DATA_ENTRY_STATE.CHANGED_SIZE: downNote = C.RESULT_STATE.CHANGED_DATA_SIZE; break;
        default: downNote = C.RESULT_STATE.CHANGED_DATA_SIZE; break;
    }
    notifyParentsOnChanged(this,downNote);
};

Object.defineProperty(InputNode.prototype, "name", {
    /** @param {string} v */
    set: function(v){
        this._name = v;
        notifyParentsOnChanged(this, C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {string} */
    get: function(){ return this._name; }
});

Object.defineProperty(InputNode.prototype, "key", {
    /** @param {number} v */
    set: function(v){
        this._key = v;
        notifyParentsOnChanged(this, C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {number} */
    get: function(){ return this._key; }
});

Object.defineProperty(InputNode.prototype, "paramName", {
    /** @param {string} v */
    set: function(v){
        this._paramName = v;
        notifyParentsOnChanged(this, C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {string} */
    get: function(){ return this._paramName; }
});

Object.defineProperty(InputNode.prototype, "paramGlobal", {
    /** @param {boolean} v */
    set: function(v){
        this._paramGlobal = v;
        notifyParentsOnChanged(this, C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {boolean} */
    get: function(){ return this._paramGlobal; }
});

Object.defineProperty(InputNode.prototype, "data", {
    /** @param {DataEntry} dataEntry */
    set: function(dataEntry){
        var prevDataLoading = false;
        if(this._data) {
            prevDataLoading = this._data._loading;
            this._data.removeListener(this._dataListener);
        }
        this._data = dataEntry;
        if(this._data) {
            this._data.addListener(this._dataListener);
        }
        if(prevDataLoading != this._data._loading){
            notifyParentsOnChanged(this, this._data._loading ? C.RESULT_STATE.IMAGE_LOAD_START :
                C.RESULT_STATE.IMAGE_LOAD_END);
        }
        Base._flushResultCallbacks();
    },
    /** @return {DataEntry} */
    get: function(){ return this._data; }
});

/**
 * Getter for local parameter name, returns null if this is a global
 * parameter
 *
 * @returns {null|String}
 * @private
 */
InputNode.prototype._getParamNames = function(){
    return this._paramGlobal ? null : this._paramName;
};

/**
 * Getter for global parameter name, returns null if this is not a global
 * parameter
 *
 * @returns {null|String}
 * @private
 */
InputNode.prototype._getGlobalParamNames = function(){
    return this._paramGlobal ? this._paramName : null;
};

//----------------------------------------------------------------------------------------------------------------------
// DataNode
//----------------------------------------------------------------------------------------------------------------------
var c_xflowNodeId = 0;
function getXflowNodeId(){
    return ++c_xflowNodeId;
}

/**
 * The DataNode is the central structure of an Xflow Graph.
 * It is used to build a data composition graph as well as a data flow.
 * It mirror the <data> element of XML3D
 *
 * @constructor
 * @param {Graph} graph Context graph
 * @param {boolean} isDataFlow is this node a dataflow
 * @extends {GraphNode}
 */
var DataNode = function(isDataFlow){
    GraphNode.call(this);

    /**
     * Marker, if this data node is expecting data. Xflow
     * is not monitoring any load events. This must be set
     * from external
     * @type {boolean}
     */
    this._loading = false;

    /**
     * Experimental! Priority. How important is this data?
     * 0: Very important
     * @type {number}
     */
    this._loadLevel = 0;

    /**
     * Used for loading events: If progress level
     * reaches infinity, loading events are triggered
     * @type {Number}
     */
    this._progressLevel = Infinity;

    /**
     * Globally unique id
     */
    this.id = getXflowNodeId();

    /**
     * Is this node a proto node
     * @type {boolean}
     */
    this._isProtoNode = isDataFlow;

    /**
     * Children. InputNodes and DataNodes (as found in DOM)
     * @type {Array}
     */
    this._children = [];

    /**
     * The DataNode that has been reference via src
     * @type {DataNode}
     */
    this._sourceNode = null;

    /**
     * Field to attach custom data
     * @type {null|Object}
     */
    this._userData = null;

    /**
     * The filter type of this node (keep, rename, remove ...)
     * @type {DATA_FILTER_TYPE}
     */
    this._filterType = C.DATA_FILTER_TYPE.NONE;

    /**
     * Define the mapping
     * @type {Mapping.Mapping}
     */
    this._filterMapping = null;

    /**
     * String identifier for operator
     * TODO: Operator class
     * @type {string|Object}
     */
    this._computeOperator = "";

    /**
     * True, if compute is a dataflow reference
     * @type {boolean}
     */
    this._computeUsesDataflow = false;

    /**
     * Mapping for input of operator,
     * e.g. (position, texcoord) or ({position: pos, texcoord: uv})
     * @type {Mapping}
     */
    this._computeInputMapping = null;

    /**
     * Mapping for output of operator,
     * e.g. (position, texcoord) = ... or {position: pos, texcoord: uv} = ...
     * @type {Mapping}
     */
    this._computeOutputMapping = null;

    /**
     * If dataflow node has been resolved, this
     * entry is set
     * @type {DataNode}
     */
    this._dataflowNode = null;

    /**
     * Internal (optimized) version of this data node
     * @type {ChannelNode}
     */
    this._channelNode = new ChannelNode(this);

    /**
     * Map of cached channel nodes for dataflow instances with varying
     * input arguments (specialized nodes)
     * TODO: Use WeakMap?
     * @type {Object.<string, ChannelNode>}
     */
    this._substitutionNodes = {};

    /**
     * Cached version of local param names collected from
     * children
     * @type {Array.<string>}
     */
    this._paramNames = null;

    /**
     * Cached version of global param names collected from
     * children
     * @type {Array.<string>}
     */
    this._globalParamNames = null;

    /**
     * Platform, this data node should be executed on
     * TODO: This should be implicit, not explicit
     * @type {null}
     */
    this._platform = null;

    /**
     * Observers of the node's C.RESULT_STATE
     * @type {Array}
     */
    this._listeners = [];

    /**
     * Observers of the node's progress level
     * @type {Array}
     */
    this._loadListeners = [];

};
Base.createClass(DataNode, GraphNode);


Object.defineProperty(DataNode.prototype, "sourceNode", {
    /** @param {?DataNode} newSourceNode */
    set: function(newSourceNode){
        replaceNodeInHierarchy(this, "_sourceNode", newSourceNode);
        updateProgressLevel(this);
        this.notify(C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {?DataNode} */
    get: function(){ return this._sourceNode; }
});

Object.defineProperty(DataNode.prototype, "dataflowNode", {
    /** @param {?DataNode} newDataflowNode */
    set: function(newDataflowNode){
        if(newDataflowNode && !this._computeUsesDataflow) {
            throw new Error("Cannot set dataflowNode when compute doesn't use dataflow.");
        }
        replaceNodeInHierarchy(this, "_dataflowNode", newDataflowNode);
        updateProgressLevel(this);
        this.notify(C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {?DataNode} */
    get: function(){ return this._dataflowNode; }
});


Object.defineProperty(DataNode.prototype, "userData", {
    /** @param {?DataNode} v */
    set: function(v){
        this._userData = v;
    },
    /** @return {?DataNode} */
    get: function(){ return this._userData; }
});

/**
 * Set (from external) if more data is expected.
 * @param {boolean} loading
 */
DataNode.prototype.setLoading = function(loading){
    if(this._loading != loading){
        this._loading = loading;
        this._channelNode.setStructureOutOfSync();
        this._channelNode.loading = loading;
        for (var sub in this._substitutionNodes) {
            var subNode = this._substitutionNodes[sub];
            subNode.setStructureOutOfSync();
            subNode.loading = loading;
        }
        updateProgressLevel(this);
        Base._flushResultCallbacks();
    }
};

/**
 * Returns if this or any child node is loading
 * @returns {boolean}
 */
DataNode.prototype.isSubtreeLoading = function(){
    return this._progressLevel == 0;
};

/**
 * @returns {Number}
 */
DataNode.prototype.getProgressLevel = function(){
    return this._progressLevel;
};


Object.defineProperty(DataNode.prototype, "filterType", {
    /** @param {C.DATA_FILTER_TYPE} v */
    set: function(v){
        this._filterType = v;
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {C.DATA_FILTER_TYPE} */
    get: function(){ return this._filterType; }
});

Object.defineProperty(DataNode.prototype, "filterMapping", {
    /** @param {Mapping} v */
    set: function(v){
        swapMapping(this, "_filterMapping", v);
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {Mapping} */
    get: function(){ return this._filterMapping; }
});

Object.defineProperty(DataNode.prototype, "computeOperator", {
    /** @param {string} v */
    set: function(v){
        this._computeOperator = v;
        this._computeUsesDataflow = false;
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {string} */
    get: function(){ return this._computeUsesDataflow ? null : this._computeOperator; }
});

Object.defineProperty(DataNode.prototype, "computeDataflowUrl", {
    /** @param {string} v */
    set: function(v){
        this._computeOperator = v;
        this._computeUsesDataflow = true;
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {string} */
    get: function(){ return this._computeUsesDataflow ? this._computeOperator : null; }
});

Object.defineProperty(DataNode.prototype, "computeInputMapping", {
    /** @param {Mapping} v */
    set: function(v){
        swapMapping(this, "_computeInputMapping", v);
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {Mapping} */
    get: function(){ return this._computeInputMapping; }
});
Object.defineProperty(DataNode.prototype, "computeOutputMapping", {
    /** @param {Mapping} v */
    set: function(v){
        swapMapping(this, "_computeOutputMapping", v);
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {Mapping} */
    get: function(){ return this._computeOutputMapping; }
});

//noinspection JSUnusedGlobalSymbols
DataNode.prototype.isProtoNode = function(){
    return this._isProtoNode;
};

/**
 * @param {GraphNode} child
 */
DataNode.prototype.appendChild = function(child){
    this._children.push(child);
    addParent(this, child);
    updateProgressLevel(this);
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};
/**
 * @param {GraphNode} child
 */
DataNode.prototype.removeChild = function(child){
    Array.erase(this._children, child);
    removeParent(this, child);
    updateProgressLevel(this);
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

/**
 * @param {GraphNode} child
 * @param {GraphNode} beforeNode
 */
DataNode.prototype.insertBefore = function(child, beforeNode){
    var idx = this._children.indexOf(beforeNode);
    if(idx == -1)
        this._children.push(child);
    else
        this._children.splice(idx, 0, child);
    addParent(this, child);
    // TODO: Next three calls on all structural changes. Add Method
    updateProgressLevel(this);
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

/**
 * clear all references and remove children
 */
DataNode.prototype.clear = function(){
    for(var i =0; i < this._children.length; ++i){
        removeParent(this, this._children[i]);
    }
    this._children = [];
    this._dataflowNode && this._dataflowNode.removeParent(this);
    this._dataflowNode = null;
    this._channelNode.decreaseRef();
    clearSubstitutionNodes(this);
    updateProgressLevel(this);
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    this._listeners = [];
    delete this._userData;
    delete this._channelNode;
    delete this._dataflowNode;
    Base._flushResultCallbacks();
};

DataNode.prototype.removeParent = function(parent) {
    Array.erase(this._parents, parent);
    updateProgressLevel(this);
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

//noinspection JSUnusedGlobalSymbols
/**
 * Detach this DataNode from all connections, including source- and proto-node references
 */
DataNode.prototype.detachFromParents = function(){
    for(var i =0; i < this._parents.length; ++i){
        var parent = this._parents[i];
        if(parent._sourceNode == this)
            parent.sourceNode = null;
        else if(parent._dataflowNode == this){
            parent.dataflowNode = null;
        }
        else{
            parent.removeChild(this);
        }
    }
    this._children = [];
};

/**
 * Sets platform of a DataNode. If _platform is defined, it will override the default platform setting of
 * an Xflow graph.
 *
 * @param {String|C.PLATFORM|null} platformSrc
 */
DataNode.prototype.setPlatform = function(platformSrc) {
    if (typeof platformSrc === 'string') {
        if (platformSrc === "cl") {
            this._platform = C.PLATFORM.CL;
        }
        else if (platformSrc === "gl") {
            this._platform = C.PLATFORM.GLSL;
        }
        else if (platformSrc === "js") {
            this._platform = C.PLATFORM.JAVASCRIPT;
        }
    } else if (!isNaN(parseFloat(platformSrc)) && isFinite(platformSrc)) {
        this._platform = platformSrc;
    } else {
        this._platform = null;
    }

    this.notify(C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

/**
 * @const
 */
var filterParser = /^([A-Za-z\s]*)\(([^()]+)\)$/;

/**
 * Set filter by string
 * @param {string} filterString
 */
DataNode.prototype.setFilter = function(filterString){
    filterString = filterString || "";
    var newType = C.DATA_FILTER_TYPE.RENAME;
    var newMapping = null;
    if(filterString){
        var result = filterString.trim().match(filterParser);
        if(result){
            var type = result[1].trim();
            switch(type){
                case "keep": newType = C.DATA_FILTER_TYPE.KEEP; break;
                case "remove": newType = C.DATA_FILTER_TYPE.REMOVE; break;
                case "rename": newType = C.DATA_FILTER_TYPE.RENAME; break;
                default:
                    Base.notifyError("Unknown filter type:" + type, this);
            }
            newMapping = Mapping.Mapping.parse(result[2], this);
        }
        else{
            Base.notifyError("Could not parse filter '" + filterString + "'", this);
        }
    }
    if(!newMapping){
        // TODO Remove this? (Mapping can be null from now on)
        newMapping = new Mapping.OrderMapping();
    }
    swapMapping(this, "_filterMapping", newMapping);
    this._filterType = newType;
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

var computeParser = /^(([^=]+)\=)?([^'(]+('[^']+')?[^'(]+)(\(([^()]*)?\))?$/;
var bracketsParser = /^\(([^()]*)\)$/;
var dataflowParser = /^dataflow\['([^']+)'\]$/;

//noinspection JSUnusedGlobalSymbols
/**
 * If the compute string contains a reference to an external dataflow,
 * the parser returns its URL. Null, otherwise
 * @param computeString
 * @returns {string|null}
 */
var getComputeDataflowUrl = function(computeString){
    computeString = computeString || "";
    var result = computeString.trim().match(computeParser);
    if(result){
        if(result = result[3].trim().match(dataflowParser)){
            return result[1];
        }
    }
    return null;
};

/**
 * Set compute by string
 * @param {string} computeString
 */
DataNode.prototype.setCompute = function(computeString){
    computeString = computeString || "";
    var newOperator = "";
    var inputMapping = null, outputMapping = null;
    var result = computeString.trim().match(computeParser);
    if(result){
        var output = result[2] ? result[2].trim() : "";
        newOperator = result[3].trim();
        var input = result[6] ? result[6].trim() : "";
        if(result = output.match(bracketsParser)){
            output = result[1];
        }
        if(input)
            inputMapping = Mapping.Mapping.parse(input, this);
        if(output)
            outputMapping = Mapping.Mapping.parse(output, this);

        if(result = newOperator.match(dataflowParser)){
            this._computeUsesDataflow = true;
            newOperator = result[1];
        }
        else{
            this._computeUsesDataflow = false;
        }
        this._dataflowNode = null;
    }
    else if(computeString){
        Base.notifyError("Error parsing Compute value '" + computeString + "'", this);
    }
    swapMapping(this, "_computeInputMapping", inputMapping);
    swapMapping(this, "_computeOutputMapping", outputMapping);
    this._computeOperator = newOperator;
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

/**
 * Notifies DataNode about a change. Notification will be forwarded to parents, if necessary
 * @param {C.RESULT_STATE} changeType
 * @param {GraphNode?} senderNode
 */
DataNode.prototype.notify = function(changeType, senderNode){
    //noinspection FallthroughInSwitchStatementJS
    switch(changeType) {
        case C.RESULT_STATE.CHANGED_STRUCTURE:
            this._paramNames = null;
            this._globalParamNames = null;
            this._channelNode.setStructureOutOfSync();
            clearSubstitutionNodes(this);
            notifyParentsOnChanged(this, changeType);
            break;

        case C.RESULT_STATE.IMAGE_LOAD_START:
        case C.RESULT_STATE.IMAGE_LOAD_END:
            updateProgressLevel(this);
            if(senderNode){
                this._channelNode.notifyDataChange(senderNode, changeType);
            }
            break;

        case C.RESULT_STATE.CHANGED_DATA_VALUE:
        case C.RESULT_STATE.CHANGED_DATA_SIZE:
            if(senderNode){
                this._channelNode.notifyDataChange(senderNode, changeType);
            }
            break;
    }
    // Inform listeners (e.g. Requests)
    for(var i = 0; i < this._listeners.length; ++i) {
        this._listeners[i](changeType);
    }
};

DataNode.prototype.addListener = function(listener){
    this._listeners.push(listener)
};

DataNode.prototype.removeListener = function(listener) {
    Array.erase(this._listeners, listener);
};

DataNode.prototype.addLoadListener = function(listener){
    this._loadListeners.push(listener);
};

//noinspection JSUnusedGlobalSymbols
DataNode.prototype.removeLoadListener = function(listener){
    Array.erase(this._loadListeners, listener);
};

DataNode.prototype._callLoadListeners = function(newLevel, oldLevel){
    var len = this._loadListeners.length;
    for(var i = 0; i < len; ++i){
        this._loadListeners[i](this, newLevel, oldLevel);
    }
};

DataNode.prototype.getOutputNames = function(){
    return getForwardNode(this)._channelNode.getOutputNames();
};

DataNode.prototype.getOutputChannelInfo = function(name){
    return getForwardNode(this)._channelNode.getOutputChannelInfo(name);
};

//noinspection JSUnusedGlobalSymbols
DataNode.prototype.getParamNames = function(){
    return this._getParamNames();
};

/**
 * Delegate computation of the result to the channel node
 * of the first contributing DataNode.
 * @param type
 * @param filter
 * @returns {Result}
 */
DataNode.prototype._getResult = function(type, filter){
    return getForwardNode(this, filter)._channelNode.getResult(type, filter);
};

DataNode.prototype._getForwardNode = function(filter){
    return getForwardNode(this, filter);
};

DataNode.prototype._getParamNames = function(){
    if(!this._paramNames){
        this._paramNames = [];
        if(this._sourceNode)
            Utils.nameset.add(this._paramNames, this._sourceNode._getParamNames());
        else{
            for(var i = 0; i < this._children.length; ++i){
                Utils.nameset.add(this._paramNames, this._children[i]._getParamNames());
            }
        }
    }
    return this._paramNames;
};

DataNode.prototype._getGlobalParamNames = function(){
    if(!this._globalParamNames){
        this._globalParamNames = [];
        if(this._dataflowNode)
            Utils.nameset.add(this._globalParamNames, this._dataflowNode._getGlobalParamNames());

        if(this._sourceNode)
            Utils.nameset.add(this._globalParamNames, this._sourceNode._getGlobalParamNames());
        else{
            for(var i = 0; i < this._children.length; ++i){
                Utils.nameset.add(this._globalParamNames, this._children[i]._getGlobalParamNames());
            }
        }
    }
    return this._globalParamNames;
};

/**
 * @param {Substitution} substitution
 * @returns {ChannelNode}
 */
DataNode.prototype._getOrCreateChannelNode = function(substitution){
    if(!substitution)
        return this._channelNode;
    else{
        var key = substitution.getKey(this);
        if(!this._substitutionNodes[key]) {
            this._substitutionNodes[key] = new ChannelNode(this, substitution);
        } else {
            this._substitutionNodes[key].increaseRef();
        }
        return this._substitutionNodes[key];
    }
};

/**
 * Remove ChannelNode passed as argument from internal substitution nodes
 * Decreases reference counter of substitution node and deletes it if not
 * used by any other node.
 * @param {ChannelNode} substitutionNode
 */
DataNode.prototype._removeSubstitutionNode = function(substitutionNode){
    var key = substitutionNode.substitution.getKey(this);
    if(this._substitutionNodes[key] && this._substitutionNodes[key].decreaseRef())
        delete this._substitutionNodes[key];
};

/**
 * Calls clear of all substitutionNodes and clears the map
 * @param {DataNode} dataNode
 */
function clearSubstitutionNodes(dataNode){
    if (!dataNode._substitutionNodes) {
        return;
    }
    for(var name in dataNode._substitutionNodes) {
        dataNode._substitutionNodes[name].clear();
    }
    dataNode._substitutionNodes = {};
    for (var i in dataNode._children) {
        clearSubstitutionNodes(dataNode._children[i]);
    }
}
//----------------------------------------------------------------------------------------------------------------------
// Helpers
//----------------------------------------------------------------------------------------------------------------------



/**
 * Skips nodes, if it does not contribute to the result (optimization)
 * @param {DataNode} dataNode
 * @param {array.<string>?} filter
 * @returns {DataNode}
 */
function getForwardNode(dataNode, filter){
    var hasFilter = (dataNode._filterMapping && !dataNode._filterMapping.isEmpty());
    if(hasFilter)
        return dataNode;

    if(!dataNode._computeOperator ){
        if(dataNode._sourceNode && dataNode._children.length == 0)
            return getForwardNode(dataNode._sourceNode);
        if(dataNode._children.length == 1 && dataNode._children[0] instanceof DataNode)
            return getForwardNode(dataNode._children[0]);
    }

    var idx = dataNode._channelNode.getChildDataIndex(filter);
    if(idx != -1 && idx != undefined){
        if(dataNode._sourceNode)
            return getForwardNode(dataNode._sourceNode);
        else
            return getForwardNode(dataNode._children[idx]);
    }
    return dataNode;
}


/**
 * Computes the progress level
 * @private
 * @param {DataNode} node
 */
function updateProgressLevel(node){
    var progressLevel = node._loading ? node._loadLevel : Infinity;
    var i;

    for(i = 0; progressLevel && i < node._children.length; ++i){
        var child = node._children[i];
        if(child instanceof DataNode){
            progressLevel = Math.min(progressLevel, Math.max(child._loadLevel, child._progressLevel) );
        }
        else if(child._data && child._data.isLoading && child._data.isLoading()){
            progressLevel = Math.min(progressLevel, 1);
        }
    }
    if(progressLevel && node._sourceNode){
        progressLevel = Math.min(progressLevel, Math.max(node._sourceNode._loadLevel, node._sourceNode._progressLevel));
    }
    if(progressLevel && node._dataflowNode){
        progressLevel = Math.min(progressLevel, Math.max(node._dataflowNode._loadLevel, node._dataflowNode._progressLevel));
    }
    var oldLevel = node._progressLevel;
    node._progressLevel = progressLevel;

    if(oldLevel != node._progressLevel){
        node._callLoadListeners(node._progressLevel, oldLevel);
        for(i = 0; i < node._parents.length; ++i)
            updateProgressLevel(node._parents[i]);
    }
}

/**
 * @private
 * @param {DataNode} parent
 * @param {GraphNode} child
 */
function addParent(parent, child){
    child._parents.push(parent);
}

/**
 * @private
 * @param {DataNode} parent
 * @param {GraphNode} child
 */
function removeParent(parent, child){
    Array.erase(child._parents, parent);
}

/**
 * Notify all parent nodes about a change
 * @param {GraphNode} node
 * @param {exports.C.RESULT_STATE} changeType
 * @private
 */
function notifyParentsOnChanged(node, changeType){
    for(var i = 0; i < node._parents.length; ++i){
        node._parents[i].notify(changeType, node);
    }
}

/**
 * Update the owners of the mappings
 * @param {DataNode} dataNode
 * @param {string} key
 * @param {Mapping} mapping
 */
function swapMapping(dataNode, key, mapping){
    dataNode[key] && dataNode[key]._removeOwner(dataNode);
    dataNode[key] = mapping;
    dataNode[key] && dataNode[key]._addOwner(dataNode);
}

function replaceNodeInHierarchy(node, field, newChild) {
    var oldChild = node[field];
    if(oldChild) {
        removeParent(node, oldChild);
    }
    node[field] = newChild;
    if(newChild) {
        addParent(node, newChild);
    }
}

module.exports = {
    InputNode: InputNode,
    DataNode: DataNode,
    getComputeDataflowUrl: getComputeDataflowUrl
};

},{"../../utils/array.js":178,"../base.js":186,"../processing/channel-node.js":230,"../utils/utils.js":238,"./../processing/mapping.js":234,"./constants.js":187}],190:[function(require,module,exports){
var Base = require("../base.js");
var C = require("./constants.js");
var DataNode = require("./graph.js").DataNode;

/**
 * Content of this file:
 * Classes to request results from an Xflow graph.
 */

/**
 * Abstract Request class.
 * Any Request is created from a DataNode to receive the result of that DataNode.
 * To allow effective optimization, it is recommended to create only one Request per DataNode and receive all
 * results through that Request.
 * @abstract
 * @param {DataNode} dataNode The DataNode from which to request results
 * @param {?Array.<string>} filter A list of names filtering the values to be received (only return values with names inside the filter)
 * @param {?function} callback A callback function that gets called whenever the result of the Request changes
 */
var Request = function(dataNode, filter, callback){
    this._dataNode = dataNode;
    this._filter = filter ? filter.slice().sort() : null;
    this._listener = callback;

    /**
     * Cached result of this request
     * @type {Result}
     */
    this._result = null;

    /**
     * Cached callback function attached to data node
     * @private
     */
    this._dataNodeListener = this._onDataNodeChange.bind(this);

    this._dataNode.addListener(this._dataNodeListener);
};

Object.defineProperty(Request.prototype, "dataNode", {
    set: function(){
       throw new Error("dataNode is readonly");
    },
    get: function(){ return this._dataNode; }
});

Object.defineProperty(Request.prototype, "filter", {
    set: function(){
        throw new Error("filter is read-only");
    },
    get: function(){ return this._filter; }
});

/**
 * Call this function, whenever the request is not required anymore.
 * Cleans up cached data and listeners
 */
Request.prototype.clear = function(){
    this._listener = null;
    if(this._result) this._result._removeRequest(this);
    this._dataNode.removeListener(this._dataNodeListener);
};

/**
 * @param {C.RESULT_STATE} data
 * @private
 */
Request.prototype._onPostponedResultChanged = function(data){
    this._listener && this._listener(this, data);
};

/**
 * Change the result of the request and update request list of old and new
 * result.
 * @private
 * @param {Request} request
 * @param {Result?} newResult
 * @returns {Result}
 */
function swapResultRequest(request, newResult){
    if(request._result) request._result._removeRequest(request);
    request._result = newResult;
    if(newResult) newResult._addRequest(request);
    return newResult;
}

/**
 * @param {Request} request
 * @param {C.RESULT_STATE} notification
 * @private
 */
function notifyListeners(request, notification){
    Base._queueResultCallback(request, notification);
}

/**
 * @param {C.RESULT_STATE} notification
 */
Request.prototype._onDataNodeChange = function(notification){
    notifyListeners(this, notification);
};

/**
 * A ComputeRequest is a Request for a ComputeResult, which contains a named map of typed values.
 * @constructor
 * @extends {Request}
 * @param {DataNode} dataNode The DataNode from which to request results
 * @param {?Array.<string>} filter A list of names filtering the values to be received (only return values with names inside the filter)
 * @param {?function} callback A callback function that gets called whenever the result of the Request changes
 */
var ComputeRequest = function(dataNode, filter, callback){
    Request.call(this, dataNode, filter, callback);
};
Base.createClass(ComputeRequest, Request);

/**
 * @returns {Result}
 */
ComputeRequest.prototype.getResult = function(){
    // swapResultRequest is called here because the result object of the request may change, e.g.
    // different forward node.
    return swapResultRequest(this, this._dataNode._getResult(C.RESULT_TYPE.COMPUTE, this._filter));
};

ComputeRequest.prototype._onResultChanged = function(notification){
    this._onDataNodeChange(notification);
};


var c_vsConnectNodeCount = {},
    c_vsConnectNodeKey = {},
    c_vsConnectNodeCache = {};

/**
 * A VertexShaderRequest is a Request for a VSDataResult, used to generate a VertexShader that includes
 * dataflow processing.
 * @constructor
 * @extends {Request}
 * @param {DataNode} dataNode
 * @param {VSConfig} vsConfig Configuration for the output of the generated vertex shader
 * @param {?function} callback A callback function that gets called whenever the result of the Request changes
 */
var VertexShaderRequest = function(dataNode, vsConfig, callback){
    var filter = vsConfig.getFilter();
    if(filter.length == 0)
        throw new Error("vsConfig requires at least one attribute entry.");
    Request.call(this, dataNode, filter, callback);
    this._vsConfig = vsConfig;
    this._vsConnectNode = getVsConnectNode(dataNode, vsConfig);
};
Base.createClass(VertexShaderRequest, Request);

VertexShaderRequest.prototype.getConfig = function(){
    return this._vsConfig;
};

/**
 * @see ComputeRequest.getResult
 * @returns {Result}
 */
VertexShaderRequest.prototype.getResult = function(){
    return swapResultRequest(this, this._vsConnectNode._getResult(C.RESULT_TYPE.VS, this._filter));
};

VertexShaderRequest.prototype._onDataNodeChange = function(notification){
    if(notification == C.RESULT_STATE.CHANGED_STRUCTURE){
        var newVSConnectedNode = getVsConnectNode(this._dataNode, this._vsConfig, this._filter);
        if(newVSConnectedNode != this._vsConnectNode){
            clearVsConnectNode(this._vsConnectNode);
            this._vsConnectNode = newVSConnectedNode;
        }
    }
    Request.prototype._onDataNodeChange.call(this, notification);
};

VertexShaderRequest.prototype.getVertexShader = function(){
    this.getResult(); // Update the result first
    if(!this._vertexShader){
        this._vertexShader = this._result.getVertexShader(this._vsConfig);
    }
    return this._vertexShader;
};

VertexShaderRequest.prototype._onResultChanged = function(notification){
    this._onDataNodeChange(notification);
};

function getVsConnectNode(dataNode, vsConfig, filter){
    var forwardNode = dataNode._getForwardNode(filter);

    var key = getDataNodeShaderKey(forwardNode, vsConfig);
    var connectNode;
    if(!(connectNode = c_vsConnectNodeCache[key])){
        connectNode = new DataNode(false);
        connectNode.appendChild(forwardNode);

        connectNode.computeOperator = vsConfig.getOperator();
        connectNode.computeInputMapping = null;
        connectNode.computeOutputMapping = null;

        c_vsConnectNodeCache[key] = connectNode;
        c_vsConnectNodeCount[connectNode.id] = 1;
        c_vsConnectNodeKey[connectNode.id] = key;
    }
    else{
        c_vsConnectNodeCount[connectNode.id]++;
    }

    return connectNode;
}

function clearVsConnectNode(connectNode){
    c_vsConnectNodeCount[connectNode.id]--;
    if(!c_vsConnectNodeCount[connectNode.id]){
        var key = c_vsConnectNodeKey[connectNode.id];
        c_vsConnectNodeCache[key] = null;
        connectNode.clear();
    }
}


function getDataNodeShaderKey(dataNode, vsConfig){
    return dataNode.id + "|" + vsConfig.getKey();
}

module.exports = {
    ComputeRequest:  ComputeRequest,
    VertexShaderRequest: VertexShaderRequest
};

},{"../base.js":186,"./constants.js":187,"./graph.js":189}],191:[function(require,module,exports){
var C =require("../interface/constants.js");

/**
 * CLProgram implements automatic Xflow input/output adaptive WebCL kernel and application code generation.
 *
 * @param operatorList
 * @constructor
 */

var CLProgram = function (operatorList) {
    this.cl = XML3D.webcl.cl; // CL wrapper

    if (!this.cl) {
        return;
    }

    this.list = operatorList;
    this.entry = operatorList.entries[0];
    this.operator = this.entry.operator;

    this.kernelParamMap = {inputs: [], outputs: []}; // Stores initialised KernelParam objects
    this.kernelFunctionParams = []; // Stores generated function parameters for kernel function header.
    this.kernelCode = null; // Generated kernel code
    this.kernelProgram = null; // Compiled kernel program
    this.mainProgram = null; // Main WebCL application code

};

/**
 * Map of helper kernel parameters required for certain input data types.
 *
 * @type Object
 */
var helperParamMap = {
    'texture': {type: "uint", params: ["width", "height"]}, 'buffer': {type: "uint", params: ["length"]}
};

/**
 * Utility prototype object for mapping Xflow inputs to kernel parameters and for generating kernel code.
 *
 * @param {Object} program
 * @param {String} name
 * @param {C.DATA_TYPE} xflowType
 * @param {String} clType
 * @param entryValue
 * @param {Boolean?} isInput
 * @name KernelParam
 * @constructor KernelParam
 */

function KernelParam(program, name, xflowType, clType, entryValue, isInput) {
    this.program = program;
    this.cl = program.cl;
    this.name = name;
    this.type = clType || null;
    this.isInput = !!isInput;
    this.needsMemObject = false;
    this.hasMemObject = false;
    this.byteSize = null;
    this.memObjectSize = null;
    this.arg = null;
    this.clFunctionParam = null;
    this.xflowType = xflowType;
    this.helperMap = null;
    this.helpers = [];
    this.entryValue = entryValue || null;
    this.val = null;

    this.prepareParam();
    this.initHelperParams();
    this.initKernelArg();
    this.updateValue(this.entryValue);

}

KernelParam.prototype = {
    /**
     * Prepares the kernel parameter data.
     * Maps the input xflow data type to webcl data type and creates a kernel function header parameter with proper
     * declarations.
     */
    prepareParam: function () {
        var helperMap;
        var xflowDataTypes = C.DATA_TYPE;
        var kernelFuncParam = [];
        var addressSpace = '';
        var declarations = '';

        if (!this.type) {
            switch (this.xflowType) {
                case xflowDataTypes.TEXTURE:
                {
                    helperMap = helperParamMap.texture;
                    this.type = "uchar4*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                case xflowDataTypes.INT:
                {
                    this.type = "int";
                }
                    break;
                case xflowDataTypes.INT4:
                {
                    helperMap = helperParamMap.buffer;
                    this.type = "int4*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                case xflowDataTypes.FLOAT:
                {
                    this.type = "float";
                }
                    break;
                case xflowDataTypes.FLOAT2:
                {
                    helperMap = helperParamMap.buffer;
                    this.type = "float2*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                case xflowDataTypes.FLOAT3:
                {
                    helperMap = helperParamMap.buffer;
                    this.type = "float*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                case xflowDataTypes.FLOAT4:
                {
                    helperMap = helperParamMap.buffer;
                    this.type = "float4*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                case xflowDataTypes.FLOAT4X4:
                {
                    helperMap = helperParamMap.buffer;
                    this.type = "float16*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                default:
                    return;
            }

            this.helperMap = helperMap;
        }

        // Arranging parameter parts
        if (addressSpace) {
            kernelFuncParam.push(addressSpace);
        }

        if (this.isInput) {
            declarations = 'const';
        }

        if (declarations) {
            kernelFuncParam.push(declarations);
        }

        kernelFuncParam.push(this.type);
        kernelFuncParam.push(this.name);
        this.clFunctionParam = kernelFuncParam.join(' ');
    },

    /**
     * Initialises helper parameters for an input parameter if needed.
     *
     */

    initHelperParams: function () {
        var helperVal;
        var self = this;
        var helperMap = this.helperMap;

        if (helperMap && this.isInput) {
            helperMap.params.forEach(function (p) {
                var pName = self.name + '_' + p;
                if (p === "width") {
                    helperVal = self.entryValue.width;
                } else if (p === "height") {
                    helperVal = self.entryValue.height;
                } else if (p === "length") {
                    helperVal = self.entryValue.length;
                    var type = self.xflowType;
                    switch (type) {
                        case C.DATA_TYPE.FLOAT2:
                        {
                            helperVal = helperVal / 2;
                        }
                            break;
                        case C.DATA_TYPE.FLOAT3:
                        {
                            helperVal = helperVal / 3;
                        }
                            break;
                        case C.DATA_TYPE.FLOAT4:
                        case C.DATA_TYPE.INT4:
                        {
                            helperVal = helperVal / 4;
                        }
                            break;
                        case C.DATA_TYPE.FLOAT4X4:
                        {
                            helperVal = helperVal / 16;
                        }
                            break;
                        default:
                            break;
                    }
                }
                self.helpers.push(new KernelParam(self.program, pName, null, helperMap.type, new Uint32Array([helperVal])));
            });
        }
    },

    /**
     * Initialises kernel argument that will be passed directly into the compiled kernel.
     * Creates a WebCL memory object if needed (e.g. for texture).
     */

    initKernelArg: function () {
        if (this.needsMemObject) {
            this.allocateMemObject();
        } else {
            this.arg = this.entryValue;
        }
    },

    allocateMemObject: function () {
        var clAPI = this.cl.API;
        var clCtx = this.cl.ctx;
        var paramType = this.type;
        var byteSize = parseInt(paramType.substring(paramType.length - 2, paramType.length - 1), 10);
        var memObjectMode = this.isInput ? 'r' : 'w';
        var entryValue = this.entryValue;
        var memObjectSize, memObject;

        if (this.hasMemObject) {
            this.arg.release();
        }

        this.byteSize = isNaN(byteSize) ? 1 : byteSize;

        if (this.xflowType === C.DATA_TYPE.TEXTURE) { // Texture is a special case
            memObjectSize = entryValue.width * entryValue.height * byteSize;
            this.byteSize = 4;
        } else {
            switch (this.xflowType) {
                case C.DATA_TYPE.INT4:
                {
                    memObjectSize = entryValue.length * Int32Array.BYTES_PER_ELEMENT;
                }
                    break;
                case C.DATA_TYPE.FLOAT2:
                case C.DATA_TYPE.FLOAT3:
                case C.DATA_TYPE.FLOAT4:
                case C.DATA_TYPE.FLOAT4x4:
                {
                    memObjectSize = entryValue.length * Float32Array.BYTES_PER_ELEMENT;
                }
                    break;
                default:
                    memObjectSize = entryValue.length * 4;
                    break;
            }
        }

        memObject = clAPI.createBuffer(memObjectSize, memObjectMode, clCtx);

        this.memObjectSize = memObjectSize;
        this.arg = memObject;

        this.hasMemObject = true;
        this.needsMemObject = false;

    },

    updateValue: function (entry) {
        if (this.hasMemObject) {
            this.val = entry.data === undefined ? entry : entry.data;
            this.entryValue = entry;
            this.checkEntrySize();
        } else {
            this.arg = this.entryValue = entry;
        }
    }, updateHelpers: function () {
        var helpers = this.helpers;
        var self = this;

        helpers.forEach(function (p) {
            var name = p.name;
            if (name.indexOf("width") !== -1) {
                p.updateValue(new Uint32Array([self.entryValue.width]));
            } else if (name.indexOf("height") !== -1) {
                p.updateValue(new Uint32Array([self.entryValue.height]));
            } else if (name.indexOf("length") !== -1) {
                var len = self.entryValue.length;
                if (self.xflowType === C.DATA_TYPE.FLOAT4 || self.xflowType === C.DATA_TYPE.INT4) {
                    len = len / 4;
                } else if (self.xflowType === C.DATA_TYPE.FLOAT4X4) {
                    len = len / 16;
                }
                p.updateValue(new Uint32Array([len]));
            }
        });
    }, checkEntrySize: function () {
        var newSize;
        var entryVal = this.entryValue;

        if (this.xflowType === C.DATA_TYPE.TEXTURE) {
            newSize = entryVal.width * entryVal.height * this.byteSize;
        } else if (this.xflowType === C.DATA_TYPE.FLOAT2 || this.xflowType === C.DATA_TYPE.FLOAT3 || this.xflowType === C.DATA_TYPE.FLOAT4 || this.xflowType === C.DATA_TYPE.FLOAT4X4) {
            newSize = entryVal.length * Float32Array.BYTES_PER_ELEMENT;
        } else if (this.xflowType === C.DATA_TYPE.INT4) {
            newSize = entryVal.length * Int32Array.BYTES_PER_ELEMENT;
        } else {
            newSize = entryVal.length * this.byteSize;
        }
        if (this.memObjectSize !== newSize) {
            this.allocateMemObject();
            this.updateHelpers();
            this.program.mainProgram = null; // Forcing CL application program update
        }
    }
};


/**
 * Runs CLProgram. WebCL related code initialised in the first run.
 *
 * @param programData
 */

CLProgram.prototype.run = function (programData) {
    var operatorData = prepareOperatorData(this.list, 0, programData);

    applyDefaultOperation(this.entry, programData, operatorData, this);

};

function prepareOperatorData(list, idx, programData) {
    var doIterate, i;
    var data = programData.operatorData[0];
    var entry = list.entries[idx];
    var mapping = entry.operator.mapping;

    data.iterFlag = {};

    for (i = 0; i < mapping.length; ++i) {
        doIterate = (entry.isTransferInput(i) || list.isInputIterate(entry.getDirectInputIndex(i)));
        data.iterFlag[i] = doIterate;
    }

    data.iterateCount = list.getIterateCount(programData);

    return data;
}

function applyDefaultOperation(entry, programData, operatorData, program) {
    if (program.operator.evaluate && program.operator.evaluate instanceof Array) {
        assembleFunctionArgs(entry, programData, program);

        if (program.kernelCode === null) {
            prepareWebCLKernel(programData, program);
        }
        //console.time('CLProgram (' + program.operator.name + ')');
        if (program.mainProgram === null) {
            program.mainProgram = createMainWebCLProgram(program);
        }
        program.mainProgram();
        //console.timeEnd('CLProgram (' + program.operator.name + ')');
    }
}

/**
 * Maps Xflow inputs and outputs into WebCL kernel inputs and outputs.
 *
 * @function assembleFunctionArgs
 * @param entry
 * @param programData
 * @param program
 */

function assembleFunctionArgs(entry, programData, program) {
    var d, dataEntry, i;
    var kernelFunctionParams = program.kernelFunctionParams;
    var outputs = program.operator.outputs;

    kernelFunctionParams.length = 0;

    for (i = 0; i < outputs.length; ++i) {
        d = outputs[i];
        dataEntry = programData.outputs[entry.getOutputIndex(i)].dataEntry;

        prepareKernelParameter(d, !!(d.source), program, kernelFunctionParams, dataEntry, i);
    }

    addInputToArgs(entry, programData, program, kernelFunctionParams);
}


function addInputToArgs(entry, programData, program, kernelFunctionParams) {
    var mapEntry, dataEntry, i;
    var mapping = entry.operator.mapping;

    for (i = 0; i < mapping.length; ++i) {
        mapEntry = mapping[i];
        dataEntry = programData.getDataEntry(entry.getDirectInputIndex(i));

        prepareKernelParameter(mapEntry, !!(mapEntry.source), program, kernelFunctionParams, dataEntry, i);
    }
}

/**
 * Creates a new KernelParam utility object or updates the existing object if input value has been changed.
 * Additionally, this is used for generating the WebCL kernel function header.
 *
 * @function prepareKernelParameter
 * @param param
 * @param input
 * @param program
 * @param functionParams
 * @param arg
 * @param i
 */

function prepareKernelParameter(param, input, program, functionParams, arg, i) {
    var kernelParams;
    var entryVal = arg ? arg.getValue() : null;

    if (input) {
        kernelParams = program.kernelParamMap.inputs;
    } else {
        kernelParams = program.kernelParamMap.outputs;
    }

    if (kernelParams[i]) {
        kernelParams[i].updateValue(entryVal);
        return;
    }

    kernelParams[i] = new KernelParam(program, param.name, param.type, null, entryVal, input);

    // Pushing generated kernel function params into array.
    // This array is later used in generating the WebCL kernel function header.
    functionParams.push(kernelParams[i].clFunctionParam);

    kernelParams[i].helpers.forEach(function (p) {
        functionParams.push(p.clFunctionParam);
    });
}


/** KERNEL CODE PREPARATION **/


/**
 * Compiles and registers the prepared WebCL kernel code.
 *
 * @function prepareWebCLKernel
 * @param programData
 * @param program
 * @returns {boolean}
 */

function prepareWebCLKernel(programData, program) {
    var kernelCode;
    var kernelManager = program.cl.kernelManager;
    var inputKernel = program.operator.evaluate;
    var kernelName = program.kernelName = program.operator.name.split('xflow.')[1];

    if (!inputKernel) {
        return false;
    }

    kernelCode = program.kernelCode = prepareKernelCode(kernelName, inputKernel, program);

    try {
        kernelManager.register(kernelName, kernelCode);
    } catch (e) {
        return false;
    }

    program.kernelProgram = kernelManager.getKernel(program.kernelName);

    return true;
}

/**
 *
 * Generates kernel function header and helper kernel code and combines it with user's input kernel code.
 *
 * @function prepareKernelCode
 * @param {String} kernelName
 * @param {Array} inputKernel
 * @param program
 * @returns {String}
 */

function prepareKernelCode(kernelName, inputKernel, program) {
    var result, innerKernelCode;

    result = createKernelHeader(kernelName, program);

    if (!result) {
        return false;
    }

    result += '{\n';

    innerKernelCode = createInnerKernelCode(program);

    if (!innerKernelCode) {
        return false;
    }

    result += innerKernelCode;
    result += inputKernel.join('\n');
    result += '\n}';

    return result;
}

/**
 * Generates a kernel function header from assembled kernel parameters.
 *
 * @function createKernelHeader
 * @param kernelName
 * @param program
 * @returns {string}
 */

function createKernelHeader(kernelName, program) {
    var functionHeader = [];

    functionHeader.push("__kernel void");
    functionHeader.push(kernelName + '(');
    functionHeader.push(program.kernelFunctionParams.join(', '));
    functionHeader.push(')');

    return functionHeader.join(' ');
}

/**
 * Generates helper kernel code.
 *
 * @function createInnerKernelCode
 * @param program
 * @returns {string}
 */

function createInnerKernelCode(program) {
    var codeLines = [];

    var firstInput = program.kernelParamMap.inputs[0];

    if (firstInput.type === "uchar4*") {
        // Add "iterators"
        codeLines.push("int x = get_global_id(0);");
        codeLines.push("int y = get_global_id(1);");

        // Add bounds checkers
        codeLines.push("if (x >= " + firstInput.name + "_width || y >= " + firstInput.name + "_height) return;");

        // Add input iterator
        codeLines.push("int " + firstInput.name + "_i = y * " + firstInput.name + "_width + x;");

    } else { // Else, assuming that the first input is an 1-dimensional buffer

        codeLines.push("int " + firstInput.name + "_i = get_global_id(0);");

        codeLines.push("if (" + firstInput.name + "_i >= " + firstInput.name + "_length) return;");
    }

    return codeLines.join('\n');

}


/** MAIN WEBCL PROGRAM INITIALISATION **/

/**
 * Initialises the main WebCL application code that executes the WebCL kernel
 *
 * @function createMainWebCLProgram
 * @param program
 * @returns {Function}
 */

function createMainWebCLProgram(program) {
    var cl = program.cl;
    var kernelManager = cl.kernelManager;
    var cmdQueue = cl.cmdQueue;
    var memObjects = {inputs: [], outputs: []};
    var assembledArgs = assembleKernelArguments(program.kernelParamMap, memObjects);
    var WSSizes = computeWorkGroupSize(program.kernelParamMap.inputs[0]);
    var kernel = program.kernelProgram;

    return function () {
        var i, len, memObj, args;
        var inputMemObjs = memObjects.inputs;
        var outputMemObjs = memObjects.outputs;

        if (!kernel) {
            return false;
        }

        args = assembledArgs.map(function (a) {
            return a.arg;
        });

        kernelManager.setArgs.apply(null, [kernel].concat(args));

        try {
            // Write the buffer to OpenCL device memory
            len = inputMemObjs.length;
            for (i = 0; i < len; i++) {
                memObj = inputMemObjs[i];
                cmdQueue.enqueueWriteBuffer(memObj.arg, false, 0, /*memObj.arg.getInfo(WebCL.MEM_SIZE)*/memObj.memObjectSize, memObj.val, []);
            }

            // Execute (enqueue) kernel
            cmdQueue.enqueueNDRangeKernel(kernel, WSSizes[1].length, [], WSSizes[1], WSSizes[0]);

            // Read the result buffer from OpenCL device
            len = outputMemObjs.length;
            for (i = 0; i < len; i++) {
                memObj = outputMemObjs[i];
                cmdQueue.enqueueReadBuffer(memObj.arg, false, 0, /*memObj.arg.getInfo(WebCL.MEM_SIZE)*/memObj.memObjectSize, memObj.val, []);
            }

            cmdQueue.finish(); //Finish all the operations

        } catch (e) {
            return false;
        }

        return true;
    };
}


/**
 * Arranges initialised kernel arguments into helper arrays so they are more easily available in
 * the main WebCL application.
 *
 * @function assembleKernelArguments
 * @param paramMap
 * @param memObjects
 * @returns {Array}
 */

function assembleKernelArguments(paramMap, memObjects) {
    var outputs = paramMap.outputs;
    var inputs = paramMap.inputs;
    var kernelArgs = [];

    outputs.forEach(function (p) {
        mapKernelArgument(p, kernelArgs, memObjects.outputs);
    });

    inputs.forEach(function (p) {
        mapKernelArgument(p, kernelArgs, memObjects.inputs);
    });

    return kernelArgs;
}

function mapKernelArgument(param, kernelArgs, memObjects) {
    kernelArgs.push(param);

    if (param.hasMemObject) {
        memObjects.push(param);
        param.helpers.forEach(function (p) {
            kernelArgs.push(p);
        });
    }
}

/**
 * Computes a proper WebCL kernel workgroup size for target input buffer
 *
 * @function computeWorkGroupSize
 * @param targetInput
 * @returns {Array}
 */

function computeWorkGroupSize(targetInput) {
    var localWS, globalWS;
    var entryVal = targetInput.entryValue;

    if (targetInput.xflowType === C.DATA_TYPE.TEXTURE) {
        localWS = [16, 4];
        globalWS = [Math.ceil(entryVal.width / localWS[0]) * localWS[0], Math.ceil(entryVal.height / localWS[1]) * localWS[1]];
    } else {
        var k = 1;
        switch (targetInput.xflowType) {
            case C.DATA_TYPE.INT4:
            case C.DATA_TYPE.FLOAT4:
            {
                k = 4;
            }
                break;
            case C.DATA_TYPE.FLOAT3:
            {
                k = 3;
            }
                break;
            case C.DATA_TYPE.FLOAT4X4:
            {
                k = 16;
            }
                break;
        }
        localWS = [16];
        globalWS = [Math.ceil(entryVal.length / (localWS[0] * k)) * localWS[0]];
    }

    return [localWS, globalWS];
}

module.exports = CLProgram;

},{"../interface/constants.js":187}],192:[function(require,module,exports){
Xflow.registerOperator("xflow.add", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'value1'},
                {type: 'float3', source: 'value2'}],
    evaluate: function(result, value1, value2, info) {
        throw new Error("Not used!");
    },
    evaluate_core: function(result, value1, value2){
        result[0] = value1[0] + value2[0];
        result[1] = value1[1] + value2[1];
        result[2] = value1[2] + value2[2];
    }
});

},{}],193:[function(require,module,exports){
Xflow.registerOperator("xflow.bufferSelect", {
    outputs: [  {type: 'float3', name: 'result', noAlloc: true}],
    params:  [  {type: 'float3', source: 'trueOption', array: true},
                {type: 'float3', source: 'falseOption', array: true},
                {type: 'bool', source: 'value', array: true}],
    evaluate: function(result, falseOption, trueOption, value) {
        result.assign = value[0] ? trueOption : falseOption;

        return true;
    }
});

},{}],194:[function(require,module,exports){
Xflow.registerOperator("xflow.clampImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image', formatType: 'ImageData'} ],
    params:  [ {type: 'texture', source : 'image'},
               {type: 'float', source : 'min'},
               {type: 'float', source : 'max'}
             ],
    evaluate: function(result, image, min, max) {
        var inpix = image.data;
        var outpix = result.data;
        var minv = min[0];
        var maxv = max[0];
        var len = image.data.length;
        for (var i = 0 ; i < len; i++) {
            var val = inpix[i];
            if (val < minv) val = minv;
            if (val > maxv) val = maxv;
            outpix[i] = val;
        }
        return true;
    }
});

},{}],195:[function(require,module,exports){
// Code portions from http://www.html5rocks.com/en/tutorials/canvas/imagefilters/

(function() {

    function convolute(inpixels, outpixels, weights, opaque) {
        var side = Math.round(Math.sqrt(weights.length));
        var halfSide = Math.floor(side/2);
        var src = inpixels.data;
        var sw = inpixels.width;
        var sh = inpixels.height;
        // pad output by the convolution matrix
        var w = sw;
        var h = sh;
        var dst = outpixels.data;
        // go through the destination image pixels
        var alphaFac = opaque ? 1 : 0;
        for (var y=0; y<h; y++) {
            for (var x=0; x<w; x++) {
                var sy = y;
                var sx = x;
                var dstOff = (y*w+x)*4;
                // calculate the weighed sum of the source image pixels that
                // fall under the convolution matrix
                var r=0, g=0, b=0, a=0;
                for (var cy=0; cy<side; cy++) {
                    for (var cx=0; cx<side; cx++) {
                        var scy = sy + cy - halfSide;
                        var scx = sx + cx - halfSide;
                        if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                            var srcOff = (scy*sw+scx)*4;
                            var wt = weights[cy*side+cx];
                            r += src[srcOff] * wt;
                            g += src[srcOff+1] * wt;
                            b += src[srcOff+2] * wt;
                            a += src[srcOff+3] * wt;
                        }
                    }
                }
                dst[dstOff] = r;
                dst[dstOff+1] = g;
                dst[dstOff+2] = b;
                dst[dstOff+3] = a + alphaFac*(255-a);
            }
        }
        return outpixels;
    };

    Xflow.registerOperator("xflow.convoluteImage", {
        outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
        params:  [
            {type: 'texture', source : 'image'},
            {type: 'float', source : 'kernel'}
        ],
        evaluate: function(result, image, kernel) {
            convolute(image, result, kernel, true);
            return true;
        }
    });

    Xflow.registerOperator("xflow.convoluteImageToFloat", {
        outputs: [ {type: 'texture', name : 'result', sizeof: 'image', formatType : 'float32'} ],
        params:  [
            {type: 'texture', source : 'image'},
            {type: 'float', source : 'kernel'}
        ],
        evaluate: function(result, image, kernel) {
            convolute(image, result, kernel, true);
            return true;
        }
    });

})();

},{}],196:[function(require,module,exports){
Xflow.registerOperator("xflow.createIGIndex", {
    outputs:[
        //{type:'int', name:'index', customAlloc:true },
        {type:'float2', name:'texcoord', customAlloc:true }
    ],
    params:[
        {type:'int', source:'vertexCount', optional:false},
        {type:'texture', source:'positionTex', optional: false}
    ],
    alloc:function (sizes, vertexCount, image) {
        sizes['texcoord'] = image.width * image.height;
        //sizes['index'] = vertexCount[0];
    },
    evaluate:function (texcoord, vertexCount, image, info) {
        // tex coords
        var halfPixel = {
            x: 0.5 / image.width,
            y: 0.5 / image.height
        };
        var i = 0;
        for (var y = 0, ylength = image.height; y < ylength; y++)
        {
            for (var x = 0, xlength = image.width; x < xlength; x++)
            {
                texcoord[i++] = (x / xlength) + halfPixel.x;
                texcoord[i++] = 1 - ((y / ylength) + halfPixel.y);
            }
        }

        // index creation
        /*for(var i = 0; i < vertexCount[0]; i++) {
            index[i] = i;
        }*/
        return true;
    }
});

},{}],197:[function(require,module,exports){
(function() {
    var TMP_MATRIX = XML3D.math.mat4.create();
    var TMP_VEC = XML3D.math.vec3.create();
    var TMP_QUAT = XML3D.math.quat.create();
    var mat4 = XML3D.math.mat4;

    Xflow.registerOperator("xflow.createTransform", {
        outputs: [{type: 'float4x4', name: 'result'}],
        params: [{type: 'float3', source: 'translation', optional: true},
            {type: 'float4', source: 'rotation', optional: true},
            {type: 'float3', source: 'scale', optional: true},
            {type: 'float3', source: 'center', optional: true},
            {type: 'float4', source: 'scaleOrientation', optional: true}],
        evaluate: function (result, translation, rotation, scale, center, scaleOrientation, info) {
            for (var i = 0; i < info.iterateCount; i++) {
                var dest = result.subarray(i * 16);
                mat4.identity(dest);
                translation && mat4.translate(dest, dest, info.iterFlag[0] ? translation.subarray(i*3) : translation);
                center && mat4.translate(dest, dest, info.iterFlag[0] ? center.subarray(i*3) : center);
                if (rotation) {
                    mat4.fromRotationTranslation(TMP_MATRIX, info.iterFlag[1] ? rotation.subarray(i*4) : rotation, [0, 0, 0]);
                    mat4.multiply(dest, dest, TMP_MATRIX);
                }
                if (scaleOrientation) {
                    mat4.fromRotationTranslation(TMP_MATRIX, info.iterFlag[4] ? scaleOrientation.subarray(i*4) : scaleOrientation, [0, 0, 0]);
                    mat4.multiply(dest, dest, TMP_MATRIX);
                }
                scale && mat4.scale(dest, dest, info.iterFlag[2] ? scale.subarray(i*3) : scale);
                if (scaleOrientation) {
                    XML3D.math.quat.copy(TMP_QUAT, info.iterFlag[4] ? scaleOrientation.subarray(i*4) : scaleOrientation)
                    mat4.fromRotationTranslation(TMP_MATRIX, XML3D.math.quat.negate(TMP_QUAT, TMP_QUAT), [0, 0, 0]);
                    mat4.multiply(dest, dest, TMP_MATRIX);
                }

                center && mat4.translate(dest, dest, XML3D.math.vec3.negate(TMP_VEC, info.iterFlag[3] ? center.subarray(i*3) : center));

            }
            return true;
        }
    });

})();
},{}],198:[function(require,module,exports){
(function() {
    var TMP_MATRIX = XML3D.math.mat4.create();
    var TMP_VEC = XML3D.math.vec3.create();
    var TMP_QUAT = XML3D.math.quat.create();
    var mat4 = XML3D.math.mat4;

    Xflow.registerOperator("xflow.createTransformInv", {
        outputs: [{type: 'float4x4', name: 'result'}],
        params: [{type: 'float3', source: 'translation', optional: true},
            {type: 'float4', source: 'rotation', optional: true},
            {type: 'float3', source: 'scale', optional: true},
            {type: 'float3', source: 'center', optional: true},
            {type: 'float4', source: 'scaleOrientation', optional: true}],
        evaluate: function (result, translation, rotation, scale, center, scaleOrientation, info) {
            for (var i = 0; i < info.iterateCount; i++) {
                var dest = result.subarray(i * 16);
                mat4.identity(dest);
                center && mat4.translate(dest, dest, info.iterFlag[3] ? center.subarray(i*3) : center);

                if (scaleOrientation) {
                    mat4.fromRotationTranslation(TMP_MATRIX, info.iterFlag[4] ? scaleOrientation.subarray(i*4) : scaleOrientation, [0, 0, 0]);
                    mat4.multiply(dest, dest, TMP_MATRIX);
                }
                scale && mat4.scale(dest, dest, XML3D.math.vec3.reciprocal(TMP_VEC, info.iterFlag[2] ? scale.subarray(i*3) : scale));
                if (scaleOrientation) {
                    XML3D.math.quat.copy(TMP_QUAT, info.iterFlag[4] ? scaleOrientation.subarray(i*4) : scaleOrientation);
                    mat4.fromRotationTranslation(TMP_MATRIX, XML3D.math.quat.invert(TMP_QUAT, TMP_QUAT), [0, 0, 0]);
                    mat4.multiply(dest, dest, TMP_MATRIX);
                }
                if (rotation) {
                    XML3D.math.quat.copy(TMP_QUAT, info.iterFlag[1] ? rotation.subarray(i*4) : rotation);
                    mat4.fromRotationTranslation(TMP_MATRIX, XML3D.math.quat.invert(TMP_QUAT, TMP_QUAT), [0, 0, 0]);
                    mat4.multiply(dest, dest, TMP_MATRIX);
                }
                center && mat4.translate(dest, dest, XML3D.math.vec3.negate(TMP_VEC, info.iterFlag[3] ? center.subarray(i*3) : center));
                translation && mat4.translate(dest, dest, XML3D.math.vec3.negate(TMP_VEC, info.iterFlag[0] ? translation.subarray(i*3) : translation));

            }
        }
    });
})();

},{}],199:[function(require,module,exports){
(function(){

var c_CubePositions =  [
    [-1,-1,-1], [1,-1,-1], [-1,1,-1], [1,1,-1], // front
    [-1,-1,-1], [-1,-1,1], [-1,1,-1], [-1,1,1], // left
    [-1,-1,-1], [1,-1,-1], [-1,-1,1], [1,-1,1], // top
    [1,-1,-1], [1,1,-1], [1,-1,1], [1,1,1],     // right
    [-1,1,-1], [1,1,-1], [-1,1,1], [1,1,1],     // bottom
    [-1,-1,1], [1,-1,1], [-1,1,1], [1,1,1]      // back
];
var c_CubeNormals =  [
    [0,0,-1], [0,0,-1], [0,0,-1], [0,0,-1], // front
    [-1,0,0], [-1,0,0], [-1,0,0], [-1,0,0], // left
    [0,-1,0], [0,-1,0], [0,-1,0], [0,-1,0], // top
    [1,0,0], [1,0,0], [1,0,0], [1,0,0],     // right
    [0,1,0], [0,1,0], [0,1,0], [0,1,0],     // bottom
    [0,0,1], [0,0,1], [0,0,1], [0,0,1]      // back
];
var c_CubeIndex = [
    [0,1,2,1,2,3],
    [4,5,6,5,6,7],
    [8,9,10,9,10,11],
    [12,13,14,13,14,15],
    [16,17,18,17,18,19],
    [20,21,22,21,22,23]
]

/**
 * Grid Generation
 */
Xflow.registerOperator("xflow.debug.createSkinCubes", {
    outputs: [	{type: 'int', name: 'index', customAlloc: true},
                {type: 'float3', name: 'position', customAlloc: true},
                {type: 'float3', name: 'normal', customAlloc: true},
                {type: 'int4', name: 'boneIndices', customAlloc: true},
                {type: 'float4', name: 'boneWeights', customAlloc: true}],
    params:  [{type: 'float4x4', source: 'bindTransforms', array: true},
              {type: 'float', source: 'size', array: true, optional: true}],
    alloc: function(sizes, bindTransforms)
    {
        var s = bindTransforms.length / 16;
        sizes['position'] = s * 4 * 6;
        sizes['normal'] = s * 4 * 6;
        sizes['boneIndices'] = s * 4 * 6;
        sizes['boneWeights'] = s * 4 * 6;
        sizes['index'] = s * 6 * 6;
    },
    evaluate: function(index, position, normal, boneIdx, boneWeight, bindTransforms, size) {
        var cubeCount = bindTransforms.length / 16;
        var size = (size && size[0] || 1) / 2;

        var tmpPosition = XML3D.math.vec3.create(),
            tmpNormal = XML3D.math.vec3.create();

        for(var i = 0; i < cubeCount; ++i){
            for(var j = 0; j < 6; ++j){
                for(var k = 0; k < 4; k++){
                    var localIdx = j*4+ k, globalIdx = i*6*4 + localIdx;

                    XML3D.math.vec3.copy(tmpPosition, c_CubePositions[localIdx]);
                    XML3D.math.vec3.scale(tmpPosition, tmpPosition, size);
                    XML3D.math.mat4.multiplyOffsetVec3(bindTransforms, i*16, tmpPosition, 0);
                    XML3D.math.vec3.copy(tmpNormal, c_CubeNormals[localIdx]);
                    XML3D.math.mat4.multiplyOffsetDirection(bindTransforms, i*16, tmpNormal, 0);

                    position[globalIdx*3+0] = tmpPosition[0];
                    position[globalIdx*3+1] = tmpPosition[1];
                    position[globalIdx*3+2] = tmpPosition[2];
                    normal[globalIdx*3+0] = tmpNormal[0];
                    normal[globalIdx*3+1] = tmpNormal[1];
                    normal[globalIdx*3+2] = tmpNormal[2];
                    boneIdx[globalIdx*4+0] = i;
                    boneIdx[globalIdx*4+1] = boneIdx[globalIdx*4+2] = boneIdx[globalIdx*4+3]= 0;
                    boneWeight[globalIdx*4+0] = 1;
                    boneWeight[globalIdx*4+1] = boneWeight[globalIdx*4+2] = boneWeight[globalIdx*4+3]= 0;
                }
                var globalIndexIdx = i*6*6 + j*6;
                for(var k = 0; k < 6; ++k){
                    index[globalIndexIdx+k] = i*6*4 + c_CubeIndex[j][k];
                }
            }
        }
        // We are done!
        position = position;
    }
});

}());

},{}],200:[function(require,module,exports){
Xflow.registerOperator("xflow.div", {
    outputs: [  {type: 'float', name: 'result'}],
    params:  [  {type: 'float', source: 'value1'},
                {type: 'float', source: 'value2'}],
    evaluate: function(result, value1, value2, info) {
        result[0] = value1[0] / value2[0];
    }

});

},{}],201:[function(require,module,exports){
Xflow.registerOperator("xflow.flipNormal", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'value'}],
    evaluate: function(result, value, info) {
        for(var i = 0; i<info.iterateCount*3; i++)
            result[i] = -value[i];
    }
});

},{}],202:[function(require,module,exports){
Xflow.registerOperator("xflow.flipVerticalImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'} ],
    evaluate: function(result, image) {
        var width = image.width;
        var height = image.height;

        var destpix = result.data;
        var srcpix = image.data;

        for (var y = 0; y < height; ++y) {
            for (var x = 0; x < width; ++x) {
                var rowOffset = y * width;
                var srcOffset = (rowOffset + x) * 4;
                var dstOffset = (rowOffset + ((width-1) - x)) * 4;
                destpix[dstOffset] =  srcpix[srcOffset];
                destpix[dstOffset+1] = srcpix[srcOffset+1];
                destpix[dstOffset+2] = srcpix[srcOffset+2];
                destpix[dstOffset+3] = srcpix[srcOffset+3];
            }
        }
        return true;
    }
});

},{}],203:[function(require,module,exports){
Xflow.registerOperator("xflow.forwardKinematics", {
    outputs: [  {type: 'float4x4',  name: 'result', customAlloc: true}],
    params:  [  {type: 'int',       source: 'parent', array: true },
                {type: 'float4x4',  source: 'xform', array: true }],
    alloc: function(sizes, parent, xform)
    {
        var length = Math.min(parent.length, xform.length / 16);
        sizes['result'] = length;
    },
    evaluate: function(result, parent,xform, info) {

        var boneCount = result.length / 16;

        var computed = [];
        //For each bone do:
        for(var i = 0; i < boneCount;){
            if(!computed[i]) {
                var p = parent[i];
                if(p >= 0){
                    //This bone has a parent bone
                    if(!computed[p]){
                        //The parent bone's transformation matrix hasn't been computed yet
                        while(parent[p] >= 0 && !computed[parent[p]]) p = parent[p];

                        if(parent[p] >= 0)
                            XML3D.math.mat4.multiplyOffset(result, p*16, xform, p*16, result, parent[p]*16);
                        else
                            for(var j = 0; j < 16; j++) {
                                result[p*16+j] = xform[p*16+j];
                            }
                        computed[p] = true;
                        continue;
                    }
                    else {
                        XML3D.math.mat4.multiplyOffset(result, i*16, xform, i*16, result,  p*16);
                    }
                }
                else{
                    for(var j = 0; j < 16; j++) {
                        result[i*16+j] = xform[i*16+j];
                    }
                }
                computed[i] = true;
            }
            i++;
        }
    }
});

},{}],204:[function(require,module,exports){
Xflow.registerOperator("xflow.forwardKinematicsInv", {
    outputs: [  {type: 'float4x4',  name: 'result', customAlloc: true}],
    params:  [  {type: 'int',       source: 'parent', array: true },
                {type: 'float4x4',  source: 'xform', array: true }],
    alloc: function(sizes, parent, xform)
    {
        var length = Math.min(parent.length, xform.length / 16);
        sizes['result'] = length;
    },
    evaluate: function(result, parent,xform, info) {
        var boneCount = xform.length / 16;

        var computed = [];
        //For each bone do:
        for(var i = 0; i < boneCount;){
            if(!computed[i]) {
                var p = parent[i];
                if(p >= 0){
                    //This bone has a parent bone
                    if(!computed[p]){
                        //The parent bone's transformation matrix hasn't been computed yet
                        while(parent[p] >= 0 && !computed[parent[p]]) p = parent[p];
                        //The current bone has a parent and its transform hasn't been computed yet

                        if(parent[p] >= 0)
                            XML3D.math.mat4.multiplyOffset(result, p*16, result, parent[p]*16, xform, p*16);
                        else
                            for(var j = 0; j < 16; j++) {
                                result[p*16+j] = xform[p*16+j];
                            }
                        computed[p] = true;
                        continue;

                    }
                    else {
                        XML3D.math.mat4.multiplyOffset(result, i*16,  result,  p*16, xform, i*16);
                    }
                }
                else{
                    for(var j = 0; j < 16; j++) {
                        result[i*16+j] = xform[i*16+j];
                    }
                }
                computed[i] = true;
            }
            i++;
        }
    }
});

},{}],205:[function(require,module,exports){
// Based on: http://web.archive.org/web/20100310063925/http://dem.ocracy.org/libero/photobooth/

Xflow.registerOperator("xflow.funMirrorImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'},
               {type: 'float', source : 'time'} ],
    evaluate: function(result, image, time) {
        var width = result.width;
        var height = result.height;
        var time = time[0];

        var s = image.data;
        var d = result.data;

        for (var y = 0; y < height; ++y) {
            for (var x = 0; x < width; ++x) {

                /*original coordinates*/
                // [0.0 ,1.0] x [0.0, 1.0]
                var coordX = x / width;
                var coordY = y / height;

                // [-1.0 ,1.0] x [-1.0, 1.0]
                var normCoordX = 2.0 * coordX - 1.0;
                var normCoordY = 2.0 * coordY - 1.0;

                /*go to polar coordinates*/
                var r = Math.sqrt(normCoordX*normCoordX + normCoordY*normCoordY); // length(normCoord)
                var phi = Math.atan2(normCoordY, normCoordX);

                /*squeeze and vary it over time*/
                r = Math.pow(r, 1.0/1.8) * time;

                /*back to cartesian coordinates*/
                normCoordX = r * Math.cos(phi);
                normCoordY = r * Math.sin(phi);
                // [0.0 ,1.0] x [0.0, 1.0]
                coordX = normCoordX / 2.0 + 0.5;
                coordY = normCoordY / 2.0 + 0.5;

                var sX = Math.round(coordX * width);
                var sY = Math.round(coordY * height);

                var i = (sY * width + sX)*4;
                var r = s[i];
                var g = s[i + 1];
                var b = s[i + 2];
                var a = s[i + 3];

                /*color the fragment with calculated texture*/
                var i = (y * width + x)*4;
                d[i] = r;
                d[i + 1] = g;
                d[i + 2] = b;
                d[i + 3] = a;
            }
        }
        return true;
    }
});

},{}],206:[function(require,module,exports){

function fetch(result, value, index, components){
    for(var i = 0; i < index.length; ++i) {
        var offset = index[i] * components;
        var j = components;
        while(j--) {
            result[i*components + j] = value[offset + j];
        }
    }
}

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'float', name: 'result'}],
    params:  [  {type: 'float', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 1);
    }
});

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'float2', name: 'result'}],
    params:  [  {type: 'float2', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 2);
    }
});

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 4);
    }
});


Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'float4', name: 'result'}],
    params:  [  {type: 'float4', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 4);
    }
});

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'float4x4', name: 'result'}],
    params:  [  {type: 'float4x4', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 16);
    }
});


Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'int', name: 'result'}],
    params:  [  {type: 'int', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 1);
    }
});

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'bool', name: 'result'}],
    params:  [  {type: 'bool', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 1);
    }
});

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'byte', name: 'result'}],
    params:  [  {type: 'byte', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 1);
    }
});



Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'ubyte', name: 'result'}],
    params:  [  {type: 'ubyte', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 1);
    }
});

},{}],207:[function(require,module,exports){
Xflow.registerOperator("xflow.grayscaleImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'} ],
    evaluate: function(result, image) {
        var width = image.width;
        var height = image.height;

        var s = image.data;
        var d = result.data;
        for (var i = 0; i < s.length; i += 4) {
            var r = s[i];
            var g = s[i + 1];
            var b = s[i + 2];
            var a = s[i + 3];
            // CIE luminance for the RGB
            // The human eye is bad at seeing red and blue, so we de-emphasize them.
            var v = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            d[i] = d[i + 1] = d[i + 2] = v
            d[i + 3] = a;
        }
        return true;
    }
});

},{}],208:[function(require,module,exports){
require("./add.js");
require("./bufferSelect.js");
require("./clampImage.js");
require("./convoluteImage.js");
require("./createIGIndex.js");
require("./createTransform.js");
require("./createTransformInv.js");
require("./debug.js");
require("./flipNormal.js");
require("./flipVerticalImage.js");
require("./forwardKinematics.js");
require("./forwardKinematicsInv.js");
require("./funMirrorImage.js");
require("./get.js");
require("./grayscaleImage.js");
require("./lerp3seq.js");
require("./magnitudeImage.js");
require("./morph3.js");
require("./mul4x4.js");
require("./noiseImage.js");
require("./normalize3.js");
require("./popartImage.js");
require("./rgbePNGtoFloat.js");
require("./selectBool.js");
require("./selectTransform.js");
require("./sepiaImage.js");
require("./skinDirection.js");
require("./skinPosition.js");
require("./slerpseq.js");
require("./sobelImage.js");
require("./sub3.js");
require("./div.js");

},{"./add.js":192,"./bufferSelect.js":193,"./clampImage.js":194,"./convoluteImage.js":195,"./createIGIndex.js":196,"./createTransform.js":197,"./createTransformInv.js":198,"./debug.js":199,"./div.js":200,"./flipNormal.js":201,"./flipVerticalImage.js":202,"./forwardKinematics.js":203,"./forwardKinematicsInv.js":204,"./funMirrorImage.js":205,"./get.js":206,"./grayscaleImage.js":207,"./lerp3seq.js":209,"./magnitudeImage.js":210,"./morph3.js":211,"./mul4x4.js":212,"./noiseImage.js":213,"./normalize3.js":214,"./popartImage.js":215,"./rgbePNGtoFloat.js":216,"./selectBool.js":217,"./selectTransform.js":218,"./sepiaImage.js":219,"./skinDirection.js":220,"./skinPosition.js":221,"./slerpseq.js":222,"./sobelImage.js":223,"./sub3.js":224}],209:[function(require,module,exports){
var binarySearch = require("../../utils/utils").binarySearch;
var XC = require("../../interface/constants.js");

Xflow.registerOperator("xflow.lerpSeq", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'sequence'},
        {type: 'float', source: 'key'}],
    mapping: [  { name: 'value1', source: 'sequence', sequence: XC.SEQUENCE.PREV_BUFFER, keySource: 'key'},
        { name: 'value2', source: 'sequence', sequence: XC.SEQUENCE.NEXT_BUFFER, keySource: 'key'},
        { name: 'weight', source: 'sequence', sequence: XC.SEQUENCE.LINEAR_WEIGHT, keySource: 'key'}],
    evaluate_core: function(result, value1, value2, weight){
        var invWeight = 1 - weight[0];
        result[0] = invWeight*value1[0] + weight[0]*value2[0];
        result[1] = invWeight*value1[1] + weight[0]*value2[1];
        result[2] = invWeight*value1[2] + weight[0]*value2[2];
    }
});


Xflow.registerOperator("xflow.lerpSeqAsync", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'sequence'},
        {type: 'float', source: 'key'}],
    mapping: [  { name: 'value1', source: 'sequence', sequence: XC.SEQUENCE.PREV_BUFFER, keySource: 'key'},
        { name: 'value2', source: 'sequence', sequence: XC.SEQUENCE.NEXT_BUFFER, keySource: 'key'},
        { name: 'weight', source: 'sequence', sequence: XC.SEQUENCE.LINEAR_WEIGHT, keySource: 'key'}],
    evaluate_async: function(result, value1, value2, weight, info, callback){
        var i = info.iterateCount, off0, off1, off2;
        while(i--){
            off0 = (info.iterFlag[0] ? i : 0)*3;
            off1 = (info.iterFlag[1] ? i : 0)*3;
            off2 = info.iterFlag[2] ? i : 0;
            var invWeight = 1 - weight[off2];
            result[i*3] = invWeight*value1[off0] + weight[off2]*value2[off1];
            result[i*3+1] = invWeight*value1[off0+1] + weight[off2]*value2[off1+1];
            result[i*3+2] = invWeight*value1[off0+2] + weight[off2]*value2[off1+2];
        }
        window.setTimeout(callback, 200);
    }
});


Xflow.registerOperator("xflow.lerpKeys", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float', source: 'keys', array: true},
        {type: 'float3', source: 'values', array: true},
        {type: 'float', source: 'key'}],
    alloc: function(sizes, keys, values, key)
    {
        sizes['result'] = 3;
    },
    evaluate: function(result, keys, values, key) {
        var maxIdx = Math.min(keys.length, Math.floor(values.length / 3));
        var idx = binarySearch(keys, key[0], maxIdx);

        if(idx < 0 || idx == maxIdx - 1){
            idx = Math.max(0,idx);
            result[0] = values[3*idx];
            result[1] = values[3*idx+1];
            result[2] = values[3*idx+2];
        }
        else{
            var weight = (key[0] - keys[idx]) / (keys[idx+1] - keys[idx]);
            var invWeight = 1 - weight;
            result[0] = invWeight*values[3*idx] + weight*values[3*idx + 3];
            result[1] = invWeight*values[3*idx+1] + weight*values[3*idx + 4];
            result[2] = invWeight*values[3*idx+2] + weight*values[3*idx + 5];
        }
    }
});






},{"../../interface/constants.js":187,"../../utils/utils":238}],210:[function(require,module,exports){
Xflow.registerOperator("xflow.magnitudeImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image1'} ],
    params:  [
        {type: 'texture', source : 'image1'},
        {type: 'texture', source : 'image2'}
    ],
    evaluate: function(result, image1, image2) {
        var inpix1 = image1.data;
        var inpix2 = image2.data;
        var outpix = result.data;

        var len = inpix1.length;
        for (var i = 0 ; i < len; i+=1) {
            var val1 = inpix1[i];
            var val2 = inpix2[i];
            outpix[i] = Math.sqrt(val1*val1 + val2*val2);
        }
        return true;
    }
});

},{}],211:[function(require,module,exports){

Xflow.registerOperator("xflow.morph", {
    outputs: [{type: 'float3', name: 'result'}],
    params:  [
        { type: 'float3', source: 'value' },
        { type: 'float3', source: 'valueAdd'},
        { type: 'float', source: 'weight'}
    ],
    evaluate: function(result, value, valueAdd, weight, info) {
        for(var i = 0; i < info.iterateCount; i++){
            var w = weight[info.iterFlag[2] ? i : 0];
            result[3*i] = value[ info.iterFlag[0] ? 3*i : 0] + w * valueAdd[info.iterFlag[1] ? 3*i : 0];
            result[3*i+1] = value[ info.iterFlag[0] ? 3*i+1 : 1] + w * valueAdd[info.iterFlag[1] ? 3*i+1 : 1];
            result[3*i+2] = value[ info.iterFlag[0] ? 3*i+2 : 2] + w * valueAdd[info.iterFlag[1] ? 3*i+2 : 2];
        }
        return true;
    },
    evaluate_core: function(result, value, valueAdd, weight){
        result[0] = value[0] + weight[0] * valueAdd[0];
        result[1] = value[1] + weight[0] * valueAdd[1];
        result[2] = value[2] + weight[0] * valueAdd[2];
    }
});

},{}],212:[function(require,module,exports){
Xflow.registerOperator("xflow.mul", {
    outputs: [  {type: 'float4x4', name: 'result'}],
    params:  [  {type: 'float4x4', source: 'value1'},
                {type: 'float4x4', source: 'value2'}],
    evaluate: function(result, value1, value2, info) {
        for(var i = 0; i < info.iterateCount; i++)
        {
            XML3D.math.mat4.multiplyOffset(result, i*16,
                value1,  info.iterFlag[0] ? i*16 : 0,
                value2, info.iterFlag[1] ? i*16 : 0);
        }
    }
});

},{}],213:[function(require,module,exports){

Xflow.registerOperator("xflow.noiseImage", {
    outputs: [ {type: 'texture', name : 'image', customAlloc: true} ],
    params:  [ {type: 'int', source: 'width'},
               {type: 'int', source:'height'},
               {type: 'float2', source: 'scale'},
               {type: 'float', source: 'minFreq'},
               {type: 'float', source: 'maxFreq'} ],
    alloc: function(sizes, width, height, scale, minFreq, maxFreq) {
        var samplerConfig = new Xflow.SamplerConfig;
        samplerConfig.setDefaults();
        sizes['image'] = {
            imageFormat : {width: width[0], height :height[0]},
            samplerConfig : samplerConfig
        };
    },
    evaluate: function(image, width, height, scale, minFreq, maxFreq) {
        width = width[0];
        height = height[0];
        minFreq = minFreq[0];
        maxFreq = maxFreq[0];

        var id = image;
        var pix = id.data;
        this.noise = this.noise || new SimplexNoise();
        var noise = this.noise;

        var useTurbulence = minFreq != 0.0 && maxFreq != 0.0 && minFreq < maxFreq;

        var snoise = function(x,y) {
            return noise.noise(x, y); // noise.noise returns values in range [-1,1]
            //return 2.0 * noise.noise(x, y) - 1.0; // this code is for noise value in range [0,1]
        };

        var turbulence = function(minFreq, maxFreq, s, t) {
            var value = 0;
            for (var f = minFreq; f < maxFreq; f *= 2)
            {
                value += Math.abs(snoise(s * f, t * f))/f;
            }
            return value;
        };

        for (var y = 0; y < height; ++y)
        {
            var t = y / height * scale[1];
            var invWidth = 1.0 / width;

            for (var x = 0; x < width; ++x)
            {
                var s = x * invWidth * scale[0];
                var v = useTurbulence ? turbulence(minFreq, maxFreq, s, t) : snoise(s, t);
                var offset = (x * width + y) * 4;
                pix[offset] =  Math.floor(v * 255);
                pix[offset+1] = Math.floor(v * 255);
                pix[offset+2] = Math.floor(v * 255);
                pix[offset+3] = 255;
            }
        }

        /* Fill with green color
        for (var y = 0; y < height; ++y)
        {
            for (var x = 0; x < width; ++x)
            {
                var offset = (x * width + y) * 4;
                pix[offset] =  0
                pix[offset+1] = 255;
                pix[offset+2] = 0;
                pix[offset+3] = 255;
            }
        }
        */

        return true;
    }
});

},{}],214:[function(require,module,exports){

Xflow.registerOperator("xflow.normalize", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'value'}],
    evaluate: function(result, value, info) {
        for(var i = 0; i < info.iterateCount; i++) {
            var offset = 3*i;
            var x = value[offset];
            var y = value[offset+1];
            var z = value[offset+2];
            var l = 1.0/Math.sqrt(x*x+y*y+z*z);
            result[offset] = x*l;
            result[offset+1] = y*l;
            result[offset+2] = z*l;
        }
    }
});

},{}],215:[function(require,module,exports){

// Based on http://kodemongki.blogspot.de/2011/06/kameraku-custom-shader-effects-example.html
Xflow.registerOperator("xflow.popartImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'},
        {type: 'float', source : 'time'} ],
    evaluate: function(result, image, time) {
        var width = image.width;
        var height = image.height;

        var s = image.data;
        var d = result.data;
        for (var i = 0; i < s.length; i += 4) {
            var r = s[i] / 255;
            var g = s[i + 1] / 255;
            var b = s[i + 2] / 255;
            var a = s[i + 3] / 255;

            var y = 0.3 * r + 0.59 * g + 0.11 * b;
            y = y < 0.3 ? 0.0 : (y < 0.6 ? 0.5 : 1.0);
            if (y == 0.5) {
                d[i]   = 0.8 * 255;
                d[i+1] = 0;
                d[i+2] = 0;
            } else if (y == 1.0) {
                d[i]   = 0.9 * 255;
                d[i+1] = 0.9 * 255;
                d[i+2] = 0;
            } else {
                d[i] = 0;
                d[i+1] = 0;
                d[i+2] = 0;
            }
            d[i+3] = s[i+3];
        }
        return true;
    }
});

},{}],216:[function(require,module,exports){
var SamplerConfig = require("../../interface/data.js").SamplerConfig;
var XC = require("../../interface/constants.js");

Xflow.registerOperator("xflow.rgbePNGtoFloat", {
    outputs: [ {type: 'texture', name : 'result', customAlloc: true } ],
    params:  [
        {type: 'texture', source : 'image'}
    ],
    alloc: function (sizes, image) {
        var samplerConfig = new SamplerConfig;
        samplerConfig.setDefaults();
        samplerConfig.minFilter = XC.TEX_FILTER_TYPE.NEAREST;
        samplerConfig.magFilter = XC.TEX_FILTER_TYPE.NEAREST;
        sizes["result"] = {
            imageFormat : {
                width: image.width,
                height: image.height,
                texelType: XC.TEXTURE_TYPE.FLOAT,
                texelFormat: XC.TEXTURE_FORMAT.RGB
            },
            samplerConfig: samplerConfig
        }
    },

    evaluate: function(result, image) {
        for (var idx = 0; idx < image.data.length; idx += 4) {
            var rgbe = image.data.subarray(idx, idx + 4);
            var f = 0.0;
            var e = rgbe[3];

            if (e > 0.0)
                f = Math.pow(2.0, e - (128.0 + 8.0));

            var rgb = new Float32Array(3);
            rgb[0] = rgbe[0] * f;
            rgb[1] = rgbe[1] * f;
            rgb[2] = rgbe[2] * f;
            result.data.set(rgb, idx / 4 * 3);
        }
        return true;
    }
});

},{"../../interface/constants.js":187,"../../interface/data.js":188}],217:[function(require,module,exports){

Xflow.registerOperator("xflow.selectBool", {
    outputs: [ {type: 'bool', name : 'result', customAlloc: true} ],
    params:  [ {type: 'int', source : 'index'},
               {type: 'bool', source: 'value'} ],
    alloc: function(sizes, index, value) {
        sizes['result'] = 1;
    },
    evaluate: function(result, index, value) {
        var i = index[0];
        if (i < value.length) {
            result[0] = value[i];
        } else {
            result[0] = false;
        }
    }
});

},{}],218:[function(require,module,exports){

Xflow.registerOperator("xflow.selectTransform", {
    outputs: [ {type: 'float4x4', name : 'result', customAlloc: true} ],
    params:  [ {type: 'int', source : 'index'},
               {type: 'float4x4', source: 'transform'} ],
    alloc: function(sizes, index, transform) {
        sizes['result'] = 1;
    },
    evaluate: function(result, index, transform) {
        var i = 16 * index[0];
        if (i < transform.length && i+15 < transform.length) {
            result[0] = transform[i+0];
            result[1] = transform[i+1];
            result[2] = transform[i+2];
            result[3] = transform[i+3];
            result[4] = transform[i+4];
            result[5] = transform[i+5];
            result[6] = transform[i+6];
            result[7] = transform[i+7];
            result[8] = transform[i+8];
            result[9] = transform[i+9];
            result[10] = transform[i+10];
            result[11] = transform[i+11];
            result[12] = transform[i+12];
            result[13] = transform[i+13];
            result[14] = transform[i+14];
            result[15] = transform[i+15];
        } else {
            result[0] = 1;
            result[1] = 0;
            result[2] = 0;
            result[3] = 0;
            result[4] = 0;
            result[5] = 1;
            result[6] = 0;
            result[7] = 0;
            result[8] = 0;
            result[9] = 0;
            result[10] = 1;
            result[11] = 0;
            result[12] = 0;
            result[13] = 0;
            result[14] = 0;
            result[15] = 1;
        }
    }
});

},{}],219:[function(require,module,exports){

Xflow.registerOperator("xflow.sepiaImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'} ],
    evaluate: function(result, image) {
        var s = image.data;
        var d = result.data;
        var r = 0, g = 0, b = 0;
        for(var i = 0 ; i < s.length; i += 4) {
            r = (s[i] * 0.393 + s[i+1] * 0.769 + s[i+2] * 0.189);
            g = (s[i] * 0.349 + s[i+1] * 0.686 + s[i+2] * 0.168);
            b = (s[i] * 0.272 + s[i+1] * 0.534 + s[i+2] * 0.131);
            if (r>255) r = 255;
            if (g>255) g = 255;
            if (b>255) b = 255;
            if (r<0) r = 0;
            if (g<0) g = 0;
            if (b<0) b = 0;
            d[i] = r;
            d[i+1] = g;
            d[i+2] = b;
            d[i+3] = 255;
        }
        return true;
    }
});

},{}],220:[function(require,module,exports){

Xflow.registerOperator("xflow.skinDirection", {
    outputs: [  {type: 'float3', name: 'result' }],
    params:  [  {type: 'float3', source: 'dir' },
                {type: 'int4', source: 'boneIdx' },
                {type: 'float4', source: 'boneWeight' },
                {type: 'float4x4', source: 'boneXform', array: true } ],
    evaluate: function(result, dir,boneIdx,boneWeight,boneXform, info) {
        var vec3 = XML3D.math.vec3,
            mat4 = XML3D.math.mat4;
        var r = vec3.create();
        var tmp =  vec3.create();

        for(var i = 0; i< info.iterateCount;++i) {
            var offset = i*3;
            r[0] = r[1] = r[2] = +0;
            for(var j = 0; j < 4; j++) {
                var weight = boneWeight[info.iterFlag[2] ? i*4+j : j];
                if (weight) {
                    var mo = boneIdx[info.iterFlag[1] ? i*4+j : j]*16;

                    mat4.multiplyOffsetDirection(boneXform, mo, dir, offset, tmp);
                    vec3.scale(tmp, tmp, weight);
                    vec3.add(r, r, tmp);
                }
            }
            vec3.normalize(r, r);
            result[offset] = r[0];
            result[offset+1] = r[1];
            result[offset+2] = r[2];
        }
    }
});

},{}],221:[function(require,module,exports){

Xflow.registerOperator("xflow.skinPosition", {
    outputs: [  {type: 'float3', name: 'result' }],
    params:  [  {type: 'float3', source: 'pos' },
                {type: 'int4', source: 'boneIdx' },
                {type: 'float4', source: 'boneWeight' },
                {type: 'float4x4', source: 'boneXform', array: true } ],
    evaluate: function(result, pos,boneIdx,boneWeight,boneXform, info) {
        var vec3 = XML3D.math.vec3,
            mat4 = XML3D.math.mat4;
        var r = vec3.create();
        var tmp =  vec3.create();

        for(var i = 0; i< info.iterateCount;++i) {
            var offset = i*3;
            r[0] = r[1] = r[2] = +0;
            for(var j = 0; j < 4; j++) {
                var weight = boneWeight[info.iterFlag[2] ? i*4+j : j];
                if (weight) {
                    var mo = boneIdx[info.iterFlag[1] ? i*4+j : j]*16;

                    mat4.multiplyOffsetVec3(boneXform, mo, pos, offset, tmp);
                    vec3.scale(tmp, tmp, weight);
                    vec3.add(r, r, tmp);
                }
            }
            result[offset] = r[0];
            result[offset+1] = r[1];
            result[offset+2] = r[2];
        }
    }
});

},{}],222:[function(require,module,exports){
var binarySearch = require("../../utils/utils").binarySearch;
var XC = require("../../interface/constants.js");

Xflow.registerOperator("xflow.slerpSeq", {
    outputs: [  {type: 'float4', name: 'result'}],
    params:  [  {type: 'float4', source: 'sequence'},
                {type: 'float', source: 'key'}],
    mapping: [  {name: 'value1', source: 'sequence', sequence: XC.SEQUENCE.PREV_BUFFER, keySource: 'key'},
                {name: 'value2',  source: 'sequence', sequence: XC.SEQUENCE.NEXT_BUFFER, keySource: 'key'},
                {name: 'weight',  source: 'sequence', sequence: XC.SEQUENCE.LINEAR_WEIGHT, keySource: 'key'}],
    evaluate: function(result, value1, value2, weight, info) {
        for(var i = 0; i < info.iterateCount; ++i){
            XML3D.math.quat.slerpOffset(  value1,info.iterFlag[0] ? i*4 : 0,
                                          value2,info.iterFlag[1] ? i*4 : 0,
                                          weight[0],
                                          result, i*4, true);
        }
    }
});


Xflow.registerOperator("xflow.slerpKeys", {
    outputs: [  {type: 'float4', name: 'result'}],
    params:  [  {type: 'float', source: 'keys', array: true},
        {type: 'float4', source: 'values', array: true},
        {type: 'float', source: 'key'}],
    alloc: function(sizes, keys, values, key)
    {
        sizes['result'] = 4;
    },
    evaluate: function(result, keys, values, key) {
        var maxIdx = Math.min(keys.length, Math.floor(values.length / 4));
        var idx = binarySearch(keys, key[0], maxIdx);

        if(idx < 0 || idx == maxIdx - 1){
            idx = Math.max(0,idx);
            result[0] = values[4*idx];
            result[1] = values[4*idx+1];
            result[2] = values[4*idx+2];
            result[3] = values[4*idx+3];
        }
        else{
            var weight = (key[0] - keys[idx]) / (keys[idx+1] - keys[idx]);
            XML3D.math.quat.slerpOffset(  values, idx*4,
                values,(idx+1)*4, weight,
                result, 0, true);
        }
    }
});

},{"../../interface/constants.js":187,"../../utils/utils":238}],223:[function(require,module,exports){

// Code portions from http://www.html5rocks.com/en/tutorials/canvas/imagefilters/
(function() {
    Xflow.Filters = {};

    var tmpCanvas = null;
    var tmpCtx = null;

    Xflow.Filters.createImageData = function(w,h) {
        if (!tmpCanvas)
            tmpCanvas = document.createElement('canvas');
        if (!tmpCtx)
            tmpCtx = tmpCanvas.getContext('2d');
        return tmpCtx.createImageData(w, h);
    };

    Xflow.Filters.createImageDataFloat32 = function(w, h) {
        return {width: w, height: h, data: new Float32Array(w * h * 4)};
    };

    Xflow.Filters.grayscale = function(inpixels, outpixels, args) {
            var s = inpixels.data;
            var d = outpixels.data;
            for (var i=0; i<s.length; i+=4) {
                var r = s[i];
                var g = s[i+1];
                var b = s[i+2];
                var a = s[i+3];
                // CIE luminance for the RGB
                // The human eye is bad at seeing red and blue, so we de-emphasize them.
                var v = 0.2126*r + 0.7152*g + 0.0722*b;
                d[i] = d[i+1] = d[i+2] = v
                d[i+3] = a;
            }
            return inpixels;
    };

    Xflow.Filters.convolute = function(inpixels, outpixels, weights, opaque) {
            var side = Math.round(Math.sqrt(weights.length));
            var halfSide = Math.floor(side/2);
            var src = inpixels.data;
            var sw = inpixels.width;
            var sh = inpixels.height;
            // pad output by the convolution matrix
            var w = sw;
            var h = sh;
            var dst = outpixels.data;
            // go through the destination image pixels
            var alphaFac = opaque ? 1 : 0;
            for (var y=0; y<h; y++) {
                for (var x=0; x<w; x++) {
                    var sy = y;
                    var sx = x;
                    var dstOff = (y*w+x)*4;
                    // calculate the weighed sum of the source image pixels that
                    // fall under the convolution matrix
                    var r=0, g=0, b=0, a=0;
                    for (var cy=0; cy<side; cy++) {
                        for (var cx=0; cx<side; cx++) {
                            var scy = sy + cy - halfSide;
                            var scx = sx + cx - halfSide;
                            if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                                var srcOff = (scy*sw+scx)*4;
                                var wt = weights[cy*side+cx];
                                r += src[srcOff] * wt;
                                g += src[srcOff+1] * wt;
                                b += src[srcOff+2] * wt;
                                a += src[srcOff+3] * wt;
                            }
                        }
                    }
                    dst[dstOff] = r;
                    dst[dstOff+1] = g;
                    dst[dstOff+2] = b;
                    dst[dstOff+3] = a + alphaFac*(255-a);
                }
            }
            return outpixels;
        };
/*
    Xflow.Filters.convoluteFloat32 = function(pixels, weights, opaque) {
        var side = Math.round(Math.sqrt(weights.length));
        var halfSide = Math.floor(side / 2);

        var src = pixels.data;
        var sw = pixels.width;
        var sh = pixels.height;

        var w = sw;
        var h = sh;
        var output = {
            width: w, height: h, data: new Float32Array(w * h * 4)
        };
        var dst = output.data;

        var alphaFac = opaque ? 1 : 0;

        for (var y = 0; y < h; y++) {
            for (var x = 0; x < w; x++) {
                var sy = y;
                var sx = x;
                var dstOff = (y * w + x) * 4;
                var r = 0, g = 0, b = 0, a = 0;
                for (var cy = 0; cy < side; cy++) {
                    for (var cx = 0; cx < side; cx++) {
                        var scy = Math.min(sh - 1, Math.max(0, sy + cy - halfSide));
                        var scx = Math.min(sw - 1, Math.max(0, sx + cx - halfSide));
                        var srcOff = (scy * sw + scx) * 4;
                        var wt = weights[cy * side + cx];
                        r += src[srcOff] * wt;
                        g += src[srcOff + 1] * wt;
                        b += src[srcOff + 2] * wt;
                        a += src[srcOff + 3] * wt;
                    }
                }
                dst[dstOff] = r;
                dst[dstOff + 1] = g;
                dst[dstOff + 2] = b;
                dst[dstOff + 3] = a + alphaFac * (255 - a);
            }
        }
        return output;
    }
*/
}());

function float4(x,y,z,w) {
    var v = new Float32Array(4);
    switch (arguments.length) {
        case 0:
            v[0] = 0;
            v[1] = 0;
            v[2] = 0;
            v[3] = 0;
            break;
        case 1:
            v[0] = x;
            v[1] = x;
            v[2] = x;
            v[3] = x;
            break;
        case 2:
            v[0] = x;
            v[1] = y;
            v[2] = 0;
            v[3] = 0;
            break;
        case 3:
            v[0] = x;
            v[1] = y;
            v[2] = z;
            v[3] = 0;
            break;
        default:
            v[0] = x;
            v[1] = y;
            v[2] = z;
            v[3] = w;
    }
    return v;
}

function hypot(a, b)
{
    return Math.sqrt(a*a + b*b);
}

function hypot4(a, b)
{
    return float4(hypot(a[0], b[0]),
                  hypot(a[1], b[1]),
                  hypot(a[2], b[2]),
                  hypot(a[3], b[3]));
}

function hypot4To(r, a, b)
{
    r[0] = hypot(a[0], b[0]);
    r[1] = hypot(a[1], b[1]);
    r[2] = hypot(a[2], b[2]);
    r[3] = hypot(a[3], b[3]);
}

function getTexel2D(imagedata, x, y) {
    var offset = (y * imagedata.width + x) * 4;
    var data = imagedata.data;
    var color = new Float32Array(4);
    color[0] = data[offset] / 255.0;
    color[1] = data[offset+1] / 255.0;
    color[2] = data[offset+2] / 255.0;
    color[3] = data[offset+3] / 255.0;
    return color;
}

function getTexel2DTo(color, imagedata, x, y) {
    var offset = (y * imagedata.width + x) * 4;
    var data = imagedata.data;
    color[0] = data[offset] / 255.0;
    color[1] = data[offset+1] / 255.0;
    color[2] = data[offset+2] / 255.0;
    color[3] = data[offset+3] / 255.0;
    return color;
}

function setTexel2D(imagedata, x, y, color) {
    var offset = (y * imagedata.width + x) * 4;
    var data = imagedata.data;
    data[offset] = color[0] * 255.0 ;
    data[offset+1] = color[1] * 255.0;
    data[offset+2] = color[2] * 255.0;
    data[offset+3] = color[3] * 255.0;
}

Xflow.registerOperator("xflow.sobelImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'} ],
    evaluate: function(result, image) {
        var width = image.width;
        var height = image.height;

        // Sobel filter, AnySL method
        var gx = float4(0.0);
        var gy = float4(0.0);
        var i00 = float4();
        var i00 = float4();
        var i10 = float4();
        var i20 = float4();
        var i01 = float4();
        var i11 = float4();
        var i21 = float4();
        var i02 = float4();
        var i12 = float4();
        var i22 = float4();
        var color = float4();

        for (var y = 0; y < height; ++y)
        {
            for (var x = 0; x < width; ++x)
            {
                /* Read each texel component and calculate the filtered value using neighbouring texel components */
                if ( x >= 1 && x < (width-1) && y >= 1 && y < height - 1)
                {
                    getTexel2DTo(i00, image, x-1, y-1);
                    getTexel2DTo(i10, image, x, y-1);
                    getTexel2DTo(i20, image, x+1, y-1);
                    getTexel2DTo(i01, image, x-1, y);
                    getTexel2DTo(i11, image, x, y);
                    getTexel2DTo(i21, image, x+1, y);
                    getTexel2DTo(i02, image, x-1, y+1);
                    getTexel2DTo(i12, image, x, y+1);
                    getTexel2DTo(i22, image, x+1, y+1);

                    gx[0] = i00[0] + 2 * i10[0] + i20[0] - i02[0]  - 2 * i12[0] - i22[0];
                    gx[1] = i00[1] + 2 * i10[1] + i20[1] - i02[1]  - 2 * i12[1] - i22[1];
                    gx[2] = i00[2] + 2 * i10[2] + i20[2] - i02[2]  - 2 * i12[2] - i22[2];

                    gy[0] = i00[0] - i20[0]  + 2*i01[0] - 2*i21[0] + i02[0]  -  i22[0];
                    gy[1] = i00[1] - i20[1]  + 2*i01[1] - 2*i21[1] + i02[1]  -  i22[1];
                    gy[2] = i00[2] - i20[2]  + 2*i01[2] - 2*i21[2] + i02[2]  -  i22[2];

                    /* taking root of sums of squares of Gx and Gy */
                    hypot4To(color, gx, gy);
                    color[0]/=2;
                    color[1]/=2;
                    color[2]/=2;
                    color[3]=1.0;
                    setTexel2D(result, x, y, color);
                }
            }
        }



// Sobel filter with separate steps
//
//        var vertical = Xflow.Filters.createImageDataFloat32(width, height);
//        Xflow.Filters.convolute(result, vertical,
//            [ -1, 0, 1,
//              -2, 0, 2,
//              -1, 0, 1 ]);
//        var horizontal = Xflow.Filters.createImageDataFloat32(width, height);
//        Xflow.Filters.convolute(result, horizontal,
//            [ -1, -2, -1,
//               0,  0,  0,
//               1,  2,  1 ]);
//
//        for (var i=0; i<result.data.length; i+=4) {
//            // make the vertical gradient red
//            var v = Math.abs(vertical.data[i]);
//            result.data[i] = v;
//            // make the horizontal gradient green
//            var h = Math.abs(horizontal.data[i]);
//            result.data[i+1] = h;
//            // and mix in some blue for aesthetics
//            result.data[i+2] = (v+h)/4;
//            result.data[i+3] = 255; // opaque alpha
//        }

        /* Copy image
        var destpix = result.data;
        var srcpix = image.data;

        for (var y = 0; y < height; ++y)
        {
            for (var x = 0; x < width; ++x)
            {
                var offset = (y * width + x) * 4;
                destpix[offset] =  srcpix[offset];
                destpix[offset+1] = srcpix[offset+1];
                destpix[offset+2] = srcpix[offset+2];
                destpix[offset+3] = srcpix[offset+3];
            }
        }
        */
        return true;
    }
});

},{}],224:[function(require,module,exports){

Xflow.registerOperator("xflow.sub", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'value1'},
                {type: 'float3', source: 'value2'}],
    evaluate: function(result, value1, value2, info) {
        throw "Not used!";

        for(var i = 0; i< info.iterateCount*3; i++)
            result[i] = value1[i] - value2[i];

        return true;
    },

    evaluate_core: function(result, value1, value2){
        result[0] = value1[0] - value2[0];
        result[1] = value1[1] - value2[1];
        result[2] = value1[2] - value2[2];
    }
});

},{}],225:[function(require,module,exports){
/**
 * One operator execution within the @see{OperatorList}.
 * @param operator
 * @constructor
 */
var OperatorEntry = function (operator) {
    /**
     * Position in OperatorList
     * @type {number}
     */
    this.index = 0;

    /**
     * Operator object
     * @type {{}}
     */
    this.operator = operator;

    /**
     * operatorIndex: Position of the input's operator in the OperatorList if the input comes from
     * previously executed operator otherwise undefined
     * outputIndex: References the outputs of the operator object defined by the operatorIndex
     * mappedName: Original name as defined in operator invocation in DataNode (currently not used)
     * inputIndex: Only set if this is direct input and references into the inputs defined in @see{ProgramData}
     * @type {Array.<{operatorIndex: number?, outputIndex: number?, mappedName: string?, inputIndex: number?}>}
     */
    this.inputInfo = [];
    /**
     * finalOut: {number} Is set, if this output a final output (e.g. a varying in a vertex shader). References the outputs of the ProgramData.
     * transfer: {boolean} Is true if this is a transfer output i.e. this output is used as input by another operator,
     * lost: Data that is lost, i.e. not used in next executor. Reference to ProgramData's outputs
     * @type {Array.<{finalOut: number?, transfer: boolean?, lost: number?}>}
     */
    this.outputInfo = [];
};

/**
 * Is the input the result of a previously executed operator
 * @param mappingIndex Input index of the operator (can be mapped using a mapping declaration)
 * @returns {boolean}
 */
OperatorEntry.prototype.isTransferInput = function (mappingIndex) {
    return this.inputInfo[mappingIndex].operatorIndex !== undefined;
};

OperatorEntry.prototype.getTransferInputOperatorIndex = function (mappingIndex) {
    return this.inputInfo[mappingIndex].operatorIndex;
};
OperatorEntry.prototype.getTransferInputOutputIndex = function (mappingIndex) {
    return this.inputInfo[mappingIndex].outputIndex;
};

/**
 * Generate unique name for a specified transfer input
 * @param mappingIdx
 * @returns {string}
 */
OperatorEntry.prototype.getTransferInputId = function (mappingIdx) {
    var info = this.inputInfo[mappingIdx];
    return info.operatorIndex + "_" + info.outputIndex;
};

/**
 * Generate unique name for transfer output
 * @param outputIndex
 * @returns {string}
 */
OperatorEntry.prototype.getTransferOutputId = function (outputIndex) {
    return this.index + "_" + outputIndex;
};

/**
 * TODO: remove or integrate for debugging purposes
 * @unused
 * @param mappingIdx
 * @returns {string|*}
 */
OperatorEntry.prototype.getInputMappingName = function (mappingIdx) {
    return this.inputInfo[mappingIdx].mappedName;
};
OperatorEntry.prototype.getDirectInputIndex = function (mappingIdx) {
    return this.inputInfo[mappingIdx].inputIndex;
};

OperatorEntry.prototype.getOutputIndex = function (operatorOutputIdx) {
    return this.outputInfo[operatorOutputIdx].finalOut || this.outputInfo[operatorOutputIdx].lost || 0;
};


OperatorEntry.prototype.isFinalOutput = function (outputIndex) {
    return this.outputInfo[outputIndex] && this.outputInfo[outputIndex].finalOut !== undefined;
};
OperatorEntry.prototype.isTransferOutput = function (outputIndex) {
    return this.outputInfo[outputIndex] && this.outputInfo[outputIndex].transfer;
};
OperatorEntry.prototype.isLostOutput = function (outputIndex) {
    return this.outputInfo[outputIndex] && this.outputInfo[outputIndex].lost !== undefined;
};


OperatorEntry.prototype.setTransferInput = function (mappingIndex, operatorIndex, outputIndex) {
    this.inputInfo[mappingIndex] = {operatorIndex: operatorIndex, outputIndex: outputIndex};
};

OperatorEntry.prototype.setDirectInput = function (mappingIndex, inputIndex, mappedName) {
    this.inputInfo[mappingIndex] = {inputIndex: inputIndex, mappedName: mappedName};
};

OperatorEntry.prototype.setFinalOutput = function (operatorOutputIndex, globalOutputIndex) {
    this.outputInfo[operatorOutputIndex] = {finalOut: globalOutputIndex};
};
OperatorEntry.prototype.setTransferOutput = function (operatorOutputIndex) {
    this.outputInfo[operatorOutputIndex] = {transfer: true};
};
OperatorEntry.prototype.setLostOutput = function (operatorOutputIndex, globalOutputIndex) {
    this.outputInfo[operatorOutputIndex] = {lost: globalOutputIndex};
};

/**
 * Generate hash-able key for the entry
 * @returns {string}
 */
OperatorEntry.prototype.getKey = function () {
    var key = this.operator.name + "*O";
    for (var i = 0; i < this.outputInfo.length; ++i) {
        var info = this.outputInfo[i];
        key += "*" + ( info.transfer ? "_" : info.finalOut || (info.lost + "?"));
    }
    key += +"*I";
    for (i = 0; i < this.inputInfo.length; ++i) {
        info = this.inputInfo[i];
        key += "*" + (info.inputIndex ? info.inputInfo : info.operatorIndex + ">" + info.outputIndex);
    }
    return key;
};

module.exports = OperatorEntry;

},{}],226:[function(require,module,exports){
var C = require("../interface/constants.js");
var Base = require("../base.js");


/**
 * List of platform-specific operators, ordered by execution (last entry is last operator
 * executed).
 *
 * @param {C.PLATFORM} platform
 * @constructor
 */
var OperatorList = function (platform) {
    this.platform = platform;
    /**
     * @type {Array.<OperatorEntry>}
     */
    this.entries = [];

    /**
     * Map from position of input parameter to size and iterator type of parameters.
     * Size is only specified for uniform array input, required for programs that
     * have the array size specified.
     * @type {Object.<number,{size: number, iterate: C.ITERATION_TYPE}>}
     */
    this.inputInfo = {};
};

OperatorList.prototype.addEntry = function (entry) {
    entry.index = this.entries.length;
    this.entries.push(entry);
};

/**
 * Hashable key for whole list
 * @returns {string}
 */
OperatorList.prototype.getKey = function () {
    var keys = [];
    for (var i = 0; i < this.entries.length; ++i) {
        keys.push(this.entries[i].getKey());
    }
    var result = this.platform + ">" + keys.join("!") + "|";
    for (var i in this.inputInfo) {
        result += i + ">" + (this.inputInfo[i].iterate || 0) + "x" + (this.inputInfo[i].size || 0);
    }
    return result;
};

OperatorList.prototype.setInputIterateType = function (inputIndex, type) {
    if (!this.inputInfo[inputIndex]) this.inputInfo[inputIndex] = {};
    this.inputInfo[inputIndex].iterate = type;
};
OperatorList.prototype.setInputSize = function (inputIndex, size) {
    if (!this.inputInfo[inputIndex]) this.inputInfo[inputIndex] = {};
    this.inputInfo[inputIndex].size = size;
};


OperatorList.prototype.isInputIterate = function (inputIndex) {
    return this.inputInfo[inputIndex] && this.inputInfo[inputIndex].iterate == C.ITERATION_TYPE.MANY;
};
OperatorList.prototype.isInputUniform = function (inputIndex) {
    return this.inputInfo[inputIndex] && this.inputInfo[inputIndex].iterate == C.ITERATION_TYPE.ONE;
};
OperatorList.prototype.isInputNull = function (inputIndex) {
    return this.inputInfo[inputIndex] && this.inputInfo[inputIndex].iterate == C.ITERATION_TYPE.NULL;
};
OperatorList.prototype.getInputIterateType = function (inputIndex) {
    return this.inputInfo[inputIndex] && this.inputInfo[inputIndex].iterate;
};

OperatorList.prototype.getInputSize = function (inputIndex) {
    return this.inputInfo[inputIndex] && this.inputInfo[inputIndex].size || 0;
};

OperatorList.prototype.getIterateCount = function (programData) {
    var count = -1;
    for (var i = 0; i < programData.inputs.length; ++i) {
        if (this.isInputIterate(i)) {
            var dataEntry = programData.getDataEntry(i);
            if (dataEntry && dataEntry.getIterateCount) {
                var size = dataEntry.getIterateCount();
                count = count < 0 ? size : Math.min(size, count);
            }
        }
    }
    return count < 0 ? 1 : count;
};

var c_sizes = {};

OperatorList.prototype.allocateOutput = function (programData, async) {
    for (var i = 0; i < this.entries.length; ++i) {
        var entry = this.entries[i];
        var operator = entry.operator;
        var operatorData = programData.operatorData[i];
        var iterateCount = this.getIterateCount(programData);
        if (operator.alloc) {
            var args = [c_sizes];
            addInputToArgs(args, entry, programData);
            args.push(iterateCount);
            operator.alloc.apply(operatorData, args);
        }
        for (var j = 0; j < operator.outputs.length; ++j) {
            var d = operator.outputs[j];
            var dataSlot = programData.outputs[entry.getOutputIndex(j)], dataEntry;
            dataEntry = async ? dataSlot.asyncDataEntry : dataSlot.dataEntry;

            if (d.noAlloc)
                continue;

            if (dataEntry.type == C.DATA_TYPE.TEXTURE) {
                // texture entry
                if (d.customAlloc) {
                    var texParams = c_sizes[d.name];
                    var newWidth = texParams.imageFormat.width;
                    var newHeight = texParams.imageFormat.height;
                    var newType = texParams.imageFormat.texelType;
                    var newFormat = texParams.imageFormat.texelFormat;
                    var newSamplerConfig = texParams.samplerConfig;
                    dataEntry._createImage(newWidth, newHeight, newFormat, newType, newSamplerConfig);
                } else if (d.sizeof) {
                    var srcEntry = null;
                    for (var k = 0; k < operator.mapping.length; ++k) {
                        if (operator.mapping[k].source == d.sizeof) {
                            srcEntry = programData.getDataEntry(entry.getDirectInputIndex(k));
                            break;
                        }
                    }
                    if (srcEntry) {
                        var newWidth = Math.max(srcEntry.width, 1);
                        var newHeight = Math.max(srcEntry.height, 1);
                        var newFormat = d.texelFormat || srcEntry.texelFormat;
                        var newType = d.texelType || srcEntry.texelType;
                        var newSamplerConfig = d.samplerConfig || srcEntry.getSamplerConfig();
                        dataEntry._createImage(newWidth, newHeight, newFormat, newType, newSamplerConfig);
                    } else
                        throw new Error("Unknown texture input parameter '" + d.sizeof + "' in operator '" + operator.name + "'");
                } else
                    throw new Error("Cannot create texture. Use customAlloc or sizeof parameter attribute");
            } else {

                var size = (d.customAlloc ? c_sizes[d.name] : iterateCount) * dataEntry.getTupleSize();

                if (!dataEntry._value || dataEntry._value.length != size) {
                    switch (dataEntry.type) {
                        case C.DATA_TYPE.FLOAT:
                        case C.DATA_TYPE.FLOAT2:
                        case C.DATA_TYPE.FLOAT3:
                        case C.DATA_TYPE.FLOAT4:
                        case C.DATA_TYPE.FLOAT4X4:
                            dataEntry._setValue(new Float32Array(size));
                            break;
                        case C.DATA_TYPE.INT:
                        case C.DATA_TYPE.INT4:
                        case C.DATA_TYPE.BOOL:
                            dataEntry._setValue(new Int32Array(size));
                            break;
                        case C.DATA_TYPE.STRING:
                            dataEntry._setValue(new Array(size));
                            break;
                        default:
                            XML3D.debug.logWarning("Could not allocate output buffer of TYPE: " + dataEntry.type);
                    }
                } else {
                    dataEntry._notifyChanged();
                }
            }
        }
    }
};

    // TODO: This function appears in multiple units
    function addInputToArgs(args, entry, programData){
        var mapping = entry.operator.mapping;
        for(var i = 0; i < mapping.length; ++i){
            var dataEntry = programData.getDataEntry(entry.getDirectInputIndex(i));
            args.push(dataEntry ? dataEntry.getValue() : null);
        }
    };

module.exports = OperatorList;

},{"../base.js":186,"../interface/constants.js":187}],227:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");

//----------------------------------------------------------------------------------------------------------------------
// registerOperator && getOperator
//----------------------------------------------------------------------------------------------------------------------

var operators = {};

    /**
     * Registers Xflow operator.
     * The operators are stored in collections using their platform as a key. If no platform is defined, the operator
     * will be registered as a JavaScript-based operator.
     *
     * @param name
     * @param data
     */

var registerOperator = function(name, data){
    var opCollection, platform;

    initOperator(data, name);
    if(!operators[name]) {
        operators[name] = {};
    }

    platform = data['platform'] || C.PLATFORM.JAVASCRIPT;

    opCollection = operators[name];

    if (!name) {
        XML3D.logWarning("Xflow.registerOperator: Operator name undefined.");
        return;
    }

    if (!data) {
        XML3D.logWarning("Xflow.registerOperator: Operator data undefined.");
        return;
    }

    data.name = name;
    if(!opCollection[platform])
        opCollection[platform] = [];

    opCollection[platform].push(data);
};

var initAnonymousOperator = function(name, data){
    initOperator(data);
    data.name = name;
    return data;
};

var isOperatorAsync = function(operator){
    return !!operator.evaluate_async;
};

var getOperators = function(name, platform){
    platform = platform || C.PLATFORM.JAVASCRIPT;

    if (name && !operators[name]) {
        return null;
    }

    if(!operators[name][platform] || operators[name][platform].length == 0) {
        return null;
    }

    return operators[name][platform];
};

function initOperator(operator, name){
    var indexMap = {};
    // Init types of outputs and params
    for(var i= 0; i < operator.outputs.length; ++i){
        if (operator.outputs[i].type === undefined) {
            XML3D.debug.logError("Xflow operator '"+name+"' is missing required attribute 'type' for output parameter "+i);
        }
        operator.outputs[i].type = C.DATA_TYPE_MAP[operator.outputs[i].type];
    }
    for(var i= 0; i < operator.params.length; ++i){
        if (operator.params[i].source === undefined) {
            XML3D.debug.logError("Xflow operator '"+name+"' is missing required attribute 'source' for input parameter "+i);
        }
        if (operator.params[i].type === undefined) {
            XML3D.debug.logError("Xflow operator '"+name+"' is missing required attribute 'type' for input parameter "+i);
        }
        operator.params[i].type = C.DATA_TYPE_MAP[operator.params[i].type];
        indexMap[operator.params[i].source] = i;
    }
    if(!operator.mapping)
        operator.mapping = operator.params;

    // Init interTypes of mapping
    for(var i = 0; i < operator.mapping.length; ++i){
        var mapping = operator.mapping[i];
        var paramIdx = indexMap[mapping.source];
        mapping.paramIdx = paramIdx;
        var type = operator.params[paramIdx].type;
        if(mapping.sequence)
            mapping.keyParamIdx = indexMap[mapping.keySource];
        if(mapping.sequence == C.SEQUENCE.LINEAR_WEIGHT)
            type = C.DATA_TYPE.FLOAT;
        mapping.internalType = type;
        mapping.name = mapping.name || mapping.source;
    }

    //Check/init platform
    operator.platform = operator.platform || C.PLATFORM.JAVASCRIPT;
}

//window.Xflow.registerOperator = registerOperator;

module.exports = {
    registerOperator: registerOperator,
    initAnonymousOperator: initAnonymousOperator,
    isOperatorAsync: isOperatorAsync,
    getOperators: getOperators
};

},{"../base.js":186,"../interface/constants.js":187}],228:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var VSProgram = require("./vs-program.js");
var CLProgram = require("./cl-program.js");

/**
 * Data for a OperatorList, generated by an Executor
 * @constructor
 */
var ProgramData = function(){
    /**
     * @type {Array.<ProgramInputConnection>}
     */
    this.inputs = [];

    /**
     *
     * @type {Array.<DataSlot>}
     */
    this.outputs = [];

    /**
     * iterateCount: How often we iterate with the default execution model
     * iterFlag: Per input: true if the input can be iterated, otherwise false
     * customData: Per instance data that users can persist between operator invocations
     * @type {Array.<{iterateCount: number, iterFlag: Array, customData: {}}>}
     */
    this.operatorData = [];
};

ProgramData.prototype.getChannel = function(index){
    return this.inputs[index].channel;
};

ProgramData.prototype.getDataEntry = function(index){
    var entry = this.inputs[index];
    var channel = entry.channel;
    if(!channel) return null;
    var key = 0;
    if(entry.sequenceKeySourceChannel){
        var keyDataEntry = entry.sequenceKeySourceChannel.getDataEntry();
        key = keyDataEntry && keyDataEntry._value ? keyDataEntry._value[0] : 0;
    }

    return channel.getDataEntry(entry.sequenceAccessType, key);
};

/**
 * @constructor
 */
var ProgramInputConnection = function(){
    /**
     * @type {Channel}
     */
    this.channel = null;

    /**
     * Is this input a uniform array
     * @type {boolean}
     */
    this.arrayAccess = false;

    /**
     * @type {C.SEQUENCE}
     */
    this.sequenceAccessType = C.SEQUENCE.NO_ACCESS;

    /**
     *
     * @type {Channel|null}
     */
    this.sequenceKeySourceChannel = null;
};

/**
 * Hash-able key to identify equal inputs within executor
 * @returns {string}
 */
ProgramInputConnection.prototype.getKey = function(){
    return (this.channel ? this.channel.id : "NULL") + ";" + this.arrayAccess + ";" + this.sequenceAccessType + ";" +
    ( this.sequenceKeySourceChannel ? this.sequenceKeySourceChannel.id : "");
};


var c_program_cache = {};

var createProgram = function(operatorList){
    var firstOperator;

    if(operatorList.entries.length === 0) {
        return null;
    }

    firstOperator = operatorList.entries[0].operator;

    var key = operatorList.getKey();
    if(!c_program_cache[key]){
        // GLSL operators are implemented in a different way, so platform information is fetched from the operatorList
        // as a fallback mode to not break the old implementations
        if(operatorList.platform === C.PLATFORM.GLSL){
            c_program_cache[key] = new VSProgram(operatorList);

        } else if (firstOperator.platform === C.PLATFORM.CL) {
            c_program_cache[key] = new CLProgram(operatorList);

        }else if(firstOperator.platform === C.PLATFORM.JAVASCRIPT && operatorList.entries.length === 1 ) {
            c_program_cache[key] = new SingleProgram(operatorList);

        }else {
            Base.notifyError("Could not create program from operatorList");
        }
    }
    return c_program_cache[key];
};



var SingleProgram = function(operatorList){
    this.list = operatorList;
    this.entry = operatorList.entries[0];
    this.operator = this.entry.operator;
    this._inlineLoop = null;
};

SingleProgram.prototype.run = function(programData, asyncCallback){
    var operatorData = prepareOperatorData(this.list, 0, programData);

    if(asyncCallback)
        applyAsyncOperator(this.entry, programData, operatorData, asyncCallback);
    else if(this.operator.evaluate_core){
        applyCoreOperation(this, programData, operatorData);
    }
    else{
        applyDefaultOperation(this.entry, programData, operatorData);
    }
};

function applyDefaultOperation(entry, programData, operatorData){
    var args = assembleFunctionArgs(entry, programData);
    args.push(operatorData);
    entry.operator.evaluate.apply(operatorData, args);
    handlePostProcessOutput(entry, programData, args, false);
}

function applyAsyncOperator(entry, programData, operatorData, asyncCallback){
    var args = assembleFunctionArgs(entry, programData, true);
    args.push(operatorData);
    args.push(function(){
        handlePostProcessOutput(entry, programData, args, true);
        asyncCallback();
    });
    entry.operator.evaluate_async.apply(operatorData, args);
}

function applyCoreOperation(program, programData, operatorData){
    var args = assembleFunctionArgs(program.entry, programData);
    args.push(operatorData.iterateCount);

    if(!program._inlineLoop){
        program._inlineLoop = createOperatorInlineLoop(program.operator, operatorData);
    }
    program._inlineLoop.apply(operatorData, args);
}

var c_VarPattern = /var\s+(.)+[;\n]/;
var c_InnerVarPattern = /[^=,\s]+\s*(=[^,]+)?(,)?/;
function createOperatorInlineLoop(operator, operatorData){

    var code = "function (";
    var funcData = parseFunction(operator.evaluate_core);
    code += funcData.args.join(",") + ",__xflowMax) {\n";
    code += "    var __xflowI = __xflowMax\n" +
        "    while(__xflowI--){\n";

    var body = funcData.body;
    body = replaceArrayAccess(body, funcData.args, operator, operatorData);
    code += body + "\n  }\n}";

    var inlineFunc = eval("(" + code + ")");
    return inlineFunc;
}

    var c_FunctionPattern = /function\s*([^(]*)\(([^)]*)\)\s*\{([\s\S]*)\}/;

function parseFunction(func){
    var result = {};
    var matches = func.toString().match(c_FunctionPattern);
    if(!matches){
        Base.notifyError("Xflow Internal: Could not parse function: " + func);
        return null;
    }
    result.args = matches[2].split(",");
    for(var i in result.args) result.args[i] = result.args[i].trim();
    result.body = matches[3];
    return result;
}

var c_bracketPattern = /([a-zA-Z_$][\w$]*)(\[)/;

function replaceArrayAccess(code, args, operator, operatorData){
    var result = "";
    var index = 0, bracketIndex = code.indexOf("[", index);
    while(bracketIndex != -1){
        var key = code.substr(index).match(c_bracketPattern)[1];

        var argIdx = args.indexOf(key);
        var addIndex = false, tupleCnt = 0;
        if(argIdx != -1){
            if(argIdx < operator.outputs.length){
                addIndex = true;
                tupleCnt = C.DATA_TYPE_TUPLE_SIZE[[operator.outputs[argIdx].type]];
            }
            else{
                var i = argIdx - operator.outputs.length;
                addIndex = operatorData.iterFlag[i];
                tupleCnt = C.DATA_TYPE_TUPLE_SIZE[operator.mapping[i].internalType];
            }
        }

        result += code.substring(index, bracketIndex) + "[";
        if(addIndex){
            result += tupleCnt + "*__xflowI + ";
        }
        index = bracketIndex + 1;
        bracketIndex = code.indexOf("[", index);
    }
    result +=  code.substring(index);
    return result;
}


function prepareOperatorData(list, idx, programData){
    var data = programData.operatorData[0];
    var entry = list.entries[idx];
    var mapping = entry.operator.mapping;
    data.iterFlag = {};
    for(var i = 0; i < mapping.length; ++i){
        var doIterate = (entry.isTransferInput(i) || list.isInputIterate(entry.getDirectInputIndex(i)));
        data.iterFlag[i] = doIterate;
    }
    data.iterateCount = list.getIterateCount(programData);
    if(!data.customData)
        data.customData = {};
    return data;
}

function assembleFunctionArgs(entry, programData, async){
    var args = [];
    var outputs = entry.operator.outputs;
    for(var i = 0; i < outputs.length; ++i){
        if(outputs[i].noAlloc){
            args.push({assign: null});
        }
        else{
            var dataSlot = programData.outputs[entry.getOutputIndex(i)];
            var dataEntry = async ? dataSlot.asyncDataEntry : dataSlot.dataEntry;
            args.push(dataEntry ? dataEntry.getValue() : null);
        }
    }
    addInputToArgs(args, entry, programData);
    return args;
}
function handlePostProcessOutput(entry, programData, parameters, async){
    var outputs = entry.operator.outputs;
    for(var i = 0; i < outputs.length; ++i){
        var dataSlot = programData.outputs[entry.getOutputIndex(i)];
        if(outputs[i].noAlloc){
            var dataEntry = async ? dataSlot.asyncDataEntry : dataSlot.dataEntry;
            if(dataEntry.type == C.DATA_TYPE.TEXTURE ){
                dataEntry._setImage(parameters[i].assign);
            }
            else{
                dataEntry._setValue(parameters[i].assign);
            }
        }
        if(async){
            dataSlot.swapAsync();
        }
    }
}


function addInputToArgs(args, entry, programData){
    var mapping = entry.operator.mapping;
    for(var i = 0; i < mapping.length; ++i){
        var mapEntry = mapping[i];
        var dataEntry = programData.getDataEntry(entry.getDirectInputIndex(i));
        args.push(dataEntry ? dataEntry.getValue() : null);
    }
}

module.exports = {
    createProgram: createProgram,
    ProgramData: ProgramData,
    ProgramInputConnection: ProgramInputConnection
};

},{"../base.js":186,"../interface/constants.js":187,"./cl-program.js":191,"./vs-program.js":229}],229:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var Utils = require("../utils/utils.js");
var VertexShader = require("../processing/vs-connect.js").VertexShader;

//----------------------------------------------------------------------------------------------------------------------
// OperatorList
//----------------------------------------------------------------------------------------------------------------------

var c_SHADER_CONSTANT_TYPES = {};
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.OBJECT_ID] = 'int';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM] = 'mat4';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM_NORMAL] = 'mat3';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.VIEW_TRANSFORM] = 'mat4';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.VIEW_TRANSFORM_NORMAL] = 'mat3';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.WORLD_TRANSFORM] = 'mat4';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.WORLD_TRANSFORM_NORMAL] = 'mat3';

var VSProgram = function(operatorList){
    this.list = operatorList;
    this._outputInfo = {};
    setOutputIterate(this);
};

VSProgram.prototype.getOutputNames = function(){
    return Object.keys(this._outputInfo);
};

VSProgram.prototype.getOutputType = function(name){
    return this._outputInfo[name].type;
};

VSProgram.prototype.isOutputUniform = function(name){
    return this._outputInfo[name].iteration == C.ITERATION_TYPE.ONE;
};

VSProgram.prototype.isOutputNull = function(name){
    return this._outputInfo[name].iteration == C.ITERATION_TYPE.NULL;
};

VSProgram.prototype.createVertexShader = function(programData, vsConfig){
    var result = new VertexShader(programData);
    constructVS(result, this, vsConfig);
    return result;
};

function setOutputIterate(program){
    var operatorList = program.list, entries = operatorList.entries;

    var baseEntry = entries[entries.length - 1], baseOperator = baseEntry.operator;

    for( var i = 0; i < baseOperator.params.length; ++i){
        var entry = baseOperator.params[i],
            name = entry.source,
            inputIndex = i,
            directInputIndex = baseEntry.getDirectInputIndex(inputIndex);
        program._outputInfo[name] = {type: entry.type};
        if( baseEntry.isTransferInput(inputIndex) ||
            operatorList.isInputIterate(directInputIndex))
        {
            program._outputInfo[name].iteration = C.ITERATION_TYPE.MANY;
        }
        else if(operatorList.isInputUniform(directInputIndex)){
            program._outputInfo[name].iteration = C.ITERATION_TYPE.ONE;
        }
        else{
            program._outputInfo[name].iteration = C.ITERATION_TYPE.NULL;
        }
    }
}

function constructVS(vs, program, vsConfig){
    var operatorList = program.list, entries = operatorList.entries;

    var usedNames = [],
        directInputNames = {},
        transferNames = {};

    var baseEntry = entries[entries.length - 1], acceptedBaseShaderInput = [], baseOperator = baseEntry.operator;

    if(!vsConfig)
        throw new Error("Could not find vsConfig! Attempt to create vertex shader programm without VS operator?");

    Utils.nameset.add(usedNames, vsConfig.getBlockedNames());

    var code = "";
    code += "// OUTPUT\n";
    // First: collect output names
    for(var name in vsConfig._addOutput){
        var entry = vsConfig._addOutput[name];
        code += "varying " + getGLSLType(entry.type) + " " + name + ";\n";
        Utils.nameset.add(usedNames, name);
    }
    var inputIndex = 0;
    for( var name in vsConfig._attributes){
        var configAttr = vsConfig._attributes[name],
            directInputIndex = baseEntry.getDirectInputIndex(inputIndex);
        for(var i = 0; i < configAttr.channeling.length; ++i){
            var channeling = configAttr.channeling[i];
            var outputInfo = {type: configAttr.type, iteration: 0, index: 0, sourceName: name},
                outputName = channeling.outputName;
            if( channeling.code ||
                baseEntry.isTransferInput(inputIndex) ||
                operatorList.isInputIterate(directInputIndex))
            {
                acceptedBaseShaderInput[inputIndex] = true;
                outputInfo.iteration = C.ITERATION_TYPE.MANY;
                var type = baseOperator.outputs[inputIndex].type;
                code += "varying " + getGLSLType(type) + " " + outputName + ";\n";
                Utils.nameset.add(usedNames, outputName);
                transferNames[baseEntry.getTransferOutputId(i)] = outputName;
            }
            else if(operatorList.isInputUniform(directInputIndex)){
                outputInfo.iteration = C.ITERATION_TYPE.ONE;
                outputInfo.index = directInputIndex;
            }
            else{
                outputInfo.iteration = C.ITERATION_TYPE.NULL;
            }
            Utils.nameset.add(vs._outputNames, outputName);
            vs._outputInfo[outputName] = outputInfo;
        }
        inputIndex++;
    }
    code += "\n";
    code += "// INPUT\n";
    // Add additional input
    for(var name in vsConfig._addInput){
        var entry = vsConfig._addInput[name];
        code += (entry.uniform ? "uniform " : "attribute " ) + getGLSLType(entry.type) + " " + name + ";\n";
        Utils.nameset.add(usedNames, name);
    }
    // Second: collect input names
    for(var i = 0; i < entries.length; ++i){
        var entry = entries[i], operator = entry.operator;
        for(var j = 0; j < operator.mapping.length; ++j){
            if( (i < entries.length - 1 || acceptedBaseShaderInput[j]) &&
                    !entry.isTransferInput(j) && !directInputNames[entry.getDirectInputIndex(j)])
            {
                var mapEntry = operator.mapping[j];
                var name = getFreeName(mapEntry.name, usedNames), inputIndex = entry.getDirectInputIndex(j),
                    uniform = !operatorList.isInputIterate(inputIndex);
                vs._inputInfo[name] = { index: inputIndex, uniform: uniform };
                Utils.nameset.add(vs._inputNames, name);
                directInputNames[inputIndex] = name;
                code += (uniform ? "uniform " : "attribute ") + getGLSLType(mapEntry.internalType) + " " + name;
                if(mapEntry.array)
                    code += "[" + operatorList.getInputSize(inputIndex) + "]";
                code += ";\n";
            }
        }
    }

    // Start main
    code += "\n// CODE\n";
    code += "void main(void){\n";

    // Create Code
    for(var i = 0; i < entries.length; ++i){
        var entry = entries[i], operator = entry.operator;
        // Declare transfer output names
        for(var j = 0; j < operator.outputs.length; ++j){
            if(!entry.isFinalOutput(j)){
                var name = getFreeName(operator.outputs[j].name, usedNames);
                transferNames[entry.getTransferOutputId(j)] = name;
                code += "\t" + getGLSLType(operator.outputs[j].type) + " " + name + ";\n";
            }
        }
        // Take Code Fragment
        var codeFragment = convertCodeFragment(operator.evaluate_glsl, entry,
                                transferNames, directInputNames, usedNames);
        code += codeFragment + "\n";
    }

    // Add attribute channeling code
    var mappingIndex = 0, conversionCode = "";
    for( var name in vsConfig._attributes){
        var entry = vsConfig._attributes[name];
        for(var i = 0; i < entry.channeling.length; ++i){
            var channeling = entry.channeling[i], outputName = channeling.outputName;
            if(vs._outputInfo[outputName].iteration == C.ITERATION_TYPE.MANY){
                if(channeling.code)
                    conversionCode += "\t" + channeling.code + "\n";
                else
                    conversionCode += "\t" + outputName + " = #I{" + name + "};\n";
            }
        }
        mappingIndex++;
    }
    for( var i = 0; i < vsConfig._codeFragments.length; ++i){
        conversionCode += "\t" + vsConfig._codeFragments[i] + "\n";
    }
    code += convertCodeFragment(conversionCode, baseEntry, transferNames, directInputNames, usedNames) + "\n";

    code += "}\n";
    vs._glslCode = code;
}

function convertCodeFragment(codeFragment, entry, transferNames, directInputNames, usedNames){
    var index, operator = entry.operator;
    while((index = codeFragment.indexOf("#I{")) != -1){
        var end = codeFragment.indexOf("}",index);
        var mappingIndex = getMappingIndex(operator, codeFragment.substring(index+3,end));
        var replaceName = entry.isTransferInput(mappingIndex) ?
            transferNames[entry.getTransferInputId(mappingIndex)] :
            directInputNames[entry.getDirectInputIndex(mappingIndex)];
        codeFragment = codeFragment.substring(0, index) + replaceName + codeFragment.substring(end+1);
    }
    while((index = codeFragment.indexOf("#O{")) != -1){
        var end = codeFragment.indexOf("}",index);
        var outputIndex = getOutputIndex(operator, codeFragment.substring(index+3,end));
        var replaceName = transferNames[entry.getTransferOutputId(outputIndex)];
        codeFragment = codeFragment.substring(0, index) + replaceName + codeFragment.substring(end+1);
    }
    var localNames = [];
    while((index = codeFragment.indexOf("#L{")) != -1){
        var end = codeFragment.indexOf("}",index);
        var key = codeFragment.substring(index+3,end);
        if(!localNames[key]){
            localNames[key] = getFreeName(key, usedNames);
        }
        var replaceName = localNames[key];
        codeFragment = codeFragment.substring(0, index) + replaceName + codeFragment.substring(end+1);
    }
    while((index = codeFragment.indexOf("#G{")) != -1){
        var end = codeFragment.indexOf("}",index);
        var replaceName = codeFragment.substring(index+3,end);
        codeFragment = codeFragment.substring(0, index) + replaceName + codeFragment.substring(end+1);
    }
    return codeFragment;
}

function getFreeName(name, usedNames){
    var result = name, i = 1;
    while(usedNames.indexOf(result) != -1){
        result = name + "_" + (++i);
    }
    Utils.nameset.add(usedNames, result);
    return result;
}

function getMappingIndex(operator, name){
    for(var i = 0; i < operator.mapping.length; ++i){
        if(operator.mapping[i].name == name)
            return i;
    }
    throw new Error("Invalid input name '" + name  + "' inside of code fragment" );
}

function getOutputIndex(operator, name){
    for(var i = 0; i < operator.outputs.length; ++i){
        if(operator.outputs[i].name == name)
            return i;
    }
}

function getGLSLType(xflowType){
    switch(xflowType){
        case C.DATA_TYPE.BOOL : return 'bool';
        case C.DATA_TYPE.BYTE : return 'uint';
        case C.DATA_TYPE.FLOAT : return 'float';
        case C.DATA_TYPE.FLOAT2 : return 'vec2';
        case C.DATA_TYPE.FLOAT3 : return 'vec3';
        case C.DATA_TYPE.FLOAT4 : return 'vec4';
        case C.DATA_TYPE.FLOAT3X3 : return 'mat3';
        case C.DATA_TYPE.FLOAT4X4 : return 'mat4';
        case C.DATA_TYPE.INT : return 'int';
        case C.DATA_TYPE.INT4 : return 'ivec4';
    }
    throw new Error("Type not supported for GLSL " + C.getTypeName(xflowType) );
}

module.exports = VSProgram;

},{"../base.js":186,"../interface/constants.js":187,"../processing/vs-connect.js":237,"../utils/utils.js":238}],230:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var Channels = require("./channel.js");
var RequestNode = require("./process-node.js").RequestNode;
var ProcessNode = require("./process-node.js").ProcessNode;
var DataSlot = require("./data-slot.js");
var Operator = require("../operator/operator.js");

var ChannelMap = Channels.ChannelMap;

//----------------------------------------------------------------------------------------------------------------------
// ChannelNode
//----------------------------------------------------------------------------------------------------------------------

/**
 * Is created for each substitution (via dataflow) of a DataNode.
 * Stores an optimized representation of the data with ChannelMaps and Channels
 * On construction a ChannelNode is marked outOfSync and synchronized only once data is requested.
 * When the structure of a DataNode is changed in any way (e.g. rename InputNode, add/remove children) a channelNode
 * is marked outOfSync.
 * @param {DataNode} dataNode
 * @param {Substitution} substitution
 * @constructor
 */
var ChannelNode = function(dataNode, substitution){
    this.owner = dataNode;
    this.platform = C.PLATFORM.JAVASCRIPT;
    this.substitution = substitution;   // Substitution is defined by the dataflow instance
    this.loading = false;   // is true if any value in the sub tree is loading and the result can't be calculated
    this.inputSlots = {};   // DataEntries from direct InputNode children of the DataNode
    this.inputChannels = new ChannelMap();    // channel map for input data prio to operator execution
    this.computedChannels = new ChannelMap(); // channel map extend by operator output
    this.outputChannels = new ChannelMap();   // channel map with applied filter => final output

    /**
     * Operator attached to DataNode (guaranteed to be resolved)
     * @type {Object}
     */
    this.operator = null;
    /**
     * Channel node of the dataflowNode (analogue to dataflowNode of DataNode)
     * @type {ChannelNode}
     */
    this.dataflowChannelNode = null;
    /**
     * Process node - only constructed if an operator/dataflow is defined
     * @type {ProcessNode}
     */
    this.processNode = null;
    /**
     * Request Nodes created for each result request on this dataNode.
     * @type {Object.<String,RequestNode>}
     */
    this.requestNodes = {};
    /**
     * Number of uses of channel node. This is only relevant for channel nodes created with substitution.
     * These nodes are cached and the useCount is used to clean this cache.
     * TODO: Use weakmap here to avoid explicit reference count
     * @type {number}
     */
    this.useCount = 1;
    /**
     * True if the channel node is out of sync and internal channel maps need to be reconstructed
     * @type {boolean}
     */
    this.outOfSync = true;
};

/**
 * If node is out of sync, reconstruct all channels
 */
ChannelNode.prototype.synchronize = function(){

    if(this.outOfSync){
        updatePlatform(this);
        synchronizeChildren(this);
        updateInputChannels(this);
        updateComputedChannels(this);
        updateOutputChannels(this);
        this.outOfSync = false;
    }
};

ChannelNode.prototype.clear = function(){
    this.useCount = 0;
    this.inputChannels.clear();
    this.outputChannels.clear();
    delete this.owner;
    var reqs = Object.keys(this.requestNodes);
    for (var i = 0; i < reqs.length; i++) {
        this.requestNodes[reqs[i]].clear();
    }
    this.requestNodes = {};
};

ChannelNode.prototype.increaseRef = function(){
    this.useCount++;
};

ChannelNode.prototype.decreaseRef = function(){
    this.useCount--;
    if(this.useCount == 0){
        this.clear();
        return true;
    }
    return false;
};

ChannelNode.prototype.getOutputNames = function(){
    this.synchronize();
    return this.outputChannels.getNames();
};

ChannelNode.prototype.getChildDataIndex = function(filter){
    this.synchronize();
    return this.outputChannels.getChildDataIndexForFilter(filter);
};

ChannelNode.prototype.setStructureOutOfSync = function()
{
    if(!this.outOfSync){
        this.outOfSync = true;
        this.inputChannels.clear();
        this.computedChannels.clear();
        this.outputChannels.clear();
        this.processNode && this.processNode.clear();
        for(var key in this.requestNodes){
            this.requestNodes[key].setStructureOutOfSync();
        }
        if(this.dataflowChannelNode) {
            this.dataflowChannelNode.setStructureOutOfSync();
        }
    }
};

ChannelNode.prototype.notifyDataChange = function(inputNode, changeType){
    var key = inputNode._name + ";" + inputNode._key;
    if(this.inputSlots[key])
        this.inputSlots[key].setDataEntry(inputNode._data, changeType);
};

ChannelNode.prototype.getResult = function(type, filter) {
    this.synchronize();

    var key = filter ? filter.join(";") : "[null]";
    if(!this.requestNodes[key]){
        this.requestNodes[key] = new RequestNode(this, filter);
    }
    return this.requestNodes[key].getResult(type);
};


ChannelNode.prototype.getOutputChannelInfo = function(name){
    this.synchronize();

    var channel = this.outputChannels.getChannel(name);
    if(!channel)
        return null;
    var result = {
        type: channel.getType(),
        seqLength: channel.getSequenceLength(),
        seqMinKey: channel.getSequenceMinKey(),
        seqMaxKey: channel.getSequenceMaxKey(),
        origin: 0,
        originalName: ""
    };
    var preFilterName = this.owner._filterMapping ? this.owner._filterMapping.getRenameSrcName(name) : name;
    var dataEntry = channel.getDataEntry();
    if(this.dataflowChannelNode){
        var protoInputChannel = this.inputChannels.getChannel(preFilterName);
        if(!protoInputChannel || dataEntry != protoInputChannel.getDataEntry()){
            result.origin = C.ORIGIN.PROTO;
            result.originalName = preFilterName;
            return result;
        }
    }
    if(this.operator){
        var inputChannel = this.inputChannels.getChannel(preFilterName);
        if(!inputChannel || dataEntry != inputChannel.getDataEntry()){
            result.origin = C.ORIGIN.COMPUTE;
            result.originalName = this.owner._computeOutputMapping.getScriptOutputNameInv(preFilterName, this.operator.outputs);
            return result;
        }
    }
    result.origin = C.ORIGIN.CHILD;
    result.originalName = preFilterName;
    return result;
};

/**
 * Select the platform to compute the attached platform
 * @param {ChannelNode} channelNode
 */
function updatePlatform(channelNode) {
    var platform;
    var owner = channelNode.owner;

    // Platforms other than JavaScript are available only for computing operators
    if(!channelNode.owner._computeOperator) {
        return;
    }

    //TODO: Improve platform selection logic.
    // Currently we use forced platform if graph platform is something other than JavaScript
    // and forced platform (owner._platform) is defined
    platform = owner._platform !== null ? owner._platform : C.PLATFORM.JAVASCRIPT;

    channelNode.platform = platform;
}

/**
 *
 * @param {ChannelNode} channelNode
 */
function synchronizeChildren(channelNode){
    var dataNode = channelNode.owner;
    channelNode.loading = dataNode.isSubtreeLoading();

    /**
     * If the channel node represents a substitution, we also need to
     * synchronize the main ChannelNode of the DataNode
     */
    if(channelNode.substitution) {
        dataNode._channelNode.synchronize();
    }

    // Now synchronize all children (either referenced data node, or real children)
    // TODO: Change here if we change behaviour of src attribute
    if(dataNode._sourceNode){
        dataNode._sourceNode._getOrCreateChannelNode(channelNode.substitution).synchronize();
    }
    else{
        for(var i = 0; i < dataNode._children.length; ++i){
            if(dataNode._children[i]._getOrCreateChannelNode){
                dataNode._children[i]._getOrCreateChannelNode(channelNode.substitution).synchronize();
            }
        }
    }
}

/**
 *
 * @param {ChannelNode} channelNode
 */
function updateInputChannels(channelNode){
    var owner = channelNode.owner;
    // TODO: Change here if we change behaviour of src attribute
    if(owner._sourceNode){
        channelNode.inputChannels.merge(owner._sourceNode._getOrCreateChannelNode(channelNode.substitution).outputChannels, 0);
    }
    else{
        var children = owner._children;
        // First the DataNodes than the input nodes in order to override the DataNode channels
        mergeInputChannelDataNodes(channelNode, children);
        mergeInputChannelInputNodes(channelNode, children);
    }
}

/**
 * @param {ChannelNode} channelNode
 * @param {Array.<GraphNode>} children
 */
function mergeInputChannelInputNodes(channelNode, children) {
    for (var i = 0; i < children.length; ++i) {
        if (!children[i]._getOrCreateChannelNode) {  // Child is an InputNode
            var child = children[i];
            var key = child._name + ";" + child._key;
            if (!channelNode.substitution) {  // No dataflow
                var slot = new DataSlot(child._data, child._key);
                channelNode.inputSlots[key] = slot;
                channelNode.inputChannels.addDataEntry(child._name, slot);
            } else {
                if (child._paramName && channelNode.substitution.hasChannel(child._paramName)) {
                    channelNode.inputChannels.addChannel(child._name, channelNode.substitution.getChannel(child._paramName));
                } else {
                    channelNode.inputChannels.addDataEntry(child._name, channelNode.owner._channelNode.inputSlots[key]);
                }
            }
        }
    }
}

/**
 * @param {ChannelNode} channelNode
 * @param {Array.<GraphNode>} children
 */
function mergeInputChannelDataNodes(channelNode, children) {
    for (var i = 0; i < children.length; ++i) {
        if (children[i]._getOrCreateChannelNode) {  // Child is a DataNode
            channelNode.inputChannels.merge(children[i]._getOrCreateChannelNode(channelNode.substitution).outputChannels, i);
        }
    }
}

function updateComputedChannels(channelNode){
    var owner = channelNode.owner;
    channelNode.computedChannels.merge(channelNode.inputChannels);

    var oldDataflowChannelNode = channelNode.dataflowChannelNode;

    if( owner._computeUsesDataflow && owner._dataflowNode){
        channelNode.operator = null;
        updateDataflowChannelNode(channelNode);
        updateComputedChannelsFromDataflow(channelNode);
    }
    else if(!owner._computeUsesDataflow && owner._computeOperator){
        channelNode.dataflowChannelNode = null;
        updateOperator(channelNode);
        updateComputedChannelsFromOperator(channelNode);
    }

    if(oldDataflowChannelNode && oldDataflowChannelNode != channelNode.dataflowChannelNode){
        oldDataflowChannelNode.owner._removeSubstitutionNode(oldDataflowChannelNode);
    }
}

/**
 * Find and set the operator for the given ChannelNode
 * @param channelNode
 */
function updateOperator(channelNode){
    var operatorName, operator;
    var owner = channelNode.owner;

    if(channelNode.loading){
        channelNode.operator = null;
        return;
    }
    if(typeof owner._computeOperator == "string"){
        operatorName = owner._computeOperator;
        operator = null;

        // Getting a correct operator for the selected platform. If operator is not available, we'll try to get
        // the default JavaScript platform operator
        if(operatorName){
            operator = findOperatorByName(channelNode, owner);
            if(operator) { // TODO: Is this good? We calculated the platform before, now it just gets overriden
                channelNode.platform = operator.platform;
            }
        }
        channelNode.operator = operator;
    }else{
        channelNode.operator = owner._computeOperator;
    }
}

var c_typeComparisons = [];

/**
 * Find operator based on name in dataNode, platform and input mapping (signature)
 * @param {ChannelNode} channelNode
 * @param {DataNode} dataNode
 * @returns {Object|null}
 */
function findOperatorByName(channelNode, dataNode){
    var operatorName = dataNode._computeOperator,
        inputMapping = dataNode._computeInputMapping,
        inputChannels = channelNode.inputChannels;

    var operators = Operator.getOperators(operatorName, channelNode.platform) ||
                Operator.getOperators(operatorName, C.PLATFORM.JAVASCRIPT);
    if(!operators){
        Base.notifyError("No operator with name '" + operatorName+"' found", channelNode.owner);
    }

    var i = operators.length;
    while(i--){
        if(checkOperator(operators[i], inputMapping, inputChannels)){
            return operators[i];
        }
    }
    c_typeComparisons.length = 0;
    i = operators.length;
    while(i--){
        checkOperator(operators[i], inputMapping, inputChannels, c_typeComparisons);
    }
    var errorMessage = "No operator '" + operatorName+"' with matching type signature found:\n\n"
                        + c_typeComparisons.join("\n");
    Base.notifyError(errorMessage, channelNode.owner);
    return null;
}

/**
 *
 * @param operator
 * @param inputMapping
 * @param inputChannels
 * @param {Array?} typeComparisonsOutput If array is give, save error information
 * @returns {boolean}
 */
function checkOperator(operator, inputMapping, inputChannels, typeComparisonsOutput){
    var inputs, errors;
    if(typeComparisonsOutput){
        inputs = []; errors = [];
    }
    for(var i = 0; i < operator.params.length; ++i){
        var inputEntry = operator.params[i], sourceName = inputEntry.source;
        var dataName = inputMapping ? inputMapping.getScriptInputName(i, sourceName) : sourceName;
        var errorHeader;
        if(typeComparisonsOutput){
            errorHeader = "For " + (i+1) + ". argument '" + sourceName + "': ";
            inputs.push( C.getTypeName(inputEntry.type) + " " + sourceName + (inputEntry.optional ? " [optional]" : ""));
        }
        if(dataName){
            var channel = inputChannels.getChannel(dataName);
            if(!channel && !inputEntry.optional){
                if(!typeComparisonsOutput)
                    return false;
                else{
                    errors.push(errorHeader + "DataEntry '" + dataName + "' does not exist");
                }
            }
            if(channel && channel.getType() != inputEntry.type){
                if(!typeComparisonsOutput)
                    return false;
                else{
                    errors.push(errorHeader + "DataEntry '" + dataName + "' has wrong type '" + C.getTypeName(channel.getType()) + "'");
                }
            }
        }
    }
    if(typeComparisonsOutput){
        typeComparisonsOutput.push(operator.name + "(" + inputs.join(", ") + ")\n\t * " + errors.join("\n\t * "));
    }
    return true;
}

/**
 *
 * @param channelNode
 */
function updateComputedChannelsFromOperator(channelNode){
    var owner = channelNode.owner;
    if(channelNode.operator){
        var procNode = channelNode.processNode = new ProcessNode(channelNode);
        var index = 0;
        for(var name in procNode.outputDataSlots){
            var destName = name;
            if(owner._computeOutputMapping) destName = owner._computeOutputMapping.getScriptOutputName(index, name);
            if(destName){
                channelNode.computedChannels.addOutputDataSlot(destName, procNode.outputDataSlots[name], procNode);
            }
            index++;
        }
    }
}

/**
 *
 * @param {ChannelNode} channelNode
 */
function updateDataflowChannelNode(channelNode){
    var owner = channelNode.owner;
    var subSubstitution = new Substitution(owner._dataflowNode, channelNode);
    channelNode.dataflowChannelNode = owner._dataflowNode._getOrCreateChannelNode(subSubstitution);
}

/**
 * @param {ChannelNode} channelNode
 */
function updateComputedChannelsFromDataflow(channelNode){
    var owner = channelNode.owner;
    if(channelNode.dataflowChannelNode){
        var dataflowCNode = channelNode.dataflowChannelNode;
        dataflowCNode.synchronize();
        // TODO: We have to make sure to get outputNames in the right order to apply output mapping correctly
        var outputNames = dataflowCNode.outputChannels.getNames();
        for(var i = 0; i < outputNames.length; ++i){
            var srcName = outputNames[i], destName = srcName;
            if(owner._computeOutputMapping)
                destName = owner._computeOutputMapping.getScriptOutputName(i, srcName);
            if(destName)
                channelNode.computedChannels.addChannel(destName, dataflowCNode.outputChannels.getChannel(srcName));
        }
    }
}

function updateOutputChannels(channelNode){
    var dataNode = channelNode.owner;
    if(dataNode._filterMapping) {
        // TODO: This is the only location where applyFilterOnChannelMap is used. Can be simplified (e.g. without callback)
        dataNode._filterMapping.applyFilterOnChannelMap(channelNode.outputChannels, channelNode.computedChannels, dataNode._filterType, setChannelFilterCallback);
    }
    else
        channelNode.outputChannels.merge(channelNode.computedChannels);
}

function setChannelFilterCallback(destMap, destName, srcMap, srcName){
    var channel = srcMap.getChannel(srcName);
    destMap.addChannel(destName, channel, srcMap.getChildDataIndex(srcName));
}

//----------------------------------------------------------------------------------------------------------------------
// Substitution
//----------------------------------------------------------------------------------------------------------------------

/**
 * TODO: Think of replacing this with a channel map
 * @param dataflowNode
 * @param userChannelNode
 * @constructor
 */
var Substitution = function(dataflowNode, userChannelNode){
    this.map = {};

    createSubstitution(this, dataflowNode, userChannelNode);
};

Substitution.prototype.hasChannel = function(name){
    return !!this.map[name];
};
Substitution.prototype.getChannel = function(name){
    return this.map[name];
};

/**
 * Create a hashable key for the substiution
 * @param subDataflowNode
 * @returns {string}
 */
Substitution.prototype.getKey = function(subDataflowNode){
    var key = "";
    var globalParamNames = subDataflowNode._getGlobalParamNames();
    for(var i = 0; i < globalParamNames.length; ++i){
        var channel = this.map[globalParamNames[i]];
        key+= (channel && channel.id || "-") + "!";
    }
    var paramNames = subDataflowNode._getParamNames();
    for(i = 0; i < paramNames.length; ++i){
        channel = this.map[paramNames[i]];
        key+= (channel && channel.id || "-") + ".";
    }
    return key;
};

/**
 *
 * @param {Substitution} substitution
 * @param {DataNode} dataflowNode
 * @param {ChannelNode} userChannelNode
 */
function createSubstitution(substitution, dataflowNode, userChannelNode){
    var userOwner = userChannelNode.owner;

    // Find channels for global parameters
    var globalParamNames = dataflowNode._getGlobalParamNames();
    for(var i = 0; i < globalParamNames.length; ++i){
        substitution.map[globalParamNames[i]] = userChannelNode.inputChannels.getChannel(globalParamNames[i]);
    }

    // Find channels for local parameters. These will override existing global parameters
    var paramNames = dataflowNode._getParamNames();
    for(i = 0; i < paramNames.length; ++i){
        var destName = paramNames[i], srcName = destName;
        if(userOwner._computeInputMapping){
            srcName = userOwner._computeInputMapping.getScriptInputName(i, destName);
        }
        substitution.map[destName] = userChannelNode.inputChannels.getChannel(srcName);
    }
}

module.exports = {
    ChannelNode:  ChannelNode,
    Substitution: Substitution
};

},{"../base.js":186,"../interface/constants.js":187,"../operator/operator.js":227,"./channel.js":231,"./data-slot.js":232,"./process-node.js":235}],231:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var BufferEntry = require("../interface/data.js").BufferEntry;


//----------------------------------------------------------------------------------------------------------------------
// DataSlot
//----------------------------------------------------------------------------------------------------------------------


//----------------------------------------------------------------------------------------------------------------------
// ChannelMap
//----------------------------------------------------------------------------------------------------------------------

/**
 * A map with channels.
 * @constructor
 */
var ChannelMap = function(){
    /**
     * A map of channels.
     * @type {Object.<string, {channel: Channel, childDataIndex: Number}>}
     */
    this.map = {};
};


/**
 * Return a list of all keys.
 * @returns {Array.<string>}
 */
ChannelMap.prototype.getNames = function()
{
    return Object.keys(this.map);
};

/**
 *
 * @param name
 * @returns {Channel}
 */
ChannelMap.prototype.getChannel = function(name)
{
    if(!this.map[name])
        return null;
    return this.map[name].channel;
};

ChannelMap.prototype.getChildDataIndex = function(name)
{
    if(!this.map[name])
        return undefined;
    return this.map[name].childDataIndex;
};
ChannelMap.prototype.getChildDataIndexForFilter = function(filter){
    var result;
    filter = filter || this.getNames();
    for(var i = 0; i < filter.length; ++i){
        var idx = this.getChildDataIndex(filter[i]);
        if(idx == undefined) continue;
        if(result != undefined && result != idx)
            result = -1;
        else
            result = idx;
    }
    return result;
};

/**
 * TODO: Add a mergeWithChildIndex method?
 * @param {ChannelMap} otherChannelMap
 * @param {number?} childDataIndex Index relative to DataNode. Used to mark if channel comes
 * from a specific child DataNode, undefined if ChannelMap should take over child index from otherChannelMap
 */
ChannelMap.prototype.merge = function(otherChannelMap, childDataIndex){
    for(var name in otherChannelMap.map){
        // Either use provided child index, otherwise use child index from ChannelMap to merge
        // For input channel map we define the childDataIndex directly, for applied filters we use the
        // childDataIndex of the provided ChannelMap (it's just a renaming)
        var index = childDataIndex == undefined ? otherChannelMap.getChildDataIndex(name) : childDataIndex;
        this.addChannel(name, otherChannelMap.getChannel(name), index);
    }
};
/**
 * Add a channel with a childDataIndex
 * The childDataIndex defines the origin of the channel.
 * If childDataIndex is undefined the value of the channel can't be determined from one single DataNode
 * @param {String} name
 * @param {Channel} channel
 * @param {Number?} childDataIndex
 */
ChannelMap.prototype.addChannel = function(name, channel, childDataIndex){
    // TODO: Check if this is ever called with a proper childDataIndex value
    if(!channel) return;
    if(childDataIndex == undefined) childDataIndex = -1;
    mergeChannelIntoChannel(this, name, channel, childDataIndex);
};

/**
 * Add DataSlot to the Channel
 * @param name
 * @param dataSlot
 */
ChannelMap.prototype.addDataEntry = function(name, dataSlot)
{
    mergeDataSlotIntoChannel(this, name, dataSlot, -1);
};
/**
 * Add an output DataSlot that originates from an operator
 * @param {String} name
 * @param {DataSlot} dataSlot
 * @param {ProcessNode} creatorNode
 */
ChannelMap.prototype.addOutputDataSlot = function(name, dataSlot, creatorNode){
    var finalChannel = mergeDataSlotIntoChannel(this, name, dataSlot, -1);
    finalChannel.creatorProcessNode = creatorNode;
};

/**
 * Empty the channel map.
 */
ChannelMap.prototype.clear = function(){
    for(var name in this.map){
        var channel = this.map[name];
        if(channel && channel.map == this)
            channel.clear();
    }
    this.map = {};
};

function initChannelSlot(channelMap, name){
    if(!channelMap.map[name]){
        channelMap.map[name] = {
            channel: null,
            childDataIndex: undefined
        }
    }
}

function mergeChannelIntoChannel(channelMap, name, newChannel, childDataIndex){
    initChannelSlot(channelMap, name);
    var currentChannel = channelMap.map[name].channel;
    if(!currentChannel || !currentChannel.willMergeWithChannel(newChannel)) {
        channelMap.map[name].channel = newChannel;
        channelMap.map[name].childDataIndex = childDataIndex;
        return newChannel;
    }
    currentChannel = getMapOwnedChannel(channelMap, currentChannel);
    currentChannel.addChannelEntries(newChannel);
    channelMap.map[name].channel = currentChannel;
    channelMap.map[name].childDataIndex = -1;
    return currentChannel;
}

function mergeDataSlotIntoChannel(channelMap, name, dataSlot, childDataIndex){
    initChannelSlot(channelMap, name);
    var currentChannel = channelMap.map[name].channel;
    if(!currentChannel || !currentChannel.willMergeWithDataSlot(dataSlot)){
        var channel = new Channel(channelMap, dataSlot);
        channelMap.map[name].channel = channel;
        channelMap.map[name].childDataIndex = childDataIndex;
        return channel;
    }
    currentChannel = getMapOwnedChannel(channelMap, currentChannel);
    currentChannel.addDataSlot(dataSlot);
    channelMap.map[name].channel = currentChannel;
    channelMap.map[name].childDataIndex = -1;
    return currentChannel;
}


function getMapOwnedChannel(map, channel){
    if(channel.map != map){
        var newChannel = new Channel(map);
        newChannel.addChannelEntries(channel);
        newChannel.creatorProcessNode = channel.creatorProcessNode;
        return newChannel
    }
    return channel;
}


//----------------------------------------------------------------------------------------------------------------------
// Channel
//----------------------------------------------------------------------------------------------------------------------


/**
 * A channel may inclue several DataSlots/DataEntries
 * A declared Sequence will result in on channel with multiple DataEntries.
 * @constructor
 * @param {ChannelMap} map Owner of the channel
 * @param {DataSlot=} dataSlot Optional DataSlot added to the channel
 */
var Channel = function(map, dataSlot){
    /**
     * DataSlot entries sorted by key value
     * @type {Array.<DataSlot>}
     */
    this.entries = [];
    /**
     * Owner ChannelMap that created with channel.
     * Note: a channel can still exist in several ChannelMaps
     * @type {ChannelMap}
     */
    this.map = map;
    /**
     * Unique ID for this channel. Is used for several optimizations.
     */
    this.id = generateChannelId();
    /**
     * Listeners of this channels (usually ProcessNodes and RequestNodes)
     * @type {Array}
     */
    this.listeners = [];
    /**
     * The ProcessNode that created/extended the content of this channel
     * There can be only one creatorProcessNode per channel because
     * then ouput DataSlots of an operator will always have key "0"
     * If two operators influence the same sequence, the second operator'
     * output will replace the first operator's output, effectively removing the dependency.
     * @type {null}
     */
    this.creatorProcessNode = null;

    if(dataSlot){
        this.addDataSlot(dataSlot);
    }
};

/**
 * Add a dataSlot to the channel, adding dependencies.
 * No notifications send etc.
 * Makes sure that resulting channel has dataSlots ordered by key
 * @param dataSlot
 */
Channel.prototype.addDataSlot = function(dataSlot){
    dataSlot.addChannel(this);
    for(var i = 0; i < this.entries.length; ++i){
        var entry = this.entries[i];
        // We use epsilon here to detect data entries with "equal" key
        if(entry.key >= dataSlot.key - C.EPSILON ){
            if(Math.abs(entry.key - dataSlot.key) <= C.EPSILON){
                entry.removeChannel(this);
                this.entries.splice(i, 1, dataSlot);
            }
            else{
                this.entries.splice(i, 0, dataSlot);
            }
            break;
        }
    }
    this.entries.push(dataSlot);
};

Channel.prototype.getSequenceLength = function(){
    return this.entries.length;
};
Channel.prototype.getSequenceMinKey = function(){
    return this.entries[0].key;
};
Channel.prototype.getSequenceMaxKey = function(){
    return this.entries[this.entries.length - 1].key;
};
/**
 * The DataType of the channel.
 * Since all DataEntries within a channel have the same type, we can simply return the type of the first entry.
 * @returns {DATA_TYPE}
 */
Channel.prototype.getType = function(){
    if(this.entries.length == 0)
        return C.DATA_TYPE.UNKNOWN;
    else
        return this.entries[0].dataEntry._type;
};
/**
 * Merge another channel into this channel.
 */
Channel.prototype.addChannelEntries = function(otherChannel){
    for(var i = 0; i < otherChannel.entries.length; ++i){
        var slot = otherChannel.entries[i];
        this.addDataSlot(slot);
    }
    // FIXME: otherChannel might be without creatorProcessNode but still define a DataSlot with key 0
    // In this case we have to set creatorProcessNode to null
    if(otherChannel.creatorProcessNode)
        this.creatorProcessNode = otherChannel.creatorProcessNode;
    //else
    //    this.creatorProcessNode = null;
};
/**
 * Return a DataEntry from this channel depending on sequenceKey.
 * @param {C.SEQUENCE?} sequenceAccessType
 * @param {number?} sequenceKey
 * @returns {DataEntry}
 */
Channel.prototype.getDataEntry = function(sequenceAccessType, sequenceKey){
    if(this.entries.length == 0)
        return null;
    if(!sequenceAccessType){
        return this.entries[0].dataEntry;
    }


    var i = 0, max = this.entries.length;
    // TODO: Do binary search here?
    while(i < max && this.entries[i].key < sequenceKey) ++i;
    if(sequenceAccessType == C.SEQUENCE.PREV_BUFFER){
        return this.entries[i ? i -1 : 0].dataEntry;
    }
    else if(sequenceAccessType == C.SEQUENCE.NEXT_BUFFER){
        return this.entries[i < max ? i : max - 1].dataEntry;
    }
    else if(sequenceAccessType == C.SEQUENCE.LINEAR_WEIGHT){
        var weight1 = this.entries[i ? i - 1 : 0].key;
        var weight2 = this.entries[i < max ? i : max - 1].key;
        var value = new Float32Array(1);
        value[0] = weight2 == weight1 ? 0 : (sequenceKey - weight1) / (weight2 - weight1);
        // TODO: Check if repeated BufferEntry and Float32Array allocation is a serious bottleneck
        return new BufferEntry(C.DATA_TYPE.FLOAT, value);
    }
    return null;
};

/**
 * Return true of the two channels need to be merged (instead of replacing this channel with otherChannel)
 * @param otherChannel
 * @returns {boolean}
 */
Channel.prototype.willMergeWithChannel = function(otherChannel){
    if(this.entries.length != otherChannel.entries.length) return true;
    if(this.getType() != otherChannel.getType())
        return false;
    for(var i = 0; i < this.entries.length; i++){
        if(Math.abs(this.entries[i].key - otherChannel.entries[i].key) > C.EPSILON)
            return true;
    }
    return false;
};
/**
 * Return true if we need to merge the channel with this dataSlot
 * (instead of creating a new channel fromthis dataSlot)
 * @param dataSlot
 * @returns {boolean}
 */
Channel.prototype.willMergeWithDataSlot = function(dataSlot){
    if(this.entries.length > 1) return true;
    if(this.getType() != dataSlot.dataEntry._type) return false;
    return (Math.abs(this.entries[0].key - dataSlot.key) > C.EPSILON);
};

Channel.prototype.notifyOnChange = function(state){
    for(var i = 0; i < this.listeners.length; i++){
        this.listeners[i].onXflowChannelChange(this, state);
    }
};

Channel.prototype.addListener = function(processNode){
    this.listeners.push(processNode);
};
Channel.prototype.removeListener = function(processNode){
    var idx = this.listeners.indexOf(processNode);
    if(idx != -1) this.listeners.splice(idx, 1);
};

Channel.prototype.clear = function(){
    for(var i = 0; i < this.entries.length; ++i){
        this.entries[i].removeChannel(this);
    }
};

var c_channelKeyIdx = 0;
function generateChannelId(){
    return ++c_channelKeyIdx;
}

module.exports = {
    Channel: Channel,
    ChannelMap: ChannelMap
};

},{"../base.js":186,"../interface/constants.js":187,"../interface/data.js":188}],232:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");

/**
 * A DataSlot wraps a dataEntry and adds a key value for sequences.
 * This structure is used internally within channels and process nodes
 * @constructor
 * @param {DataEntry} dataEntry
 * @param {number=} key
 */
var DataSlot = function(dataEntry, key){
    this.key = key || 0;            // sequence key
    this.dataEntry = dataEntry;     // dataEntry of the slot
    /**
     * alternative dataEntry for asynchronous processing
     * only used for output DataSlots of asynchronous operators
     * @type {DataEntry}
     */
    this.asyncDataEntry = null;
    /**
     * list of all channels that contain this DataSlot
     * @type {Array.<Channel>}
     */
    this.parentChannels = [];

};
DataSlot.prototype.addChannel = function(channel){
    this.parentChannels.push(channel);
};
DataSlot.prototype.removeChannel = function(channel){
    var idx = this.parentChannels.indexOf(channel);
    if(idx != -1) this.parentChannels.splice(idx, 1);
};
DataSlot.prototype.swapAsync = function(){
    var tmp = this.dataEntry;
    this.dataEntry = this.asyncDataEntry;
    this.asyncDataEntry = tmp;
};

DataSlot.prototype.setDataEntry = function(dataEntry, changeType){
    this.dataEntry = dataEntry;
    var state = changeType == C.RESULT_STATE.CHANGED_DATA_VALUE ? C.DATA_ENTRY_STATE.CHANGED_VALUE :
        C.DATA_ENTRY_STATE.CHANGED_SIZE;
    this.notifyOnChange(state);
};

DataSlot.prototype.notifyOnChange = function(state){
    for(var i = 0; i < this.parentChannels.length; ++i){
        this.parentChannels[i].notifyOnChange(state);
    }
};

module.exports = DataSlot;

},{"../base.js":186,"../interface/constants.js":187}],233:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var OperatorList = require("../operator/operator-list.js");
var Utils = require("../utils/utils.js");
var Operator = require("../operator/operator.js");
var OperatorEntry = require("../operator/operator-entry.js");
var Program = require("../operator/program.js");

//----------------------------------------------------------------------------------------------------------------------
// Executor
//----------------------------------------------------------------------------------------------------------------------

/**
 * Tries to combine multiple ProcessNodes into a Program. Currently only used for vertex shaders.
 *
 * @param {RequestNode|ProcessNode} ownerNode
 * @param {C.PLATFORM} platform
 * @constructor
 */
var Executor = function(ownerNode, platform){
    this.platform = platform;

    /**
     * Nodes that are merged by this executor
     * @type {Array.<ProcessNode|RequestNode>}
     */
    this.mergedNodes = [];

    /**
     * Subset of this.mergedNodes that directly provide results of the executor
     * @type {Array.<ProcessNode>}
     */
    this.mergedOutputNodes = [];

    /**
     * ProcessNodes to be executed before this executor can be
     * executed
     * @type {Array.<ProcessNode>}
     */
    this.subNodes = [];

    /**
     * TODO: Unused. Remove?
     * @type {Array}
     */
    this.unprocessedDataNames = [];

    /**
     *  TODO: Maybe we should just store the cl-platform objects in global object so they are more easily available and
     *  to avoid long prototype chains. Or we could pass the graph context to each node of the graph.
     *  However, it would be good to allow each Graph object to have at least own context, cmdQueue and kernelManager.
     *  e.g. passing graph information here requires a long prototype chain
     */
    this.operatorList =  new OperatorList(platform);
    this.programData =  new Program.ProgramData();

    /**
     *
     * @type {Program}
     */
    this.program = null;

    constructExecutor(this, ownerNode);
};

    Executor.prototype.isProcessed = function(){
        var i = this.mergedOutputNodes.length;
        while(i--){
            if(this.mergedOutputNodes[i].status != C.PROCESS_STATE.PROCESSED)
                return false;
        }
        return true;
    };


    Executor.prototype.run = function(asyncCallback){
        runSubNodes(this);
        updateIterateState(this); // TODO check if iterate State has changes in any way and only refetch program in that case

        this.program = Program.createProgram(this.operatorList);

        if(this.program){
            this.operatorList.allocateOutput(this.programData, !!asyncCallback);
            this.program.run(this.programData, asyncCallback);
        }
        if(this.platform != C.PLATFORM.ASYNC){
            var i = this.mergedOutputNodes.length;
            while(i--){
                this.mergedOutputNodes[i].status = C.PROCESS_STATE.PROCESSED;
            }
        }


    };

    Executor.prototype.getVertexShader = function(){
        runSubNodes(this);
        updateIterateState(this);

        this.program = Program.createProgram(this.operatorList);

        return this.program;
    };

/**
 * Construct Executor
 * @param executer
 * @param ownerNode
 */
function constructExecutor(executer, ownerNode){
    var cData = {
        blockedNodes: [],   // Bad Nodes that cannot be merge. Filled during pre scan
        doneNodes: [],      // Nodes that have been signed up for merging. TODO: Redundant with constructionOrder and subNodes? - maybe yes!
        constructionOrder: [], // Store nodes in order of construction of OperatorEntries.
        inputSlots: {},     // Collected input channels of all merged nodes. Used to avoid assigning same input buffer twice
        finalOutput: null,  // finalOutput channes in case we have a RequestNode
        firstOperator: null // Set to first operator that has been merged (will be executed last)
    };
    var requestNode = initRequestNode(cData, executer, ownerNode);

    var noOperators = false; // TODO: Remove this?
    constructPreScan(cData, ownerNode, executer.platform, noOperators);

    setConstructionOrderAndSubNodes(cData, executer, ownerNode);

    constructFromData(executer, cData);
}
/**
 * Only relevant if ownerNodes is a RequestNode
 * Sets finalOutput of construction data and unprocessedDataNames
 * @param cData
 * @param executer
 * @param ownerNode
 * @returns {boolean}
 */
function initRequestNode(cData, executer, ownerNode){
    if(true) { // FIXME: ownerNode instanceof RequestNode){
        cData.finalOutput = {};
        var filter = ownerNode.filter || ownerNode.owner.outputChannels.getNames();
        for(var i = 0; i < filter.length; ++i){
            var name = filter[i];
            var channel = ownerNode.owner.outputChannels.getChannel(name);
            if(channel && channel.creatorProcessNode)
                cData.finalOutput[name] = channel.getDataEntry();
        }
        Utils.nameset.add(executer.unprocessedDataNames, filter);
        return true;
    }
    return false;
}
/**
 * Goes to processing subtree at filled blockedNodes array in construction data.
 * All nodes that cannot be merged or have parents that can't be merged will be blocked
 * @param cData
 * @param node
 * @param platform
 * @param noOperators
 */
function constructPreScan(cData, node, platform, noOperators){
    if(cData.blockedNodes.indexOf(node) != -1)
        return;

    if(node.operator){
        if(noOperators || !canOperatorMerge(cData, node.operator, platform)){
            blockSubtree(cData, node);
            return;
        }
        else{
            if(!cData.firstOperator) cData.firstOperator = node.operator;
            var mapping = node.operator.mapping;
            for(var i = 0; i < mapping.length; ++i){
                if(mapping[i].sequence){
                    blockInput(cData, node, mapping[i].source);
                    blockInput(cData, node, mapping[i].keySource);
                }
                else if(mapping[i].array){
                    // TODO: Rename .array to .randomAccess
                    blockInput(cData, node, mapping[i].source);
                }
            }
        }
    }
    for(var i = 0; i < node.children.length; ++i){
        constructPreScan(cData, node.children[i], platform, noOperators);
    }
}

function canOperatorMerge(cData, operator, platform){
    // TODO: Detect merge support
    return (platform == C.PLATFORM.ASYNC || !Operator.isOperatorAsync(operator)) &&
        (!cData.firstOperator ||
        (platform == C.PLATFORM.GLSL && cData.firstOperator.evaluate_glsl && operator.evaluate_glsl));
}

function blockSubtree(cData, node){
    if(cData.blockedNodes.indexOf(node) != -1)
        return;

    cData.blockedNodes.push(node);
    for(var i = 0; i < node.children.length; ++i){
        blockSubtree(cData, node.children[i]);
    }
}
/**
 * Block all processNodes assigned to an input channel
 * @param cData
 * @param node
 * @param inputName
 */
    function blockInput(cData, node, inputName){
        var channel = node.inputChannels[inputName];
        if(channel && channel.creatorProcessNode){
            blockSubtree(cData, channel.creatorProcessNode);
        }
    }
/**
 * Fill doneNodes and constructionOrder arrays of construction data.
 * It also fills the subNodes array of the executer
 * @param cData construction data
 * @param executer
 * @param node
 */
    function setConstructionOrderAndSubNodes(cData, executer, node){
        if(cData.doneNodes.indexOf(node) != -1)
            return;

        cData.doneNodes.push(node);

        if(cData.blockedNodes.indexOf(node) != -1){
            executer.subNodes.push(node);
        }
        else{
            for(var i = 0; i < node.children.length; ++i){
                setConstructionOrderAndSubNodes(cData, executer, node.children[i]);
            }

            if(node.operator){ // RequestNodes don't have an operator. Consider this case.
                cData.constructionOrder.push(node);
            }
        }
    }
/**
 * Last step of construction: create OperatorList from constructionOrder array
 * Also fill mergedNodes and programData
 * @param executer
 * @param cData
 */
    function constructFromData(executer, cData){

        for(var i = 0; i < cData.constructionOrder.length; ++i){
            var node = cData.constructionOrder[i];

            var entry = new OperatorEntry(node.operator);

            constructInputConnection(executer, entry, cData, node);

            var isOutputNode = constructOutputConnection(executer, entry, cData, node);

            executer.programData.operatorData.push({});
            executer.operatorList.addEntry(entry);
            executer.mergedNodes.push(node);
            if(isOutputNode || (i == cData.constructionOrder.length-1))
                executer.mergedOutputNodes.push(node)

        }

        constructLostOutput(executer, cData);
    }
/**
 * Construct input info for OperatorEntry.
 * Will implicitly create ProgramInputConnections for ProgramData
 * @param {Executor} executer
 * @param {OperatorEntry} entry
 * @param {{}} cData
 * @param {ProcessNode} node
 */
    function constructInputConnection(executer, entry, cData, node){
        var mapping = node.operator.mapping;
        for(var j = 0; j < mapping.length; ++j){
            var channel = node.inputChannels[mapping[j].source];
            var operatorIndex;
            if(channel && channel.creatorProcessNode && (operatorIndex =
                executer.mergedNodes.indexOf(channel.creatorProcessNode) ) != -1 )
            {
                // it's transfer input
                var outputIndex = getOperatorOutputIndex(channel.creatorProcessNode, channel);
                entry.setTransferInput(j, operatorIndex, outputIndex);
                var prevOperator = executer.operatorList.entries[operatorIndex];
                if(!prevOperator.isFinalOutput(outputIndex)){
                    prevOperator.setTransferOutput(outputIndex);
                }
                continue;
            }
            // Handle direct input

            var mappedInputName = mapping[j].source;
            if(node.owner.owner._computeInputMapping)
                mappedInputName = node.owner.owner._computeInputMapping.getScriptInputName(mapping[j].paramIdx, mapping[j].source);

            var connection = new Program.ProgramInputConnection();
            connection.channel = channel;
            connection.arrayAccess = mapping[j].array || false; // TODO: rename to randomAccess
            connection.sequenceAccessType = mapping[j].sequence || 0;
            if(connection.sequenceAccessType)
                connection.sequenceKeySourceChannel = node.inputChannels[mapping[j].keySource];

            var connectionKey = connection.getKey();
            var inputSlotIdx = cData.inputSlots[connectionKey];
            if(channel && inputSlotIdx != undefined){
                // Direct input already exists
                entry.setDirectInput(j, inputSlotIdx, mappedInputName);
            }
            else{
                // new direct input
                inputSlotIdx = executer.programData.inputs.length;
                cData.inputSlots[connectionKey] = inputSlotIdx;
                executer.programData.inputs.push(connection);
                entry.setDirectInput(j, inputSlotIdx, mappedInputName);
            }
        }
    }

/**
 * Construct output info of OperatorEntry
 * @param {Executor} executer
 * @param {OperatorEntry} entry
 * @param {{}} cData
 * @param {ProcessNode} node
 */
    function constructOutputConnection(executer, entry, cData, node){
        var outputs = node.operator.outputs;
        var isOutputNode = true;
        for(var i = 0; i < outputs.length; ++i){
            var slot = node.outputDataSlots[outputs[i].name];
            var finalOutputName = getFinalOutputName(slot, cData);
            if(finalOutputName){
                var index =  executer.programData.outputs.length;
                executer.programData.outputs.push(slot);
                entry.setFinalOutput(i, index);
                if(finalOutputName !== true){
                    Utils.nameset.remove(executer.unprocessedDataNames, finalOutputName);
                }
            }
            else{
                isOutputNode = false;
            }
        }
        return isOutputNode; // TODO: Check if computation of isOutputNode is really correct?
    }


    function getOperatorOutputIndex(processNode, channel){
        var outputs = processNode.operator.outputs;
        for(var i = 0; i < outputs.length; ++i){
            if(channel.getDataEntry() == processNode.outputDataSlots[outputs[i].name].dataEntry){
                return i;
            }
        }
        return null;
    }

    function getFinalOutputName(dataSlot, cData){
        if(!cData.finalOutput) // If root of Executor is a ProcessNode we don't have finalOutput defined and all outputs are final.
            return true;
        for(var name in cData.finalOutput){
            if(cData.finalOutput[name] == dataSlot.dataEntry){
                return name;
            }
        }
        return false;
    }

    function constructLostOutput(executer, cData){
        for(var i = 0; i < cData.constructionOrder.length; ++i){
            var node = cData.constructionOrder[i];
            var entry = executer.operatorList.entries[i];

            var outputs = node.operator.outputs;
            for(var j = 0; j < outputs.length; ++j){
                if(!entry.isFinalOutput(j) && ! entry.isTransferOutput(j)){
                    var index = executer.programData.outputs.length;
                    executer.programData.outputs.push(node.outputDataSlots[outputs[j].name]);
                    entry.setLostOutput(j, index);
                }
            }
        }
    }


    function updateIterateState(executer){
        var inputs = executer.programData.inputs;
        for(var i = 0; i < executer.programData.inputs.length; ++i){
            var entry = executer.programData.getDataEntry(i);
            var iterateCount = entry ? entry.getIterateCount ? entry.getIterateCount() : 1 : 0;
            if(!iterateCount)
                executer.operatorList.setInputIterateType(i, C.ITERATION_TYPE.NULL);
            else if(!inputs[i].arrayAccess && iterateCount > 1)
                executer.operatorList.setInputIterateType(i, C.ITERATION_TYPE.MANY);
            else
                executer.operatorList.setInputIterateType(i, C.ITERATION_TYPE.ONE);

            if(inputs[i].arrayAccess && platformRequiresArraySize(executer. platform)){
                executer.operatorList.setInputSize(i, iterateCount);
            }
        }
    }
/**
 * Determine if the platform needs to declare uniform array sizes in the source code.
 * @param platform
 * @returns {boolean}
 */
    function platformRequiresArraySize(platform){
        return platform == C.PLATFORM.GLSL;
    }


    function runSubNodes(executer){
        for(var i = 0; i < executer.subNodes.length; ++i){
            executer.subNodes[i].process();
        }
    }

module.exports = Executor;

},{"../base.js":186,"../interface/constants.js":187,"../operator/operator-entry.js":225,"../operator/operator-list.js":226,"../operator/operator.js":227,"../operator/program.js":228,"../utils/utils.js":238}],234:[function(require,module,exports){
var Base = require("../base.js");
var C = require("./../interface/constants.js");


var orderMappingParser = /^([^:,{}]+)(,[^:{},]+)*$/;
var nameMappingParser = /^\{(([^:,{}]+:[^:{},]+)(,[^:{},]+:[^:},]+)*)}$/;

/**
 * A mapping used for a filter or a compute properties of a DataNode
 * @abstract
 */
var Mapping = function(){
    /**
     * @type {Array<DataNode>}
     */
    this._owners = [];
};

/**
 * Parse a Mapping (both C.OrderMapping or C.ComputeMapping) from a syntax string.
 * @param {string} string The syntax string.
 * @param {C.DataNode} dataNode DataNode of the Mapping
 * @returns {?C.Mapping}
 */
Mapping.parse = function(string, dataNode){
    string = string.trim();
    var results = string.trim().match(orderMappingParser);
    if(results)
        return OrderMapping.parse(string, dataNode);
    results = string.trim().match(nameMappingParser);
    if(results)
        return NameMapping.parse(results[1], dataNode);
    Base.notifyError("Cannot parse name mapping '" + string + "'", dataNode);
    return null;
};

/**
 *
 * @param {DataNode} owner
 * @private
 */
Mapping.prototype._addOwner = function(owner){
    var idx = this._owners.indexOf(owner);
    if(idx == -1)
        this._owners.push(owner);
};

/**
 *
 * @param {DataNode} owner
 * @private
 */
Mapping.prototype._removeOwner = function(owner){
    var idx = this._owners.indexOf(owner);
    if(idx != -1)
        this._owners.splice(idx, -1);
};


//----------------------------------------------------------------------------------------------------------------------
// OrderMapping
//----------------------------------------------------------------------------------------------------------------------

/**
 * An OrderMapping used for a filter or compute properties of a DataNode
 * It describes a mapping of names referring to the order of arguments / output values.
 * OrderMapping syntax examples in compute:
 * position = C.morph(position, posAdd, weight)
 * @constructor
 * @extends {Mapping}
 */
var OrderMapping = function(){
    Mapping.call(this);
    this._names = [];
};
Base.createClass(OrderMapping, Mapping);

OrderMapping.parse = function(string, dataNode){
    var mapping = new OrderMapping(dataNode);
    var token = string.split(",");
    for(var i = 0; i < token.length; i++){
        mapping._names.push(token[i].trim());
    }
    return mapping;
};


Object.defineProperty(OrderMapping.prototype, "length", {
    set: function(){ throw new Error("length is read-only");
    },
    get: function(){ return this._names.length; }
});

OrderMapping.prototype.getName = function(idx){
    return this._names[idx];
};

OrderMapping.prototype.clear = function(){
    this._names = [];
    mappingNotifyOwner(this);
};

OrderMapping.prototype.setName = function(index, name){
    this._names[index] = name;
    mappingNotifyOwner(this);
};


//noinspection JSUnusedGlobalSymbols
OrderMapping.prototype.removeName = function(index){
    this._names.splice(index);
    mappingNotifyOwner(this);
};

OrderMapping.prototype.isEmpty = function(){
    return this._names.length == 0;
};

/**
 *
 * @param {ChannelMap} destMap
 * @param {ChannelMap} sourceMap
 * @param {exports.C.DATA_FILTER_TYPE} filterType
 * @param {function(ChannelMap, string, ChannelMap, string)} callback
 */
OrderMapping.prototype.applyFilterOnChannelMap = function(destMap, sourceMap, filterType, callback){
    var i;
    if(filterType == C.DATA_FILTER_TYPE.KEEP){
        for(i = 0; i < this._names.length; ++i){
            var name = this._names[i];
            if(sourceMap.map[name]) {
                callback(destMap, name, sourceMap, name);
            }
        }
    }
    else{
        for(i in sourceMap.map){
            var idx = this._names.indexOf(i);
            if(filterType == C.DATA_FILTER_TYPE.RENAME ||
                (filterType == C.DATA_FILTER_TYPE.REMOVE && idx == -1))
                callback(destMap, i, sourceMap, i);
        }
    }
};

/**
 * Return the name of the input value assigned to operator argument.
 * Returns null, if no mapping is defined.
 * @param {number} index Position of the operator argument
 * @returns {string|null}
 */
OrderMapping.prototype.getScriptInputName = function(index /*, destName */){
    if(this._names[index])
        return this._names[index];
    else
        return null;
};

/**
 * Returns the name of the output parameter as it should be used for the
 * following dataflow. Returns null, if no mapping is defined.
 * @param index
 * @returns {string|null}
 */
OrderMapping.prototype.getScriptOutputName = function(index /*, srcName */){
    if(this._names[index])
        return this._names[index];
    else
        return null;
};

/**
 * Returns the inverse name of the output parameter as it should be used for the
 * following dataflow. Returns null, if no mapping is defined.
 * @param {string} destName
 * @param {array<object>} operatorOutputs
 * @returns {string|null}
 */
OrderMapping.prototype.getScriptOutputNameInv = function(destName, operatorOutputs){
    var index = this._names.indexOf(destName);
    if(index == -1)
        return null;
    return operatorOutputs[index].name;
};

/**
 * Identity function. Used to implement interface. Usually you don't rename with order
 * mapping.
 * @param name
 * @returns {string}
 */
OrderMapping.prototype.getRenameSrcName = function(name){
    return name;
};

//----------------------------------------------------------------------------------------------------------------------
// NameMapping
//----------------------------------------------------------------------------------------------------------------------

/**
 * An NameMapping used for a filter or compute properties of a DataNode
 * It describes a mapping of names referring to the original names of the arguments / output values.
 * NameMapping syntax examples in compute:
 * {position: result} = C.morph({value: position, valueAdd: posAdd, weight: weight})
 * @constructor
 * @extends {Mapping}
 */
var NameMapping = function(){
    Mapping.call(this);
    this._destNames = [];
    this._srcNames = [];

};
Base.createClass(NameMapping, Mapping);

NameMapping.parse = function(string, dataNode)  {
    var mapping = new NameMapping(dataNode);
    var token = string.split(",");
    for(var i = 0; i < token.length; i++){
        var pair = token[i].split(":");
        var dest = pair[0].trim(); var src = pair[1].trim();
        mapping.setNamePair(dest, src);
    }
    return mapping;
};

Object.defineProperty(NameMapping.prototype, "length", {
    set: function(){ throw new Error("length is read-only");
    },
    get: function(){ return this._srcNames.length; }
});

NameMapping.prototype.getDestName = function(idx){
    return this._destNames[idx];
};
NameMapping.prototype.getSrcName = function(idx){
    return this._srcNames[idx];
};

NameMapping.prototype.getSrcNameFromDestName = function(destName){
    var idx = this._destNames.indexOf(destName);
    return idx == -1 ? null : this._srcNames[idx];
};
NameMapping.prototype.getDestNameFromSrcName = function(srcName){
    var idx = this._srcNames.indexOf(srcName);
    return idx == -1 ? null : this._destNames[idx];
};

NameMapping.prototype.clear = function(){
    this._srcNames = [];
    this._destNames = [];
    mappingNotifyOwner(this);
};

NameMapping.prototype.setNamePair = function(destName, srcName){
    var idx = this._destNames.indexOf(destName);
    if(idx != -1){
        this._destNames.splice(idx,1);
        this._srcNames.splice(idx,1);
    }
    this._destNames.push(destName);
    this._srcNames.push(srcName);
    mappingNotifyOwner(this);
};

//noinspection JSUnusedGlobalSymbols
NameMapping.prototype.removeNamePair = function(destName){
    var idx = this._destNames.indexOf(destName);
    if(idx != -1){
        this._destNames.splice(idx,1);
        this._srcNames.splice(idx,1);
    }
    mappingNotifyOwner(this);
};

NameMapping.prototype.isEmpty = function(){
    return this._destNames.length == 0;
};

/**
 * @see OrderMapping.applyFilterOnChannelMap
 * @param {ChannelMap} destMap
 * @param {ChannelMap} sourceMap
 * @param {C.DATA_FILTER_TYPE} filterType
 * @param {function} callback
 */
NameMapping.prototype.applyFilterOnChannelMap = function(destMap, sourceMap, filterType, callback) {
    var i;
    if(filterType == C.DATA_FILTER_TYPE.REMOVE){
        for(i in sourceMap.map)
            if(this._srcNames.indexOf(i) == -1)
                callback(destMap, i, sourceMap, i);
    }
    else{
        if(filterType == C.DATA_FILTER_TYPE.RENAME){
            for(i in sourceMap.map)
                if(this._srcNames.indexOf(i) == -1)
                    callback(destMap, i, sourceMap, i);
        }
        for(i in this._destNames){
            callback(destMap, this._destNames[i], sourceMap, this._srcNames[i]);
        }
    }
};

/**
 * Renames: Look-up the destination name and return the source name
 * @param {string} name
 * @returns {string}
 */
NameMapping.prototype.getRenameSrcName = function(name){
    return this.getSrcNameFromDestName(name) || name;
};

/**
 * Return the name of the input value assigned to operator argument
 * @param {number} index Position of the operator argument
 * @param {string} destinationName Name of the operator argument
 * @returns {string|null}
 */
NameMapping.prototype.getScriptInputName= function(index, destinationName){
    return this.getSrcNameFromDestName(destinationName);
};

/**
 * @see OrderMapping.getScriptOutputName
 */
NameMapping.prototype.getScriptOutputName = function(index, srcName){
    return this.getDestNameFromSrcName(srcName);
};

/**
 * @see OrderMapping.getScriptOutputNameInv
 */
NameMapping.prototype.getScriptOutputNameInv = function(destName /*, operatorOutputs */){
    var index = this._destNames.indexOf(destName);
    if(index == -1)
        return null;
    return this._srcNames[index];
};

/**
 * Notify all DataNodes that use the mapping passed to the function
 * @param {Mapping} mapping
 */
function mappingNotifyOwner(mapping){
    for(var i = 0; i < mapping._owners.length; ++i) {
        mapping._owners[i].notify(C.RESULT_STATE.CHANGED_STRUCTURE);
    }
    Base._flushResultCallbacks();
}
module.exports = {
    NameMapping: NameMapping,
    OrderMapping: OrderMapping,
    Mapping: Mapping
};

},{"../base.js":186,"./../interface/constants.js":187}],235:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var utils = require("../utils/utils.js");
var Executor = require("./executor.js");
var Result = require("./result.js");
var Operator = require("../operator/operator.js");
var Data = require("../interface/data.js");
var DataSlot = require("../processing/data-slot.js");

var BufferEntry = Data.BufferEntry;
var TextureEntry = Data.TextureEntry;
var ImageDataTextureEntry = Data.ImageDataTextureEntry;

//----------------------------------------------------------------------------------------------------------------------
// C.ProcessNode
//----------------------------------------------------------------------------------------------------------------------

var ASYNC_PROCESS_STATE = {
    IDLE : 0,
    RUNNING : 1,
    RESCHEDULED : 2,
    INIT: 3
};


/**
 * Optimized representation for the processing graph. Only created for ChannelNodes with operators.
 * Is connected directly to other ProcessNodes, ignoring channels that are not relevant for processing
 * @param {ChannelNode} channelNode
 * @constructor
 * @extends {GraphNode}
 */
var ProcessNode = function(channelNode){
    this.owner = channelNode;
    this.operator = channelNode.operator;

    /**
     * Input channels for the operator
     * @type {Object.<string, Channel>}
     */
    this.inputChannels = {};

    /**
     * Outputs of operator
     * @type {Object.<string, DataSlot>}
     */
    this.outputDataSlots = {};

    /**
     * @type {exports.C.PROCESS_STATE}
     */
    this.status = C.PROCESS_STATE.MODIFIED;

    /**
     * @type {ASYNC_PROCESS_STATE}
     */
    this.asyncProcessState = ASYNC_PROCESS_STATE.INIT;

    /**
     * Direct Children without transitive children of children
     * TODO: Use Set()?
     * @type {Array.<ProcessNode>}
     */
    this.children = [];

    /**
     * Children with transitive dependencies
     * TODO: Use Set()?
     * @type {Array.<ProcessNode>}
     */
    this.descendants = [];

    /**
     * Callback, the executor needs to call when the computation is ready
     * @type {Function}
     * @private
     */
    this._bindedAsyncCallback = null;

    /**
     * Index of array matches platform id (C.PLATFORM)
     * @type {Array.<Executor>}
     */
    this.executers = [];

    constructProcessNode(this, channelNode);

    if(Operator.isOperatorAsync(this.operator)){
        this._bindedAsyncCallback = this.receiveAsyncProcessing.bind(this);
    }
};

ProcessNode.prototype.onXflowChannelChange = function(channel, state){
    if (Operator.isOperatorAsync(this.operator)) {
        if (this.status == C.PROCESS_STATE.LOADING || this.asyncProcessState != ASYNC_PROCESS_STATE.INIT) {
            this.status = C.PROCESS_STATE.MODIFIED;
            this.updateState();
        }
    }
    else {

        if (state == C.DATA_ENTRY_STATE.CHANGED_VALUE && this.status > C.PROCESS_STATE.UNPROCESSED) {
            this.status = C.PROCESS_STATE.UNPROCESSED;
        } else {
            this.status = C.PROCESS_STATE.MODIFIED;
        }
        this.notifyOutputChanged(state);
    }
};

ProcessNode.prototype.startAsyncProcessing = function(){
    if(this.asyncProcessState == ASYNC_PROCESS_STATE.IDLE || this.asyncProcessState == ASYNC_PROCESS_STATE.INIT){
        this.asyncProcessState = ASYNC_PROCESS_STATE.RUNNING;
        var executer = getOrCreateExecuter(this, C.PLATFORM.ASYNC);
        executer.run(this._bindedAsyncCallback);
    }
    else{
        this.asyncProcessState = ASYNC_PROCESS_STATE.RESCHEDULED;
    }
};
ProcessNode.prototype.receiveAsyncProcessing = function(){
    this.status = C.PROCESS_STATE.PROCESSED;
    this.notifyOutputChanged(C.DATA_ENTRY_STATE.CHANGED_SIZE_TYPE);
    if(this.asyncProcessState == ASYNC_PROCESS_STATE.RESCHEDULED){
        this.asyncProcessState = ASYNC_PROCESS_STATE.IDLE;
        this.status = C.PROCESS_STATE.MODIFIED;
        this.updateState();
    }
    else{
        this.asyncProcessState = ASYNC_PROCESS_STATE.IDLE;
    }
    Base._flushResultCallbacks();
};



ProcessNode.prototype.notifyOutputChanged = function(state){
    for(var name in this.outputDataSlots){
        this.outputDataSlots[name].notifyOnChange(state);
    }
};


ProcessNode.prototype.clear = function(){
    for(var name in this.inputChannels){
        this.inputChannels[name] && this.inputChannels[name].removeListener(this);
    }
    for (var i = 0; i < this.children.length; i++) {
        this.children[i].clear();
    }
};

ProcessNode.prototype.updateState = function(){
    if(this.status == C.PROCESS_STATE.MODIFIED){
        this.status = C.PROCESS_STATE.UNPROCESSED;

        XML3D.debug.assert(!this.owner.loading, "This should never happen");

        if(this.owner.loading)
            this.status = C.PROCESS_STATE.LOADING;
        else{
            for(var i = 0; i < this.children.length; ++i){
                this.status = Math.min(this.status, this.children[i].updateState());
            }
            if(this.status > C.PROCESS_STATE.LOADING && isInputLoading(this.operator, this.inputChannels))
                this.status = C.PROCESS_STATE.LOADING;

            if(this.status > C.PROCESS_STATE.INVALID &&
                !checkInput(this, this.operator, this.owner.owner._computeInputMapping, this.inputChannels))
                this.status = C.PROCESS_STATE.INVALID;

            if(this.status == C.PROCESS_STATE.UNPROCESSED && Operator.isOperatorAsync(this.operator)){
                this.status = this.asyncProcessState == ASYNC_PROCESS_STATE.INIT ? C.PROCESS_STATE.LOADING
                    : C.PROCESS_STATE.PROCESSED;
                this.startAsyncProcessing();
            }

        }
    }
    return this.status;
};

ProcessNode.prototype.process = function(){

    if(this.status == C.PROCESS_STATE.UNPROCESSED){
        var executer = getOrCreateExecuter(this, this.owner.platform);
        executer.run();
        this.status = C.PROCESS_STATE.PROCESSED;
    }
};

/**
 *
 * @param {ProcessNode} processNode
 * @param {ChannelNode} channelNode
 */
function constructProcessNode(processNode, channelNode){
    var dataNode = channelNode.owner;
    synchronizeInputChannels(processNode, channelNode, dataNode);
    synchronizeChildrenAndDescendants(processNode.children, processNode.descendants, processNode.inputChannels);
    synchronizeOutput(processNode.operator, processNode.outputDataSlots);
}

/**
 *
 * @param processNode
 * @param channelNode
 * @param dataNode
 */
function synchronizeInputChannels(processNode, channelNode, dataNode){
    var operator = processNode.operator, inputMapping = dataNode._computeInputMapping;
    for(var i = 0; i < operator.params.length; ++i){
        var sourceName = operator.params[i].source;
        var dataName = inputMapping ? inputMapping.getScriptInputName(i, sourceName) : sourceName;
        if(dataName){
            var channel = channelNode.inputChannels.getChannel(dataName);
            if(channel) channel.addListener(processNode);
            processNode.inputChannels[sourceName] = channel;
        }
    }
}

function isInputLoading(operator, inputChannels){
    for(var i in operator.params){
        var entry = operator.params[i];
        var channel = inputChannels[entry.source];
        if(!channel) continue;
        var dataEntry = channel.getDataEntry();
        if(!dataEntry) continue;
        if(dataEntry.isLoading && dataEntry.isLoading()) return true;
    }
    return false;
}

function checkInput(processNode, operator, inputMapping, inputChannels){
    var dataNode = processNode.owner.owner;
    for(var i in operator.params){
        var entry = operator.params[i];
        var dataName = inputMapping ? inputMapping.getScriptInputName(i, entry.source) : entry.source;
        if(!entry.optional && !dataName){
            Base.notifyError("Xflow: operator " + operator.name + ": Missing input argument for "
                + entry.source, dataNode);
            return false;
        }
        if(dataName){
            var channel = inputChannels[entry.source];
            if(!channel){
                if(!inputMapping) continue;
                Base.notifyError("Xflow: operator " + operator.name + ": Input of name '" + dataName +
                    "' not found. Used for parameter " + entry.source, dataNode);
                return false;
            }
            var dataEntry = channel.getDataEntry();

            if(!channel.creatorProcessNode){
                if(!entry.optional && (!dataEntry || dataEntry.isEmpty())){
                    Base.notifyError("Xflow: operator " + operator.name + ": Input for " + entry.source +
                        ' contains no data.', dataNode);
                    return false;
                }
            }
            if(dataEntry && dataEntry.type != entry.type){
                Base.notifyError("Xflow: operator " + operator.name + ": Input for " + entry.source +
                    " has wrong type. Expected: " + C.getTypeName(entry.type)
                    + ", but got: " +  C.getTypeName(dataEntry.type), dataNode);
                return false;
            }
        }
    }
    return true;
}

function synchronizeChildrenAndDescendants(children, descendants, inputChannels){
    var channel;
    for(var name in inputChannels){
        channel = inputChannels[name];
        if(channel && channel.creatorProcessNode){
            utils.set.add(children, channel.creatorProcessNode);
            utils.set.add(descendants, channel.creatorProcessNode.descendants);
        }
    }
    utils.set.remove(children, descendants);
    utils.set.add(descendants, children);
}

function synchronizeOutput(operator, outputs){
    var async = Operator.isOperatorAsync(operator);
    for(var i in operator.outputs){
        var dataEntry = operator.outputs[i];

        var entry, asyncEntry;
        var type = dataEntry.type;
        if(type != C.DATA_TYPE.TEXTURE){
            entry = new BufferEntry(type, null);
            if(async) asyncEntry = new BufferEntry(type, null);
        }
        else{
            entry = window.document ? new TextureEntry(null) : new ImageDataTextureEntry(null);
            if(async) asyncEntry = window.document ? new TextureEntry(null) : new ImageDataTextureEntry(null);
        }
        outputs[dataEntry.name] = new DataSlot(entry, 0);
        if(async) outputs[dataEntry.name].asyncDataEntry = asyncEntry;
    }
}

function getOrCreateExecuter(node, platform){
    if(!node.executers[platform]){
        node.executers[platform] = new Executor(node, platform);
    }
    return node.executers[platform];
}


//----------------------------------------------------------------------------------------------------------------------
// RequestNode
//----------------------------------------------------------------------------------------------------------------------
/**
 *
 * FIXME: RequestNodes are never deleted.
 * @param {ChannelNode} channelNode
 * @param {Array.<string>} filter
 * @constructor
 */
var RequestNode = function(channelNode, filter){
    this.owner = channelNode;
    this.filter = filter;

    /**
     *
     * @type {Object<C.PLATFORM, exports.Result>}
     */
    this.results = {};

    /**
     * @type {exports.C.PROCESS_STATE}
     */
    this.status = C.PROCESS_STATE.MODIFIED;

    /**
     * @type {Object.<string, Channel>}
     */
    this.channels = {};

    /**
     * @see ProcessNode.children
     * @type {Array}
     */
    this.children = [];

    /**
     * @see ProcessNode.executers
     * @type {Array}
     */
    this.executers = [];

    /**
     * @see ProcessNode.outOfSync
     * @type {boolean}
     */
    this.outOfSync = true;
};

RequestNode.prototype.synchronize = function(){
    if(this.outOfSync){
        this.outOfSync = false;
        synchronizeRequestChannels(this, this.owner);
        synchronizeChildrenAndDescendants(this.children, [], this.channels);
    }
};

RequestNode.prototype.updateState = function(){
    this.synchronize();
    if(this.status == C.PROCESS_STATE.MODIFIED){
        this.status = C.PROCESS_STATE.UNPROCESSED;

        if(this.owner.loading) {
            this.status = C.PROCESS_STATE.LOADING;
        } else {
            for(var i = 0; i < this.children.length; ++i){
                this.status = Math.min(this.status, this.children[i].updateState());
            }
        }
    }
    return this.status;
};

RequestNode.prototype.getResult = function(resultType){
    this.updateState();

    // TODO: This could be in getRequestComputeResult
    if(this.status == C.PROCESS_STATE.UNPROCESSED){
        if(resultType == C.RESULT_TYPE.COMPUTE){
            var executer = getOrCreateExecuter(this, this.owner.platform);
            if(!executer.isProcessed())
                executer.run();
        }
        this.status = C.PROCESS_STATE.PROCESSED;
    }
    var result = null;
    if (resultType == C.RESULT_TYPE.COMPUTE) {
        result = getRequestComputeResult(this);
    } else if (resultType == C.RESULT_TYPE.VS) {
        result = getRequestVSResult(this);
    }
    result.loading = (this.status == C.PROCESS_STATE.LOADING);
    return result;
};

RequestNode.prototype.setStructureOutOfSync = function(){
    this.outOfSync = true;
    this.status = C.PROCESS_STATE.MODIFIED;
    for(var type in this.results){
        this.results[type]._notifyChanged(C.RESULT_STATE.CHANGED_STRUCTURE);
    }
    for(var name in this.channels){
        this.channels[name].removeListener(this);
    }
    this.channels = [];
    this.children = [];
    this.executers = [];
};

RequestNode.prototype.onXflowChannelChange = function(channel, state){
    if(channel.creatorProcessNode)
        this.status = C.PROCESS_STATE.MODIFIED;
    var notifyState = (state == C.DATA_ENTRY_STATE.CHANGED_VALUE ? C.RESULT_STATE.CHANGED_DATA_VALUE
            : C.RESULT_STATE.CHANGED_DATA_SIZE);

    for(var type in this.results){
        this.results[type]._notifyChanged(notifyState);
    }
};

RequestNode.prototype.clear = function() {
    this.setStructureOutOfSync();
    delete this.owner;
};

/**
 *
 * @param requestNode
 * @param channelNode
 */
function synchronizeRequestChannels(requestNode, channelNode){
    var names = requestNode.filter;
    if(!names){
        names = channelNode.outputChannels.getNames();
    }

    for(var i = 0; i < names.length; ++i){
        var name = names[i];
        var channel = channelNode.outputChannels.getChannel(name);
        if(channel){
            requestNode.channels[name] = channel;
            channel.addListener(requestNode);
        }
    }
}

/**
 *
 * @param {RequestNode} requestNode
 * @returns {Result}
 */
function getRequestComputeResult(requestNode)
{
    if(!requestNode.results[C.RESULT_TYPE.COMPUTE])
        requestNode.results[C.RESULT_TYPE.COMPUTE] = new Result.ComputeResult();

    var result = requestNode.results[C.RESULT_TYPE.COMPUTE];
    result._dataEntries = {}; result._outputNames = [];

    for(var name in requestNode.channels){
        var entry = requestNode.channels[name].getDataEntry();
        result._dataEntries[name] = entry && !entry.isEmpty() ? entry : null;
        result._outputNames.push(name);
    }
    return result;
}

/**
 *
 * @param requestNode
 * @returns {exports.VSDataResult}
 */
function getRequestVSResult(requestNode)
{
    var executer = getOrCreateExecuter(requestNode, C.PLATFORM.GLSL);
    if(!requestNode.results[C.RESULT_TYPE.VS])
        requestNode.results[C.RESULT_TYPE.VS] = new Result.VSDataResult();
    var result = requestNode.results[C.RESULT_TYPE.VS];

    var program = executer.getVertexShader();
    result._program = program;
    result._programData = executer.programData;
    return result;
}


module.exports = {
    RequestNode: RequestNode,
    ProcessNode: ProcessNode
};


},{"../base.js":186,"../interface/constants.js":187,"../interface/data.js":188,"../operator/operator.js":227,"../processing/data-slot.js":232,"../utils/utils.js":238,"./executor.js":233,"./result.js":236}],236:[function(require,module,exports){
var Base = require("../base.js");
require("../../utils/array.js");

var queueResultCallback = Base._queueResultCallback;

/**
 * Content of this file:
 * Result classes of an Xflow graph which are received through Requests.
 */

/**
 * Abstract Result structure containing a (processed) result of the Xflow graph.
 * @abstract
 */
var Result = function(){
    this.loading = false;
    /** Valid is false if an error occurred during the processing of the result */
    this.valid = false;
    this._listeners = [];
    this._requests = [];
};

/**
 * @param {function(Result, C.RESULT_STATE)} callback
 */
Result.prototype.addListener = function(callback){
    this._listeners.push(callback);
};

/**
 * @param {function(Result, C.RESULT_STATE)} callback
 */
Result.prototype.removeListener = function(callback){
    Array.erase(this._listeners, callback);
};

/**
 * @param {function(Result, C.RESULT_STATE)} callback
 */
Result.prototype._addRequest = function(request){
    this._requests.push(request);
};

/**
 * @param {function(Result, C.RESULT_STATE)} callback
 */
Result.prototype._removeRequest = function(request){
    Array.erase(this._requests, request);
};


Result.prototype._notifyChanged = function(state){
    this.valid = false;
    for(var i = 0; i < this._requests.length; ++i){
        this._requests[i]._onResultChanged(state);
    }
    queueResultCallback(this, state);
}

Result.prototype._onPostponedResultChanged = function(state){
    for(var i = 0; i < this._listeners.length; ++i){
        this._listeners[i](this, state);
    }
}



/**
 * ComputeResult contains a named map of typed values.
 * @constructor
 * @extends {Result}
 */
var ComputeResult = function(){
    Result.call(this);
    this._outputNames = [];
    /** @type {Object.<string,DataEntry>} */
    this._dataEntries = {};
};
Base.createClass(ComputeResult, Result);

Object.defineProperty(ComputeResult.prototype, "outputNames", {
    set: function(v){
        throw new Error("outputNames is readonly");
    },
    get: function(){ return this._outputNames; }
});

ComputeResult.prototype.getOutputData = function(name){
    return this._dataEntries[name];
};

/**
 * @returns {Object.<string,DataEntry>}
 */
ComputeResult.prototype.getOutputMap = function() {
    return this._dataEntries;
};



/**
 * VSDataResult is used to analyse the output of a VertexShader
 * Note that the VSDataResult is not used to generate the VertexShader directly.
 * For that, the VertexShader structure must be created from VertexShaderRequest
 * @constructor
 * @extends {Result}
 */
var VSDataResult = function(){
    Result.call(this);
    this._program = null;
    this._programData = null;
};
Base.createClass(VSDataResult, Result);

Object.defineProperty(VSDataResult.prototype, "outputNames", {
    set: function(v){
        throw new Error("shaderOutputNames is readonly");
    },
    get: function(){ return this._program.getOutputNames(); }
});

VSDataResult.prototype.isOutputUniform = function(name){
    return this._program.isOutputUniform(name);
}
VSDataResult.prototype.isOutputNull = function(name){
    return this._program.isOutputNull(name);
}
VSDataResult.prototype.getOutputType = function(name){
    return this._program.getOutputType(name);
}
VSDataResult.prototype.getVertexShader = function(vsConfig){
    return this._program.createVertexShader(this._programData, vsConfig);
}

module.exports = {
    ComputeResult:  ComputeResult,
    VSDataResult: VSDataResult
};

},{"../../utils/array.js":178,"../base.js":186}],237:[function(require,module,exports){
var Base = require("../base.js");
var C = require("./../interface/constants.js");

var initAnonymousOperator = require("../operator/operator.js").initAnonymousOperator;

var shaderConstant = {};
shaderConstant[C.SHADER_CONSTANT_KEY.OBJECT_ID] = "objectID";
shaderConstant[C.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM] = "screenTransform";
shaderConstant[C.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM_NORMAL] = "screenTransformNormal";
shaderConstant[C.SHADER_CONSTANT_KEY.VIEW_TRANSFORM] = "viewTransform";
shaderConstant[C.SHADER_CONSTANT_KEY.VIEW_TRANSFORM_NORMAL] = "viewTransformNormal";
shaderConstant[C.SHADER_CONSTANT_KEY.WORLD_TRANSFORM] = "worldTransform";
shaderConstant[C.SHADER_CONSTANT_KEY.WORLD_TRANSFORM_NORMAL] = "worldTransformNormal";

var setShaderConstant = function(type, name){
    shaderConstant[type] = name;
};


/**
 * The output configuration of a VertexShader generated by Xflow
 * @constructor
 */
var VSConfig = function(){
    this._attributes = {};
    this._blockedNames = [];
    this._addInput = {};
    this._addOutput = {};
    this._codeFragments = [];
    this._outputChanneling = {};
};

VSConfig.prototype.addAttribute = function(type, name, optional){
    if(this._attributes[name]){
        if(this._attributes[name].type != type)
            throw new Error("Tries to add two attributes with different types of name '" + name + '"');
        this._attributes[name].optional = this._attributes[name].optional && optional;
        return;
    }
    this._attributes[name] = {type: type, optional: optional, channeling: []};
};

VSConfig.prototype.channelAttribute = function(inputName, outputName, code){
    this._attributes[inputName].channeling.push( { outputName : outputName, code : code });
};

VSConfig.prototype.addInputParameter = function(type, name, uniform){
    if(this._addInput[name])
        return;
    this._addInput[name] = { type: type, uniform: uniform };
    this._blockedNames.push(name);
};
VSConfig.prototype.addOutputParameter = function(type, name){
    if(this._addOutput[name])
        return;
    this._addOutput[name] = { type: type };
    this._blockedNames.push(name);
};
VSConfig.prototype.addCodeFragment = function(codeFragment){
    this._codeFragments.push(codeFragment);
};

VSConfig.prototype.addBlockedName = function(name){
    this._blockedNames.push(name);
};

VSConfig.prototype.getBlockedNames = function(){
    return this._blockedNames;
};

VSConfig.prototype.getFilter = function(){
    return Object.keys(this._attributes);
};
VSConfig.prototype.getKey = function(){
    var key = "";
    for(var name in this._attributes){
        var attr = this._attributes[name];
        key += ";" + attr.type + "," + name + "," + attr.optional;
    }
    return key;
};

var c_vs_operator_cache = {};

VSConfig.prototype.getOperator = function(){
    var key = this.getKey();
    if(c_vs_operator_cache[key])
        return c_vs_operator_cache[key];

    var outputs = [], params = [], glslCode = "\t// VS Connector\n";
    var name = "VSConnect";
    for(var attributeName in this._attributes){
        var attr = this._attributes[attributeName];
        var type = C.getTypeName(attr.type);
        outputs.push( { type: type, name: attributeName} );
        params.push( { type: type, source: attributeName, optional: attr.optional} );
        name += "T" + type + "N" + attributeName + "O" + attr.optional + ".";
    }
    var operator = initAnonymousOperator(name,
    {
        outputs: outputs,
        params:  params,
        evaluate_glsl: glslCode
    });
    c_vs_operator_cache[key] = operator;
    return operator;
};

var VertexShader = function(programData){
    this._programData = programData;
    this._glslCode = null;
    this._inputNames = [];
    this._outputNames = [];
    this._inputInfo = {};
    this._outputInfo = {};
};

Object.defineProperty(VertexShader.prototype, "inputNames", {
    set: function(v){
        throw new Error("inputNames is readonly");
    },
    get: function(){ return this._inputNames; }
});

Object.defineProperty(VertexShader.prototype, "outputNames", {
    set: function(v){
        throw new Error("outputNames is readonly");
    },
    get: function(){ return this._outputNames; }
});

VertexShader.prototype.isInputUniform = function(name){
    return this._inputInfo[name].uniform;
};
VertexShader.prototype.getInputData = function(name){
    return this._programData.getDataEntry(this._inputInfo[name].index);
};

VertexShader.prototype.isOutputNull = function(name){
    return this._outputInfo[name].iteration == C.ITERATION_TYPE.NULL;
};
VertexShader.prototype.isOutputFragmentUniform = function(name){
    return this._outputInfo[name].iteration == C.ITERATION_TYPE.ONE;
};
VertexShader.prototype.getUniformOutputData = function(name){
    return this._programData.getDataEntry(this._outputInfo[name].index);
};
VertexShader.prototype.getOutputType = function(name){
    return this._outputInfo[name].type;
};
VertexShader.prototype.getOutputSourceName = function(name){
    return this._outputInfo[name].sourceName;
};
VertexShader.prototype.getGLSLCode = function(){
    return this._glslCode;
};

module.exports = {
    shaderConstant: shaderConstant,
    setShaderConstant: setShaderConstant,
    VSConfig: VSConfig,
    VertexShader: VertexShader
};

},{"../base.js":186,"../operator/operator.js":227,"./../interface/constants.js":187}],238:[function(require,module,exports){
var set = {};


set.add = function(setArray, setToAdd){
    if(Array.isArray(setToAdd)){
        for(var i = 0; i < setToAdd.length; ++i){
            if(setArray.indexOf(setToAdd[i]) == -1)
                setArray.push(setToAdd[i]);
        }
    }
    else{
        if(setArray.indexOf(setToAdd) == -1)
            setArray.push(setToAdd);
    }
}
set.remove = function(setArray, setToRemove){
    var idx;
    if(Array.isArray(setToRemove)){
        for(var i = 0; i < setToRemove.length; ++i){
            if( (idx = setArray.indexOf(setToRemove[i])) != -1)
                setArray.splice(idx,1);
        }
    }
    else{
        if( (idx = setArray.indexOf(setToRemove)) != -1)
            setArray.splice(idx,1);
    }
}

set.intersection = function(dest, setA, setB){
    var size = setA.length;
    for(var i = 0; i < size; ++i){
        if(setB.indexOf(setA[i]) != -1)
            dest.push(setA[i]);
    }
}

set.isIntersecting = function(setA, setB){
    var i = setA.length;
    while(i--){
        if(setB.indexOf(setA[i]) != -1)
            return true;
    }
    return false;
}

set.isSubset = function(smallerSet, largerSet){
    var i = smallerSet.length;
    while(i--){
        if(largerSet.indexOf(smallerSet[i]) == -1)
            return false;
    }
    return true;
}

/**
 * Nameset Utilities for Xflow
 */
var nameset = {};

nameset.add = function(nameSet, toAdd){
    if(!toAdd) return;
    if(typeof toAdd == "string"){
        if(nameSet.indexOf(toAdd) == -1)
            nameSet.push(toAdd);
    }
    else{
        for(var i = 0; i < toAdd.length; ++i){
            if(nameSet.indexOf(toAdd[i]) == -1)
                nameSet.push(toAdd[i]);
        }
    }
}

nameset.remove = function(nameSet, toRemove){
    if(!toRemove) return;
    if(typeof toRemove == "string"){
        var removeIdx = nameSet.indexOf(toRemove);
        if(removeIdx != -1)
            nameSet.splice(removeIdx, 1);
    }
    else{
        for(var i = 0; i < toRemove.length; ++i){
            var removeIdx = nameSet.indexOf(toRemove[i]);
            if(removeIdx != -1)
                nameSet.splice(removeIdx, 1);
        }
    }
}

nameset.intersection = function(nameSetA, nameSetB){
    var i = nameSetA.length;
    while(i--){
        if(nameSetB.indexOf(nameSetA[i]) == -1){
            nameSetA.splice(i,1);
        }
    }
}


var binarySearch = function(keys, key, maxIndex){
    var min = 0, max = maxIndex - 1;
    while(min <= max){
        var i = Math.floor((min + max) / 2);
        if(keys[i] == key){
            return i;
        }
        else if(keys[i] < key)
            min = i + 1;
        else
            max = i - 1;
    }
    return max;
}

module.exports = {
    set: set,
    nameset: nameset,
    binarySearch: binarySearch
}

},{}],239:[function(require,module,exports){

module.exports = require("./init.js");
},{"./init.js":68}]},{},[239]);
